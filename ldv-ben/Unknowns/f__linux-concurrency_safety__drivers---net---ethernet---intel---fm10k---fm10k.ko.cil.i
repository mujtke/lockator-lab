/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __le16;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u64 __le64;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
typedef int pao_T__;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39 
struct rw_semaphore;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwsem.h"
struct vm_area_struct;

#line 173 
struct inode;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_47 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_46 {
   struct __anonstruct_47 __anonCompField___anonunion_46_19 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_46 __anonCompField_ctl_table_header_20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_53 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_54 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_52 {
   struct __anonstruct_53 __anonCompField___anonunion_52_23 ;
   struct __anonstruct_54 __anonCompField___anonunion_52_24 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_52 __anonCompField_uprobe_task_25 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_55 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_55 mm_context_t;

#line 27 
struct address_space;

#line 28 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_56 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_58 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_62 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_61 {
   atomic_t _mapcount ;
   struct __anonstruct_62 __anonCompField___anonunion_61_28 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_60 {
   union __anonunion_61 __anonCompField___anonstruct_60_29 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_59 {
   unsigned long counters ;
   struct __anonstruct_60 __anonCompField___anonunion_59_30 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_57 {
   union __anonunion_58 __anonCompField___anonstruct_57_27 ;
   union __anonunion_59 __anonCompField___anonstruct_57_31 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_64 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_65 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_63 {
   struct list_head lru ;
   struct __anonstruct_64 __anonCompField___anonunion_63_33 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_65 __anonCompField___anonunion_63_34 ;
   pgtable_t pmd_huge_pte ;
};

#line 32 
struct kmem_cache;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_66 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_56 __anonCompField_page_26 ;
   struct __anonstruct_57 __anonCompField_page_32 ;
   union __anonunion_63 __anonCompField_page_35 ;
   union __anonunion_66 __anonCompField_page_36 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_67 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct vm_operations_struct;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_67 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct bio_vec;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_69 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_69 __anonCompField_iov_iter_37 ;
   unsigned long nr_segs ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 18 
struct pid;

#line 19 
struct cred;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct pipe_inode_info;

#line 56 
struct net;

#line 73 
struct fasync_struct;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_70 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_70 nodemask_t;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 33 
struct dentry;

#line 34 
struct user_namespace;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_162 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_162 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_163 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_163 kgid_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_164 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_164 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_166 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_167 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_169 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_171 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_170 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_171 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_172 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_173 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_165 {
   int _pad[28U] ;
   struct __anonstruct__kill_166 _kill ;
   struct __anonstruct__timer_167 _timer ;
   struct __anonstruct__rt_168 _rt ;
   struct __anonstruct__sigchld_169 _sigchld ;
   struct __anonstruct__sigfault_170 _sigfault ;
   struct __anonstruct__sigpoll_172 _sigpoll ;
   struct __anonstruct__sigsys_173 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_165 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_180 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_181 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_183 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_182 {
   struct keyring_index_key index_key ;
   struct __anonstruct_183 __anonCompField___anonunion_182_50 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_184 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_186 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_185 {
   union __anonunion_payload_186 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_180 __anonCompField_key_48 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_181 __anonCompField_key_49 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_182 __anonCompField_key_51 ;
   union __anonunion_type_data_184 type_data ;
   union __anonunion_185 __anonCompField_key_52 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
union __anonunion_187 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_187 __anonCompField_idr_layer_53 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 31 
struct kernfs_node;

#line 32 
struct kernfs_ops;

#line 33 
struct kernfs_open_file;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270 
struct kernfs_root;

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct uts_namespace;

#line 1173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 176 
struct iattr;

#line 177 
struct super_block;

#line 178 
struct file_system_type;

#line 179 
struct kernfs_open_node;

#line 180 
struct kernfs_iattrs;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_206 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_206 __anonCompField_kernfs_node_57 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 477 
struct kobject;

#line 478 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct bin_attribute;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 67 
struct path;

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dma_map_ops;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203 
struct of_device_id;

#line 203 
struct acpi_device_id;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 1283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct writeback_control;

#line 66 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_207 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_207 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_22366 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_212 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_213 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_22366 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_212 __anonCompField_nf_bridge_info_61 ;
   union __anonunion_213 __anonCompField_nf_bridge_info_62 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_216 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_215 {
   u64 v64 ;
   struct __anonstruct_216 __anonCompField___anonunion_215_63 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_215 __anonCompField_skb_mstamp_64 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_219 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_218 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_219 __anonCompField___anonstruct_218_65 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_217 {
   struct __anonstruct_218 __anonCompField___anonunion_217_66 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_221 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_220 {
   __wsum csum ;
   struct __anonstruct_221 __anonCompField___anonunion_220_68 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_222 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_223 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_224 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_217 __anonCompField_sk_buff_67 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_220 __anonCompField_sk_buff_69 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_222 __anonCompField_sk_buff_70 ;
   __u32 secmark ;
   union __anonunion_223 __anonCompField_sk_buff_71 ;
   union __anonunion_224 __anonCompField_sk_buff_72 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_226 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_226 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_227 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_227 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_228 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_228 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_229 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_229 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_230 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_230 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_231 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_231 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_232 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_232 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_233 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_233 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_234 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_235 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_234 ifr_ifrn ;
   union __anonunion_ifr_ifru_235 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_240 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_239 {
   struct __anonstruct_240 __anonCompField___anonunion_239_73 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_239 __anonCompField_lockref_74 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_242 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_241 {
   struct __anonstruct_242 __anonCompField___anonunion_241_75 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_241 __anonCompField_qstr_76 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_243 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_243 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_247 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_246 {
   struct __anonstruct_247 __anonCompField___anonunion_246_77 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_246 __anonCompField_radix_tree_node_78 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 62 
struct kstatfs;

#line 63 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_251 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_251 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_252 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_252 __anonCompField_kqid_80 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_255 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_256 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_257 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_255 __anonCompField_inode_81 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_256 __anonCompField_inode_82 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_257 __anonCompField_inode_83 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_258 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_258 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_260 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_259 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_260 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_259 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118 
struct proc_dir_entry;

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_291 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_291 possible_net_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_27932 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_27932 phy_interface_t;

#line 126 
enum ldv_27985 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_27985 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_29697 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_29698 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_304 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_305 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_306 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_304 adj_list ;
   struct __anonstruct_all_adj_list_305 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_29697 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_29698 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_306 __anonCompField_net_device_93 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_319 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_319 __anonCompField_pci_dev_94 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};

#line 1928  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/pps.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations const *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pps_kernel.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};

#line 83 
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_pin_desc {
   char name[64U] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5U] ;
};

#line 134 
enum ldv_32453 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
union __anonunion_320 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_clock_request {
   enum ldv_32453 type ;
   union __anonunion_320 __anonCompField_ptp_clock_request_95 ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int n_pins ;
   int pps ;
   struct ptp_pin_desc *pin_config ;
   int (*adjfreq)(struct ptp_clock_info *, s32 ) ;
   int (*adjtime)(struct ptp_clock_info *, s64 ) ;
   int (*gettime64)(struct ptp_clock_info *, struct timespec *) ;
   int (*settime64)(struct ptp_clock_info *, struct timespec const *) ;
   int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int ) ;
   int (*verify)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ) ;
};

#line 113 
struct ptp_clock;

#line 190 
struct fm10k_hw;

#line 191 
struct fm10k_mbx_info;

#line 192 
struct fm10k_msg_data;

#line 193 
enum fm10k_tlv_type {
    FM10K_TLV_NULL_STRING = 0,
    FM10K_TLV_MAC_ADDR = 1,
    FM10K_TLV_BOOL = 2,
    FM10K_TLV_UNSIGNED = 3,
    FM10K_TLV_SIGNED = 4,
    FM10K_TLV_LE_STRUCT = 5,
    FM10K_TLV_NESTED = 6,
    FM10K_TLV_MAX_TYPE = 7
};

#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct fm10k_tlv_attr {
   unsigned int id ;
   enum fm10k_tlv_type type ;
   u16 len ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.h"
struct fm10k_msg_data {
   unsigned int id ;
   struct fm10k_tlv_attr const *attr ;
   s32 (*func)(struct fm10k_hw *, u32 **, struct fm10k_mbx_info *) ;
};

#line 181 
enum fm10k_mbx_state {
    FM10K_STATE_CLOSED = 0,
    FM10K_STATE_CONNECT = 1,
    FM10K_STATE_OPEN = 2,
    FM10K_STATE_DISCONNECT = 3
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.h"
struct fm10k_mbx_ops {
   s32 (*connect)(struct fm10k_hw *, struct fm10k_mbx_info *) ;
   void (*disconnect)(struct fm10k_hw *, struct fm10k_mbx_info *) ;
   bool (*rx_ready)(struct fm10k_mbx_info *) ;
   bool (*tx_ready)(struct fm10k_mbx_info *, u16 ) ;
   bool (*tx_complete)(struct fm10k_mbx_info *) ;
   s32 (*enqueue_tx)(struct fm10k_hw *, struct fm10k_mbx_info *, u32 const *) ;
   s32 (*process)(struct fm10k_hw *, struct fm10k_mbx_info *) ;
   s32 (*register_handlers)(struct fm10k_mbx_info *, struct fm10k_msg_data const *) ;
};

#line 242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.h"
struct fm10k_mbx_fifo {
   u32 *buffer ;
   u16 head ;
   u16 tail ;
   u16 size ;
};

#line 250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.h"
struct fm10k_mbx_info {
   struct fm10k_mbx_ops ops ;
   struct fm10k_msg_data const *msg_data ;
   struct fm10k_mbx_fifo rx ;
   struct fm10k_mbx_fifo tx ;
   u32 timeout ;
   u32 udelay ;
   u32 mbx_reg ;
   u32 mbmem_reg ;
   u32 mbx_lock ;
   u32 mbx_hdr ;
   u16 max_size ;
   u16 mbmem_len ;
   u16 tail ;
   u16 tail_len ;
   u16 pulled ;
   u16 head ;
   u16 head_len ;
   u16 pushed ;
   u16 local ;
   u16 remote ;
   enum fm10k_mbx_state state ;
   s32 test_result ;
   u64 tx_busy ;
   u64 tx_dropped ;
   u64 tx_messages ;
   u64 tx_dwords ;
   u64 rx_messages ;
   u64 rx_dwords ;
   u64 rx_parse_err ;
   u32 buffer[640U] ;
};

#line 316 
enum fm10k_bus_speed {
    fm10k_bus_speed_unknown = 0,
    fm10k_bus_speed_2500 = 2500,
    fm10k_bus_speed_5000 = 5000,
    fm10k_bus_speed_8000 = 8000,
    fm10k_bus_speed_reserved = 8001
};

#line 324 
enum fm10k_bus_width {
    fm10k_bus_width_unknown = 0,
    fm10k_bus_width_pcie_x1 = 1,
    fm10k_bus_width_pcie_x2 = 2,
    fm10k_bus_width_pcie_x4 = 4,
    fm10k_bus_width_pcie_x8 = 8,
    fm10k_bus_width_reserved = 9
};

#line 333 
enum fm10k_bus_payload {
    fm10k_bus_payload_unknown = 0,
    fm10k_bus_payload_128 = 1,
    fm10k_bus_payload_256 = 2,
    fm10k_bus_payload_512 = 3,
    fm10k_bus_payload_reserved = 4
};

#line 341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.h"
struct fm10k_bus_info {
   enum fm10k_bus_speed speed ;
   enum fm10k_bus_width width ;
   enum fm10k_bus_payload payload ;
};

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_hw_stat {
   u64 count ;
   u32 base_l ;
   u32 base_h ;
};

#line 427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_hw_stats_q {
   struct fm10k_hw_stat tx_bytes ;
   struct fm10k_hw_stat tx_packets ;
   struct fm10k_hw_stat rx_bytes ;
   struct fm10k_hw_stat rx_packets ;
   struct fm10k_hw_stat rx_drops ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_hw_stats {
   struct fm10k_hw_stat timeout ;
   struct fm10k_hw_stat ur ;
   struct fm10k_hw_stat ca ;
   struct fm10k_hw_stat um ;
   struct fm10k_hw_stat xec ;
   struct fm10k_hw_stat vlan_drop ;
   struct fm10k_hw_stat loopback_drop ;
   struct fm10k_hw_stat nodesc_drop ;
   struct fm10k_hw_stats_q q[128U] ;
};

#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_dglort_cfg {
   u16 glort ;
   u16 queue_b ;
   u8 vsi_b ;
   u8 idx ;
   u8 rss_l ;
   u8 pc_l ;
   u8 vsi_l ;
   u8 queue_l ;
   u8 shared_l ;
   u8 inner_rss ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_fault {
   u64 address ;
   u32 specinfo ;
   u8 type ;
   u8 func ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_mac_ops {
   s32 (*reset_hw)(struct fm10k_hw *) ;
   s32 (*init_hw)(struct fm10k_hw *) ;
   s32 (*start_hw)(struct fm10k_hw *) ;
   s32 (*stop_hw)(struct fm10k_hw *) ;
   s32 (*get_bus_info)(struct fm10k_hw *) ;
   s32 (*get_host_state)(struct fm10k_hw *, bool *) ;
   bool (*is_slot_appropriate)(struct fm10k_hw *) ;
   s32 (*update_vlan)(struct fm10k_hw *, u32 , u8 , bool ) ;
   s32 (*read_mac_addr)(struct fm10k_hw *) ;
   s32 (*update_uc_addr)(struct fm10k_hw *, u16 , u8 const *, u16 , bool , u8 ) ;
   s32 (*update_mc_addr)(struct fm10k_hw *, u16 , u8 const *, u16 , bool ) ;
   s32 (*update_xcast_mode)(struct fm10k_hw *, u16 , u8 ) ;
   void (*update_int_moderator)(struct fm10k_hw *) ;
   s32 (*update_lport_state)(struct fm10k_hw *, u16 , u16 , bool ) ;
   void (*update_hw_stats)(struct fm10k_hw *, struct fm10k_hw_stats *) ;
   void (*rebind_hw_stats)(struct fm10k_hw *, struct fm10k_hw_stats *) ;
   s32 (*configure_dglort_map)(struct fm10k_hw *, struct fm10k_dglort_cfg *) ;
   void (*set_dma_mask)(struct fm10k_hw *, u64 ) ;
   s32 (*get_fault)(struct fm10k_hw *, int , struct fm10k_fault *) ;
   void (*request_lport_map)(struct fm10k_hw *) ;
   s32 (*adjust_systime)(struct fm10k_hw *, s32 ) ;
   u64 (*read_systime)(struct fm10k_hw *) ;
};

#line 543 
enum fm10k_mac_type {
    fm10k_mac_unknown = 0,
    fm10k_mac_pf = 1,
    fm10k_mac_vf = 2,
    fm10k_num_macs = 3
};

#line 550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_mac_info {
   struct fm10k_mac_ops ops ;
   enum fm10k_mac_type type ;
   u8 addr[6U] ;
   u8 perm_addr[6U] ;
   u16 default_vid ;
   u16 max_msix_vectors ;
   u16 max_queues ;
   bool vlan_override ;
   bool get_host_state ;
   bool tx_ready ;
   u32 dglort_map ;
};

#line 564  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_swapi_table_info {
   u32 used ;
   u32 avail ;
};

#line 569  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_swapi_info {
   u32 status ;
   struct fm10k_swapi_table_info mac ;
   struct fm10k_swapi_table_info nexthop ;
   struct fm10k_swapi_table_info ffu ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_vf_info {
   struct fm10k_mbx_info mbx ;
   int rate ;
   u16 glort ;
   u16 sw_vid ;
   u16 pf_vid ;
   u8 mac[6U] ;
   u8 vsi ;
   u8 vf_idx ;
   u8 vf_flags ;
};

#line 603  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_iov_ops {
   s32 (*assign_resources)(struct fm10k_hw *, u16 , u16 ) ;
   s32 (*configure_tc)(struct fm10k_hw *, u16 , int ) ;
   s32 (*assign_int_moderator)(struct fm10k_hw *, u16 ) ;
   s32 (*assign_default_mac_vlan)(struct fm10k_hw *, struct fm10k_vf_info *) ;
   s32 (*reset_resources)(struct fm10k_hw *, struct fm10k_vf_info *) ;
   s32 (*set_lport)(struct fm10k_hw *, struct fm10k_vf_info *, u16 , u8 ) ;
   void (*reset_lport)(struct fm10k_hw *, struct fm10k_vf_info *) ;
   void (*update_stats)(struct fm10k_hw *, struct fm10k_hw_stats_q *, u16 ) ;
   s32 (*report_timestamp)(struct fm10k_hw *, struct fm10k_vf_info *, u64 ) ;
};

#line 634  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_iov_info {
   struct fm10k_iov_ops ops ;
   u16 total_vfs ;
   u16 num_vfs ;
   u16 num_pools ;
};

#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_hw {
   u32 *hw_addr ;
   u32 *sw_addr ;
   void *back ;
   struct fm10k_mac_info mac ;
   struct fm10k_bus_info bus ;
   struct fm10k_bus_info bus_caps ;
   struct fm10k_iov_info iov ;
   struct fm10k_mbx_info mbx ;
   struct fm10k_swapi_info swapi ;
   u16 device_id ;
   u16 vendor_id ;
   u16 subsystem_device_id ;
   u16 subsystem_vendor_id ;
   u8 revision_id ;
};

#line 670  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_tx_desc {
   __le64 buffer_addr ;
   __le16 buflen ;
   __le16 vlan ;
   __le16 mss ;
   u8 hdrlen ;
   u8 flags ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.h"
struct fm10k_l2_accel {
   int size ;
   u16 count ;
   u16 dglort ;
   struct callback_head rcu ;
   struct net_device *macvlan[0U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_tx_buffer {
   struct fm10k_tx_desc *next_to_watch ;
   struct sk_buff *skb ;
   unsigned int bytecount ;
   u16 gso_segs ;
   u16 tx_flags ;
   dma_addr_t dma ;
   __u32 len ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_rx_buffer {
   dma_addr_t dma ;
   struct page *page ;
   u32 page_offset ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_queue_stats {
   u64 packets ;
   u64 bytes ;
};

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_tx_queue_stats {
   u64 restart_queue ;
   u64 csum_err ;
   u64 tx_busy ;
   u64 tx_done_old ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_rx_queue_stats {
   u64 alloc_failed ;
   u64 csum_err ;
   u64 errors ;
};

#line 111 
struct fm10k_q_vector;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
union __anonunion_325 {
   struct fm10k_tx_buffer *tx_buffer ;
   struct fm10k_rx_buffer *rx_buffer ;
};

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct __anonstruct_327 {
   struct fm10k_rx_queue_stats rx_stats ;
   struct sk_buff *skb ;
};

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
union __anonunion_326 {
   struct fm10k_tx_queue_stats tx_stats ;
   struct __anonstruct_327 __anonCompField___anonunion_326_98 ;
};

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_ring {
   struct fm10k_q_vector *q_vector ;
   struct net_device *netdev ;
   struct device *dev ;
   struct fm10k_l2_accel *l2_accel ;
   void *desc ;
   union __anonunion_325 __anonCompField_fm10k_ring_97 ;
   u32 *tail ;
   unsigned long state ;
   dma_addr_t dma ;
   unsigned int size ;
   u8 queue_index ;
   u8 reg_idx ;
   u8 qos_pc ;
   u16 vid ;
   u16 count ;
   u16 next_to_alloc ;
   u16 next_to_use ;
   u16 next_to_clean ;
   struct fm10k_queue_stats stats ;
   struct u64_stats_sync syncp ;
   union __anonunion_326 __anonCompField_fm10k_ring_99 ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_ring_container {
   struct fm10k_ring *ring ;
   unsigned int total_bytes ;
   unsigned int total_packets ;
   u16 work_limit ;
   u16 itr ;
   u8 count ;
};

#line 179 
struct fm10k_intfc;

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_q_vector {
   struct fm10k_intfc *interface ;
   u32 *itr ;
   u16 v_idx ;
   struct fm10k_ring_container rx ;
   struct fm10k_ring_container tx ;
   struct napi_struct napi ;
   char name[25U] ;
   struct dentry *dbg_q_vector ;
   struct callback_head rcu ;
   struct fm10k_ring ring[0U] ;
};

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_ring_feature {
   u16 limit ;
   u16 indices ;
   u16 mask ;
   u16 offset ;
};

#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_iov_data {
   unsigned int num_vfs ;
   unsigned int next_vf_mbx ;
   struct callback_head rcu ;
   struct fm10k_vf_info vf_info[0U] ;
};

#line 240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_intfc {
   unsigned long active_vlans[64U] ;
   struct net_device *netdev ;
   struct fm10k_l2_accel *l2_accel ;
   struct pci_dev *pdev ;
   unsigned long state ;
   u32 flags ;
   int xcast_mode ;
   int num_tx_queues ;
   u16 tx_itr ;
   int num_rx_queues ;
   u16 rx_itr ;
   struct fm10k_ring *tx_ring[128U] ;
   u64 restart_queue ;
   u64 tx_busy ;
   u64 tx_csum_errors ;
   u64 alloc_failed ;
   u64 rx_csum_errors ;
   u64 tx_bytes_nic ;
   u64 tx_packets_nic ;
   u64 rx_bytes_nic ;
   u64 rx_packets_nic ;
   u64 rx_drops_nic ;
   u64 rx_overrun_pf ;
   u64 rx_overrun_vf ;
   u32 tx_timeout_count ;
   struct fm10k_ring *rx_ring[128U] ;
   struct fm10k_q_vector *q_vector[256U] ;
   struct msix_entry *msix_entries ;
   int num_q_vectors ;
   struct fm10k_ring_feature ring_feature[2U] ;
   struct fm10k_iov_data *iov_data ;
   struct fm10k_hw_stats stats ;
   struct fm10k_hw hw ;
   u32 *uc_addr ;
   u32 *sw_addr ;
   u16 msg_enable ;
   u16 tx_ring_count ;
   u16 rx_ring_count ;
   struct timer_list service_timer ;
   struct work_struct service_task ;
   unsigned long next_stats_update ;
   unsigned long next_tx_hang_check ;
   unsigned long last_reset ;
   unsigned long link_down_event ;
   bool host_ready ;
   u32 reta[32U] ;
   u32 rssrk[10U] ;
   struct list_head vxlan_port ;
   struct dentry *dbg_intfc ;
   struct ptp_clock_info ptp_caps ;
   struct ptp_clock *ptp_clock ;
   struct sk_buff_head ts_tx_skb_queue ;
   u32 tx_hwtstamp_timeouts ;
   struct hwtstamp_config ts_config ;
   s64 ptp_adjust ;
   rwlock_t systime_lock ;
   u8 pfc_en ;
   u8 rx_pause ;
   u16 glort ;
   u16 glort_count ;
   u16 vid ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct __anonstruct_q_969 {
   __le64 pkt_addr ;
   __le64 hdr_addr ;
   __le64 reserved ;
   __le64 timestamp ;
};

#line 689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct __anonstruct_d_970 {
   __le32 data ;
   __le32 rss ;
   __le32 staterr ;
   __le32 vlan_len ;
   __le32 glort ;
};

#line 689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct __anonstruct_w_971 {
   __le16 pkt_info ;
   __le16 hdr_info ;
   __le16 rss_lower ;
   __le16 rss_upper ;
   __le16 status ;
   __le16 csum_err ;
   __le16 length ;
   __le16 vlan ;
   __le16 dglort ;
   __le16 sglort ;
};

#line 689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
union fm10k_rx_desc {
   struct __anonstruct_q_969 q ;
   struct __anonstruct_d_970 d ;
   struct __anonstruct_w_971 w ;
};

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11722 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param;

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_1149 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_1149 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/xfrm.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 646  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_type.h"
struct fm10k_info {
   enum fm10k_mac_type mac ;
   s32 (*get_invariants)(struct fm10k_hw *) ;
   struct fm10k_mac_ops *mac_ops ;
   struct fm10k_iov_ops *iov_ops ;
};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.h"
struct fm10k_swapi_1588_timestamp {
   __le64 egress ;
   __le64 ingress ;
   __le16 dglort ;
   __le16 sglort ;
};

#line 536  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_stats {
   char stat_string[32U] ;
   int sizeof_stat ;
   int stat_offset ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/fcntl.h"
enum ldv_12038 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_12038 socket_state;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct;

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_page_1871 {
   struct page *p ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_1871 page ;
   __u32 page_offset ;
   __u32 size ;
};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};

#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct xfrm_policy;

#line 98 
struct xfrm_state;

#line 114 
struct request_sock;

#line 2893  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_vxlan_port {
   struct list_head list ;
   sa_family_t sa_family ;
   __be16 port ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/cacheflush.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) dst_reg : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
};

#line 273 
struct bpf_prog_aux;

#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
union __anonunion_1995 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff const *, struct bpf_insn const *) ;
   union __anonunion_1995 __anonCompField_bpf_prog_105 ;
};

#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   int maxtype ;
   struct nla_policy const *policy ;
   int (*validate)(struct nlattr **, struct nlattr **) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device const *) ;
   int (*fill_info)(struct sk_buff *, struct net_device const *) ;
   size_t (*get_xstats_size)(struct net_device const *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device const *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy const *slave_policy ;
   int (*slave_validate)(struct nlattr **, struct nlattr **) ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **) ;
   size_t (*get_slave_size)(struct net_device const *, struct net_device const *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device const *, struct net_device const *) ;
   struct net *(*get_link_net)(struct net_device const *) ;
};

#line 171 
struct neigh_table;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   void (*neigh_cleanup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};

#line 129 
struct neigh_ops;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops const *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const *, struct net_device const *, __u32 *) ;
   bool (*key_eq)(struct neighbour const *, void const *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};

#line 519 
struct dn_route;

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
union __anonunion_2003 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_2003 __anonCompField_dst_entry_106 ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_socket_lock_t_2004 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_2004 socket_lock_t;

#line 124 
struct proto;

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u32 __portpair;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u64 __addrpair;

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_2006 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_2005 {
   __addrpair skc_addrpair ;
   struct __anonstruct_2006 __anonCompField___anonunion_2005_107 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_2007 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_2009 {
   __be16 skc_dport ;
   __u16 skc_num ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_2008 {
   __portpair skc_portpair ;
   struct __anonstruct_2009 __anonCompField___anonunion_2008_110 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_2010 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_2011 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock_common {
   union __anonunion_2005 __anonCompField_sock_common_108 ;
   union __anonunion_2007 __anonCompField_sock_common_109 ;
   union __anonunion_2008 __anonCompField_sock_common_111 ;
   unsigned short skc_family ;
   unsigned char volatile skc_state ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) skc_reuse : 4 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_reuseport : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_ipv6only : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_2010 __anonCompField_sock_common_112 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_2011 __anonCompField_sock_common_113 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};

#line 219 
struct cg_proto;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_sk_backlog_2012 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_2012 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) sk_shutdown : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_tx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_rx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) sk_userlocks : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) sk_protocol : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred const *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
};

#line 914 
struct request_sock_ops;

#line 915 
struct timewait_sock_ops;

#line 917 
struct raw_hashinfo;

#line 932 
struct udp_table;

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_h_2015 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   void (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   void (*clear_sk)(struct sock *, int ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock const *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_2015 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup *, struct cgroup_subsys *) ;
   void (*destroy_cgroup)(struct mem_cgroup *) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup *) ;
};

#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock const *) ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cookie_ts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops const *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};

#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __sum16;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[6U] ;
   unsigned long nr_free ;
};

#line 96 
struct pglist_data;

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct zone_padding {
   char x[0U] ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2U] ;
   unsigned long recent_scanned[2U] ;
};

#line 215 
struct zone;

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5U] ;
   struct zone_reclaim_stat reclaim_stat ;
   struct zone *zone ;
};

#line 247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3U] ;
};

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   s8 stat_threshold ;
   s8 vm_stat_diff[39U] ;
};

#line 270 
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
};

#line 278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct zone {
   unsigned long watermark[3U] ;
   long lowmem_reserve[4U] ;
   int node ;
   unsigned int inactive_ratio ;
   struct pglist_data *zone_pgdat ;
   struct per_cpu_pageset *pageset ;
   unsigned long dirty_balance_reserve ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   unsigned long zone_start_pfn ;
   unsigned long managed_pages ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const *name ;
   int nr_migrate_reserve_block ;
   unsigned long nr_isolate_pageblock ;
   seqlock_t span_seqlock ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct zone_padding _pad1_ ;
   struct free_area free_area[11U] ;
   unsigned long flags ;
   spinlock_t lock ;
   struct zone_padding _pad2_ ;
   spinlock_t lru_lock ;
   struct lruvec lruvec ;
   atomic_long_t inactive_age ;
   unsigned long percpu_drift_mark ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn[2U] ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   bool compact_blockskip_flush ;
   struct zone_padding _pad3_ ;
   atomic_long_t vm_stat[39U] ;
};

#line 567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct zonelist_cache {
   unsigned short z_to_n[4096U] ;
   unsigned long fullzones[64U] ;
   unsigned long last_full_zap ;
};

#line 654  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};

#line 667  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[4097U] ;
   struct zonelist_cache zlcache ;
};

#line 705  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4U] ;
   struct zonelist node_zonelists[2U] ;
   int nr_zones ;
   spinlock_t node_size_lock ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
   enum zone_type classzone_idx ;
   spinlock_t numabalancing_migrate_lock ;
   unsigned long numabalancing_migrate_next_window ;
   unsigned long numabalancing_migrate_nr_pages ;
   unsigned long first_deferred_pfn ;
};

#line 773  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) priority : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};

#line 890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};

#line 321  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
enum macvlan_mode {
    MACVLAN_MODE_PRIVATE = 1,
    MACVLAN_MODE_VEPA = 2,
    MACVLAN_MODE_BRIDGE = 4,
    MACVLAN_MODE_PASSTHRU = 8,
    MACVLAN_MODE_SOURCE = 16
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) res1 : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) doff : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) fin : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syn : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rst : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) psh : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ack : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) urg : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ece : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};

#line 410  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
struct udphdr {
   __be16 source ;
   __be16 dest ;
   __be16 len ;
   __sum16 check ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
struct iphdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ihl : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
union __anonunion_3037 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
struct inetpeer_addr_base {
   union __anonunion_3037 __anonCompField_inetpeer_addr_base_109 ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_3038 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct __anonstruct_3040 {
   atomic_t rid ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_3039 {
   struct __anonstruct_3040 __anonCompField___anonunion_3039_111 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_3038 __anonCompField_inet_peer_110 ;
   union __anonunion_3039 __anonCompField_inet_peer_112 ;
   __u32 dtime ;
   atomic_t refcnt ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct uncached_list;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cryptohash.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   struct hlist_nulls_head head ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_listen_hashbucket listening_hash[32U] ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
struct vlan_pcpu_stats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 rx_multicast ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
   u32 rx_errors ;
   u32 tx_dropped ;
};

#line 126 
struct netpoll;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_macvlan.h"
struct macvlan_port;

#line 15 
struct macvtap_queue;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_macvlan.h"
struct macvlan_dev {
   struct net_device *dev ;
   struct list_head list ;
   struct hlist_node hlist ;
   struct macvlan_port *port ;
   struct net_device *lowerdev ;
   void *fwd_priv ;
   struct vlan_pcpu_stats *pcpu_stats ;
   unsigned long mc_filter[4U] ;
   netdev_features_t set_features ;
   enum macvlan_mode mode ;
   u16 flags ;
   struct macvtap_queue *taps[256U] ;
   struct list_head queue_list ;
   int numvtaps ;
   int numqueues ;
   netdev_features_t tap_features ;
   int minor ;
   int nest_level ;
   struct netpoll *netpoll ;
   unsigned int macaddr_count ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct __anonstruct_d_3061 {
   __le32 glort ;
   __le32 vlan ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct __anonstruct_w_3062 {
   __le16 dglort ;
   __le16 sglort ;
   __le16 vlan ;
   __le16 swpri_type_user ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
union fm10k_ftag_info {
   __le64 ftag ;
   struct __anonstruct_d_3061 d ;
   struct __anonstruct_w_3062 w ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
union __anonunion_3063 {
   __le64 tstamp ;
   unsigned long ts_tx_timeout ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct fm10k_cb {
   union __anonunion_3063 __anonCompField_fm10k_cb_122 ;
   union fm10k_ftag_info fi ;
};

#line 445  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
union __anonunion___u_3065 {
   struct fm10k_l2_accel *__val ;
   char __c[1U] ;
};

#line 669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
struct fm10k_nvgre_hdr {
   __be16 flags ;
   __be16 proto ;
   __be32 tni ;
};

#line 822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
union __anonunion_network_hdr_3067 {
   struct iphdr *ipv4 ;
   struct ipv6hdr *ipv6 ;
   u8 *raw ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.h"
struct fm10k_mac_update {
   __le32 mac_lower ;
   __le16 mac_upper ;
   __le16 vlan ;
   __le16 glort ;
   u8 flags ;
   u8 action ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.h"
struct fm10k_global_table_data {
   __le32 used ;
   __le32 avail ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.h"
struct fm10k_swapi_error {
   __le32 status ;
   struct fm10k_global_table_data mac ;
   struct fm10k_global_table_data nexthop ;
   struct fm10k_global_table_data ffu ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
enum tk_offsets {
    TK_OFFS_REAL = 0,
    TK_OFFS_BOOT = 1,
    TK_OFFS_TAI = 2,
    TK_OFFS_MAX = 3
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct ldv_struct_character_driver_scenario_15 {
   struct file_operations *arg0 ;
   int signal_pending ;
};

#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_free_irq_6 {
   int arg0 ;
   int signal_pending ;
};

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_16 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 36  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_18 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_random_allocationless_scenario_20 {
   struct net_device *arg0 ;
   int signal_pending ;
};

#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_timer_scenario_19 {
   struct timer_list *arg0 ;
   int signal_pending ;
};

#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_traverse_kernel_items_scenario_22 {
   struct seq_operations *arg1 ;
   struct seq_file *arg0 ;
   int signal_pending ;
};

#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/fvtp/.tmp_fm10k_iov.c"
void ldv_inline_asm(void);


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr, unsigned long volatile *addr)
{
  
#line 112 
  if (0 != 0) 
#line 114 
              ldv_inline_asm(); else 
#line 117 
                                     ldv_inline_asm();
  
#line 118 
  return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int fls(int x)
{
  int __retres;
  int r;
  
#line 440 
  ldv_inline_asm();
  
#line 464 
  __retres = r + 1;
  
#line 464 
  return __retres;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val)
{
  int tmp;
  
#line 72 
  if (0 != 0 && (val == 1 || val == -1)) 
#line 72 
                                         tmp = val; else 
#line 72 
                                                         tmp = 0;
  
#line 72 
  int const pao_ID__ = tmp;
  
#line 72 
  switch (4UL) {
    case (unsigned long)1: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)2: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)4: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)8: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    default: 
#line 72 
    ;
    
#line 72 
    __bad_percpu_size();
  }
  ldv_6377: 
#line 72 
  ;
  
#line 74 
  return;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val)
{
  int tmp;
  
#line 77 
  if (0 != 0 && (- val == 1 || - val == -1)) 
#line 77 
                                             tmp = - val; else 
#line 77 
                                                               tmp = 0;
  
#line 77 
  int const pao_ID__ = tmp;
  
#line 77 
  switch (4UL) {
    case (unsigned long)1: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)2: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)4: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)8: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    default: 
#line 77 
    ;
    
#line 77 
    __bad_percpu_size();
  }
  ldv_6389: 
#line 77 
  ;
  
#line 79 
  return;
}


#line 333  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lock_acquire(struct lockdep_map *, unsigned int, int, int, int, struct lockdep_map *, unsigned long);


#line 337 
void lock_release(struct lockdep_map *, int, unsigned long);


#line 545 
void lockdep_rcu_suspicious(char const *, int const, char const *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void)
{
  
#line 270 
  __preempt_count_add(1);
  
#line 271 
  ldv_inline_asm();
  
#line 272 
  return;
}


#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void)
{
  
#line 275 
  ldv_inline_asm();
  
#line 275 
  __preempt_count_sub(1);
  
#line 276 
  return;
}


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcutree.h"
void kfree_call_rcu(struct callback_head *, void (*)(struct callback_head *));


#line 104 
bool rcu_is_watching(void);


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map)
{
  __here_0: 
#line 449 
  ;
  
#line 449 
  ;
  
#line 449 
  lock_acquire(map,0U,0,2,0,(struct lockdep_map *)0,(unsigned long)((void *)0));
  
#line 451 
  return;
}


#line 452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map)
{
  __here_0: 
#line 454 
  ;
  
#line 454 
  ;
  
#line 454 
  lock_release(map,1,(unsigned long)((void *)0));
  
#line 456 
  return;
}


#line 457 
extern struct lockdep_map rcu_lock_map;


#line 461 
int debug_lockdep_rcu_enabled(void);


#line 843  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_read_lock(void)
{
  
#line 845 
  __rcu_read_lock();
  
#line 847 
  rcu_lock_acquire(& rcu_lock_map);
  {
    bool __warned;
    int tmp;
    
#line 848 
    tmp = debug_lockdep_rcu_enabled();
    
#line 848 
    if (tmp != 0) {
      
#line 848 
      if (! __warned) {
        int tmp_1;
        bool tmp_0;
        
#line 848 
        tmp_0 = rcu_is_watching();
        
#line 848 
        if (tmp_0) 
#line 848 
                   tmp_1 = 0; else 
#line 848 
                                   tmp_1 = 1;
        
#line 848 
        if (tmp_1) {
          
#line 848 
          __warned = (_Bool)1;
          
#line 848 
          lockdep_rcu_suspicious("include/linux/rcupdate.h",849,"rcu_read_lock() used illegally while idle");
        }
        else ;
      }
      else ;
    }
    else ;
  }
  
#line 851 
  return;
}


#line 897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void)
{
  {
    bool __warned;
    int tmp;
    
#line 899 
    tmp = debug_lockdep_rcu_enabled();
    
#line 899 
    if (tmp != 0) {
      
#line 899 
      if (! __warned) {
        int tmp_1;
        bool tmp_0;
        
#line 899 
        tmp_0 = rcu_is_watching();
        
#line 899 
        if (tmp_0) 
#line 899 
                   tmp_1 = 0; else 
#line 899 
                                   tmp_1 = 1;
        
#line 899 
        if (tmp_1) {
          
#line 899 
          __warned = (_Bool)1;
          
#line 899 
          lockdep_rcu_suspicious("include/linux/rcupdate.h",900,"rcu_read_unlock() used illegally while idle");
        }
        else ;
      }
      else ;
    }
    else ;
  }
  
#line 902 
  __rcu_read_unlock();
  
#line 903 
  rcu_lock_release(& rcu_lock_map);
  
#line 904 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void volatile *addr)
{
  
#line 68 
  ldv_inline_asm();
  
#line 69 
  return;
}


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 1083 
void dev_err(struct device const *, char const * , ...);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device const *dev)
{
  void *__retres;
  
#line 1882 
  __retres = (void *)dev + 3008U;
  
#line 1882 
  return __retres;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 96 
  __retres = (_Bool)((*((u32 const *)addr) | (unsigned int)*((u16 const *)(addr + 4U))) == 0U);
  
#line 96 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_3;
  int tmp_0;
  bool tmp;
  
#line 190 
  tmp = is_multicast_ether_addr(addr);
  
#line 190 
  if (tmp) 
#line 190 
           tmp_0 = 0; else 
#line 190 
                           tmp_0 = 1;
  
#line 190 
  if (tmp_0) {
    int tmp_2;
    bool tmp_1;
    
#line 190 
    tmp_1 = is_zero_ether_addr(addr);
    
#line 190 
    if (tmp_1) 
#line 190 
               tmp_2 = 0; else 
#line 190 
                               tmp_2 = 1;
    
#line 190 
    if (tmp_2) 
#line 190 
               tmp_3 = 1; else 
#line 190 
                               tmp_3 = 0;
  }
  else 
#line 190 
       tmp_3 = 0;
  
#line 190 
  __retres = (_Bool)(tmp_3 != 0);
  
#line 190 
  return __retres;
}


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst, u8 const *src)
{
  
#line 274 
  *((u32 *)dst) = *((u32 const *)src);
  
#line 275 
  *((u16 *)(dst + 4U)) = *((u16 const *)(src + 4U));
  
#line 276 
  return;
}


#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_find_ext_capability(struct pci_dev *, int);


#line 863 
int pci_bus_read_config_dword(struct pci_bus *, unsigned int, int, u32 *);


#line 869 
int pci_bus_write_config_dword(struct pci_bus *, unsigned int, int, u32);


#line 891  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev const *dev, int where, u32 *val)
{
  int tmp;
  
#line 894 
  tmp = pci_bus_read_config_dword(dev->bus,dev->devfn,where,val);
  
#line 894 
  return tmp;
}


#line 904  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev const *dev, int where, u32 val)
{
  int tmp;
  
#line 907 
  tmp = pci_bus_write_config_dword(dev->bus,dev->devfn,where,val);
  
#line 907 
  return tmp;
}


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1672 
int pci_enable_sriov(struct pci_dev *, int);


#line 1673 
void pci_disable_sriov(struct pci_dev *);


#line 1674 
int pci_num_vf(struct pci_dev *);


#line 1675 
int pci_vfs_assigned(struct pci_dev *);


#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.h"
s32 fm10k_tlv_msg_error(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 178 
struct fm10k_tlv_attr const fm10k_tlv_msg_test_attr[14U];


#line 180 
s32 fm10k_tlv_msg_test(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.h"
s32 fm10k_pfvf_mbx_init(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, struct fm10k_msg_data const *msg_data, u8 id);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.h"
u32 fm10k_read_reg(struct fm10k_hw *hw, int reg);


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.h"
bool fm10k_glort_valid_pf(struct fm10k_hw *hw, u16 glort);


#line 28 
u16 fm10k_queues_per_pool(struct fm10k_hw *hw);


#line 29 
u16 fm10k_vf_queue_index(struct fm10k_hw *hw, u16 vf_idx);


#line 127 
s32 fm10k_iov_msg_msix_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 128 
s32 fm10k_iov_msg_mac_vlan_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 130 
s32 fm10k_iov_msg_lport_state_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.h"
struct fm10k_tlv_attr const fm10k_mac_vlan_msg_attr[6U];


#line 68 
struct fm10k_tlv_attr const fm10k_lport_state_msg_attr[4U];


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static void fm10k_mbx_lock(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 360 
  goto ldv_46781;
  ldv_46780: 
#line 361 
  ;
  
#line 361 
  __const_udelay(85900UL);
  ldv_46781: 
#line 363 
  ;
  
#line 360 
  tmp = test_and_set_bit(4L,(unsigned long volatile *)(& interface->state));
  
#line 360 
  if (tmp != 0) 
#line 362 
                goto ldv_46780; else 
#line 365 
                                     goto ldv_46782;
  ldv_46782: 
#line 366 
  ;
  
#line 367 
  return;
}


#line 364  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static void fm10k_mbx_unlock(struct fm10k_intfc *interface)
{
  
#line 366 
  ldv_inline_asm();
  
#line 368 
  clear_bit(4L,(unsigned long volatile *)(& interface->state));
  
#line 369 
  return;
}


#line 487 
s32 fm10k_iov_event(struct fm10k_intfc *interface);


#line 488 
s32 fm10k_iov_mbx(struct fm10k_intfc *interface);


#line 489 
void fm10k_iov_suspend(struct pci_dev *pdev);


#line 490 
int fm10k_iov_resume(struct pci_dev *pdev);


#line 491 
void fm10k_iov_disable(struct pci_dev *pdev);


#line 492 
int fm10k_iov_configure(struct pci_dev *pdev, int num_vfs);


#line 493 
s32 fm10k_iov_update_pvid(struct fm10k_intfc *interface, u16 glort, u16 pvid);


#line 494 
int fm10k_ndo_set_vf_mac(struct net_device *netdev, int vf_idx, u8 *mac);


#line 495 
int fm10k_ndo_set_vf_vlan(struct net_device *netdev, int vf_idx, u16 vid, u8 qos);


#line 497 
int fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx, int unused, int rate);


#line 499 
int fm10k_ndo_get_vf_config(struct net_device *netdev, int vf_idx, struct ifla_vf_info *ivi);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
static s32 fm10k_iov_msg_error(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 tmp;
  
#line 28 
  struct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;
  
#line 29 
  struct fm10k_intfc *interface = (struct fm10k_intfc *)hw->back;
  
#line 30 
  struct pci_dev *pdev = interface->pdev;
  
#line 32 
  dev_err((struct device const *)(& pdev->dev),"Unknown message ID %u on VF %d\n",*(*results) & 65535U,(int)vf_info->vf_idx);
  
#line 35 
  tmp = fm10k_tlv_msg_error(hw,results,mbx);
  
#line 35 
  return tmp;
}


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
static struct fm10k_msg_data const iov_mbx_data[5U] = {{.id = 0U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_tlv_msg_test_attr), .func = & fm10k_tlv_msg_test}, {.id = 1U, .attr = (struct fm10k_tlv_attr const *)0, .func = & fm10k_iov_msg_msix_pf}, {.id = 2U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_mac_vlan_msg_attr), .func = & fm10k_iov_msg_mac_vlan_pf}, {.id = 3U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_lport_state_msg_attr), .func = & fm10k_iov_msg_lport_state_pf}, {.id = 4294967295U, .attr = (struct fm10k_tlv_attr const *)0, .func = & fm10k_iov_msg_error}};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
s32 fm10k_iov_event(struct fm10k_intfc *interface)
{
  s32 __retres;
  struct fm10k_iov_data *iov_data;
  s64 vflre;
  int i;
  struct fm10k_iov_data * volatile *tmp;
  u32 tmp_0;
  u32 tmp_1;
  u32 tmp_2;
  u32 tmp_3;
  
#line 48 
  struct fm10k_hw *hw = & interface->hw;
  {
    
#line 54 
    struct fm10k_iov_data *__var = (struct fm10k_iov_data *)0;
    
#line 54 
    tmp = (struct fm10k_iov_data * volatile *)(& interface->iov_data);
  }
  
#line 54 
  ;
  
#line 54 
  if (*tmp == (struct fm10k_iov_data *)0) {
    
#line 55 
    __retres = 0;
    
#line 55 
    goto return_label;
  }
  else ;
  
#line 57 
  rcu_read_lock();
  
#line 59 
  iov_data = interface->iov_data;
  
#line 62 
  if (iov_data == (struct fm10k_iov_data *)0) 
#line 63 
                                              goto read_unlock; else ;
  
#line 65 
  tmp_0 = fm10k_read_reg(hw,6);
  
#line 65 
  if ((tmp_0 & 2048U) == 0U) 
#line 66 
                             goto read_unlock; else ;
  ldv_46989: 
#line 67 
  ;
  
#line 70 
  tmp_1 = fm10k_read_reg(hw,100420);
  
#line 70 
  vflre = (long long)tmp_1;
  
#line 71 
  vflre <<= 32;
  
#line 72 
  tmp_2 = fm10k_read_reg(hw,100421);
  
#line 72 
  vflre = (long long)tmp_2 | vflre;
  
#line 73 
  vflre = (vflre << 32) | (vflre >> 32);
  
#line 74 
  tmp_3 = fm10k_read_reg(hw,100420);
  
#line 74 
  vflre = (long long)tmp_3 | vflre;
  
#line 76 
  i = (int)iov_data->num_vfs;
  
#line 78 
  vflre <<= 64 - i;
  
#line 78 
  goto ldv_46987;
  ldv_46986: 
#line 79 
  ;
  {
    
#line 79 
    struct fm10k_vf_info *vf_info = & iov_data->vf_info[i];
    
#line 81 
    if (vflre >= 0LL) 
#line 82 
                      goto ldv_46985; else ;
    
#line 84 
    (*(hw->iov.ops.reset_resources))(hw,vf_info);
    
#line 85 
    (*(vf_info->mbx.ops.connect))(hw,& vf_info->mbx);
  }
  ldv_46985: 
#line 87 
  ;
  
#line 78 
  vflre *= 2LL;
  ldv_46987: 
#line 79 
  ;
  
#line 78 
  if (vflre != 0LL) {
    int tmp_4;
    
#line 78 
    tmp_4 = i;
    
#line 78 
    i -= 1;
    
#line 78 
    ;
    
#line 78 
    if (tmp_4 != 0) 
#line 80 
                    goto ldv_46986; else 
#line 83 
                                         goto ldv_46988;
  }
  else 
#line 83 
       goto ldv_46988;
  ldv_46988: 
#line 84 
  ;
  
#line 87 
  if (iov_data->num_vfs != (unsigned int)i) 
#line 89 
                                            goto ldv_46989; else 
#line 92 
                                                                 goto ldv_46990;
  ldv_46990: 
#line 93 
  ;
  read_unlock: 
#line 89 
  ;
  
#line 90 
  rcu_read_unlock();
  
#line 92 
  __retres = 0;
  return_label: 
#line 92 
                return __retres;
}


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
s32 fm10k_iov_mbx(struct fm10k_intfc *interface)
{
  s32 __retres;
  struct fm10k_iov_data *iov_data;
  int i;
  struct fm10k_iov_data * volatile *tmp;
  unsigned int tmp_0;
  int tmp_5;
  
#line 97 
  struct fm10k_hw *hw = & interface->hw;
  {
    
#line 102 
    struct fm10k_iov_data *__var = (struct fm10k_iov_data *)0;
    
#line 102 
    tmp = (struct fm10k_iov_data * volatile *)(& interface->iov_data);
  }
  
#line 102 
  ;
  
#line 102 
  if (*tmp == (struct fm10k_iov_data *)0) {
    
#line 103 
    __retres = 0;
    
#line 103 
    goto return_label;
  }
  else ;
  
#line 105 
  rcu_read_lock();
  
#line 107 
  iov_data = interface->iov_data;
  
#line 110 
  if (iov_data == (struct fm10k_iov_data *)0) 
#line 111 
                                              goto read_unlock; else ;
  
#line 114 
  fm10k_mbx_lock(interface);
  process_mbx: 
#line 123 
  ;
  
#line 124 
  tmp_0 = (unsigned int)(iov_data->next_vf_mbx != 0U);
  
#line 124 
  if (tmp_0) ; else 
#line 124 
                    tmp_0 = iov_data->num_vfs;
  
#line 124 
  i = (int)tmp_0;
  
#line 124 
  goto ldv_47006;
  ldv_47005: 
#line 125 
  ;
  {
    int tmp_4;
    bool tmp_3;
    
#line 125 
    struct fm10k_vf_info *vf_info = & iov_data->vf_info[i];
    
#line 126 
    struct fm10k_mbx_info *mbx = & vf_info->mbx;
    
#line 127 
    u16 glort = vf_info->glort;
    
#line 130 
    if ((unsigned int)vf_info->vf_flags != 0U) {
      int tmp_2;
      bool tmp_1;
      
#line 130 
      tmp_1 = fm10k_glort_valid_pf(hw,(unsigned short)((int)glort));
      
#line 130 
      if (tmp_1) 
#line 130 
                 tmp_2 = 0; else 
#line 130 
                                 tmp_2 = 1;
      
#line 130 
      if (tmp_2) 
#line 131 
                 (*(hw->iov.ops.reset_lport))(hw,vf_info); else ;
    }
    else ;
    
#line 134 
    if (mbx->timeout == 0U) {
      
#line 135 
      (*(hw->iov.ops.reset_resources))(hw,vf_info);
      
#line 136 
      (*(mbx->ops.connect))(hw,mbx);
    }
    else ;
    
#line 140 
    tmp_3 = (*(hw->mbx.ops.tx_ready))(& hw->mbx,(unsigned short)7);
    
#line 140 
    if (tmp_3) 
#line 140 
               tmp_4 = 0; else 
#line 140 
                               tmp_4 = 1;
    
#line 140 
    if (tmp_4) 
#line 141 
               goto ldv_47004; else ;
    
#line 144 
    (*(mbx->ops.process))(hw,mbx);
  }
  ldv_47006: 
#line 146 
  ;
  
#line 124 
  tmp_5 = i;
  
#line 124 
  i -= 1;
  
#line 124 
  ;
  
#line 124 
  if (tmp_5 != 0) 
#line 126 
                  goto ldv_47005; else 
#line 129 
                                       goto ldv_47004;
  ldv_47004: 
#line 130 
  ;
  
#line 151 
  if (i >= 0) 
#line 152 
              iov_data->next_vf_mbx = (unsigned int)(i + 1);
  else 
    
#line 153 
    if (iov_data->next_vf_mbx != 0U) {
      
#line 154 
      iov_data->next_vf_mbx = 0U;
      
#line 155 
      goto process_mbx;
    }
    else ;
  
#line 159 
  fm10k_mbx_unlock(interface);
  read_unlock: 
#line 161 
  ;
  
#line 162 
  rcu_read_unlock();
  
#line 164 
  __retres = 0;
  return_label: 
#line 164 
                return __retres;
}


#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
void fm10k_iov_suspend(struct pci_dev *pdev)
{
  int num_vfs;
  int i;
  unsigned int tmp_0;
  
#line 169 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 170 
  struct fm10k_iov_data *iov_data = interface->iov_data;
  
#line 171 
  struct fm10k_hw *hw = & interface->hw;
  
#line 175 
  if (iov_data != (struct fm10k_iov_data *)0) 
#line 175 
                                              tmp_0 = iov_data->num_vfs; else 
                                                                    
#line 175 
                                                                    tmp_0 = 0U;
  
#line 175 
  num_vfs = (int)tmp_0;
  {
    u32 * volatile *tmp_1;
    {
      
#line 178 
      u32 *__var = (u32 *)0U;
      
#line 178 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 178 
    u32 *hw_addr = *tmp_1;
    
#line 178 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 178 
                                            writel(65535U,(void volatile *)(hw_addr + 50U)); else ;
  }
  
#line 182 
  i = 0;
  
#line 182 
  goto ldv_47020;
  ldv_47019: 
#line 183 
  ;
  {
    
#line 183 
    struct fm10k_vf_info *vf_info = & iov_data->vf_info[i];
    
#line 185 
    (*(hw->iov.ops.reset_resources))(hw,vf_info);
    
#line 186 
    (*(hw->iov.ops.reset_lport))(hw,vf_info);
  }
  
#line 182 
  i += 1;
  ldv_47020: 
#line 183 
  ;
  
#line 182 
  if (i < num_vfs) 
#line 184 
                   goto ldv_47019; else 
#line 187 
                                        goto ldv_47021;
  ldv_47021: 
#line 188 
  ;
  
#line 189 
  return;
}


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
int fm10k_iov_resume(struct pci_dev *pdev)
{
  int __retres;
  int num_vfs;
  int i;
  unsigned int tmp_0;
  int tmp_2;
  u16 tmp_1;
  int tmp_3;
  
#line 192 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 193 
  struct fm10k_iov_data *iov_data = interface->iov_data;
  
#line 194 
  struct fm10k_dglort_cfg dglort = {.glort = (unsigned short)0U, .queue_b = (unsigned short)0, .vsi_b = (unsigned char)0, .idx = (unsigned char)0, .rss_l = (unsigned char)0, .pc_l = (unsigned char)0, .vsi_l = (unsigned char)0, .queue_l = (unsigned char)0, .shared_l = (unsigned char)0, .inner_rss = (unsigned char)0};
  
#line 195 
  struct fm10k_hw *hw = & interface->hw;
  
#line 199 
  if (iov_data != (struct fm10k_iov_data *)0) 
#line 199 
                                              tmp_0 = iov_data->num_vfs; else 
                                                                    
#line 199 
                                                                    tmp_0 = 0U;
  
#line 199 
  num_vfs = (int)tmp_0;
  
#line 202 
  if (iov_data == (struct fm10k_iov_data *)0) {
    
#line 203 
    __retres = -12;
    
#line 203 
    goto return_label;
  }
  else ;
  
#line 206 
  (*(hw->iov.ops.assign_resources))(hw,(unsigned short)((int)((unsigned short)num_vfs)),(unsigned short)((int)((unsigned short)num_vfs)));
  
#line 209 
  dglort.glort = (unsigned short)hw->mac.dglort_map;
  
#line 210 
  dglort.idx = (unsigned char)2U;
  
#line 211 
  dglort.inner_rss = (unsigned char)1U;
  
#line 212 
  tmp_1 = fm10k_queues_per_pool(hw);
  
#line 212 
  tmp_2 = fls((int)tmp_1 + -1);
  
#line 212 
  dglort.rss_l = (unsigned char)tmp_2;
  
#line 213 
  dglort.queue_b = fm10k_vf_queue_index(hw,(unsigned short)0);
  
#line 214 
  tmp_3 = fls((int)hw->iov.total_vfs + -1);
  
#line 214 
  dglort.vsi_l = (unsigned char)tmp_3;
  
#line 215 
  dglort.vsi_b = (unsigned char)1U;
  
#line 217 
  (*(hw->mac.ops.configure_dglort_map))(hw,& dglort);
  
#line 220 
  i = 0;
  
#line 220 
  goto ldv_47034;
  ldv_47033: 
#line 221 
  ;
  {
    
#line 221 
    struct fm10k_vf_info *vf_info = & iov_data->vf_info[i];
    
#line 224 
    if (~ hw->mac.dglort_map >> 16 == (unsigned int)i) 
#line 225 
                                                       goto ldv_47032; else ;
    
#line 228 
    (*(hw->iov.ops.set_lport))(hw,vf_info,(unsigned short)((int)((unsigned short)i)),(unsigned char)2);
    
#line 232 
    vf_info->sw_vid = hw->mac.default_vid;
    
#line 235 
    (*(hw->iov.ops.assign_default_mac_vlan))(hw,vf_info);
    
#line 238 
    (*(vf_info->mbx.ops.connect))(hw,& vf_info->mbx);
  }
  
#line 220 
  i += 1;
  ldv_47034: 
#line 221 
  ;
  
#line 220 
  if (i < num_vfs) 
#line 222 
                   goto ldv_47033; else 
#line 225 
                                        goto ldv_47032;
  ldv_47032: 
#line 226 
  ;
  
#line 241 
  __retres = 0;
  return_label: 
#line 241 
                return __retres;
}


#line 244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
s32 fm10k_iov_update_pvid(struct fm10k_intfc *interface, u16 glort, u16 pvid)
{
  s32 __retres;
  struct fm10k_vf_info *vf_info;
  
#line 246 
  struct fm10k_iov_data *iov_data = interface->iov_data;
  
#line 247 
  struct fm10k_hw *hw = & interface->hw;
  
#line 249 
  u16 vf_idx = (unsigned short)((int)glort - (int)((unsigned short)hw->mac.dglort_map));
  
#line 252 
  if (iov_data == (struct fm10k_iov_data *)0) {
    
#line 253 
    __retres = -2;
    
#line 253 
    goto return_label;
  }
  else ;
  
#line 256 
  if ((unsigned int)vf_idx >= iov_data->num_vfs) {
    
#line 257 
    __retres = -2;
    
#line 257 
    goto return_label;
  }
  else ;
  
#line 260 
  vf_info = & iov_data->vf_info[(int)vf_idx];
  
#line 261 
  if ((int)vf_info->sw_vid != (int)pvid) {
    
#line 262 
    vf_info->sw_vid = pvid;
    
#line 263 
    (*(hw->iov.ops.assign_default_mac_vlan))(hw,vf_info);
  }
  else ;
  
#line 266 
  __retres = 0;
  return_label: 
#line 266 
                return __retres;
}


#line 280 
void __compiletime_assert_280(void);


#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
static void fm10k_iov_free_data(struct pci_dev *pdev)
{
  
#line 271 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 273 
  if (interface->iov_data == (struct fm10k_iov_data *)0) 
#line 274 
                                                         goto return_label; else ;
  
#line 277 
  fm10k_iov_suspend(pdev);
  {
    
#line 280 
    bool __cond = (_Bool)0;
    
#line 280 
    if ((int)__cond != 0) 
#line 280 
                          __compiletime_assert_280(); else ;
  }
  
#line 280 
  kfree_call_rcu(& (interface->iov_data)->rcu,(void (*)(struct callback_head *))8);
  
#line 281 
  interface->iov_data = (struct fm10k_iov_data *)0;
  return_label: 
#line 282 
                return;
}


#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
static s32 fm10k_iov_alloc_data(struct pci_dev *pdev, int num_vfs)
{
  s32 __retres;
  size_t size;
  int i;
  int err;
  
#line 286 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 287 
  struct fm10k_iov_data *iov_data = interface->iov_data;
  
#line 288 
  struct fm10k_hw *hw = & interface->hw;
  
#line 293 
  if (iov_data != (struct fm10k_iov_data *)0) {
    
#line 294 
    __retres = -16;
    
#line 294 
    goto return_label;
  }
  else ;
  
#line 297 
  if (hw->iov.ops.assign_resources == (s32 (*)(struct fm10k_hw *, u16 , u16 ))0) {
    
#line 298 
    __retres = -19;
    
#line 298 
    goto return_label;
  }
  else ;
  
#line 301 
  if (num_vfs == 0) {
    
#line 302 
    __retres = 0;
    
#line 302 
    goto return_label;
  }
  else ;
  
#line 305 
  size = (unsigned long)((void *)24 + (unsigned int)num_vfs * 2800U);
  
#line 306 
  iov_data = (struct fm10k_iov_data *)kzalloc(size,208U);
  
#line 307 
  if (iov_data == (struct fm10k_iov_data *)0) {
    
#line 308 
    __retres = -12;
    
#line 308 
    goto return_label;
  }
  else ;
  
#line 311 
  iov_data->num_vfs = (unsigned int)num_vfs;
  
#line 314 
  i = 0;
  
#line 314 
  goto ldv_47065;
  ldv_47064: 
#line 315 
  ;
  {
    
#line 315 
    struct fm10k_vf_info *vf_info = & iov_data->vf_info[i];
    
#line 318 
    vf_info->vsi = (unsigned char)((unsigned int)((unsigned char)i) + 1U);
    
#line 319 
    vf_info->vf_idx = (unsigned char)i;
    
#line 322 
    err = fm10k_pfvf_mbx_init(hw,& vf_info->mbx,(struct fm10k_msg_data const *)(& iov_mbx_data),(unsigned char)((int)((unsigned char)i)));
    
#line 323 
    if (err != 0) {
      
#line 324 
      dev_err((struct device const *)(& pdev->dev),"Unable to initialize SR-IOV mailbox\n");
      
#line 326 
      kfree((void const *)iov_data);
      
#line 327 
      __retres = err;
      
#line 327 
      goto return_label;
    }
    else ;
  }
  
#line 314 
  i += 1;
  ldv_47065: 
#line 315 
  ;
  
#line 314 
  if (i < num_vfs) 
#line 316 
                   goto ldv_47064; else 
#line 319 
                                        goto ldv_47066;
  ldv_47066: 
#line 320 
  ;
  
#line 332 
  interface->iov_data = iov_data;
  
#line 335 
  fm10k_iov_resume(pdev);
  
#line 337 
  __retres = 0;
  return_label: 
#line 337 
                return __retres;
}


#line 340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
void fm10k_iov_disable(struct pci_dev *pdev)
{
  int tmp;
  
#line 342 
  tmp = pci_num_vf(pdev);
  
#line 342 
  if (tmp != 0) {
    int tmp_0;
    
#line 342 
    tmp_0 = pci_vfs_assigned(pdev);
    
#line 342 
    if (tmp_0 != 0) 
#line 343 
                    dev_err((struct device const *)(& pdev->dev),"Cannot disable SR-IOV while VFs are assigned\n"); else 
                                                                    
#line 346 
                                                                    pci_disable_sriov(pdev);
  }
  else 
#line 346 
       pci_disable_sriov(pdev);
  
#line 348 
  fm10k_iov_free_data(pdev);
  
#line 349 
  return;
}


#line 351  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
static void fm10k_disable_aer_comp_abort(struct pci_dev *pdev)
{
  u32 err_sev;
  int pos;
  
#line 356 
  pos = pci_find_ext_capability(pdev,1);
  
#line 357 
  if (pos == 0) 
#line 358 
                goto return_label; else ;
  
#line 360 
  pci_read_config_dword((struct pci_dev const *)pdev,pos + 12,& err_sev);
  
#line 361 
  err_sev &= 4294934527U;
  
#line 362 
  pci_write_config_dword((struct pci_dev const *)pdev,pos + 12,err_sev);
  return_label: 
#line 363 
                return;
}


#line 365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
int fm10k_iov_configure(struct pci_dev *pdev, int num_vfs)
{
  int __retres;
  
#line 367 
  int current_vfs = pci_num_vf(pdev);
  
#line 368 
  int err = 0;
  
#line 370 
  if (current_vfs != 0) {
    int tmp_0;
    
#line 370 
    tmp_0 = pci_vfs_assigned(pdev);
    
#line 370 
    if (tmp_0 != 0) {
      
#line 371 
      dev_err((struct device const *)(& pdev->dev),"Cannot modify SR-IOV while VFs are assigned\n");
      
#line 373 
      num_vfs = current_vfs;
    }
    else 
#line 370 
         goto _LAND;
  }
  else {
    _LAND: {
             
#line 375 
             pci_disable_sriov(pdev);
             
#line 376 
             fm10k_iov_free_data(pdev);
           }
  }
  
#line 380 
  err = fm10k_iov_alloc_data(pdev,num_vfs);
  
#line 381 
  if (err != 0) {
    
#line 382 
    __retres = err;
    
#line 382 
    goto return_label;
  }
  else ;
  
#line 385 
  if (num_vfs != 0 && num_vfs != current_vfs) {
    
#line 390 
    fm10k_disable_aer_comp_abort(pdev);
    
#line 392 
    err = pci_enable_sriov(pdev,num_vfs);
    
#line 393 
    if (err != 0) {
      
#line 394 
      dev_err((struct device const *)(& pdev->dev),"Enable PCI SR-IOV failed: %d\n",err);
      
#line 396 
      __retres = err;
      
#line 396 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 400 
  __retres = num_vfs;
  return_label: 
#line 400 
                return __retres;
}


#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
__inline static void fm10k_reset_vf_info(struct fm10k_intfc *interface, struct fm10k_vf_info *vf_info)
{
  
#line 406 
  struct fm10k_hw *hw = & interface->hw;
  
#line 409 
  fm10k_mbx_lock(interface);
  
#line 412 
  (*(hw->iov.ops.reset_lport))(hw,vf_info);
  
#line 415 
  (*(hw->iov.ops.assign_default_mac_vlan))(hw,vf_info);
  
#line 418 
  (*(hw->iov.ops.set_lport))(hw,vf_info,(unsigned short)((int)vf_info->vf_idx),(unsigned char)2);
  
#line 421 
  fm10k_mbx_unlock(interface);
  
#line 422 
  return;
}


#line 424  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
int fm10k_ndo_set_vf_mac(struct net_device *netdev, int vf_idx, u8 *mac)
{
  int __retres;
  struct fm10k_vf_info *vf_info;
  int tmp_1;
  bool tmp_0;
  
#line 426 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 427 
  struct fm10k_iov_data *iov_data = interface->iov_data;
  
#line 431 
  if (iov_data == (struct fm10k_iov_data *)0 || iov_data->num_vfs <= (unsigned int)vf_idx) {
    
#line 432 
    __retres = -22;
    
#line 432 
    goto return_label;
  }
  else ;
  
#line 435 
  tmp_0 = is_zero_ether_addr((u8 const *)mac);
  
#line 435 
  if (tmp_0) 
#line 435 
             tmp_1 = 0; else 
#line 435 
                             tmp_1 = 1;
  
#line 435 
  if (tmp_1) {
    int tmp_3;
    bool tmp_2;
    
#line 435 
    tmp_2 = is_valid_ether_addr((u8 const *)mac);
    
#line 435 
    if (tmp_2) 
#line 435 
               tmp_3 = 0; else 
#line 435 
                               tmp_3 = 1;
    
#line 435 
    if (tmp_3) {
      
#line 436 
      __retres = -22;
      
#line 436 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 439 
  vf_info = & iov_data->vf_info[vf_idx];
  
#line 440 
  ether_addr_copy((u8 *)(& vf_info->mac),(u8 const *)mac);
  
#line 442 
  fm10k_reset_vf_info(interface,vf_info);
  
#line 444 
  __retres = 0;
  return_label: 
#line 444 
                return __retres;
}


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
int fm10k_ndo_set_vf_vlan(struct net_device *netdev, int vf_idx, u16 vid, u8 qos)
{
  int __retres;
  struct fm10k_vf_info *vf_info;
  
#line 450 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 451 
  struct fm10k_iov_data *iov_data = interface->iov_data;
  
#line 452 
  struct fm10k_hw *hw = & interface->hw;
  
#line 456 
  if (iov_data == (struct fm10k_iov_data *)0 || iov_data->num_vfs <= (unsigned int)vf_idx) {
    
#line 457 
    __retres = -22;
    
#line 457 
    goto return_label;
  }
  else ;
  
#line 460 
  if ((unsigned int)qos != 0U || (unsigned int)vid > 4094U) {
    
#line 461 
    __retres = -22;
    
#line 461 
    goto return_label;
  }
  else ;
  
#line 463 
  vf_info = & iov_data->vf_info[vf_idx];
  
#line 466 
  if ((int)vf_info->pf_vid == (int)vid) {
    
#line 467 
    __retres = 0;
    
#line 467 
    goto return_label;
  }
  else ;
  
#line 470 
  vf_info->pf_vid = vid;
  
#line 473 
  (*(hw->mac.ops.update_vlan))(hw,268369920U,(unsigned char)((int)vf_info->vsi),(_Bool)0);
  
#line 475 
  fm10k_reset_vf_info(interface,vf_info);
  
#line 477 
  __retres = 0;
  return_label: 
#line 477 
                return __retres;
}


#line 480  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
int fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx, int unused, int rate)
{
  int __retres;
  
#line 483 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 484 
  struct fm10k_iov_data *iov_data = interface->iov_data;
  
#line 485 
  struct fm10k_hw *hw = & interface->hw;
  
#line 488 
  if (iov_data == (struct fm10k_iov_data *)0 || iov_data->num_vfs <= (unsigned int)vf_idx) {
    
#line 489 
    __retres = -22;
    
#line 489 
    goto return_label;
  }
  else ;
  
#line 492 
  if ((unsigned int)rate > 100000U) {
    
#line 493 
    __retres = -22;
    
#line 493 
    goto return_label;
  }
  else ;
  
#line 496 
  iov_data->vf_info[vf_idx].rate = rate;
  
#line 499 
  (*(hw->iov.ops.configure_tc))(hw,(unsigned short)((int)((unsigned short)vf_idx)),rate);
  
#line 501 
  __retres = 0;
  return_label: 
#line 501 
                return __retres;
}


#line 504  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_iov.c"
int fm10k_ndo_get_vf_config(struct net_device *netdev, int vf_idx, struct ifla_vf_info *ivi)
{
  int __retres;
  struct fm10k_vf_info *vf_info;
  
#line 507 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 508 
  struct fm10k_iov_data *iov_data = interface->iov_data;
  
#line 512 
  if (iov_data == (struct fm10k_iov_data *)0 || iov_data->num_vfs <= (unsigned int)vf_idx) {
    
#line 513 
    __retres = -22;
    
#line 513 
    goto return_label;
  }
  else ;
  
#line 515 
  vf_info = & iov_data->vf_info[vf_idx];
  
#line 517 
  ivi->vf = (unsigned int)vf_idx;
  
#line 518 
  ivi->max_tx_rate = (unsigned int)vf_info->rate;
  
#line 519 
  ivi->min_tx_rate = 0U;
  
#line 520 
  ether_addr_copy((u8 *)(& ivi->mac),(u8 const *)(& vf_info->mac));
  
#line 521 
  ivi->vlan = (unsigned int)vf_info->pf_vid;
  
#line 522 
  ivi->qos = 0U;
  
#line 524 
  __retres = 0;
  return_label: 
#line 524 
                return __retres;
}


#line 431  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_iov.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 434 
  tmp = ldv_kzalloc(size,flags);
  
#line 434 
  return tmp;
}


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memset(void *, int, size_t);


#line 63 
int memcmp(void const *, void const *, size_t);


#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.h"
s32 fm10k_tlv_msg_init(u32 *msg, u16 msg_id);


#line 109 
s32 fm10k_tlv_attr_put_null_string(u32 *msg, u16 attr_id, unsigned char const *string);


#line 110 
s32 fm10k_tlv_attr_get_null_string(u32 *attr, unsigned char *string);


#line 111 
s32 fm10k_tlv_attr_put_mac_vlan(u32 *msg, u16 attr_id, u8 const *mac_addr, u16 vlan);


#line 112 
s32 fm10k_tlv_attr_get_mac_vlan(u32 *attr, u8 *mac_addr, u16 *vlan);


#line 113 
s32 fm10k_tlv_attr_put_bool(u32 *msg, u16 attr_id);


#line 114 
s32 fm10k_tlv_attr_put_value(u32 *msg, u16 attr_id, s64 value, u32 len);


#line 131 
s32 fm10k_tlv_attr_get_value(u32 *attr, void *value, u32 len);


#line 148 
s32 fm10k_tlv_attr_put_le_struct(u32 *msg, u16 attr_id, void const *le_struct, u32 len);


#line 149 
s32 fm10k_tlv_attr_get_le_struct(u32 *attr, void *le_struct, u32 len);


#line 150 
u32 *fm10k_tlv_attr_nest_start(u32 *msg, u16 attr_id);


#line 151 
s32 fm10k_tlv_attr_nest_stop(u32 *msg);


#line 152 
s32 fm10k_tlv_attr_parse(u32 *attr, u32 **results, struct fm10k_tlv_attr const *tlv_attr);


#line 153 
s32 fm10k_tlv_msg_parse(struct fm10k_hw *hw, u32 *msg, struct fm10k_mbx_info *mbx, struct fm10k_msg_data const *data);


#line 179 
void fm10k_tlv_msg_test_create(u32 *msg, u32 attr_flags);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_msg_init(u32 *msg, u16 msg_id)
{
  s32 __retres;
  
#line 33 
  if (msg == (u32 *)0U) {
    
#line 34 
    __retres = -2;
    
#line 34 
    goto return_label;
  }
  else ;
  
#line 36 
  *msg = (unsigned int)((int)msg_id | 65536);
  
#line 38 
  __retres = 0;
  return_label: 
#line 38 
                return __retres;
}


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_put_null_string(u32 *msg, u16 attr_id, unsigned char const *string)
{
  s32 __retres;
  u32 *attr;
  unsigned char const *tmp;
  
#line 54 
  u32 attr_data = 0U;
  
#line 54 
  u32 len = 0U;
  
#line 58 
  if (string == (unsigned char const *)0U || msg == (u32 *)0U) {
    
#line 59 
    __retres = -2;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  attr = msg + ((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U);
  ldv_43989: 
#line 62 
  ;
  
#line 66 
  if (len != 0U && (len & 3U) == 0U) {
    
#line 67 
    *(attr + len / 4U) = attr_data;
    
#line 68 
    attr_data = 0U;
  }
  else ;
  
#line 72 
  attr_data = ((unsigned int)*string << (len & 3U) * 8U) | attr_data;
  
#line 73 
  len += 1U;
  
#line 76 
  tmp = string;
  
#line 76 
  string += 1;
  
#line 76 
  ;
  
#line 76 
  if ((unsigned int)*tmp != 0U) 
#line 78 
                                goto ldv_43989; else 
#line 81 
                                                     goto ldv_43990;
  ldv_43990: 
#line 82 
  ;
  
#line 79 
  *(attr + (len + 3U) / 4U) = attr_data;
  
#line 82 
  len <<= 20;
  
#line 83 
  *attr = (unsigned int)attr_id | len;
  
#line 86 
  len += 4194304U;
  
#line 87 
  *msg += (len + 3145728U) & 4291821567U;
  
#line 89 
  __retres = 0;
  return_label: 
#line 89 
                return __retres;
}


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_get_null_string(u32 *attr, unsigned char *string)
{
  s32 __retres;
  u32 len;
  u32 tmp;
  
#line 106 
  if (string == (unsigned char *)0U || attr == (u32 *)0U) {
    
#line 107 
    __retres = -2;
    
#line 107 
    goto return_label;
  }
  else ;
  
#line 109 
  len = *attr >> 20;
  
#line 110 
  attr += 1;
  
#line 112 
  goto ldv_43997;
  ldv_43996: 
#line 113 
  ;
  
#line 113 
  *(string + len) = (unsigned char)(*(attr + len / 4U) >> (len & 3U) * 8U);
  ldv_43997: 
#line 114 
  ;
  
#line 112 
  tmp = len;
  
#line 112 
  len -= 1U;
  
#line 112 
  ;
  
#line 112 
  if (tmp != 0U) 
#line 114 
                 goto ldv_43996; else 
#line 117 
                                      goto ldv_43998;
  ldv_43998: 
#line 118 
  ;
  
#line 115 
  __retres = 0;
  return_label: 
#line 115 
                return __retres;
}


#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_put_mac_vlan(u32 *msg, u16 attr_id, u8 const *mac_addr, u16 vlan)
{
  s32 __retres;
  u32 *attr;
  
#line 131 
  u32 len = 6291456U;
  
#line 135 
  if (msg == (u32 *)0U || mac_addr == (u8 const *)0U) {
    
#line 136 
    __retres = -2;
    
#line 136 
    goto return_label;
  }
  else ;
  
#line 138 
  attr = msg + ((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U);
  
#line 141 
  *attr = (unsigned int)attr_id | len;
  
#line 144 
  *(attr + 1U) = *((__le32 const *)mac_addr);
  
#line 145 
  *(attr + 2U) = (unsigned int)*((__le16 const *)(mac_addr + 4U));
  
#line 146 
  *(attr + 2U) |= (unsigned int)vlan << 16;
  
#line 149 
  len += 4194304U;
  
#line 150 
  *msg += (len + 3145728U) & 4291821567U;
  
#line 152 
  __retres = 0;
  return_label: 
#line 152 
                return __retres;
}


#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_get_mac_vlan(u32 *attr, u8 *mac_addr, u16 *vlan)
{
  s32 __retres;
  
#line 168 
  if (mac_addr == (u8 *)0U || attr == (u32 *)0U) {
    
#line 169 
    __retres = -2;
    
#line 169 
    goto return_label;
  }
  else ;
  
#line 171 
  *((__le32 *)mac_addr) = *(attr + 1U);
  
#line 172 
  *((__le16 *)(mac_addr + 4U)) = (unsigned short)*(attr + 2U);
  
#line 173 
  *vlan = (unsigned short)(*(attr + 2U) >> 16);
  
#line 175 
  __retres = 0;
  return_label: 
#line 175 
                return __retres;
}


#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_put_bool(u32 *msg, u16 attr_id)
{
  s32 __retres;
  
#line 191 
  if (msg == (u32 *)0U) {
    
#line 192 
    __retres = -2;
    
#line 192 
    goto return_label;
  }
  else ;
  
#line 195 
  *(msg + ((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U)) = (unsigned int)attr_id;
  
#line 198 
  *msg += 4194304U;
  
#line 200 
  __retres = 0;
  return_label: 
#line 200 
                return __retres;
}


#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_put_value(u32 *msg, u16 attr_id, s64 value, u32 len)
{
  s32 __retres;
  u32 *attr;
  
#line 219 
  if (((msg == (u32 *)0U || len == 0U) || len > 8U) || ((len + 4294967295U) & len) != 0U) {
    
#line 220 
    __retres = -2;
    
#line 220 
    goto return_label;
  }
  else ;
  
#line 222 
  attr = msg + ((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U);
  
#line 224 
  if (len <= 3U) 
#line 225 
                 *(attr + 1U) = (unsigned int)value & ~ ((unsigned int)(18446744073709551615UL << len * 8U));
  else {
    
#line 227 
    *(attr + 1U) = (unsigned int)value;
    
#line 228 
    if (len > 4U) 
#line 229 
                  *(attr + 2U) = (unsigned int)(value >> 32); else ;
  }
  
#line 233 
  len <<= 20;
  
#line 234 
  *attr = (unsigned int)attr_id | len;
  
#line 237 
  len += 4194304U;
  
#line 238 
  *msg += (len + 3145728U) & 4291821567U;
  
#line 240 
  __retres = 0;
  return_label: 
#line 240 
                return __retres;
}


#line 254  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_get_value(u32 *attr, void *value, u32 len)
{
  s32 __retres;
  
#line 257 
  if (attr == (u32 *)0U || value == (void *)0) {
    
#line 258 
    __retres = -2;
    
#line 258 
    goto return_label;
  }
  else ;
  
#line 260 
  if (*attr >> 20 != len) {
    
#line 261 
    __retres = -2;
    
#line 261 
    goto return_label;
  }
  else ;
  
#line 263 
  if (len == 8U) 
#line 264 
                 *((u64 *)value) = ((unsigned long long)*(attr + 2U) << 32) | (unsigned long long)*(attr + 1U);
  else 
    
#line 265 
    if (len == 4U) 
#line 266 
                   *((u32 *)value) = *(attr + 1U);
    else 
      
#line 267 
      if (len == 2U) 
#line 268 
                     *((u16 *)value) = (unsigned short)*(attr + 1U); else 
                                                                    
#line 270 
                                                                    *((u8 *)value) = (unsigned char)*(attr + 1U);
  
#line 272 
  __retres = 0;
  return_label: 
#line 272 
                return __retres;
}


#line 286  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_put_le_struct(u32 *msg, u16 attr_id, void const *le_struct, u32 len)
{
  s32 __retres;
  u32 *attr;
  u32 i;
  
#line 289 
  __le32 const *le32_ptr = (__le32 const *)le_struct;
  
#line 294 
  if ((msg == (u32 *)0U || len == 0U) || (len & 3U) != 0U) {
    
#line 295 
    __retres = -2;
    
#line 295 
    goto return_label;
  }
  else ;
  
#line 297 
  attr = msg + ((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U);
  
#line 300 
  i = 0U;
  
#line 300 
  goto ldv_44038;
  ldv_44037: 
#line 301 
  ;
  
#line 301 
  *(attr + (i + 1U)) = *(le32_ptr + i);
  
#line 300 
  i += 1U;
  ldv_44038: 
#line 301 
  ;
  
#line 300 
  if (len / 4U > i) 
#line 302 
                    goto ldv_44037; else 
#line 305 
                                         goto ldv_44039;
  ldv_44039: 
#line 306 
  ;
  
#line 304 
  len <<= 20;
  
#line 305 
  *attr = (unsigned int)attr_id | len;
  
#line 308 
  len += 4194304U;
  
#line 309 
  *msg += (len + 3145728U) & 4291821567U;
  
#line 311 
  __retres = 0;
  return_label: 
#line 311 
                return __retres;
}


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_get_le_struct(u32 *attr, void *le_struct, u32 len)
{
  s32 __retres;
  u32 i;
  
#line 327 
  __le32 *le32_ptr = (__le32 *)le_struct;
  
#line 331 
  if (le_struct == (void *)0 || attr == (u32 *)0U) {
    
#line 332 
    __retres = -2;
    
#line 332 
    goto return_label;
  }
  else ;
  
#line 334 
  if (*attr >> 20 != len) {
    
#line 335 
    __retres = -2;
    
#line 335 
    goto return_label;
  }
  else ;
  
#line 337 
  attr += 1;
  
#line 339 
  i = 0U;
  
#line 339 
  goto ldv_44048;
  ldv_44047: 
#line 340 
  ;
  
#line 340 
  *(le32_ptr + i) = *(attr + i);
  
#line 339 
  i += 1U;
  
#line 339 
  len += 4294967292U;
  ldv_44048: 
#line 340 
  ;
  
#line 339 
  if (len != 0U) 
#line 341 
                 goto ldv_44047; else 
#line 344 
                                      goto ldv_44049;
  ldv_44049: 
#line 345 
  ;
  
#line 342 
  __retres = 0;
  return_label: 
#line 342 
                return __retres;
}


#line 356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
u32 *fm10k_tlv_attr_nest_start(u32 *msg, u16 attr_id)
{
  u32 *__retres;
  u32 *attr;
  
#line 361 
  if (msg == (u32 *)0U) {
    
#line 362 
    __retres = (u32 *)0U;
    
#line 362 
    goto return_label;
  }
  else ;
  
#line 364 
  attr = msg + ((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U);
  
#line 366 
  *attr = (unsigned int)attr_id;
  
#line 369 
  __retres = attr;
  return_label: 
#line 369 
                return __retres;
}


#line 381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_nest_stop(u32 *msg)
{
  s32 __retres;
  u32 *attr;
  u32 len;
  
#line 387 
  if (msg == (u32 *)0U) {
    
#line 388 
    __retres = -2;
    
#line 388 
    goto return_label;
  }
  else ;
  
#line 391 
  attr = msg + ((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U);
  
#line 392 
  len = *attr & 4293918720U;
  
#line 395 
  if (len != 0U) {
    
#line 396 
    len += 4194304U;
    
#line 397 
    *msg += len;
  }
  else ;
  
#line 400 
  __retres = 0;
  return_label: 
#line 400 
                return __retres;
}


#line 414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static s32 fm10k_tlv_attr_validate(u32 *attr, struct fm10k_tlv_attr const *tlv_attr)
{
  s32 __retres;
  
#line 417 
  u32 attr_id = *attr & 65535U;
  
#line 418 
  u16 len = (unsigned short)(*attr >> 20);
  
#line 421 
  if ((*attr & 65536U) != 0U) {
    
#line 422 
    __retres = -2;
    
#line 422 
    goto return_label;
  }
  else ;
  
#line 425 
  goto ldv_44067;
  ldv_44066: 
#line 426 
  ;
  
#line 426 
  tlv_attr += 1;
  ldv_44067: 
#line 427 
  ;
  
#line 425 
  if (tlv_attr->id < attr_id) 
#line 427 
                              goto ldv_44066; else 
#line 430 
                                                   goto ldv_44068;
  ldv_44068: 
#line 431 
  ;
  
#line 429 
  if (tlv_attr->id != attr_id) {
    
#line 430 
    __retres = 2147483647;
    
#line 430 
    goto return_label;
  }
  else ;
  
#line 433 
  attr += 1;
  
#line 435 
  switch ((unsigned int)tlv_attr->type) {
    case (unsigned int)0: 
#line 436 
    ;
    
#line 437 
    if ((unsigned int)len == 0U || (*(attr + ((int)len + -1) / 4) & (unsigned int)(255 << (((int)len + -1) % 4) * 8)) != 0U) {
      
#line 439 
      __retres = -2;
      
#line 439 
      goto return_label;
    }
    else ;
    
#line 440 
    if ((int)tlv_attr->len < (int)len) {
      
#line 441 
      __retres = -2;
      
#line 441 
      goto return_label;
    }
    else ;
    
#line 442 
    goto ldv_44070;
    case (unsigned int)1: 
#line 443 
    ;
    
#line 444 
    if ((unsigned int)len != 6U) {
      
#line 445 
      __retres = -2;
      
#line 445 
      goto return_label;
    }
    else ;
    
#line 446 
    goto ldv_44070;
    case (unsigned int)2: 
#line 447 
    ;
    
#line 448 
    if ((unsigned int)len != 0U) {
      
#line 449 
      __retres = -2;
      
#line 449 
      goto return_label;
    }
    else ;
    
#line 450 
    goto ldv_44070;
    case (unsigned int)3: 
#line 451 
    ;
    case (unsigned int)4: 
#line 452 
    ;
    
#line 453 
    if ((int)tlv_attr->len != (int)len) {
      
#line 454 
      __retres = -2;
      
#line 454 
      goto return_label;
    }
    else ;
    
#line 455 
    goto ldv_44070;
    case (unsigned int)5: 
#line 456 
    ;
    
#line 458 
    if (((unsigned int)len & 3U) != 0U || (int)tlv_attr->len != (int)len) {
      
#line 459 
      __retres = -2;
      
#line 459 
      goto return_label;
    }
    else ;
    
#line 460 
    goto ldv_44070;
    case (unsigned int)6: 
#line 461 
    ;
    
#line 463 
    if (((unsigned int)len & 3U) != 0U) {
      
#line 464 
      __retres = -2;
      
#line 464 
      goto return_label;
    }
    else ;
    
#line 465 
    goto ldv_44070;
    default: 
#line 466 
    ;
    
#line 468 
    __retres = -2;
    
#line 468 
    goto return_label;
  }
  ldv_44070: 
#line 471 
  ;
  
#line 471 
  __retres = 0;
  return_label: 
#line 471 
                return __retres;
}


#line 486  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_attr_parse(u32 *attr, u32 **results, struct fm10k_tlv_attr const *tlv_attr)
{
  s32 __retres;
  u32 i;
  u32 attr_id;
  u16 len;
  
#line 489 
  u32 offset = 0U;
  
#line 490 
  s32 err = 0;
  
#line 494 
  if (attr == (u32 *)0U || results == (u32 **)0U) {
    
#line 495 
    __retres = -2;
    
#line 495 
    goto return_label;
  }
  else ;
  
#line 498 
  i = 0U;
  
#line 498 
  goto ldv_44089;
  ldv_44088: 
#line 499 
  ;
  
#line 499 
  *(results + i) = (u32 *)0U;
  
#line 498 
  i += 1U;
  ldv_44089: 
#line 499 
  ;
  
#line 498 
  if (i <= 31U) 
#line 500 
                goto ldv_44088; else 
#line 503 
                                     goto ldv_44090;
  ldv_44090: 
#line 504 
  ;
  
#line 502 
  len = (unsigned short)(*attr >> 20);
  
#line 505 
  if ((unsigned int)len == 0U) {
    
#line 506 
    __retres = 0;
    
#line 506 
    goto return_label;
  }
  else ;
  
#line 509 
  if (tlv_attr == (struct fm10k_tlv_attr const *)0) {
    
#line 510 
    *results = attr;
    
#line 511 
    __retres = 0;
    
#line 511 
    goto return_label;
  }
  else ;
  
#line 515 
  attr += 1;
  
#line 518 
  goto ldv_44092;
  ldv_44091: 
#line 519 
  ;
  
#line 519 
  attr_id = *attr & 65535U;
  
#line 521 
  if (attr_id <= 31U) 
#line 522 
                      err = fm10k_tlv_attr_validate(attr,tlv_attr); else 
                                                                    
#line 524 
                                                                    err = 2147483647;
  
#line 526 
  if (err < 0) {
    
#line 527 
    __retres = err;
    
#line 527 
    goto return_label;
  }
  else ;
  
#line 528 
  if (err == 0) 
#line 529 
                *(results + attr_id) = attr; else ;
  
#line 532 
  offset = (unsigned int)(((int)((unsigned short)(((unsigned long)*attr + 3145728UL) >> 22)) + 1) * 4) + offset;
  
#line 535 
  attr += (unsigned int)((unsigned short)(((unsigned long)*attr + 3145728UL) >> 22)) + 1U;
  ldv_44092: 
#line 536 
  ;
  
#line 518 
  if ((unsigned int)len > offset) 
#line 520 
                                  goto ldv_44091; else 
#line 523 
                                                       goto ldv_44093;
  ldv_44093: 
#line 524 
  ;
  
#line 539 
  if ((unsigned int)len != offset) {
    
#line 540 
    __retres = -2;
    
#line 540 
    goto return_label;
  }
  else ;
  
#line 542 
  __retres = 0;
  return_label: 
#line 542 
                return __retres;
}


#line 558  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_msg_parse(struct fm10k_hw *hw, u32 *msg, struct fm10k_mbx_info *mbx, struct fm10k_msg_data const *data)
{
  s32 __retres;
  u32 *results[32U];
  u32 msg_id;
  s32 err;
  s32 tmp;
  
#line 567 
  if (msg == (u32 *)0U || data == (struct fm10k_msg_data const *)0) {
    
#line 568 
    __retres = -2;
    
#line 568 
    goto return_label;
  }
  else ;
  
#line 571 
  if ((*msg & 65536U) == 0U) {
    
#line 572 
    __retres = -2;
    
#line 572 
    goto return_label;
  }
  else ;
  
#line 575 
  msg_id = *msg & 65535U;
  
#line 577 
  goto ldv_44104;
  ldv_44103: 
#line 578 
  ;
  
#line 578 
  data += 1;
  ldv_44104: 
#line 579 
  ;
  
#line 577 
  if (data->id < msg_id) 
#line 579 
                         goto ldv_44103; else 
#line 582 
                                              goto ldv_44105;
  ldv_44105: 
#line 583 
  ;
  
#line 581 
  if (data->id != msg_id) {
    
#line 582 
    goto ldv_44107;
    ldv_44106: 
#line 583 
    ;
    
#line 583 
    data += 1;
    ldv_44107: 
#line 584 
    ;
    
#line 582 
    if (data->id != 4294967295U) 
#line 584 
                                 goto ldv_44106; else 
#line 587 
                                                      goto ldv_44108;
    ldv_44108: 
#line 588 
    ;
  }
  else ;
  
#line 587 
  err = fm10k_tlv_attr_parse(msg,(u32 **)(& results),data->attr);
  
#line 588 
  if (err < 0) {
    
#line 589 
    __retres = err;
    
#line 589 
    goto return_label;
  }
  else ;
  
#line 591 
  tmp = (*(data->func))(hw,(u32 **)(& results),mbx);
  
#line 591 
  __retres = tmp;
  return_label: 
#line 591 
                return __retres;
}


#line 604  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_msg_error(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  
#line 607 
  __retres = 2147483647;
  
#line 607 
  return __retres;
}


#line 610  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static unsigned char const test_str[6U] = {(unsigned char)'f', (unsigned char)'m', (unsigned char)'1', (unsigned char)'0', (unsigned char)'k', (unsigned char)'\000'};

#line 611  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static unsigned char const test_mac[6U] = {(unsigned char)18U, (unsigned char)52U, (unsigned char)86U, (unsigned char)120U, (unsigned char)154U, (unsigned char)188U};

#line 613  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static u16 const test_vlan = (unsigned short)4077U;

#line 614  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static u64 const test_u64 = 18364758544493064720ULL;

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static u32 const test_u32 = 2271560481U;

#line 616  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static u16 const test_u16 = (unsigned short)34661U;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static u8 const test_u8 = (unsigned char)135U;

#line 618  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static s64 const test_s64 = -1311768467463790320LL;

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static s32 const test_s32 = -19093112;

#line 620  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static s16 const test_s16 = (short)(-4660);

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static s8 const test_s8 = (signed char)(-18);

#line 622  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static __le32 const test_le[2U] = {305419896U, 2596069104U};

#line 629  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
struct fm10k_tlv_attr const fm10k_tlv_msg_test_attr[14U] = {{.id = 1U, .type = FM10K_TLV_NULL_STRING, .len = (unsigned short)80U}, {.id = 2U, .type = FM10K_TLV_MAC_ADDR, .len = (unsigned short)6U}, {.id = 3U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)1U}, {.id = 4U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)2U}, {.id = 5U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)4U}, {.id = 6U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)8U}, {.id = 7U, .type = FM10K_TLV_SIGNED, .len = (unsigned short)1U}, {.id = 8U, .type = FM10K_TLV_SIGNED, .len = (unsigned short)2U}, {.id = 9U, .type = FM10K_TLV_SIGNED, .len = (unsigned short)4U}, {.id = 10U, .type = FM10K_TLV_SIGNED, .len = (unsigned short)8U}, {.id = 11U, .type = FM10K_TLV_LE_STRUCT, .len = (unsigned short)8U}, {.id = 12U, .type = FM10K_TLV_NESTED, .len = (unsigned short)0}, {.id = 13U, .type = FM10K_TLV_SIGNED, .len = (unsigned short)4U}, {.id = 4294967295U, .type = 0, .len = (unsigned short)0}};

#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
static void fm10k_tlv_msg_test_generate_data(u32 *msg, u32 attr_flags)
{
  
#line 655 
  if ((attr_flags & 2U) != 0U) 
#line 656 
                               fm10k_tlv_attr_put_null_string(msg,(unsigned short)1,(unsigned char const *)(& test_str)); else ;
  
#line 658 
  if ((attr_flags & 4U) != 0U) 
#line 659 
                               fm10k_tlv_attr_put_mac_vlan(msg,(unsigned short)2,(u8 const *)(& test_mac),(unsigned short)((int)test_vlan)); else ;
  
#line 661 
  if ((attr_flags & 8U) != 0U) 
#line 662 
                               fm10k_tlv_attr_put_value(msg,(unsigned short)3,(long long)test_u8,1U); else ;
  
#line 663 
  if ((attr_flags & 16U) != 0U) 
#line 664 
                                fm10k_tlv_attr_put_value(msg,(unsigned short)4,(long long)test_u16,2U); else ;
  
#line 665 
  if ((attr_flags & 32U) != 0U) 
#line 666 
                                fm10k_tlv_attr_put_value(msg,(unsigned short)5,(long long)test_u32,4U); else ;
  
#line 667 
  if ((attr_flags & 64U) != 0U) 
#line 668 
                                fm10k_tlv_attr_put_value(msg,(unsigned short)6,(long long)test_u64,8U); else ;
  
#line 669 
  if ((attr_flags & 128U) != 0U) 
#line 670 
                                 fm10k_tlv_attr_put_value(msg,(unsigned short)7,(long long)test_s8,1U); else ;
  
#line 671 
  if ((attr_flags & 256U) != 0U) 
#line 672 
                                 fm10k_tlv_attr_put_value(msg,(unsigned short)8,(long long)test_s16,2U); else ;
  
#line 673 
  if ((attr_flags & 512U) != 0U) 
#line 674 
                                 fm10k_tlv_attr_put_value(msg,(unsigned short)9,(long long)test_s32,4U); else ;
  
#line 675 
  if ((attr_flags & 1024U) != 0U) 
#line 676 
                                  fm10k_tlv_attr_put_value(msg,(unsigned short)10,test_s64,8U); else ;
  
#line 677 
  if ((attr_flags & 2048U) != 0U) 
#line 678 
                                  fm10k_tlv_attr_put_le_struct(msg,(unsigned short)11,(void const *)(& test_le),8U); else ;
  
#line 680 
  return;
}


#line 690  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
void fm10k_tlv_msg_test_create(u32 *msg, u32 attr_flags)
{
  
#line 692 
  u32 *nest = (u32 *)0U;
  
#line 694 
  fm10k_tlv_msg_init(msg,(unsigned short)0);
  
#line 696 
  fm10k_tlv_msg_test_generate_data(msg,attr_flags);
  
#line 699 
  attr_flags >>= 12;
  
#line 701 
  if (attr_flags != 0U) {
    
#line 702 
    nest = fm10k_tlv_attr_nest_start(msg,(unsigned short)12);
    
#line 704 
    fm10k_tlv_msg_test_generate_data(nest,attr_flags);
    
#line 706 
    fm10k_tlv_attr_nest_stop(msg);
  }
  else ;
  
#line 708 
  return;
}


#line 720  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_tlv.c"
s32 fm10k_tlv_msg_test(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u32 *nest_results[32U];
  unsigned char result_str[80U];
  unsigned char result_mac[6U];
  __le32 result_le[2U];
  u16 result_vlan;
  u64 result_u64;
  u32 result_u32;
  u16 result_u16;
  u8 result_u8;
  s64 result_s64;
  s32 result_s32;
  s16 result_s16;
  s8 result_s8;
  u32 reply[3U];
  s32 tmp_3;
  
#line 726 
  s32 err = 0;
  
#line 740 
  if (*(results + 13U) != (u32 *)0U) {
    s32 tmp;
    
#line 741 
    tmp = fm10k_tlv_attr_get_value(*(results + 13U),(void *)(& mbx->test_result),4U);
    
#line 741 
    __retres = tmp;
    
#line 741 
    goto return_label;
  }
  else ;
  parse_nested: 
#line 744 
  ;
  
#line 745 
  if (*(results + 1U) != (u32 *)0U) {
    
#line 746 
    err = fm10k_tlv_attr_get_null_string(*(results + 1U),(unsigned char *)(& result_str));
    
#line 749 
    if (err == 0) {
      int tmp_0;
      
#line 749 
      tmp_0 = memcmp((void const *)(& test_str),(void const *)(& result_str),6UL);
      
#line 749 
      if (tmp_0 != 0) 
#line 750 
                      err = -9; else ;
    }
    else ;
    
#line 751 
    if (err != 0) 
#line 752 
                  goto report_result; else ;
  }
  else ;
  
#line 754 
  if (*(results + 2U) != (u32 *)0U) {
    
#line 755 
    err = fm10k_tlv_attr_get_mac_vlan(*(results + 2U),(u8 *)(& result_mac),& result_vlan);
    
#line 758 
    if (err == 0) {
      int tmp_1;
      
#line 758 
      tmp_1 = memcmp((void const *)(& test_mac),(void const *)(& result_mac),6UL);
      
#line 758 
      if (tmp_1 != 0) 
#line 759 
                      err = -9; else ;
    }
    else ;
    
#line 760 
    if (err == 0 && (unsigned int)result_vlan != 4077U) 
#line 761 
                                                        err = -9; else ;
    
#line 762 
    if (err != 0) 
#line 763 
                  goto report_result; else ;
  }
  else ;
  
#line 765 
  if (*(results + 3U) != (u32 *)0U) {
    
#line 766 
    err = fm10k_tlv_attr_get_value(*(results + 3U),(void *)(& result_u8),1U);
    
#line 768 
    if (err == 0 && (unsigned int)result_u8 != 135U) 
#line 769 
                                                     err = -9; else ;
    
#line 770 
    if (err != 0) 
#line 771 
                  goto report_result; else ;
  }
  else ;
  
#line 773 
  if (*(results + 4U) != (u32 *)0U) {
    
#line 774 
    err = fm10k_tlv_attr_get_value(*(results + 4U),(void *)(& result_u16),2U);
    
#line 776 
    if (err == 0 && (unsigned int)result_u16 != 34661U) 
#line 777 
                                                        err = -9; else ;
    
#line 778 
    if (err != 0) 
#line 779 
                  goto report_result; else ;
  }
  else ;
  
#line 781 
  if (*(results + 5U) != (u32 *)0U) {
    
#line 782 
    err = fm10k_tlv_attr_get_value(*(results + 5U),(void *)(& result_u32),4U);
    
#line 784 
    if (err == 0 && result_u32 != 2271560481U) 
#line 785 
                                               err = -9; else ;
    
#line 786 
    if (err != 0) 
#line 787 
                  goto report_result; else ;
  }
  else ;
  
#line 789 
  if (*(results + 6U) != (u32 *)0U) {
    
#line 790 
    err = fm10k_tlv_attr_get_value(*(results + 6U),(void *)(& result_u64),8U);
    
#line 792 
    if (err == 0 && result_u64 != 18364758544493064720ULL) 
#line 793 
                                                           err = -9; else ;
    
#line 794 
    if (err != 0) 
#line 795 
                  goto report_result; else ;
  }
  else ;
  
#line 797 
  if (*(results + 7U) != (u32 *)0U) {
    
#line 798 
    err = fm10k_tlv_attr_get_value(*(results + 7U),(void *)(& result_s8),1U);
    
#line 800 
    if (err == 0 && (int)result_s8 != -18) 
#line 801 
                                           err = -9; else ;
    
#line 802 
    if (err != 0) 
#line 803 
                  goto report_result; else ;
  }
  else ;
  
#line 805 
  if (*(results + 8U) != (u32 *)0U) {
    
#line 806 
    err = fm10k_tlv_attr_get_value(*(results + 8U),(void *)(& result_s16),2U);
    
#line 808 
    if (err == 0 && (int)result_s16 != -4660) 
#line 809 
                                              err = -9; else ;
    
#line 810 
    if (err != 0) 
#line 811 
                  goto report_result; else ;
  }
  else ;
  
#line 813 
  if (*(results + 9U) != (u32 *)0U) {
    
#line 814 
    err = fm10k_tlv_attr_get_value(*(results + 9U),(void *)(& result_s32),4U);
    
#line 816 
    if (err == 0 && result_s32 != -19093112) 
#line 817 
                                             err = -9; else ;
    
#line 818 
    if (err != 0) 
#line 819 
                  goto report_result; else ;
  }
  else ;
  
#line 821 
  if (*(results + 10U) != (u32 *)0U) {
    
#line 822 
    err = fm10k_tlv_attr_get_value(*(results + 10U),(void *)(& result_s64),8U);
    
#line 824 
    if (err == 0 && result_s64 != -1311768467463790320LL) 
#line 825 
                                                          err = -9; else ;
    
#line 826 
    if (err != 0) 
#line 827 
                  goto report_result; else ;
  }
  else ;
  
#line 829 
  if (*(results + 11U) != (u32 *)0U) {
    
#line 830 
    err = fm10k_tlv_attr_get_le_struct(*(results + 11U),(void *)(& result_le),8U);
    
#line 834 
    if (err == 0) {
      int tmp_2;
      
#line 834 
      tmp_2 = memcmp((void const *)(& test_le),(void const *)(& result_le),8UL);
      
#line 834 
      if (tmp_2 != 0) 
#line 835 
                      err = -9; else ;
    }
    else ;
    
#line 836 
    if (err != 0) 
#line 837 
                  goto report_result; else ;
  }
  else ;
  
#line 840 
  if (*(results + 12U) != (u32 *)0U) {
    
#line 842 
    memset((void *)(& nest_results),0,256UL);
    
#line 845 
    err = fm10k_tlv_attr_parse(*(results + 12U),(u32 **)(& nest_results),(struct fm10k_tlv_attr const *)(& fm10k_tlv_msg_test_attr));
    
#line 848 
    if (err != 0) 
#line 849 
                  goto report_result; else ;
    
#line 852 
    results = (u32 **)(& nest_results);
    
#line 853 
    goto parse_nested;
  }
  else ;
  report_result: 
#line 856 
  ;
  
#line 858 
  fm10k_tlv_msg_init((u32 *)(& reply),(unsigned short)0);
  
#line 859 
  fm10k_tlv_attr_put_value((u32 *)(& reply),(unsigned short)13,(long long)err,4U);
  
#line 862 
  tmp_3 = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& reply));
  
#line 862 
  __retres = tmp_3;
  return_label: 
#line 862 
                return __retres;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int sprintf(char *, char const * , ...);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
static int ldv_seq_open_73(struct file *ldv_func_arg1, struct seq_operations const *ldv_func_arg2);


#line 118 
ssize_t seq_read(struct file *, char *, size_t, loff_t *);


#line 119 
loff_t seq_lseek(struct file *, loff_t, int);


#line 120 
int seq_release(struct inode *, struct file *);


#line 123 
int seq_puts(struct seq_file *, char const *);


#line 126 
int seq_printf(struct seq_file *, char const * , ...);


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static char const *pci_name(struct pci_dev const *pdev)
{
  char const *tmp;
  
#line 1486 
  tmp = dev_name(& pdev->dev);
  
#line 1486 
  return tmp;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
char fm10k_driver_name[6U];


#line 504 
void fm10k_dbg_q_vector_init(struct fm10k_q_vector *q_vector);


#line 505 
void fm10k_dbg_q_vector_exit(struct fm10k_q_vector *q_vector);


#line 506 
void fm10k_dbg_intfc_init(struct fm10k_intfc *interface);


#line 507 
void fm10k_dbg_intfc_exit(struct fm10k_intfc *interface);


#line 508 
void fm10k_dbg_init(void);


#line 509 
void fm10k_dbg_exit(void);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_74(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_75(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 66 
struct dentry *debugfs_create_dir(char const *, struct dentry *);


#line 77 
void debugfs_remove_recursive(struct dentry *);


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static struct dentry *dbg_root;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static void *fm10k_dbg_desc_seq_start(struct seq_file *s, loff_t *pos)
{
  void *__retres;
  loff_t *tmp;
  
#line 34 
  struct fm10k_ring *ring = (struct fm10k_ring *)s->private;
  
#line 36 
  if (*pos < (long long)ring->count) 
#line 36 
                                     tmp = pos; else 
#line 36 
                                                     tmp = (loff_t *)0LL;
  
#line 36 
  __retres = (void *)tmp;
  
#line 36 
  return __retres;
}


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static void *fm10k_dbg_desc_seq_next(struct seq_file *s, void *v, loff_t *pos)
{
  void *__retres;
  loff_t *tmp;
  
#line 42 
  struct fm10k_ring *ring = (struct fm10k_ring *)s->private;
  
#line 44 
  *pos += 1LL;
  
#line 44 
  ;
  
#line 44 
  if (*pos < (long long)ring->count) 
#line 44 
                                     tmp = pos; else 
#line 44 
                                                     tmp = (loff_t *)0LL;
  
#line 44 
  __retres = (void *)tmp;
  
#line 44 
  return __retres;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static void fm10k_dbg_desc_seq_stop(struct seq_file *s, void *v)
{
  
#line 49 
  return;
}


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static void fm10k_dbg_desc_break(struct seq_file *s, int i)
{
  int tmp;
  
#line 55 
  goto ldv_47149;
  ldv_47148: 
#line 56 
  ;
  
#line 56 
  seq_puts(s,"-");
  ldv_47149: 
#line 57 
  ;
  
#line 55 
  tmp = i;
  
#line 55 
  i -= 1;
  
#line 55 
  ;
  
#line 55 
  if (tmp != 0) 
#line 57 
                goto ldv_47148; else 
#line 60 
                                     goto ldv_47150;
  ldv_47150: 
#line 61 
  ;
  
#line 58 
  seq_puts(s,"\n");
  
#line 59 
  return;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static int fm10k_dbg_tx_desc_seq_show(struct seq_file *s, void *v)
{
  int __retres;
  
#line 63 
  struct fm10k_ring *ring = (struct fm10k_ring *)s->private;
  
#line 64 
  int i = (int)*((loff_t *)v);
  
#line 65 
  char const tx_desc_hdr[58U] = {(char)'D', (char)'E', (char)'S', (char)' ', (char)'B', (char)'U', (char)'F', (char)'F', (char)'E', (char)'R', (char)'_', (char)'A', (char)'D', (char)'D', (char)'R', (char)'E', (char)'S', (char)'S', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)'L', (char)'E', (char)'N', (char)'G', (char)'T', (char)'H', (char)' ', (char)'V', (char)'L', (char)'A', (char)'N', (char)' ', (char)' ', (char)' ', (char)'M', (char)'S', (char)'S', (char)' ', (char)' ', (char)' ', (char)' ', (char)'H', (char)'D', (char)'R', (char)'L', (char)'E', (char)'N', (char)' ', (char)'F', (char)'L', (char)'A', (char)'G', (char)'S', (char)'\n', (char)'\000'};
  
#line 69 
  if (i == 0) {
    
#line 70 
    seq_printf(s,(char const *)(& tx_desc_hdr));
    
#line 71 
    fm10k_dbg_desc_break(s,57);
  }
  else ;
  
#line 75 
  if (ring->desc == (void *)0) 
#line 76 
                               seq_printf(s,"%03X Descriptor ring not allocated.\n",i);
  else {
    
#line 78 
    struct fm10k_tx_desc *txd = (struct fm10k_tx_desc *)ring->desc + i;
    
#line 80 
    seq_printf(s,"%03X %#018llx %#06x %#06x %#06x %#06x %#04x\n",i,txd->buffer_addr,(int)txd->buflen,(int)txd->vlan,(int)txd->mss,(int)txd->hdrlen,(int)txd->flags);
  }
  
#line 85 
  __retres = 0;
  
#line 85 
  return __retres;
}


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static int fm10k_dbg_rx_desc_seq_show(struct seq_file *s, void *v)
{
  int __retres;
  
#line 90 
  struct fm10k_ring *ring = (struct fm10k_ring *)s->private;
  
#line 91 
  int i = (int)*((loff_t *)v);
  
#line 92 
  char const rx_desc_hdr[76U] = {(char)'D', (char)'E', (char)'S', (char)' ', (char)'D', (char)'A', (char)'T', (char)'A', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)'R', (char)'S', (char)'S', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)'S', (char)'T', (char)'A', (char)'T', (char)'E', (char)'R', (char)'R', (char)' ', (char)' ', (char)' ', (char)' ', (char)'L', (char)'E', (char)'N', (char)'G', (char)'T', (char)'H', (char)' ', (char)'V', (char)'L', (char)'A', (char)'N', (char)' ', (char)' ', (char)' ', (char)'D', (char)'G', (char)'L', (char)'O', (char)'R', (char)'T', (char)' ', (char)'S', (char)'G', (char)'L', (char)'O', (char)'R', (char)'T', (char)' ', (char)'T', (char)'I', (char)'M', (char)'E', (char)'S', (char)'T', (char)'A', (char)'M', (char)'P', (char)'\n', (char)'\000'};
  
#line 96 
  if (i == 0) {
    
#line 97 
    seq_printf(s,(char const *)(& rx_desc_hdr));
    
#line 98 
    fm10k_dbg_desc_break(s,75);
  }
  else ;
  
#line 102 
  if (ring->desc == (void *)0) 
#line 103 
                               seq_printf(s,"%03X Descriptor ring not allocated.\n",i);
  else {
    
#line 105 
    union fm10k_rx_desc *rxd = (union fm10k_rx_desc *)ring->desc + i;
    
#line 107 
    seq_printf(s,"%03X %#010x %#010x %#010x %#06x %#06x %#06x %#06x %#018llx\n",i,rxd->d.data,rxd->d.rss,rxd->d.staterr,(int)rxd->w.length,(int)rxd->w.vlan,(int)rxd->w.dglort,(int)rxd->w.sglort,rxd->q.timestamp);
  }
  
#line 114 
  __retres = 0;
  
#line 114 
  return __retres;
}


#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static struct seq_operations const fm10k_dbg_tx_desc_seq_ops = {.start = & fm10k_dbg_desc_seq_start, .stop = & fm10k_dbg_desc_seq_stop, .next = & fm10k_dbg_desc_seq_next, .show = & fm10k_dbg_tx_desc_seq_show};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static struct seq_operations const fm10k_dbg_rx_desc_seq_ops = {.start = & fm10k_dbg_desc_seq_start, .stop = & fm10k_dbg_desc_seq_stop, .next = & fm10k_dbg_desc_seq_next, .show = & fm10k_dbg_rx_desc_seq_show};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static int fm10k_dbg_desc_open(struct inode *inode, struct file *filep)
{
  int __retres;
  struct seq_operations const *desc_seq_ops;
  int err;
  
#line 133 
  struct fm10k_ring *ring = (struct fm10k_ring *)inode->i_private;
  
#line 134 
  struct fm10k_q_vector *q_vector = ring->q_vector;
  
#line 138 
  if (q_vector->rx.ring > ring) 
#line 139 
                                desc_seq_ops = & fm10k_dbg_tx_desc_seq_ops; else 
                                                                    
#line 141 
                                                                    desc_seq_ops = & fm10k_dbg_rx_desc_seq_ops;
  
#line 143 
  err = ldv_seq_open_73(filep,desc_seq_ops);
  
#line 144 
  if (err != 0) {
    
#line 145 
    __retres = err;
    
#line 145 
    goto return_label;
  }
  else ;
  
#line 147 
  ((struct seq_file *)filep->private_data)->private = (void *)ring;
  
#line 149 
  __retres = 0;
  return_label: 
#line 149 
                return __retres;
}


#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
static struct file_operations const fm10k_dbg_desc_fops = {.owner = & __this_module, .llseek = & seq_lseek, .read = & seq_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & fm10k_dbg_desc_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = & seq_release, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
void fm10k_dbg_q_vector_init(struct fm10k_q_vector *q_vector)
{
  char name[16U];
  int i;
  
#line 170 
  struct fm10k_intfc *interface = q_vector->interface;
  
#line 174 
  if (interface->dbg_intfc == (struct dentry *)0) 
#line 175 
                                                  goto return_label; else ;
  
#line 178 
  sprintf((char *)(& name),"q_vector.%03d",(int)q_vector->v_idx);
  
#line 180 
  q_vector->dbg_q_vector = debugfs_create_dir((char const *)(& name),interface->dbg_intfc);
  
#line 181 
  if (q_vector->dbg_q_vector == (struct dentry *)0) 
#line 182 
                                                    goto return_label; else ;
  
#line 185 
  i = 0;
  
#line 185 
  goto ldv_47186;
  ldv_47185: 
#line 186 
  ;
  {
    
#line 186 
    struct fm10k_ring *ring = q_vector->tx.ring + i;
    
#line 188 
    sprintf((char *)(& name),"tx_ring.%03d",(int)ring->queue_index);
    
#line 190 
    ldv_debugfs_create_file_74((char const *)(& name),(unsigned short)384,q_vector->dbg_q_vector,(void *)ring,& fm10k_dbg_desc_fops);
  }
  
#line 185 
  i += 1;
  ldv_47186: 
#line 186 
  ;
  
#line 185 
  if ((int)q_vector->tx.count > i) 
#line 187 
                                   goto ldv_47185; else 
#line 190 
                                                        goto ldv_47187;
  ldv_47187: 
#line 191 
  ;
  
#line 196 
  i = 0;
  
#line 196 
  goto ldv_47190;
  ldv_47189: 
#line 197 
  ;
  {
    
#line 197 
    struct fm10k_ring *ring_0 = q_vector->rx.ring + i;
    
#line 199 
    sprintf((char *)(& name),"rx_ring.%03d",(int)ring_0->queue_index);
    
#line 201 
    ldv_debugfs_create_file_75((char const *)(& name),(unsigned short)384,q_vector->dbg_q_vector,(void *)ring_0,& fm10k_dbg_desc_fops);
  }
  
#line 196 
  i += 1;
  ldv_47190: 
#line 197 
  ;
  
#line 196 
  if ((int)q_vector->rx.count > i) 
#line 198 
                                   goto ldv_47189; else 
#line 201 
                                                        goto ldv_47191;
  ldv_47191: 
#line 202 
  ;
  return_label: 
#line 203 
                return;
}


#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
void fm10k_dbg_q_vector_exit(struct fm10k_q_vector *q_vector)
{
  
#line 213 
  struct fm10k_intfc *interface = q_vector->interface;
  
#line 215 
  if (interface->dbg_intfc != (struct dentry *)0) 
#line 216 
                                                  debugfs_remove_recursive(q_vector->dbg_q_vector); else ;
  
#line 217 
  q_vector->dbg_q_vector = (struct dentry *)0;
  
#line 218 
  return;
}


#line 225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
void fm10k_dbg_intfc_init(struct fm10k_intfc *interface)
{
  
#line 227 
  char const *name = pci_name((struct pci_dev const *)interface->pdev);
  
#line 229 
  if (dbg_root != (struct dentry *)0) 
#line 230 
                                      interface->dbg_intfc = debugfs_create_dir(name,dbg_root); else ;
  
#line 231 
  return;
}


#line 237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
void fm10k_dbg_intfc_exit(struct fm10k_intfc *interface)
{
  
#line 239 
  if (dbg_root != (struct dentry *)0) 
#line 240 
                                      debugfs_remove_recursive(interface->dbg_intfc); else ;
  
#line 241 
  interface->dbg_intfc = (struct dentry *)0;
  
#line 242 
  return;
}


#line 247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
void fm10k_dbg_init(void)
{
  
#line 249 
  dbg_root = debugfs_create_dir((char const *)(& fm10k_driver_name),(struct dentry *)0);
  
#line 250 
  return;
}


#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_debugfs.c"
void fm10k_dbg_exit(void)
{
  
#line 257 
  debugfs_remove_recursive(dbg_root);
  
#line 258 
  dbg_root = (struct dentry *)0;
  
#line 259 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
int (*ldv_emg_alias_seq_release_4)(struct inode *, struct file *) = & seq_release;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
long long (*ldv_emg_alias_seq_lseek_2)(struct file *, long long , int ) = & seq_lseek;

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
struct file_operations *ldv_emg_alias_fm10k_dbg_desc_fops_2 = (struct file_operations *)(& fm10k_dbg_desc_fops);

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
long (*ldv_emg_alias_seq_read_3)(struct file *, char *, unsigned long , long long *) = & seq_read;

#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
struct seq_operations *ldv_emg_alias_fm10k_dbg_rx_desc_seq_ops_6 = (struct seq_operations *)(& fm10k_dbg_rx_desc_seq_ops);

#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
struct seq_operations *ldv_emg_alias_fm10k_dbg_tx_desc_seq_ops_3 = (struct seq_operations *)(& fm10k_dbg_tx_desc_seq_ops);

#line 66 
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4);


#line 69 
int ldv_emg_seq_open(struct file *arg0, struct seq_operations *arg1);


#line 80  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
int ldv_emg_wrapper_fm10k_dbg_desc_open_5(struct inode *arg0, struct file *arg1)
{
  int tmp;
  
#line 81 
  tmp = fm10k_dbg_desc_open(arg0,arg1);
  
#line 81 
  return tmp;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
void *ldv_emg_wrapper_fm10k_dbg_desc_seq_start_2(struct seq_file *arg0, long long *arg1)
{
  void *tmp;
  
#line 86 
  tmp = fm10k_dbg_desc_seq_start(arg0,arg1);
  
#line 86 
  return tmp;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
void *ldv_emg_wrapper_fm10k_dbg_desc_seq_next_3(struct seq_file *arg0, void *arg1, long long *arg2)
{
  void *tmp;
  
#line 91 
  tmp = fm10k_dbg_desc_seq_next(arg0,arg1,arg2);
  
#line 91 
  return tmp;
}


#line 95  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
void ldv_emg_wrapper_fm10k_dbg_desc_seq_stop_5(struct seq_file *arg0, void *arg1)
{
  
#line 96 
  fm10k_dbg_desc_seq_stop(arg0,arg1);
  
#line 97 
  return;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
int ldv_emg_wrapper_fm10k_dbg_rx_desc_seq_show_4(struct seq_file *arg0, void *arg1)
{
  int tmp;
  
#line 101 
  tmp = fm10k_dbg_rx_desc_seq_show(arg0,arg1);
  
#line 101 
  return tmp;
}


#line 105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
int ldv_emg_wrapper_fm10k_dbg_tx_desc_seq_show_2(struct seq_file *arg0, void *arg1)
{
  int tmp;
  
#line 106 
  tmp = fm10k_dbg_tx_desc_seq_show(arg0,arg1);
  
#line 106 
  return tmp;
}


#line 789  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
static int ldv_seq_open_73(struct file *ldv_func_arg1, struct seq_operations const *ldv_func_arg2)
{
  int tmp;
  
#line 793 
  tmp = ldv_emg_seq_open(ldv_func_arg1,(struct seq_operations *)ldv_func_arg2);
  
#line 793 
  return tmp;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_74(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 801 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 801 
  return tmp;
}


#line 805  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_75(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 809 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 809 
  return tmp;
}

void __builtin_unreachable(void);


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned long __arch_hweight64(__u64 w)
{
  
#line 47 
  unsigned long res = 0UL;
  
#line 48 
  ldv_inline_asm();
  
#line 58 
  return res;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitops.h"
__inline static unsigned long hweight_long(unsigned long w)
{
  unsigned long tmp_0;
  
#line 80 
  if (0 != 0) 
#line 80 
              tmp_0 = (unsigned long)((((unsigned int)((((((((((unsigned long long)w & 1ULL) != 0ULL) + (((unsigned long long)w & 2ULL) != 0ULL)) + (((unsigned long long)w & 4ULL) != 0ULL)) + (((unsigned long long)w & 8ULL) != 0ULL)) + (((unsigned long long)w & 16ULL) != 0ULL)) + (((unsigned long long)w & 32ULL) != 0ULL)) + (((unsigned long long)w & 64ULL) != 0ULL)) + (((unsigned long long)w & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 8) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 8) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(w >> 16) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 16) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 24) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 24) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 128ULL) != 0ULL)))) + (((unsigned int)((((((((((unsigned long long)(w >> 32) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 32) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 40) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 40) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(w >> 48) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 48) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 56) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 56) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 128ULL) != 0ULL))))); else 
                                                                    
#line 80 
                                                                    tmp_0 = __arch_hweight64((unsigned long long)w);
  
#line 80 
  return tmp_0;
}


#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int snprintf(char *, size_t, char const * , ...);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-defs.h"
void __bad_size_call_parameter(void);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
int __bitmap_weight(unsigned long const *, unsigned int);


#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const *src, unsigned int nbits)
{
  int __retres;
  int tmp_0;
  
#line 300 
  if (0 != 0 && nbits <= 64U) {
    unsigned long tmp;
    
#line 301 
    tmp = hweight_long(*src & (18446744073709551615UL >> (- nbits & 63U)));
    
#line 301 
    __retres = (int)tmp;
    
#line 301 
    goto return_label;
  }
  else ;
  
#line 302 
  tmp_0 = __bitmap_weight(src,nbits);
  
#line 302 
  __retres = tmp_0;
  return_label: 
#line 302 
                return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
extern int nr_cpu_ids;


#line 89 
extern struct cpumask const * const cpu_online_mask;


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask const *srcp)
{
  unsigned int __retres;
  int tmp;
  
#line 476 
  tmp = bitmap_weight((unsigned long const *)(& srcp->bits),(unsigned int)nr_cpu_ids);
  
#line 476 
  __retres = (unsigned int)tmp;
  
#line 476 
  return __retres;
}


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  int __retres;
  int tmp;
  {
    int pfo_ret__;
    
#line 22 
    switch (4UL) {
      case (unsigned long)1: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)2: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)4: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)8: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      default: 
#line 22 
      ;
      
#line 22 
      __bad_percpu_size();
    }
    ldv_6320: 
#line 22 
    ;
    
#line 22 
    tmp = pfo_ret__;
  }
  
#line 22 
  __retres = tmp & 2147483647;
  
#line 22 
  return __retres;
}


#line 7  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
void __local_bh_disable_ip(unsigned long, unsigned int);


#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_disable(void)
{
  __here_0: 
#line 18 
  ;
  
#line 18 
  __local_bh_disable_ip((unsigned long)((void *)0),512U);
  
#line 20 
  return;
}


#line 22 
void __local_bh_enable_ip(unsigned long, unsigned int);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_enable(void)
{
  __here_0: 
#line 31 
  ;
  
#line 31 
  __local_bh_enable_ip((unsigned long)((void *)0),512U);
  
#line 33 
  return;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_61(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_64(spinlock_t *lock);


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
void ldv_spin_model_lock(char *);


#line 75 
void ldv_spin_model_unlock(char *);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 173 
static int ldv_mod_timer_74(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 177 
static int ldv_mod_timer_81(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 181 
static int ldv_mod_timer_82(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_85(struct timer_list *ldv_func_arg1);


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void __init_work(struct work_struct *, int);


#line 444 
bool cancel_work_sync(struct work_struct *);


#line 490 
static bool ldv_queue_work_73(struct workqueue_struct *wq, struct work_struct *work);


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile *addr)
{
  unsigned int ret;
  
#line 59 
  ldv_inline_asm();
  
#line 58 
  return ret;
}


#line 181 
void *ioremap_nocache(resource_size_t, unsigned long);


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset, unsigned long size)
{
  void *tmp;
  
#line 192 
  tmp = ioremap_nocache(offset,size);
  
#line 192 
  return tmp;
}


#line 195 
void iounmap(void volatile *);


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/aer.h"
int pci_enable_pcie_error_reporting(struct pci_dev *);


#line 43 
int pci_disable_pcie_error_reporting(struct pci_dev *);


#line 44 
int pci_cleanup_aer_uncorrect_error_status(struct pci_dev *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
void get_random_bytes(void *, int);


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 1085 
void dev_warn(struct device const *, char const * , ...);


#line 1089 
void _dev_info(struct device const *, char const * , ...);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static u64 dma_get_mask(struct device *dev)
{
  u64 __retres;
  
#line 93 
  if ((dev != (struct device *)0 && dev->dma_mask != (u64 *)0ULL) && *(dev->dma_mask) != 0ULL) {
    
#line 94 
    __retres = *(dev->dma_mask);
    
#line 94 
    goto return_label;
  }
  else ;
  
#line 95 
  __retres = 4294967295ULL;
  return_label: 
#line 95 
                return __retres;
}


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
  
#line 118 
  int rc = dma_set_mask(dev,mask);
  
#line 119 
  if (rc == 0) 
#line 120 
               dma_set_coherent_mask(dev,mask); else ;
  
#line 121 
  return rc;
}


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
void usleep_range(unsigned long, unsigned long);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_76(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 145 
static int ldv_request_irq_77(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 149 
static int ldv_request_irq_79(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 161 
static void ldv_free_irq_75(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 165 
static void ldv_free_irq_78(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 169 
static void ldv_free_irq_80(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __napi_schedule(struct napi_struct *);


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n)
{
  bool __retres;
  int tmp;
  
#line 396 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& n->state));
  
#line 396 
  __retres = (_Bool)(tmp != 0);
  
#line 396 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n)
{
  bool __retres;
  int tmp_2;
  int tmp_0;
  bool tmp;
  
#line 410 
  tmp = napi_disable_pending(n);
  
#line 410 
  if (tmp) 
#line 410 
           tmp_0 = 0; else 
#line 410 
                           tmp_0 = 1;
  
#line 410 
  if (tmp_0) {
    int tmp_1;
    
#line 410 
    tmp_1 = test_and_set_bit(0L,(unsigned long volatile *)(& n->state));
    
#line 410 
    if (tmp_1 == 0) 
#line 410 
                    tmp_2 = 1; else 
#line 410 
                                    tmp_2 = 0;
  }
  else 
#line 410 
       tmp_2 = 0;
  
#line 410 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 410 
  return __retres;
}


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n)
{
  bool tmp;
  
#line 423 
  tmp = napi_schedule_prep(n);
  
#line 423 
  if ((int)tmp != 0) 
#line 424 
                     __napi_schedule(n); else ;
  
#line 425 
  return;
}


#line 496 
void napi_disable(struct napi_struct *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  int tmp;
  
#line 507 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& n->state));
  
#line 507 
  if ((long)(tmp == 0) != 0L) {
    
#line 509 
    ldv_inline_asm();
    
#line 507 
    ;
  }
  else ;
  
#line 509 
  ldv_inline_asm();
  
#line 509 
  clear_bit(0L,(unsigned long volatile *)(& n->state));
  
#line 510 
  return;
}


#line 1771  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netdev_get_prio_tc_map(struct net_device const *dev, u32 prio)
{
  int __retres;
  
#line 1773 
  __retres = (int)dev->prio_tc_map[prio & 15U];
  
#line 1773 
  return __retres;
}


#line 1822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev, unsigned int index)
{
  struct netdev_queue *__retres;
  
#line 1825 
  __retres = dev->_tx + index;
  
#line 1825 
  return __retres;
}


#line 2183 
int dev_close(struct net_device *);


#line 2205 
static void ldv_free_netdev_84(struct net_device *ldv_func_arg1);


#line 2209 
static void ldv_free_netdev_87(struct net_device *ldv_func_arg1);


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  
#line 2517 
  clear_bit(0L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2518 
  return;
}


#line 2531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2535 
  i = 0U;
  
#line 2535 
  goto ldv_43232;
  ldv_43231: 
#line 2536 
  ;
  {
    
#line 2536 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2537 
    netif_tx_start_queue(txq);
  }
  
#line 2535 
  i += 1U;
  ldv_43232: 
#line 2536 
  ;
  
#line 2535 
  if (dev->num_tx_queues > i) 
#line 2537 
                              goto ldv_43231; else 
#line 2540 
                                                   goto ldv_43233;
  ldv_43233: 
#line 2541 
  ;
  
#line 2542 
  return;
}


#line 2541 
void netif_tx_wake_queue(struct netdev_queue *);


#line 2555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2559 
  i = 0U;
  
#line 2559 
  goto ldv_43245;
  ldv_43244: 
#line 2560 
  ;
  {
    
#line 2560 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2561 
    netif_tx_wake_queue(txq);
  }
  
#line 2559 
  i += 1U;
  ldv_43245: 
#line 2560 
  ;
  
#line 2559 
  if (dev->num_tx_queues > i) 
#line 2561 
                              goto ldv_43244; else 
#line 2564 
                                                   goto ldv_43246;
  ldv_43246: 
#line 2565 
  ;
  
#line 2566 
  return;
}


#line 2582 
void netif_tx_stop_all_queues(struct net_device *);


#line 2769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 2771 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev->state));
  
#line 2771 
  __retres = (_Bool)(tmp != 0);
  
#line 2771 
  return __retres;
}


#line 3038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 3040 
  tmp = constant_test_bit(2L,(unsigned long const volatile *)(& dev->state));
  
#line 3040 
  __retres = (_Bool)(tmp == 0);
  
#line 3040 
  return __retres;
}


#line 3047 
void netif_carrier_on(struct net_device *);


#line 3049 
void netif_carrier_off(struct net_device *);


#line 3112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_device_present(struct net_device *dev)
{
  bool __retres;
  int tmp;
  
#line 3114 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& dev->state));
  
#line 3114 
  __retres = (_Bool)(tmp != 0);
  
#line 3114 
  return __retres;
}


#line 3117 
void netif_device_detach(struct net_device *);


#line 3119 
void netif_device_attach(struct net_device *);


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_61(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_64(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3287 
  local_bh_disable();
  {
    int pscr_ret__;
    {
      
#line 3288 
      void const *__vpp_verify = (void const *)0;
      
#line 3288 
      void const *tmp = __vpp_verify;
    }
    
#line 3288 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3288 
      ;
      {
        int pfo_ret__;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43806;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43806;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43806;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43806;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_43806: 
#line 3288 
        ;
        
#line 3288 
        tmp_0 = pfo_ret__;
      }
      
#line 3288 
      pscr_ret__ = tmp_0;
      
#line 3288 
      goto ldv_43812;
      case (unsigned long)2: 
#line 3288 
      ;
      {
        int pfo_ret___0;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43816;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43816;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43816;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43816;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_43816: 
#line 3288 
        ;
        
#line 3288 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3288 
      pscr_ret__ = tmp_0_0;
      
#line 3288 
      goto ldv_43812;
      case (unsigned long)4: 
#line 3288 
      ;
      {
        int pfo_ret___1;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43825;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43825;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43825;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43825;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_43825: 
#line 3288 
        ;
        
#line 3288 
        tmp_1 = pfo_ret___1;
      }
      
#line 3288 
      pscr_ret__ = tmp_1;
      
#line 3288 
      goto ldv_43812;
      case (unsigned long)8: 
#line 3288 
      ;
      {
        int pfo_ret___2;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43834;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43834;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43834;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_43834;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_43834: 
#line 3288 
        ;
        
#line 3288 
        tmp_2 = pfo_ret___2;
      }
      
#line 3288 
      pscr_ret__ = tmp_2;
      
#line 3288 
      goto ldv_43812;
      default: 
#line 3288 
      ;
      
#line 3288 
      __bad_size_call_parameter();
      
#line 3288 
      goto ldv_43812;
    }
    ldv_43812: 
#line 3288 
    ;
    
#line 3288 
    tmp_3 = pscr_ret__;
  }
  
#line 3288 
  cpu = tmp_3;
  
#line 3289 
  i = 0U;
  
#line 3289 
  goto ldv_43844;
  ldv_43843: 
#line 3290 
  ;
  {
    
#line 3290 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3292 
    __netif_tx_lock(txq,cpu);
    
#line 3293 
    netif_tx_start_queue(txq);
    
#line 3294 
    __netif_tx_unlock(txq);
  }
  
#line 3289 
  i += 1U;
  ldv_43844: 
#line 3290 
  ;
  
#line 3289 
  if (dev->num_tx_queues > i) 
#line 3291 
                              goto ldv_43843; else 
#line 3294 
                                                   goto ldv_43845;
  ldv_43845: 
#line 3295 
  ;
  
#line 3296 
  local_bh_enable();
  
#line 3297 
  return;
}


#line 3355 
static int ldv_register_netdev_83(struct net_device *ldv_func_arg1);


#line 3360 
static void ldv_unregister_netdev_86(struct net_device *ldv_func_arg1);


#line 3549 
void netdev_rss_key_fill(void *, size_t);


#line 3828 
void netdev_err(struct net_device const *, char const * , ...);


#line 3834 
void netdev_info(struct net_device const *, char const * , ...);


#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void eth_random_addr(u8 *addr)
{
  
#line 220 
  get_random_bytes((void *)addr,6);
  
#line 221 
  *addr = (unsigned char)((unsigned int)*addr & 254U);
  
#line 222 
  *addr = (unsigned char)((unsigned int)*addr | 2U);
  
#line 223 
  return;
}


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
void rtnl_lock(void);


#line 28 
void rtnl_unlock(void);


#line 29 
int rtnl_trylock(void);


#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_bus_read_config_word(struct pci_bus *, unsigned int, int, u16 *);


#line 887  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev const *dev, int where, u16 *val)
{
  int tmp;
  
#line 889 
  tmp = pci_bus_read_config_word(dev->bus,dev->devfn,where,val);
  
#line 889 
  return tmp;
}


#line 953 
int pci_enable_device_mem(struct pci_dev *);


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1013 
int pci_select_bars(struct pci_dev *, unsigned long);


#line 1026 
int pci_save_state(struct pci_dev *);


#line 1027 
void pci_restore_state(struct pci_dev *);


#line 1040 
int pci_set_power_state(struct pci_dev *, pci_power_t);


#line 1046 
int pci_wake_from_d3(struct pci_dev *, bool);


#line 1100 
int pci_request_selected_regions(struct pci_dev *, int, char const *);


#line 1102 
void pci_release_selected_regions(struct pci_dev *, int);


#line 1146 
static int ldv___pci_register_driver_88(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_89(struct pci_driver *ldv_func_arg1);


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 1676 
int pci_sriov_set_totalvfs(struct pci_dev *, u16);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.h"
u16 fm10k_read_pci_cfg_word(struct fm10k_hw *hw, u32 reg);


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.h"
s32 fm10k_msg_lport_map_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 106 
struct fm10k_tlv_attr const fm10k_lport_map_msg_attr[2U];


#line 112 
struct fm10k_tlv_attr const fm10k_update_pvid_msg_attr[2U];


#line 117 
s32 fm10k_msg_err_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 118 
struct fm10k_tlv_attr const fm10k_err_msg_attr[2U];


#line 122 
struct fm10k_tlv_attr const fm10k_1588_timestamp_msg_attr[2U];


#line 134 
struct fm10k_info fm10k_pf_info;


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.h"
s32 fm10k_msg_mac_vlan_vf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 66 
s32 fm10k_msg_lport_state_vf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 73 
struct fm10k_tlv_attr const fm10k_1588_msg_attr[2U];


#line 77 
struct fm10k_info fm10k_vf_info;


#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
struct workqueue_struct *fm10k_workqueue;


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static void fm10k_mbx_lock_0(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 360 
  goto ldv_47855;
  ldv_47854: 
#line 361 
  ;
  
#line 361 
  __const_udelay(85900UL);
  ldv_47855: 
#line 363 
  ;
  
#line 360 
  tmp = test_and_set_bit(4L,(unsigned long volatile *)(& interface->state));
  
#line 360 
  if (tmp != 0) 
#line 362 
                goto ldv_47854; else 
#line 365 
                                     goto ldv_47856;
  ldv_47856: 
#line 366 
  ;
  
#line 367 
  return;
}


#line 371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static int fm10k_mbx_trylock(struct fm10k_intfc *interface)
{
  int __retres;
  int tmp;
  
#line 373 
  tmp = test_and_set_bit(4L,(unsigned long volatile *)(& interface->state));
  
#line 373 
  __retres = tmp == 0;
  
#line 373 
  return __retres;
}


#line 384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static u16 fm10k_desc_unused(struct fm10k_ring *ring)
{
  u16 __retres;
  int tmp;
  
#line 386 
  s16 unused = (short)((unsigned int)((int)ring->next_to_clean - (int)ring->next_to_use) + 65535U);
  
#line 388 
  if ((long)((int)unused < 0) != 0L) 
#line 388 
                                     tmp = (int)ring->count + (int)((unsigned short)unused); else 
                                                                    
#line 388 
                                                                    tmp = (int)((unsigned short)unused);
  
#line 388 
  __retres = (unsigned short)tmp;
  
#line 388 
  return __retres;
}


#line 442 
int fm10k_init_queueing_scheme(struct fm10k_intfc *interface);


#line 443 
void fm10k_clear_queueing_scheme(struct fm10k_intfc *interface);


#line 449 
void fm10k_alloc_rx_buffers(struct fm10k_ring *rx_ring, u16 cleaned_count);


#line 452 
void fm10k_mbx_free_irq(struct fm10k_intfc *interface);


#line 453 
int fm10k_mbx_request_irq(struct fm10k_intfc *interface);


#line 454 
void fm10k_qv_free_irq(struct fm10k_intfc *interface);


#line 455 
int fm10k_qv_request_irq(struct fm10k_intfc *interface);


#line 456 
int fm10k_register_pci_driver(void);


#line 457 
void fm10k_unregister_pci_driver(void);


#line 458 
void fm10k_up(struct fm10k_intfc *interface);


#line 459 
void fm10k_down(struct fm10k_intfc *interface);


#line 460 
void fm10k_update_stats(struct fm10k_intfc *interface);


#line 461 
void fm10k_service_event_schedule(struct fm10k_intfc *interface);


#line 462 
void fm10k_update_rx_drop_en(struct fm10k_intfc *interface);


#line 464 
void fm10k_netpoll(struct net_device *netdev);


#line 468 
struct net_device *fm10k_alloc_netdev(void);


#line 473 
void fm10k_clean_all_rx_rings(struct fm10k_intfc *interface);


#line 474 
void fm10k_clean_all_tx_rings(struct fm10k_intfc *interface);


#line 477 
void fm10k_restore_rx_state(struct fm10k_intfc *interface);


#line 478 
void fm10k_reset_rx_state(struct fm10k_intfc *interface);


#line 480 
int fm10k_open(struct net_device *netdev);


#line 481 
int fm10k_close(struct net_device *netdev);


#line 524 
void fm10k_ts_tx_hwtstamp(struct fm10k_intfc *interface, __le16 dglort, u64 systime);


#line 526 
void fm10k_ts_reset(struct fm10k_intfc *interface);


#line 527 
void fm10k_ts_init(struct fm10k_intfc *interface);


#line 528 
void fm10k_ts_tx_subtask(struct fm10k_intfc *interface);


#line 529 
void fm10k_ptp_register(struct fm10k_intfc *interface);


#line 530 
void fm10k_ptp_unregister(struct fm10k_intfc *interface);


#line 535 
void fm10k_dcbnl_set_ops(struct net_device *dev);


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static struct fm10k_info const *fm10k_info_tbl[2U] = {(struct fm10k_info const *)(& fm10k_pf_info), (struct fm10k_info const *)(& fm10k_vf_info)};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static struct pci_device_id const fm10k_pci_tbl[3U] = {{.vendor = 32902U, .device = 5540U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5541U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
struct pci_device_id const __mod_pci__fm10k_pci_tbl_device_table[3U];

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
u16 fm10k_read_pci_cfg_word(struct fm10k_hw *hw, u32 reg)
{
  u16 __retres;
  
#line 50 
  struct fm10k_intfc *interface = (struct fm10k_intfc *)hw->back;
  
#line 51 
  u16 value = (unsigned short)0U;
  
#line 53 
  if ((long)(hw->hw_addr == (u32 *)0U) != 0L) {
    
#line 54 
    __retres = (unsigned short)(~ ((int)value));
    
#line 54 
    goto return_label;
  }
  else ;
  
#line 56 
  pci_read_config_word((struct pci_dev const *)interface->pdev,(int)reg,& value);
  
#line 57 
  if ((unsigned int)value == 65535U) 
#line 58 
                                     fm10k_read_reg(hw,0); else ;
  
#line 60 
  __retres = value;
  return_label: 
#line 60 
                return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
u32 fm10k_read_reg(struct fm10k_hw *hw, int reg)
{
  u32 __retres;
  u32 * volatile *tmp;
  {
    
#line 65 
    u32 *__var = (u32 *)0U;
    
#line 65 
    tmp = (u32 * volatile *)(& hw->hw_addr);
  }
  
#line 65 
  u32 *hw_addr = *tmp;
  
#line 66 
  u32 value = 0U;
  
#line 68 
  if ((long)(hw_addr == (u32 *)0U) != 0L) {
    
#line 69 
    __retres = ~ value;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  value = readl((void const volatile *)(hw_addr + reg));
  
#line 72 
  if (value == 4294967295U) {
    
#line 72 
    if (reg == 0) 
#line 72 
                  goto _LOR;
    else {
      unsigned int tmp_0;
      
#line 72 
      tmp_0 = readl((void const volatile *)hw_addr);
      
#line 72 
      if (tmp_0 == 4294967295U) {
        _LOR: {
                
#line 73 
                struct fm10k_intfc *interface = (struct fm10k_intfc *)hw->back;
                
#line 74 
                struct net_device *netdev = interface->netdev;
                
#line 76 
                hw->hw_addr = (u32 *)0U;
                
#line 77 
                netif_device_detach(netdev);
                
#line 78 
                netdev_err((struct net_device const *)netdev,"PCIe link lost, device now detached\n");
              }
      }
      else ;
    }
  }
  else ;
  
#line 81 
  __retres = value;
  return_label: 
#line 81 
                return __retres;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static int fm10k_hw_ready(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 86 
  struct fm10k_hw *hw = & interface->hw;
  
#line 88 
  fm10k_read_reg(hw,0);
  
#line 90 
  if ((long)(hw->hw_addr == (u32 *)0U) != 0L) 
#line 90 
                                              tmp = -19; else 
#line 90 
                                                              tmp = 0;
  
#line 90 
  return tmp;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_service_event_schedule(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 95 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& interface->state));
  
#line 95 
  if (tmp == 0) {
    int tmp_0;
    
#line 95 
    tmp_0 = test_and_set_bit(2L,(unsigned long volatile *)(& interface->state));
    
#line 95 
    if (tmp_0 == 0) 
#line 97 
                    ldv_queue_work_73(fm10k_workqueue,& interface->service_task); else ;
  }
  else ;
  
#line 98 
  return;
}


#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_service_event_complete(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 102 
  tmp = constant_test_bit(2L,(unsigned long const volatile *)(& interface->state));
  
#line 102 
  if ((long)(tmp == 0) != 0L) {
    
#line 104 
    ldv_inline_asm();
    
#line 102 
    ;
  }
  else ;
  
#line 104 
  ldv_inline_asm();
  
#line 106 
  clear_bit(2L,(unsigned long volatile *)(& interface->state));
  
#line 107 
  return;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_service_timer(unsigned long data)
{
  
#line 115 
  struct fm10k_intfc *interface = (struct fm10k_intfc *)data;
  
#line 118 
  ldv_mod_timer_74(& interface->service_timer,jiffies + 500UL);
  
#line 120 
  fm10k_service_event_schedule(interface);
  
#line 121 
  return;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_detach_subtask(struct fm10k_intfc *interface)
{
  bool tmp;
  bool tmp_0;
  
#line 125 
  struct net_device *netdev = interface->netdev;
  
#line 128 
  tmp = netif_device_present(netdev);
  
#line 128 
  if ((int)tmp != 0) 
#line 129 
                     goto return_label;
  else 
    
#line 128 
    if (interface->hw.hw_addr != (u32 *)0U) 
#line 129 
                                            goto return_label; else ;
  
#line 131 
  rtnl_lock();
  
#line 133 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 133 
  if ((int)tmp_0 != 0) 
#line 134 
                       dev_close(netdev); else ;
  
#line 136 
  rtnl_unlock();
  return_label: 
#line 137 
                return;
}


#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_reinit(struct fm10k_intfc *interface)
{
  int err;
  int tmp_0;
  bool tmp_1;
  int tmp_4;
  s32 tmp_5;
  bool tmp_6;
  
#line 141 
  struct net_device *netdev = interface->netdev;
  
#line 142 
  struct fm10k_hw *hw = & interface->hw;
  {
    int tmp;
    
#line 145 
    tmp = preempt_count();
    
#line 145 
    int __ret_warn_on = ((unsigned long)tmp & 2096896UL) != 0UL;
    
#line 145 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 145 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c",145); else ;
    
#line 145 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 148 
  netdev->trans_start = jiffies;
  
#line 150 
  goto ldv_48085;
  ldv_48084: 
#line 151 
  ;
  
#line 151 
  usleep_range(1000UL,2000UL);
  ldv_48085: 
#line 152 
  ;
  
#line 150 
  tmp_0 = test_and_set_bit(0L,(unsigned long volatile *)(& interface->state));
  
#line 150 
  if (tmp_0 != 0) 
#line 152 
                  goto ldv_48084; else 
#line 155 
                                       goto ldv_48086;
  ldv_48086: 
#line 156 
  ;
  
#line 153 
  rtnl_lock();
  
#line 155 
  fm10k_iov_suspend(interface->pdev);
  
#line 157 
  tmp_1 = netif_running((struct net_device const *)netdev);
  
#line 157 
  if ((int)tmp_1 != 0) 
#line 158 
                       fm10k_close(netdev); else ;
  
#line 160 
  fm10k_mbx_free_irq(interface);
  
#line 163 
  interface->last_reset = jiffies + 2500UL;
  
#line 166 
  tmp_5 = (*(hw->mac.ops.reset_hw))(hw);
  
#line 166 
  tmp_4 = tmp_5 != 0;
  
#line 166 
  if (tmp_4) ; else 
#line 166 
                    tmp_4 = (*(hw->mac.ops.init_hw))(hw);
  
#line 166 
  err = tmp_4;
  
#line 167 
  if (err != 0) 
#line 168 
                dev_err((struct device const *)(& (interface->pdev)->dev),"init_hw failed: %d\n",err); else ;
  
#line 171 
  fm10k_mbx_request_irq(interface);
  
#line 174 
  fm10k_ts_reset(interface);
  
#line 176 
  tmp_6 = netif_running((struct net_device const *)netdev);
  
#line 176 
  if ((int)tmp_6 != 0) 
#line 177 
                       fm10k_open(netdev); else ;
  
#line 179 
  fm10k_iov_resume(interface->pdev);
  
#line 181 
  rtnl_unlock();
  
#line 183 
  clear_bit(0L,(unsigned long volatile *)(& interface->state));
  
#line 184 
  return;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_reset_subtask(struct fm10k_intfc *interface)
{
  
#line 188 
  if ((interface->flags & 1U) == 0U) 
#line 189 
                                     goto return_label; else ;
  
#line 191 
  interface->flags &= 4294967294U;
  
#line 193 
  netdev_err((struct net_device const *)interface->netdev,"Reset interface\n");
  
#line 195 
  fm10k_reinit(interface);
  return_label: 
#line 196 
                return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_configure_swpri_map(struct fm10k_intfc *interface)
{
  int i;
  
#line 206 
  struct net_device *netdev = interface->netdev;
  
#line 207 
  struct fm10k_hw *hw = & interface->hw;
  
#line 211 
  interface->flags &= 4294967279U;
  
#line 214 
  if (hw->mac.type != (unsigned int)fm10k_mac_pf) 
#line 215 
                                                  goto return_label; else ;
  
#line 218 
  i = 0;
  
#line 218 
  goto ldv_48100;
  ldv_48099: 
#line 219 
  ;
  {
    u32 * volatile *tmp;
    {
      
#line 219 
      u32 *__var = (u32 *)0U;
      
#line 219 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 219 
    u32 *hw_addr = *tmp;
    
#line 219 
    if ((long)(hw_addr == (u32 *)0U) == 0L) {
      int tmp_0;
      
#line 219 
      ;
      
#line 219 
      tmp_0 = netdev_get_prio_tc_map((struct net_device const *)netdev,(unsigned int)i);
      
#line 219 
      writel((unsigned int)tmp_0,(void volatile *)(hw_addr + ((unsigned int)i + 80U)));
    }
    else ;
  }
  
#line 218 
  i += 1;
  ldv_48100: 
#line 219 
  ;
  
#line 218 
  if (i <= 15) 
#line 220 
               goto ldv_48099; else 
#line 223 
                                    goto ldv_48101;
  ldv_48101: 
#line 224 
  ;
  return_label: 
#line 225 
                return;
}


#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_watchdog_update_host_state(struct fm10k_intfc *interface)
{
  s32 err;
  int tmp_1;
  
#line 229 
  struct fm10k_hw *hw = & interface->hw;
  
#line 232 
  tmp_1 = constant_test_bit(5L,(unsigned long const volatile *)(& interface->state));
  
#line 232 
  if (tmp_1 != 0) {
    int tmp;
    
#line 233 
    interface->host_ready = (_Bool)0;
    {
      unsigned long __dummy;
      unsigned long __dummy2;
      
#line 234 
      tmp = 1;
    }
    
#line 234 
    if (tmp != 0) {
      int tmp_0;
      {
        unsigned long __dummy_0;
        unsigned long volatile __dummy2_0;
        
#line 234 
        tmp_0 = 1;
      }
      
#line 234 
      if (tmp_0 != 0) {
        
#line 234 
        if ((long)(jiffies - interface->link_down_event) < 0L) 
#line 235 
                                                               goto return_label; else ;
      }
      else ;
    }
    else ;
    
#line 236 
    clear_bit(5L,(unsigned long volatile *)(& interface->state));
  }
  else ;
  
#line 239 
  if ((interface->flags & 16U) != 0U) {
    int tmp_2;
    
#line 240 
    tmp_2 = rtnl_trylock();
    
#line 240 
    if (tmp_2 != 0) {
      
#line 241 
      fm10k_configure_swpri_map(interface);
      
#line 242 
      rtnl_unlock();
    }
    else ;
  }
  else ;
  
#line 247 
  fm10k_mbx_lock_0(interface);
  
#line 249 
  err = (*(hw->mac.ops.get_host_state))(hw,& interface->host_ready);
  
#line 250 
  if (err != 0) {
    int tmp_3;
    {
      unsigned long __dummy_1;
      unsigned long volatile __dummy2_1;
      
#line 250 
      tmp_3 = 1;
    }
    
#line 250 
    if (tmp_3 != 0) {
      int tmp_4;
      {
        unsigned long __dummy_2;
        unsigned long __dummy2_2;
        
#line 250 
        tmp_4 = 1;
      }
      
#line 250 
      if (tmp_4 != 0) {
        
#line 250 
        if ((long)(interface->last_reset - jiffies) < 0L) 
#line 251 
                                                          interface->flags |= 1U; else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 254 
  fm10k_mbx_unlock(interface);
  return_label: 
#line 255 
                return;
}


#line 265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_mbx_subtask(struct fm10k_intfc *interface)
{
  
#line 268 
  fm10k_watchdog_update_host_state(interface);
  
#line 271 
  fm10k_iov_mbx(interface);
  
#line 272 
  return;
}


#line 278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_watchdog_host_is_ready(struct fm10k_intfc *interface)
{
  bool tmp;
  
#line 280 
  struct net_device *netdev = interface->netdev;
  
#line 283 
  tmp = netif_carrier_ok((struct net_device const *)netdev);
  
#line 283 
  if ((int)tmp != 0) 
#line 284 
                     goto return_label; else ;
  
#line 286 
  if (((int)interface->msg_enable & 1) != 0) 
#line 286 
                                             netdev_info((struct net_device const *)netdev,"NIC Link is up\n"); else ;
  
#line 288 
  netif_carrier_on(netdev);
  
#line 289 
  netif_tx_wake_all_queues(netdev);
  return_label: 
#line 290 
                return;
}


#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_watchdog_host_not_ready(struct fm10k_intfc *interface)
{
  int tmp_0;
  bool tmp;
  
#line 298 
  struct net_device *netdev = interface->netdev;
  
#line 301 
  tmp = netif_carrier_ok((struct net_device const *)netdev);
  
#line 301 
  if (tmp) 
#line 301 
           tmp_0 = 0; else 
#line 301 
                           tmp_0 = 1;
  
#line 301 
  if (tmp_0) 
#line 302 
             goto return_label; else ;
  
#line 304 
  if (((int)interface->msg_enable & 1) != 0) 
#line 304 
                                             netdev_info((struct net_device const *)netdev,"NIC Link is down\n"); else ;
  
#line 306 
  netif_carrier_off(netdev);
  
#line 307 
  netif_tx_stop_all_queues(netdev);
  return_label: 
#line 308 
                return;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_update_stats(struct fm10k_intfc *interface)
{
  u64 bytes;
  u64 pkts;
  int i;
  
#line 316 
  struct net_device_stats *net_stats = & (interface->netdev)->stats;
  
#line 317 
  struct fm10k_hw *hw = & interface->hw;
  
#line 318 
  u64 rx_errors = 0ULL;
  
#line 318 
  u64 rx_csum_errors = 0ULL;
  
#line 318 
  u64 tx_csum_errors = 0ULL;
  
#line 319 
  u64 restart_queue = 0ULL;
  
#line 319 
  u64 tx_busy = 0ULL;
  
#line 319 
  u64 alloc_failed = 0ULL;
  
#line 320 
  u64 rx_bytes_nic = 0ULL;
  
#line 320 
  u64 rx_pkts_nic = 0ULL;
  
#line 320 
  u64 rx_drops_nic = 0ULL;
  
#line 321 
  u64 tx_bytes_nic = 0ULL;
  
#line 321 
  u64 tx_pkts_nic = 0ULL;
  
#line 326 
  interface->next_stats_update = jiffies + 250UL;
  
#line 329 
  bytes = 0ULL;
  
#line 329 
  pkts = 0ULL;
  
#line 329 
  i = 0;
  
#line 329 
  goto ldv_48151;
  ldv_48150: 
#line 330 
  ;
  {
    
#line 330 
    struct fm10k_ring *tx_ring = interface->tx_ring[i];
    
#line 332 
    restart_queue = tx_ring->__anonCompField_fm10k_ring_99.tx_stats.restart_queue + restart_queue;
    
#line 333 
    tx_busy = tx_ring->__anonCompField_fm10k_ring_99.tx_stats.tx_busy + tx_busy;
    
#line 334 
    tx_csum_errors = tx_ring->__anonCompField_fm10k_ring_99.tx_stats.csum_err + tx_csum_errors;
    
#line 335 
    bytes = tx_ring->stats.bytes + bytes;
    
#line 336 
    pkts = tx_ring->stats.packets + pkts;
  }
  
#line 329 
  i += 1;
  ldv_48151: 
#line 330 
  ;
  
#line 329 
  if (interface->num_tx_queues > i) 
#line 331 
                                    goto ldv_48150; else 
#line 334 
                                                         goto ldv_48152;
  ldv_48152: 
#line 335 
  ;
  
#line 339 
  interface->restart_queue = restart_queue;
  
#line 340 
  interface->tx_busy = tx_busy;
  
#line 341 
  net_stats->tx_bytes = (unsigned long)bytes;
  
#line 342 
  net_stats->tx_packets = (unsigned long)pkts;
  
#line 343 
  interface->tx_csum_errors = tx_csum_errors;
  
#line 345 
  bytes = 0ULL;
  
#line 345 
  pkts = 0ULL;
  
#line 345 
  i = 0;
  
#line 345 
  goto ldv_48155;
  ldv_48154: 
#line 346 
  ;
  {
    
#line 346 
    struct fm10k_ring *rx_ring = interface->rx_ring[i];
    
#line 348 
    bytes = rx_ring->stats.bytes + bytes;
    
#line 349 
    pkts = rx_ring->stats.packets + pkts;
    
#line 350 
    alloc_failed = rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.rx_stats.alloc_failed + alloc_failed;
    
#line 351 
    rx_csum_errors = rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.rx_stats.csum_err + rx_csum_errors;
    
#line 352 
    rx_errors = rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.rx_stats.errors + rx_errors;
  }
  
#line 345 
  i += 1;
  ldv_48155: 
#line 346 
  ;
  
#line 345 
  if (interface->num_rx_queues > i) 
#line 347 
                                    goto ldv_48154; else 
#line 350 
                                                         goto ldv_48156;
  ldv_48156: 
#line 351 
  ;
  
#line 355 
  net_stats->rx_bytes = (unsigned long)bytes;
  
#line 356 
  net_stats->rx_packets = (unsigned long)pkts;
  
#line 357 
  interface->alloc_failed = alloc_failed;
  
#line 358 
  interface->rx_csum_errors = rx_csum_errors;
  
#line 360 
  (*(hw->mac.ops.update_hw_stats))(hw,& interface->stats);
  
#line 362 
  i = 0;
  
#line 362 
  goto ldv_48159;
  ldv_48158: 
#line 363 
  ;
  {
    
#line 363 
    struct fm10k_hw_stats_q *q = & interface->stats.q[i];
    
#line 365 
    tx_bytes_nic = q->tx_bytes.count + tx_bytes_nic;
    
#line 366 
    tx_pkts_nic = q->tx_packets.count + tx_pkts_nic;
    
#line 367 
    rx_bytes_nic = q->rx_bytes.count + rx_bytes_nic;
    
#line 368 
    rx_pkts_nic = q->rx_packets.count + rx_pkts_nic;
    
#line 369 
    rx_drops_nic = q->rx_drops.count + rx_drops_nic;
  }
  
#line 362 
  i += 1;
  ldv_48159: 
#line 363 
  ;
  
#line 362 
  if ((int)hw->mac.max_queues > i) 
#line 364 
                                   goto ldv_48158; else 
#line 367 
                                                        goto ldv_48160;
  ldv_48160: 
#line 368 
  ;
  
#line 372 
  interface->tx_bytes_nic = tx_bytes_nic;
  
#line 373 
  interface->tx_packets_nic = tx_pkts_nic;
  
#line 374 
  interface->rx_bytes_nic = rx_bytes_nic;
  
#line 375 
  interface->rx_packets_nic = rx_pkts_nic;
  
#line 376 
  interface->rx_drops_nic = rx_drops_nic;
  
#line 379 
  net_stats->rx_errors = (unsigned long)rx_errors;
  
#line 380 
  net_stats->rx_dropped = (unsigned long)interface->stats.nodesc_drop.count;
  
#line 381 
  return;
}


#line 387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_watchdog_flush_tx(struct fm10k_intfc *interface)
{
  int i;
  bool tmp;
  
#line 389 
  int some_tx_pending = 0;
  
#line 393 
  tmp = netif_carrier_ok((struct net_device const *)interface->netdev);
  
#line 393 
  if ((int)tmp != 0) 
#line 394 
                     goto return_label; else ;
  
#line 396 
  i = 0;
  
#line 396 
  goto ldv_48169;
  ldv_48168: 
#line 397 
  ;
  {
    
#line 397 
    struct fm10k_ring *tx_ring = interface->tx_ring[i];
    
#line 399 
    if ((int)tx_ring->next_to_use != (int)tx_ring->next_to_clean) {
      
#line 400 
      some_tx_pending = 1;
      
#line 401 
      goto ldv_48167;
    }
    else ;
  }
  
#line 396 
  i += 1;
  ldv_48169: 
#line 397 
  ;
  
#line 396 
  if (interface->num_tx_queues > i) 
#line 398 
                                    goto ldv_48168; else 
#line 401 
                                                         goto ldv_48167;
  ldv_48167: 
#line 402 
  ;
  
#line 409 
  if (some_tx_pending != 0) 
#line 410 
                            interface->flags |= 1U; else ;
  return_label: 
#line 411 
                return;
}


#line 417  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_watchdog_subtask(struct fm10k_intfc *interface)
{
  int tmp;
  int tmp_1;
  
#line 420 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& interface->state));
  
#line 420 
  if (tmp != 0) 
#line 422 
                goto return_label;
  else {
    int tmp_0;
    
#line 420 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& interface->state));
    
#line 420 
    if (tmp_0 != 0) 
#line 422 
                    goto return_label; else ;
  }
  
#line 424 
  if ((int)interface->host_ready != 0) 
#line 425 
                                       fm10k_watchdog_host_is_ready(interface); else 
                                                                    
#line 427 
                                                                    fm10k_watchdog_host_not_ready(interface);
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 430 
    tmp_1 = 1;
  }
  
#line 430 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 430 
      tmp_2 = 1;
    }
    
#line 430 
    if (tmp_2 != 0) {
      
#line 430 
      if ((long)(interface->next_stats_update - jiffies) < 0L) 
#line 431 
                                                               fm10k_update_stats(interface); else ;
    }
    else ;
  }
  else ;
  
#line 434 
  fm10k_watchdog_flush_tx(interface);
  return_label: 
#line 435 
                return;
}


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_check_hang_subtask(struct fm10k_intfc *interface)
{
  int i;
  int tmp;
  int tmp_1;
  bool tmp_3;
  
#line 451 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& interface->state));
  
#line 451 
  if (tmp != 0) 
#line 453 
                goto return_label;
  else {
    int tmp_0;
    
#line 451 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& interface->state));
    
#line 451 
    if (tmp_0 != 0) 
#line 453 
                    goto return_label; else ;
  }
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
#line 456 
    tmp_1 = 1;
  }
  
#line 456 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_0;
      unsigned long volatile __dummy2_0;
      
#line 456 
      tmp_2 = 1;
    }
    
#line 456 
    if (tmp_2 != 0) {
      
#line 456 
      if ((long)(interface->next_tx_hang_check - jiffies) >= 0L) 
#line 457 
                                                                 goto return_label; else ;
    }
    else ;
  }
  else ;
  
#line 458 
  interface->next_tx_hang_check = jiffies + 500UL;
  
#line 460 
  tmp_3 = netif_carrier_ok((struct net_device const *)interface->netdev);
  
#line 460 
  if ((int)tmp_3 != 0) {
    
#line 462 
    i = 0;
    
#line 462 
    goto ldv_48190;
    ldv_48189: 
#line 463 
    ;
    
#line 463 
    clear_bit(0L,(unsigned long volatile *)(& (interface->tx_ring[i])->state));
    
#line 462 
    i += 1;
    ldv_48190: 
#line 463 
    ;
    
#line 462 
    if (interface->num_tx_queues > i) 
#line 464 
                                      goto ldv_48189; else 
#line 467 
                                                           goto ldv_48191;
    ldv_48191: 
#line 468 
    ;
    
#line 466 
    i = 0;
    
#line 466 
    goto ldv_48195;
    ldv_48194: 
#line 467 
    ;
    {
      
#line 467 
      struct fm10k_q_vector *qv = interface->q_vector[i];
      
#line 469 
      if ((unsigned int)qv->tx.count == 0U && (unsigned int)qv->rx.count == 0U) 
        
#line 470 
        goto ldv_48193; else ;
      
#line 471 
      writel(2952790016U,(void volatile *)qv->itr);
    }
    ldv_48193: 
#line 473 
    ;
    
#line 466 
    i += 1;
    ldv_48195: 
#line 467 
    ;
    
#line 466 
    if (interface->num_q_vectors > i) 
#line 468 
                                      goto ldv_48194; else 
#line 471 
                                                           goto ldv_48196;
    ldv_48196: 
#line 472 
    ;
  }
  else ;
  return_label: 
#line 474 
                return;
}


#line 480  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_service_task(struct work_struct *work)
{
  struct fm10k_intfc *interface;
  struct fm10k_intfc *tmp;
  {
    
#line 484 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 484 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709533128U;
  }
  
#line 484 
  interface = tmp;
  
#line 487 
  fm10k_mbx_subtask(interface);
  
#line 488 
  fm10k_detach_subtask(interface);
  
#line 489 
  fm10k_reset_subtask(interface);
  
#line 492 
  fm10k_watchdog_subtask(interface);
  
#line 493 
  fm10k_check_hang_subtask(interface);
  
#line 494 
  fm10k_ts_tx_subtask(interface);
  
#line 497 
  fm10k_service_event_complete(interface);
  
#line 498 
  return;
}


#line 507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_configure_tx_ring(struct fm10k_intfc *interface, struct fm10k_ring *ring)
{
  
#line 510 
  struct fm10k_hw *hw = & interface->hw;
  
#line 511 
  u64 tdba = ring->dma;
  
#line 512 
  u32 size = (unsigned int)ring->count * 16U;
  
#line 513 
  u32 txint = 768U;
  
#line 514 
  u32 txdctl = 81920U;
  
#line 515 
  u8 reg_idx = ring->reg_idx;
  {
    u32 * volatile *tmp;
    {
      
#line 518 
      u32 *__var = (u32 *)0U;
      
#line 518 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 518 
    u32 *hw_addr = *tmp;
    
#line 518 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 518 
                                            writel(0U,(void volatile *)(hw_addr + ((unsigned int)((int)reg_idx * 64) + 32774U))); else ;
  }
  
#line 519 
  fm10k_read_reg(hw,0);
  {
    u32 * volatile *tmp_0;
    {
      
#line 524 
      u32 *__var_0 = (u32 *)0U;
      
#line 524 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 524 
    u32 *hw_addr_0 = *tmp_0;
    
#line 524 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 524 
                                              writel((unsigned int)tdba,(void volatile *)(hw_addr_0 + ((unsigned int)((int)reg_idx * 64) + 32768U))); else ;
  }
  {
    u32 * volatile *tmp_1;
    {
      
#line 525 
      u32 *__var_1 = (u32 *)0U;
      
#line 525 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 525 
    u32 *hw_addr_1 = *tmp_1;
    
#line 525 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 525 
                                              writel((unsigned int)(tdba >> 32),(void volatile *)(hw_addr_1 + ((unsigned int)((int)reg_idx * 64) + 32769U))); else ;
  }
  {
    u32 * volatile *tmp_2;
    {
      
#line 526 
      u32 *__var_2 = (u32 *)0U;
      
#line 526 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 526 
    u32 *hw_addr_2 = *tmp_2;
    
#line 526 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 526 
                                              writel(size,(void volatile *)(hw_addr_2 + ((unsigned int)((int)reg_idx * 64) + 32770U))); else ;
  }
  {
    u32 * volatile *tmp_3;
    {
      
#line 529 
      u32 *__var_3 = (u32 *)0U;
      
#line 529 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 529 
    u32 *hw_addr_3 = *tmp_3;
    
#line 529 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 529 
                                              writel(0U,(void volatile *)(hw_addr_3 + ((unsigned int)((int)reg_idx * 64) + 32772U))); else ;
  }
  {
    u32 * volatile *tmp_4;
    {
      
#line 530 
      u32 *__var_4 = (u32 *)0U;
      
#line 530 
      tmp_4 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 530 
    u32 *hw_addr_4 = *tmp_4;
    
#line 530 
    if ((long)(hw_addr_4 == (u32 *)0U) == 0L) 
#line 530 
                                              writel(0U,(void volatile *)(hw_addr_4 + ((unsigned int)((int)reg_idx * 64) + 32773U))); else ;
  }
  
#line 533 
  ring->tail = interface->uc_addr + ((unsigned int)((int)reg_idx * 64) + 32773U);
  
#line 536 
  ring->next_to_clean = (unsigned short)0U;
  
#line 537 
  ring->next_to_use = (unsigned short)0U;
  
#line 540 
  if (ring->q_vector != (struct fm10k_q_vector *)0) {
    
#line 541 
    txint = (unsigned int)((int)(ring->q_vector)->v_idx + 1);
    
#line 542 
    txint = txint;
  }
  else ;
  {
    u32 * volatile *tmp_5;
    {
      
#line 545 
      u32 *__var_5 = (u32 *)0U;
      
#line 545 
      tmp_5 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 545 
    u32 *hw_addr_5 = *tmp_5;
    
#line 545 
    if ((long)(hw_addr_5 == (u32 *)0U) == 0L) 
#line 545 
                                              writel(txint,(void volatile *)(hw_addr_5 + ((unsigned int)((int)reg_idx * 64) + 32776U))); else ;
  }
  {
    u32 * volatile *tmp_6;
    {
      
#line 548 
      u32 *__var_6 = (u32 *)0U;
      
#line 548 
      tmp_6 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 548 
    u32 *hw_addr_6 = *tmp_6;
    
#line 548 
    if ((long)(hw_addr_6 == (u32 *)0U) == 0L) 
#line 548 
                                              writel(1U,(void volatile *)(hw_addr_6 + ((unsigned int)((int)reg_idx * 64) + 32782U))); else ;
  }
  {
    u32 * volatile *tmp_7;
    {
      
#line 552 
      u32 *__var_7 = (u32 *)0U;
      
#line 552 
      tmp_7 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 552 
    u32 *hw_addr_7 = *tmp_7;
    
#line 552 
    if ((long)(hw_addr_7 == (u32 *)0U) == 0L) 
#line 552 
                                              writel(txdctl,(void volatile *)(hw_addr_7 + ((unsigned int)((int)reg_idx * 64) + 32774U))); else ;
  }
  
#line 554 
  return;
}


#line 562  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_enable_tx_ring(struct fm10k_intfc *interface, struct fm10k_ring *ring)
{
  u32 txdctl;
  u32 tmp;
  
#line 565 
  struct fm10k_hw *hw = & interface->hw;
  
#line 566 
  int wait_loop = 10;
  
#line 568 
  u8 reg_idx = ring->reg_idx;
  
#line 571 
  tmp = fm10k_read_reg(hw,(int)reg_idx * 64 + 32774);
  
#line 571 
  if ((tmp & 16384U) != 0U) 
#line 572 
                            goto return_label; else ;
  ldv_48248: 
#line 573 
  ;
  
#line 576 
  usleep_range(1000UL,2000UL);
  
#line 577 
  txdctl = fm10k_read_reg(hw,(int)reg_idx * 64 + 32774);
  
#line 578 
  if ((txdctl & 16384U) == 0U) {
    
#line 578 
    wait_loop -= 1;
    
#line 578 
    if (wait_loop != 0) 
#line 580 
                        goto ldv_48248; else 
#line 583 
                                             goto ldv_48249;
  }
  else 
#line 583 
       goto ldv_48249;
  ldv_48249: 
#line 584 
  ;
  
#line 579 
  if (wait_loop == 0) {
    
#line 580 
    if (((int)interface->msg_enable & 1) != 0) 
#line 580 
                                               netdev_err((struct net_device const *)interface->netdev,"Could not enable Tx Queue %d\n",(int)reg_idx); else ;
  }
  else ;
  return_label: 
#line 581 
                return;
}


#line 590  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_configure_tx(struct fm10k_intfc *interface)
{
  int i;
  
#line 595 
  i = 0;
  
#line 595 
  goto ldv_48255;
  ldv_48254: 
#line 596 
  ;
  
#line 596 
  fm10k_configure_tx_ring(interface,interface->tx_ring[i]);
  
#line 595 
  i += 1;
  ldv_48255: 
#line 596 
  ;
  
#line 595 
  if (interface->num_tx_queues > i) 
#line 597 
                                    goto ldv_48254; else 
#line 600 
                                                         goto ldv_48256;
  ldv_48256: 
#line 601 
  ;
  
#line 599 
  i = 0;
  
#line 599 
  goto ldv_48258;
  ldv_48257: 
#line 600 
  ;
  
#line 600 
  fm10k_enable_tx_ring(interface,interface->tx_ring[i]);
  
#line 599 
  i += 1;
  ldv_48258: 
#line 600 
  ;
  
#line 599 
  if (interface->num_tx_queues > i) 
#line 601 
                                    goto ldv_48257; else 
#line 604 
                                                         goto ldv_48259;
  ldv_48259: 
#line 605 
  ;
  
#line 606 
  return;
}


#line 610  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_configure_rx_ring(struct fm10k_intfc *interface, struct fm10k_ring *ring)
{
  u16 tmp_9;
  
#line 613 
  u64 rdba = ring->dma;
  
#line 614 
  struct fm10k_hw *hw = & interface->hw;
  
#line 615 
  u32 size = (unsigned int)ring->count * 32U;
  
#line 616 
  u32 rxqctl = 253U;
  
#line 617 
  u32 rxdctl = 1U;
  
#line 618 
  u32 srrctl = 2147483648U;
  
#line 619 
  u32 rxint = 768U;
  
#line 620 
  u8 rx_pause = interface->rx_pause;
  
#line 621 
  u8 reg_idx = ring->reg_idx;
  {
    u32 * volatile *tmp;
    {
      
#line 624 
      u32 *__var = (u32 *)0U;
      
#line 624 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 624 
    u32 *hw_addr = *tmp;
    
#line 624 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 624 
                                            writel(0U,(void volatile *)(hw_addr + ((unsigned int)((int)reg_idx * 64) + 16390U))); else ;
  }
  
#line 625 
  fm10k_read_reg(hw,0);
  {
    u32 * volatile *tmp_0;
    {
      
#line 630 
      u32 *__var_0 = (u32 *)0U;
      
#line 630 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 630 
    u32 *hw_addr_0 = *tmp_0;
    
#line 630 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 630 
                                              writel((unsigned int)rdba,(void volatile *)(hw_addr_0 + ((unsigned int)((int)reg_idx * 64) + 16384U))); else ;
  }
  {
    u32 * volatile *tmp_1;
    {
      
#line 631 
      u32 *__var_1 = (u32 *)0U;
      
#line 631 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 631 
    u32 *hw_addr_1 = *tmp_1;
    
#line 631 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 631 
                                              writel((unsigned int)(rdba >> 32),(void volatile *)(hw_addr_1 + ((unsigned int)((int)reg_idx * 64) + 16385U))); else ;
  }
  {
    u32 * volatile *tmp_2;
    {
      
#line 632 
      u32 *__var_2 = (u32 *)0U;
      
#line 632 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 632 
    u32 *hw_addr_2 = *tmp_2;
    
#line 632 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 632 
                                              writel(size,(void volatile *)(hw_addr_2 + ((unsigned int)((int)reg_idx * 64) + 16386U))); else ;
  }
  {
    u32 * volatile *tmp_3;
    {
      
#line 635 
      u32 *__var_3 = (u32 *)0U;
      
#line 635 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 635 
    u32 *hw_addr_3 = *tmp_3;
    
#line 635 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 635 
                                              writel(0U,(void volatile *)(hw_addr_3 + ((unsigned int)((int)reg_idx * 64) + 16388U))); else ;
  }
  {
    u32 * volatile *tmp_4;
    {
      
#line 636 
      u32 *__var_4 = (u32 *)0U;
      
#line 636 
      tmp_4 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 636 
    u32 *hw_addr_4 = *tmp_4;
    
#line 636 
    if ((long)(hw_addr_4 == (u32 *)0U) == 0L) 
#line 636 
                                              writel(0U,(void volatile *)(hw_addr_4 + ((unsigned int)((int)reg_idx * 64) + 16389U))); else ;
  }
  
#line 639 
  ring->tail = interface->uc_addr + ((unsigned int)((int)reg_idx * 64) + 16389U);
  
#line 642 
  ring->next_to_clean = (unsigned short)0U;
  
#line 643 
  ring->next_to_use = (unsigned short)0U;
  
#line 644 
  ring->next_to_alloc = (unsigned short)0U;
  
#line 647 
  srrctl |= 8U;
  
#line 650 
  srrctl |= 1073741824U;
  {
    u32 * volatile *tmp_5;
    {
      
#line 651 
      u32 *__var_5 = (u32 *)0U;
      
#line 651 
      tmp_5 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 651 
    u32 *hw_addr_5 = *tmp_5;
    
#line 651 
    if ((long)(hw_addr_5 == (u32 *)0U) == 0L) 
#line 651 
                                              writel(srrctl,(void volatile *)(hw_addr_5 + ((unsigned int)((int)reg_idx * 64) + 16393U))); else ;
  }
  
#line 655 
  if ((unsigned int)interface->pfc_en != 0U) 
#line 656 
                                             rx_pause = interface->pfc_en; else ;
  
#line 658 
  if ((((int)rx_pause >> (int)ring->qos_pc) & 1) == 0) 
#line 659 
                                                       rxdctl |= 512U; else ;
  {
    u32 * volatile *tmp_6;
    {
      
#line 661 
      u32 *__var_6 = (u32 *)0U;
      
#line 661 
      tmp_6 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 661 
    u32 *hw_addr_6 = *tmp_6;
    
#line 661 
    if ((long)(hw_addr_6 == (u32 *)0U) == 0L) 
#line 661 
                                              writel(rxdctl,(void volatile *)(hw_addr_6 + ((unsigned int)((int)reg_idx * 64) + 16391U))); else ;
  }
  
#line 664 
  ring->vid = hw->mac.default_vid;
  
#line 667 
  if (ring->q_vector != (struct fm10k_q_vector *)0) {
    
#line 668 
    rxint = (unsigned int)((int)(ring->q_vector)->v_idx + 1);
    
#line 669 
    rxint |= 256U;
  }
  else ;
  {
    u32 * volatile *tmp_7;
    {
      
#line 672 
      u32 *__var_7 = (u32 *)0U;
      
#line 672 
      tmp_7 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 672 
    u32 *hw_addr_7 = *tmp_7;
    
#line 672 
    if ((long)(hw_addr_7 == (u32 *)0U) == 0L) 
#line 672 
                                              writel(rxint,(void volatile *)(hw_addr_7 + ((unsigned int)((int)reg_idx * 64) + 16392U))); else ;
  }
  {
    u32 * volatile *tmp_8;
    {
      
#line 675 
      u32 *__var_8 = (u32 *)0U;
      
#line 675 
      tmp_8 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 675 
    u32 *hw_addr_8 = *tmp_8;
    
#line 675 
    if ((long)(hw_addr_8 == (u32 *)0U) == 0L) 
#line 675 
                                              writel(rxqctl,(void volatile *)(hw_addr_8 + ((unsigned int)((int)reg_idx * 64) + 16390U))); else ;
  }
  
#line 678 
  tmp_9 = fm10k_desc_unused(ring);
  
#line 678 
  ;
  
#line 678 
  fm10k_alloc_rx_buffers(ring,(unsigned short)((int)tmp_9));
  
#line 679 
  return;
}


#line 687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_update_rx_drop_en(struct fm10k_intfc *interface)
{
  int i;
  
#line 689 
  struct fm10k_hw *hw = & interface->hw;
  
#line 690 
  u8 rx_pause = interface->rx_pause;
  
#line 694 
  if ((unsigned int)interface->pfc_en != 0U) 
#line 695 
                                             rx_pause = interface->pfc_en; else ;
  
#line 698 
  i = 0;
  
#line 698 
  goto ldv_48316;
  ldv_48315: 
#line 699 
  ;
  {
    
#line 699 
    struct fm10k_ring *ring = interface->rx_ring[i];
    
#line 700 
    u32 rxdctl = 1U;
    
#line 701 
    u8 reg_idx = ring->reg_idx;
    
#line 703 
    if ((((int)rx_pause >> (int)ring->qos_pc) & 1) == 0) 
#line 704 
                                                         rxdctl |= 512U; else ;
    {
      u32 * volatile *tmp;
      {
        
#line 706 
        u32 *__var = (u32 *)0U;
        
#line 706 
        tmp = (u32 * volatile *)(& hw->hw_addr);
      }
      
#line 706 
      u32 *hw_addr = *tmp;
      
#line 706 
      if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 706 
                                              writel(rxdctl,(void volatile *)(hw_addr + ((unsigned int)((int)reg_idx * 64) + 16391U))); else ;
    }
  }
  
#line 698 
  i += 1;
  ldv_48316: 
#line 699 
  ;
  
#line 698 
  if (interface->num_rx_queues > i) 
#line 700 
                                    goto ldv_48315; else 
#line 703 
                                                         goto ldv_48317;
  ldv_48317: 
#line 704 
  ;
  
#line 705 
  return;
}


#line 716  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_configure_dglort(struct fm10k_intfc *interface)
{
  int i;
  u32 mrqc;
  int tmp_2;
  int tmp_3;
  int tmp_5;
  int tmp_6;
  
#line 718 
  struct fm10k_dglort_cfg dglort = {.glort = (unsigned short)0U, .queue_b = (unsigned short)0, .vsi_b = (unsigned char)0, .idx = (unsigned char)0, .rss_l = (unsigned char)0, .pc_l = (unsigned char)0, .vsi_l = (unsigned char)0, .queue_l = (unsigned char)0, .shared_l = (unsigned char)0, .inner_rss = (unsigned char)0};
  
#line 719 
  struct fm10k_hw *hw = & interface->hw;
  
#line 724 
  i = 0;
  
#line 724 
  goto ldv_48329;
  ldv_48328: 
#line 725 
  ;
  {
    u32 * volatile *tmp;
    {
      
#line 725 
      u32 *__var = (u32 *)0U;
      
#line 725 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 725 
    u32 *hw_addr = *tmp;
    
#line 725 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 725 
                                            writel(interface->rssrk[i],(void volatile *)(hw_addr + ((unsigned int)i + 2048U))); else ;
  }
  
#line 724 
  i += 1;
  ldv_48329: 
#line 725 
  ;
  
#line 724 
  if (i <= 9) 
#line 726 
              goto ldv_48328; else 
#line 729 
                                   goto ldv_48330;
  ldv_48330: 
#line 730 
  ;
  
#line 728 
  i = 0;
  
#line 728 
  goto ldv_48335;
  ldv_48334: 
#line 729 
  ;
  {
    u32 * volatile *tmp_0;
    {
      
#line 729 
      u32 *__var_0 = (u32 *)0U;
      
#line 729 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 729 
    u32 *hw_addr_0 = *tmp_0;
    
#line 729 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 729 
                                              writel(interface->reta[i],(void volatile *)(hw_addr_0 + ((unsigned int)i + 4096U))); else ;
  }
  
#line 728 
  i += 1;
  ldv_48335: 
#line 729 
  ;
  
#line 728 
  if (i <= 31) 
#line 730 
               goto ldv_48334; else 
#line 733 
                                    goto ldv_48336;
  ldv_48336: 
#line 734 
  ;
  
#line 734 
  mrqc = 51U;
  
#line 739 
  if ((interface->flags & 2U) != 0U) 
#line 740 
                                     mrqc |= 64U; else ;
  
#line 741 
  if ((interface->flags & 4U) != 0U) 
#line 742 
                                     mrqc |= 128U; else ;
  {
    u32 * volatile *tmp_1;
    {
      
#line 744 
      u32 *__var_1 = (u32 *)0U;
      
#line 744 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 744 
    u32 *hw_addr_1 = *tmp_1;
    
#line 744 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 744 
                                              writel(mrqc,(void volatile *)(hw_addr_1 + 8448U)); else ;
  }
  
#line 747 
  dglort.inner_rss = (unsigned char)1U;
  
#line 748 
  tmp_2 = fls((int)interface->ring_feature[0].mask);
  
#line 748 
  dglort.rss_l = (unsigned char)tmp_2;
  
#line 749 
  tmp_3 = fls((int)interface->ring_feature[1].mask);
  
#line 749 
  dglort.pc_l = (unsigned char)tmp_3;
  
#line 750 
  (*(hw->mac.ops.configure_dglort_map))(hw,& dglort);
  
#line 753 
  if ((unsigned int)interface->glort_count > 64U) {
    int tmp_4;
    
#line 754 
    memset((void *)(& dglort),0,12UL);
    
#line 755 
    dglort.inner_rss = (unsigned char)1U;
    
#line 756 
    dglort.glort = (unsigned short)((unsigned int)interface->glort + 64U);
    
#line 757 
    dglort.idx = (unsigned char)4U;
    
#line 758 
    tmp_4 = fls(interface->num_rx_queues + -1);
    
#line 758 
    dglort.queue_l = (unsigned char)tmp_4;
    
#line 759 
    (*(hw->mac.ops.configure_dglort_map))(hw,& dglort);
  }
  else ;
  
#line 763 
  memset((void *)(& dglort),0,12UL);
  
#line 764 
  dglort.inner_rss = (unsigned char)1U;
  
#line 765 
  dglort.glort = interface->glort;
  
#line 766 
  tmp_5 = fls((int)interface->ring_feature[0].mask);
  
#line 766 
  dglort.rss_l = (unsigned char)tmp_5;
  
#line 767 
  tmp_6 = fls((int)interface->ring_feature[1].mask);
  
#line 767 
  dglort.pc_l = (unsigned char)tmp_6;
  
#line 769 
  dglort.idx = (unsigned char)7U;
  
#line 770 
  if (interface->l2_accel != (struct fm10k_l2_accel *)0) {
    int tmp_7;
    
#line 771 
    tmp_7 = fls((interface->l2_accel)->size);
    
#line 771 
    dglort.shared_l = (unsigned char)tmp_7;
  }
  else ;
  
#line 772 
  (*(hw->mac.ops.configure_dglort_map))(hw,& dglort);
  
#line 773 
  return;
}


#line 781  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_configure_rx(struct fm10k_intfc *interface)
{
  int i;
  
#line 786 
  fm10k_configure_swpri_map(interface);
  
#line 789 
  fm10k_configure_dglort(interface);
  
#line 792 
  i = 0;
  
#line 792 
  goto ldv_48345;
  ldv_48344: 
#line 793 
  ;
  
#line 793 
  fm10k_configure_rx_ring(interface,interface->rx_ring[i]);
  
#line 792 
  i += 1;
  ldv_48345: 
#line 793 
  ;
  
#line 792 
  if (interface->num_rx_queues > i) 
#line 794 
                                    goto ldv_48344; else 
#line 797 
                                                         goto ldv_48346;
  ldv_48346: 
#line 798 
  ;
  
#line 799 
  return;
}


#line 798  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_napi_enable_all(struct fm10k_intfc *interface)
{
  struct fm10k_q_vector *q_vector;
  int q_idx;
  
#line 803 
  q_idx = 0;
  
#line 803 
  goto ldv_48353;
  ldv_48352: 
#line 804 
  ;
  
#line 804 
  q_vector = interface->q_vector[q_idx];
  
#line 805 
  napi_enable(& q_vector->napi);
  
#line 803 
  q_idx += 1;
  ldv_48353: 
#line 804 
  ;
  
#line 803 
  if (interface->num_q_vectors > q_idx) 
#line 805 
                                        goto ldv_48352; else 
#line 808 
                                                             goto ldv_48354;
  ldv_48354: 
#line 809 
  ;
  
#line 810 
  return;
}


#line 809  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static irqreturn_t fm10k_msix_clean_rings(int irq, void *data)
{
  irqreturn_t __retres;
  
#line 811 
  struct fm10k_q_vector *q_vector = (struct fm10k_q_vector *)data;
  
#line 813 
  if ((unsigned int)q_vector->rx.count != 0U || (unsigned int)q_vector->tx.count != 0U) 
    
#line 814 
    napi_schedule(& q_vector->napi); else ;
  
#line 816 
  __retres = IRQ_HANDLED;
  
#line 816 
  return __retres;
}


#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static irqreturn_t fm10k_msix_mbx_vf(int irq, void *data)
{
  irqreturn_t __retres;
  int tmp_0;
  
#line 821 
  struct fm10k_intfc *interface = (struct fm10k_intfc *)data;
  
#line 822 
  struct fm10k_hw *hw = & interface->hw;
  
#line 823 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  {
    u32 * volatile *tmp;
    {
      
#line 826 
      u32 *__var = (u32 *)0U;
      
#line 826 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 826 
    u32 *hw_addr = *tmp;
    
#line 826 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 826 
                                            writel(2684354580U,(void volatile *)(hw_addr + 96U)); else ;
  }
  
#line 830 
  tmp_0 = fm10k_mbx_trylock(interface);
  
#line 830 
  if (tmp_0 != 0) {
    
#line 831 
    (*(mbx->ops.process))(hw,mbx);
    
#line 832 
    fm10k_mbx_unlock(interface);
  }
  else ;
  
#line 835 
  hw->mac.get_host_state = (_Bool)1;
  
#line 836 
  fm10k_service_event_schedule(interface);
  
#line 838 
  __retres = IRQ_HANDLED;
  
#line 838 
  return __retres;
}


#line 849  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_netpoll(struct net_device *netdev)
{
  int i;
  int tmp_0;
  
#line 851 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 855 
  tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& interface->state));
  
#line 855 
  if (tmp_0 != 0) 
#line 856 
                  goto return_label; else ;
  
#line 858 
  i = 0;
  
#line 858 
  goto ldv_48376;
  ldv_48375: 
#line 859 
  ;
  
#line 859 
  fm10k_msix_clean_rings(0,(void *)interface->q_vector[i]);
  
#line 858 
  i += 1;
  ldv_48376: 
#line 859 
  ;
  
#line 858 
  if (interface->num_q_vectors > i) 
#line 860 
                                    goto ldv_48375; else 
#line 863 
                                                         goto ldv_48377;
  ldv_48377: 
#line 864 
  ;
  return_label: 
#line 865 
                return;
}


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_print_fault(struct fm10k_intfc *interface, int type, struct fm10k_fault *fault)
{
  char *error;
  
#line 867 
  struct pci_dev *pdev = interface->pdev;
  
#line 870 
  switch (type) {
    case 8: 
#line 871 
    ;
    
#line 872 
    switch ((int)fault->type) {
      default: 
#line 873 
      ;
      
#line 874 
      error = (char *)"Unknown PCA error";
      
#line 875 
      goto ldv_48387;
      case 0: 
#line 876 
      ;
      
#line 876 
      error = (char *)"PCA_NO_FAULT";
      
#line 876 
      goto ldv_48387;
      case 1: 
#line 877 
      ;
      
#line 877 
      error = (char *)"PCA_UNMAPPED_ADDR";
      
#line 877 
      goto ldv_48387;
      case 2: 
#line 878 
      ;
      
#line 878 
      error = (char *)"PCA_BAD_QACCESS_PF";
      
#line 878 
      goto ldv_48387;
      case 3: 
#line 879 
      ;
      
#line 879 
      error = (char *)"PCA_BAD_QACCESS_VF";
      
#line 879 
      goto ldv_48387;
      case 4: 
#line 880 
      ;
      
#line 880 
      error = (char *)"PCA_MALICIOUS_REQ";
      
#line 880 
      goto ldv_48387;
      case 5: 
#line 881 
      ;
      
#line 881 
      error = (char *)"PCA_POISONED_TLP";
      
#line 881 
      goto ldv_48387;
      case 6: 
#line 882 
      ;
      
#line 882 
      error = (char *)"PCA_TLP_ABORT";
      
#line 882 
      goto ldv_48387;
    }
    ldv_48387: 
#line 884 
    ;
    
#line 884 
    goto ldv_48395;
    case 16: 
#line 885 
    ;
    
#line 886 
    switch ((int)fault->type) {
      default: 
#line 887 
      ;
      
#line 888 
      error = (char *)"Unknown THI error";
      
#line 889 
      goto ldv_48398;
      case 0: 
#line 890 
      ;
      
#line 890 
      error = (char *)"THI_NO_FAULT";
      
#line 890 
      goto ldv_48398;
      case 1: 
#line 891 
      ;
      
#line 891 
      error = (char *)"THI_MAL_DIS_Q_FAULT";
      
#line 891 
      goto ldv_48398;
    }
    ldv_48398: 
#line 893 
    ;
    
#line 893 
    goto ldv_48395;
    case 28: 
#line 894 
    ;
    
#line 895 
    switch ((int)fault->type) {
      default: 
#line 896 
      ;
      
#line 897 
      error = (char *)"Unknown FUM error";
      
#line 898 
      goto ldv_48403;
      case 0: 
#line 899 
      ;
      
#line 899 
      error = (char *)"FUM_NO_FAULT";
      
#line 899 
      goto ldv_48403;
      case 1: 
#line 900 
      ;
      
#line 900 
      error = (char *)"FUM_UNMAPPED_ADDR";
      
#line 900 
      goto ldv_48403;
      case 3: 
#line 901 
      ;
      
#line 901 
      error = (char *)"FUM_BAD_VF_QACCESS";
      
#line 901 
      goto ldv_48403;
      case 4: 
#line 902 
      ;
      
#line 902 
      error = (char *)"FUM_ADD_DECODE_ERR";
      
#line 902 
      goto ldv_48403;
      case 5: 
#line 903 
      ;
      
#line 903 
      error = (char *)"FUM_RO_ERROR";
      
#line 903 
      goto ldv_48403;
      case 6: 
#line 904 
      ;
      
#line 904 
      error = (char *)"FUM_QPRC_CRC_ERROR";
      
#line 904 
      goto ldv_48403;
      case 7: 
#line 905 
      ;
      
#line 905 
      error = (char *)"FUM_CSR_TIMEOUT";
      
#line 905 
      goto ldv_48403;
      case 8: 
#line 906 
      ;
      
#line 906 
      error = (char *)"FUM_INVALID_TYPE";
      
#line 906 
      goto ldv_48403;
      case 9: 
#line 907 
      ;
      
#line 907 
      error = (char *)"FUM_INVALID_LENGTH";
      
#line 907 
      goto ldv_48403;
      case 10: 
#line 908 
      ;
      
#line 908 
      error = (char *)"FUM_INVALID_BE";
      
#line 908 
      goto ldv_48403;
      case 11: 
#line 909 
      ;
      
#line 909 
      error = (char *)"FUM_INVALID_ALIGN";
      
#line 909 
      goto ldv_48403;
    }
    ldv_48403: 
#line 911 
    ;
    
#line 911 
    goto ldv_48395;
    default: 
#line 912 
    ;
    
#line 913 
    error = (char *)"Undocumented fault";
    
#line 914 
    goto ldv_48395;
  }
  ldv_48395: 
#line 917 
  ;
  
#line 917 
  dev_warn((struct device const *)(& pdev->dev),"%s Address: 0x%llx SpecInfo: 0x%x Func: %02x.%0x\n",error,fault->address,fault->specinfo,((int)fault->func >> 3) & 31,(int)fault->func & 7);
  
#line 921 
  return;
}


#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_report_fault(struct fm10k_intfc *interface, u32 eicr)
{
  int type;
  int err;
  
#line 925 
  struct fm10k_hw *hw = & interface->hw;
  
#line 926 
  struct fm10k_fault fault = {.address = 0ULL, .specinfo = 0U, .type = (unsigned char)0, .func = (unsigned char)0};
  
#line 929 
  eicr &= 63U;
  
#line 929 
  type = 8;
  
#line 929 
  goto ldv_48426;
  ldv_48425: 
#line 930 
  ;
  
#line 933 
  if ((eicr & 1U) == 0U) 
#line 934 
                         goto ldv_48424; else ;
  
#line 937 
  err = (*(hw->mac.ops.get_fault))(hw,type,& fault);
  
#line 938 
  if (err != 0) {
    
#line 939 
    dev_err((struct device const *)(& (interface->pdev)->dev),"error reading fault\n");
    
#line 941 
    goto ldv_48424;
  }
  else ;
  
#line 944 
  fm10k_print_fault(interface,type,& fault);
  ldv_48424: 
#line 945 
  ;
  
#line 931 
  eicr >>= 1;
  
#line 931 
  type += 4;
  ldv_48426: 
#line 932 
  ;
  
#line 929 
  if (eicr != 0U) 
#line 932 
                  goto ldv_48425; else 
#line 935 
                                       goto ldv_48427;
  ldv_48427: 
#line 936 
  ;
  
#line 937 
  return;
}


#line 948  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_reset_drop_on_empty(struct fm10k_intfc *interface, u32 eicr)
{
  u32 maxholdq;
  int q;
  int tmp_1;
  
#line 950 
  struct fm10k_hw *hw = & interface->hw;
  
#line 951 
  u32 const rxdctl = 1U;
  
#line 955 
  if ((eicr & 4096U) == 0U) 
#line 956 
                            goto return_label; else ;
  
#line 958 
  maxholdq = fm10k_read_reg(hw,39);
  
#line 959 
  if (maxholdq != 0U) {
    u32 * volatile *tmp;
    {
      
#line 960 
      u32 *__var = (u32 *)0U;
      
#line 960 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 960 
    u32 *hw_addr = *tmp;
    
#line 960 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 960 
                                            writel(maxholdq,(void volatile *)(hw_addr + 39U)); else ;
  }
  else ;
  
#line 961 
  q = 255;
  ldv_48447: 
#line 962 
  ;
  
#line 962 
  if (maxholdq < (u32)0) 
    
#line 963 
    if (q <= 127) {
      
#line 964 
      interface->rx_overrun_pf += 1ULL;
      {
        u32 * volatile *tmp_0;
        {
          
#line 965 
          u32 *__var_0 = (u32 *)0U;
          
#line 965 
          tmp_0 = (u32 * volatile *)(& hw->hw_addr);
        }
        
#line 965 
        u32 *hw_addr_0 = *tmp_0;
        
#line 965 
        if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 965 
                                                  writel(rxdctl,(void volatile *)(hw_addr_0 + ((unsigned int)(q * 64) + 16391U))); else ;
      }
    }
    else 
#line 967 
         interface->rx_overrun_vf += 1ULL;
  else ;
  
#line 971 
  maxholdq *= 2U;
  
#line 972 
  if (maxholdq == 0U) 
#line 973 
                      q &= -32; else ;
  
#line 975 
  if (q == 0) 
#line 976 
              goto ldv_48442; else ;
  
#line 978 
  tmp_1 = q;
  
#line 978 
  q -= 1;
  
#line 978 
  ;
  
#line 978 
  if (((unsigned int)tmp_1 & 31U) != 0U) 
#line 979 
                                         goto ldv_48443; else ;
  
#line 981 
  maxholdq = fm10k_read_reg(hw,q / 32 + 32);
  
#line 982 
  if (maxholdq != 0U) {
    u32 * volatile *tmp_2;
    {
      
#line 983 
      u32 *__var_1 = (u32 *)0U;
      
#line 983 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 983 
    u32 *hw_addr_1 = *tmp_2;
    
#line 983 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 983 
                                              writel(maxholdq,(void volatile *)(hw_addr_1 + ((unsigned int)(q / 32) + 32U))); else ;
  }
  else ;
  ldv_48443: 
#line 985 
  ;
  
#line 962 
  goto ldv_48447;
  ldv_48442: 
#line 963 
  ;
  return_label: 
#line 964 
                return;
}


#line 987  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static irqreturn_t fm10k_msix_mbx_pf(int irq, void *data)
{
  irqreturn_t __retres;
  u32 eicr;
  int tmp_0;
  
#line 989 
  struct fm10k_intfc *interface = (struct fm10k_intfc *)data;
  
#line 990 
  struct fm10k_hw *hw = & interface->hw;
  
#line 991 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 995 
  eicr = fm10k_read_reg(hw,6);
  {
    u32 * volatile *tmp;
    {
      
#line 996 
      u32 *__var = (u32 *)0U;
      
#line 996 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 996 
    u32 *hw_addr = *tmp;
    
#line 996 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 996 
                                            writel(eicr & 448U,(void volatile *)(hw_addr + 6U)); else ;
  }
  
#line 1001 
  fm10k_report_fault(interface,eicr);
  
#line 1004 
  fm10k_reset_drop_on_empty(interface,eicr);
  
#line 1007 
  tmp_0 = fm10k_mbx_trylock(interface);
  
#line 1007 
  if (tmp_0 != 0) {
    
#line 1008 
    (*(mbx->ops.process))(hw,mbx);
    
#line 1010 
    fm10k_iov_event(interface);
    
#line 1011 
    fm10k_mbx_unlock(interface);
  }
  else ;
  
#line 1015 
  if ((eicr & 256U) != 0U) {
    
#line 1017 
    interface->link_down_event = jiffies + 1000UL;
    
#line 1018 
    clear_bit(5L,(unsigned long volatile *)(& interface->state));
    
#line 1021 
    hw->mac.dglort_map = 65535U;
  }
  else ;
  
#line 1025 
  hw->mac.get_host_state = (_Bool)1;
  
#line 1028 
  fm10k_service_event_schedule(interface);
  {
    u32 * volatile *tmp_1;
    {
      
#line 1031 
      u32 *__var_0 = (u32 *)0U;
      
#line 1031 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1031 
    u32 *hw_addr_0 = *tmp_1;
    
#line 1031 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 1031 
                                              writel(2684354580U,(void volatile *)(hw_addr_0 + 74752U)); else ;
  }
  
#line 1034 
  __retres = IRQ_HANDLED;
  
#line 1034 
  return __retres;
}


#line 1037  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_mbx_free_irq(struct fm10k_intfc *interface)
{
  int itr_reg;
  
#line 1039 
  struct msix_entry *entry = interface->msix_entries;
  
#line 1040 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1044 
  (*(hw->mbx.ops.disconnect))(hw,& hw->mbx);
  
#line 1047 
  if (hw->mac.type == (unsigned int)fm10k_mac_pf) {
    {
      u32 * volatile *tmp;
      {
        
#line 1048 
        u32 *__var = (u32 *)0U;
        
#line 1048 
        tmp = (u32 * volatile *)(& hw->hw_addr);
      }
      
#line 1048 
      u32 *hw_addr = *tmp;
      
#line 1048 
      if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 1048 
                                              writel(22107137U,(void volatile *)(hw_addr + 7U)); else ;
    }
    
#line 1057 
    itr_reg = 74752;
  }
  else 
#line 1059 
       itr_reg = 96;
  {
    u32 * volatile *tmp_0;
    {
      
#line 1062 
      u32 *__var_0 = (u32 *)0U;
      
#line 1062 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1062 
    u32 *hw_addr_0 = *tmp_0;
    
#line 1062 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 1062 
                                              writel(1073741824U,(void volatile *)(hw_addr_0 + itr_reg)); else ;
  }
  
#line 1064 
  ldv_free_irq_75(entry->vector,(void *)interface);
  
#line 1065 
  return;
}


#line 1067  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static s32 fm10k_mbx_mac_addr(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  struct fm10k_intfc *interface;
  s32 err;
  struct fm10k_intfc *tmp;
  bool tmp_0;
  
#line 1070 
  bool vlan_override = hw->mac.vlan_override;
  
#line 1071 
  u16 default_vid = hw->mac.default_vid;
  
#line 1075 
  err = fm10k_msg_mac_vlan_vf(hw,results,mbx);
  
#line 1076 
  if (err != 0) {
    
#line 1077 
    __retres = err;
    
#line 1077 
    goto return_label;
  }
  else ;
  {
    
#line 1079 
    struct fm10k_hw const *__mptr = (struct fm10k_hw const *)hw;
    
#line 1079 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709536432U;
  }
  
#line 1079 
  interface = tmp;
  
#line 1082 
  tmp_0 = is_valid_ether_addr((u8 const *)(& hw->mac.perm_addr));
  
#line 1082 
  if ((int)tmp_0 != 0) {
    int tmp_1;
    
#line 1082 
    tmp_1 = memcmp((void const *)(& hw->mac.perm_addr),(void const *)(& hw->mac.addr),6UL);
    
#line 1082 
    if (tmp_1 != 0) 
#line 1084 
                    interface->flags |= 1U; else ;
  }
  else ;
  
#line 1087 
  if ((int)hw->mac.vlan_override != (int)vlan_override || (int)hw->mac.default_vid != (int)default_vid) 
    
#line 1089 
    interface->flags |= 1U; else ;
  
#line 1091 
  __retres = 0;
  return_label: 
#line 1091 
                return __retres;
}


#line 1094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static s32 fm10k_1588_msg_vf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  struct fm10k_intfc *interface;
  u64 timestamp;
  s32 err;
  struct fm10k_intfc *tmp;
  
#line 1101 
  err = fm10k_tlv_attr_get_value(*results,(void *)(& timestamp),8U);
  
#line 1103 
  if (err != 0) {
    
#line 1104 
    __retres = err;
    
#line 1104 
    goto return_label;
  }
  else ;
  {
    
#line 1106 
    struct fm10k_hw const *__mptr = (struct fm10k_hw const *)hw;
    
#line 1106 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709536432U;
  }
  
#line 1106 
  interface = tmp;
  
#line 1108 
  fm10k_ts_tx_hwtstamp(interface,(unsigned short)0,timestamp);
  
#line 1110 
  __retres = 0;
  return_label: 
#line 1110 
                return __retres;
}


#line 1114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static s32 fm10k_mbx_error(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  struct fm10k_intfc *interface;
  struct pci_dev *pdev;
  struct fm10k_intfc *tmp;
  {
    
#line 1120 
    struct fm10k_hw const *__mptr = (struct fm10k_hw const *)hw;
    
#line 1120 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709536432U;
  }
  
#line 1120 
  interface = tmp;
  
#line 1121 
  pdev = interface->pdev;
  
#line 1123 
  dev_err((struct device const *)(& pdev->dev),"Unknown message ID %u\n",*(*results) & 65535U);
  
#line 1126 
  __retres = 0;
  
#line 1126 
  return __retres;
}


#line 1129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static struct fm10k_msg_data const vf_mbx_data[5U] = {{.id = 0U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_tlv_msg_test_attr), .func = & fm10k_tlv_msg_test}, {.id = 2U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_mac_vlan_msg_attr), .func = & fm10k_mbx_mac_addr}, {.id = 3U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_lport_state_msg_attr), .func = & fm10k_msg_lport_state_vf}, {.id = 4U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_1588_msg_attr), .func = & fm10k_1588_msg_vf}, {.id = 4294967295U, .attr = (struct fm10k_tlv_attr const *)0, .func = & fm10k_mbx_error}};

#line 1137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static int fm10k_mbx_request_irq_vf(struct fm10k_intfc *interface)
{
  int __retres;
  int err;
  
#line 1139 
  struct msix_entry *entry = interface->msix_entries;
  
#line 1140 
  struct net_device *dev = interface->netdev;
  
#line 1141 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1145 
  u32 itr = (unsigned int)entry->entry;
  
#line 1148 
  err = (*(hw->mbx.ops.register_handlers))(& hw->mbx,(struct fm10k_msg_data const *)(& vf_mbx_data));
  
#line 1149 
  if (err != 0) {
    
#line 1150 
    __retres = err;
    
#line 1150 
    goto return_label;
  }
  else ;
  
#line 1153 
  err = ldv_request_irq_76(entry->vector,& fm10k_msix_mbx_vf,0UL,(char const *)(& dev->name),(void *)interface);
  
#line 1155 
  if (err != 0) {
    
#line 1156 
    if (((int)interface->msg_enable & 2) != 0) 
#line 1156 
                                               netdev_err((struct net_device const *)dev,"request_irq for msix_mbx failed: %d\n",err); else ;
    
#line 1158 
    __retres = err;
    
#line 1158 
    goto return_label;
  }
  else ;
  {
    u32 * volatile *tmp;
    {
      
#line 1162 
      u32 *__var = (u32 *)0U;
      
#line 1162 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1162 
    u32 *hw_addr = *tmp;
    
#line 1162 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 1162 
                                            writel(itr,(void volatile *)(hw_addr + 48U)); else ;
  }
  {
    u32 * volatile *tmp_0;
    {
      
#line 1165 
      u32 *__var_0 = (u32 *)0U;
      
#line 1165 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1165 
    u32 *hw_addr_0 = *tmp_0;
    
#line 1165 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 1165 
                                              writel(2684354560U,(void volatile *)(hw_addr_0 + ((unsigned int)entry->entry + 96U))); else ;
  }
  
#line 1167 
  __retres = 0;
  return_label: 
#line 1167 
                return __retres;
}


#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static s32 fm10k_lport_map(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  struct fm10k_intfc *interface;
  s32 err;
  struct fm10k_intfc *tmp;
  
#line 1174 
  u32 dglort_map = hw->mac.dglort_map;
  
#line 1177 
  err = fm10k_msg_lport_map_pf(hw,results,mbx);
  
#line 1178 
  if (err != 0) {
    
#line 1179 
    __retres = err;
    
#line 1179 
    goto return_label;
  }
  else ;
  {
    
#line 1181 
    struct fm10k_hw const *__mptr = (struct fm10k_hw const *)hw;
    
#line 1181 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709536432U;
  }
  
#line 1181 
  interface = tmp;
  
#line 1184 
  if (hw->mac.dglort_map != dglort_map) 
#line 1185 
                                        interface->flags |= 1U; else ;
  
#line 1187 
  __retres = 0;
  return_label: 
#line 1187 
                return __retres;
}


#line 1190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static s32 fm10k_update_pvid(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  struct fm10k_intfc *interface;
  u16 glort;
  u16 pvid;
  u32 pvid_update;
  s32 err;
  int tmp_0;
  bool tmp;
  struct fm10k_intfc *tmp_1;
  
#line 1198 
  err = fm10k_tlv_attr_get_value(*(results + 13U),(void *)(& pvid_update),4U);
  
#line 1200 
  if (err != 0) {
    
#line 1201 
    __retres = err;
    
#line 1201 
    goto return_label;
  }
  else ;
  
#line 1204 
  glort = (unsigned short)pvid_update;
  
#line 1205 
  pvid = (unsigned short)(pvid_update >> 16);
  
#line 1208 
  tmp = fm10k_glort_valid_pf(hw,(unsigned short)((int)glort));
  
#line 1208 
  if (tmp) 
#line 1208 
           tmp_0 = 0; else 
#line 1208 
                           tmp_0 = 1;
  
#line 1208 
  if (tmp_0) {
    
#line 1209 
    __retres = -2;
    
#line 1209 
    goto return_label;
  }
  else ;
  
#line 1212 
  if ((unsigned int)pvid > 4095U) {
    
#line 1213 
    __retres = -2;
    
#line 1213 
    goto return_label;
  }
  else ;
  {
    
#line 1215 
    struct fm10k_hw const *__mptr = (struct fm10k_hw const *)hw;
    
#line 1215 
    tmp_1 = (struct fm10k_intfc *)__mptr + 18446744073709536432U;
  }
  
#line 1215 
  interface = tmp_1;
  
#line 1218 
  err = fm10k_iov_update_pvid(interface,(unsigned short)((int)glort),(unsigned short)((int)pvid));
  
#line 1219 
  if (err == 0) {
    
#line 1220 
    __retres = 0;
    
#line 1220 
    goto return_label;
  }
  else ;
  
#line 1223 
  if ((int)hw->mac.default_vid != (int)pvid) 
#line 1224 
                                             interface->flags |= 1U; else ;
  
#line 1226 
  hw->mac.default_vid = pvid;
  
#line 1228 
  __retres = 0;
  return_label: 
#line 1228 
                return __retres;
}


#line 1231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static s32 fm10k_1588_msg_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  struct fm10k_swapi_1588_timestamp timestamp;
  struct fm10k_iov_data *iov_data;
  struct fm10k_intfc *interface;
  u16 sglort;
  u16 vf_idx;
  s32 err;
  struct fm10k_intfc *tmp;
  int tmp_1;
  bool tmp_0;
  struct fm10k_iov_data * volatile *tmp_2;
  
#line 1240 
  err = fm10k_tlv_attr_get_le_struct(*(results + 16U),(void *)(& timestamp),20U);
  
#line 1243 
  if (err != 0) {
    
#line 1244 
    __retres = err;
    
#line 1244 
    goto return_label;
  }
  else ;
  {
    
#line 1246 
    struct fm10k_hw const *__mptr = (struct fm10k_hw const *)hw;
    
#line 1246 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709536432U;
  }
  
#line 1246 
  interface = tmp;
  
#line 1248 
  if ((unsigned int)timestamp.dglort != 0U) {
    
#line 1249 
    fm10k_ts_tx_hwtstamp(interface,(unsigned short)((int)timestamp.dglort),timestamp.egress);
    
#line 1251 
    __retres = 0;
    
#line 1251 
    goto return_label;
  }
  else ;
  
#line 1255 
  if ((unsigned int)timestamp.sglort == 0U) {
    
#line 1256 
    __retres = -2;
    
#line 1256 
    goto return_label;
  }
  else ;
  
#line 1259 
  sglort = timestamp.sglort;
  
#line 1260 
  tmp_0 = fm10k_glort_valid_pf(hw,(unsigned short)((int)sglort));
  
#line 1260 
  if (tmp_0) 
#line 1260 
             tmp_1 = 0; else 
#line 1260 
                             tmp_1 = 1;
  
#line 1260 
  if (tmp_1) {
    
#line 1261 
    __retres = -2;
    
#line 1261 
    goto return_label;
  }
  else ;
  
#line 1263 
  if ((int)interface->glort == (int)sglort) {
    
#line 1264 
    fm10k_ts_tx_hwtstamp(interface,(unsigned short)0,timestamp.ingress);
    
#line 1266 
    __retres = 0;
    
#line 1266 
    goto return_label;
  }
  else ;
  {
    
#line 1270 
    struct fm10k_iov_data *__var = (struct fm10k_iov_data *)0;
    
#line 1270 
    tmp_2 = (struct fm10k_iov_data * volatile *)(& interface->iov_data);
  }
  
#line 1270 
  ;
  
#line 1270 
  if (*tmp_2 == (struct fm10k_iov_data *)0) {
    
#line 1271 
    __retres = -2;
    
#line 1271 
    goto return_label;
  }
  else ;
  
#line 1273 
  rcu_read_lock();
  
#line 1276 
  iov_data = interface->iov_data;
  
#line 1277 
  vf_idx = (unsigned short)((int)((unsigned short)hw->mac.dglort_map) - (int)sglort);
  
#line 1279 
  if (iov_data == (struct fm10k_iov_data *)0 || (unsigned int)vf_idx >= iov_data->num_vfs) {
    
#line 1280 
    err = -2;
    
#line 1281 
    goto err_unlock;
  }
  else ;
  
#line 1284 
  err = (*(hw->iov.ops.report_timestamp))(hw,& iov_data->vf_info[(int)vf_idx],timestamp.ingress);
  err_unlock: 
#line 1287 
  ;
  
#line 1288 
  rcu_read_unlock();
  
#line 1290 
  __retres = err;
  return_label: 
#line 1290 
                return __retres;
}


#line 1293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static struct fm10k_msg_data const pf_mbx_data[8U] = {{.id = 1U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_err_msg_attr), .func = & fm10k_msg_err_pf}, {.id = 2U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_err_msg_attr), .func = & fm10k_msg_err_pf}, {.id = 256U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_lport_map_msg_attr), .func = & fm10k_lport_map}, {.id = 512U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_err_msg_attr), .func = & fm10k_msg_err_pf}, {.id = 513U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_err_msg_attr), .func = & fm10k_msg_err_pf}, {.id = 1024U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_update_pvid_msg_attr), .func = & fm10k_update_pvid}, {.id = 1793U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_1588_timestamp_msg_attr), .func = & fm10k_1588_msg_pf}, {.id = 4294967295U, .attr = (struct fm10k_tlv_attr const *)0, .func = & fm10k_mbx_error}};

#line 1304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static int fm10k_mbx_request_irq_pf(struct fm10k_intfc *interface)
{
  int __retres;
  int err;
  
#line 1306 
  struct msix_entry *entry = interface->msix_entries;
  
#line 1307 
  struct net_device *dev = interface->netdev;
  
#line 1308 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1312 
  u32 mbx_itr = (unsigned int)entry->entry;
  
#line 1313 
  u32 other_itr = (unsigned int)entry->entry | 512U;
  
#line 1316 
  err = (*(hw->mbx.ops.register_handlers))(& hw->mbx,(struct fm10k_msg_data const *)(& pf_mbx_data));
  
#line 1317 
  if (err != 0) {
    
#line 1318 
    __retres = err;
    
#line 1318 
    goto return_label;
  }
  else ;
  
#line 1321 
  err = ldv_request_irq_77(entry->vector,& fm10k_msix_mbx_pf,0UL,(char const *)(& dev->name),(void *)interface);
  
#line 1323 
  if (err != 0) {
    
#line 1324 
    if (((int)interface->msg_enable & 2) != 0) 
#line 1324 
                                               netdev_err((struct net_device const *)dev,"request_irq for msix_mbx failed: %d\n",err); else ;
    
#line 1326 
    __retres = err;
    
#line 1326 
    goto return_label;
  }
  else ;
  {
    u32 * volatile *tmp;
    {
      
#line 1330 
      u32 *__var = (u32 *)0U;
      
#line 1330 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1330 
    u32 *hw_addr = *tmp;
    
#line 1330 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 1330 
                                            writel(other_itr,(void volatile *)(hw_addr + 65665U)); else ;
  }
  {
    u32 * volatile *tmp_0;
    {
      
#line 1331 
      u32 *__var_0 = (u32 *)0U;
      
#line 1331 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1331 
    u32 *hw_addr_0 = *tmp_0;
    
#line 1331 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 1331 
                                              writel(other_itr,(void volatile *)(hw_addr_0 + 65666U)); else ;
  }
  {
    u32 * volatile *tmp_1;
    {
      
#line 1332 
      u32 *__var_1 = (u32 *)0U;
      
#line 1332 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1332 
    u32 *hw_addr_1 = *tmp_1;
    
#line 1332 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 1332 
                                              writel(other_itr,(void volatile *)(hw_addr_1 + 65668U)); else ;
  }
  {
    u32 * volatile *tmp_2;
    {
      
#line 1333 
      u32 *__var_2 = (u32 *)0U;
      
#line 1333 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1333 
    u32 *hw_addr_2 = *tmp_2;
    
#line 1333 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 1333 
                                              writel(other_itr,(void volatile *)(hw_addr_2 + 65670U)); else ;
  }
  {
    u32 * volatile *tmp_3;
    {
      
#line 1334 
      u32 *__var_3 = (u32 *)0U;
      
#line 1334 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1334 
    u32 *hw_addr_3 = *tmp_3;
    
#line 1334 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 1334 
                                              writel(other_itr,(void volatile *)(hw_addr_3 + 65669U)); else ;
  }
  {
    u32 * volatile *tmp_4;
    {
      
#line 1337 
      u32 *__var_4 = (u32 *)0U;
      
#line 1337 
      tmp_4 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1337 
    u32 *hw_addr_4 = *tmp_4;
    
#line 1337 
    if ((long)(hw_addr_4 == (u32 *)0U) == 0L) 
#line 1337 
                                              writel(mbx_itr,(void volatile *)(hw_addr_4 + 65664U)); else ;
  }
  {
    u32 * volatile *tmp_5;
    {
      
#line 1340 
      u32 *__var_5 = (u32 *)0U;
      
#line 1340 
      tmp_5 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1340 
    u32 *hw_addr_5 = *tmp_5;
    
#line 1340 
    if ((long)(hw_addr_5 == (u32 *)0U) == 0L) 
#line 1340 
                                              writel(44214274U,(void volatile *)(hw_addr_5 + 7U)); else ;
  }
  {
    u32 * volatile *tmp_6;
    {
      
#line 1350 
      u32 *__var_6 = (u32 *)0U;
      
#line 1350 
      tmp_6 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1350 
    u32 *hw_addr_6 = *tmp_6;
    
#line 1350 
    if ((long)(hw_addr_6 == (u32 *)0U) == 0L) 
#line 1350 
                                              writel(2684354560U,(void volatile *)(hw_addr_6 + ((unsigned int)entry->entry + 74752U))); else ;
  }
  
#line 1352 
  __retres = 0;
  return_label: 
#line 1352 
                return __retres;
}


#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
int fm10k_mbx_request_irq(struct fm10k_intfc *interface)
{
  int err;
  
#line 1357 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1361 
  if (hw->mac.type == (unsigned int)fm10k_mac_pf) 
#line 1362 
                                                  err = fm10k_mbx_request_irq_pf(interface); else 
                                                                    
#line 1364 
                                                                    err = fm10k_mbx_request_irq_vf(interface);
  
#line 1367 
  if (err == 0) 
#line 1368 
                err = (*(hw->mbx.ops.connect))(hw,& hw->mbx); else ;
  
#line 1370 
  return err;
}


#line 1379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_qv_free_irq(struct fm10k_intfc *interface)
{
  struct msix_entry *entry;
  
#line 1381 
  int vector = interface->num_q_vectors;
  
#line 1382 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1385 
  entry = interface->msix_entries + (vector + 1);
  
#line 1387 
  goto ldv_48603;
  ldv_48604: 
#line 1388 
  ;
  {
    struct fm10k_q_vector *q_vector;
    
#line 1390 
    vector -= 1;
    
#line 1391 
    entry -= 1;
    
#line 1392 
    q_vector = interface->q_vector[vector];
    
#line 1394 
    if ((unsigned int)q_vector->tx.count == 0U && (unsigned int)q_vector->rx.count == 0U) 
      
#line 1395 
      goto ldv_48603; else ;
    
#line 1399 
    writel(1073741824U,(void volatile *)q_vector->itr);
    
#line 1401 
    ldv_free_irq_78(entry->vector,(void *)q_vector);
  }
  ldv_48603: 
#line 1403 
  ;
  
#line 1387 
  if (vector != 0) 
#line 1389 
                   goto ldv_48604; else 
#line 1392 
                                        goto ldv_48605;
  ldv_48605: 
#line 1393 
  ;
  
#line 1394 
  return;
}


#line 1412  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
int fm10k_qv_request_irq(struct fm10k_intfc *interface)
{
  int __retres;
  struct msix_entry *entry;
  int vector;
  int err;
  
#line 1414 
  struct net_device *dev = interface->netdev;
  
#line 1415 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1417 
  int ri = 0;
  
#line 1417 
  int ti = 0;
  
#line 1420 
  entry = interface->msix_entries + 1U;
  
#line 1422 
  vector = 0;
  
#line 1422 
  goto ldv_48620;
  ldv_48619: 
#line 1423 
  ;
  {
    
#line 1423 
    struct fm10k_q_vector *q_vector = interface->q_vector[vector];
    
#line 1426 
    if ((unsigned int)q_vector->tx.count != 0U && (unsigned int)q_vector->rx.count != 0U) {
      int tmp;
      
#line 1428 
      tmp = ri;
      
#line 1428 
      ri += 1;
      
#line 1427 
      ;
      
#line 1427 
      ;
      
#line 1427 
      ;
      
#line 1427 
      snprintf((char *)(& q_vector->name),24UL,"%s-TxRx-%d",(char *)(& dev->name),tmp);
      
#line 1429 
      ti += 1;
    }
    else 
      
#line 1430 
      if ((unsigned int)q_vector->rx.count != 0U) {
        int tmp_0;
        
#line 1432 
        tmp_0 = ri;
        
#line 1432 
        ri += 1;
        
#line 1431 
        ;
        
#line 1431 
        ;
        
#line 1431 
        ;
        
#line 1431 
        snprintf((char *)(& q_vector->name),24UL,"%s-rx-%d",(char *)(& dev->name),tmp_0);
      }
      else 
        
#line 1433 
        if ((unsigned int)q_vector->tx.count != 0U) {
          int tmp_1;
          
#line 1435 
          tmp_1 = ti;
          
#line 1435 
          ti += 1;
          
#line 1434 
          ;
          
#line 1434 
          ;
          
#line 1434 
          ;
          
#line 1434 
          snprintf((char *)(& q_vector->name),24UL,"%s-tx-%d",(char *)(& dev->name),tmp_1);
        }
        else 
#line 1438 
             goto ldv_48617;
    
#line 1442 
    if (hw->mac.type == (unsigned int)fm10k_mac_pf) 
#line 1442 
                                                    q_vector->itr = interface->uc_addr + ((unsigned int)entry->entry + 74752U); else 
                                                                    
#line 1442 
                                                                    q_vector->itr = interface->uc_addr + ((unsigned int)entry->entry + 96U);
    
#line 1447 
    err = ldv_request_irq_79(entry->vector,& fm10k_msix_clean_rings,0UL,(char const *)(& q_vector->name),(void *)q_vector);
    
#line 1449 
    if (err != 0) {
      
#line 1450 
      if (((int)interface->msg_enable & 2) != 0) 
#line 1450 
                                                 netdev_err((struct net_device const *)dev,"request_irq failed for MSIX interrupt Error: %d\n",err); else ;
      
#line 1453 
      goto err_out;
    }
    else ;
    
#line 1457 
    writel(2684354560U,(void volatile *)q_vector->itr);
    
#line 1459 
    entry += 1;
  }
  ldv_48617: 
#line 1461 
  ;
  
#line 1422 
  vector += 1;
  ldv_48620: 
#line 1423 
  ;
  
#line 1422 
  if (interface->num_q_vectors > vector) 
#line 1424 
                                         goto ldv_48619; else 
#line 1427 
                                                              goto ldv_48621;
  ldv_48621: 
#line 1428 
  ;
  
#line 1462 
  __retres = 0;
  
#line 1462 
  goto return_label;
  err_out: 
#line 1464 
  ;
  
#line 1466 
  goto ldv_48623;
  ldv_48624: 
#line 1467 
  ;
  {
    struct fm10k_q_vector *q_vector_0;
    
#line 1469 
    entry -= 1;
    
#line 1470 
    vector -= 1;
    
#line 1471 
    q_vector_0 = interface->q_vector[vector];
    
#line 1473 
    if ((unsigned int)q_vector_0->tx.count == 0U && (unsigned int)q_vector_0->rx.count == 0U) 
      
#line 1474 
      goto ldv_48623; else ;
    
#line 1478 
    writel(1073741824U,(void volatile *)q_vector_0->itr);
    
#line 1480 
    ldv_free_irq_80(entry->vector,(void *)q_vector_0);
  }
  ldv_48623: 
#line 1482 
  ;
  
#line 1466 
  if (vector != 0) 
#line 1468 
                   goto ldv_48624; else 
#line 1471 
                                        goto ldv_48625;
  ldv_48625: 
#line 1472 
  ;
  
#line 1483 
  __retres = err;
  return_label: 
#line 1483 
                return __retres;
}


#line 1486  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_up(struct fm10k_intfc *interface)
{
  
#line 1488 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1491 
  (*(hw->mac.ops.start_hw))(hw);
  
#line 1494 
  fm10k_configure_tx(interface);
  
#line 1497 
  fm10k_configure_rx(interface);
  
#line 1500 
  (*(hw->mac.ops.update_int_moderator))(hw);
  
#line 1503 
  clear_bit(1L,(unsigned long volatile *)(& interface->state));
  
#line 1506 
  fm10k_napi_enable_all(interface);
  
#line 1509 
  fm10k_restore_rx_state(interface);
  
#line 1512 
  netif_tx_start_all_queues(interface->netdev);
  
#line 1515 
  hw->mac.get_host_state = (_Bool)1;
  
#line 1516 
  ldv_mod_timer_81(& interface->service_timer,jiffies);
  
#line 1517 
  return;
}


#line 1519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_napi_disable_all(struct fm10k_intfc *interface)
{
  struct fm10k_q_vector *q_vector;
  int q_idx;
  
#line 1524 
  q_idx = 0;
  
#line 1524 
  goto ldv_48636;
  ldv_48635: 
#line 1525 
  ;
  
#line 1525 
  q_vector = interface->q_vector[q_idx];
  
#line 1526 
  napi_disable(& q_vector->napi);
  
#line 1524 
  q_idx += 1;
  ldv_48636: 
#line 1525 
  ;
  
#line 1524 
  if (interface->num_q_vectors > q_idx) 
#line 1526 
                                        goto ldv_48635; else 
#line 1529 
                                                             goto ldv_48637;
  ldv_48637: 
#line 1530 
  ;
  
#line 1531 
  return;
}


#line 1530  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_down(struct fm10k_intfc *interface)
{
  
#line 1532 
  struct net_device *netdev = interface->netdev;
  
#line 1533 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1536 
  clear_bit(1L,(unsigned long volatile *)(& interface->state));
  
#line 1539 
  netif_carrier_off(netdev);
  
#line 1542 
  netif_tx_stop_all_queues(netdev);
  
#line 1543 
  netif_tx_disable(netdev);
  
#line 1546 
  fm10k_reset_rx_state(interface);
  
#line 1549 
  usleep_range(10000UL,20000UL);
  
#line 1552 
  fm10k_napi_disable_all(interface);
  
#line 1555 
  fm10k_update_stats(interface);
  
#line 1558 
  (*(hw->mac.ops.stop_hw))(hw);
  
#line 1561 
  fm10k_clean_all_tx_rings(interface);
  
#line 1562 
  fm10k_clean_all_rx_rings(interface);
  
#line 1563 
  return;
}


#line 1573  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static int fm10k_sw_init(struct fm10k_intfc *interface, struct pci_device_id const *ent)
{
  int __retres;
  u32 rss_key[10U];
  unsigned int rss;
  int err;
  int tmp_1;
  u64 tmp_3;
  int tmp_6;
  s32 tmp_7;
  int tmp_9;
  bool tmp_8;
  u32 tmp_12;
  
#line 1576 
  struct fm10k_info const *fi = fm10k_info_tbl[ent->driver_data];
  
#line 1577 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1578 
  struct pci_dev *pdev = interface->pdev;
  
#line 1579 
  struct net_device *netdev = interface->netdev;
  
#line 1585 
  hw->back = (void *)interface;
  
#line 1586 
  hw->hw_addr = interface->uc_addr;
  
#line 1589 
  hw->vendor_id = pdev->vendor;
  
#line 1590 
  hw->device_id = pdev->device;
  
#line 1591 
  hw->revision_id = pdev->revision;
  
#line 1592 
  hw->subsystem_vendor_id = pdev->subsystem_vendor;
  
#line 1593 
  hw->subsystem_device_id = pdev->subsystem_device;
  
#line 1596 
  memcpy((void *)(& hw->mac.ops),(void const *)fi->mac_ops,176UL);
  
#line 1597 
  hw->mac.type = fi->mac;
  
#line 1600 
  if (fi->iov_ops != (struct fm10k_iov_ops *)0) 
#line 1601 
                                                memcpy((void *)(& hw->iov.ops),(void const *)fi->iov_ops,72UL); else ;
  {
    unsigned int tmp;
    int tmp_0;
    
#line 1604 
    int __min1 = 128;
    
#line 1604 
    tmp = cpumask_weight(cpu_online_mask);
    
#line 1604 
    int __min2 = (int)tmp;
    
#line 1604 
    if (__min1 < __min2) 
#line 1604 
                         tmp_0 = __min1; else 
#line 1604 
                                              tmp_0 = __min2;
    
#line 1604 
    tmp_1 = tmp_0;
  }
  
#line 1604 
  rss = (unsigned int)tmp_1;
  
#line 1605 
  interface->ring_feature[0].limit = (unsigned short)rss;
  
#line 1606 
  (*(fi->get_invariants))(hw);
  
#line 1609 
  if (hw->mac.ops.get_bus_info != (s32 (*)(struct fm10k_hw *))0) 
#line 1610 
                                                                 (*(hw->mac.ops.get_bus_info))(hw); else ;
  
#line 1613 
  if (hw->mac.ops.set_dma_mask != (void (*)(struct fm10k_hw *, u64 ))0) {
    u64 tmp_2;
    
#line 1614 
    tmp_2 = dma_get_mask(& pdev->dev);
    
#line 1614 
    ;
    
#line 1614 
    (*(hw->mac.ops.set_dma_mask))(hw,tmp_2);
  }
  else ;
  
#line 1617 
  tmp_3 = dma_get_mask(& pdev->dev);
  
#line 1617 
  if (tmp_3 > 4294967295ULL) {
    
#line 1618 
    netdev->features |= 32ULL;
    
#line 1619 
    netdev->vlan_features |= 32ULL;
  }
  else ;
  
#line 1623 
  interface->last_reset = jiffies + 2500UL;
  
#line 1626 
  tmp_7 = (*(hw->mac.ops.reset_hw))(hw);
  
#line 1626 
  tmp_6 = tmp_7 != 0;
  
#line 1626 
  if (tmp_6) ; else 
#line 1626 
                    tmp_6 = (*(hw->mac.ops.init_hw))(hw);
  
#line 1626 
  err = tmp_6;
  
#line 1627 
  if (err != 0) {
    
#line 1628 
    dev_err((struct device const *)(& pdev->dev),"init_hw failed: %d\n",err);
    
#line 1629 
    __retres = err;
    
#line 1629 
    goto return_label;
  }
  else ;
  
#line 1633 
  (*(hw->mac.ops.update_hw_stats))(hw,& interface->stats);
  
#line 1636 
  pci_sriov_set_totalvfs(pdev,(unsigned short)((int)hw->iov.total_vfs));
  
#line 1639 
  eth_random_addr((u8 *)(& hw->mac.addr));
  
#line 1642 
  err = (*(hw->mac.ops.read_mac_addr))(hw);
  
#line 1643 
  if (err != 0) {
    
#line 1644 
    dev_warn((struct device const *)(& pdev->dev),"Failed to obtain MAC address defaulting to random\n");
    
#line 1647 
    netdev->addr_assign_type = (unsigned char)((unsigned int)netdev->addr_assign_type | 1U);
  }
  else ;
  
#line 1650 
  memcpy((void *)netdev->dev_addr,(void const *)(& hw->mac.addr),(unsigned long)netdev->addr_len);
  
#line 1651 
  memcpy((void *)(& netdev->perm_addr),(void const *)(& hw->mac.addr),(unsigned long)netdev->addr_len);
  
#line 1653 
  tmp_8 = is_valid_ether_addr((u8 const *)(& netdev->perm_addr));
  
#line 1653 
  if (tmp_8) 
#line 1653 
             tmp_9 = 0; else 
#line 1653 
                             tmp_9 = 1;
  
#line 1653 
  if (tmp_9) {
    
#line 1654 
    dev_err((struct device const *)(& pdev->dev),"Invalid MAC Address\n");
    
#line 1655 
    __retres = -5;
    
#line 1655 
    goto return_label;
  }
  else ;
  
#line 1659 
  tmp_12 = fm10k_read_reg(hw,0);
  
#line 1659 
  if ((tmp_12 & 4U) != 0U) {
    void *tmp_11;
    resource_size_t tmp_10;
    
#line 1661 
    if (pdev->resource[4].start != 0ULL || pdev->resource[4].end != pdev->resource[4].start) 
      
#line 1661 
      tmp_10 = (pdev->resource[4].end - pdev->resource[4].start) + 1ULL; else 
                                                                    
#line 1661 
                                                                    tmp_10 = 0ULL;
    
#line 1660 
    ;
    
#line 1660 
    tmp_11 = ioremap(pdev->resource[4].start,(unsigned long)tmp_10);
    
#line 1660 
    interface->sw_addr = (u32 *)tmp_11;
  }
  else ;
  
#line 1662 
  hw->sw_addr = interface->sw_addr;
  
#line 1665 
  if (hw->mac.type != (unsigned int)fm10k_mac_pf) {
    
#line 1666 
    netdev->hw_enc_features = 0ULL;
    
#line 1667 
    netdev->features &= 18446744073642442751ULL;
    
#line 1668 
    netdev->hw_features &= 18446744073642442751ULL;
  }
  else ;
  
#line 1672 
  fm10k_dcbnl_set_ops(netdev);
  
#line 1675 
  clear_bit(3L,(unsigned long volatile *)(& interface->state));
  {
    struct lock_class_key __key;
    
#line 1676 
    init_timer_key(& interface->service_timer,0U,"((&interface->service_timer))",& __key);
  }
  
#line 1676 
  interface->service_timer.function = & fm10k_service_timer;
  
#line 1676 
  interface->service_timer.data = (unsigned long)interface;
  {
    struct lock_class_key __key_0;
    
#line 1678 
    __init_work(& interface->service_task,0);
    
#line 1678 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 1678 
    interface->service_task.data = __constr_expr_37;
    
#line 1678 
    lockdep_init_map(& interface->service_task.lockdep_map,"(&interface->service_task)",& __key_0,0);
    
#line 1678 
    INIT_LIST_HEAD(& interface->service_task.entry);
    
#line 1678 
    interface->service_task.func = & fm10k_service_task;
  }
  
#line 1681 
  ldv_mod_timer_82(& interface->service_timer,jiffies + 500UL);
  
#line 1684 
  fm10k_ts_init(interface);
  
#line 1687 
  interface->tx_ring_count = (unsigned short)256U;
  
#line 1688 
  interface->rx_ring_count = (unsigned short)256U;
  
#line 1691 
  interface->tx_itr = (unsigned short)100U;
  
#line 1692 
  interface->rx_itr = (unsigned short)32818U;
  
#line 1695 
  INIT_LIST_HEAD(& interface->vxlan_port);
  
#line 1697 
  netdev_rss_key_fill((void *)(& rss_key),40UL);
  
#line 1698 
  memcpy((void *)(& interface->rssrk),(void const *)(& rss_key),40UL);
  
#line 1701 
  clear_bit(1L,(unsigned long volatile *)(& interface->state));
  
#line 1703 
  __retres = 0;
  return_label: 
#line 1703 
                return __retres;
}


#line 1706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_slot_warn(struct fm10k_intfc *interface)
{
  bool tmp;
  char *tmp_1;
  char *tmp_3;
  
#line 1708 
  struct device *dev = & (interface->pdev)->dev;
  
#line 1709 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1711 
  tmp = (*(hw->mac.ops.is_slot_appropriate))(hw);
  
#line 1711 
  if ((int)tmp != 0) 
#line 1712 
                     goto return_label; else ;
  
#line 1716 
  if (hw->bus_caps.speed != (unsigned int)fm10k_bus_speed_2500) {
    char *tmp_0;
    
#line 1719 
    if (hw->bus_caps.speed == (unsigned int)fm10k_bus_speed_5000) 
#line 1719 
                                                                  tmp_0 = (char *)"5.0GT/s"; else 
                                                                    
#line 1719 
                                                                    tmp_0 = (char *)"8.0GT/s";
    
#line 1716 
    tmp_1 = tmp_0;
  }
  else 
#line 1716 
       tmp_1 = (char *)"2.5GT/s";
  
#line 1715 
  if (hw->bus_caps.width != (unsigned int)fm10k_bus_width_pcie_x1) {
    char *tmp_2;
    
#line 1716 
    if (hw->bus_caps.width == (unsigned int)fm10k_bus_width_pcie_x4) 
      
#line 1716 
      tmp_2 = (char *)"x4"; else 
#line 1716 
                                 tmp_2 = (char *)"x8";
    
#line 1715 
    tmp_3 = tmp_2;
  }
  else 
#line 1715 
       tmp_3 = (char *)"x1";
  
#line 1714 
  ;
  
#line 1714 
  dev_warn((struct device const *)dev,"For optimal performance, a %s %s slot is recommended.\n",tmp_3,tmp_1);
  
#line 1722 
  dev_warn((struct device const *)dev,"A slot with more lanes and/or higher speed is suggested.\n");
  return_label: 
#line 1724 
                return;
}


#line 1737  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static int fm10k_probe(struct pci_dev *pdev, struct pci_device_id const *ent)
{
  int __retres;
  struct net_device *netdev;
  struct fm10k_intfc *interface;
  struct fm10k_hw *hw;
  int err;
  int tmp;
  char *tmp_4;
  char *tmp_7;
  char *tmp_10;
  int tmp_11;
  
#line 1745 
  err = pci_enable_device_mem(pdev);
  
#line 1746 
  if (err != 0) {
    
#line 1747 
    __retres = err;
    
#line 1747 
    goto return_label;
  }
  else ;
  
#line 1749 
  err = dma_set_mask_and_coherent(& pdev->dev,281474976710655ULL);
  
#line 1750 
  if (err != 0) 
#line 1751 
                err = dma_set_mask_and_coherent(& pdev->dev,4294967295ULL); else ;
  
#line 1752 
  if (err != 0) {
    
#line 1753 
    dev_err((struct device const *)(& pdev->dev),"DMA configuration failed: %d\n",err);
    
#line 1755 
    goto err_dma;
  }
  else ;
  
#line 1758 
  tmp = pci_select_bars(pdev,512UL);
  
#line 1758 
  ;
  
#line 1758 
  err = pci_request_selected_regions(pdev,tmp,(char const *)(& fm10k_driver_name));
  
#line 1762 
  if (err != 0) {
    
#line 1763 
    dev_err((struct device const *)(& pdev->dev),"pci_request_selected_regions failed: %d\n",err);
    
#line 1765 
    goto err_pci_reg;
  }
  else ;
  
#line 1768 
  pci_enable_pcie_error_reporting(pdev);
  
#line 1770 
  pci_set_master(pdev);
  
#line 1771 
  pci_save_state(pdev);
  
#line 1773 
  netdev = fm10k_alloc_netdev();
  
#line 1774 
  if (netdev == (struct net_device *)0) {
    
#line 1775 
    err = -12;
    
#line 1776 
    goto err_alloc_netdev;
  }
  else ;
  
#line 1779 
  netdev->dev.parent = & pdev->dev;
  
#line 1781 
  interface = (struct fm10k_intfc *)netdev_priv((struct net_device const *)netdev);
  
#line 1782 
  pci_set_drvdata(pdev,(void *)interface);
  
#line 1784 
  interface->netdev = netdev;
  
#line 1785 
  interface->pdev = pdev;
  
#line 1786 
  hw = & interface->hw;
  
#line 1788 
  interface->uc_addr = (u32 *)ioremap(pdev->resource[0].start,1048576UL);
  
#line 1790 
  if (interface->uc_addr == (u32 *)0U) {
    
#line 1791 
    err = -5;
    
#line 1792 
    goto err_ioremap;
  }
  else ;
  
#line 1795 
  err = fm10k_sw_init(interface,ent);
  
#line 1796 
  if (err != 0) 
#line 1797 
                goto err_sw_init; else ;
  
#line 1800 
  fm10k_dbg_intfc_init(interface);
  
#line 1802 
  err = fm10k_init_queueing_scheme(interface);
  
#line 1803 
  if (err != 0) 
#line 1804 
                goto err_sw_init; else ;
  
#line 1806 
  err = fm10k_mbx_request_irq(interface);
  
#line 1807 
  if (err != 0) 
#line 1808 
                goto err_mbx_interrupt; else ;
  
#line 1811 
  err = fm10k_hw_ready(interface);
  
#line 1812 
  if (err != 0) 
#line 1813 
                goto err_register; else ;
  
#line 1815 
  err = ldv_register_netdev_83(netdev);
  
#line 1816 
  if (err != 0) 
#line 1817 
                goto err_register; else ;
  
#line 1820 
  netif_carrier_off(netdev);
  
#line 1823 
  netif_tx_stop_all_queues(netdev);
  
#line 1826 
  fm10k_ptp_register(interface);
  
#line 1829 
  if (hw->bus.payload != (unsigned int)fm10k_bus_payload_128) {
    char *tmp_3;
    
#line 1829 
    if (hw->bus.payload != (unsigned int)fm10k_bus_payload_256) {
      char *tmp_2;
      
#line 1829 
      if (hw->bus.payload == (unsigned int)fm10k_bus_payload_512) 
#line 1829 
                                                                  tmp_2 = (char *)"512B"; else 
                                                                    
#line 1829 
                                                                    tmp_2 = (char *)"Unknown";
      
#line 1829 
      tmp_3 = tmp_2;
    }
    else 
#line 1829 
         tmp_3 = (char *)"256B";
    
#line 1829 
    tmp_4 = tmp_3;
  }
  else 
#line 1829 
       tmp_4 = (char *)"128B";
  
#line 1829 
  if (hw->bus.width != (unsigned int)fm10k_bus_width_pcie_x8) {
    char *tmp_6;
    
#line 1829 
    if (hw->bus.width != (unsigned int)fm10k_bus_width_pcie_x4) {
      char *tmp_5;
      
#line 1829 
      if (hw->bus.width == (unsigned int)fm10k_bus_width_pcie_x1) 
#line 1829 
                                                                  tmp_5 = (char *)"x1"; else 
                                                                    
#line 1829 
                                                                    tmp_5 = (char *)"Unknown";
      
#line 1829 
      tmp_6 = tmp_5;
    }
    else 
#line 1829 
         tmp_6 = (char *)"x4";
    
#line 1829 
    tmp_7 = tmp_6;
  }
  else 
#line 1829 
       tmp_7 = (char *)"x8";
  
#line 1829 
  if (hw->bus.speed != (unsigned int)fm10k_bus_speed_8000) {
    char *tmp_9;
    
#line 1829 
    if (hw->bus.speed != (unsigned int)fm10k_bus_speed_5000) {
      char *tmp_8;
      
#line 1829 
      if (hw->bus.speed == (unsigned int)fm10k_bus_speed_2500) 
#line 1829 
                                                               tmp_8 = (char *)"2.5GT/s"; else 
                                                                    
#line 1829 
                                                                    tmp_8 = (char *)"Unknown";
      
#line 1829 
      tmp_9 = tmp_8;
    }
    else 
#line 1829 
         tmp_9 = (char *)"5.0GT/s";
    
#line 1829 
    tmp_10 = tmp_9;
  }
  else 
#line 1829 
       tmp_10 = (char *)"8.0GT/s";
  
#line 1829 
  ;
  
#line 1829 
  _dev_info((struct device const *)(& pdev->dev),"(PCI Express:%s Width: %s Payload: %s)\n",tmp_10,tmp_7,tmp_4);
  
#line 1844 
  fm10k_slot_warn(interface);
  
#line 1847 
  fm10k_iov_configure(pdev,0);
  
#line 1850 
  clear_bit(3L,(unsigned long volatile *)(& interface->state));
  
#line 1852 
  __retres = 0;
  
#line 1852 
  goto return_label;
  err_register: 
#line 1854 
  ;
  
#line 1855 
  fm10k_mbx_free_irq(interface);
  err_mbx_interrupt: 
#line 1856 
  ;
  
#line 1857 
  fm10k_clear_queueing_scheme(interface);
  err_sw_init: 
#line 1858 
  ;
  
#line 1859 
  if (interface->sw_addr != (u32 *)0U) 
#line 1860 
                                       iounmap((void volatile *)interface->sw_addr); else ;
  
#line 1861 
  iounmap((void volatile *)interface->uc_addr);
  err_ioremap: 
#line 1862 
  ;
  
#line 1863 
  ldv_free_netdev_84(netdev);
  err_alloc_netdev: 
#line 1864 
  ;
  
#line 1865 
  tmp_11 = pci_select_bars(pdev,512UL);
  
#line 1865 
  ;
  
#line 1865 
  pci_release_selected_regions(pdev,tmp_11);
  err_pci_reg: 
#line 1867 
  ;
  err_dma: 
#line 1868 
  ;
  
#line 1869 
  pci_disable_device(pdev);
  
#line 1870 
  __retres = err;
  return_label: 
#line 1870 
                return __retres;
}


#line 1882  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_remove(struct pci_dev *pdev)
{
  int tmp_0;
  
#line 1884 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 1885 
  struct net_device *netdev = interface->netdev;
  
#line 1887 
  ldv_del_timer_sync_85(& interface->service_timer);
  
#line 1889 
  clear_bit(3L,(unsigned long volatile *)(& interface->state));
  
#line 1890 
  cancel_work_sync(& interface->service_task);
  
#line 1893 
  if ((unsigned int)netdev->reg_state == 1U) 
#line 1894 
                                             ldv_unregister_netdev_86(netdev); else ;
  
#line 1897 
  fm10k_ptp_unregister(interface);
  
#line 1900 
  fm10k_iov_disable(pdev);
  
#line 1903 
  fm10k_mbx_free_irq(interface);
  
#line 1906 
  fm10k_clear_queueing_scheme(interface);
  
#line 1909 
  fm10k_dbg_intfc_exit(interface);
  
#line 1911 
  if (interface->sw_addr != (u32 *)0U) 
#line 1912 
                                       iounmap((void volatile *)interface->sw_addr); else ;
  
#line 1913 
  iounmap((void volatile *)interface->uc_addr);
  
#line 1915 
  ldv_free_netdev_87(netdev);
  
#line 1917 
  tmp_0 = pci_select_bars(pdev,512UL);
  
#line 1917 
  ;
  
#line 1917 
  pci_release_selected_regions(pdev,tmp_0);
  
#line 1920 
  pci_disable_pcie_error_reporting(pdev);
  
#line 1922 
  pci_disable_device(pdev);
  
#line 1923 
  return;
}


#line 1934  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static int fm10k_resume(struct pci_dev *pdev)
{
  int __retres;
  u32 err;
  int tmp_0;
  s32 tmp_1;
  int tmp_2;
  
#line 1936 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 1937 
  struct net_device *netdev = interface->netdev;
  
#line 1938 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1941 
  pci_set_power_state(pdev,0);
  
#line 1942 
  pci_restore_state(pdev);
  
#line 1947 
  pci_save_state(pdev);
  
#line 1949 
  tmp_0 = pci_enable_device_mem(pdev);
  
#line 1949 
  err = (unsigned int)tmp_0;
  
#line 1950 
  if (err != 0U) {
    
#line 1951 
    dev_err((struct device const *)(& pdev->dev),"Cannot enable PCI device from suspend\n");
    
#line 1952 
    __retres = (int)err;
    
#line 1952 
    goto return_label;
  }
  else ;
  
#line 1954 
  pci_set_master(pdev);
  
#line 1956 
  pci_wake_from_d3(pdev,(_Bool)0);
  
#line 1959 
  hw->hw_addr = interface->uc_addr;
  
#line 1962 
  tmp_1 = (*(hw->mac.ops.init_hw))(& interface->hw);
  
#line 1962 
  err = (unsigned int)tmp_1;
  
#line 1963 
  if (err != 0U) {
    
#line 1964 
    __retres = (int)err;
    
#line 1964 
    goto return_label;
  }
  else ;
  
#line 1967 
  (*(hw->mac.ops.rebind_hw_stats))(hw,& interface->stats);
  
#line 1970 
  fm10k_ts_reset(interface);
  
#line 1972 
  rtnl_lock();
  
#line 1974 
  tmp_2 = fm10k_init_queueing_scheme(interface);
  
#line 1974 
  err = (unsigned int)tmp_2;
  
#line 1975 
  if (err == 0U) {
    bool tmp_4;
    
#line 1976 
    fm10k_mbx_request_irq(interface);
    
#line 1977 
    tmp_4 = netif_running((struct net_device const *)netdev);
    
#line 1977 
    if ((int)tmp_4 != 0) {
      int tmp_3;
      
#line 1978 
      tmp_3 = fm10k_open(netdev);
      
#line 1978 
      err = (unsigned int)tmp_3;
    }
    else ;
  }
  else ;
  
#line 1981 
  rtnl_unlock();
  
#line 1983 
  if (err != 0U) {
    
#line 1984 
    __retres = (int)err;
    
#line 1984 
    goto return_label;
  }
  else ;
  
#line 1987 
  fm10k_iov_resume(pdev);
  
#line 1989 
  netif_device_attach(netdev);
  
#line 1991 
  __retres = 0;
  return_label: 
#line 1991 
                return __retres;
}


#line 2002  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static int fm10k_suspend(struct pci_dev *pdev, pm_message_t state)
{
  int __retres;
  bool tmp_0;
  
#line 2005 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 2006 
  struct net_device *netdev = interface->netdev;
  
#line 2007 
  int err = 0;
  
#line 2009 
  netif_device_detach(netdev);
  
#line 2011 
  fm10k_iov_suspend(pdev);
  
#line 2013 
  rtnl_lock();
  
#line 2015 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 2015 
  if ((int)tmp_0 != 0) 
#line 2016 
                       fm10k_close(netdev); else ;
  
#line 2018 
  fm10k_mbx_free_irq(interface);
  
#line 2020 
  fm10k_clear_queueing_scheme(interface);
  
#line 2022 
  rtnl_unlock();
  
#line 2024 
  err = pci_save_state(pdev);
  
#line 2025 
  if (err != 0) {
    
#line 2026 
    __retres = err;
    
#line 2026 
    goto return_label;
  }
  else ;
  
#line 2028 
  pci_disable_device(pdev);
  
#line 2029 
  pci_wake_from_d3(pdev,(_Bool)0);
  
#line 2030 
  pci_set_power_state(pdev,3);
  
#line 2032 
  __retres = 0;
  return_label: 
#line 2032 
                return __retres;
}


#line 2044  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static pci_ers_result_t fm10k_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
{
  pci_ers_result_t __retres;
  bool tmp_0;
  
#line 2047 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 2048 
  struct net_device *netdev = interface->netdev;
  
#line 2050 
  netif_device_detach(netdev);
  
#line 2052 
  if (state == 3U) {
    
#line 2053 
    __retres = 4U;
    
#line 2053 
    goto return_label;
  }
  else ;
  
#line 2055 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 2055 
  if ((int)tmp_0 != 0) 
#line 2056 
                       fm10k_close(netdev); else ;
  
#line 2058 
  fm10k_mbx_free_irq(interface);
  
#line 2060 
  pci_disable_device(pdev);
  
#line 2063 
  __retres = 3U;
  return_label: 
#line 2063 
                return __retres;
}


#line 2072  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static pci_ers_result_t fm10k_io_slot_reset(struct pci_dev *pdev)
{
  pci_ers_result_t result;
  int tmp_0;
  
#line 2074 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 2077 
  tmp_0 = pci_enable_device_mem(pdev);
  
#line 2077 
  if (tmp_0 != 0) {
    
#line 2078 
    dev_err((struct device const *)(& pdev->dev),"Cannot re-enable PCI device after reset.\n");
    
#line 2080 
    result = 4U;
  }
  else {
    
#line 2082 
    pci_set_master(pdev);
    
#line 2083 
    pci_restore_state(pdev);
    
#line 2088 
    pci_save_state(pdev);
    
#line 2090 
    pci_wake_from_d3(pdev,(_Bool)0);
    
#line 2093 
    interface->hw.hw_addr = interface->uc_addr;
    
#line 2095 
    interface->flags |= 1U;
    
#line 2096 
    fm10k_service_event_schedule(interface);
    
#line 2098 
    result = 5U;
  }
  
#line 2101 
  pci_cleanup_aer_uncorrect_error_status(pdev);
  
#line 2103 
  return result;
}


#line 2113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static void fm10k_io_resume(struct pci_dev *pdev)
{
  bool tmp_0;
  int tmp_2;
  
#line 2115 
  struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  
#line 2116 
  struct net_device *netdev = interface->netdev;
  
#line 2117 
  struct fm10k_hw *hw = & interface->hw;
  
#line 2118 
  int err = 0;
  
#line 2121 
  (*(hw->mac.ops.init_hw))(& interface->hw);
  
#line 2124 
  (*(hw->mac.ops.rebind_hw_stats))(hw,& interface->stats);
  
#line 2127 
  fm10k_mbx_request_irq(interface);
  
#line 2130 
  fm10k_ts_reset(interface);
  
#line 2132 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 2132 
  if ((int)tmp_0 != 0) 
#line 2133 
                       err = fm10k_open(netdev); else ;
  
#line 2136 
  tmp_2 = err != 0;
  
#line 2136 
  if (tmp_2) ; else 
#line 2136 
                    tmp_2 = fm10k_hw_ready(interface);
  
#line 2136 
  err = tmp_2;
  
#line 2138 
  if (err == 0) 
#line 2139 
                netif_device_attach(netdev); else ;
  
#line 2140 
  return;
}


#line 2142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static struct pci_error_handlers const fm10k_err_handler = {.error_detected = (pci_ers_result_t (*)(struct pci_dev *, enum pci_channel_state ))(& fm10k_io_error_detected), .mmio_enabled = (pci_ers_result_t (*)(struct pci_dev *))0, .link_reset = (pci_ers_result_t (*)(struct pci_dev *))0, .slot_reset = & fm10k_io_slot_reset, .reset_notify = (void (*)(struct pci_dev *, bool ))0, .resume = & fm10k_io_resume};

#line 2148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
static struct pci_driver fm10k_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = (char const *)(& fm10k_driver_name), .id_table = (struct pci_device_id const *)(& fm10k_pci_tbl), .probe = & fm10k_probe, .remove = & fm10k_remove, .suspend = & fm10k_suspend, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = & fm10k_resume, .shutdown = (void (*)(struct pci_dev *))0, .sriov_configure = & fm10k_iov_configure, .err_handler = & fm10k_err_handler, .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 2166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
int fm10k_register_pci_driver(void)
{
  int tmp;
  
#line 2168 
  tmp = ldv___pci_register_driver_88(& fm10k_driver,& __this_module,"fm10k");
  
#line 2168 
  return tmp;
}


#line 2176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pci.c"
void fm10k_unregister_pci_driver(void)
{
  
#line 2178 
  ldv_pci_unregister_driver_89(& fm10k_driver);
  
#line 2179 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
struct pci_driver *ldv_emg_alias_fm10k_driver_2 = & fm10k_driver;

#line 59 
int ldv_emg_del_timer_sync(struct timer_list *arg0);


#line 60 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 61 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 62 
_Bool ldv_emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1);


#line 64 
void ldv_emg_unregister_netdev(struct net_device *arg0);


#line 65 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 66 
int ldv_emg_register_netdev(struct net_device *arg0);


#line 67 
void ldv_emg_free_netdev(struct net_device *arg0);


#line 69 
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1);


#line 70 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
int ldv_emg_wrapper_fm10k_probe_2(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 75 
  tmp = fm10k_probe(arg0,(struct pci_device_id const *)arg1);
  
#line 75 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
void ldv_emg_wrapper_fm10k_remove_4(struct pci_dev *arg0)
{
  
#line 80 
  fm10k_remove(arg0);
  
#line 81 
  return;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
int ldv_emg_wrapper_fm10k_suspend_3(struct pci_dev *arg0, struct pm_message arg1)
{
  int tmp;
  
#line 85 
  tmp = fm10k_suspend(arg0,arg1);
  
#line 85 
  return tmp;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
int ldv_emg_wrapper_fm10k_resume_5(struct pci_dev *arg0)
{
  int tmp;
  
#line 90 
  tmp = fm10k_resume(arg0);
  
#line 90 
  return tmp;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
enum irqreturn ldv_emg_wrapper_fm10k_msix_clean_rings_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 95 
  tmp = fm10k_msix_clean_rings(arg0,arg1);
  
#line 95 
  return tmp;
}


#line 99  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
enum irqreturn ldv_emg_wrapper_fm10k_msix_mbx_pf_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 100 
  tmp = fm10k_msix_mbx_pf(arg0,arg1);
  
#line 100 
  return tmp;
}


#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
enum irqreturn ldv_emg_wrapper_fm10k_msix_mbx_vf_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 105 
  tmp = fm10k_msix_mbx_vf(arg0,arg1);
  
#line 105 
  return tmp;
}


#line 655  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_spin_lock_61(spinlock_t *lock)
{
  
#line 659 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 661 
  spin_lock(lock);
  
#line 662 
  return;
}


#line 698  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_spin_unlock_64(spinlock_t *lock)
{
  
#line 702 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 704 
  spin_unlock(lock);
  
#line 705 
  return;
}


#line 788  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static bool ldv_queue_work_73(struct workqueue_struct *wq, struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 792 
  tmp = ldv_emg_queue_work(wq,work);
  
#line 792 
  __retres = tmp != 0;
  
#line 792 
  return __retres;
}


#line 796  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv_mod_timer_74(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 800 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 800 
  return tmp;
}


#line 804  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_free_irq_75(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 808 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 809 
  return;
}


#line 812  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv_request_irq_76(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 816 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 816 
  return tmp;
}


#line 820  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv_request_irq_77(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 824 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 824 
  return tmp;
}


#line 828  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_free_irq_78(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 832 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 833 
  return;
}


#line 836  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv_request_irq_79(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 840 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 840 
  return tmp;
}


#line 844  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_free_irq_80(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 848 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 849 
  return;
}


#line 852  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv_mod_timer_81(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 856 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 856 
  return tmp;
}


#line 860  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv_mod_timer_82(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 864 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 864 
  return tmp;
}


#line 868  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv_register_netdev_83(struct net_device *ldv_func_arg1)
{
  int tmp;
  
#line 872 
  tmp = ldv_emg_register_netdev(ldv_func_arg1);
  
#line 872 
  return tmp;
}


#line 876  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_free_netdev_84(struct net_device *ldv_func_arg1)
{
  
#line 880 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 881 
  return;
}


#line 884  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv_del_timer_sync_85(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 888 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 888 
  return tmp;
}


#line 892  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_unregister_netdev_86(struct net_device *ldv_func_arg1)
{
  
#line 896 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 897 
  return;
}


#line 900  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_free_netdev_87(struct net_device *ldv_func_arg1)
{
  
#line 904 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 905 
  return;
}


#line 908  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static int ldv___pci_register_driver_88(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 912 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 912 
  return tmp;
}


#line 916  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_pci.c.aux"
static void ldv_pci_unregister_driver_89(struct pci_driver *ldv_func_arg1)
{
  
#line 920 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 921 
  return;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
char *strncpy(char *, char const *, __kernel_size_t);


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vmalloc(unsigned long);


#line 83 
void vfree(void const *);


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
u32 ethtool_op_get_link(struct net_device *);


#line 1816  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netdev_get_num_tc(struct net_device *dev)
{
  int __retres;
  
#line 1818 
  __retres = (int)dev->num_tc;
  
#line 1818 
  return __retres;
}


#line 3830 
void netdev_warn(struct net_device const *, char const * , ...);


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
int ptp_clock_index(struct ptp_clock *);


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static void fm10k_mbx_lock_1(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 360 
  goto ldv_46934;
  ldv_46933: 
#line 361 
  ;
  
#line 361 
  __const_udelay(85900UL);
  ldv_46934: 
#line 363 
  ;
  
#line 360 
  tmp = test_and_set_bit(4L,(unsigned long volatile *)(& interface->state));
  
#line 360 
  if (tmp != 0) 
#line 362 
                goto ldv_46933; else 
#line 365 
                                     goto ldv_46935;
  ldv_46935: 
#line 366 
  ;
  
#line 367 
  return;
}


#line 441 
char const fm10k_driver_version[9U];


#line 469 
int fm10k_setup_rx_resources(struct fm10k_ring *rx_ring);


#line 470 
int fm10k_setup_tx_resources(struct fm10k_ring *tx_ring);


#line 471 
void fm10k_free_rx_resources(struct fm10k_ring *rx_ring);


#line 472 
void fm10k_free_tx_resources(struct fm10k_ring *tx_ring);


#line 479 
int fm10k_setup_tc(struct net_device *dev, u8 tc);


#line 484 
void fm10k_set_ethtool_ops(struct net_device *dev);


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static struct fm10k_stats const fm10k_gstrings_net_stats[10U] = {{.stat_string = {(char)'t', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 8}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 24}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 40}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 0}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 16}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 32}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 48}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 80}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 96}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'i', (char)'f', (char)'o', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 112}};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static struct fm10k_stats const fm10k_gstrings_global_stats[24U] = {{.stat_string = {(char)'t', (char)'x', (char)'_', (char)'r', (char)'e', (char)'s', (char)'t', (char)'a', (char)'r', (char)'t', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1600}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'u', (char)'s', (char)'y', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1608}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'s', (char)'u', (char)'m', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1616}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'a', (char)'l', (char)'l', (char)'o', (char)'c', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1624}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'s', (char)'u', (char)'m', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1632}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1648}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1640}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1664}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1656}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'s', (char)'_', (char)'n', (char)'i', (char)'c', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1672}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'_', (char)'p', (char)'f', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1680}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'r', (char)'u', (char)'n', (char)'_', (char)'v', (char)'f', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1688}, {.stat_string = {(char)'s', (char)'w', (char)'a', (char)'p', (char)'i', (char)'_', (char)'s', (char)'t', (char)'a', (char)'t', (char)'u', (char)'s', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 18296}, {.stat_string = {(char)'m', (char)'a', (char)'c', (char)'_', (char)'r', (char)'u', (char)'l', (char)'e', (char)'s', (char)'_', (char)'u', (char)'s', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 18300}, {.stat_string = {(char)'m', (char)'a', (char)'c', (char)'_', (char)'r', (char)'u', (char)'l', (char)'e', (char)'s', (char)'_', (char)'a', (char)'v', (char)'a', (char)'i', (char)'l', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 18304}, {.stat_string = {(char)'m', (char)'b', (char)'x', (char)'_', (char)'t', (char)'x', (char)'_', (char)'b', (char)'u', (char)'s', (char)'y', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 15680}, {.stat_string = {(char)'m', (char)'b', (char)'x', (char)'_', (char)'t', (char)'x', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'s', (char)'i', (char)'z', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 15688}, {.stat_string = {(char)'m', (char)'b', (char)'x', (char)'_', (char)'t', (char)'x', (char)'_', (char)'m', (char)'e', (char)'s', (char)'s', (char)'a', (char)'g', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 15696}, {.stat_string = {(char)'m', (char)'b', (char)'x', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'w', (char)'o', (char)'r', (char)'d', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 15704}, {.stat_string = {(char)'m', (char)'b', (char)'x', (char)'_', (char)'r', (char)'x', (char)'_', (char)'m', (char)'e', (char)'s', (char)'s', (char)'a', (char)'g', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 15712}, {.stat_string = {(char)'m', (char)'b', (char)'x', (char)'_', (char)'r', (char)'x', (char)'_', (char)'d', (char)'w', (char)'o', (char)'r', (char)'d', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 15720}, {.stat_string = {(char)'m', (char)'b', (char)'x', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'r', (char)'s', (char)'e', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 15728}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'h', (char)'a', (char)'n', (char)'g', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 1696}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'h', (char)'w', (char)'t', (char)'s', (char)'t', (char)'a', (char)'m', (char)'p', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'o', (char)'u', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 19008}};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static struct fm10k_stats const fm10k_gstrings_pf_stats[8U] = {{.stat_string = {(char)'t', (char)'i', (char)'m', (char)'e', (char)'o', (char)'u', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 4816}, {.stat_string = {(char)'u', (char)'r', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 4832}, {.stat_string = {(char)'c', (char)'a', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 4848}, {.stat_string = {(char)'u', (char)'m', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 4864}, {.stat_string = {(char)'x', (char)'e', (char)'c', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 4880}, {.stat_string = {(char)'v', (char)'l', (char)'a', (char)'n', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 4896}, {.stat_string = {(char)'l', (char)'o', (char)'o', (char)'p', (char)'b', (char)'a', (char)'c', (char)'k', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 4912}, {.stat_string = {(char)'n', (char)'o', (char)'d', (char)'e', (char)'s', (char)'c', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 4928}};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static char const fm10k_gstrings_test[1U][32U] = {{(char)'M', (char)'a', (char)'i', (char)'l', (char)'b', (char)'o', (char)'x', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'(', (char)'o', (char)'n', (char)'/', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_strings(struct net_device *dev, u32 stringset, u8 *data)
{
  unsigned int i;
  
#line 125 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 126 
  char *p = (char *)data;
  
#line 129 
  switch (stringset) {
    case (u32)0: 
#line 130 
    ;
    
#line 131 
    memcpy((void *)data,(void const *)(& fm10k_gstrings_test),32UL);
    
#line 133 
    goto ldv_47138;
    case (u32)1: 
#line 134 
    ;
    
#line 135 
    i = 0U;
    
#line 135 
    goto ldv_47144;
    ldv_47143: 
#line 136 
    ;
    
#line 136 
    memcpy((void *)p,(void const *)(& fm10k_gstrings_net_stats[i].stat_string),32UL);
    
#line 138 
    p += 32U;
    
#line 135 
    i += 1U;
    ldv_47144: 
#line 136 
    ;
    
#line 135 
    if (i <= 9U) 
#line 137 
                 goto ldv_47143; else 
#line 140 
                                      goto ldv_47145;
    ldv_47145: 
#line 141 
    ;
    
#line 140 
    i = 0U;
    
#line 140 
    goto ldv_47150;
    ldv_47149: 
#line 141 
    ;
    
#line 141 
    memcpy((void *)p,(void const *)(& fm10k_gstrings_global_stats[i].stat_string),32UL);
    
#line 143 
    p += 32U;
    
#line 140 
    i += 1U;
    ldv_47150: 
#line 141 
    ;
    
#line 140 
    if (i <= 23U) 
#line 142 
                  goto ldv_47149; else 
#line 145 
                                       goto ldv_47151;
    ldv_47151: 
#line 146 
    ;
    
#line 146 
    if (interface->hw.mac.type != (unsigned int)fm10k_mac_vf) {
      
#line 147 
      i = 0U;
      
#line 147 
      goto ldv_47156;
      ldv_47155: 
#line 148 
      ;
      
#line 148 
      memcpy((void *)p,(void const *)(& fm10k_gstrings_pf_stats[i].stat_string),32UL);
      
#line 150 
      p += 32U;
      
#line 147 
      i += 1U;
      ldv_47156: 
#line 148 
      ;
      
#line 147 
      if (i <= 7U) 
#line 149 
                   goto ldv_47155; else 
#line 152 
                                        goto ldv_47157;
      ldv_47157: 
#line 153 
      ;
    }
    else ;
    
#line 154 
    i = 0U;
    
#line 154 
    goto ldv_47159;
    ldv_47158: 
#line 155 
    ;
    
#line 155 
    sprintf(p,"tx_queue_%u_packets",i);
    
#line 156 
    p += 32U;
    
#line 157 
    sprintf(p,"tx_queue_%u_bytes",i);
    
#line 158 
    p += 32U;
    
#line 159 
    sprintf(p,"rx_queue_%u_packets",i);
    
#line 160 
    p += 32U;
    
#line 161 
    sprintf(p,"rx_queue_%u_bytes",i);
    
#line 162 
    p += 32U;
    
#line 154 
    i += 1U;
    ldv_47159: 
#line 155 
    ;
    
#line 154 
    if ((unsigned int)interface->hw.mac.max_queues > i) 
#line 156 
                                                        goto ldv_47158; else 
                                                                    
#line 159 
                                                                    goto ldv_47160;
    ldv_47160: 
#line 160 
    ;
    
#line 164 
    goto ldv_47138;
  }
  ldv_47138: 
#line 166 
  ;
  
#line 167 
  return;
}


#line 168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_get_sset_count(struct net_device *dev, int sset)
{
  int __retres;
  
#line 170 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 171 
  struct fm10k_hw *hw = & interface->hw;
  
#line 172 
  int stats_len = 34;
  
#line 174 
  switch (sset) {
    case 0: 
#line 175 
    ;
    
#line 176 
    __retres = 1;
    
#line 176 
    goto return_label;
    case 1: 
#line 177 
    ;
    
#line 178 
    stats_len = (int)((unsigned int)hw->mac.max_queues * 4U + (unsigned int)stats_len);
    
#line 180 
    if (hw->mac.type != (unsigned int)fm10k_mac_vf) 
#line 181 
                                                    stats_len = (int)((unsigned int)stats_len + 8U); else ;
    
#line 183 
    __retres = stats_len;
    
#line 183 
    goto return_label;
    default: 
#line 184 
    ;
    
#line 185 
    __retres = -95;
    
#line 185 
    goto return_label;
  }
  return_label: 
#line 174 
                return __retres;
}


#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_ethtool_stats(struct net_device *netdev, struct ethtool_stats *stats, u64 *data)
{
  char *p;
  int i;
  int j;
  u64 *tmp_0;
  u64 *tmp_1;
  
#line 193 
  int const stat_count = 2;
  
#line 194 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 195 
  struct net_device_stats *net_stats = & netdev->stats;
  
#line 199 
  fm10k_update_stats(interface);
  
#line 201 
  i = 0;
  
#line 201 
  goto ldv_47195;
  ldv_47194: 
#line 202 
  ;
  
#line 202 
  p = (char *)net_stats + fm10k_gstrings_net_stats[i].stat_offset;
  
#line 203 
  tmp_0 = data;
  
#line 203 
  data += 1;
  
#line 203 
  if (fm10k_gstrings_net_stats[i].sizeof_stat == 8) 
#line 203 
                                                    *tmp_0 = *((u64 *)p); else 
                                                                    
#line 203 
                                                                    *tmp_0 = (unsigned long long)*((u32 *)p);
  
#line 201 
  i += 1;
  ldv_47195: 
#line 202 
  ;
  
#line 201 
  if ((unsigned int)i <= 9U) 
#line 203 
                             goto ldv_47194; else 
#line 206 
                                                  goto ldv_47196;
  ldv_47196: 
#line 207 
  ;
  
#line 207 
  i = 0;
  
#line 207 
  goto ldv_47201;
  ldv_47200: 
#line 208 
  ;
  
#line 208 
  p = (char *)interface + fm10k_gstrings_global_stats[i].stat_offset;
  
#line 210 
  tmp_1 = data;
  
#line 210 
  data += 1;
  
#line 210 
  if (fm10k_gstrings_global_stats[i].sizeof_stat == 8) 
#line 210 
                                                       *tmp_1 = *((u64 *)p); else 
                                                                    
#line 210 
                                                                    *tmp_1 = (unsigned long long)*((u32 *)p);
  
#line 207 
  i += 1;
  ldv_47201: 
#line 208 
  ;
  
#line 207 
  if ((unsigned int)i <= 23U) 
#line 209 
                              goto ldv_47200; else 
#line 212 
                                                   goto ldv_47202;
  ldv_47202: 
#line 213 
  ;
  
#line 214 
  if (interface->hw.mac.type != (unsigned int)fm10k_mac_vf) {
    u64 *tmp_2;
    
#line 215 
    i = 0;
    
#line 215 
    goto ldv_47207;
    ldv_47206: 
#line 216 
    ;
    
#line 216 
    p = (char *)interface + fm10k_gstrings_pf_stats[i].stat_offset;
    
#line 218 
    tmp_2 = data;
    
#line 218 
    data += 1;
    
#line 218 
    if (fm10k_gstrings_pf_stats[i].sizeof_stat == 8) 
#line 218 
                                                     *tmp_2 = *((u64 *)p); else 
                                                                    
#line 218 
                                                                    *tmp_2 = (unsigned long long)*((u32 *)p);
    
#line 215 
    i += 1;
    ldv_47207: 
#line 216 
    ;
    
#line 215 
    if ((unsigned int)i <= 7U) 
#line 217 
                               goto ldv_47206; else 
#line 220 
                                                    goto ldv_47208;
    ldv_47208: 
#line 221 
    ;
  }
  else ;
  
#line 222 
  i = 0;
  
#line 222 
  goto ldv_47218;
  ldv_47217: 
#line 223 
  ;
  {
    struct fm10k_ring *ring;
    u64 *queue_stat;
    u64 *tmp_3;
    u64 *tmp_4;
    
#line 226 
    ring = interface->tx_ring[i];
    
#line 227 
    if (ring != (struct fm10k_ring *)0) 
#line 228 
                                        queue_stat = (u64 *)(& ring->stats); else ;
    
#line 229 
    j = 0;
    
#line 229 
    goto ldv_47212;
    ldv_47211: 
#line 230 
    ;
    
#line 230 
    tmp_3 = data;
    
#line 230 
    data += 1;
    
#line 230 
    if (ring != (struct fm10k_ring *)0) 
#line 230 
                                        *tmp_3 = *(queue_stat + j); else 
                                                                    
#line 230 
                                                                    *tmp_3 = 0ULL;
    
#line 229 
    j += 1;
    ldv_47212: 
#line 230 
    ;
    
#line 229 
    if (j <= 1) 
#line 231 
                goto ldv_47211; else 
#line 234 
                                     goto ldv_47213;
    ldv_47213: 
#line 235 
    ;
    
#line 232 
    ring = interface->rx_ring[i];
    
#line 233 
    if (ring != (struct fm10k_ring *)0) 
#line 234 
                                        queue_stat = (u64 *)(& ring->stats); else ;
    
#line 235 
    j = 0;
    
#line 235 
    goto ldv_47215;
    ldv_47214: 
#line 236 
    ;
    
#line 236 
    tmp_4 = data;
    
#line 236 
    data += 1;
    
#line 236 
    if (ring != (struct fm10k_ring *)0) 
#line 236 
                                        *tmp_4 = *(queue_stat + j); else 
                                                                    
#line 236 
                                                                    *tmp_4 = 0ULL;
    
#line 235 
    j += 1;
    ldv_47215: 
#line 236 
    ;
    
#line 235 
    if (j <= 1) 
#line 237 
                goto ldv_47214; else 
#line 240 
                                     goto ldv_47216;
    ldv_47216: 
#line 241 
    ;
  }
  
#line 222 
  i += 1;
  ldv_47218: 
#line 223 
  ;
  
#line 222 
  if ((int)interface->hw.mac.max_queues > i) 
#line 224 
                                             goto ldv_47217; else 
#line 227 
                                                                  goto ldv_47219;
  ldv_47219: 
#line 228 
  ;
  
#line 229 
  return;
}


#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_reg_q(struct fm10k_hw *hw, u32 *buff, int i)
{
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_17;
  int tmp_18;
  int tmp_19;
  int tmp_20;
  int tmp_21;
  int tmp_22;
  int tmp_23;
  int tmp_24;
  int tmp_25;
  int tmp_26;
  int tmp_27;
  
#line 245 
  int idx = 0;
  
#line 247 
  tmp = idx;
  
#line 247 
  idx += 1;
  
#line 247 
  *(buff + tmp) = fm10k_read_reg(hw,(i + 256) * 64);
  
#line 248 
  tmp_0 = idx;
  
#line 248 
  idx += 1;
  
#line 248 
  *(buff + tmp_0) = fm10k_read_reg(hw,i * 64 + 16385);
  
#line 249 
  tmp_1 = idx;
  
#line 249 
  idx += 1;
  
#line 249 
  *(buff + tmp_1) = fm10k_read_reg(hw,i * 64 + 16386);
  
#line 250 
  tmp_2 = idx;
  
#line 250 
  idx += 1;
  
#line 250 
  *(buff + tmp_2) = fm10k_read_reg(hw,i * 64 + 16387);
  
#line 251 
  tmp_3 = idx;
  
#line 251 
  idx += 1;
  
#line 251 
  *(buff + tmp_3) = fm10k_read_reg(hw,i * 64 + 16388);
  
#line 252 
  tmp_4 = idx;
  
#line 252 
  idx += 1;
  
#line 252 
  *(buff + tmp_4) = fm10k_read_reg(hw,i * 64 + 16389);
  
#line 253 
  tmp_5 = idx;
  
#line 253 
  idx += 1;
  
#line 253 
  *(buff + tmp_5) = fm10k_read_reg(hw,i * 64 + 16390);
  
#line 254 
  tmp_6 = idx;
  
#line 254 
  idx += 1;
  
#line 254 
  *(buff + tmp_6) = fm10k_read_reg(hw,i * 64 + 16391);
  
#line 255 
  tmp_7 = idx;
  
#line 255 
  idx += 1;
  
#line 255 
  *(buff + tmp_7) = fm10k_read_reg(hw,i * 64 + 16392);
  
#line 256 
  tmp_8 = idx;
  
#line 256 
  idx += 1;
  
#line 256 
  *(buff + tmp_8) = fm10k_read_reg(hw,i * 64 + 16393);
  
#line 257 
  tmp_9 = idx;
  
#line 257 
  idx += 1;
  
#line 257 
  *(buff + tmp_9) = fm10k_read_reg(hw,i * 64 + 16394);
  
#line 258 
  tmp_10 = idx;
  
#line 258 
  idx += 1;
  
#line 258 
  *(buff + tmp_10) = fm10k_read_reg(hw,i * 64 + 16395);
  
#line 259 
  tmp_11 = idx;
  
#line 259 
  idx += 1;
  
#line 259 
  *(buff + tmp_11) = fm10k_read_reg(hw,i * 64 + 16396);
  
#line 260 
  tmp_12 = idx;
  
#line 260 
  idx += 1;
  
#line 260 
  *(buff + tmp_12) = fm10k_read_reg(hw,i * 64 + 16397);
  
#line 261 
  tmp_13 = idx;
  
#line 261 
  idx += 1;
  
#line 261 
  *(buff + tmp_13) = fm10k_read_reg(hw,(i + 512) * 64);
  
#line 262 
  tmp_14 = idx;
  
#line 262 
  idx += 1;
  
#line 262 
  *(buff + tmp_14) = fm10k_read_reg(hw,i * 64 + 32769);
  
#line 263 
  tmp_15 = idx;
  
#line 263 
  idx += 1;
  
#line 263 
  *(buff + tmp_15) = fm10k_read_reg(hw,i * 64 + 32770);
  
#line 264 
  tmp_16 = idx;
  
#line 264 
  idx += 1;
  
#line 264 
  *(buff + tmp_16) = fm10k_read_reg(hw,i * 64 + 32771);
  
#line 265 
  tmp_17 = idx;
  
#line 265 
  idx += 1;
  
#line 265 
  *(buff + tmp_17) = fm10k_read_reg(hw,i * 64 + 32772);
  
#line 266 
  tmp_18 = idx;
  
#line 266 
  idx += 1;
  
#line 266 
  *(buff + tmp_18) = fm10k_read_reg(hw,i * 64 + 32773);
  
#line 267 
  tmp_19 = idx;
  
#line 267 
  idx += 1;
  
#line 267 
  *(buff + tmp_19) = fm10k_read_reg(hw,i * 64 + 32774);
  
#line 268 
  tmp_20 = idx;
  
#line 268 
  idx += 1;
  
#line 268 
  *(buff + tmp_20) = fm10k_read_reg(hw,i * 64 + 32775);
  
#line 269 
  tmp_21 = idx;
  
#line 269 
  idx += 1;
  
#line 269 
  *(buff + tmp_21) = fm10k_read_reg(hw,i * 64 + 32776);
  
#line 270 
  tmp_22 = idx;
  
#line 270 
  idx += 1;
  
#line 270 
  *(buff + tmp_22) = fm10k_read_reg(hw,i * 64 + 32777);
  
#line 271 
  tmp_23 = idx;
  
#line 271 
  idx += 1;
  
#line 271 
  *(buff + tmp_23) = fm10k_read_reg(hw,i * 64 + 32778);
  
#line 272 
  tmp_24 = idx;
  
#line 272 
  idx += 1;
  
#line 272 
  *(buff + tmp_24) = fm10k_read_reg(hw,i * 64 + 32779);
  
#line 273 
  tmp_25 = idx;
  
#line 273 
  idx += 1;
  
#line 273 
  *(buff + tmp_25) = fm10k_read_reg(hw,i * 64 + 32780);
  
#line 274 
  tmp_26 = idx;
  
#line 274 
  idx += 1;
  
#line 274 
  *(buff + tmp_26) = fm10k_read_reg(hw,i * 64 + 32781);
  
#line 275 
  tmp_27 = idx;
  
#line 275 
  idx += 1;
  
#line 275 
  *(buff + tmp_27) = fm10k_read_reg(hw,i * 64 + 32782);
  
#line 277 
  if ((long)(idx != 29) != 0L) {
    
#line 279 
    ldv_inline_asm();
    
#line 277 
    ;
  }
  else ;
  
#line 279 
  return;
}


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_reg_vsi(struct fm10k_hw *hw, u32 *buff, int i)
{
  int j;
  int tmp;
  int tmp_0;
  int tmp_1;
  
#line 285 
  int idx = 0;
  
#line 287 
  tmp = idx;
  
#line 287 
  idx += 1;
  
#line 287 
  *(buff + tmp) = fm10k_read_reg(hw,i + 8448);
  
#line 288 
  j = 0;
  
#line 288 
  goto ldv_47234;
  ldv_47233: 
#line 289 
  ;
  
#line 289 
  tmp_0 = idx;
  
#line 289 
  idx += 1;
  
#line 289 
  *(buff + tmp_0) = fm10k_read_reg(hw,(i * 16 + j) + 2048);
  
#line 288 
  j += 1;
  ldv_47234: 
#line 289 
  ;
  
#line 288 
  if (j <= 9) 
#line 290 
              goto ldv_47233; else 
#line 293 
                                   goto ldv_47235;
  ldv_47235: 
#line 294 
  ;
  
#line 290 
  j = 0;
  
#line 290 
  goto ldv_47237;
  ldv_47236: 
#line 291 
  ;
  
#line 291 
  tmp_1 = idx;
  
#line 291 
  idx += 1;
  
#line 291 
  *(buff + tmp_1) = fm10k_read_reg(hw,(i * 32 + j) + 4096);
  
#line 290 
  j += 1;
  ldv_47237: 
#line 291 
  ;
  
#line 290 
  if (j <= 31) 
#line 292 
               goto ldv_47236; else 
#line 295 
                                    goto ldv_47238;
  ldv_47238: 
#line 296 
  ;
  
#line 293 
  if ((long)(idx != 43) != 0L) {
    
#line 295 
    ldv_inline_asm();
    
#line 293 
    ;
  }
  else ;
  
#line 295 
  return;
}


#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_regs(struct net_device *netdev, struct ethtool_regs *regs, void *p)
{
  u16 i;
  
#line 299 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 300 
  struct fm10k_hw *hw = & interface->hw;
  
#line 301 
  u32 *buff = (u32 *)p;
  
#line 304 
  regs->version = (unsigned int)((((int)hw->revision_id << 16) | 16777216) | (int)hw->device_id);
  
#line 306 
  switch ((unsigned int)hw->mac.type) {
    u32 *tmp_0;
    u32 *tmp_1;
    u32 *tmp_2;
    u32 *tmp_3;
    u32 *tmp_4;
    u32 *tmp_5;
    u32 *tmp_6;
    u32 *tmp_7;
    u32 *tmp_8;
    u32 *tmp_9;
    u32 *tmp_10;
    u32 *tmp_11;
    u32 *tmp_12;
    u32 *tmp_13;
    u32 *tmp_14;
    case (unsigned int)1: 
#line 307 
    ;
    
#line 309 
    tmp_0 = buff;
    
#line 309 
    buff += 1;
    
#line 309 
    *tmp_0 = fm10k_read_reg(hw,0);
    
#line 310 
    tmp_1 = buff;
    
#line 310 
    buff += 1;
    
#line 310 
    *tmp_1 = fm10k_read_reg(hw,1);
    
#line 311 
    tmp_2 = buff;
    
#line 311 
    buff += 1;
    
#line 311 
    *tmp_2 = fm10k_read_reg(hw,3);
    
#line 312 
    tmp_3 = buff;
    
#line 312 
    buff += 1;
    
#line 312 
    *tmp_3 = fm10k_read_reg(hw,5);
    
#line 314 
    i = (unsigned short)0U;
    
#line 314 
    goto ldv_47250;
    ldv_47249: 
#line 315 
    ;
    
#line 315 
    tmp_4 = buff;
    
#line 315 
    buff += 1;
    
#line 315 
    *tmp_4 = fm10k_read_reg(hw,(int)i + 48);
    
#line 316 
    tmp_5 = buff;
    
#line 316 
    buff += 1;
    
#line 316 
    *tmp_5 = fm10k_read_reg(hw,(int)i + 56);
    
#line 314 
    i = (u16)((int)i + 1);
    ldv_47250: 
#line 315 
    ;
    
#line 314 
    if ((unsigned int)i <= 7U) 
#line 316 
                               goto ldv_47249; else 
#line 319 
                                                    goto ldv_47251;
    ldv_47251: 
#line 320 
    ;
    
#line 319 
    i = (unsigned short)0U;
    
#line 319 
    goto ldv_47253;
    ldv_47252: 
#line 320 
    ;
    
#line 320 
    fm10k_get_reg_vsi(hw,buff,(int)i);
    
#line 321 
    buff += 43U;
    
#line 319 
    i = (u16)((int)i + 1);
    ldv_47253: 
#line 320 
    ;
    
#line 319 
    if ((unsigned int)i <= 64U) 
#line 321 
                                goto ldv_47252; else 
#line 324 
                                                     goto ldv_47254;
    ldv_47254: 
#line 325 
    ;
    
#line 324 
    tmp_6 = buff;
    
#line 324 
    buff += 1;
    
#line 324 
    *tmp_6 = fm10k_read_reg(hw,8387);
    
#line 325 
    tmp_7 = buff;
    
#line 325 
    buff += 1;
    
#line 325 
    *tmp_7 = fm10k_read_reg(hw,8388);
    
#line 327 
    i = (unsigned short)0U;
    
#line 327 
    goto ldv_47256;
    ldv_47255: 
#line 328 
    ;
    
#line 328 
    fm10k_get_reg_q(hw,buff,(int)i);
    
#line 329 
    buff += 29U;
    
#line 327 
    i = (u16)((int)i + 1);
    ldv_47256: 
#line 328 
    ;
    
#line 327 
    if ((unsigned int)i <= 127U) 
#line 329 
                                 goto ldv_47255; else 
#line 332 
                                                      goto ldv_47257;
    ldv_47257: 
#line 333 
    ;
    
#line 332 
    tmp_8 = buff;
    
#line 332 
    buff += 1;
    
#line 332 
    *tmp_8 = fm10k_read_reg(hw,8391);
    
#line 334 
    i = (unsigned short)0U;
    
#line 334 
    goto ldv_47259;
    ldv_47258: 
#line 335 
    ;
    
#line 335 
    tmp_9 = buff;
    
#line 335 
    buff += 1;
    
#line 335 
    *tmp_9 = fm10k_read_reg(hw,(int)i + 65664);
    
#line 334 
    i = (u16)((int)i + 1);
    ldv_47259: 
#line 335 
    ;
    
#line 334 
    if ((unsigned int)i <= 7U) 
#line 336 
                               goto ldv_47258; else 
#line 339 
                                                    goto ldv_47260;
    ldv_47260: 
#line 340 
    ;
    
#line 338 
    i = (unsigned short)0U;
    
#line 338 
    goto ldv_47262;
    ldv_47261: 
#line 339 
    ;
    
#line 339 
    tmp_10 = buff;
    
#line 339 
    buff += 1;
    
#line 339 
    *tmp_10 = fm10k_read_reg(hw,(int)i + 74752);
    
#line 338 
    i = (u16)((int)i + 1);
    ldv_47262: 
#line 339 
    ;
    
#line 338 
    if ((unsigned int)i <= 129U) 
#line 340 
                                 goto ldv_47261; else 
#line 343 
                                                      goto ldv_47263;
    ldv_47263: 
#line 344 
    ;
    
#line 341 
    goto ldv_47264;
    case (unsigned int)2: 
#line 342 
    ;
    
#line 344 
    tmp_11 = buff;
    
#line 344 
    buff += 1;
    
#line 344 
    *tmp_11 = fm10k_read_reg(hw,0);
    
#line 345 
    tmp_12 = buff;
    
#line 345 
    buff += 1;
    
#line 345 
    *tmp_12 = fm10k_read_reg(hw,48);
    
#line 346 
    tmp_13 = buff;
    
#line 346 
    buff += 1;
    
#line 346 
    *tmp_13 = fm10k_read_reg(hw,64);
    
#line 349 
    i = (unsigned short)0U;
    
#line 349 
    goto ldv_47267;
    ldv_47266: 
#line 350 
    ;
    
#line 350 
    tmp_14 = buff;
    
#line 350 
    buff += 1;
    
#line 350 
    *tmp_14 = fm10k_read_reg(hw,(int)i + 96);
    
#line 349 
    i = (u16)((int)i + 1);
    ldv_47267: 
#line 350 
    ;
    
#line 349 
    if ((unsigned int)i <= 7U) 
#line 351 
                               goto ldv_47266; else 
#line 354 
                                                    goto ldv_47268;
    ldv_47268: 
#line 355 
    ;
    
#line 352 
    fm10k_get_reg_vsi(hw,buff,0);
    
#line 353 
    buff += 43U;
    
#line 355 
    i = (unsigned short)0U;
    
#line 355 
    goto ldv_47270;
    ldv_47269: 
#line 356 
    ;
    
#line 356 
    if ((int)hw->mac.max_queues > (int)i) 
#line 357 
                                          fm10k_get_reg_q(hw,buff,(int)i); else 
                                                                    
#line 359 
                                                                    memset((void *)buff,0,116UL);
    
#line 360 
    buff += 29U;
    
#line 355 
    i = (u16)((int)i + 1);
    ldv_47270: 
#line 356 
    ;
    
#line 355 
    if ((unsigned int)i <= 15U) 
#line 357 
                                goto ldv_47269; else 
#line 360 
                                                     goto ldv_47271;
    ldv_47271: 
#line 361 
    ;
    
#line 363 
    goto ldv_47264;
    default: 
#line 364 
    ;
    
#line 365 
    goto return_label;
  }
  ldv_47264: 
#line 367 
  ;
  return_label: 
#line 368 
                return;
}


#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_get_regs_len(struct net_device *netdev)
{
  int __retres;
  
#line 377 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 378 
  struct fm10k_hw *hw = & interface->hw;
  
#line 380 
  switch ((unsigned int)hw->mac.type) {
    case (unsigned int)1: 
#line 381 
    ;
    
#line 382 
    __retres = 26676;
    
#line 382 
    goto return_label;
    case (unsigned int)2: 
#line 383 
    ;
    
#line 384 
    __retres = 2072;
    
#line 384 
    goto return_label;
    default: 
#line 385 
    ;
    
#line 386 
    __retres = 0;
    
#line 386 
    goto return_label;
  }
  return_label: 
#line 380 
                return __retres;
}


#line 390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
  char const *tmp_0;
  int tmp_1;
  int tmp_2;
  
#line 393 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 395 
  strncpy((char *)(& info->driver),(char const *)(& fm10k_driver_name),31UL);
  
#line 397 
  strncpy((char *)(& info->version),(char const *)(& fm10k_driver_version),31UL);
  
#line 399 
  tmp_0 = pci_name((struct pci_dev const *)interface->pdev);
  
#line 399 
  ;
  
#line 399 
  strncpy((char *)(& info->bus_info),tmp_0,31UL);
  
#line 402 
  tmp_1 = fm10k_get_sset_count(dev,1);
  
#line 402 
  info->n_stats = (unsigned int)tmp_1;
  
#line 404 
  tmp_2 = fm10k_get_regs_len(dev);
  
#line 404 
  info->regdump_len = (unsigned int)tmp_2;
  
#line 405 
  return;
}


#line 407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam *pause)
{
  
#line 410 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 413 
  pause->autoneg = 0U;
  
#line 414 
  pause->tx_pause = 1U;
  
#line 416 
  pause->rx_pause = (unsigned int)((unsigned int)interface->rx_pause != 0U);
  
#line 417 
  return;
}


#line 419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *pause)
{
  int __retres;
  bool tmp_0;
  
#line 422 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 423 
  struct fm10k_hw *hw = & interface->hw;
  
#line 425 
  if (pause->autoneg != 0U || pause->tx_pause == 0U) {
    
#line 426 
    __retres = -22;
    
#line 426 
    goto return_label;
  }
  else ;
  
#line 429 
  if (hw->mac.type == (unsigned int)fm10k_mac_pf) 
    
#line 430 
    if (pause->rx_pause != 0U) 
#line 430 
                               interface->rx_pause = (unsigned char)255U; else 
                                                                    
#line 430 
                                                                    interface->rx_pause = (unsigned char)0U;
  else 
    
#line 431 
    if (pause->rx_pause != 0U) {
      
#line 432 
      __retres = -22;
      
#line 432 
      goto return_label;
    }
    else ;
  
#line 434 
  tmp_0 = netif_running((struct net_device const *)dev);
  
#line 434 
  if ((int)tmp_0 != 0) 
#line 435 
                       fm10k_update_rx_drop_en(interface); else ;
  
#line 437 
  __retres = 0;
  return_label: 
#line 437 
                return __retres;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static u32 fm10k_get_msglevel(struct net_device *netdev)
{
  u32 __retres;
  
#line 442 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 444 
  __retres = (unsigned int)interface->msg_enable;
  
#line 444 
  return __retres;
}


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_set_msglevel(struct net_device *netdev, u32 data)
{
  
#line 449 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 451 
  interface->msg_enable = (unsigned short)data;
  
#line 452 
  return;
}


#line 454  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  
#line 457 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 459 
  ring->rx_max_pending = 4096U;
  
#line 460 
  ring->tx_max_pending = 4096U;
  
#line 461 
  ring->rx_mini_max_pending = 0U;
  
#line 462 
  ring->rx_jumbo_max_pending = 0U;
  
#line 463 
  ring->rx_pending = (unsigned int)interface->rx_ring_count;
  
#line 464 
  ring->tx_pending = (unsigned int)interface->tx_ring_count;
  
#line 465 
  ring->rx_mini_pending = 0U;
  
#line 466 
  ring->rx_jumbo_pending = 0U;
  
#line 467 
  return;
}


#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_set_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  int __retres;
  struct fm10k_ring *temp_ring;
  int i;
  u32 new_rx_count;
  u32 new_tx_count;
  u32 tmp_3;
  u32 tmp_7;
  int tmp_8;
  int tmp_10;
  bool tmp_9;
  int tmp_12;
  
#line 472 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 474 
  int err = 0;
  
#line 477 
  if (ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) {
    
#line 478 
    __retres = -22;
    
#line 478 
    goto return_label;
  }
  else ;
  {
    u32 tmp_1;
    u32 tmp_2;
    {
      u32 tmp_0;
      
#line 480 
      u32 __max1 = ring->tx_pending;
      
#line 480 
      u32 __max2 = 128U;
      
#line 480 
      if (__max1 > __max2) 
#line 480 
                           tmp_0 = __max1; else 
#line 480 
                                                tmp_0 = __max2;
      
#line 480 
      tmp_1 = tmp_0;
    }
    
#line 480 
    u32 __min1 = tmp_1;
    
#line 480 
    u32 __min2 = 4096U;
    
#line 480 
    if (__min1 < __min2) 
#line 480 
                         tmp_2 = __min1; else 
#line 480 
                                              tmp_2 = __min2;
    
#line 480 
    tmp_3 = tmp_2;
  }
  
#line 480 
  new_tx_count = tmp_3;
  
#line 482 
  new_tx_count = (new_tx_count + 7U) & 4294967288U;
  {
    u32 tmp_5;
    u32 tmp_6;
    {
      u32 tmp_4;
      
#line 484 
      u32 __max1_0 = ring->rx_pending;
      
#line 484 
      u32 __max2_0 = 128U;
      
#line 484 
      if (__max1_0 > __max2_0) 
#line 484 
                               tmp_4 = __max1_0; else 
#line 484 
                                                      tmp_4 = __max2_0;
      
#line 484 
      tmp_5 = tmp_4;
    }
    
#line 484 
    u32 __min1_0 = tmp_5;
    
#line 484 
    u32 __min2_0 = 4096U;
    
#line 484 
    if (__min1_0 < __min2_0) 
#line 484 
                             tmp_6 = __min1_0; else 
#line 484 
                                                    tmp_6 = __min2_0;
    
#line 484 
    tmp_7 = tmp_6;
  }
  
#line 484 
  new_rx_count = tmp_7;
  
#line 486 
  new_rx_count = (new_rx_count + 7U) & 4294967288U;
  
#line 488 
  if ((unsigned int)interface->tx_ring_count == new_tx_count && (unsigned int)interface->rx_ring_count == new_rx_count) {
    
#line 491 
    __retres = 0;
    
#line 491 
    goto return_label;
  }
  else ;
  
#line 494 
  goto ldv_47334;
  ldv_47333: 
#line 495 
  ;
  
#line 495 
  usleep_range(1000UL,2000UL);
  ldv_47334: 
#line 496 
  ;
  
#line 494 
  tmp_8 = test_and_set_bit(0L,(unsigned long volatile *)(& interface->state));
  
#line 494 
  if (tmp_8 != 0) 
#line 496 
                  goto ldv_47333; else 
#line 499 
                                       goto ldv_47335;
  ldv_47335: 
#line 500 
  ;
  
#line 497 
  tmp_9 = netif_running((struct net_device const *)interface->netdev);
  
#line 497 
  if (tmp_9) 
#line 497 
             tmp_10 = 0; else 
#line 497 
                              tmp_10 = 1;
  
#line 497 
  if (tmp_10) {
    
#line 498 
    i = 0;
    
#line 498 
    goto ldv_47337;
    ldv_47336: 
#line 499 
    ;
    
#line 499 
    (interface->tx_ring[i])->count = (unsigned short)new_tx_count;
    
#line 498 
    i += 1;
    ldv_47337: 
#line 499 
    ;
    
#line 498 
    if (interface->num_tx_queues > i) 
#line 500 
                                      goto ldv_47336; else 
#line 503 
                                                           goto ldv_47338;
    ldv_47338: 
#line 504 
    ;
    
#line 500 
    i = 0;
    
#line 500 
    goto ldv_47340;
    ldv_47339: 
#line 501 
    ;
    
#line 501 
    (interface->rx_ring[i])->count = (unsigned short)new_rx_count;
    
#line 500 
    i += 1;
    ldv_47340: 
#line 501 
    ;
    
#line 500 
    if (interface->num_rx_queues > i) 
#line 502 
                                      goto ldv_47339; else 
#line 505 
                                                           goto ldv_47341;
    ldv_47341: 
#line 506 
    ;
    
#line 502 
    interface->tx_ring_count = (unsigned short)new_tx_count;
    
#line 503 
    interface->rx_ring_count = (unsigned short)new_rx_count;
    
#line 504 
    goto clear_reset;
  }
  else ;
  {
    int tmp_11;
    
#line 508 
    int __max1_1 = interface->num_tx_queues;
    
#line 508 
    int __max2_1 = interface->num_rx_queues;
    
#line 508 
    if (__max1_1 > __max2_1) 
#line 508 
                             tmp_11 = __max1_1; else 
#line 508 
                                                     tmp_11 = __max2_1;
    
#line 508 
    tmp_12 = tmp_11;
  }
  
#line 508 
  i = tmp_12;
  
#line 509 
  temp_ring = (struct fm10k_ring *)vmalloc((unsigned long)i * 4096UL);
  
#line 511 
  if (temp_ring == (struct fm10k_ring *)0) {
    
#line 512 
    err = -12;
    
#line 513 
    goto clear_reset;
  }
  else ;
  
#line 516 
  fm10k_down(interface);
  
#line 523 
  if ((unsigned int)interface->tx_ring_count != new_tx_count) {
    
#line 524 
    i = 0;
    
#line 524 
    goto ldv_47351;
    ldv_47350: 
#line 525 
    ;
    
#line 525 
    memcpy((void *)(temp_ring + i),(void const *)interface->tx_ring[i],4096UL);
    
#line 528 
    (temp_ring + i)->count = (unsigned short)new_tx_count;
    
#line 529 
    err = fm10k_setup_tx_resources(temp_ring + i);
    
#line 530 
    if (err != 0) {
      
#line 531 
      goto ldv_47347;
      ldv_47346: 
#line 532 
      ;
      
#line 532 
      i -= 1;
      
#line 533 
      fm10k_free_tx_resources(temp_ring + i);
      ldv_47347: 
#line 534 
      ;
      
#line 531 
      if (i != 0) 
#line 533 
                  goto ldv_47346; else 
#line 536 
                                       goto ldv_47348;
      ldv_47348: 
#line 537 
      ;
      
#line 535 
      goto err_setup;
    }
    else ;
    
#line 524 
    i += 1;
    ldv_47351: 
#line 525 
    ;
    
#line 524 
    if (interface->num_tx_queues > i) 
#line 526 
                                      goto ldv_47350; else 
#line 529 
                                                           goto ldv_47352;
    ldv_47352: 
#line 530 
    ;
    
#line 539 
    i = 0;
    
#line 539 
    goto ldv_47354;
    ldv_47353: 
#line 540 
    ;
    
#line 540 
    fm10k_free_tx_resources(interface->tx_ring[i]);
    
#line 542 
    memcpy((void *)interface->tx_ring[i],(void const *)(temp_ring + i),4096UL);
    
#line 539 
    i += 1;
    ldv_47354: 
#line 540 
    ;
    
#line 539 
    if (interface->num_tx_queues > i) 
#line 541 
                                      goto ldv_47353; else 
#line 544 
                                                           goto ldv_47355;
    ldv_47355: 
#line 545 
    ;
    
#line 546 
    interface->tx_ring_count = (unsigned short)new_tx_count;
  }
  else ;
  
#line 550 
  if ((unsigned int)interface->rx_ring_count != new_rx_count) {
    
#line 551 
    i = 0;
    
#line 551 
    goto ldv_47360;
    ldv_47359: 
#line 552 
    ;
    
#line 552 
    memcpy((void *)(temp_ring + i),(void const *)interface->rx_ring[i],4096UL);
    
#line 555 
    (temp_ring + i)->count = (unsigned short)new_rx_count;
    
#line 556 
    err = fm10k_setup_rx_resources(temp_ring + i);
    
#line 557 
    if (err != 0) {
      
#line 558 
      goto ldv_47357;
      ldv_47356: 
#line 559 
      ;
      
#line 559 
      i -= 1;
      
#line 560 
      fm10k_free_rx_resources(temp_ring + i);
      ldv_47357: 
#line 561 
      ;
      
#line 558 
      if (i != 0) 
#line 560 
                  goto ldv_47356; else 
#line 563 
                                       goto ldv_47358;
      ldv_47358: 
#line 564 
      ;
      
#line 562 
      goto err_setup;
    }
    else ;
    
#line 551 
    i += 1;
    ldv_47360: 
#line 552 
    ;
    
#line 551 
    if (interface->num_rx_queues > i) 
#line 553 
                                      goto ldv_47359; else 
#line 556 
                                                           goto ldv_47361;
    ldv_47361: 
#line 557 
    ;
    
#line 566 
    i = 0;
    
#line 566 
    goto ldv_47363;
    ldv_47362: 
#line 567 
    ;
    
#line 567 
    fm10k_free_rx_resources(interface->rx_ring[i]);
    
#line 569 
    memcpy((void *)interface->rx_ring[i],(void const *)(temp_ring + i),4096UL);
    
#line 566 
    i += 1;
    ldv_47363: 
#line 567 
    ;
    
#line 566 
    if (interface->num_rx_queues > i) 
#line 568 
                                      goto ldv_47362; else 
#line 571 
                                                           goto ldv_47364;
    ldv_47364: 
#line 572 
    ;
    
#line 573 
    interface->rx_ring_count = (unsigned short)new_rx_count;
  }
  else ;
  err_setup: 
#line 576 
  ;
  
#line 577 
  fm10k_up(interface);
  
#line 578 
  vfree((void const *)temp_ring);
  clear_reset: 
#line 579 
  ;
  
#line 580 
  clear_bit(0L,(unsigned long volatile *)(& interface->state));
  
#line 581 
  __retres = err;
  return_label: 
#line 581 
                return __retres;
}


#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_get_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)
{
  int __retres;
  
#line 587 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 589 
  ec->use_adaptive_tx_coalesce = (unsigned int)((int)interface->tx_itr < 0);
  
#line 591 
  ec->tx_coalesce_usecs = (unsigned int)interface->tx_itr & 4294934527U;
  
#line 593 
  ec->use_adaptive_rx_coalesce = (unsigned int)((int)interface->rx_itr < 0);
  
#line 595 
  ec->rx_coalesce_usecs = (unsigned int)interface->rx_itr & 4294934527U;
  
#line 597 
  __retres = 0;
  
#line 597 
  return __retres;
}


#line 600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_set_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)
{
  int __retres;
  struct fm10k_q_vector *qv;
  u16 tx_itr;
  u16 rx_itr;
  int i;
  
#line 603 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 609 
  if (ec->rx_coalesce_usecs > 4095U || ec->tx_coalesce_usecs > 4095U) {
    
#line 611 
    __retres = -22;
    
#line 611 
    goto return_label;
  }
  else ;
  
#line 614 
  tx_itr = (unsigned short)ec->tx_coalesce_usecs;
  
#line 615 
  rx_itr = (unsigned short)ec->rx_coalesce_usecs;
  
#line 618 
  if (ec->use_adaptive_tx_coalesce != 0U) 
#line 619 
                                          tx_itr = (unsigned short)32868U; else ;
  
#line 621 
  if (ec->use_adaptive_rx_coalesce != 0U) 
#line 622 
                                          rx_itr = (unsigned short)32818U; else ;
  
#line 625 
  interface->tx_itr = tx_itr;
  
#line 626 
  interface->rx_itr = rx_itr;
  
#line 629 
  i = 0;
  
#line 629 
  goto ldv_47380;
  ldv_47379: 
#line 630 
  ;
  
#line 630 
  qv = interface->q_vector[i];
  
#line 631 
  qv->tx.itr = tx_itr;
  
#line 632 
  qv->rx.itr = rx_itr;
  
#line 629 
  i += 1;
  ldv_47380: 
#line 630 
  ;
  
#line 629 
  if (interface->num_q_vectors > i) 
#line 631 
                                    goto ldv_47379; else 
#line 634 
                                                         goto ldv_47381;
  ldv_47381: 
#line 635 
  ;
  
#line 635 
  __retres = 0;
  return_label: 
#line 635 
                return __retres;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_get_rss_hash_opts(struct fm10k_intfc *interface, struct ethtool_rxnfc *cmd)
{
  int __retres;
  
#line 641 
  cmd->data = 0ULL;
  
#line 644 
  switch (cmd->flow_type) {
    case (__u32)1: 
#line 645 
    ;
    case (__u32)5: 
#line 646 
    ;
    
#line 647 
    cmd->data |= 192ULL;
    case (__u32)2: 
#line 649 
    ;
    
#line 650 
    if ((interface->flags & 2U) != 0U) 
#line 651 
                                       cmd->data |= 192ULL; else ;
    case (__u32)3: 
#line 653 
    ;
    case (__u32)7: 
#line 654 
    ;
    case (__u32)4: 
#line 655 
    ;
    case (__u32)8: 
#line 656 
    ;
    case (__u32)9: 
#line 657 
    ;
    case (__u32)11: 
#line 658 
    ;
    case (__u32)10: 
#line 659 
    ;
    case (__u32)12: 
#line 660 
    ;
    case (__u32)16: 
#line 661 
    ;
    case (__u32)17: 
#line 662 
    ;
    
#line 663 
    cmd->data |= 48ULL;
    
#line 664 
    goto ldv_47399;
    case (__u32)6: 
#line 665 
    ;
    
#line 666 
    if ((interface->flags & 4U) != 0U) 
#line 667 
                                       cmd->data |= 192ULL; else ;
    
#line 668 
    cmd->data |= 48ULL;
    
#line 669 
    goto ldv_47399;
    default: 
#line 670 
    ;
    
#line 671 
    __retres = -22;
    
#line 671 
    goto return_label;
  }
  ldv_47399: 
#line 674 
  ;
  
#line 674 
  __retres = 0;
  return_label: 
#line 674 
                return __retres;
}


#line 677  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd, u32 *rule_locs)
{
  
#line 680 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 681 
  int ret = -95;
  
#line 683 
  switch (cmd->cmd) {
    case (__u32)45: 
#line 684 
    ;
    
#line 685 
    cmd->data = (unsigned long long)interface->num_rx_queues;
    
#line 686 
    ret = 0;
    
#line 687 
    goto ldv_47410;
    case (__u32)41: 
#line 688 
    ;
    
#line 689 
    ret = fm10k_get_rss_hash_opts(interface,cmd);
    
#line 690 
    goto ldv_47410;
    default: 
#line 691 
    ;
    
#line 692 
    goto ldv_47410;
  }
  ldv_47410: 
#line 695 
  ;
  
#line 695 
  return ret;
}


#line 700  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_set_rss_hash_opt(struct fm10k_intfc *interface, struct ethtool_rxnfc *nfc)
{
  int __retres;
  
#line 703 
  u32 flags = interface->flags;
  
#line 708 
  if ((nfc->data & 18446744073709551375ULL) != 0ULL) {
    
#line 710 
    __retres = -22;
    
#line 710 
    goto return_label;
  }
  else ;
  
#line 712 
  switch (nfc->flow_type) {
    case (__u32)1: 
#line 713 
    ;
    case (__u32)5: 
#line 714 
    ;
    
#line 715 
    if ((((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) || (nfc->data & 64ULL) == 0ULL) || (nfc->data & 128ULL) == 0ULL) {
      
#line 719 
      __retres = -22;
      
#line 719 
      goto return_label;
    }
    else ;
    
#line 720 
    goto ldv_47420;
    case (__u32)2: 
#line 721 
    ;
    
#line 722 
    if ((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) {
      
#line 724 
      __retres = -22;
      
#line 724 
      goto return_label;
    }
    else ;
    
#line 725 
    switch (nfc->data & 192ULL) {
      case (unsigned long long)0: 
#line 726 
      ;
      
#line 727 
      flags &= 4294967293U;
      
#line 728 
      goto ldv_47423;
      case (unsigned long long)192: 
#line 729 
      ;
      
#line 730 
      flags |= 2U;
      
#line 731 
      goto ldv_47423;
      default: 
#line 732 
      ;
      
#line 733 
      __retres = -22;
      
#line 733 
      goto return_label;
    }
    ldv_47423: 
#line 735 
    ;
    
#line 735 
    goto ldv_47420;
    case (__u32)6: 
#line 736 
    ;
    
#line 737 
    if ((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) {
      
#line 739 
      __retres = -22;
      
#line 739 
      goto return_label;
    }
    else ;
    
#line 740 
    switch (nfc->data & 192ULL) {
      case (unsigned long long)0: 
#line 741 
      ;
      
#line 742 
      flags &= 4294967291U;
      
#line 743 
      goto ldv_47428;
      case (unsigned long long)192: 
#line 744 
      ;
      
#line 745 
      flags |= 4U;
      
#line 746 
      goto ldv_47428;
      default: 
#line 747 
      ;
      
#line 748 
      __retres = -22;
      
#line 748 
      goto return_label;
    }
    ldv_47428: 
#line 750 
    ;
    
#line 750 
    goto ldv_47420;
    case (__u32)4: 
#line 751 
    ;
    case (__u32)9: 
#line 752 
    ;
    case (__u32)10: 
#line 753 
    ;
    case (__u32)3: 
#line 754 
    ;
    case (__u32)8: 
#line 755 
    ;
    case (__u32)11: 
#line 756 
    ;
    case (__u32)12: 
#line 757 
    ;
    case (__u32)7: 
#line 758 
    ;
    
#line 759 
    if ((((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) || (nfc->data & 64ULL) != 0ULL) || (nfc->data & 128ULL) != 0ULL) {
      
#line 763 
      __retres = -22;
      
#line 763 
      goto return_label;
    }
    else ;
    
#line 764 
    goto ldv_47420;
    default: 
#line 765 
    ;
    
#line 766 
    __retres = -22;
    
#line 766 
    goto return_label;
  }
  ldv_47420: 
#line 770 
  ;
  
#line 770 
  if (interface->flags != flags) {
    u32 mrqc;
    
#line 771 
    struct fm10k_hw *hw = & interface->hw;
    
#line 774 
    if ((flags & 6U) != 0U && (interface->flags & 6U) == 0U) {
      
#line 776 
      if (((int)interface->msg_enable & 1) != 0) 
#line 776 
                                                 netdev_warn((struct net_device const *)interface->netdev,"enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n"); else ;
    }
    else ;
    
#line 779 
    interface->flags = flags;
    
#line 782 
    mrqc = 51U;
    
#line 787 
    if ((flags & 2U) != 0U) 
#line 788 
                            mrqc |= 64U; else ;
    
#line 789 
    if ((flags & 4U) != 0U) 
#line 790 
                            mrqc |= 128U; else ;
    {
      u32 * volatile *tmp;
      {
        
#line 792 
        u32 *__var = (u32 *)0U;
        
#line 792 
        tmp = (u32 * volatile *)(& hw->hw_addr);
      }
      
#line 792 
      u32 *hw_addr = *tmp;
      
#line 792 
      if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 792 
                                              writel(mrqc,(void volatile *)(hw_addr + 8448U)); else ;
    }
  }
  else ;
  
#line 795 
  __retres = 0;
  return_label: 
#line 795 
                return __retres;
}


#line 798  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
{
  
#line 800 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 801 
  int ret = -95;
  
#line 803 
  switch (cmd->cmd) {
    case (__u32)42: 
#line 804 
    ;
    
#line 805 
    ret = fm10k_set_rss_hash_opt(interface,cmd);
    
#line 806 
    goto ldv_47452;
    default: 
#line 807 
    ;
    
#line 808 
    goto ldv_47452;
  }
  ldv_47452: 
#line 811 
  ;
  
#line 811 
  return ret;
}


#line 814  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_mbx_test(struct fm10k_intfc *interface, u64 *data)
{
  int __retres;
  u32 attr_flag;
  u32 test_msg[6U];
  unsigned long timeout;
  int err;
  int tmp;
  unsigned int tmp_1;
  
#line 816 
  struct fm10k_hw *hw = & interface->hw;
  
#line 817 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 823 
  if (hw->mac.type != (unsigned int)fm10k_mac_vf) {
    
#line 824 
    __retres = 0;
    
#line 824 
    goto return_label;
  }
  else ;
  
#line 827 
  attr_flag = 1U;
  
#line 827 
  goto ldv_47474;
  ldv_47473: 
#line 828 
  ;
  
#line 831 
  fm10k_tlv_msg_test_create((u32 *)(& test_msg),attr_flag);
  
#line 833 
  fm10k_mbx_lock_1(interface);
  
#line 834 
  mbx->test_result = 2147483647;
  
#line 835 
  err = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& test_msg));
  
#line 836 
  fm10k_mbx_unlock(interface);
  
#line 839 
  timeout = jiffies + 250UL;
  ldv_47472: 
#line 840 
  ;
  
#line 841 
  if (err < 0) 
#line 842 
               goto err_out; else ;
  
#line 844 
  usleep_range(500UL,1000UL);
  
#line 846 
  fm10k_mbx_lock_1(interface);
  
#line 847 
  (*(mbx->ops.process))(hw,mbx);
  
#line 848 
  fm10k_mbx_unlock(interface);
  
#line 850 
  err = mbx->test_result;
  
#line 851 
  if (err == 0) 
#line 852 
                goto ldv_47465; else ;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
#line 853 
    tmp = 1;
  }
  
#line 853 
  if (tmp != 0) {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long volatile __dummy2_0;
      
#line 853 
      tmp_0 = 1;
    }
    
#line 853 
    if (tmp_0 != 0) {
      
#line 853 
      if ((long)(jiffies - timeout) < 0L) 
#line 855 
                                          goto ldv_47472; else 
#line 858 
                                                               goto ldv_47465;
    }
    else 
#line 858 
         goto ldv_47465;
  }
  else 
#line 858 
       goto ldv_47465;
  ldv_47465: 
#line 859 
  ;
  
#line 856 
  if (err != 0) 
#line 857 
                goto err_out; else ;
  
#line 829 
  attr_flag *= 2U;
  ldv_47474: 
#line 830 
  ;
  
#line 827 
  if (attr_flag <= 16777215U) 
#line 830 
                              goto ldv_47473; else 
#line 833 
                                                   goto ldv_47475;
  ldv_47475: 
#line 834 
  ;
  err_out: 
#line 860 
  ;
  
#line 861 
  if (err >= 0) 
#line 861 
                tmp_1 = (unsigned int)(err > 0); else 
#line 861 
                                                      tmp_1 = attr_flag;
  
#line 861 
  *data = (unsigned long long)tmp_1;
  
#line 862 
  __retres = err;
  return_label: 
#line 862 
                return __retres;
}


#line 865  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_self_test(struct net_device *dev, struct ethtool_test *eth_test, u64 *data)
{
  int tmp_0;
  
#line 868 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 869 
  struct fm10k_hw *hw = & interface->hw;
  
#line 871 
  memset((void *)data,0,8UL);
  
#line 873 
  if ((long)(hw == (struct fm10k_hw *)0) != 0L) {
    
#line 874 
    if (((int)interface->msg_enable & 1) != 0) 
#line 874 
                                               netdev_err((struct net_device const *)dev,"Interface removed - test blocked\n"); else ;
    
#line 876 
    eth_test->flags |= 2U;
    
#line 877 
    goto return_label;
  }
  else ;
  
#line 880 
  tmp_0 = fm10k_mbx_test(interface,data);
  
#line 880 
  if (tmp_0 != 0) 
#line 881 
                  eth_test->flags |= 2U; else ;
  return_label: 
#line 882 
                return;
}


#line 884  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static u32 fm10k_get_reta_size(struct net_device *netdev)
{
  u32 __retres;
  
#line 886 
  __retres = 128U;
  
#line 886 
  return __retres;
}


#line 889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_get_reta(struct net_device *netdev, u32 *indir)
{
  int __retres;
  int i;
  
#line 891 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 894 
  if (indir == (u32 *)0U) {
    
#line 895 
    __retres = 0;
    
#line 895 
    goto return_label;
  }
  else ;
  
#line 897 
  i = 0;
  
#line 897 
  goto ldv_47494;
  ldv_47493: 
#line 898 
  ;
  {
    
#line 898 
    u32 reta = interface->reta[i];
    
#line 900 
    *indir = reta & 255U;
    
#line 901 
    *(indir + 1U) = (reta << 16) >> 24;
    
#line 902 
    *(indir + 2U) = (reta << 8) >> 24;
    
#line 903 
    *(indir + 3U) = reta >> 24;
  }
  
#line 897 
  i += 1;
  
#line 897 
  indir += 4U;
  ldv_47494: 
#line 898 
  ;
  
#line 897 
  if (i <= 31) 
#line 899 
               goto ldv_47493; else 
#line 902 
                                    goto ldv_47495;
  ldv_47495: 
#line 903 
  ;
  
#line 906 
  __retres = 0;
  return_label: 
#line 906 
                return __retres;
}


#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_set_reta(struct net_device *netdev, u32 const *indir)
{
  int __retres;
  int i;
  u16 rss_i;
  u32 tmp_0;
  int tmp_1;
  
#line 911 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 912 
  struct fm10k_hw *hw = & interface->hw;
  
#line 916 
  if (indir == (u32 const *)0U) {
    
#line 917 
    __retres = 0;
    
#line 917 
    goto return_label;
  }
  else ;
  
#line 920 
  rss_i = interface->ring_feature[0].indices;
  
#line 921 
  tmp_0 = fm10k_get_reta_size(netdev);
  
#line 921 
  i = (int)tmp_0;
  
#line 921 
  goto ldv_47504;
  ldv_47505: 
#line 922 
  ;
  
#line 922 
  if (*(indir + i) < (unsigned int)rss_i) 
#line 923 
                                          goto ldv_47504; else ;
  
#line 924 
  __retres = -22;
  
#line 924 
  goto return_label;
  ldv_47504: 
#line 925 
  ;
  
#line 921 
  tmp_1 = i;
  
#line 921 
  i -= 1;
  
#line 921 
  ;
  
#line 921 
  if (tmp_1 != 0) 
#line 923 
                  goto ldv_47505; else 
#line 926 
                                       goto ldv_47506;
  ldv_47506: 
#line 927 
  ;
  
#line 928 
  i = 0;
  
#line 928 
  goto ldv_47513;
  ldv_47512: 
#line 929 
  ;
  {
    
#line 929 
    u32 reta = ((*indir | (*(indir + 1U) << 8)) | (*(indir + 2U) << 16)) | (*(indir + 3U) << 24);
    
#line 934 
    if (interface->reta[i] == reta) 
#line 935 
                                    goto ldv_47508; else ;
    
#line 937 
    interface->reta[i] = reta;
    {
      u32 * volatile *tmp_2;
      {
        
#line 938 
        u32 *__var = (u32 *)0U;
        
#line 938 
        tmp_2 = (u32 * volatile *)(& hw->hw_addr);
      }
      
#line 938 
      u32 *hw_addr = *tmp_2;
      
#line 938 
      if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 938 
                                              writel(reta,(void volatile *)(hw_addr + ((unsigned int)i + 4096U))); else ;
    }
  }
  ldv_47508: 
#line 941 
  ;
  
#line 928 
  i += 1;
  
#line 928 
  indir += 4U;
  ldv_47513: 
#line 929 
  ;
  
#line 928 
  if (i <= 31) 
#line 930 
               goto ldv_47512; else 
#line 933 
                                    goto ldv_47514;
  ldv_47514: 
#line 934 
  ;
  
#line 941 
  __retres = 0;
  return_label: 
#line 941 
                return __retres;
}


#line 944  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static u32 fm10k_get_rssrk_size(struct net_device *netdev)
{
  u32 __retres;
  
#line 946 
  __retres = 40U;
  
#line 946 
  return __retres;
}


#line 949  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_get_rssh(struct net_device *netdev, u32 *indir, u8 *key, u8 *hfunc)
{
  int __retres;
  int i;
  int err;
  
#line 952 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 955 
  if (hfunc != (u8 *)0U) 
#line 956 
                         *hfunc = (unsigned char)1U; else ;
  
#line 958 
  err = fm10k_get_reta(netdev,indir);
  
#line 959 
  if (err != 0 || key == (u8 *)0U) {
    
#line 960 
    __retres = err;
    
#line 960 
    goto return_label;
  }
  else ;
  
#line 962 
  i = 0;
  
#line 962 
  goto ldv_47528;
  ldv_47527: 
#line 963 
  ;
  
#line 963 
  *((__le32 *)key) = interface->rssrk[i];
  
#line 962 
  i += 1;
  
#line 962 
  key += 4U;
  ldv_47528: 
#line 963 
  ;
  
#line 962 
  if (i <= 9) 
#line 964 
              goto ldv_47527; else 
#line 967 
                                   goto ldv_47529;
  ldv_47529: 
#line 968 
  ;
  
#line 965 
  __retres = 0;
  return_label: 
#line 965 
                return __retres;
}


#line 968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_set_rssh(struct net_device *netdev, u32 const *indir, u8 const *key, u8 const hfunc)
{
  int __retres;
  int i;
  int err;
  
#line 971 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 972 
  struct fm10k_hw *hw = & interface->hw;
  
#line 976 
  if ((unsigned int)hfunc > 1U) {
    
#line 977 
    __retres = -95;
    
#line 977 
    goto return_label;
  }
  else ;
  
#line 979 
  err = fm10k_set_reta(netdev,indir);
  
#line 980 
  if (err != 0 || key == (u8 const *)0U) {
    
#line 981 
    __retres = err;
    
#line 981 
    goto return_label;
  }
  else ;
  
#line 983 
  i = 0;
  
#line 983 
  goto ldv_47546;
  ldv_47545: 
#line 984 
  ;
  {
    
#line 984 
    u32 rssrk = *((__le32 *)key);
    
#line 986 
    if (interface->rssrk[i] == rssrk) 
#line 987 
                                      goto ldv_47541; else ;
    
#line 989 
    interface->rssrk[i] = rssrk;
    {
      u32 * volatile *tmp_0;
      {
        
#line 990 
        u32 *__var = (u32 *)0U;
        
#line 990 
        tmp_0 = (u32 * volatile *)(& hw->hw_addr);
      }
      
#line 990 
      u32 *hw_addr = *tmp_0;
      
#line 990 
      if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 990 
                                              writel(rssrk,(void volatile *)(hw_addr + ((unsigned int)i + 2048U))); else ;
    }
  }
  ldv_47541: 
#line 993 
  ;
  
#line 983 
  i += 1;
  
#line 983 
  key += 4U;
  ldv_47546: 
#line 984 
  ;
  
#line 983 
  if (i <= 9) 
#line 985 
              goto ldv_47545; else 
#line 988 
                                   goto ldv_47547;
  ldv_47547: 
#line 989 
  ;
  
#line 993 
  __retres = 0;
  return_label: 
#line 993 
                return __retres;
}


#line 996  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static unsigned int fm10k_max_channels(struct net_device *dev)
{
  int tmp_0;
  
#line 998 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 999 
  unsigned int max_combined = (unsigned int)interface->hw.mac.max_queues;
  
#line 1000 
  tmp_0 = netdev_get_num_tc(dev);
  
#line 1000 
  u8 tcs = (unsigned char)tmp_0;
  
#line 1003 
  if ((unsigned int)tcs > 1U) {
    int tmp_1;
    
#line 1004 
    tmp_1 = fls((int)(max_combined / (unsigned int)tcs));
    
#line 1004 
    max_combined = (unsigned int)(1 << (tmp_1 + -1));
  }
  else ;
  
#line 1006 
  return max_combined;
}


#line 1009  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static void fm10k_get_channels(struct net_device *dev, struct ethtool_channels *ch)
{
  
#line 1012 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 1013 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1016 
  ch->max_combined = fm10k_max_channels(dev);
  
#line 1019 
  ch->max_other = 1U;
  
#line 1020 
  ch->other_count = ch->max_other;
  
#line 1023 
  ch->combined_count = (unsigned int)interface->ring_feature[0].indices;
  
#line 1024 
  return;
}


#line 1026  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_set_channels(struct net_device *dev, struct ethtool_channels *ch)
{
  int __retres;
  unsigned int tmp_0;
  int tmp_2;
  int tmp_1;
  
#line 1029 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 1030 
  unsigned int count = ch->combined_count;
  
#line 1031 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1034 
  if ((count == 0U || ch->rx_count != 0U) || ch->tx_count != 0U) {
    
#line 1035 
    __retres = -22;
    
#line 1035 
    goto return_label;
  }
  else ;
  
#line 1038 
  if (ch->other_count != 1U) {
    
#line 1039 
    __retres = -22;
    
#line 1039 
    goto return_label;
  }
  else ;
  
#line 1042 
  tmp_0 = fm10k_max_channels(dev);
  
#line 1042 
  ;
  
#line 1042 
  if (tmp_0 < count) {
    
#line 1043 
    __retres = -22;
    
#line 1043 
    goto return_label;
  }
  else ;
  
#line 1045 
  interface->ring_feature[0].limit = (unsigned short)count;
  
#line 1048 
  tmp_1 = netdev_get_num_tc(dev);
  
#line 1048 
  ;
  
#line 1048 
  tmp_2 = fm10k_setup_tc(dev,(unsigned char)((int)((unsigned char)tmp_1)));
  
#line 1048 
  __retres = tmp_2;
  return_label: 
#line 1048 
                return __retres;
}


#line 1051  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static int fm10k_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
{
  int __retres;
  
#line 1054 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 1056 
  info->so_timestamping = 95U;
  
#line 1064 
  if (interface->ptp_clock != (struct ptp_clock *)0) 
#line 1065 
                                                     info->phc_index = ptp_clock_index(interface->ptp_clock); else 
                                                                    
#line 1067 
                                                                    info->phc_index = -1;
  
#line 1069 
  info->tx_types = 3U;
  
#line 1072 
  info->rx_filters = 3U;
  
#line 1075 
  __retres = 0;
  
#line 1075 
  return __retres;
}


#line 1078  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
static struct ethtool_ops const fm10k_ethtool_ops = {.get_settings = (int (*)(struct net_device *, struct ethtool_cmd *))0, .set_settings = (int (*)(struct net_device *, struct ethtool_cmd *))0, .get_drvinfo = & fm10k_get_drvinfo, .get_regs_len = & fm10k_get_regs_len, .get_regs = & fm10k_get_regs, .get_wol = (void (*)(struct net_device *, struct ethtool_wolinfo *))0, .set_wol = (int (*)(struct net_device *, struct ethtool_wolinfo *))0, .get_msglevel = & fm10k_get_msglevel, .set_msglevel = & fm10k_set_msglevel, .nway_reset = (int (*)(struct net_device *))0, .get_link = & ethtool_op_get_link, .get_eeprom_len = (int (*)(struct net_device *))0, .get_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .set_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_coalesce = & fm10k_get_coalesce, .set_coalesce = & fm10k_set_coalesce, .get_ringparam = & fm10k_get_ringparam, .set_ringparam = & fm10k_set_ringparam, .get_pauseparam = & fm10k_get_pauseparam, .set_pauseparam = & fm10k_set_pauseparam, .self_test = & fm10k_self_test, .get_strings = & fm10k_get_strings, .set_phys_id = (int (*)(struct net_device *, enum ethtool_phys_id_state ))0, .get_ethtool_stats = & fm10k_get_ethtool_stats, .begin = (int (*)(struct net_device *))0, .complete = (void (*)(struct net_device *))0, .get_priv_flags = (u32 (*)(struct net_device *))0, .set_priv_flags = (int (*)(struct net_device *, u32 ))0, .get_sset_count = & fm10k_get_sset_count, .get_rxnfc = & fm10k_get_rxnfc, .set_rxnfc = & fm10k_set_rxnfc, .flash_device = (int (*)(struct net_device *, struct ethtool_flash *))0, .reset = (int (*)(struct net_device *, u32 *))0, .get_rxfh_key_size = & fm10k_get_rssrk_size, .get_rxfh_indir_size = & fm10k_get_reta_size, .get_rxfh = & fm10k_get_rssh, .set_rxfh = & fm10k_set_rssh, .get_channels = & fm10k_get_channels, .set_channels = & fm10k_set_channels, .get_dump_flag = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_dump_data = (int (*)(struct net_device *, struct ethtool_dump *, void *))0, .set_dump = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_ts_info = & fm10k_get_ts_info, .get_module_info = (int (*)(struct net_device *, struct ethtool_modinfo *))0, .get_module_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .set_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .get_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void *))0, .set_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void const *))0};

#line 1106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c"
void fm10k_set_ethtool_ops(struct net_device *dev)
{
  
#line 1108 
  dev->ethtool_ops = & fm10k_ethtool_ops;
  
#line 1109 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
unsigned int (*ldv_emg_alias_ethtool_op_get_link_22)(struct net_device *) = & ethtool_op_get_link;

#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_get_rxnfc_16(struct net_device *arg0, struct ethtool_rxnfc *arg1, unsigned int *arg2)
{
  int tmp;
  
#line 75 
  tmp = fm10k_get_rxnfc(arg0,arg1,arg2);
  
#line 75 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
unsigned int ldv_emg_wrapper_fm10k_get_rssrk_size_9(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 80 
  tmp = fm10k_get_rssrk_size(arg0);
  
#line 80 
  return tmp;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_get_rssh_18(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char *arg3)
{
  int tmp;
  
#line 85 
  tmp = fm10k_get_rssh(arg0,arg1,arg2,arg3);
  
#line 85 
  return tmp;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_get_regs_len_38(struct net_device *arg0)
{
  int tmp;
  
#line 90 
  tmp = fm10k_get_regs_len(arg0);
  
#line 90 
  return tmp;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_get_channels_25(struct net_device *arg0, struct ethtool_channels *arg1)
{
  
#line 95 
  fm10k_get_channels(arg0,arg1);
  
#line 96 
  return;
}


#line 99  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_set_ringparam_8(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  int tmp;
  
#line 100 
  tmp = fm10k_set_ringparam(arg0,arg1);
  
#line 100 
  return tmp;
}


#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_get_strings_37(struct net_device *arg0, unsigned int arg1, unsigned char *arg2)
{
  
#line 105 
  fm10k_get_strings(arg0,arg1,arg2);
  
#line 106 
  return;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
unsigned int ldv_emg_wrapper_fm10k_get_msglevel_10(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 110 
  tmp = fm10k_get_msglevel(arg0);
  
#line 110 
  return tmp;
}


#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_set_rssh_28(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char arg3)
{
  int tmp;
  
#line 115 
  tmp = fm10k_set_rssh(arg0,(u32 const *)arg1,(u8 const *)arg2,(unsigned char)((int)arg3));
  
#line 115 
  return tmp;
}


#line 119  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
unsigned int ldv_emg_wrapper_fm10k_get_reta_size_23(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 120 
  tmp = fm10k_get_reta_size(arg0);
  
#line 120 
  return tmp;
}


#line 124  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_get_ethtool_stats_3(struct net_device *arg0, struct ethtool_stats *arg1, unsigned long long *arg2)
{
  
#line 125 
  fm10k_get_ethtool_stats(arg0,arg1,arg2);
  
#line 126 
  return;
}


#line 129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_get_drvinfo_6(struct net_device *arg0, struct ethtool_drvinfo *arg1)
{
  
#line 130 
  fm10k_get_drvinfo(arg0,arg1);
  
#line 131 
  return;
}


#line 134  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_get_ts_info_24(struct net_device *arg0, struct ethtool_ts_info *arg1)
{
  int tmp;
  
#line 135 
  tmp = fm10k_get_ts_info(arg0,arg1);
  
#line 135 
  return tmp;
}


#line 139  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_get_coalesce_31(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 140 
  tmp = fm10k_get_coalesce(arg0,arg1);
  
#line 140 
  return tmp;
}


#line 144  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_get_ringparam_17(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  
#line 145 
  fm10k_get_ringparam(arg0,arg1);
  
#line 146 
  return;
}


#line 149  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_get_sset_count_35(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 150 
  tmp = fm10k_get_sset_count(arg0,arg1);
  
#line 150 
  return tmp;
}


#line 154  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_get_regs_34(struct net_device *arg0, struct ethtool_regs *arg1, void *arg2)
{
  
#line 155 
  fm10k_get_regs(arg0,arg1,arg2);
  
#line 156 
  return;
}


#line 159  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_get_pauseparam_21(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  
#line 160 
  fm10k_get_pauseparam(arg0,arg1);
  
#line 161 
  return;
}


#line 164  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_set_msglevel_40(struct net_device *arg0, unsigned int arg1)
{
  
#line 165 
  fm10k_set_msglevel(arg0,arg1);
  
#line 166 
  return;
}


#line 169  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_set_rxnfc_5(struct net_device *arg0, struct ethtool_rxnfc *arg1)
{
  int tmp;
  
#line 170 
  tmp = fm10k_set_rxnfc(arg0,arg1);
  
#line 170 
  return tmp;
}


#line 174  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_set_pauseparam_29(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  int tmp;
  
#line 175 
  tmp = fm10k_set_pauseparam(arg0,arg1);
  
#line 175 
  return tmp;
}


#line 179  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_set_coalesce_39(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 180 
  tmp = fm10k_set_coalesce(arg0,arg1);
  
#line 180 
  return tmp;
}


#line 184  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
int ldv_emg_wrapper_fm10k_set_channels_27(struct net_device *arg0, struct ethtool_channels *arg1)
{
  int tmp;
  
#line 185 
  tmp = fm10k_set_channels(arg0,arg1);
  
#line 185 
  return tmp;
}


#line 189  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ethtool.c.aux"
void ldv_emg_wrapper_fm10k_self_test_14(struct net_device *arg0, struct ethtool_test *arg1, unsigned long long *arg2)
{
  
#line 190 
  fm10k_self_test(arg0,arg1,arg2);
  
#line 191 
  return;
}

unsigned short __builtin_bswap16(unsigned short);


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bitops/find.h"
unsigned long find_next_bit(unsigned long const *, unsigned long, unsigned long);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val)
{
  __u16 tmp;
  
#line 49 
  tmp = __builtin_bswap16((unsigned short)((int)val));
  
#line 49 
  return tmp;
}


#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_sleep(char const *, int, int);


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
void __list_add(struct list_head *, struct list_head *, struct list_head *);


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new, struct list_head *head)
{
  
#line 77 
  __list_add(new,head->prev,head);
  
#line 78 
  return;
}


#line 113 
void list_del(struct list_head *);


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_empty(struct list_head const *head)
{
  int __retres;
  
#line 189 
  __retres = (struct list_head const *)head->next == head;
  
#line 189 
  return __retres;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memmove(void *, void const *, size_t);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static void *ERR_PTR(long error);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const *v)
{
  int __retres;
  int const volatile *tmp;
  {
    
#line 27 
    int const __var = 0;
    
#line 27 
    tmp = (int const volatile *)(& v->counter);
  }
  
#line 27 
  __retres = *tmp;
  
#line 27 
  return __retres;
}


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
void *ldv_err_ptr(long error);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
void __free_pages(struct page *, unsigned int);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc(size_t size, gfp_t flags);


#line 581 
static void *kzalloc_0(size_t size, gfp_t flags);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 94 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 96 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 96 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 98 
    ldv_inline_asm();
    
#line 96 
    ;
  }
  else ;
  
#line 97 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 98 
    (*(ops->unmap_page))(dev,addr,size,dir,(struct dma_attrs *)0); else ;
  
#line 99 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)0);
  
#line 100 
  return;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, struct dma_attrs *);


#line 136 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, struct dma_attrs *);


#line 772  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
void kfree_skb(struct sk_buff *);


#line 775 
void consume_skb(struct sk_buff *);


#line 842 
struct sk_buff *skb_clone(struct sk_buff *, gfp_t);


#line 852 
int pskb_expand_head(struct sk_buff *, int, int, gfp_t);


#line 862 
int skb_pad(struct sk_buff *, int);


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 978 
  __retres = skb->head + skb->end;
  
#line 978 
  return __retres;
}


#line 1127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff const *skb)
{
  int __retres;
  int dataref;
  unsigned char *tmp;
  
#line 1131 
  if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) {
    
#line 1132 
    __retres = 0;
    
#line 1132 
    goto return_label;
  }
  else ;
  
#line 1134 
  tmp = skb_end_pointer(skb);
  
#line 1134 
  dataref = atomic_read((atomic_t const *)(& ((struct skb_shared_info *)tmp)->dataref));
  
#line 1135 
  dataref = (dataref & 65535) - (dataref >> 16);
  
#line 1136 
  __retres = dataref != 1;
  return_label: 
#line 1136 
                return __retres;
}


#line 1176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_shared(struct sk_buff const *skb)
{
  int __retres;
  int tmp;
  
#line 1178 
  tmp = atomic_read(& skb->users);
  
#line 1178 
  __retres = tmp != 1;
  
#line 1178 
  return __retres;
}


#line 1194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *skb_share_check(struct sk_buff *skb, gfp_t pri)
{
  int tmp_0;
  
#line 1196 
  if ((pri & 16U) != 0U) 
#line 1196 
                         __might_sleep("include/linux/skbuff.h",1196,0); else ;
  
#line 1197 
  tmp_0 = skb_shared((struct sk_buff const *)skb);
  
#line 1197 
  if (tmp_0 != 0) {
    
#line 1198 
    struct sk_buff *nskb = skb_clone(skb,pri);
    
#line 1200 
    if ((long)(nskb != (struct sk_buff *)0) != 0L) 
#line 1201 
                                                   consume_skb(skb); else 
                                                                    
#line 1203 
                                                                    kfree_skb(skb);
    
#line 1204 
    skb = nskb;
  }
  else ;
  
#line 1206 
  return skb;
}


#line 1567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff const *skb)
{
  bool __retres;
  
#line 1569 
  __retres = (_Bool)(skb->data_len != 0U);
  
#line 1569 
  return __retres;
}


#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1574 
  __retres = skb->len - skb->data_len;
  
#line 1574 
  return __retres;
}


#line 1650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1652 
  __retres = skb->head + skb->tail;
  
#line 1652 
  return __retres;
}


#line 1689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
  bool tmp_1;
  
#line 1691 
  unsigned char *tmp = skb_tail_pointer((struct sk_buff const *)skb);
  
#line 1692 
  tmp_1 = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 1692 
  if ((long)((int)tmp_1 != 0) != 0L) {
    
#line 1694 
    ldv_inline_asm();
    
#line 1692 
    ;
  }
  else ;
  
#line 1693 
  skb->tail += len;
  
#line 1694 
  skb->len += len;
  
#line 1695 
  return tmp;
}


#line 1707  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
{
  unsigned char *__retres;
  
#line 1709 
  skb->len -= len;
  
#line 1710 
  if ((long)(skb->len < skb->data_len) != 0L) {
    
#line 1712 
    ldv_inline_asm();
    
#line 1710 
    ;
  }
  else ;
  
#line 1711 
  skb->data += len;
  
#line 1711 
  __retres = skb->data;
  
#line 1711 
  return __retres;
}


#line 1719 
unsigned char *__pskb_pull_tail(struct sk_buff *, int);


#line 1735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  unsigned int tmp;
  unsigned char *tmp_1;
  unsigned int tmp_0;
  
#line 1737 
  tmp = skb_headlen((struct sk_buff const *)skb);
  
#line 1737 
  ;
  
#line 1737 
  if ((long)(tmp >= len) != 0L) {
    
#line 1738 
    __retres = 1;
    
#line 1738 
    goto return_label;
  }
  else ;
  
#line 1739 
  if ((long)(skb->len < len) != 0L) {
    
#line 1740 
    __retres = 0;
    
#line 1740 
    goto return_label;
  }
  else ;
  
#line 1741 
  tmp_0 = skb_headlen((struct sk_buff const *)skb);
  
#line 1741 
  ;
  
#line 1741 
  ;
  
#line 1741 
  tmp_1 = __pskb_pull_tail(skb,(int)(len - tmp_0));
  
#line 1741 
  __retres = tmp_1 != (unsigned char *)0U;
  return_label: 
#line 1741 
                return __retres;
}


#line 1750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1752 
  __retres = (unsigned int)((long)skb->data - (long)skb->head);
  
#line 1752 
  return __retres;
}


#line 1923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reset_mac_header(struct sk_buff *skb)
{
  
#line 1925 
  skb->mac_header = (unsigned short)((long)skb->data - (long)skb->head);
  
#line 1926 
  return;
}


#line 2130 
void skb_queue_purge(struct sk_buff_head *);


#line 2427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb, unsigned int headroom, int cloned)
{
  int __retres;
  unsigned int tmp_0;
  
#line 2430 
  int delta = 0;
  
#line 2432 
  tmp_0 = skb_headroom((struct sk_buff const *)skb);
  
#line 2432 
  ;
  
#line 2432 
  if (tmp_0 < headroom) {
    unsigned int tmp;
    
#line 2433 
    tmp = skb_headroom((struct sk_buff const *)skb);
    
#line 2433 
    delta = (int)(headroom - tmp);
  }
  else ;
  
#line 2435 
  if (delta != 0 || cloned != 0) {
    int tmp_5;
    int tmp_2;
    int tmp_4;
    {
      int tmp_1;
      
#line 2436 
      int _max1 = 32;
      
#line 2436 
      int _max2 = 64;
      
#line 2436 
      if (_max1 > _max2) 
#line 2436 
                         tmp_1 = _max1; else 
#line 2436 
                                             tmp_1 = _max2;
      
#line 2436 
      tmp_2 = tmp_1;
    }
    {
      int tmp_3;
      
#line 2436 
      int _max1_0 = 32;
      
#line 2436 
      int _max2_0 = 64;
      
#line 2436 
      if (_max1_0 > _max2_0) 
#line 2436 
                             tmp_3 = _max1_0; else 
#line 2436 
                                                   tmp_3 = _max2_0;
      
#line 2436 
      tmp_4 = tmp_3;
    }
    
#line 2436 
    ;
    
#line 2436 
    ;
    
#line 2436 
    tmp_5 = pskb_expand_head(skb,((tmp_2 + -1) + delta) & ~ (tmp_4 + -1),0,32U);
    
#line 2436 
    __retres = tmp_5;
    
#line 2436 
    goto return_label;
  }
  else ;
  
#line 2438 
  __retres = 0;
  return_label: 
#line 2438 
                return __retres;
}


#line 2468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
{
  int tmp_0;
  int tmp;
  
#line 2470 
  tmp = skb_header_cloned((struct sk_buff const *)skb);
  
#line 2470 
  ;
  
#line 2470 
  ;
  
#line 2470 
  tmp_0 = __skb_cow(skb,headroom,tmp);
  
#line 2470 
  return tmp_0;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
void dql_reset(struct dql *);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static void u64_stats_init(struct u64_stats_sync *syncp)
{
  
#line 73 
  return;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_irq(struct u64_stats_sync const *syncp)
{
  unsigned int __retres;
  
#line 131 
  __retres = 0U;
  
#line 131 
  return __retres;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_irq(struct u64_stats_sync const *syncp, unsigned int start)
{
  bool __retres;
  
#line 144 
  __retres = (_Bool)0;
  
#line 144 
  return __retres;
}


#line 1787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_reset_tc(struct net_device *dev)
{
  
#line 1789 
  dev->num_tc = (unsigned char)0U;
  
#line 1790 
  memset((void *)(& dev->tc_to_txq),0,64UL);
  
#line 1791 
  memset((void *)(& dev->prio_tc_map),0,16UL);
  
#line 1792 
  return;
}


#line 1806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netdev_set_num_tc(struct net_device *dev, u8 num_tc)
{
  int __retres;
  
#line 1808 
  if ((unsigned int)num_tc > 16U) {
    
#line 1809 
    __retres = -22;
    
#line 1809 
    goto return_label;
  }
  else ;
  
#line 1811 
  dev->num_tc = num_tc;
  
#line 1812 
  __retres = 0;
  return_label: 
#line 1812 
                return __retres;
}


#line 2723  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q)
{
  
#line 2726 
  clear_bit(1L,(unsigned long volatile *)(& q->state));
  
#line 2727 
  dql_reset(& q->dql);
  
#line 2728 
  return;
}


#line 2867 
int netif_set_real_num_tx_queues(struct net_device *, unsigned int);


#line 2870 
int netif_set_real_num_rx_queues(struct net_device *, unsigned int);


#line 2900 
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);


#line 2931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  
#line 2933 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2934 
  return;
}


#line 3360 
int __hw_addr_sync_dev(struct netdev_hw_addr_list *, struct net_device *, int (*)(struct net_device *, unsigned char const *), int (*)(struct net_device *, unsigned char const *));


#line 3365 
void __hw_addr_unsync_dev(struct netdev_hw_addr_list *, struct net_device *, int (*)(struct net_device *, unsigned char const *));


#line 3398  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int __dev_uc_sync(struct net_device *dev, int (*sync)(struct net_device *, unsigned char const *), int (*unsync)(struct net_device *, unsigned char const *))
{
  int tmp;
  
#line 3404 
  tmp = __hw_addr_sync_dev(& dev->uc,dev,sync,unsync);
  
#line 3404 
  return tmp;
}


#line 3414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __dev_uc_unsync(struct net_device *dev, int (*unsync)(struct net_device *, unsigned char const *))
{
  
#line 3418 
  __hw_addr_unsync_dev(& dev->uc,dev,unsync);
  
#line 3419 
  return;
}


#line 3442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int __dev_mc_sync(struct net_device *dev, int (*sync)(struct net_device *, unsigned char const *), int (*unsync)(struct net_device *, unsigned char const *))
{
  int tmp;
  
#line 3448 
  tmp = __hw_addr_sync_dev(& dev->mc,dev,sync,unsync);
  
#line 3448 
  return tmp;
}


#line 3458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __dev_mc_unsync(struct net_device *dev, int (*unsync)(struct net_device *, unsigned char const *))
{
  
#line 3462 
  __hw_addr_unsync_dev(& dev->mc,dev,unsync);
  
#line 3463 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
int eth_validate_addr(struct net_device *);


#line 53 
static struct net_device *ldv_alloc_etherdev_mqs_74(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3);


#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)
{
  
#line 412 
  skb->vlan_proto = vlan_proto;
  
#line 413 
  skb->vlan_tci = (unsigned short)((unsigned int)vlan_tci | 4096U);
  
#line 414 
  return;
}


#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static struct netdev_queue *txring_txq(struct fm10k_ring const *ring)
{
  struct netdev_queue *__retres;
  
#line 172 
  __retres = (ring->netdev)->_tx + (int)ring->queue_index;
  
#line 172 
  return __retres;
}


#line 355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static void fm10k_mbx_lock_2(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 360 
  goto ldv_46794;
  ldv_46793: 
#line 361 
  ;
  
#line 361 
  __const_udelay(85900UL);
  ldv_46794: 
#line 363 
  ;
  
#line 360 
  tmp = test_and_set_bit(4L,(unsigned long volatile *)(& interface->state));
  
#line 360 
  if (tmp != 0) 
#line 362 
                goto ldv_46793; else 
#line 365 
                                     goto ldv_46795;
  ldv_46795: 
#line 366 
  ;
  
#line 367 
  return;
}


#line 444 
__be16 fm10k_tx_encap_offload(struct sk_buff *skb);


#line 445 
netdev_tx_t fm10k_xmit_frame_ring(struct sk_buff *skb, struct fm10k_ring *tx_ring);


#line 447 
void fm10k_tx_timeout_reset(struct fm10k_intfc *interface);


#line 448 
bool fm10k_check_tx_hang(struct fm10k_ring *tx_ring);


#line 475 
void fm10k_unmap_and_free_tx_resource(struct fm10k_ring *ring, struct fm10k_tx_buffer *tx_buffer);


#line 523 
void fm10k_ts_tx_enqueue(struct fm10k_intfc *interface, struct sk_buff *skb);


#line 531 
int fm10k_get_ts_config(struct net_device *netdev, struct ifreq *ifr);


#line 532 
int fm10k_set_ts_config(struct net_device *netdev, struct ifreq *ifr);


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vzalloc(unsigned long);


#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/vxlan.h"
void vxlan_get_rx_port(struct net_device *);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
int fm10k_setup_tx_resources(struct fm10k_ring *tx_ring)
{
  int __retres;
  int size;
  
#line 35 
  struct device *dev = tx_ring->dev;
  
#line 38 
  size = (int)((unsigned int)tx_ring->count * 40U);
  
#line 40 
  tx_ring->__anonCompField_fm10k_ring_97.tx_buffer = (struct fm10k_tx_buffer *)vzalloc((unsigned long)size);
  
#line 41 
  if (tx_ring->__anonCompField_fm10k_ring_97.tx_buffer == (struct fm10k_tx_buffer *)0) 
    
#line 42 
    goto err; else ;
  
#line 44 
  u64_stats_init(& tx_ring->syncp);
  
#line 47 
  tx_ring->size = (unsigned int)tx_ring->count * 16U;
  
#line 48 
  tx_ring->size = (tx_ring->size + 4095U) & 4294963200U;
  
#line 50 
  tx_ring->desc = dma_alloc_attrs(dev,(unsigned long)tx_ring->size,& tx_ring->dma,208U,(struct dma_attrs *)0);
  
#line 52 
  if (tx_ring->desc == (void *)0) 
#line 53 
                                  goto err; else ;
  
#line 55 
  __retres = 0;
  
#line 55 
  goto return_label;
  err: 
#line 57 
  ;
  
#line 58 
  vfree((void const *)tx_ring->__anonCompField_fm10k_ring_97.tx_buffer);
  
#line 59 
  tx_ring->__anonCompField_fm10k_ring_97.tx_buffer = (struct fm10k_tx_buffer *)0;
  
#line 60 
  __retres = -12;
  return_label: 
#line 60 
                return __retres;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_setup_all_tx_resources(struct fm10k_intfc *interface)
{
  int __retres;
  int i;
  int tmp;
  
#line 75 
  int err = 0;
  
#line 77 
  i = 0;
  
#line 77 
  goto ldv_52026;
  ldv_52025: 
#line 78 
  ;
  
#line 78 
  err = fm10k_setup_tx_resources(interface->tx_ring[i]);
  
#line 79 
  if (err == 0) 
#line 80 
                goto ldv_52023; else ;
  
#line 82 
  if (((int)interface->msg_enable & 2) != 0) 
#line 82 
                                             netdev_err((struct net_device const *)interface->netdev,"Allocation for Tx Queue %u failed\n",i); else ;
  
#line 84 
  goto err_setup_tx;
  ldv_52023: 
#line 85 
  ;
  
#line 77 
  i += 1;
  ldv_52026: 
#line 78 
  ;
  
#line 77 
  if (interface->num_tx_queues > i) 
#line 79 
                                    goto ldv_52025; else 
#line 82 
                                                         goto ldv_52027;
  ldv_52027: 
#line 83 
  ;
  
#line 87 
  __retres = 0;
  
#line 87 
  goto return_label;
  err_setup_tx: 
#line 88 
  ;
  
#line 90 
  goto ldv_52029;
  ldv_52028: 
#line 91 
  ;
  
#line 91 
  fm10k_free_tx_resources(interface->tx_ring[i]);
  ldv_52029: 
#line 92 
  ;
  
#line 90 
  tmp = i;
  
#line 90 
  i -= 1;
  
#line 90 
  ;
  
#line 90 
  if (tmp != 0) 
#line 92 
                goto ldv_52028; else 
#line 95 
                                     goto ldv_52030;
  ldv_52030: 
#line 96 
  ;
  
#line 92 
  __retres = err;
  return_label: 
#line 92 
                return __retres;
}


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
int fm10k_setup_rx_resources(struct fm10k_ring *rx_ring)
{
  int __retres;
  int size;
  
#line 103 
  struct device *dev = rx_ring->dev;
  
#line 106 
  size = (int)((unsigned int)rx_ring->count * 24U);
  
#line 108 
  rx_ring->__anonCompField_fm10k_ring_97.rx_buffer = (struct fm10k_rx_buffer *)vzalloc((unsigned long)size);
  
#line 109 
  if (rx_ring->__anonCompField_fm10k_ring_97.rx_buffer == (struct fm10k_rx_buffer *)0) 
    
#line 110 
    goto err; else ;
  
#line 112 
  u64_stats_init(& rx_ring->syncp);
  
#line 115 
  rx_ring->size = (unsigned int)rx_ring->count * 32U;
  
#line 116 
  rx_ring->size = (rx_ring->size + 4095U) & 4294963200U;
  
#line 118 
  rx_ring->desc = dma_alloc_attrs(dev,(unsigned long)rx_ring->size,& rx_ring->dma,208U,(struct dma_attrs *)0);
  
#line 120 
  if (rx_ring->desc == (void *)0) 
#line 121 
                                  goto err; else ;
  
#line 123 
  __retres = 0;
  
#line 123 
  goto return_label;
  err: 
#line 124 
  ;
  
#line 125 
  vfree((void const *)rx_ring->__anonCompField_fm10k_ring_97.rx_buffer);
  
#line 126 
  rx_ring->__anonCompField_fm10k_ring_97.rx_buffer = (struct fm10k_rx_buffer *)0;
  
#line 127 
  __retres = -12;
  return_label: 
#line 127 
                return __retres;
}


#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_setup_all_rx_resources(struct fm10k_intfc *interface)
{
  int __retres;
  int i;
  int tmp;
  
#line 142 
  int err = 0;
  
#line 144 
  i = 0;
  
#line 144 
  goto ldv_52045;
  ldv_52044: 
#line 145 
  ;
  
#line 145 
  err = fm10k_setup_rx_resources(interface->rx_ring[i]);
  
#line 146 
  if (err == 0) 
#line 147 
                goto ldv_52042; else ;
  
#line 149 
  if (((int)interface->msg_enable & 2) != 0) 
#line 149 
                                             netdev_err((struct net_device const *)interface->netdev,"Allocation for Rx Queue %u failed\n",i); else ;
  
#line 151 
  goto err_setup_rx;
  ldv_52042: 
#line 152 
  ;
  
#line 144 
  i += 1;
  ldv_52045: 
#line 145 
  ;
  
#line 144 
  if (interface->num_rx_queues > i) 
#line 146 
                                    goto ldv_52044; else 
#line 149 
                                                         goto ldv_52046;
  ldv_52046: 
#line 150 
  ;
  
#line 154 
  __retres = 0;
  
#line 154 
  goto return_label;
  err_setup_rx: 
#line 155 
  ;
  
#line 157 
  goto ldv_52048;
  ldv_52047: 
#line 158 
  ;
  
#line 158 
  fm10k_free_rx_resources(interface->rx_ring[i]);
  ldv_52048: 
#line 159 
  ;
  
#line 157 
  tmp = i;
  
#line 157 
  i -= 1;
  
#line 157 
  ;
  
#line 157 
  if (tmp != 0) 
#line 159 
                goto ldv_52047; else 
#line 162 
                                     goto ldv_52049;
  ldv_52049: 
#line 163 
  ;
  
#line 159 
  __retres = err;
  return_label: 
#line 159 
                return __retres;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
void fm10k_unmap_and_free_tx_resource(struct fm10k_ring *ring, struct fm10k_tx_buffer *tx_buffer)
{
  
#line 165 
  if (tx_buffer->skb != (struct sk_buff *)0) {
    
#line 166 
    dev_kfree_skb_any(tx_buffer->skb);
    
#line 167 
    if (tx_buffer->len != 0U) 
#line 168 
                              dma_unmap_single_attrs(ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0); else ;
  }
  else 
    
#line 172 
    if (tx_buffer->len != 0U) 
#line 173 
                              dma_unmap_page(ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE); else ;
  
#line 178 
  tx_buffer->next_to_watch = (struct fm10k_tx_desc *)0;
  
#line 179 
  tx_buffer->skb = (struct sk_buff *)0;
  
#line 180 
  tx_buffer->len = 0U;
  
#line 181 
  return;
}


#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_clean_tx_ring(struct fm10k_ring *tx_ring)
{
  struct fm10k_tx_buffer *tx_buffer;
  unsigned long size;
  u16 i;
  struct netdev_queue *tmp;
  
#line 195 
  if (tx_ring->__anonCompField_fm10k_ring_97.tx_buffer == (struct fm10k_tx_buffer *)0) 
    
#line 196 
    goto return_label; else ;
  
#line 199 
  i = (unsigned short)0U;
  
#line 199 
  goto ldv_52061;
  ldv_52060: 
#line 200 
  ;
  
#line 200 
  tx_buffer = tx_ring->__anonCompField_fm10k_ring_97.tx_buffer + (int)i;
  
#line 201 
  fm10k_unmap_and_free_tx_resource(tx_ring,tx_buffer);
  
#line 199 
  i = (u16)((int)i + 1);
  ldv_52061: 
#line 200 
  ;
  
#line 199 
  if ((int)tx_ring->count > (int)i) 
#line 201 
                                    goto ldv_52060; else 
#line 204 
                                                         goto ldv_52062;
  ldv_52062: 
#line 205 
  ;
  
#line 205 
  tmp = txring_txq((struct fm10k_ring const *)tx_ring);
  
#line 205 
  netdev_tx_reset_queue(tmp);
  
#line 207 
  size = (unsigned long)tx_ring->count * 40UL;
  
#line 208 
  memset((void *)tx_ring->__anonCompField_fm10k_ring_97.tx_buffer,0,size);
  
#line 211 
  memset(tx_ring->desc,0,(unsigned long)tx_ring->size);
  return_label: 
#line 212 
                return;
}


#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
void fm10k_free_tx_resources(struct fm10k_ring *tx_ring)
{
  
#line 222 
  fm10k_clean_tx_ring(tx_ring);
  
#line 224 
  vfree((void const *)tx_ring->__anonCompField_fm10k_ring_97.tx_buffer);
  
#line 225 
  tx_ring->__anonCompField_fm10k_ring_97.tx_buffer = (struct fm10k_tx_buffer *)0;
  
#line 228 
  if (tx_ring->desc == (void *)0) 
#line 229 
                                  goto return_label; else ;
  
#line 231 
  dma_free_attrs(tx_ring->dev,(unsigned long)tx_ring->size,tx_ring->desc,tx_ring->dma,(struct dma_attrs *)0);
  
#line 233 
  tx_ring->desc = (void *)0;
  return_label: 
#line 234 
                return;
}


#line 240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
void fm10k_clean_all_tx_rings(struct fm10k_intfc *interface)
{
  int i;
  
#line 244 
  i = 0;
  
#line 244 
  goto ldv_52071;
  ldv_52070: 
#line 245 
  ;
  
#line 245 
  fm10k_clean_tx_ring(interface->tx_ring[i]);
  
#line 244 
  i += 1;
  ldv_52071: 
#line 245 
  ;
  
#line 244 
  if (interface->num_tx_queues > i) 
#line 246 
                                    goto ldv_52070; else 
#line 249 
                                                         goto ldv_52072;
  ldv_52072: 
#line 250 
  ;
  
#line 248 
  skb_queue_purge(& interface->ts_tx_skb_queue);
  
#line 249 
  return;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_free_all_tx_resources(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 259 
  int i = interface->num_tx_queues;
  
#line 261 
  goto ldv_52078;
  ldv_52077: 
#line 262 
  ;
  
#line 262 
  fm10k_free_tx_resources(interface->tx_ring[i]);
  ldv_52078: 
#line 263 
  ;
  
#line 261 
  tmp = i;
  
#line 261 
  i -= 1;
  
#line 261 
  ;
  
#line 261 
  if (tmp != 0) 
#line 263 
                goto ldv_52077; else 
#line 266 
                                     goto ldv_52079;
  ldv_52079: 
#line 267 
  ;
  
#line 268 
  return;
}


#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_clean_rx_ring(struct fm10k_ring *rx_ring)
{
  unsigned long size;
  u16 i;
  
#line 274 
  if (rx_ring->__anonCompField_fm10k_ring_97.rx_buffer == (struct fm10k_rx_buffer *)0) 
    
#line 275 
    goto return_label; else ;
  
#line 277 
  if (rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.skb != (struct sk_buff *)0) 
    
#line 278 
    consume_skb(rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.skb); else ;
  
#line 279 
  rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.skb = (struct sk_buff *)0;
  
#line 282 
  i = (unsigned short)0U;
  
#line 282 
  goto ldv_52088;
  ldv_52087: 
#line 283 
  ;
  {
    
#line 283 
    struct fm10k_rx_buffer *buffer = rx_ring->__anonCompField_fm10k_ring_97.rx_buffer + (int)i;
    
#line 285 
    if (buffer->page == (struct page *)0) 
#line 286 
                                          goto ldv_52086; else ;
    
#line 288 
    dma_unmap_page(rx_ring->dev,buffer->dma,4096UL,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 290 
    __free_pages(buffer->page,0U);
    
#line 292 
    buffer->page = (struct page *)0;
  }
  ldv_52086: 
#line 294 
  ;
  
#line 282 
  i = (u16)((int)i + 1);
  ldv_52088: 
#line 283 
  ;
  
#line 282 
  if ((int)rx_ring->count > (int)i) 
#line 284 
                                    goto ldv_52087; else 
#line 287 
                                                         goto ldv_52089;
  ldv_52089: 
#line 288 
  ;
  
#line 295 
  size = (unsigned long)rx_ring->count * 24UL;
  
#line 296 
  memset((void *)rx_ring->__anonCompField_fm10k_ring_97.rx_buffer,0,size);
  
#line 299 
  memset(rx_ring->desc,0,(unsigned long)rx_ring->size);
  
#line 301 
  rx_ring->next_to_alloc = (unsigned short)0U;
  
#line 302 
  rx_ring->next_to_clean = (unsigned short)0U;
  
#line 303 
  rx_ring->next_to_use = (unsigned short)0U;
  return_label: 
#line 304 
                return;
}


#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
void fm10k_free_rx_resources(struct fm10k_ring *rx_ring)
{
  
#line 314 
  fm10k_clean_rx_ring(rx_ring);
  
#line 316 
  vfree((void const *)rx_ring->__anonCompField_fm10k_ring_97.rx_buffer);
  
#line 317 
  rx_ring->__anonCompField_fm10k_ring_97.rx_buffer = (struct fm10k_rx_buffer *)0;
  
#line 320 
  if (rx_ring->desc == (void *)0) 
#line 321 
                                  goto return_label; else ;
  
#line 323 
  dma_free_attrs(rx_ring->dev,(unsigned long)rx_ring->size,rx_ring->desc,rx_ring->dma,(struct dma_attrs *)0);
  
#line 326 
  rx_ring->desc = (void *)0;
  return_label: 
#line 327 
                return;
}


#line 333  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
void fm10k_clean_all_rx_rings(struct fm10k_intfc *interface)
{
  int i;
  
#line 337 
  i = 0;
  
#line 337 
  goto ldv_52098;
  ldv_52097: 
#line 338 
  ;
  
#line 338 
  fm10k_clean_rx_ring(interface->rx_ring[i]);
  
#line 337 
  i += 1;
  ldv_52098: 
#line 338 
  ;
  
#line 337 
  if (interface->num_rx_queues > i) 
#line 339 
                                    goto ldv_52097; else 
#line 342 
                                                         goto ldv_52099;
  ldv_52099: 
#line 343 
  ;
  
#line 344 
  return;
}


#line 347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_free_all_rx_resources(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 349 
  int i = interface->num_rx_queues;
  
#line 351 
  goto ldv_52105;
  ldv_52104: 
#line 352 
  ;
  
#line 352 
  fm10k_free_rx_resources(interface->rx_ring[i]);
  ldv_52105: 
#line 353 
  ;
  
#line 351 
  tmp = i;
  
#line 351 
  i -= 1;
  
#line 351 
  ;
  
#line 351 
  if (tmp != 0) 
#line 353 
                goto ldv_52104; else 
#line 356 
                                     goto ldv_52106;
  ldv_52106: 
#line 357 
  ;
  
#line 358 
  return;
}


#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_request_glort_range(struct fm10k_intfc *interface)
{
  
#line 363 
  struct fm10k_hw *hw = & interface->hw;
  
#line 364 
  u16 mask = (unsigned short)(~ hw->mac.dglort_map >> 16);
  
#line 367 
  interface->glort = (unsigned short)hw->mac.dglort_map;
  
#line 368 
  interface->glort_count = (unsigned short)0U;
  
#line 371 
  if (hw->mac.dglort_map == 65535U) 
#line 372 
                                    goto return_label; else ;
  
#line 379 
  if ((int)hw->iov.total_vfs >= (int)mask) {
    
#line 380 
    interface->glort_count = (unsigned short)1U;
    
#line 381 
    interface->glort = (unsigned short)((int)interface->glort + (int)mask);
  }
  else 
    
#line 382 
    if ((unsigned int)mask <= 63U) {
      
#line 383 
      interface->glort_count = (unsigned short)(((int)mask + 1) / 2);
      
#line 384 
      interface->glort = (unsigned short)((int)interface->glort + (int)interface->glort_count);
    }
    else {
      
#line 386 
      interface->glort_count = (unsigned short)((unsigned int)mask + 65473U);
      
#line 387 
      interface->glort = (unsigned short)((unsigned int)interface->glort + 64U);
    }
  return_label: 
#line 389 
                return;
}


#line 397  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_del_vxlan_port_all(struct fm10k_intfc *interface)
{
  struct fm10k_vxlan_port *vxlan_port;
  int tmp;
  int tmp_1;
  
#line 402 
  tmp = list_empty((struct list_head const *)(& interface->vxlan_port));
  
#line 402 
  if (tmp == 0) {
    struct fm10k_vxlan_port *tmp_0;
    {
      
#line 402 
      struct list_head const *__mptr = (struct list_head const *)interface->vxlan_port.next;
      
#line 402 
      tmp_0 = (struct fm10k_vxlan_port *)__mptr;
    }
    
#line 402 
    vxlan_port = tmp_0;
  }
  else 
#line 402 
       vxlan_port = (struct fm10k_vxlan_port *)0;
  
#line 404 
  goto ldv_52121;
  ldv_52120: 
#line 405 
  ;
  
#line 405 
  list_del(& vxlan_port->list);
  
#line 406 
  kfree((void const *)vxlan_port);
  
#line 407 
  tmp_1 = list_empty((struct list_head const *)(& interface->vxlan_port));
  
#line 407 
  if (tmp_1 == 0) {
    struct fm10k_vxlan_port *tmp_2;
    {
      
#line 407 
      struct list_head const *__mptr_0 = (struct list_head const *)interface->vxlan_port.next;
      
#line 407 
      tmp_2 = (struct fm10k_vxlan_port *)__mptr_0;
    }
    
#line 407 
    vxlan_port = tmp_2;
  }
  else 
#line 407 
       vxlan_port = (struct fm10k_vxlan_port *)0;
  ldv_52121: 
#line 408 
  ;
  
#line 404 
  if (vxlan_port != (struct fm10k_vxlan_port *)0) 
#line 406 
                                                  goto ldv_52120; else 
                                                                    
#line 409 
                                                                    goto ldv_52122;
  ldv_52122: 
#line 410 
  ;
  
#line 411 
  return;
}


#line 419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_restore_vxlan_port(struct fm10k_intfc *interface)
{
  struct fm10k_vxlan_port *vxlan_port;
  int tmp;
  
#line 421 
  struct fm10k_hw *hw = & interface->hw;
  
#line 425 
  if (hw->mac.type != (unsigned int)fm10k_mac_pf) 
#line 426 
                                                  goto return_label; else ;
  
#line 428 
  tmp = list_empty((struct list_head const *)(& interface->vxlan_port));
  
#line 428 
  if (tmp == 0) {
    struct fm10k_vxlan_port *tmp_0;
    {
      
#line 428 
      struct list_head const *__mptr = (struct list_head const *)interface->vxlan_port.next;
      
#line 428 
      tmp_0 = (struct fm10k_vxlan_port *)__mptr;
    }
    
#line 428 
    vxlan_port = tmp_0;
  }
  else 
#line 428 
       vxlan_port = (struct fm10k_vxlan_port *)0;
  {
    u32 * volatile *tmp_1;
    {
      
#line 432 
      u32 *__var = (u32 *)0U;
      
#line 432 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 432 
    u32 *hw_addr = *tmp_1;
    
#line 432 
    if ((long)(hw_addr == (u32 *)0U) == 0L) {
      int tmp_4;
      
#line 432 
      ;
      
#line 432 
      if (vxlan_port != (struct fm10k_vxlan_port *)0) {
        int tmp_3;
        
#line 432 
        if (0 != 0) 
#line 432 
                    tmp_3 = (int)((unsigned short)(((int)vxlan_port->port << 8) | ((int)vxlan_port->port >> 8))) | 1700265984;
        else {
          __u16 tmp_2;
          
#line 432 
          tmp_2 = __fswab16((unsigned short)((int)vxlan_port->port));
          
#line 432 
          tmp_3 = (int)tmp_2 | 1700265984;
        }
        
#line 432 
        tmp_4 = tmp_3;
      }
      else 
#line 432 
           tmp_4 = 1700265984;
      
#line 432 
      writel((unsigned int)tmp_4,(void volatile *)(hw_addr + 64U));
    }
    else ;
  }
  return_label: 
#line 434 
                return;
}


#line 449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_add_vxlan_port(struct net_device *dev, sa_family_t sa_family, __be16 port)
{
  struct fm10k_vxlan_port *vxlan_port;
  struct fm10k_vxlan_port *tmp_0;
  struct fm10k_vxlan_port *tmp_1;
  
#line 451 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 455 
  if (interface->hw.mac.type != (unsigned int)fm10k_mac_pf) 
#line 456 
                                                            goto return_label; else ;
  {
    
#line 459 
    struct list_head const *__mptr = (struct list_head const *)interface->vxlan_port.next;
    
#line 459 
    tmp_0 = (struct fm10k_vxlan_port *)__mptr;
  }
  
#line 459 
  vxlan_port = tmp_0;
  
#line 459 
  goto ldv_52146;
  ldv_52145: 
#line 460 
  ;
  
#line 460 
  if ((int)vxlan_port->port == (int)port && (int)vxlan_port->sa_family == (int)sa_family) {
    
#line 462 
    list_del(& vxlan_port->list);
    
#line 463 
    goto insert_tail;
  }
  else ;
  {
    
#line 459 
    struct list_head const *__mptr_0 = (struct list_head const *)vxlan_port->list.next;
    
#line 459 
    tmp_1 = (struct fm10k_vxlan_port *)__mptr_0;
  }
  
#line 459 
  vxlan_port = tmp_1;
  ldv_52146: 
#line 461 
  ;
  
#line 459 
  if (& vxlan_port->list != & interface->vxlan_port) 
#line 461 
                                                     goto ldv_52145; else 
                                                                    
#line 464 
                                                                    goto ldv_52147;
  ldv_52147: 
#line 465 
  ;
  
#line 468 
  vxlan_port = (struct fm10k_vxlan_port *)kmalloc(24UL,32U);
  
#line 469 
  if (vxlan_port == (struct fm10k_vxlan_port *)0) 
#line 470 
                                                  goto return_label; else ;
  
#line 471 
  vxlan_port->port = port;
  
#line 472 
  vxlan_port->sa_family = sa_family;
  insert_tail: 
#line 474 
  ;
  
#line 476 
  list_add_tail(& vxlan_port->list,& interface->vxlan_port);
  
#line 478 
  fm10k_restore_vxlan_port(interface);
  return_label: 
#line 479 
                return;
}


#line 492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_del_vxlan_port(struct net_device *dev, sa_family_t sa_family, __be16 port)
{
  struct fm10k_vxlan_port *vxlan_port;
  struct fm10k_vxlan_port *tmp_0;
  struct fm10k_vxlan_port *tmp_1;
  
#line 494 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 497 
  if (interface->hw.mac.type != (unsigned int)fm10k_mac_pf) 
#line 498 
                                                            goto return_label; else ;
  {
    
#line 501 
    struct list_head const *__mptr = (struct list_head const *)interface->vxlan_port.next;
    
#line 501 
    tmp_0 = (struct fm10k_vxlan_port *)__mptr;
  }
  
#line 501 
  vxlan_port = tmp_0;
  
#line 501 
  goto ldv_52161;
  ldv_52160: 
#line 502 
  ;
  
#line 502 
  if ((int)vxlan_port->port == (int)port && (int)vxlan_port->sa_family == (int)sa_family) {
    
#line 504 
    list_del(& vxlan_port->list);
    
#line 505 
    kfree((void const *)vxlan_port);
    
#line 506 
    goto ldv_52159;
  }
  else ;
  {
    
#line 501 
    struct list_head const *__mptr_0 = (struct list_head const *)vxlan_port->list.next;
    
#line 501 
    tmp_1 = (struct fm10k_vxlan_port *)__mptr_0;
  }
  
#line 501 
  vxlan_port = tmp_1;
  ldv_52161: 
#line 503 
  ;
  
#line 501 
  if (& vxlan_port->list != & interface->vxlan_port) 
#line 503 
                                                     goto ldv_52160; else 
                                                                    
#line 506 
                                                                    goto ldv_52159;
  ldv_52159: 
#line 507 
  ;
  
#line 510 
  fm10k_restore_vxlan_port(interface);
  return_label: 
#line 511 
                return;
}


#line 525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
int fm10k_open(struct net_device *netdev)
{
  int __retres;
  int err;
  
#line 527 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 531 
  err = fm10k_setup_all_tx_resources(interface);
  
#line 532 
  if (err != 0) 
#line 533 
                goto err_setup_tx; else ;
  
#line 536 
  err = fm10k_setup_all_rx_resources(interface);
  
#line 537 
  if (err != 0) 
#line 538 
                goto err_setup_rx; else ;
  
#line 541 
  err = fm10k_qv_request_irq(interface);
  
#line 542 
  if (err != 0) 
#line 543 
                goto err_req_irq; else ;
  
#line 546 
  fm10k_request_glort_range(interface);
  
#line 549 
  err = netif_set_real_num_tx_queues(netdev,(unsigned int)interface->num_tx_queues);
  
#line 551 
  if (err != 0) 
#line 552 
                goto err_set_queues; else ;
  
#line 554 
  err = netif_set_real_num_rx_queues(netdev,(unsigned int)interface->num_rx_queues);
  
#line 556 
  if (err != 0) 
#line 557 
                goto err_set_queues; else ;
  
#line 561 
  vxlan_get_rx_port(netdev);
  
#line 564 
  fm10k_up(interface);
  
#line 566 
  __retres = 0;
  
#line 566 
  goto return_label;
  err_set_queues: 
#line 568 
  ;
  
#line 569 
  fm10k_qv_free_irq(interface);
  err_req_irq: 
#line 570 
  ;
  
#line 571 
  fm10k_free_all_rx_resources(interface);
  err_setup_rx: 
#line 572 
  ;
  
#line 573 
  fm10k_free_all_tx_resources(interface);
  err_setup_tx: 
#line 574 
  ;
  
#line 575 
  __retres = err;
  return_label: 
#line 575 
                return __retres;
}


#line 589  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
int fm10k_close(struct net_device *netdev)
{
  int __retres;
  
#line 591 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 593 
  fm10k_down(interface);
  
#line 595 
  fm10k_qv_free_irq(interface);
  
#line 597 
  fm10k_del_vxlan_port_all(interface);
  
#line 599 
  fm10k_free_all_tx_resources(interface);
  
#line 600 
  fm10k_free_all_rx_resources(interface);
  
#line 602 
  __retres = 0;
  
#line 602 
  return __retres;
}


#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static netdev_tx_t fm10k_xmit_frame(struct sk_buff *skb, struct net_device *dev)
{
  netdev_tx_t __retres;
  int err;
  unsigned char *tmp_6;
  netdev_tx_t tmp_7;
  
#line 607 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 608 
  unsigned int r_idx = (unsigned int)skb->queue_mapping;
  
#line 611 
  if ((unsigned int)skb->protocol == 129U && ((int)skb->vlan_tci & 4096) == 0) {
    struct vlan_hdr *vhdr;
    __be16 proto;
    int tmp_0;
    int tmp_2;
    int tmp_4;
    
#line 620 
    skb = skb_share_check(skb,32U);
    
#line 621 
    if (skb == (struct sk_buff *)0) {
      
#line 622 
      __retres = NETDEV_TX_OK;
      
#line 622 
      goto return_label;
    }
    else ;
    
#line 625 
    tmp_0 = pskb_may_pull(skb,18U);
    
#line 625 
    if ((long)(tmp_0 == 0) != 0L) {
      
#line 626 
      __retres = NETDEV_TX_OK;
      
#line 626 
      goto return_label;
    }
    else ;
    
#line 629 
    err = skb_cow_head(skb,0U);
    
#line 630 
    if (err != 0) {
      
#line 631 
      __retres = NETDEV_TX_OK;
      
#line 631 
      goto return_label;
    }
    else ;
    
#line 634 
    vhdr = (struct vlan_hdr *)(skb->data + 14U);
    
#line 637 
    if (0 != 0) 
#line 637 
                tmp_2 = (int)((unsigned short)(((int)vhdr->h_vlan_TCI << 8) | ((int)vhdr->h_vlan_TCI >> 8)));
    else {
      __u16 tmp_1;
      
#line 639 
      tmp_1 = __fswab16((unsigned short)((int)vhdr->h_vlan_TCI));
      
#line 637 
      tmp_2 = (int)tmp_1;
    }
    
#line 637 
    ;
    
#line 637 
    __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)tmp_2);
    
#line 640 
    proto = vhdr->h_vlan_encapsulated_proto;
    
#line 641 
    if (0 != 0) 
#line 641 
                tmp_4 = (unsigned int)((unsigned short)(((int)proto << 8) | ((int)proto >> 8))) > 1535U;
    else {
      __u16 tmp_3;
      
#line 641 
      tmp_3 = __fswab16((unsigned short)((int)proto));
      
#line 641 
      tmp_4 = (unsigned int)tmp_3 > 1535U;
    }
    
#line 641 
    if (tmp_4) 
#line 641 
               skb->protocol = proto; else 
#line 641 
                                           skb->protocol = (unsigned short)1024U;
    
#line 645 
    memmove((void *)(skb->data + 4U),(void const *)skb->data,12UL);
    
#line 646 
    __skb_pull(skb,4U);
    
#line 647 
    skb_reset_mac_header(skb);
  }
  else ;
  
#line 653 
  if ((long)(skb->len <= 16U) != 0L) {
    int tmp_5;
    
#line 654 
    int pad_len = (int)(17U - skb->len);
    
#line 656 
    tmp_5 = skb_pad(skb,pad_len);
    
#line 656 
    if (tmp_5 != 0) {
      
#line 657 
      __retres = NETDEV_TX_OK;
      
#line 657 
      goto return_label;
    }
    else ;
    
#line 658 
    __skb_put(skb,(unsigned int)pad_len);
  }
  else ;
  
#line 662 
  tmp_6 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 662 
  ;
  
#line 662 
  if ((long)(((int)((struct skb_shared_info *)tmp_6)->tx_flags & 1) != 0) != 0L) 
    
#line 663 
    fm10k_ts_tx_enqueue(interface,skb); else ;
  
#line 665 
  if ((unsigned int)interface->num_tx_queues <= r_idx) 
#line 666 
                                                       r_idx %= (unsigned int)interface->num_tx_queues; else ;
  
#line 668 
  tmp_7 = fm10k_xmit_frame_ring(skb,interface->tx_ring[r_idx]);
  
#line 668 
  err = (int)tmp_7;
  
#line 670 
  __retres = (enum netdev_tx)err;
  return_label: 
#line 670 
                return __retres;
}


#line 673  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_change_mtu(struct net_device *dev, int new_mtu)
{
  int __retres;
  
#line 675 
  if ((unsigned int)new_mtu + 4294967228U > 15290U) {
    
#line 676 
    __retres = -22;
    
#line 676 
    goto return_label;
  }
  else ;
  
#line 678 
  dev->mtu = (unsigned int)new_mtu;
  
#line 680 
  __retres = 0;
  return_label: 
#line 680 
                return __retres;
}


#line 687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_tx_timeout(struct net_device *netdev)
{
  int i;
  
#line 689 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 690 
  bool real_tx_hang = (_Bool)0;
  
#line 694 
  i = 0;
  
#line 694 
  goto ldv_52197;
  ldv_52196: 
#line 695 
  ;
  {
    int tmp_0;
    
#line 695 
    struct fm10k_ring *tx_ring = interface->tx_ring[i];
    
#line 697 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& tx_ring->state));
    
#line 697 
    if (tmp_0 != 0) {
      bool tmp_1;
      
#line 697 
      tmp_1 = fm10k_check_tx_hang(tx_ring);
      
#line 697 
      if ((int)tmp_1 != 0) 
#line 698 
                           real_tx_hang = (_Bool)1; else ;
    }
    else ;
  }
  
#line 694 
  i += 1;
  ldv_52197: 
#line 695 
  ;
  
#line 694 
  if (interface->num_tx_queues > i) 
#line 696 
                                    goto ldv_52196; else 
#line 699 
                                                         goto ldv_52198;
  ldv_52198: 
#line 700 
  ;
  
#line 701 
  if ((int)real_tx_hang != 0) 
#line 702 
                              fm10k_tx_timeout_reset(interface);
  else {
    
#line 704 
    if (((int)interface->msg_enable & 1) != 0) 
#line 704 
                                               netdev_info((struct net_device const *)netdev,"Fake Tx hang detected with timeout of %d seconds\n",netdev->watchdog_timeo / 250); else ;
    
#line 709 
    if (netdev->watchdog_timeo <= 15999) 
#line 710 
                                         netdev->watchdog_timeo *= 2; else ;
  }
  
#line 712 
  return;
}


#line 714  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_uc_vlan_unsync(struct net_device *netdev, unsigned char const *uc_addr)
{
  int __retres;
  int err;
  
#line 717 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 718 
  struct fm10k_hw *hw = & interface->hw;
  
#line 719 
  u16 glort = interface->glort;
  
#line 720 
  u16 vid = interface->vid;
  
#line 721 
  bool set = (_Bool)((unsigned int)vid > 4095U);
  
#line 725 
  vid = (unsigned short)((unsigned int)vid & 4095U);
  
#line 727 
  err = (*(hw->mac.ops.update_uc_addr))(hw,(unsigned short)((int)glort),uc_addr,(unsigned short)((int)vid),(_Bool)((bool)((int)set) != 0),(unsigned char)0);
  
#line 728 
  if (err != 0) {
    
#line 729 
    __retres = err;
    
#line 729 
    goto return_label;
  }
  else ;
  
#line 732 
  __retres = 1;
  return_label: 
#line 732 
                return __retres;
}


#line 735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_mc_vlan_unsync(struct net_device *netdev, unsigned char const *mc_addr)
{
  int __retres;
  int err;
  
#line 738 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 739 
  struct fm10k_hw *hw = & interface->hw;
  
#line 740 
  u16 glort = interface->glort;
  
#line 741 
  u16 vid = interface->vid;
  
#line 742 
  bool set = (_Bool)((unsigned int)vid > 4095U);
  
#line 746 
  vid = (unsigned short)((unsigned int)vid & 4095U);
  
#line 748 
  err = (*(hw->mac.ops.update_mc_addr))(hw,(unsigned short)((int)glort),mc_addr,(unsigned short)((int)vid),(_Bool)((bool)((int)set) != 0));
  
#line 749 
  if (err != 0) {
    
#line 750 
    __retres = err;
    
#line 750 
    goto return_label;
  }
  else ;
  
#line 753 
  __retres = 1;
  return_label: 
#line 753 
                return __retres;
}


#line 756  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_update_vid(struct net_device *netdev, u16 vid, bool set)
{
  int __retres;
  s32 err;
  unsigned int tmp_0;
  
#line 758 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 759 
  struct fm10k_hw *hw = & interface->hw;
  
#line 763 
  if ((unsigned int)vid == 0U) {
    
#line 764 
    __retres = 0;
    
#line 764 
    goto return_label;
  }
  else ;
  
#line 766 
  if ((unsigned int)vid > 4095U) {
    
#line 767 
    __retres = -22;
    
#line 767 
    goto return_label;
  }
  else ;
  
#line 770 
  if ((int)hw->mac.vlan_override != 0) {
    
#line 771 
    __retres = -13;
    
#line 771 
    goto return_label;
  }
  else ;
  
#line 774 
  clear_bit((long)vid,(unsigned long volatile *)(& interface->active_vlans));
  
#line 775 
  if (! set) 
#line 776 
             clear_bit((long)vid,(unsigned long volatile *)(& interface->active_vlans)); else ;
  
#line 779 
  if ((int)hw->mac.default_vid == (int)vid) {
    
#line 780 
    __retres = 0;
    
#line 780 
    goto return_label;
  }
  else ;
  
#line 782 
  fm10k_mbx_lock_2(interface);
  
#line 785 
  if ((netdev->flags & 256U) == 0U) {
    
#line 786 
    err = (*(hw->mac.ops.update_vlan))(hw,(unsigned int)vid,(unsigned char)0,(_Bool)((bool)((int)set) != 0));
    
#line 787 
    if (err != 0) 
#line 788 
                  goto err_out; else ;
  }
  else ;
  
#line 792 
  err = (*(hw->mac.ops.update_uc_addr))(hw,(unsigned short)((int)interface->glort),(u8 const *)(& hw->mac.addr),(unsigned short)((int)vid),(_Bool)((bool)((int)set) != 0),(unsigned char)0);
  
#line 794 
  if (err != 0) 
#line 795 
                goto err_out; else ;
  
#line 798 
  if ((int)set != 0) 
#line 798 
                     tmp_0 = 4096U; else 
#line 798 
                                         tmp_0 = 0U;
  
#line 798 
  interface->vid = (unsigned short)(tmp_0 + (unsigned int)vid);
  
#line 801 
  __dev_uc_unsync(netdev,& fm10k_uc_vlan_unsync);
  
#line 802 
  __dev_mc_unsync(netdev,& fm10k_mc_vlan_unsync);
  err_out: 
#line 804 
  ;
  
#line 805 
  fm10k_mbx_unlock(interface);
  
#line 807 
  __retres = err;
  return_label: 
#line 807 
                return __retres;
}


#line 810  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  int tmp;
  
#line 814 
  tmp = fm10k_update_vid(netdev,(unsigned short)((int)vid),(_Bool)1);
  
#line 814 
  return tmp;
}


#line 817  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  int tmp;
  
#line 821 
  tmp = fm10k_update_vid(netdev,(unsigned short)((int)vid),(_Bool)0);
  
#line 821 
  return tmp;
}


#line 824  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static u16 fm10k_find_next_vlan(struct fm10k_intfc *interface, u16 vid)
{
  unsigned int tmp;
  unsigned long tmp_0;
  
#line 826 
  struct fm10k_hw *hw = & interface->hw;
  
#line 827 
  u16 default_vid = hw->mac.default_vid;
  
#line 828 
  if ((int)vid < (int)default_vid) 
#line 828 
                                   tmp = (unsigned int)default_vid; else 
                                                                    
#line 828 
                                                                    tmp = 4096U;
  
#line 828 
  u16 vid_limit = (unsigned short)tmp;
  
#line 830 
  vid = (u16)((int)vid + 1);
  
#line 830 
  ;
  
#line 830 
  ;
  
#line 830 
  tmp_0 = find_next_bit((unsigned long const *)(& interface->active_vlans),(unsigned long)vid_limit,(unsigned long)vid);
  
#line 830 
  vid = (unsigned short)tmp_0;
  
#line 832 
  return vid;
}


#line 835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_clear_unused_vlans(struct fm10k_intfc *interface)
{
  u32 vid;
  u32 prev_vid;
  u16 tmp;
  
#line 837 
  struct fm10k_hw *hw = & interface->hw;
  
#line 841 
  vid = 0U;
  
#line 841 
  prev_vid = 0U;
  
#line 841 
  goto ldv_52253;
  ldv_52252: 
#line 842 
  ;
  
#line 844 
  if (prev_vid == vid) 
#line 845 
                       goto ldv_52251; else ;
  
#line 848 
  prev_vid = (((vid - prev_vid) + 4294967295U) << 16) + prev_vid;
  
#line 849 
  (*(hw->mac.ops.update_vlan))(hw,prev_vid,(unsigned char)0,(_Bool)0);
  ldv_52251: 
#line 850 
  ;
  
#line 843 
  prev_vid = vid + 1U;
  
#line 843 
  tmp = fm10k_find_next_vlan(interface,(unsigned short)((int)((unsigned short)vid)));
  
#line 843 
  vid = (unsigned int)tmp;
  ldv_52253: 
#line 844 
  ;
  
#line 841 
  if (prev_vid <= 4095U) 
#line 844 
                         goto ldv_52252; else 
#line 847 
                                              goto ldv_52254;
  ldv_52254: 
#line 848 
  ;
  
#line 849 
  return;
}


#line 853  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int __fm10k_uc_sync(struct net_device *dev, unsigned char const *addr, bool sync)
{
  int __retres;
  u16 vid;
  s32 err;
  int tmp_1;
  bool tmp_0;
  
#line 856 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 857 
  struct fm10k_hw *hw = & interface->hw;
  
#line 858 
  u16 glort = interface->glort;
  
#line 861 
  tmp_0 = is_valid_ether_addr(addr);
  
#line 861 
  if (tmp_0) 
#line 861 
             tmp_1 = 0; else 
#line 861 
                             tmp_1 = 1;
  
#line 861 
  if (tmp_1) {
    
#line 862 
    __retres = -99;
    
#line 862 
    goto return_label;
  }
  else ;
  
#line 865 
  if ((unsigned int)hw->mac.default_vid != 0U) 
#line 865 
                                               vid = fm10k_find_next_vlan(interface,(unsigned short)0); else 
                                                                    
#line 865 
                                                                    vid = (unsigned short)0U;
  
#line 865 
  goto ldv_52266;
  ldv_52265: 
#line 866 
  ;
  
#line 868 
  err = (*(hw->mac.ops.update_uc_addr))(hw,(unsigned short)((int)glort),addr,(unsigned short)((int)vid),(_Bool)((bool)((int)sync) != 0),(unsigned char)0);
  
#line 870 
  if (err != 0) {
    
#line 871 
    __retres = err;
    
#line 871 
    goto return_label;
  }
  else ;
  
#line 867 
  vid = fm10k_find_next_vlan(interface,(unsigned short)((int)vid));
  ldv_52266: 
#line 868 
  ;
  
#line 865 
  if ((unsigned int)vid <= 4095U) 
#line 868 
                                  goto ldv_52265; else 
#line 871 
                                                       goto ldv_52267;
  ldv_52267: 
#line 872 
  ;
  
#line 874 
  __retres = 0;
  return_label: 
#line 874 
                return __retres;
}


#line 877  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_uc_sync(struct net_device *dev, unsigned char const *addr)
{
  int tmp;
  
#line 880 
  tmp = __fm10k_uc_sync(dev,addr,(_Bool)1);
  
#line 880 
  return tmp;
}


#line 883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_uc_unsync(struct net_device *dev, unsigned char const *addr)
{
  int tmp;
  
#line 886 
  tmp = __fm10k_uc_sync(dev,addr,(_Bool)0);
  
#line 886 
  return tmp;
}


#line 889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_set_mac(struct net_device *dev, void *p)
{
  int __retres;
  int tmp_1;
  bool tmp_0;
  int tmp_2;
  
#line 891 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 892 
  struct fm10k_hw *hw = & interface->hw;
  
#line 893 
  struct sockaddr *addr = (struct sockaddr *)p;
  
#line 894 
  s32 err = 0;
  
#line 896 
  tmp_0 = is_valid_ether_addr((u8 const *)(& addr->sa_data));
  
#line 896 
  if (tmp_0) 
#line 896 
             tmp_1 = 0; else 
#line 896 
                             tmp_1 = 1;
  
#line 896 
  if (tmp_1) {
    
#line 897 
    __retres = -99;
    
#line 897 
    goto return_label;
  }
  else ;
  
#line 899 
  if ((dev->flags & 1U) != 0U) {
    
#line 901 
    fm10k_mbx_lock_2(interface);
    
#line 903 
    err = fm10k_uc_sync(dev,(unsigned char const *)(& addr->sa_data));
    
#line 904 
    if (err == 0) 
#line 905 
                  fm10k_uc_unsync(dev,(unsigned char const *)(& hw->mac.addr)); else ;
    
#line 907 
    fm10k_mbx_unlock(interface);
  }
  else ;
  
#line 910 
  if (err == 0) {
    
#line 911 
    ether_addr_copy(dev->dev_addr,(u8 const *)(& addr->sa_data));
    
#line 912 
    ether_addr_copy((u8 *)(& hw->mac.addr),(u8 const *)(& addr->sa_data));
    
#line 913 
    dev->addr_assign_type = (unsigned char)((unsigned int)dev->addr_assign_type & 254U);
  }
  else ;
  
#line 917 
  if (err != 0) 
#line 917 
                tmp_2 = -11; else 
#line 917 
                                  tmp_2 = 0;
  
#line 917 
  __retres = tmp_2;
  return_label: 
#line 917 
                return __retres;
}


#line 920  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int __fm10k_mc_sync(struct net_device *dev, unsigned char const *addr, bool sync)
{
  int __retres;
  u16 vid;
  
#line 923 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 924 
  struct fm10k_hw *hw = & interface->hw;
  
#line 925 
  u16 glort = interface->glort;
  
#line 928 
  if ((unsigned int)hw->mac.default_vid != 0U) 
#line 928 
                                               vid = fm10k_find_next_vlan(interface,(unsigned short)0); else 
                                                                    
#line 928 
                                                                    vid = (unsigned short)0U;
  
#line 928 
  goto ldv_52294;
  ldv_52293: 
#line 929 
  ;
  
#line 931 
  (*(hw->mac.ops.update_mc_addr))(hw,(unsigned short)((int)glort),addr,(unsigned short)((int)vid),(_Bool)((bool)((int)sync) != 0));
  
#line 930 
  vid = fm10k_find_next_vlan(interface,(unsigned short)((int)vid));
  ldv_52294: 
#line 931 
  ;
  
#line 928 
  if ((unsigned int)vid <= 4095U) 
#line 931 
                                  goto ldv_52293; else 
#line 934 
                                                       goto ldv_52295;
  ldv_52295: 
#line 935 
  ;
  
#line 934 
  __retres = 0;
  
#line 934 
  return __retres;
}


#line 937  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_mc_sync(struct net_device *dev, unsigned char const *addr)
{
  int tmp;
  
#line 940 
  tmp = __fm10k_mc_sync(dev,addr,(_Bool)1);
  
#line 940 
  return tmp;
}


#line 943  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_mc_unsync(struct net_device *dev, unsigned char const *addr)
{
  int tmp;
  
#line 946 
  tmp = __fm10k_mc_sync(dev,addr,(_Bool)0);
  
#line 946 
  return tmp;
}


#line 949  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_set_rx_mode(struct net_device *dev)
{
  int xcast_mode;
  
#line 951 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 952 
  struct fm10k_hw *hw = & interface->hw;
  
#line 956 
  if ((dev->flags & 1U) == 0U) 
#line 957 
                               goto return_label; else ;
  
#line 960 
  if ((dev->flags & 256U) == 0U) {
    int tmp_1;
    
#line 960 
    if ((dev->flags & 512U) == 0U) {
      int tmp_0;
      
#line 961 
      if ((dev->flags & 4098U) != 0U) 
#line 961 
                                      tmp_0 = 1; else 
#line 961 
                                                      tmp_0 = 3;
      
#line 960 
      tmp_1 = tmp_0;
    }
    else 
#line 960 
         tmp_1 = 0;
    
#line 960 
    xcast_mode = tmp_1;
  }
  else 
#line 960 
       xcast_mode = 2;
  
#line 965 
  fm10k_mbx_lock_2(interface);
  
#line 968 
  if (interface->xcast_mode != xcast_mode) {
    
#line 970 
    if (xcast_mode == 2) 
#line 971 
                         (*(hw->mac.ops.update_vlan))(hw,268369920U,(unsigned char)0,(_Bool)1); else ;
    
#line 972 
    if (interface->xcast_mode == 2) 
#line 973 
                                    fm10k_clear_unused_vlans(interface); else ;
    
#line 976 
    (*(hw->mac.ops.update_xcast_mode))(hw,(unsigned short)((int)interface->glort),(unsigned char)((int)((unsigned char)xcast_mode)));
    
#line 979 
    interface->xcast_mode = xcast_mode;
  }
  else ;
  
#line 983 
  if (xcast_mode != 2) {
    
#line 984 
    __dev_uc_sync(dev,& fm10k_uc_sync,& fm10k_uc_unsync);
    
#line 985 
    if (xcast_mode != 0) 
#line 986 
                         __dev_mc_sync(dev,& fm10k_mc_sync,& fm10k_mc_unsync); else ;
  }
  else ;
  
#line 989 
  fm10k_mbx_unlock(interface);
  return_label: 
#line 990 
                return;
}


#line 992  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
void fm10k_restore_rx_state(struct fm10k_intfc *interface)
{
  int xcast_mode;
  u16 vid;
  u16 glort;
  
#line 994 
  struct net_device *netdev = interface->netdev;
  
#line 995 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1000 
  if (hw->mac.type == (unsigned int)fm10k_mac_vf) {
    bool tmp;
    
#line 1001 
    tmp = is_valid_ether_addr((u8 const *)(& hw->mac.perm_addr));
    
#line 1001 
    if ((int)tmp != 0) {
      
#line 1002 
      ether_addr_copy((u8 *)(& hw->mac.addr),(u8 const *)(& hw->mac.perm_addr));
      
#line 1003 
      ether_addr_copy((u8 *)(& netdev->perm_addr),(u8 const *)(& hw->mac.perm_addr));
      
#line 1004 
      ether_addr_copy(netdev->dev_addr,(u8 const *)(& hw->mac.perm_addr));
      
#line 1005 
      netdev->addr_assign_type = (unsigned char)((unsigned int)netdev->addr_assign_type & 254U);
    }
    else ;
    
#line 1008 
    if ((int)hw->mac.vlan_override != 0) 
#line 1009 
                                         netdev->features &= 18446744073709551359ULL; else 
                                                                    
#line 1011 
                                                                    netdev->features |= 256ULL;
  }
  else ;
  
#line 1015 
  glort = interface->glort;
  
#line 1018 
  if ((netdev->flags & 256U) != 0U) 
#line 1019 
                                    xcast_mode = 2;
  else 
    
#line 1020 
    if ((netdev->flags & 512U) != 0U) 
#line 1021 
                                      xcast_mode = 0;
    else 
      
#line 1022 
      if ((netdev->flags & 4098U) != 0U) 
#line 1023 
                                         xcast_mode = 1; else 
#line 1025 
                                                              xcast_mode = 3;
  
#line 1027 
  fm10k_mbx_lock_2(interface);
  
#line 1030 
  (*(hw->mac.ops.update_lport_state))(hw,(unsigned short)((int)glort),(unsigned short)((int)interface->glort_count),(_Bool)1);
  
#line 1033 
  (*(hw->mac.ops.update_vlan))(hw,268369920U,(unsigned char)0,(_Bool)(xcast_mode == 2));
  
#line 1037 
  (*(hw->mac.ops.update_vlan))(hw,0U,(unsigned char)0,(_Bool)1);
  
#line 1040 
  if ((unsigned int)hw->mac.default_vid != 0U) 
#line 1040 
                                               vid = fm10k_find_next_vlan(interface,(unsigned short)0); else 
                                                                    
#line 1040 
                                                                    vid = (unsigned short)0U;
  
#line 1040 
  goto ldv_52319;
  ldv_52318: 
#line 1041 
  ;
  
#line 1043 
  (*(hw->mac.ops.update_vlan))(hw,(unsigned int)vid,(unsigned char)0,(_Bool)1);
  
#line 1044 
  (*(hw->mac.ops.update_uc_addr))(hw,(unsigned short)((int)glort),(u8 const *)(& hw->mac.addr),(unsigned short)((int)vid),(_Bool)1,(unsigned char)0);
  
#line 1042 
  vid = fm10k_find_next_vlan(interface,(unsigned short)((int)vid));
  ldv_52319: 
#line 1043 
  ;
  
#line 1040 
  if ((unsigned int)vid <= 4095U) 
#line 1043 
                                  goto ldv_52318; else 
#line 1046 
                                                       goto ldv_52320;
  ldv_52320: 
#line 1047 
  ;
  
#line 1049 
  (*(hw->mac.ops.update_xcast_mode))(hw,(unsigned short)((int)glort),(unsigned char)((int)((unsigned char)xcast_mode)));
  
#line 1052 
  if (xcast_mode != 2) {
    
#line 1053 
    __dev_uc_sync(netdev,& fm10k_uc_sync,& fm10k_uc_unsync);
    
#line 1054 
    if (xcast_mode != 0) 
#line 1055 
                         __dev_mc_sync(netdev,& fm10k_mc_sync,& fm10k_mc_unsync); else ;
  }
  else ;
  
#line 1058 
  fm10k_mbx_unlock(interface);
  
#line 1061 
  interface->xcast_mode = xcast_mode;
  
#line 1064 
  fm10k_restore_vxlan_port(interface);
  
#line 1065 
  return;
}


#line 1067  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
void fm10k_reset_rx_state(struct fm10k_intfc *interface)
{
  
#line 1069 
  struct net_device *netdev = interface->netdev;
  
#line 1070 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1072 
  fm10k_mbx_lock_2(interface);
  
#line 1075 
  (*(hw->mac.ops.update_lport_state))(hw,(unsigned short)((int)interface->glort),(unsigned short)((int)interface->glort_count),(_Bool)0);
  
#line 1078 
  fm10k_mbx_unlock(interface);
  
#line 1081 
  interface->xcast_mode = 3;
  
#line 1084 
  __dev_uc_unsync(netdev,(int (*)(struct net_device *, unsigned char const *))0);
  
#line 1085 
  __dev_mc_unsync(netdev,(int (*)(struct net_device *, unsigned char const *))0);
  
#line 1086 
  return;
}


#line 1096  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static struct rtnl_link_stats64 *fm10k_get_stats64(struct net_device *netdev, struct rtnl_link_stats64 *stats)
{
  struct fm10k_ring *ring;
  unsigned int start;
  unsigned int i;
  u64 bytes;
  u64 packets;
  struct fm10k_ring * volatile *tmp_0;
  bool tmp_1;
  struct fm10k_ring * volatile *tmp_2;
  bool tmp_3;
  
#line 1099 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 1104 
  rcu_read_lock();
  
#line 1106 
  i = 0U;
  
#line 1106 
  goto ldv_52342;
  ldv_52341: 
#line 1107 
  ;
  {
    
#line 1107 
    struct fm10k_ring *__var = (struct fm10k_ring *)0;
    
#line 1107 
    tmp_0 = (struct fm10k_ring * volatile *)(& interface->rx_ring[i]);
  }
  
#line 1107 
  ring = *tmp_0;
  
#line 1109 
  if (ring == (struct fm10k_ring *)0) 
#line 1110 
                                      goto ldv_52338; else ;
  ldv_52339: 
#line 1112 
  ;
  
#line 1113 
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& ring->syncp));
  
#line 1114 
  packets = ring->stats.packets;
  
#line 1115 
  bytes = ring->stats.bytes;
  
#line 1116 
  tmp_1 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& ring->syncp),start);
  
#line 1116 
  if ((int)tmp_1 != 0) 
#line 1118 
                       goto ldv_52339; else 
#line 1121 
                                            goto ldv_52340;
  ldv_52340: 
#line 1122 
  ;
  
#line 1118 
  stats->rx_packets += packets;
  
#line 1119 
  stats->rx_bytes += bytes;
  ldv_52338: 
#line 1120 
  ;
  
#line 1106 
  i += 1U;
  ldv_52342: 
#line 1107 
  ;
  
#line 1106 
  if ((unsigned int)interface->num_rx_queues > i) 
#line 1108 
                                                  goto ldv_52341; else 
                                                                    
#line 1111 
                                                                    goto ldv_52343;
  ldv_52343: 
#line 1112 
  ;
  
#line 1122 
  i = 0U;
  
#line 1122 
  goto ldv_52350;
  ldv_52349: 
#line 1123 
  ;
  {
    
#line 1123 
    struct fm10k_ring *__var_0 = (struct fm10k_ring *)0;
    
#line 1123 
    tmp_2 = (struct fm10k_ring * volatile *)(& interface->tx_ring[i]);
  }
  
#line 1123 
  ring = *tmp_2;
  
#line 1125 
  if (ring == (struct fm10k_ring *)0) 
#line 1126 
                                      goto ldv_52346; else ;
  ldv_52347: 
#line 1128 
  ;
  
#line 1129 
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& ring->syncp));
  
#line 1130 
  packets = ring->stats.packets;
  
#line 1131 
  bytes = ring->stats.bytes;
  
#line 1132 
  tmp_3 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& ring->syncp),start);
  
#line 1132 
  if ((int)tmp_3 != 0) 
#line 1134 
                       goto ldv_52347; else 
#line 1137 
                                            goto ldv_52348;
  ldv_52348: 
#line 1138 
  ;
  
#line 1134 
  stats->tx_packets += packets;
  
#line 1135 
  stats->tx_bytes += bytes;
  ldv_52346: 
#line 1136 
  ;
  
#line 1122 
  i += 1U;
  ldv_52350: 
#line 1123 
  ;
  
#line 1122 
  if ((unsigned int)interface->num_tx_queues > i) 
#line 1124 
                                                  goto ldv_52349; else 
                                                                    
#line 1127 
                                                                    goto ldv_52351;
  ldv_52351: 
#line 1128 
  ;
  
#line 1138 
  rcu_read_unlock();
  
#line 1141 
  stats->rx_missed_errors = (unsigned long long)netdev->stats.rx_missed_errors;
  
#line 1143 
  return stats;
}


#line 1146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
int fm10k_setup_tc(struct net_device *dev, u8 tc)
{
  int __retres;
  bool tmp_0;
  bool tmp_1;
  
#line 1148 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 1151 
  if ((unsigned int)tc != 0U && interface->hw.mac.type != (unsigned int)fm10k_mac_pf) {
    
#line 1152 
    __retres = -22;
    
#line 1152 
    goto return_label;
  }
  else ;
  
#line 1155 
  if ((unsigned int)tc > 8U) {
    
#line 1156 
    __retres = -22;
    
#line 1156 
    goto return_label;
  }
  else ;
  
#line 1162 
  tmp_0 = netif_running((struct net_device const *)dev);
  
#line 1162 
  if ((int)tmp_0 != 0) 
#line 1163 
                       fm10k_close(dev); else ;
  
#line 1165 
  fm10k_mbx_free_irq(interface);
  
#line 1167 
  fm10k_clear_queueing_scheme(interface);
  
#line 1170 
  netdev_reset_tc(dev);
  
#line 1171 
  netdev_set_num_tc(dev,(unsigned char)((int)tc));
  
#line 1173 
  fm10k_init_queueing_scheme(interface);
  
#line 1175 
  fm10k_mbx_request_irq(interface);
  
#line 1177 
  tmp_1 = netif_running((struct net_device const *)dev);
  
#line 1177 
  if ((int)tmp_1 != 0) 
#line 1178 
                       fm10k_open(dev); else ;
  
#line 1181 
  interface->flags |= 16U;
  
#line 1183 
  __retres = 0;
  return_label: 
#line 1183 
                return __retres;
}


#line 1186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static int fm10k_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
  int __retres;
  
#line 1188 
  switch (cmd) {
    int tmp;
    int tmp_0;
    case 35249: 
#line 1189 
    ;
    
#line 1190 
    tmp = fm10k_get_ts_config(netdev,ifr);
    
#line 1190 
    __retres = tmp;
    
#line 1190 
    goto return_label;
    case 35248: 
#line 1191 
    ;
    
#line 1192 
    tmp_0 = fm10k_set_ts_config(netdev,ifr);
    
#line 1192 
    __retres = tmp_0;
    
#line 1192 
    goto return_label;
    default: 
#line 1193 
    ;
    
#line 1194 
    __retres = -95;
    
#line 1194 
    goto return_label;
  }
  return_label: 
#line 1188 
                return __retres;
}


#line 1206 
void __compiletime_assert_1206(void);


#line 1198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_assign_l2_accel(struct fm10k_intfc *interface, struct fm10k_l2_accel *l2_accel)
{
  struct fm10k_ring *ring;
  int i;
  struct fm10k_l2_accel * volatile *tmp;
  
#line 1204 
  i = 0;
  
#line 1204 
  goto ldv_52378;
  ldv_52377: 
#line 1205 
  ;
  
#line 1205 
  ring = interface->rx_ring[i];
  {
    
#line 1206 
    bool __cond = (_Bool)0;
    
#line 1206 
    if ((int)__cond != 0) 
#line 1206 
                          __compiletime_assert_1206(); else ;
  }
  
#line 1208 
  ldv_inline_asm();
  {
    
#line 1206 
    struct fm10k_l2_accel *__var = (struct fm10k_l2_accel *)0;
    
#line 1206 
    tmp = (struct fm10k_l2_accel * volatile *)(& ring->l2_accel);
  }
  
#line 1206 
  *tmp = l2_accel;
  
#line 1204 
  i += 1;
  ldv_52378: 
#line 1205 
  ;
  
#line 1204 
  if (interface->num_rx_queues > i) 
#line 1206 
                                    goto ldv_52377; else 
#line 1209 
                                                         goto ldv_52379;
  ldv_52379: 
#line 1210 
  ;
  
#line 1209 
  interface->l2_accel = l2_accel;
  
#line 1210 
  return;
}


#line 1260 
void __compiletime_assert_1260(void);


#line 1212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void *fm10k_dfwd_add_station(struct net_device *dev, struct net_device *sdev)
{
  void *__retres;
  int i;
  u16 glort;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  
#line 1215 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 1216 
  struct fm10k_l2_accel *l2_accel = interface->l2_accel;
  
#line 1217 
  struct fm10k_l2_accel *old_l2_accel = (struct fm10k_l2_accel *)0;
  
#line 1218 
  struct fm10k_dglort_cfg dglort = {.glort = (unsigned short)0U, .queue_b = (unsigned short)0, .vsi_b = (unsigned char)0, .idx = (unsigned char)0, .rss_l = (unsigned char)0, .pc_l = (unsigned char)0, .vsi_l = (unsigned char)0, .queue_l = (unsigned char)0, .shared_l = (unsigned char)0, .inner_rss = (unsigned char)0};
  
#line 1219 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1220 
  int size = 0;
  
#line 1224 
  if (l2_accel == (struct fm10k_l2_accel *)0) {
    
#line 1226 
    if ((unsigned int)interface->glort_count <= 6U) {
      void *tmp_0;
      
#line 1227 
      tmp_0 = ERR_PTR(-16L);
      
#line 1227 
      __retres = tmp_0;
      
#line 1227 
      goto return_label;
    }
    else ;
    
#line 1229 
    size = 80;
    
#line 1230 
    l2_accel = (struct fm10k_l2_accel *)kzalloc_0((unsigned long)size,208U);
    
#line 1231 
    if (l2_accel == (struct fm10k_l2_accel *)0) {
      void *tmp_2;
      
#line 1232 
      tmp_2 = ERR_PTR(-12L);
      
#line 1232 
      __retres = tmp_2;
      
#line 1232 
      goto return_label;
    }
    else ;
    
#line 1234 
    l2_accel->size = 7;
    
#line 1235 
    l2_accel->dglort = interface->glort;
    
#line 1238 
    fm10k_assign_l2_accel(interface,l2_accel);
  }
  else 
    
#line 1240 
    if ((unsigned int)l2_accel->count == 63U || (int)l2_accel->count == (int)interface->glort_count + -1) {
      void *tmp_3;
      
#line 1242 
      tmp_3 = ERR_PTR(-16L);
      
#line 1242 
      __retres = tmp_3;
      
#line 1242 
      goto return_label;
    }
    else 
      
#line 1244 
      if ((int)l2_accel->count == l2_accel->size) {
        
#line 1245 
        old_l2_accel = l2_accel;
        
#line 1246 
        size = (int)((long)((void *)24 + ((unsigned int)l2_accel->size * 16U + 8U)));
        
#line 1248 
        l2_accel = (struct fm10k_l2_accel *)kzalloc_0((unsigned long)size,208U);
        
#line 1249 
        if (l2_accel == (struct fm10k_l2_accel *)0) {
          void *tmp_5;
          
#line 1250 
          tmp_5 = ERR_PTR(-12L);
          
#line 1250 
          __retres = tmp_5;
          
#line 1250 
          goto return_label;
        }
        else ;
        
#line 1252 
        memcpy((void *)l2_accel,(void const *)old_l2_accel,(unsigned long)((void *)24 + (unsigned int)old_l2_accel->size * 8U));
        
#line 1256 
        l2_accel->size = old_l2_accel->size * 2 + 1;
        
#line 1259 
        fm10k_assign_l2_accel(interface,l2_accel);
        {
          
#line 1260 
          bool __cond = (_Bool)0;
          
#line 1260 
          if ((int)__cond != 0) 
#line 1260 
                                __compiletime_assert_1260(); else ;
        }
        
#line 1260 
        kfree_call_rcu(& old_l2_accel->rcu,(void (*)(struct callback_head *))8);
      }
      else ;
  
#line 1264 
  i = 0;
  
#line 1264 
  goto ldv_52399;
  ldv_52398: 
#line 1265 
  ;
  
#line 1265 
  if (l2_accel->macvlan[i] == (struct net_device *)0) 
#line 1266 
                                                      goto ldv_52397; else ;
  
#line 1264 
  i += 1;
  ldv_52399: 
#line 1265 
  ;
  
#line 1264 
  if (l2_accel->size > i) 
#line 1266 
                          goto ldv_52398; else 
#line 1269 
                                               goto ldv_52397;
  ldv_52397: 
#line 1270 
  ;
  
#line 1270 
  l2_accel->macvlan[i] = sdev;
  
#line 1271 
  l2_accel->count = (u16)((int)l2_accel->count + 1);
  
#line 1274 
  dglort.idx = (unsigned char)7U;
  
#line 1275 
  dglort.inner_rss = (unsigned char)1U;
  
#line 1276 
  tmp_6 = fls((int)interface->ring_feature[0].mask);
  
#line 1276 
  dglort.rss_l = (unsigned char)tmp_6;
  
#line 1277 
  tmp_7 = fls((int)interface->ring_feature[1].mask);
  
#line 1277 
  dglort.pc_l = (unsigned char)tmp_7;
  
#line 1278 
  dglort.glort = interface->glort;
  
#line 1279 
  tmp_8 = fls(l2_accel->size);
  
#line 1279 
  dglort.shared_l = (unsigned char)tmp_8;
  
#line 1280 
  (*(hw->mac.ops.configure_dglort_map))(hw,& dglort);
  
#line 1283 
  fm10k_mbx_lock_2(interface);
  
#line 1285 
  glort = (unsigned short)((unsigned int)((int)l2_accel->dglort + (int)((unsigned short)i)) + 1U);
  
#line 1286 
  (*(hw->mac.ops.update_xcast_mode))(hw,(unsigned short)((int)glort),(unsigned char)1);
  
#line 1287 
  (*(hw->mac.ops.update_uc_addr))(hw,(unsigned short)((int)glort),(u8 const *)sdev->dev_addr,(unsigned short)0,(_Bool)1,(unsigned char)0);
  
#line 1289 
  fm10k_mbx_unlock(interface);
  
#line 1291 
  __retres = (void *)sdev;
  return_label: 
#line 1291 
                return __retres;
}


#line 1342 
void __compiletime_assert_1342(void);


#line 1294  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static void fm10k_dfwd_del_station(struct net_device *dev, void *priv)
{
  struct fm10k_l2_accel * volatile *tmp_0;
  int i;
  u16 glort;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  
#line 1296 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  {
    
#line 1297 
    struct fm10k_l2_accel *__var = (struct fm10k_l2_accel *)0;
    
#line 1297 
    tmp_0 = (struct fm10k_l2_accel * volatile *)(& interface->l2_accel);
  }
  
#line 1297 
  struct fm10k_l2_accel *l2_accel = *tmp_0;
  
#line 1298 
  struct fm10k_dglort_cfg dglort = {.glort = (unsigned short)0U, .queue_b = (unsigned short)0, .vsi_b = (unsigned char)0, .idx = (unsigned char)0, .rss_l = (unsigned char)0, .pc_l = (unsigned char)0, .vsi_l = (unsigned char)0, .queue_l = (unsigned char)0, .shared_l = (unsigned char)0, .inner_rss = (unsigned char)0};
  
#line 1299 
  struct fm10k_hw *hw = & interface->hw;
  
#line 1300 
  struct net_device *sdev = (struct net_device *)priv;
  
#line 1304 
  if (l2_accel == (struct fm10k_l2_accel *)0) 
#line 1305 
                                              goto return_label; else ;
  
#line 1308 
  i = 0;
  
#line 1308 
  goto ldv_52415;
  ldv_52414: 
#line 1309 
  ;
  
#line 1309 
  if (l2_accel->macvlan[i] == sdev) 
#line 1310 
                                    goto ldv_52413; else ;
  
#line 1308 
  i += 1;
  ldv_52415: 
#line 1309 
  ;
  
#line 1308 
  if (l2_accel->size > i) 
#line 1310 
                          goto ldv_52414; else 
#line 1313 
                                               goto ldv_52413;
  ldv_52413: 
#line 1314 
  ;
  
#line 1314 
  if (l2_accel->size == i) 
#line 1315 
                           goto return_label; else ;
  
#line 1318 
  fm10k_mbx_lock_2(interface);
  
#line 1320 
  glort = (unsigned short)((unsigned int)((int)l2_accel->dglort + (int)((unsigned short)i)) + 1U);
  
#line 1321 
  (*(hw->mac.ops.update_xcast_mode))(hw,(unsigned short)((int)glort),(unsigned char)3);
  
#line 1322 
  (*(hw->mac.ops.update_uc_addr))(hw,(unsigned short)((int)glort),(u8 const *)sdev->dev_addr,(unsigned short)0,(_Bool)0,(unsigned char)0);
  
#line 1324 
  fm10k_mbx_unlock(interface);
  
#line 1327 
  l2_accel->macvlan[i] = (struct net_device *)0;
  
#line 1328 
  l2_accel->count = (u16)((int)l2_accel->count - 1);
  
#line 1331 
  dglort.idx = (unsigned char)7U;
  
#line 1332 
  dglort.inner_rss = (unsigned char)1U;
  
#line 1333 
  tmp_1 = fls((int)interface->ring_feature[0].mask);
  
#line 1333 
  dglort.rss_l = (unsigned char)tmp_1;
  
#line 1334 
  tmp_2 = fls((int)interface->ring_feature[1].mask);
  
#line 1334 
  dglort.pc_l = (unsigned char)tmp_2;
  
#line 1335 
  dglort.glort = interface->glort;
  
#line 1336 
  tmp_3 = fls(l2_accel->size);
  
#line 1336 
  dglort.shared_l = (unsigned char)tmp_3;
  
#line 1337 
  (*(hw->mac.ops.configure_dglort_map))(hw,& dglort);
  
#line 1340 
  if ((unsigned int)l2_accel->count == 0U) {
    
#line 1341 
    fm10k_assign_l2_accel(interface,(struct fm10k_l2_accel *)0);
    {
      
#line 1342 
      bool __cond = (_Bool)0;
      
#line 1342 
      if ((int)__cond != 0) 
#line 1342 
                            __compiletime_assert_1342(); else ;
    }
    
#line 1342 
    kfree_call_rcu(& l2_accel->rcu,(void (*)(struct callback_head *))8);
  }
  else ;
  return_label: 
#line 1344 
                return;
}


#line 1346  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static netdev_features_t fm10k_features_check(struct sk_buff *skb, struct net_device *dev, netdev_features_t features)
{
  netdev_features_t __retres;
  
#line 1350 
  if ((unsigned int)*((unsigned char *)skb + 146UL) == 0U) {
    
#line 1351 
    __retres = features;
    
#line 1351 
    goto return_label;
  }
  else {
    __be16 tmp;
    
#line 1350 
    tmp = fm10k_tx_encap_offload(skb);
    
#line 1350 
    if ((unsigned int)tmp != 0U) {
      
#line 1351 
      __retres = features;
      
#line 1351 
      goto return_label;
    }
    else ;
  }
  
#line 1353 
  __retres = features & 18446744073172746213ULL;
  return_label: 
#line 1353 
                return __retres;
}


#line 1356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
static struct net_device_ops const fm10k_netdev_ops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & fm10k_open, .ndo_stop = & fm10k_close, .ndo_start_xmit = & fm10k_xmit_frame, .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & fm10k_set_rx_mode, .ndo_set_mac_address = & fm10k_set_mac, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & fm10k_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & fm10k_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = & fm10k_tx_timeout, .ndo_get_stats64 = & fm10k_get_stats64, .ndo_get_stats = (struct net_device_stats *(*)(struct net_device *))0, .ndo_vlan_rx_add_vid = & fm10k_vlan_rx_add_vid, .ndo_vlan_rx_kill_vid = & fm10k_vlan_rx_kill_vid, .ndo_poll_controller = & fm10k_netpoll, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = (int (*)(struct napi_struct *))0, .ndo_set_vf_mac = & fm10k_ndo_set_vf_mac, .ndo_set_vf_vlan = & fm10k_ndo_set_vf_vlan, .ndo_set_vf_rate = & fm10k_ndo_set_vf_bw, .ndo_set_vf_spoofchk = (int (*)(struct net_device *, int , bool ))0, .ndo_get_vf_config = & fm10k_ndo_get_vf_config, .ndo_set_vf_link_state = (int (*)(struct net_device *, int , int ))0, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = & fm10k_setup_tc, .ndo_fcoe_enable = (int (*)(struct net_device *))0, .ndo_fcoe_disable = (int (*)(struct net_device *))0, .ndo_fcoe_ddp_setup = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_ddp_done = (int (*)(struct net_device *, u16 ))0, .ndo_fcoe_ddp_target = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = (int (*)(struct net_device *, struct sk_buff const *, u16 , u32 ))0, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = (netdev_features_t (*)(struct net_device *, netdev_features_t ))0, .ndo_set_features = (int (*)(struct net_device *, netdev_features_t ))0, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ))0, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = (int (*)(struct net_device *, struct netdev_phys_item_id *))0, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = & fm10k_add_vxlan_port, .ndo_del_vxlan_port = & fm10k_del_vxlan_port, .ndo_dfwd_add_station = & fm10k_dfwd_add_station, .ndo_dfwd_del_station = & fm10k_dfwd_del_station, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = & fm10k_features_check, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 1386  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c"
struct net_device *fm10k_alloc_netdev(void)
{
  struct net_device *__retres;
  struct fm10k_intfc *interface;
  struct net_device *dev;
  
#line 1391 
  dev = ldv_alloc_etherdev_mqs_74(19136,128U,128U);
  
#line 1392 
  if (dev == (struct net_device *)0) {
    
#line 1393 
    __retres = (struct net_device *)0;
    
#line 1393 
    goto return_label;
  }
  else ;
  
#line 1396 
  dev->netdev_ops = & fm10k_netdev_ops;
  
#line 1397 
  fm10k_set_ethtool_ops(dev);
  
#line 1400 
  interface = (struct fm10k_intfc *)netdev_priv((struct net_device const *)dev);
  
#line 1401 
  interface->msg_enable = (unsigned short)7U;
  
#line 1404 
  dev->features |= 25838551059ULL;
  
#line 1415 
  dev->hw_features |= dev->features;
  
#line 1418 
  dev->hw_features |= 4398046511104ULL;
  
#line 1421 
  dev->vlan_features |= dev->features;
  
#line 1424 
  dev->hw_enc_features |= 68747282ULL;
  
#line 1435 
  dev->features |= 896ULL;
  
#line 1439 
  dev->priv_flags |= 131072U;
  
#line 1441 
  __retres = dev;
  return_label: 
#line 1441 
                return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
int (*ldv_emg_alias_eth_validate_addr_26)(struct net_device *) = & eth_validate_addr;

#line 68 
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
int ldv_emg_wrapper_fm10k_set_mac_12(struct net_device *arg0, void *arg1)
{
  int tmp;
  
#line 75 
  tmp = fm10k_set_mac(arg0,arg1);
  
#line 75 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
void *ldv_emg_wrapper_fm10k_dfwd_add_station_36(struct net_device *arg0, struct net_device *arg1)
{
  void *tmp;
  
#line 80 
  tmp = fm10k_dfwd_add_station(arg0,arg1);
  
#line 80 
  return tmp;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
void ldv_emg_wrapper_fm10k_tx_timeout_13(struct net_device *arg0)
{
  
#line 85 
  fm10k_tx_timeout(arg0);
  
#line 86 
  return;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
void ldv_emg_wrapper_fm10k_del_vxlan_port_19(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  
#line 90 
  fm10k_del_vxlan_port(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 91 
  return;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
int ldv_emg_wrapper_fm10k_ioctl_15(struct net_device *arg0, struct ifreq *arg1, int arg2)
{
  int tmp;
  
#line 95 
  tmp = fm10k_ioctl(arg0,arg1,arg2);
  
#line 95 
  return tmp;
}


#line 99  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
int ldv_emg_wrapper_fm10k_change_mtu_4(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 100 
  tmp = fm10k_change_mtu(arg0,arg1);
  
#line 100 
  return tmp;
}


#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
void ldv_emg_wrapper_fm10k_add_vxlan_port_7(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  
#line 105 
  fm10k_add_vxlan_port(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 106 
  return;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
unsigned long long ldv_emg_wrapper_fm10k_features_check_32(struct sk_buff *arg0, struct net_device *arg1, unsigned long long arg2)
{
  unsigned long long tmp;
  
#line 110 
  tmp = fm10k_features_check(arg0,arg1,arg2);
  
#line 110 
  return tmp;
}


#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
struct rtnl_link_stats64 *ldv_emg_wrapper_fm10k_get_stats64_2(struct net_device *arg0, struct rtnl_link_stats64 *arg1)
{
  struct rtnl_link_stats64 *tmp;
  
#line 115 
  tmp = fm10k_get_stats64(arg0,arg1);
  
#line 115 
  return tmp;
}


#line 119  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
int ldv_emg_wrapper_fm10k_vlan_rx_kill_vid_41(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  int tmp;
  
#line 120 
  tmp = fm10k_vlan_rx_kill_vid(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 120 
  return tmp;
}


#line 124  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
void ldv_emg_wrapper_fm10k_set_rx_mode_20(struct net_device *arg0)
{
  
#line 125 
  fm10k_set_rx_mode(arg0);
  
#line 126 
  return;
}


#line 129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
int ldv_emg_wrapper_fm10k_vlan_rx_add_vid_30(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  int tmp;
  
#line 130 
  tmp = fm10k_vlan_rx_add_vid(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 130 
  return tmp;
}


#line 134  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
enum netdev_tx ldv_emg_wrapper_fm10k_xmit_frame_11(struct sk_buff *arg0, struct net_device *arg1)
{
  enum netdev_tx tmp;
  
#line 135 
  tmp = fm10k_xmit_frame(arg0,arg1);
  
#line 135 
  return tmp;
}


#line 139  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
void ldv_emg_wrapper_fm10k_dfwd_del_station_33(struct net_device *arg0, void *arg1)
{
  
#line 140 
  fm10k_dfwd_del_station(arg0,arg1);
  
#line 141 
  return;
}


#line 145  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
static void *ERR_PTR(long error)
{
  void *tmp;
  
#line 148 
  tmp = ldv_err_ptr(error);
  
#line 148 
  return tmp;
}


#line 485  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 488 
  tmp = ldv_kmalloc(size,flags);
  
#line 488 
  return tmp;
}


#line 506  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 509 
  tmp = ldv_kzalloc(size,flags);
  
#line 509 
  return tmp;
}


#line 833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_netdev.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_74(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3)
{
  struct net_device *tmp;
  
#line 837 
  tmp = ldv_emg_alloc_etherdev_mqs(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 837 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.h"
s32 fm10k_get_bus_info_generic(struct fm10k_hw *hw);


#line 53 
s32 fm10k_get_invariants_generic(struct fm10k_hw *hw);


#line 54 
s32 fm10k_disable_queues_generic(struct fm10k_hw *hw, u16 q_cnt);


#line 55 
s32 fm10k_start_hw_generic(struct fm10k_hw *hw);


#line 56 
s32 fm10k_stop_hw_generic(struct fm10k_hw *hw);


#line 57 
u32 fm10k_read_hw_stats_32b(struct fm10k_hw *hw, u32 addr, struct fm10k_hw_stat *stat);


#line 60 
void fm10k_update_hw_stats_q(struct fm10k_hw *hw, struct fm10k_hw_stats_q *q, u32 idx, u32 count);


#line 63 
void fm10k_unbind_hw_stats_q(struct fm10k_hw_stats_q *q, u32 idx, u32 count);


#line 64 
s32 fm10k_get_host_state_generic(struct fm10k_hw *hw, bool *host_ready);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
s32 fm10k_get_bus_info_generic(struct fm10k_hw *hw)
{
  s32 __retres;
  u16 link_cap;
  u16 link_status;
  u16 device_cap;
  u16 device_control;
  
#line 35 
  link_cap = fm10k_read_pci_cfg_word(hw,124U);
  
#line 37 
  switch ((int)link_cap & 1008) {
    case 16: 
#line 38 
    ;
    
#line 39 
    hw->bus_caps.width = fm10k_bus_width_pcie_x1;
    
#line 40 
    goto ldv_44018;
    case 32: 
#line 41 
    ;
    
#line 42 
    hw->bus_caps.width = fm10k_bus_width_pcie_x2;
    
#line 43 
    goto ldv_44018;
    case 64: 
#line 44 
    ;
    
#line 45 
    hw->bus_caps.width = fm10k_bus_width_pcie_x4;
    
#line 46 
    goto ldv_44018;
    case 128: 
#line 47 
    ;
    
#line 48 
    hw->bus_caps.width = fm10k_bus_width_pcie_x8;
    
#line 49 
    goto ldv_44018;
    default: 
#line 50 
    ;
    
#line 51 
    hw->bus_caps.width = fm10k_bus_width_unknown;
    
#line 52 
    goto ldv_44018;
  }
  ldv_44018: 
#line 55 
  ;
  
#line 55 
  switch ((int)link_cap & 15) {
    case 1: 
#line 56 
    ;
    
#line 57 
    hw->bus_caps.speed = fm10k_bus_speed_2500;
    
#line 58 
    goto ldv_44024;
    case 2: 
#line 59 
    ;
    
#line 60 
    hw->bus_caps.speed = fm10k_bus_speed_5000;
    
#line 61 
    goto ldv_44024;
    case 3: 
#line 62 
    ;
    
#line 63 
    hw->bus_caps.speed = fm10k_bus_speed_8000;
    
#line 64 
    goto ldv_44024;
    default: 
#line 65 
    ;
    
#line 66 
    hw->bus_caps.speed = fm10k_bus_speed_unknown;
    
#line 67 
    goto ldv_44024;
  }
  ldv_44024: 
#line 71 
  ;
  
#line 71 
  device_cap = fm10k_read_pci_cfg_word(hw,116U);
  
#line 73 
  switch ((int)device_cap & 7) {
    case 0: 
#line 74 
    ;
    
#line 75 
    hw->bus_caps.payload = fm10k_bus_payload_128;
    
#line 76 
    goto ldv_44029;
    case 1: 
#line 77 
    ;
    
#line 78 
    hw->bus_caps.payload = fm10k_bus_payload_256;
    
#line 79 
    goto ldv_44029;
    case 2: 
#line 80 
    ;
    
#line 81 
    hw->bus_caps.payload = fm10k_bus_payload_512;
    
#line 82 
    goto ldv_44029;
    default: 
#line 83 
    ;
    
#line 84 
    hw->bus_caps.payload = fm10k_bus_payload_unknown;
    
#line 85 
    goto ldv_44029;
  }
  ldv_44029: 
#line 89 
  ;
  
#line 89 
  link_status = fm10k_read_pci_cfg_word(hw,130U);
  
#line 91 
  switch ((int)link_status & 1008) {
    case 16: 
#line 92 
    ;
    
#line 93 
    hw->bus.width = fm10k_bus_width_pcie_x1;
    
#line 94 
    goto ldv_44034;
    case 32: 
#line 95 
    ;
    
#line 96 
    hw->bus.width = fm10k_bus_width_pcie_x2;
    
#line 97 
    goto ldv_44034;
    case 64: 
#line 98 
    ;
    
#line 99 
    hw->bus.width = fm10k_bus_width_pcie_x4;
    
#line 100 
    goto ldv_44034;
    case 128: 
#line 101 
    ;
    
#line 102 
    hw->bus.width = fm10k_bus_width_pcie_x8;
    
#line 103 
    goto ldv_44034;
    default: 
#line 104 
    ;
    
#line 105 
    hw->bus.width = fm10k_bus_width_unknown;
    
#line 106 
    goto ldv_44034;
  }
  ldv_44034: 
#line 109 
  ;
  
#line 109 
  switch ((int)link_status & 15) {
    case 1: 
#line 110 
    ;
    
#line 111 
    hw->bus.speed = fm10k_bus_speed_2500;
    
#line 112 
    goto ldv_44040;
    case 2: 
#line 113 
    ;
    
#line 114 
    hw->bus.speed = fm10k_bus_speed_5000;
    
#line 115 
    goto ldv_44040;
    case 3: 
#line 116 
    ;
    
#line 117 
    hw->bus.speed = fm10k_bus_speed_8000;
    
#line 118 
    goto ldv_44040;
    default: 
#line 119 
    ;
    
#line 120 
    hw->bus.speed = fm10k_bus_speed_unknown;
    
#line 121 
    goto ldv_44040;
  }
  ldv_44040: 
#line 125 
  ;
  
#line 125 
  device_control = fm10k_read_pci_cfg_word(hw,120U);
  
#line 127 
  switch ((int)device_control & 224) {
    case 0: 
#line 128 
    ;
    
#line 129 
    hw->bus.payload = fm10k_bus_payload_128;
    
#line 130 
    goto ldv_44045;
    case 32: 
#line 131 
    ;
    
#line 132 
    hw->bus.payload = fm10k_bus_payload_256;
    
#line 133 
    goto ldv_44045;
    case 64: 
#line 134 
    ;
    
#line 135 
    hw->bus.payload = fm10k_bus_payload_512;
    
#line 136 
    goto ldv_44045;
    default: 
#line 137 
    ;
    
#line 138 
    hw->bus.payload = fm10k_bus_payload_unknown;
    
#line 139 
    goto ldv_44045;
  }
  ldv_44045: 
#line 142 
  ;
  
#line 142 
  __retres = 0;
  
#line 142 
  return __retres;
}


#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
static u16 fm10k_get_pcie_msix_count_generic(struct fm10k_hw *hw)
{
  u16 msix_count;
  
#line 150 
  msix_count = fm10k_read_pci_cfg_word(hw,178U);
  
#line 151 
  msix_count = (unsigned short)((unsigned int)msix_count & 2047U);
  
#line 154 
  msix_count = (u16)((int)msix_count + 1);
  
#line 156 
  if ((unsigned int)msix_count > 256U) 
#line 157 
                                       msix_count = (unsigned short)256U; else ;
  
#line 159 
  return msix_count;
}


#line 168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
s32 fm10k_get_invariants_generic(struct fm10k_hw *hw)
{
  s32 __retres;
  
#line 170 
  struct fm10k_mac_info *mac = & hw->mac;
  
#line 173 
  mac->dglort_map = 65535U;
  
#line 176 
  mac->max_msix_vectors = fm10k_get_pcie_msix_count_generic(hw);
  
#line 178 
  __retres = 0;
  
#line 178 
  return __retres;
}


#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
s32 fm10k_start_hw_generic(struct fm10k_hw *hw)
{
  s32 __retres;
  
#line 191 
  hw->mac.tx_ready = (_Bool)1;
  
#line 193 
  __retres = 0;
  
#line 193 
  return __retres;
}


#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
s32 fm10k_disable_queues_generic(struct fm10k_hw *hw, u16 q_cnt)
{
  s32 __retres;
  u32 reg;
  u16 i;
  u16 time;
  
#line 208 
  hw->mac.tx_ready = (_Bool)0;
  
#line 211 
  i = (unsigned short)0U;
  
#line 211 
  goto ldv_44074;
  ldv_44073: 
#line 212 
  ;
  
#line 212 
  reg = fm10k_read_reg(hw,(int)i * 64 + 32774);
  {
    u32 * volatile *tmp;
    {
      
#line 213 
      u32 *__var = (u32 *)0U;
      
#line 213 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 213 
    u32 *hw_addr = *tmp;
    
#line 213 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 213 
                                            writel(reg & 4294950911U,(void volatile *)(hw_addr + ((unsigned int)((int)i * 64) + 32774U))); else ;
  }
  
#line 215 
  reg = fm10k_read_reg(hw,(int)i * 64 + 16390);
  {
    u32 * volatile *tmp_0;
    {
      
#line 216 
      u32 *__var_0 = (u32 *)0U;
      
#line 216 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 216 
    u32 *hw_addr_0 = *tmp_0;
    
#line 216 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 216 
                                              writel(reg & 4294967294U,(void volatile *)(hw_addr_0 + ((unsigned int)((int)i * 64) + 16390U))); else ;
  }
  
#line 211 
  i = (u16)((int)i + 1);
  ldv_44074: 
#line 212 
  ;
  
#line 211 
  if ((int)i < (int)q_cnt) 
#line 213 
                           goto ldv_44073; else 
#line 216 
                                                goto ldv_44075;
  ldv_44075: 
#line 217 
  ;
  
#line 220 
  fm10k_read_reg(hw,0);
  
#line 221 
  __const_udelay(4295UL);
  
#line 224 
  i = (unsigned short)0U;
  
#line 224 
  time = (unsigned short)100U;
  
#line 224 
  goto ldv_44076;
  ldv_44077: 
#line 225 
  ;
  
#line 226 
  if ((int)i == (int)q_cnt) {
    
#line 227 
    __retres = 0;
    
#line 227 
    goto return_label;
  }
  else ;
  
#line 230 
  reg = fm10k_read_reg(hw,(int)i * 64 + 32774);
  
#line 231 
  if (reg == 4294967295U || (reg & 16384U) == 0U) {
    
#line 232 
    reg = fm10k_read_reg(hw,(int)i * 64 + 16390);
    
#line 233 
    if (reg == 4294967295U || (reg & 1U) == 0U) {
      
#line 234 
      i = (u16)((int)i + 1);
      
#line 235 
      goto ldv_44076;
    }
    else ;
  }
  else ;
  
#line 240 
  time = (u16)((int)time - 1);
  
#line 241 
  if ((unsigned int)time != 0U) 
#line 242 
                                __const_udelay(4295UL); else ;
  ldv_44076: 
#line 244 
  ;
  
#line 224 
  if ((unsigned int)time != 0U) 
#line 226 
                                goto ldv_44077; else 
#line 229 
                                                     goto ldv_44078;
  ldv_44078: 
#line 230 
  ;
  
#line 245 
  __retres = -4;
  return_label: 
#line 245 
                return __retres;
}


#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
s32 fm10k_stop_hw_generic(struct fm10k_hw *hw)
{
  s32 tmp;
  
#line 255 
  tmp = fm10k_disable_queues_generic(hw,(unsigned short)((int)hw->mac.max_queues));
  
#line 255 
  return tmp;
}


#line 266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
u32 fm10k_read_hw_stats_32b(struct fm10k_hw *hw, u32 addr, struct fm10k_hw_stat *stat)
{
  u32 tmp;
  
#line 269 
  tmp = fm10k_read_reg(hw,(int)addr);
  
#line 269 
  u32 delta = tmp - stat->base_l;
  
#line 271 
  if ((long)(hw->hw_addr == (u32 *)0U) != 0L) 
#line 272 
                                              stat->base_h = 0U; else ;
  
#line 274 
  return delta;
}


#line 287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
static u64 fm10k_read_hw_stats_48b(struct fm10k_hw *hw, u32 addr, struct fm10k_hw_stat *stat)
{
  u64 __retres;
  u32 count_l;
  u32 count_h;
  u32 count_tmp;
  u64 delta;
  
#line 295 
  count_h = fm10k_read_reg(hw,(int)(addr + 1U));
  ldv_44097: 
#line 296 
  ;
  
#line 299 
  count_tmp = count_h;
  
#line 300 
  count_l = fm10k_read_reg(hw,(int)addr);
  
#line 301 
  count_h = fm10k_read_reg(hw,(int)(addr + 1U));
  
#line 302 
  if (count_h != count_tmp) 
#line 304 
                            goto ldv_44097; else 
#line 307 
                                                 goto ldv_44098;
  ldv_44098: 
#line 308 
  ;
  
#line 304 
  delta = ((unsigned long long)(count_h - stat->base_h) << 32) + (unsigned long long)count_l;
  
#line 305 
  delta -= (unsigned long long)stat->base_l;
  
#line 307 
  __retres = delta & 281474976710655ULL;
  
#line 307 
  return __retres;
}


#line 318  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
static void fm10k_update_hw_base_48b(struct fm10k_hw_stat *stat, u64 delta)
{
  
#line 320 
  if (delta == 0ULL) 
#line 321 
                     goto return_label; else ;
  
#line 324 
  delta = (unsigned long long)stat->base_l + delta;
  
#line 325 
  stat->base_l = (unsigned int)delta;
  
#line 328 
  stat->base_h += (unsigned int)(delta >> 32);
  return_label: 
#line 329 
                return;
}


#line 340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
static void fm10k_update_hw_stats_tx_q(struct fm10k_hw *hw, struct fm10k_hw_stats_q *q, u32 idx)
{
  u32 id_tx;
  u32 id_tx_prev;
  u32 tx_packets;
  
#line 345 
  u64 tx_bytes = 0ULL;
  
#line 348 
  id_tx = fm10k_read_reg(hw,(int)(idx * 64U + 32775U));
  ldv_44112: 
#line 349 
  ;
  
#line 352 
  tx_packets = fm10k_read_hw_stats_32b(hw,idx * 64U + 32777U,& q->tx_packets);
  
#line 355 
  if (tx_packets != 0U) 
#line 356 
                        tx_bytes = fm10k_read_hw_stats_48b(hw,idx * 64U + 32778U,& q->tx_bytes); else ;
  
#line 361 
  id_tx_prev = id_tx;
  
#line 362 
  id_tx = fm10k_read_reg(hw,(int)(idx * 64U + 32775U));
  
#line 363 
  if (((id_tx ^ id_tx_prev) & 127U) != 0U) 
#line 365 
                                           goto ldv_44112; else 
#line 368 
                                                                goto ldv_44113;
  ldv_44113: 
#line 369 
  ;
  
#line 366 
  id_tx &= 127U;
  
#line 367 
  id_tx |= 2147483648U;
  
#line 370 
  if (q->tx_packets.base_h == id_tx) {
    
#line 371 
    q->tx_packets.count += (unsigned long long)tx_packets;
    
#line 372 
    q->tx_bytes.count += tx_bytes;
  }
  else ;
  
#line 376 
  q->tx_packets.base_l += tx_packets;
  
#line 377 
  fm10k_update_hw_base_48b(& q->tx_bytes,tx_bytes);
  
#line 379 
  q->tx_packets.base_h = id_tx;
  
#line 380 
  return;
}


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
static void fm10k_update_hw_stats_rx_q(struct fm10k_hw *hw, struct fm10k_hw_stats_q *q, u32 idx)
{
  u32 id_rx;
  u32 id_rx_prev;
  u32 rx_packets;
  u32 rx_drops;
  
#line 396 
  u64 rx_bytes = 0ULL;
  
#line 399 
  id_rx = fm10k_read_reg(hw,(int)(idx * 64U + 16390U));
  ldv_44124: 
#line 400 
  ;
  
#line 403 
  rx_drops = fm10k_read_hw_stats_32b(hw,idx * 64U + 16395U,& q->rx_drops);
  
#line 406 
  rx_packets = fm10k_read_hw_stats_32b(hw,idx * 64U + 16394U,& q->rx_packets);
  
#line 409 
  if (rx_packets != 0U) 
#line 410 
                        rx_bytes = fm10k_read_hw_stats_48b(hw,idx * 64U + 16396U,& q->rx_bytes); else ;
  
#line 415 
  id_rx_prev = id_rx;
  
#line 416 
  id_rx = fm10k_read_reg(hw,(int)(idx * 64U + 16390U));
  
#line 417 
  if (((id_rx ^ id_rx_prev) & 508U) != 0U) 
#line 419 
                                           goto ldv_44124; else 
#line 422 
                                                                goto ldv_44125;
  ldv_44125: 
#line 423 
  ;
  
#line 420 
  id_rx &= 508U;
  
#line 421 
  id_rx |= 2147483648U;
  
#line 424 
  if (q->rx_packets.base_h == id_rx) {
    
#line 425 
    q->rx_drops.count += (unsigned long long)rx_drops;
    
#line 426 
    q->rx_packets.count += (unsigned long long)rx_packets;
    
#line 427 
    q->rx_bytes.count += rx_bytes;
  }
  else ;
  
#line 431 
  q->rx_drops.base_l += rx_drops;
  
#line 432 
  q->rx_packets.base_l += rx_packets;
  
#line 433 
  fm10k_update_hw_base_48b(& q->rx_bytes,rx_bytes);
  
#line 435 
  q->rx_packets.base_h = id_rx;
  
#line 436 
  return;
}


#line 448  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
void fm10k_update_hw_stats_q(struct fm10k_hw *hw, struct fm10k_hw_stats_q *q, u32 idx, u32 count)
{
  u32 i;
  
#line 453 
  i = 0U;
  
#line 453 
  goto ldv_44134;
  ldv_44133: 
#line 454 
  ;
  
#line 454 
  fm10k_update_hw_stats_tx_q(hw,q,idx);
  
#line 455 
  fm10k_update_hw_stats_rx_q(hw,q,idx);
  
#line 453 
  i += 1U;
  
#line 453 
  idx += 1U;
  
#line 453 
  q += 1;
  ldv_44134: 
#line 454 
  ;
  
#line 453 
  if (i < count) 
#line 455 
                 goto ldv_44133; else 
#line 458 
                                      goto ldv_44135;
  ldv_44135: 
#line 459 
  ;
  
#line 460 
  return;
}


#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
void fm10k_unbind_hw_stats_q(struct fm10k_hw_stats_q *q, u32 idx, u32 count)
{
  u32 i;
  
#line 473 
  i = 0U;
  
#line 473 
  goto ldv_44143;
  ldv_44142: 
#line 474 
  ;
  
#line 474 
  q->rx_packets.base_h = 0U;
  
#line 475 
  q->tx_packets.base_h = 0U;
  
#line 473 
  i += 1U;
  
#line 473 
  idx += 1U;
  
#line 473 
  q += 1;
  ldv_44143: 
#line 474 
  ;
  
#line 473 
  if (i < count) 
#line 475 
                 goto ldv_44142; else 
#line 478 
                                      goto ldv_44144;
  ldv_44144: 
#line 479 
  ;
  
#line 480 
  return;
}


#line 487  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_common.c"
s32 fm10k_get_host_state_generic(struct fm10k_hw *hw, bool *host_ready)
{
  int tmp_1;
  bool tmp_0;
  
#line 489 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 490 
  struct fm10k_mac_info *mac = & hw->mac;
  
#line 491 
  s32 ret_val = 0;
  
#line 492 
  u32 txdctl = fm10k_read_reg(hw,32774);
  
#line 495 
  (*(mbx->ops.process))(hw,mbx);
  
#line 498 
  if (txdctl == 4294967295U || (txdctl & 16384U) == 0U) 
#line 499 
                                                        mac->get_host_state = (_Bool)1; else ;
  
#line 502 
  if (! mac->get_host_state || txdctl == 4294967295U) 
#line 503 
                                                      goto out; else ;
  
#line 506 
  if ((int)hw->mac.tx_ready != 0 && (txdctl & 16384U) == 0U) {
    
#line 507 
    ret_val = -5;
    
#line 508 
    goto out;
  }
  else ;
  
#line 512 
  if (mbx->timeout == 0U) {
    
#line 513 
    ret_val = -5;
    
#line 514 
    goto out;
  }
  else ;
  
#line 518 
  tmp_0 = (*(mbx->ops.tx_ready))(mbx,(unsigned short)7);
  
#line 518 
  if (tmp_0) 
#line 518 
             tmp_1 = 0; else 
#line 518 
                             tmp_1 = 1;
  
#line 518 
  if (tmp_1) 
#line 519 
             goto out; else ;
  
#line 522 
  if (mac->dglort_map == 65535U) 
#line 523 
                                 goto out; else ;
  
#line 528 
  mac->get_host_state = (_Bool)0;
  out: 
#line 530 
  ;
  
#line 531 
  *host_ready = (_Bool)(! ((int)mac->get_host_state != 0));
  
#line 532 
  return ret_val;
}


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_stop_hw_vf(struct fm10k_hw *hw)
{
  s32 __retres;
  s32 err;
  u16 i;
  bool tmp;
  
#line 30 
  u8 *perm_addr = (u8 *)(& hw->mac.perm_addr);
  
#line 31 
  u32 bal = 0U;
  
#line 31 
  u32 bah = 0U;
  
#line 36 
  err = fm10k_stop_hw_generic(hw);
  
#line 37 
  if (err != 0) {
    
#line 38 
    __retres = err;
    
#line 38 
    goto return_label;
  }
  else ;
  
#line 41 
  tmp = is_valid_ether_addr((u8 const *)perm_addr);
  
#line 41 
  if ((int)tmp != 0) {
    
#line 42 
    bal = (((unsigned int)*(perm_addr + 3U) << 24) | ((unsigned int)*(perm_addr + 4U) << 16)) | ((unsigned int)*(perm_addr + 5U) << 8);
    
#line 45 
    bah = ((((unsigned int)*perm_addr << 16) | ((unsigned int)*(perm_addr + 1U) << 8)) | (unsigned int)*(perm_addr + 2U)) | 4278190080U;
  }
  else ;
  
#line 54 
  i = (unsigned short)0U;
  
#line 54 
  goto ldv_44065;
  ldv_44064: 
#line 55 
  ;
  {
    u32 * volatile *tmp_0;
    {
      
#line 55 
      u32 *__var = (u32 *)0U;
      
#line 55 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 55 
    u32 *hw_addr = *tmp_0;
    
#line 55 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 55 
                                            writel(bal,(void volatile *)(hw_addr + ((unsigned int)((int)i * 64) + 32768U))); else ;
  }
  {
    u32 * volatile *tmp_1;
    {
      
#line 56 
      u32 *__var_0 = (u32 *)0U;
      
#line 56 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 56 
    u32 *hw_addr_0 = *tmp_1;
    
#line 56 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 56 
                                              writel(bah,(void volatile *)(hw_addr_0 + ((unsigned int)((int)i * 64) + 32769U))); else ;
  }
  {
    u32 * volatile *tmp_2;
    {
      
#line 57 
      u32 *__var_1 = (u32 *)0U;
      
#line 57 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 57 
    u32 *hw_addr_1 = *tmp_2;
    
#line 57 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 57 
                                              writel(bal,(void volatile *)(hw_addr_1 + ((unsigned int)((int)i * 64) + 16384U))); else ;
  }
  {
    u32 * volatile *tmp_3;
    {
      
#line 58 
      u32 *__var_2 = (u32 *)0U;
      
#line 58 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 58 
    u32 *hw_addr_2 = *tmp_3;
    
#line 58 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 58 
                                              writel(bah,(void volatile *)(hw_addr_2 + ((unsigned int)((int)i * 64) + 16385U))); else ;
  }
  
#line 54 
  i = (u16)((int)i + 1);
  ldv_44065: 
#line 55 
  ;
  
#line 54 
  if ((int)hw->mac.max_queues > (int)i) 
#line 56 
                                        goto ldv_44064; else 
#line 59 
                                                             goto ldv_44066;
  ldv_44066: 
#line 60 
  ;
  
#line 61 
  __retres = 0;
  return_label: 
#line 61 
                return __retres;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_reset_hw_vf(struct fm10k_hw *hw)
{
  s32 __retres;
  s32 err;
  u32 tmp_1;
  
#line 76 
  err = fm10k_stop_hw_vf(hw);
  
#line 77 
  if (err != 0) {
    
#line 78 
    __retres = err;
    
#line 78 
    goto return_label;
  }
  else ;
  {
    u32 * volatile *tmp;
    {
      
#line 81 
      u32 *__var = (u32 *)0U;
      
#line 81 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 81 
    u32 *hw_addr = *tmp;
    
#line 81 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 81 
                                            writel(8U,(void volatile *)hw_addr); else ;
  }
  
#line 84 
  fm10k_read_reg(hw,0);
  
#line 85 
  __const_udelay(644250UL);
  {
    u32 * volatile *tmp_0;
    {
      
#line 88 
      u32 *__var_0 = (u32 *)0U;
      
#line 88 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 88 
    u32 *hw_addr_0 = *tmp_0;
    
#line 88 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 88 
                                              writel(0U,(void volatile *)hw_addr_0); else ;
  }
  
#line 89 
  tmp_1 = fm10k_read_reg(hw,0);
  
#line 89 
  if ((tmp_1 & 8U) != 0U) 
#line 90 
                          err = -7; else ;
  
#line 92 
  __retres = err;
  return_label: 
#line 92 
                return __retres;
}


#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_init_hw_vf(struct fm10k_hw *hw)
{
  s32 __retres;
  u32 tqdloc;
  u32 tmp;
  s32 err;
  u16 i;
  u32 tmp_0;
  u32 tmp_1;
  u32 tmp_3;
  
#line 102 
  tmp = fm10k_read_reg(hw,32780);
  
#line 102 
  u32 tqdloc0 = ~ tmp;
  
#line 107 
  i = (unsigned short)1U;
  
#line 107 
  goto ldv_44086;
  ldv_44085: 
#line 108 
  ;
  
#line 109 
  tmp_0 = fm10k_read_reg(hw,(int)i * 64 + 32780);
  
#line 109 
  tqdloc = ~ tmp_0;
  
#line 110 
  if (tqdloc == 0U || tqdloc == tqdloc0) 
#line 111 
                                         goto ldv_44084; else ;
  
#line 114 
  tmp_1 = fm10k_read_reg(hw,(int)i * 64 + 32775);
  
#line 114 
  if (tmp_1 == 4294967295U) 
#line 116 
                            goto ldv_44084;
  else {
    u32 tmp_2;
    
#line 114 
    tmp_2 = fm10k_read_reg(hw,(int)i * 64 + 16390);
    
#line 114 
    if (tmp_2 == 4294967295U) 
#line 116 
                              goto ldv_44084; else ;
  }
  
#line 107 
  i = (u16)((int)i + 1);
  ldv_44086: 
#line 108 
  ;
  
#line 107 
  if (tqdloc0 != 0U && (unsigned int)i <= 15U) 
#line 109 
                                               goto ldv_44085; else 
#line 112 
                                                                    goto ldv_44084;
  ldv_44084: 
#line 113 
  ;
  
#line 120 
  err = fm10k_disable_queues_generic(hw,(unsigned short)((int)i));
  
#line 121 
  if (err != 0) {
    
#line 122 
    __retres = err;
    
#line 122 
    goto return_label;
  }
  else ;
  
#line 125 
  hw->mac.max_queues = i;
  
#line 128 
  tmp_3 = fm10k_read_reg(hw,32775);
  
#line 128 
  hw->mac.default_vid = (unsigned short)((unsigned int)((unsigned short)(tmp_3 >> 16)) & 4095U);
  
#line 131 
  __retres = 0;
  return_label: 
#line 131 
                return __retres;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static bool fm10k_is_slot_appropriate_vf(struct fm10k_hw *hw)
{
  bool __retres;
  
#line 144 
  __retres = (_Bool)1;
  
#line 144 
  return __retres;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
struct fm10k_tlv_attr const fm10k_mac_vlan_msg_attr[6U] = {{.id = 0U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)4U}, {.id = 1U, .type = FM10K_TLV_BOOL, .len = (unsigned short)0U}, {.id = 2U, .type = FM10K_TLV_MAC_ADDR, .len = (unsigned short)6U}, {.id = 3U, .type = FM10K_TLV_MAC_ADDR, .len = (unsigned short)6U}, {.id = 4U, .type = FM10K_TLV_MAC_ADDR, .len = (unsigned short)6U}, {.id = 4294967295U, .type = 0, .len = (unsigned short)0}};

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_update_vlan_vf(struct fm10k_hw *hw, u32 vid, u8 vsi, bool set)
{
  s32 __retres;
  u32 msg[4U];
  s32 tmp;
  
#line 169 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 173 
  if ((unsigned int)vsi != 0U) {
    
#line 174 
    __retres = -2;
    
#line 174 
    goto return_label;
  }
  else ;
  
#line 177 
  if (((vid << 16) | vid) >> 28 != 0U) {
    
#line 178 
    __retres = -2;
    
#line 178 
    goto return_label;
  }
  else ;
  
#line 181 
  if (! set) 
#line 182 
             vid |= 32768U; else ;
  
#line 185 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)2);
  
#line 186 
  fm10k_tlv_attr_put_value((u32 *)(& msg),(unsigned short)0,(long long)vid,4U);
  
#line 189 
  tmp = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 189 
  __retres = tmp;
  return_label: 
#line 189 
                return __retres;
}


#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
s32 fm10k_msg_mac_vlan_vf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u8 perm_addr[6U];
  u16 vid;
  s32 err;
  
#line 208 
  err = fm10k_tlv_attr_get_mac_vlan(*(results + 3U),(u8 *)(& perm_addr),& vid);
  
#line 211 
  if (err != 0) {
    
#line 212 
    __retres = err;
    
#line 212 
    goto return_label;
  }
  else ;
  
#line 214 
  ether_addr_copy((u8 *)(& hw->mac.perm_addr),(u8 const *)(& perm_addr));
  
#line 215 
  hw->mac.default_vid = (unsigned short)((unsigned int)vid & 4095U);
  
#line 216 
  hw->mac.vlan_override = (_Bool)((int)vid < 0);
  
#line 218 
  __retres = 0;
  return_label: 
#line 218 
                return __retres;
}


#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_read_mac_addr_vf(struct fm10k_hw *hw)
{
  s32 __retres;
  u8 perm_addr[6U];
  u32 base_addr;
  
#line 232 
  base_addr = fm10k_read_reg(hw,32768);
  
#line 235 
  if (base_addr << 24 != 0U) {
    
#line 236 
    __retres = -8;
    
#line 236 
    goto return_label;
  }
  else ;
  
#line 238 
  perm_addr[3] = (unsigned char)(base_addr >> 24);
  
#line 239 
  perm_addr[4] = (unsigned char)(base_addr >> 16);
  
#line 240 
  perm_addr[5] = (unsigned char)(base_addr >> 8);
  
#line 242 
  base_addr = fm10k_read_reg(hw,32769);
  
#line 245 
  if (~ base_addr >> 24 != 0U) {
    
#line 246 
    __retres = -8;
    
#line 246 
    goto return_label;
  }
  else ;
  
#line 248 
  perm_addr[0] = (unsigned char)(base_addr >> 16);
  
#line 249 
  perm_addr[1] = (unsigned char)(base_addr >> 8);
  
#line 250 
  perm_addr[2] = (unsigned char)base_addr;
  
#line 252 
  ether_addr_copy((u8 *)(& hw->mac.perm_addr),(u8 const *)(& perm_addr));
  
#line 253 
  ether_addr_copy((u8 *)(& hw->mac.addr),(u8 const *)(& perm_addr));
  
#line 255 
  __retres = 0;
  return_label: 
#line 255 
                return __retres;
}


#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_update_uc_addr_vf(struct fm10k_hw *hw, u16 glort, u8 const *mac, u16 vid, bool add, u8 flags)
{
  s32 __retres;
  u32 msg[7U];
  int tmp_0;
  bool tmp;
  bool tmp_1;
  s32 tmp_3;
  
#line 273 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 277 
  if ((unsigned int)vid > 4095U) {
    
#line 278 
    __retres = -2;
    
#line 278 
    goto return_label;
  }
  else ;
  
#line 281 
  tmp = is_valid_ether_addr(mac);
  
#line 281 
  if (tmp) 
#line 281 
           tmp_0 = 0; else 
#line 281 
                           tmp_0 = 1;
  
#line 281 
  if (tmp_0) {
    
#line 282 
    __retres = -2;
    
#line 282 
    goto return_label;
  }
  else ;
  
#line 285 
  tmp_1 = is_valid_ether_addr((u8 const *)(& hw->mac.perm_addr));
  
#line 285 
  if ((int)tmp_1 != 0) {
    int tmp_2;
    
#line 285 
    tmp_2 = memcmp((void const *)(& hw->mac.perm_addr),(void const *)mac,6UL);
    
#line 285 
    if (tmp_2 != 0) {
      
#line 287 
      __retres = -2;
      
#line 287 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 290 
  if (! add) 
#line 291 
             vid = (unsigned short)((unsigned int)vid | 32768U); else ;
  
#line 294 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)2);
  
#line 295 
  fm10k_tlv_attr_put_mac_vlan((u32 *)(& msg),(unsigned short)2,mac,(unsigned short)((int)vid));
  
#line 298 
  tmp_3 = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 298 
  __retres = tmp_3;
  return_label: 
#line 298 
                return __retres;
}


#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_update_mc_addr_vf(struct fm10k_hw *hw, u16 glort, u8 const *mac, u16 vid, bool add)
{
  s32 __retres;
  u32 msg[7U];
  int tmp_0;
  bool tmp;
  s32 tmp_1;
  
#line 315 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 319 
  if ((unsigned int)vid > 4095U) {
    
#line 320 
    __retres = -2;
    
#line 320 
    goto return_label;
  }
  else ;
  
#line 323 
  tmp = is_multicast_ether_addr(mac);
  
#line 323 
  if (tmp) 
#line 323 
           tmp_0 = 0; else 
#line 323 
                           tmp_0 = 1;
  
#line 323 
  if (tmp_0) {
    
#line 324 
    __retres = -2;
    
#line 324 
    goto return_label;
  }
  else ;
  
#line 327 
  if (! add) 
#line 328 
             vid = (unsigned short)((unsigned int)vid | 32768U); else ;
  
#line 331 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)2);
  
#line 332 
  fm10k_tlv_attr_put_mac_vlan((u32 *)(& msg),(unsigned short)4,mac,(unsigned short)((int)vid));
  
#line 336 
  tmp_1 = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 336 
  __retres = tmp_1;
  return_label: 
#line 336 
                return __retres;
}


#line 346  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static void fm10k_update_int_moderator_vf(struct fm10k_hw *hw)
{
  u32 msg[1U];
  
#line 348 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 352 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)1);
  
#line 355 
  (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 356 
  return;
}


#line 359  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
struct fm10k_tlv_attr const fm10k_lport_state_msg_attr[4U] = {{.id = 0U, .type = FM10K_TLV_BOOL, .len = (unsigned short)0U}, {.id = 1U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)1U}, {.id = 2U, .type = FM10K_TLV_BOOL, .len = (unsigned short)0U}, {.id = 4294967295U, .type = 0, .len = (unsigned short)0}};

#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
s32 fm10k_msg_lport_state_vf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  
#line 378 
  if (*(results + 2U) == (u32 *)0U) 
#line 378 
                                    hw->mac.dglort_map = 65535U; else 
                                                                   
#line 378 
                                                                   hw->mac.dglort_map = 4294901760U;
  
#line 381 
  __retres = 0;
  
#line 381 
  return __retres;
}


#line 395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_update_lport_state_vf(struct fm10k_hw *hw, u16 glort, u16 count, bool enable)
{
  u32 msg[2U];
  s32 tmp;
  
#line 398 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 402 
  hw->mac.dglort_map = 65535U;
  
#line 405 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)3);
  
#line 406 
  if (! enable) 
#line 407 
                fm10k_tlv_attr_put_bool((u32 *)(& msg),(unsigned short)0); else ;
  
#line 410 
  tmp = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 410 
  return tmp;
}


#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_update_xcast_mode_vf(struct fm10k_hw *hw, u16 glort, u8 mode)
{
  s32 __retres;
  u32 msg[3U];
  s32 tmp;
  
#line 425 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 428 
  if ((unsigned int)mode > 3U) {
    
#line 429 
    __retres = -2;
    
#line 429 
    goto return_label;
  }
  else ;
  
#line 431 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)3);
  
#line 432 
  fm10k_tlv_attr_put_value((u32 *)(& msg),(unsigned short)1,(long long)mode,1U);
  
#line 435 
  tmp = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 435 
  __retres = tmp;
  return_label: 
#line 435 
                return __retres;
}


#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
struct fm10k_tlv_attr const fm10k_1588_msg_attr[2U] = {{.id = 0U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)8U}, {.id = 4294967295U, .type = 0, .len = (unsigned short)0}};

#line 452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static void fm10k_update_hw_stats_vf(struct fm10k_hw *hw, struct fm10k_hw_stats *stats)
{
  
#line 455 
  fm10k_update_hw_stats_q(hw,(struct fm10k_hw_stats_q *)(& stats->q),0U,(unsigned int)hw->mac.max_queues);
  
#line 456 
  return;
}


#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static void fm10k_rebind_hw_stats_vf(struct fm10k_hw *hw, struct fm10k_hw_stats *stats)
{
  
#line 469 
  fm10k_unbind_hw_stats_q((struct fm10k_hw_stats_q *)(& stats->q),0U,(unsigned int)hw->mac.max_queues);
  
#line 472 
  fm10k_update_hw_stats_vf(hw,stats);
  
#line 473 
  return;
}


#line 484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_configure_dglort_map_vf(struct fm10k_hw *hw, struct fm10k_dglort_cfg *dglort)
{
  s32 __retres;
  
#line 488 
  if (dglort == (struct fm10k_dglort_cfg *)0) {
    
#line 489 
    __retres = -2;
    
#line 489 
    goto return_label;
  }
  else ;
  
#line 493 
  __retres = 0;
  return_label: 
#line 493 
                return __retres;
}


#line 507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_adjust_systime_vf(struct fm10k_hw *hw, s32 ppb)
{
  int tmp;
  
#line 514 
  if (ppb != 0) 
#line 514 
                tmp = -2; else 
#line 514 
                               tmp = 0;
  
#line 514 
  return tmp;
}


#line 527  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static u64 fm10k_read_systime_vf(struct fm10k_hw *hw)
{
  u64 __retres;
  u32 systime_l;
  u32 systime_h;
  u32 systime_tmp;
  
#line 531 
  systime_h = fm10k_read_reg(hw,65);
  ldv_44180: 
#line 532 
  ;
  
#line 534 
  systime_tmp = systime_h;
  
#line 535 
  systime_l = fm10k_read_reg(hw,64);
  
#line 536 
  systime_h = fm10k_read_reg(hw,65);
  
#line 537 
  if (systime_tmp != systime_h) 
#line 539 
                                goto ldv_44180; else 
#line 542 
                                                     goto ldv_44181;
  ldv_44181: 
#line 543 
  ;
  
#line 539 
  __retres = ((unsigned long long)systime_h << 32) | (unsigned long long)systime_l;
  
#line 539 
  return __retres;
}


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static struct fm10k_msg_data const fm10k_msg_data_vf[4U] = {{.id = 0U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_tlv_msg_test_attr), .func = & fm10k_tlv_msg_test}, {.id = 2U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_mac_vlan_msg_attr), .func = & fm10k_msg_mac_vlan_vf}, {.id = 3U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_lport_state_msg_attr), .func = & fm10k_msg_lport_state_vf}, {.id = 4294967295U, .attr = (struct fm10k_tlv_attr const *)0, .func = & fm10k_tlv_msg_error}};

#line 549  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static struct fm10k_mac_ops mac_ops_vf = {.reset_hw = & fm10k_reset_hw_vf, .init_hw = & fm10k_init_hw_vf, .start_hw = & fm10k_start_hw_generic, .stop_hw = & fm10k_stop_hw_vf, .get_bus_info = & fm10k_get_bus_info_generic, .get_host_state = & fm10k_get_host_state_generic, .is_slot_appropriate = & fm10k_is_slot_appropriate_vf, .update_vlan = & fm10k_update_vlan_vf, .read_mac_addr = & fm10k_read_mac_addr_vf, .update_uc_addr = & fm10k_update_uc_addr_vf, .update_mc_addr = & fm10k_update_mc_addr_vf, .update_xcast_mode = & fm10k_update_xcast_mode_vf, .update_int_moderator = & fm10k_update_int_moderator_vf, .update_lport_state = & fm10k_update_lport_state_vf, .update_hw_stats = & fm10k_update_hw_stats_vf, .rebind_hw_stats = & fm10k_rebind_hw_stats_vf, .configure_dglort_map = & fm10k_configure_dglort_map_vf, .set_dma_mask = (void (*)(struct fm10k_hw *, u64 ))0, .get_fault = (s32 (*)(struct fm10k_hw *, int , struct fm10k_fault *))0, .request_lport_map = (void (*)(struct fm10k_hw *))0, .adjust_systime = & fm10k_adjust_systime_vf, .read_systime = & fm10k_read_systime_vf};

#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
static s32 fm10k_get_invariants_vf(struct fm10k_hw *hw)
{
  s32 tmp;
  
#line 573 
  fm10k_get_invariants_generic(hw);
  
#line 575 
  tmp = fm10k_pfvf_mbx_init(hw,& hw->mbx,(struct fm10k_msg_data const *)(& fm10k_msg_data_vf),(unsigned char)0);
  
#line 575 
  return tmp;
}


#line 578  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_vf.c"
struct fm10k_info fm10k_vf_info = {.mac = fm10k_mac_vf, .get_invariants = & fm10k_get_invariants_vf, .mac_ops = & mac_ops_vf, .iov_ops = (struct fm10k_iov_ops *)0};
void *__builtin_memcpy(void *, void const *, unsigned long);

void __builtin_prefetch(void const * , ...);


#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compiler.h"
__inline static void __read_once_size(void const volatile *p, void *res, int size)
{
  
#line 203 
  switch (size) {
    case 1: 
#line 204 
    ;
    
#line 204 
    *((__u8 *)res) = *((__u8 volatile *)p);
    
#line 204 
    goto ldv_1185;
    case 2: 
#line 205 
    ;
    
#line 205 
    *((__u16 *)res) = *((__u16 volatile *)p);
    
#line 205 
    goto ldv_1185;
    case 4: 
#line 206 
    ;
    
#line 206 
    *((__u32 *)res) = *((__u32 volatile *)p);
    
#line 206 
    goto ldv_1185;
    case 8: 
#line 207 
    ;
    
#line 207 
    *((__u64 *)res) = *((__u64 volatile *)p);
    
#line 207 
    goto ldv_1185;
    default: 
#line 208 
    ;
    
#line 209 
    ldv_inline_asm();
    
#line 210 
    __builtin_memcpy(res,(void const *)p,(unsigned long)size);
    
#line 211 
    ldv_inline_asm();
  }
  ldv_1185: 
#line 213 
  ;
  
#line 214 
  return;
}


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_main.c.aux"
void ldv_atomic_inc(atomic_t *v);


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 697  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
__inline static void prefetchw(void const *x)
{
  
#line 699 
  ldv_inline_asm();
  
#line 700 
  return;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc(atomic_t *v);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 464  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
int rcu_read_lock_bh_held(void);


#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct workqueue_struct *__alloc_workqueue_key(char const *, unsigned int, int, struct lock_class_key *, char const * , ...);


#line 421 
void destroy_workqueue(struct workqueue_struct *);


#line 436 
void flush_workqueue(struct workqueue_struct *);


#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/memory_hotplug.h"
extern pg_data_t *node_data[];


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/topology.h"
__inline static int numa_node_id(void)
{
  int tmp_3;
  {
    int pscr_ret__;
    {
      
#line 77 
      void const *__vpp_verify = (void const *)0;
      
#line 77 
      void const *tmp = __vpp_verify;
    }
    
#line 77 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 77 
      ;
      {
        int pfo_ret__;
        
#line 77 
        switch (4UL) {
          case (unsigned long)1: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14250;
          case (unsigned long)2: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14250;
          case (unsigned long)4: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14250;
          case (unsigned long)8: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14250;
          default: 
#line 77 
          ;
          
#line 77 
          __bad_percpu_size();
        }
        ldv_14250: 
#line 77 
        ;
        
#line 77 
        tmp_0 = pfo_ret__;
      }
      
#line 77 
      pscr_ret__ = tmp_0;
      
#line 77 
      goto ldv_14256;
      case (unsigned long)2: 
#line 77 
      ;
      {
        int pfo_ret___0;
        
#line 77 
        switch (4UL) {
          case (unsigned long)1: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14260;
          case (unsigned long)2: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14260;
          case (unsigned long)4: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14260;
          case (unsigned long)8: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14260;
          default: 
#line 77 
          ;
          
#line 77 
          __bad_percpu_size();
        }
        ldv_14260: 
#line 77 
        ;
        
#line 77 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 77 
      pscr_ret__ = tmp_0_0;
      
#line 77 
      goto ldv_14256;
      case (unsigned long)4: 
#line 77 
      ;
      {
        int pfo_ret___1;
        
#line 77 
        switch (4UL) {
          case (unsigned long)1: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14269;
          case (unsigned long)2: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14269;
          case (unsigned long)4: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14269;
          case (unsigned long)8: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14269;
          default: 
#line 77 
          ;
          
#line 77 
          __bad_percpu_size();
        }
        ldv_14269: 
#line 77 
        ;
        
#line 77 
        tmp_1 = pfo_ret___1;
      }
      
#line 77 
      pscr_ret__ = tmp_1;
      
#line 77 
      goto ldv_14256;
      case (unsigned long)8: 
#line 77 
      ;
      {
        int pfo_ret___2;
        
#line 77 
        switch (4UL) {
          case (unsigned long)1: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14278;
          case (unsigned long)2: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14278;
          case (unsigned long)4: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14278;
          case (unsigned long)8: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_14278;
          default: 
#line 77 
          ;
          
#line 77 
          __bad_percpu_size();
        }
        ldv_14278: 
#line 77 
        ;
        
#line 77 
        tmp_2 = pfo_ret___2;
      }
      
#line 77 
      pscr_ret__ = tmp_2;
      
#line 77 
      goto ldv_14256;
      default: 
#line 77 
      ;
      
#line 77 
      __bad_size_call_parameter();
      
#line 77 
      goto ldv_14256;
    }
    ldv_14256: 
#line 77 
    ;
    
#line 77 
    tmp_3 = pscr_ret__;
  }
  
#line 77 
  return tmp_3;
}


#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/topology.h"
__inline static int numa_mem_id(void)
{
  int tmp;
  
#line 168 
  tmp = numa_node_id();
  
#line 168 
  return tmp;
}


#line 263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags)
{
  int __retres;
  
#line 265 
  if ((long)((flags & 262144U) != 0U) != 0L) {
    
#line 266 
    __retres = 1;
    
#line 266 
    goto return_label;
  }
  else ;
  
#line 268 
  __retres = 0;
  return_label: 
#line 268 
                return __retres;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid, gfp_t flags)
{
  struct zonelist *__retres;
  int tmp;
  
#line 282 
  tmp = gfp_zonelist(flags);
  
#line 282 
  ;
  
#line 282 
  __retres = (struct zonelist *)(& (node_data[nid])->node_zonelists) + tmp;
  
#line 282 
  return __retres;
}


#line 293 
struct page *__alloc_pages_nodemask(gfp_t, unsigned int, struct zonelist *, nodemask_t *);


#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist)
{
  struct page *tmp;
  
#line 300 
  tmp = __alloc_pages_nodemask(gfp_mask,order,zonelist,(nodemask_t *)0);
  
#line 300 
  return tmp;
}


#line 303  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
{
  struct page *tmp_0;
  struct zonelist *tmp;
  
#line 307 
  if (nid < 0) 
#line 308 
               nid = numa_node_id(); else ;
  
#line 310 
  tmp = node_zonelist(nid,gfp_mask);
  
#line 310 
  ;
  
#line 310 
  ;
  
#line 310 
  tmp_0 = __alloc_pages(gfp_mask,order,tmp);
  
#line 310 
  return tmp_0;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
int net_ratelimit(void);


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_1(size_t size, gfp_t flags);


#line 400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page-flags.h"
__inline static int PageTail(struct page const *page)
{
  int tmp;
  
#line 400 
  tmp = constant_test_bit(15L,(unsigned long const volatile *)(& page->flags));
  
#line 400 
  return tmp;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static struct page *compound_head_by_tail(struct page *tail)
{
  struct page *__retres;
  int tmp;
  
#line 442 
  struct page *head = tail->__anonCompField_page_36.first_page;
  
#line 443 
  ldv_inline_asm();
  
#line 450 
  tmp = PageTail((struct page const *)tail);
  
#line 450 
  if ((long)(tmp != 0) != 0L) {
    
#line 451 
    __retres = head;
    
#line 451 
    goto return_label;
  }
  else ;
  
#line 452 
  __retres = tail;
  return_label: 
#line 452 
                return __retres;
}


#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static struct page *compound_head(struct page *page)
{
  struct page *__retres;
  int tmp_0;
  
#line 463 
  tmp_0 = PageTail((struct page const *)page);
  
#line 463 
  if ((long)(tmp_0 != 0) != 0L) {
    struct page *tmp;
    
#line 464 
    tmp = compound_head_by_tail(page);
    
#line 464 
    __retres = tmp;
    
#line 464 
    goto return_label;
  }
  else ;
  
#line 465 
  __retres = page;
  return_label: 
#line 465 
                return __retres;
}


#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static int page_count(struct page *page)
{
  int tmp_0;
  struct page *tmp;
  
#line 498 
  tmp = compound_head(page);
  
#line 498 
  tmp_0 = atomic_read((atomic_t const *)(& tmp->__anonCompField_page_32.__anonCompField___anonstruct_57_31.__anonCompField___anonunion_59_30._count));
  
#line 498 
  return tmp_0;
}


#line 760  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static int page_to_nid(struct page const *page)
{
  int __retres;
  
#line 762 
  __retres = (int)(page->flags >> 54UL);
  
#line 762 
  return __retres;
}


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page const *page)
{
  void *__retres;
  
#line 947 
  __retres = (void *)((unsigned long)((unsigned long long)(((long)page + 24189255811072L) / 64L) << 12) + 18446612132314218496UL);
  
#line 947 
  return __retres;
}


#line 1031  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static bool page_is_pfmemalloc(struct page *page)
{
  bool __retres;
  
#line 1037 
  __retres = (_Bool)(page->__anonCompField_page_32.__anonCompField___anonstruct_57_27.index == 18446744073709551615UL);
  
#line 1037 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 67 
void debug_dma_sync_single_range_for_cpu(struct device *, dma_addr_t, unsigned long, size_t, int);


#line 73 
void debug_dma_sync_single_range_for_device(struct device *, dma_addr_t, unsigned long, size_t, int);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t addr;
  void *tmp_0;
  int tmp_1;
  
#line 80 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 83 
  ;
  
#line 83 
  tmp_0 = lowmem_page_address((struct page const *)page);
  
#line 83 
  ;
  
#line 83 
  kmemcheck_mark_initialized(tmp_0 + offset,(unsigned int)size);
  
#line 84 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 84 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 86 
    ldv_inline_asm();
    
#line 84 
    ;
  }
  else ;
  
#line 85 
  addr = (*(ops->map_page))(dev,page,offset,size,dir,(struct dma_attrs *)0);
  
#line 86 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr,(_Bool)0);
  
#line 88 
  return addr;
}


#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t addr, unsigned long offset, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 132 
  struct dma_map_ops const *ops = get_dma_ops(dev);
  
#line 134 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 134 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 136 
    ldv_inline_asm();
    
#line 134 
    ;
  }
  else ;
  
#line 135 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 136 
    (*(ops->sync_single_for_cpu))(dev,addr + (unsigned long long)offset,size,dir); else ;
  
#line 137 
  debug_dma_sync_single_range_for_cpu(dev,addr,offset,size,(int)dir);
  
#line 138 
  return;
}


#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_device(struct device *dev, dma_addr_t addr, unsigned long offset, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 146 
  struct dma_map_ops const *ops = get_dma_ops(dev);
  
#line 148 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 148 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 150 
    ldv_inline_asm();
    
#line 148 
    ;
  }
  else ;
  
#line 149 
  if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 150 
    (*(ops->sync_single_for_device))(dev,addr + (unsigned long long)offset,size,dir); else ;
  
#line 151 
  debug_dma_sync_single_range_for_device(dev,addr,offset,size,(int)dir);
  
#line 152 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const *frag)
{
  unsigned int __retres;
  
#line 232 
  __retres = frag->size;
  
#line 232 
  return __retres;
}


#line 926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
{
  
#line 928 
  skb->l4_hash = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))(type == (unsigned int)PKT_HASH_TYPE_L4);
  
#line 929 
  skb->sw_hash = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 930 
  skb->hash = hash;
  
#line 931 
  return;
}


#line 1000  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
  struct skb_shared_hwtstamps *__retres;
  unsigned char *tmp;
  
#line 1002 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1002 
  __retres = & ((struct skb_shared_info *)tmp)->hwtstamps;
  
#line 1002 
  return __retres;
}


#line 1639 
void skb_add_rx_frag(struct sk_buff *, int, struct page *, int, int, unsigned int);


#line 1824  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_inner_transport_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1827 
  __retres = skb->head + (int)skb->inner_transport_header;
  
#line 1827 
  return __retres;
}


#line 1842  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_inner_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1844 
  __retres = skb->head + (int)skb->inner_network_header;
  
#line 1844 
  return __retres;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1882 
  __retres = skb->head + (int)skb->transport_header;
  
#line 1882 
  return __retres;
}


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1899 
  __retres = skb->head + (int)skb->network_header;
  
#line 1899 
  return __retres;
}


#line 1913  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1915 
  __retres = skb->head + (int)skb->mac_header;
  
#line 1915 
  return __retres;
}


#line 2198 
struct sk_buff *__napi_alloc_skb(struct napi_struct *, unsigned int, gfp_t);


#line 2200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *napi_alloc_skb(struct napi_struct *napi, unsigned int length)
{
  struct sk_buff *tmp;
  
#line 2203 
  tmp = __napi_alloc_skb(napi,length,32U);
  
#line 2203 
  return tmp;
}


#line 2215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *__dev_alloc_pages(gfp_t gfp_mask, unsigned int order)
{
  struct page *tmp;
  
#line 2226 
  gfp_mask |= 24832U;
  
#line 2228 
  tmp = alloc_pages_node(-1,gfp_mask,order);
  
#line 2228 
  return tmp;
}


#line 2244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *__dev_alloc_page(gfp_t gfp_mask)
{
  struct page *tmp;
  
#line 2246 
  tmp = __dev_alloc_pages(gfp_mask,0U);
  
#line 2246 
  return tmp;
}


#line 2249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *dev_alloc_page(void)
{
  struct page *tmp;
  
#line 2251 
  tmp = __dev_alloc_page(32U);
  
#line 2251 
  return tmp;
}


#line 2272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const *frag)
{
  struct page *__retres;
  
#line 2274 
  __retres = frag->page.p;
  
#line 2274 
  return __retres;
}


#line 2390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev, skb_frag_t const *frag, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t tmp_0;
  struct page *tmp;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  tmp = skb_frag_page(frag);
  
#line 2395 
  ;
  
#line 2395 
  tmp_0 = dma_map_page(dev,tmp,(unsigned long)frag->page_offset + offset,size,dir);
  
#line 2395 
  return tmp_0;
}


#line 2501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  
#line 2503 
  unsigned int size = skb->len;
  
#line 2505 
  if ((long)(size < len) != 0L) {
    int tmp;
    
#line 2506 
    len -= size;
    
#line 2507 
    tmp = skb_pad(skb,(int)len);
    
#line 2507 
    if (tmp != 0) {
      
#line 2508 
      __retres = -12;
      
#line 2508 
      goto return_label;
    }
    else ;
    
#line 2509 
    __skb_put(skb,len);
  }
  else ;
  
#line 2511 
  __retres = 0;
  return_label: 
#line 2511 
                return __retres;
}


#line 2865 
void skb_clone_tx_timestamp(struct sk_buff *);


#line 2911 
void skb_tstamp_tx(struct sk_buff *, struct skb_shared_hwtstamps *);


#line 2914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void sw_tx_timestamp(struct sk_buff *skb)
{
  unsigned char *tmp;
  
#line 2916 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2916 
  ;
  
#line 2916 
  if (((int)((struct skb_shared_info *)tmp)->tx_flags & 2) != 0) {
    unsigned char *tmp_0;
    
#line 2917 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2916 
    ;
    
#line 2916 
    if (((int)((struct skb_shared_info *)tmp_0)->tx_flags & 4) == 0) 
      
#line 2918 
      skb_tstamp_tx(skb,(struct skb_shared_hwtstamps *)0); else ;
  }
  else ;
  
#line 2919 
  return;
}


#line 2933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_tx_timestamp(struct sk_buff *skb)
{
  
#line 2935 
  skb_clone_tx_timestamp(skb);
  
#line 2936 
  sw_tx_timestamp(skb);
  
#line 2937 
  return;
}


#line 3305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb, u16 rx_queue)
{
  
#line 3307 
  skb->queue_mapping = (unsigned short)((unsigned int)rx_queue + 1U);
  
#line 3308 
  return;
}


#line 3384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff const *skb)
{
  bool __retres;
  unsigned char *tmp;
  
#line 3386 
  tmp = skb_end_pointer(skb);
  
#line 3386 
  ;
  
#line 3386 
  __retres = (_Bool)((unsigned int)((struct skb_shared_info *)tmp)->gso_size != 0U);
  
#line 3386 
  return __retres;
}


#line 3426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff const *skb)
{
  
#line 3428 
  return;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql, unsigned int count)
{
  
#line 74 
  if ((long)(count > 268435455U) != 0L) {
    
#line 76 
    ldv_inline_asm();
    
#line 74 
    ;
  }
  else ;
  
#line 76 
  dql->last_obj_cnt = count;
  
#line 77 
  ldv_inline_asm();
  
#line 85 
  dql->num_queued += count;
  
#line 86 
  return;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql const *dql)
{
  int __retres;
  unsigned int const volatile *tmp;
  unsigned int const volatile *tmp_0;
  {
    
#line 91 
    unsigned int const __var = 0U;
    
#line 91 
    tmp = (unsigned int const volatile *)(& dql->adj_limit);
  }
  {
    
#line 91 
    unsigned int const __var_0 = 0U;
    
#line 91 
    tmp_0 = (unsigned int const volatile *)(& dql->num_queued);
  }
  
#line 91 
  ;
  
#line 91 
  __retres = (int)(*tmp - *tmp_0);
  
#line 91 
  return __retres;
}


#line 95 
void dql_completed(struct dql *, unsigned int);


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void napi_complete_done(struct napi_struct *, int);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n)
{
  
#line 460 
  napi_complete_done(n,0);
  
#line 461 
  return;
}


#line 1795  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netdev_set_tc_queue(struct net_device *dev, u8 tc, u16 count, u16 offset)
{
  int __retres;
  
#line 1797 
  if ((int)dev->num_tc <= (int)tc) {
    
#line 1798 
    __retres = -22;
    
#line 1798 
    goto return_label;
  }
  else ;
  
#line 1800 
  dev->tc_to_txq[(int)tc].count = count;
  
#line 1801 
  dev->tc_to_txq[(int)tc].offset = offset;
  
#line 1802 
  __retres = 0;
  return_label: 
#line 1802 
                return __retres;
}


#line 1911 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);


#line 1920 
void netif_napi_del(struct napi_struct *);


#line 2505 
void netif_schedule_queue(struct netdev_queue *);


#line 2584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  int tmp;
  
#line 2586 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev_queue->state));
  
#line 2586 
  __retres = (_Bool)(tmp != 0);
  
#line 2586 
  return __retres;
}


#line 2600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_xmit_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  
#line 2602 
  __retres = (_Bool)((dev_queue->state & 3UL) != 0UL);
  
#line 2602 
  return __retres;
}


#line 2645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2649 
  dql_queued(& dev_queue->dql,bytes);
  
#line 2651 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2651 
  if ((long)(tmp >= 0) != 0L) 
#line 2652 
                              goto return_label; else ;
  
#line 2654 
  clear_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2655 
  ldv_inline_asm();
  
#line 2664 
  tmp_0 = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2664 
  if ((long)(tmp_0 >= 0) != 0L) 
#line 2665 
                                clear_bit(1L,(unsigned long volatile *)(& dev_queue->state)); else ;
  return_label: 
#line 2666 
                return;
}


#line 2683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue, unsigned int pkts, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2687 
  if ((long)(bytes == 0U) != 0L) 
#line 2688 
                                 goto return_label; else ;
  
#line 2690 
  dql_completed(& dev_queue->dql,bytes);
  
#line 2691 
  ldv_inline_asm();
  
#line 2699 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2699 
  if (tmp < 0) 
#line 2700 
               goto return_label; else ;
  
#line 2702 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2702 
  if (tmp_0 != 0) 
#line 2703 
                  netif_schedule_queue(dev_queue); else ;
  return_label: 
#line 2704 
                return;
}


#line 2788  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_start_subqueue(struct net_device *dev, u16 queue_index)
{
  
#line 2790 
  struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,(unsigned int)queue_index);
  
#line 2792 
  netif_tx_start_queue(txq);
  
#line 2793 
  return;
}


#line 2815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device const *dev, u16 queue_index)
{
  bool tmp_0;
  
#line 2818 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  
#line 2820 
  tmp_0 = netif_tx_queue_stopped((struct netdev_queue const *)txq);
  
#line 2820 
  return tmp_0;
}


#line 2829 
void netif_wake_subqueue(struct net_device *, u16);


#line 2936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_consume_skb_any(struct sk_buff *skb)
{
  
#line 2938 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_CONSUMED);
  
#line 2939 
  return;
}


#line 2948 
gro_result_t napi_gro_receive(struct napi_struct *, struct sk_buff *);


#line 3553 
int skb_checksum_help(struct sk_buff *);


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static struct tcphdr *inner_tcp_hdr(struct sk_buff const *skb)
{
  struct tcphdr *tmp;
  
#line 39 
  tmp = (struct tcphdr *)skb_inner_transport_header(skb);
  
#line 39 
  return tmp;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static unsigned int inner_tcp_hdrlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  struct tcphdr *tmp;
  
#line 44 
  tmp = inner_tcp_hdr(skb);
  
#line 44 
  ;
  
#line 44 
  __retres = (unsigned int)((int)tmp->doff * 4);
  
#line 44 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/udp.h"
__inline static struct udphdr *udp_hdr(struct sk_buff const *skb)
{
  struct udphdr *tmp;
  
#line 27 
  tmp = (struct udphdr *)skb_transport_header(skb);
  
#line 27 
  return tmp;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff const *skb)
{
  struct ipv6hdr *tmp;
  
#line 76 
  tmp = (struct ipv6hdr *)skb_network_header(skb);
  
#line 76 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
__inline static struct ipv6hdr *inner_ipv6_hdr(struct sk_buff const *skb)
{
  struct ipv6hdr *tmp;
  
#line 81 
  tmp = (struct ipv6hdr *)skb_inner_network_header(skb);
  
#line 81 
  return tmp;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 25 
  tmp = (struct iphdr *)skb_network_header(skb);
  
#line 25 
  return tmp;
}


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *inner_ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 30 
  tmp = (struct iphdr *)skb_inner_network_header(skb);
  
#line 30 
  return tmp;
}


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ip.h"
__inline static unsigned int ip_hdrlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  struct iphdr *tmp;
  
#line 55 
  tmp = ip_hdr(skb);
  
#line 55 
  ;
  
#line 55 
  __retres = (unsigned int)((int)tmp->ihl * 4);
  
#line 55 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
u32 eth_get_headlen(void *, unsigned int);


#line 33 
__be16 eth_type_trans(struct sk_buff *, struct net_device *);


#line 445  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static int eth_skb_pad(struct sk_buff *skb)
{
  int tmp;
  
#line 447 
  tmp = skb_put_padto(skb,60U);
  
#line 447 
  return tmp;
}


#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static __be16 __vlan_get_protocol(struct sk_buff *skb, __be16 type, int *depth)
{
  __be16 __retres;
  
#line 484 
  unsigned int vlan_depth = (unsigned int)skb->mac_len;
  
#line 490 
  if ((unsigned int)type == 129U || (unsigned int)type == 43144U) {
    
#line 491 
    if (vlan_depth != 0U) {
      int tmp;
      {
        
#line 492 
        int __ret_warn_on = vlan_depth <= 3U;
        
#line 492 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 492 
                                              warn_slowpath_null("include/linux/if_vlan.h",492); else ;
        
#line 492 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 492 
      if ((long)tmp != 0L) {
        
#line 493 
        __retres = (unsigned short)0U;
        
#line 493 
        goto return_label;
      }
      else ;
      
#line 494 
      vlan_depth += 4294967292U;
    }
    else 
#line 496 
         vlan_depth = 14U;
    ldv_53733: 
#line 497 
    ;
    {
      struct vlan_hdr *vh;
      int tmp_0;
      
#line 501 
      tmp_0 = pskb_may_pull(skb,vlan_depth + 4U);
      
#line 501 
      if ((long)(tmp_0 == 0) != 0L) {
        
#line 503 
        __retres = (unsigned short)0U;
        
#line 503 
        goto return_label;
      }
      else ;
      
#line 505 
      vh = (struct vlan_hdr *)(skb->data + vlan_depth);
      
#line 506 
      type = vh->h_vlan_encapsulated_proto;
      
#line 507 
      vlan_depth += 4U;
    }
    
#line 509 
    if ((unsigned int)type == 129U || (unsigned int)type == 43144U) 
#line 511 
                                                                    goto ldv_53733; else 
                                                                    
#line 514 
                                                                    goto ldv_53734;
    ldv_53734: 
#line 515 
    ;
  }
  else ;
  
#line 512 
  if (depth != (int *)0) 
#line 513 
                         *depth = (int)vlan_depth; else ;
  
#line 515 
  __retres = type;
  return_label: 
#line 515 
                return __retres;
}


#line 525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static __be16 vlan_get_protocol(struct sk_buff *skb)
{
  __be16 tmp;
  
#line 527 
  tmp = __vlan_get_protocol(skb,(unsigned short)((int)skb->protocol),(int *)0);
  
#line 527 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_macvlan.h"
static void macvlan_count_rx(struct macvlan_dev const *vlan, unsigned int len, bool success, bool multicast)
{
  
#line 70 
  if ((long)((int)success != 0) != 0L) {
    struct vlan_pcpu_stats *pcpu_stats;
    struct vlan_pcpu_stats *tmp_0_0;
    {
      struct vlan_pcpu_stats *tmp_0;
      {
        
#line 73 
        void const *__vpp_verify = (void const *)0;
        
#line 73 
        void const *tmp = __vpp_verify;
      }
      {
        unsigned long tcp_ptr__;
        
#line 74 
        ldv_inline_asm();
        
#line 73 
        tmp_0 = (struct vlan_pcpu_stats *)tcp_ptr__;
      }
      
#line 73 
      tmp_0_0 = tmp_0;
    }
    
#line 73 
    pcpu_stats = tmp_0_0;
    
#line 74 
    u64_stats_init(& pcpu_stats->syncp);
    
#line 75 
    pcpu_stats->rx_packets += 1ULL;
    
#line 76 
    pcpu_stats->rx_bytes += (unsigned long long)len;
    
#line 77 
    if ((int)multicast != 0) 
#line 78 
                             pcpu_stats->rx_multicast += 1ULL; else ;
    
#line 79 
    u64_stats_init(& pcpu_stats->syncp);
  }
  else {
    {
      
#line 81 
      void const *__vpp_verify_0 = (void const *)0;
      
#line 81 
      void const *tmp_3 = __vpp_verify_0;
    }
    
#line 81 
    switch (4UL) {
      case (unsigned long)1: 
#line 81 
      ;
      {
        
#line 81 
        int const pao_ID__ = 1;
        
#line 81 
        switch (4UL) {
          case (unsigned long)1: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53802;
          case (unsigned long)2: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53802;
          case (unsigned long)4: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53802;
          case (unsigned long)8: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53802;
          default: 
#line 81 
          ;
          
#line 81 
          __bad_percpu_size();
        }
        ldv_53802: 
#line 81 
        ;
      }
      
#line 81 
      goto ldv_53807;
      case (unsigned long)2: 
#line 81 
      ;
      {
        
#line 81 
        int const pao_ID___0 = 1;
        
#line 81 
        switch (4UL) {
          case (unsigned long)1: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53813;
          case (unsigned long)2: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53813;
          case (unsigned long)4: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53813;
          case (unsigned long)8: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53813;
          default: 
#line 81 
          ;
          
#line 81 
          __bad_percpu_size();
        }
        ldv_53813: 
#line 81 
        ;
      }
      
#line 81 
      goto ldv_53807;
      case (unsigned long)4: 
#line 81 
      ;
      {
        
#line 81 
        int const pao_ID___1 = 1;
        
#line 81 
        switch (4UL) {
          case (unsigned long)1: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53823;
          case (unsigned long)2: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53823;
          case (unsigned long)4: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53823;
          case (unsigned long)8: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53823;
          default: 
#line 81 
          ;
          
#line 81 
          __bad_percpu_size();
        }
        ldv_53823: 
#line 81 
        ;
      }
      
#line 81 
      goto ldv_53807;
      case (unsigned long)8: 
#line 81 
      ;
      {
        
#line 81 
        int const pao_ID___2 = 1;
        
#line 81 
        switch (4UL) {
          case (unsigned long)1: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53833;
          case (unsigned long)2: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53833;
          case (unsigned long)4: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53833;
          case (unsigned long)8: 
#line 81 
          ;
          
#line 83 
          ldv_inline_asm();
          
#line 81 
          goto ldv_53833;
          default: 
#line 81 
          ;
          
#line 81 
          __bad_percpu_size();
        }
        ldv_53833: 
#line 81 
        ;
      }
      
#line 81 
      goto ldv_53807;
      default: 
#line 81 
      ;
      
#line 81 
      __bad_size_call_parameter();
      
#line 81 
      goto ldv_53807;
    }
    ldv_53807: 
#line 81 
    ;
  }
  
#line 83 
  return;
}


#line 1216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
void pci_disable_msix(struct pci_dev *);


#line 1227 
int pci_enable_msix_range(struct pci_dev *, struct msix_entry *, int, int);


#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k.h"
__inline static __le32 fm10k_test_staterr(union fm10k_rx_desc *rx_desc, u32 const stat_err_bits)
{
  __le32 __retres;
  
#line 380 
  __retres = rx_desc->d.staterr & stat_err_bits;
  
#line 380 
  return __retres;
}


#line 520 
void fm10k_systime_to_hwtstamp(struct fm10k_intfc *interface, struct skb_shared_hwtstamps *hwtstamp, u64 systime);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
char const fm10k_driver_version[9U] = {(char)'0', (char)'.', (char)'1', (char)'5', (char)'.', (char)'2', (char)'-', (char)'k', (char)'\000'};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
char fm10k_driver_name[6U] = {(char)'f', (char)'m', (char)'1', (char)'0', (char)'k', (char)'\000'};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static char const fm10k_driver_string[47U] = {(char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)'(', (char)'R', (char)')', (char)' ', (char)'E', (char)'t', (char)'h', (char)'e', (char)'r', (char)'n', (char)'e', (char)'t', (char)' ', (char)'S', (char)'w', (char)'i', (char)'t', (char)'c', (char)'h', (char)' ', (char)'H', (char)'o', (char)'s', (char)'t', (char)' ', (char)'I', (char)'n', (char)'t', (char)'e', (char)'r', (char)'f', (char)'a', (char)'c', (char)'e', (char)' ', (char)'D', (char)'r', (char)'i', (char)'v', (char)'e', (char)'r', (char)'\000'};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static char const fm10k_copyright[38U] = {(char)'C', (char)'o', (char)'p', (char)'y', (char)'r', (char)'i', (char)'g', (char)'h', (char)'t', (char)' ', (char)'(', (char)'c', (char)')', (char)' ', (char)'2', (char)'0', (char)'1', (char)'3', (char)' ', (char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)' ', (char)'C', (char)'o', (char)'r', (char)'p', (char)'o', (char)'r', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'.', (char)'\000'};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
struct workqueue_struct *fm10k_workqueue = (struct workqueue_struct *)0;

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static int fm10k_init_module(void)
{
  int tmp_1;
  
#line 55 
  printk("\001",(char const *)(& fm10k_driver_string),(char const *)(& fm10k_driver_version));
  
#line 56 
  printk("\001",(char const *)(& fm10k_copyright));
  
#line 59 
  if (fm10k_workqueue == (struct workqueue_struct *)0) {
    struct workqueue_struct *tmp_0;
    {
      struct lock_class_key __key;
      char const *__lock_name;
      
#line 60 
      __lock_name = "\"%s\"";
      
#line 60 
      tmp_0 = __alloc_workqueue_key("%s",8U,1,& __key,__lock_name,(char *)"fm10k");
    }
    
#line 60 
    fm10k_workqueue = tmp_0;
  }
  else ;
  
#line 62 
  fm10k_dbg_init();
  
#line 64 
  tmp_1 = fm10k_register_pci_driver();
  
#line 64 
  return tmp_1;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_exit_module(void)
{
  
#line 76 
  fm10k_unregister_pci_driver();
  
#line 78 
  fm10k_dbg_exit();
  
#line 81 
  flush_workqueue(fm10k_workqueue);
  
#line 82 
  destroy_workqueue(fm10k_workqueue);
  
#line 83 
  fm10k_workqueue = (struct workqueue_struct *)0;
  
#line 84 
  return;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_alloc_mapped_page(struct fm10k_ring *rx_ring, struct fm10k_rx_buffer *bi)
{
  bool __retres;
  dma_addr_t dma;
  int tmp;
  
#line 90 
  struct page *page = bi->page;
  
#line 94 
  if ((long)(page != (struct page *)0) != 0L) {
    
#line 95 
    __retres = (_Bool)1;
    
#line 95 
    goto return_label;
  }
  else ;
  
#line 98 
  page = dev_alloc_page();
  
#line 99 
  if ((long)(page == (struct page *)0) != 0L) {
    
#line 100 
    rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.rx_stats.alloc_failed += 1ULL;
    
#line 101 
    __retres = (_Bool)0;
    
#line 101 
    goto return_label;
  }
  else ;
  
#line 105 
  dma = dma_map_page(rx_ring->dev,page,0UL,4096UL,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 110 
  tmp = dma_mapping_error(rx_ring->dev,dma);
  
#line 110 
  if (tmp != 0) {
    
#line 111 
    __free_pages(page,0U);
    
#line 113 
    rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.rx_stats.alloc_failed += 1ULL;
    
#line 114 
    __retres = (_Bool)0;
    
#line 114 
    goto return_label;
  }
  else ;
  
#line 117 
  bi->dma = dma;
  
#line 118 
  bi->page = page;
  
#line 119 
  bi->page_offset = 0U;
  
#line 121 
  __retres = (_Bool)1;
  return_label: 
#line 121 
                return __retres;
}


#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
void fm10k_alloc_rx_buffers(struct fm10k_ring *rx_ring, u16 cleaned_count)
{
  union fm10k_rx_desc *rx_desc;
  struct fm10k_rx_buffer *bi;
  int tmp_0;
  bool tmp;
  
#line 133 
  u16 i = rx_ring->next_to_use;
  
#line 136 
  if ((unsigned int)cleaned_count == 0U) 
#line 137 
                                         goto return_label; else ;
  
#line 139 
  rx_desc = (union fm10k_rx_desc *)rx_ring->desc + (int)i;
  
#line 140 
  bi = rx_ring->__anonCompField_fm10k_ring_97.rx_buffer + (int)i;
  
#line 141 
  i = (unsigned short)((int)i - (int)rx_ring->count);
  ldv_56773: 
#line 142 
  ;
  
#line 144 
  tmp = fm10k_alloc_mapped_page(rx_ring,bi);
  
#line 144 
  if (tmp) 
#line 144 
           tmp_0 = 0; else 
#line 144 
                           tmp_0 = 1;
  
#line 144 
  if (tmp_0) 
#line 145 
             goto ldv_56772; else ;
  
#line 150 
  rx_desc->q.pkt_addr = bi->dma + (unsigned long long)bi->page_offset;
  
#line 152 
  rx_desc += 1;
  
#line 153 
  bi += 1;
  
#line 154 
  i = (u16)((int)i + 1);
  
#line 155 
  if ((long)((unsigned int)i == 0U) != 0L) {
    
#line 156 
    rx_desc = (union fm10k_rx_desc *)rx_ring->desc;
    
#line 157 
    bi = rx_ring->__anonCompField_fm10k_ring_97.rx_buffer;
    
#line 158 
    i = (unsigned short)((int)i - (int)rx_ring->count);
  }
  else ;
  
#line 162 
  rx_desc->d.staterr = 0U;
  
#line 164 
  cleaned_count = (u16)((int)cleaned_count - 1);
  
#line 165 
  if ((unsigned int)cleaned_count != 0U) 
#line 167 
                                         goto ldv_56773; else 
#line 170 
                                                              goto ldv_56772;
  ldv_56772: 
#line 171 
  ;
  
#line 167 
  i = (unsigned short)((int)rx_ring->count + (int)i);
  
#line 169 
  if ((int)rx_ring->next_to_use != (int)i) {
    
#line 171 
    rx_ring->next_to_use = i;
    
#line 174 
    rx_ring->next_to_alloc = i;
    
#line 175 
    ldv_inline_asm();
    
#line 184 
    writel((unsigned int)i,(void volatile *)rx_ring->tail);
  }
  else ;
  return_label: 
#line 186 
                return;
}


#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_reuse_rx_page(struct fm10k_ring *rx_ring, struct fm10k_rx_buffer *old_buff)
{
  struct fm10k_rx_buffer *new_buff;
  
#line 199 
  u16 nta = rx_ring->next_to_alloc;
  
#line 201 
  new_buff = rx_ring->__anonCompField_fm10k_ring_97.rx_buffer + (int)nta;
  
#line 204 
  nta = (u16)((int)nta + 1);
  
#line 205 
  if ((int)rx_ring->count > (int)nta) 
#line 205 
                                      rx_ring->next_to_alloc = nta; else 
                                                                    
#line 205 
                                                                    rx_ring->next_to_alloc = (unsigned short)0U;
  
#line 208 
  *new_buff = *old_buff;
  
#line 211 
  dma_sync_single_range_for_device(rx_ring->dev,old_buff->dma,(unsigned long)old_buff->page_offset,2048UL,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 213 
  return;
}


#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
__inline static bool fm10k_page_is_reserved(struct page *page)
{
  bool __retres;
  int tmp_2;
  int tmp;
  int tmp_0;
  
#line 219 
  tmp = page_to_nid((struct page const *)page);
  
#line 219 
  tmp_0 = numa_mem_id();
  
#line 219 
  if (tmp != tmp_0) 
#line 219 
                    tmp_2 = 1;
  else {
    bool tmp_1;
    
#line 219 
    tmp_1 = page_is_pfmemalloc(page);
    
#line 219 
    if ((int)tmp_1 != 0) 
#line 219 
                         tmp_2 = 1; else 
#line 219 
                                         tmp_2 = 0;
  }
  
#line 219 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 219 
  return __retres;
}


#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_can_reuse_rx_page(struct fm10k_rx_buffer *rx_buffer, struct page *page, unsigned int truesize)
{
  bool __retres;
  bool tmp;
  int tmp_0;
  
#line 227 
  tmp = fm10k_page_is_reserved(page);
  
#line 227 
  if ((long)((int)tmp != 0) != 0L) {
    
#line 228 
    __retres = (_Bool)0;
    
#line 228 
    goto return_label;
  }
  else ;
  
#line 232 
  tmp_0 = page_count(page);
  
#line 232 
  if ((long)(tmp_0 != 1) != 0L) {
    
#line 233 
    __retres = (_Bool)0;
    
#line 233 
    goto return_label;
  }
  else ;
  
#line 236 
  rx_buffer->page_offset ^= 2048U;
  
#line 248 
  atomic_inc(& page->__anonCompField_page_32.__anonCompField___anonstruct_57_31.__anonCompField___anonunion_59_30._count);
  
#line 250 
  __retres = (_Bool)1;
  return_label: 
#line 250 
                return __retres;
}


#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_add_rx_frag(struct fm10k_rx_buffer *rx_buffer, union fm10k_rx_desc *rx_desc, struct sk_buff *skb)
{
  bool __retres;
  void *tmp;
  unsigned int pull_len;
  bool tmp_0;
  unsigned char *tmp_4;
  unsigned char *tmp_5;
  bool tmp_6;
  
#line 271 
  struct page *page = rx_buffer->page;
  
#line 272 
  tmp = lowmem_page_address((struct page const *)page);
  
#line 272 
  unsigned char *va = (unsigned char *)(tmp + rx_buffer->page_offset);
  
#line 273 
  unsigned int size = (unsigned int)rx_desc->w.length;
  
#line 275 
  unsigned int truesize = 2048U;
  
#line 281 
  tmp_0 = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 281 
  if ((long)((int)tmp_0 != 0) != 0L) 
#line 282 
                                     goto add_tail_frag; else ;
  
#line 284 
  if ((long)(size <= 256U) != 0L) {
    unsigned char *tmp_1;
    int tmp_3;
    bool tmp_2;
    
#line 285 
    ;
    
#line 285 
    ;
    
#line 285 
    tmp_1 = __skb_put(skb,size);
    
#line 285 
    memcpy((void *)tmp_1,(void const *)va,(unsigned long)(size + 7U) & 4294967288UL);
    
#line 288 
    tmp_2 = fm10k_page_is_reserved(page);
    
#line 288 
    if (tmp_2) 
#line 288 
               tmp_3 = 0; else 
#line 288 
                               tmp_3 = 1;
    
#line 288 
    if ((long)tmp_3 != 0L) {
      
#line 289 
      __retres = (_Bool)1;
      
#line 289 
      goto return_label;
    }
    else ;
    
#line 292 
    __free_pages(page,0U);
    
#line 293 
    __retres = (_Bool)0;
    
#line 293 
    goto return_label;
  }
  else ;
  
#line 299 
  pull_len = eth_get_headlen((void *)va,256U);
  
#line 302 
  ;
  
#line 302 
  ;
  
#line 302 
  tmp_4 = __skb_put(skb,pull_len);
  
#line 302 
  memcpy((void *)tmp_4,(void const *)va,(unsigned long)(pull_len + 7U) & 4294967288UL);
  
#line 305 
  va += pull_len;
  
#line 306 
  size -= pull_len;
  add_tail_frag: 
#line 308 
  ;
  
#line 309 
  ;
  
#line 309 
  ;
  
#line 309 
  ;
  
#line 309 
  ;
  
#line 309 
  tmp_5 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 309 
  ;
  
#line 309 
  skb_add_rx_frag(skb,(int)((struct skb_shared_info *)tmp_5)->nr_frags,page,(int)((long)va) & 4095,(int)size,truesize);
  
#line 312 
  tmp_6 = fm10k_can_reuse_rx_page(rx_buffer,page,truesize);
  
#line 312 
  __retres = tmp_6;
  return_label: 
#line 312 
                return __retres;
}


#line 315  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static struct sk_buff *fm10k_fetch_rx_buffer(struct fm10k_ring *rx_ring, union fm10k_rx_desc *rx_desc, struct sk_buff *skb)
{
  struct sk_buff *__retres;
  struct fm10k_rx_buffer *rx_buffer;
  struct page *page;
  bool tmp_0;
  
#line 322 
  rx_buffer = rx_ring->__anonCompField_fm10k_ring_97.rx_buffer + (int)rx_ring->next_to_clean;
  
#line 323 
  page = rx_buffer->page;
  
#line 324 
  prefetchw((void const *)page);
  
#line 326 
  if ((long)(skb == (struct sk_buff *)0) != 0L) {
    void *tmp;
    
#line 327 
    tmp = lowmem_page_address((struct page const *)page);
    
#line 327 
    void *page_addr = tmp + rx_buffer->page_offset;
    
#line 331 
    __builtin_prefetch((void const *)page_addr);
    
#line 333 
    __builtin_prefetch((void const *)(page_addr + 64U));
    
#line 337 
    skb = napi_alloc_skb(& (rx_ring->q_vector)->napi,256U);
    
#line 339 
    if ((long)(skb == (struct sk_buff *)0) != 0L) {
      
#line 340 
      rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.rx_stats.alloc_failed += 1ULL;
      
#line 341 
      __retres = (struct sk_buff *)0;
      
#line 341 
      goto return_label;
    }
    else ;
    
#line 348 
    prefetchw((void const *)skb->data);
  }
  else ;
  
#line 352 
  dma_sync_single_range_for_cpu(rx_ring->dev,rx_buffer->dma,(unsigned long)rx_buffer->page_offset,2048UL,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 359 
  tmp_0 = fm10k_add_rx_frag(rx_buffer,rx_desc,skb);
  
#line 359 
  if ((int)tmp_0 != 0) 
#line 361 
                       fm10k_reuse_rx_page(rx_ring,rx_buffer); else 
#line 364 
                                                                    dma_unmap_page(rx_ring->dev,rx_buffer->dma,4096UL,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 369 
  rx_buffer->page = (struct page *)0;
  
#line 371 
  __retres = skb;
  return_label: 
#line 371 
                return __retres;
}


#line 374  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
__inline static void fm10k_rx_checksum(struct fm10k_ring *ring, union fm10k_rx_desc *rx_desc, struct sk_buff *skb)
{
  __le32 tmp;
  __le32 tmp_1;
  
#line 378 
  skb_checksum_none_assert((struct sk_buff const *)skb);
  
#line 381 
  if (((ring->netdev)->features & 17179869184ULL) == 0ULL) 
#line 382 
                                                           goto return_label; else ;
  
#line 385 
  tmp = fm10k_test_staterr(rx_desc,55296U);
  
#line 385 
  if (tmp != 0U) {
    
#line 390 
    ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.rx_stats.csum_err += 1ULL;
    
#line 391 
    goto return_label;
  }
  else ;
  
#line 395 
  tmp_1 = fm10k_test_staterr(rx_desc,64U);
  
#line 395 
  if (tmp_1 != 0U) 
#line 396 
                   skb->encapsulation = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  else {
    __le32 tmp_0;
    
#line 397 
    tmp_0 = fm10k_test_staterr(rx_desc,16U);
    
#line 397 
    if (tmp_0 == 0U) 
#line 398 
                     goto return_label; else ;
  }
  
#line 400 
  skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U;
  return_label: 
#line 401 
                return;
}


#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
__inline static void fm10k_rx_hash(struct fm10k_ring *ring, union fm10k_rx_desc *rx_desc, struct sk_buff *skb)
{
  u16 rss_type;
  int tmp;
  
#line 415 
  if (((ring->netdev)->features & 8589934592ULL) == 0ULL) 
#line 416 
                                                          goto return_label; else ;
  
#line 418 
  rss_type = (unsigned short)((unsigned int)rx_desc->w.pkt_info & 15U);
  
#line 419 
  if ((unsigned int)rss_type == 0U) 
#line 420 
                                    goto return_label; else ;
  
#line 424 
  if (((394UL >> (int)rss_type) & 1UL) != 0UL) 
#line 424 
                                               tmp = 3; else 
#line 424 
                                                             tmp = 2;
  
#line 422 
  ;
  
#line 422 
  ;
  
#line 422 
  skb_set_hash(skb,rx_desc->d.rss,(enum pkt_hash_types)tmp);
  return_label: 
#line 425 
                return;
}


#line 427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_rx_hwtstamp(struct fm10k_ring *rx_ring, union fm10k_rx_desc *rx_desc, struct sk_buff *skb)
{
  
#line 431 
  struct fm10k_intfc *interface = (rx_ring->q_vector)->interface;
  
#line 433 
  ((struct fm10k_cb *)(& skb->cb))->__anonCompField_fm10k_cb_122.tstamp = rx_desc->q.timestamp;
  
#line 435 
  if ((long)((interface->flags & 8U) != 0U) != 0L) {
    struct skb_shared_hwtstamps *tmp;
    
#line 436 
    ;
    
#line 436 
    tmp = skb_hwtstamps(skb);
    
#line 436 
    ;
    
#line 436 
    fm10k_systime_to_hwtstamp(interface,tmp,rx_desc->q.timestamp);
  }
  else ;
  
#line 438 
  return;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_type_trans(struct fm10k_ring *rx_ring, union fm10k_rx_desc *rx_desc, struct sk_buff *skb)
{
  struct fm10k_l2_accel *tmp_3;
  void *tmp_4;
  
#line 444 
  struct net_device *dev = rx_ring->netdev;
  {
    struct fm10k_l2_accel *tmp_0;
    {
      struct fm10k_l2_accel *tmp;
      {
        union __anonunion___u_3065 __u;
        
#line 445 
        __read_once_size((void const volatile *)(& rx_ring->l2_accel),(void *)(& __u.__c),8);
        
#line 445 
        tmp = __u.__val;
      }
      
#line 445 
      struct fm10k_l2_accel *_________p1 = tmp;
      
#line 445 
      tmp_0 = _________p1;
    }
    
#line 445 
    struct fm10k_l2_accel *________p1 = tmp_0;
    {
      bool __warned;
      int tmp_1;
      
#line 445 
      tmp_1 = debug_lockdep_rcu_enabled();
      
#line 445 
      if (tmp_1 != 0) {
        
#line 445 
        if (! __warned) {
          int tmp_2;
          
#line 445 
          tmp_2 = rcu_read_lock_bh_held();
          
#line 445 
          if (tmp_2 == 0) {
            
#line 445 
            __warned = (_Bool)1;
            
#line 445 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c",445,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 445 
    tmp_3 = ________p1;
  }
  
#line 445 
  struct fm10k_l2_accel *l2_accel = tmp_3;
  
#line 448 
  if (l2_accel != (struct fm10k_l2_accel *)0) {
    
#line 449 
    u16 idx = (unsigned short)((unsigned int)((struct fm10k_cb *)(& skb->cb))->fi.w.dglort + 65535U);
    
#line 451 
    idx = (unsigned short)((int)idx - (int)l2_accel->dglort);
    
#line 452 
    if ((int)idx < l2_accel->size && l2_accel->macvlan[(int)idx] != (struct net_device *)0) 
      
#line 453 
      dev = l2_accel->macvlan[(int)idx]; else 
#line 455 
                                              l2_accel = (struct fm10k_l2_accel *)0;
  }
  else ;
  
#line 458 
  skb->protocol = eth_type_trans(skb,dev);
  
#line 460 
  if (l2_accel == (struct fm10k_l2_accel *)0) 
#line 461 
                                              goto return_label; else ;
  
#line 464 
  ;
  
#line 464 
  ;
  
#line 464 
  tmp_4 = netdev_priv((struct net_device const *)dev);
  
#line 464 
  macvlan_count_rx((struct macvlan_dev const *)tmp_4,skb->len + 14U,(_Bool)1,(_Bool)(((int)rx_desc->w.hdr_info & 6) != 0));
  return_label: 
#line 466 
                return;
}


#line 479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static unsigned int fm10k_process_skb_fields(struct fm10k_ring *rx_ring, union fm10k_rx_desc *rx_desc, struct sk_buff *skb)
{
  
#line 483 
  unsigned int len = skb->len;
  
#line 485 
  fm10k_rx_hash(rx_ring,rx_desc,skb);
  
#line 487 
  fm10k_rx_checksum(rx_ring,rx_desc,skb);
  
#line 489 
  fm10k_rx_hwtstamp(rx_ring,rx_desc,skb);
  
#line 491 
  ((struct fm10k_cb *)(& skb->cb))->fi.w.vlan = rx_desc->w.vlan;
  
#line 493 
  skb_record_rx_queue(skb,(unsigned short)((int)rx_ring->queue_index));
  
#line 495 
  ((struct fm10k_cb *)(& skb->cb))->fi.d.glort = rx_desc->d.glort;
  
#line 497 
  if ((unsigned int)rx_desc->w.vlan != 0U) {
    
#line 498 
    u16 vid = rx_desc->w.vlan;
    
#line 500 
    if ((int)rx_ring->vid != (int)vid) 
#line 501 
                                       __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)((int)vid)); else ;
  }
  else ;
  
#line 504 
  fm10k_type_trans(rx_ring,rx_desc,skb);
  
#line 506 
  return len;
}


#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_is_non_eop(struct fm10k_ring *rx_ring, union fm10k_rx_desc *rx_desc)
{
  bool __retres;
  __le32 tmp;
  
#line 522 
  u32 ntc = (unsigned int)((int)rx_ring->next_to_clean + 1);
  
#line 525 
  if ((unsigned int)rx_ring->count > ntc) 
#line 525 
                                          ntc = ntc; else 
#line 525 
                                                          ntc = 0U;
  
#line 526 
  rx_ring->next_to_clean = (unsigned short)ntc;
  
#line 528 
  __builtin_prefetch((void const *)rx_ring->desc + ntc);
  
#line 530 
  tmp = fm10k_test_staterr(rx_desc,2U);
  
#line 530 
  if ((long)(tmp != 0U) != 0L) {
    
#line 531 
    __retres = (_Bool)0;
    
#line 531 
    goto return_label;
  }
  else ;
  
#line 533 
  __retres = (_Bool)1;
  return_label: 
#line 533 
                return __retres;
}


#line 550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_cleanup_headers(struct fm10k_ring *rx_ring, union fm10k_rx_desc *rx_desc, struct sk_buff *skb)
{
  bool __retres;
  __le32 tmp;
  int tmp_0;
  
#line 554 
  tmp = fm10k_test_staterr(rx_desc,8192U);
  
#line 554 
  if ((long)(tmp != 0U) != 0L) {
    
#line 556 
    dev_kfree_skb_any(skb);
    
#line 557 
    rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.rx_stats.errors += 1ULL;
    
#line 558 
    __retres = (_Bool)1;
    
#line 558 
    goto return_label;
  }
  else ;
  
#line 562 
  tmp_0 = eth_skb_pad(skb);
  
#line 562 
  if (tmp_0 != 0) {
    
#line 563 
    __retres = (_Bool)1;
    
#line 563 
    goto return_label;
  }
  else ;
  
#line 565 
  __retres = (_Bool)0;
  return_label: 
#line 565 
                return __retres;
}


#line 573  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_receive_skb(struct fm10k_q_vector *q_vector, struct sk_buff *skb)
{
  
#line 576 
  napi_gro_receive(& q_vector->napi,skb);
  
#line 577 
  return;
}


#line 579  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_clean_rx_irq(struct fm10k_q_vector *q_vector, struct fm10k_ring *rx_ring, int budget)
{
  bool __retres;
  
#line 583 
  struct sk_buff *skb = rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.skb;
  
#line 584 
  unsigned int total_bytes = 0U;
  
#line 584 
  unsigned int total_packets = 0U;
  
#line 585 
  u16 cleaned_count = fm10k_desc_unused(rx_ring);
  
#line 587 
  goto ldv_56874;
  ldv_56875: 
#line 588 
  ;
  {
    union fm10k_rx_desc *rx_desc;
    bool tmp_0;
    bool tmp_1;
    unsigned int tmp_2;
    
#line 591 
    if ((unsigned int)cleaned_count > 15U) {
      
#line 592 
      fm10k_alloc_rx_buffers(rx_ring,(unsigned short)((int)cleaned_count));
      
#line 593 
      cleaned_count = (unsigned short)0U;
    }
    else ;
    
#line 596 
    rx_desc = (union fm10k_rx_desc *)rx_ring->desc + (int)rx_ring->next_to_clean;
    
#line 598 
    if (rx_desc->d.staterr == 0U) 
#line 599 
                                  goto ldv_56873; else ;
    
#line 600 
    ldv_inline_asm();
    
#line 608 
    skb = fm10k_fetch_rx_buffer(rx_ring,rx_desc,skb);
    
#line 611 
    if (skb == (struct sk_buff *)0) 
#line 612 
                                    goto ldv_56873; else ;
    
#line 614 
    cleaned_count = (u16)((int)cleaned_count + 1);
    
#line 617 
    tmp_0 = fm10k_is_non_eop(rx_ring,rx_desc);
    
#line 617 
    if ((int)tmp_0 != 0) 
#line 618 
                         goto ldv_56874; else ;
    
#line 621 
    tmp_1 = fm10k_cleanup_headers(rx_ring,rx_desc,skb);
    
#line 621 
    if ((int)tmp_1 != 0) {
      
#line 622 
      skb = (struct sk_buff *)0;
      
#line 623 
      goto ldv_56874;
    }
    else ;
    
#line 627 
    tmp_2 = fm10k_process_skb_fields(rx_ring,rx_desc,skb);
    
#line 627 
    total_bytes = tmp_2 + total_bytes;
    
#line 629 
    fm10k_receive_skb(q_vector,skb);
    
#line 632 
    skb = (struct sk_buff *)0;
    
#line 635 
    total_packets += 1U;
  }
  ldv_56874: 
#line 637 
  ;
  
#line 587 
  if ((long)(total_packets < (unsigned int)budget) != 0L) 
#line 589 
                                                          goto ldv_56875; else 
                                                                    
#line 592 
                                                                    goto ldv_56873;
  ldv_56873: 
#line 593 
  ;
  
#line 639 
  rx_ring->__anonCompField_fm10k_ring_99.__anonCompField___anonunion_326_98.skb = skb;
  
#line 641 
  u64_stats_init(& rx_ring->syncp);
  
#line 642 
  rx_ring->stats.packets += (unsigned long long)total_packets;
  
#line 643 
  rx_ring->stats.bytes += (unsigned long long)total_bytes;
  
#line 644 
  u64_stats_init(& rx_ring->syncp);
  
#line 645 
  q_vector->rx.total_packets += total_packets;
  
#line 646 
  q_vector->rx.total_bytes += total_bytes;
  
#line 648 
  __retres = (_Bool)(total_packets < (unsigned int)budget);
  
#line 648 
  return __retres;
}


#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static struct ethhdr *fm10k_port_is_vxlan(struct sk_buff *skb)
{
  struct ethhdr *__retres;
  struct fm10k_vxlan_port *vxlan_port;
  int tmp_0;
  struct udphdr *tmp_2;
  unsigned char *tmp_3;
  
#line 654 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)skb->dev);
  
#line 658 
  tmp_0 = list_empty((struct list_head const *)(& interface->vxlan_port));
  
#line 658 
  if (tmp_0 == 0) {
    struct fm10k_vxlan_port *tmp_1;
    {
      
#line 658 
      struct list_head const *__mptr = (struct list_head const *)interface->vxlan_port.next;
      
#line 658 
      tmp_1 = (struct fm10k_vxlan_port *)__mptr;
    }
    
#line 658 
    vxlan_port = tmp_1;
  }
  else 
#line 658 
       vxlan_port = (struct fm10k_vxlan_port *)0;
  
#line 661 
  if (vxlan_port == (struct fm10k_vxlan_port *)0) {
    
#line 662 
    __retres = (struct ethhdr *)0;
    
#line 662 
    goto return_label;
  }
  else ;
  
#line 663 
  tmp_2 = udp_hdr((struct sk_buff const *)skb);
  
#line 663 
  ;
  
#line 663 
  if ((int)vxlan_port->port != (int)tmp_2->dest) {
    
#line 664 
    __retres = (struct ethhdr *)0;
    
#line 664 
    goto return_label;
  }
  else ;
  
#line 667 
  tmp_3 = skb_transport_header((struct sk_buff const *)skb);
  
#line 667 
  __retres = (struct ethhdr *)(tmp_3 + 16U);
  return_label: 
#line 667 
                return __retres;
}


#line 678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static struct ethhdr *fm10k_gre_is_nvgre(struct sk_buff *skb)
{
  struct ethhdr *__retres;
  struct fm10k_nvgre_hdr *nvgre_hdr;
  unsigned int tmp;
  __be16 tmp_0;
  unsigned char *tmp_1;
  
#line 681 
  tmp = ip_hdrlen((struct sk_buff const *)skb);
  
#line 681 
  int hlen = (int)tmp;
  
#line 684 
  tmp_0 = vlan_get_protocol(skb);
  
#line 684 
  if ((unsigned int)tmp_0 != 8U) {
    
#line 685 
    __retres = (struct ethhdr *)0;
    
#line 685 
    goto return_label;
  }
  else ;
  
#line 688 
  tmp_1 = skb_network_header((struct sk_buff const *)skb);
  
#line 688 
  nvgre_hdr = (struct fm10k_nvgre_hdr *)(tmp_1 + hlen);
  
#line 691 
  if (((int)nvgre_hdr->flags & 65439) != 0) {
    
#line 692 
    __retres = (struct ethhdr *)0;
    
#line 692 
    goto return_label;
  }
  else ;
  
#line 695 
  if (((int)nvgre_hdr->flags & 32) != 0) {
    
#line 696 
    __retres = (struct ethhdr *)(nvgre_hdr + 1U);
    
#line 696 
    goto return_label;
  }
  else ;
  
#line 698 
  __retres = (struct ethhdr *)(& nvgre_hdr->tni);
  return_label: 
#line 698 
                return __retres;
}


#line 701  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
__be16 fm10k_tx_encap_offload(struct sk_buff *skb)
{
  __be16 __retres;
  u8 inner_l4_hlen;
  struct ethhdr *eth_hdr_0;
  __be16 tmp;
  unsigned char *tmp_5;
  unsigned char *tmp_6;
  
#line 703 
  u8 l4_hdr = (unsigned char)0U;
  
#line 703 
  u8 inner_l4_hdr = (unsigned char)0U;
  
#line 706 
  if ((unsigned int)*((unsigned char *)skb + 147UL) != 0U || (unsigned int)skb->__anonCompField_sk_buff_72.inner_protocol != 22629U) {
    
#line 708 
    __retres = (unsigned short)0U;
    
#line 708 
    goto return_label;
  }
  else ;
  
#line 710 
  tmp = vlan_get_protocol(skb);
  
#line 710 
  switch ((int)tmp) {
    struct iphdr *tmp_0;
    struct ipv6hdr *tmp_1;
    case 8: 
#line 711 
    ;
    
#line 712 
    tmp_0 = ip_hdr((struct sk_buff const *)skb);
    
#line 712 
    l4_hdr = tmp_0->protocol;
    
#line 713 
    goto ldv_56900;
    case 56710: 
#line 714 
    ;
    
#line 715 
    tmp_1 = ipv6_hdr((struct sk_buff const *)skb);
    
#line 715 
    l4_hdr = tmp_1->nexthdr;
    
#line 716 
    goto ldv_56900;
    default: 
#line 717 
    ;
    
#line 718 
    __retres = (unsigned short)0U;
    
#line 718 
    goto return_label;
  }
  ldv_56900: 
#line 721 
  ;
  
#line 721 
  switch ((int)l4_hdr) {
    case 17: 
#line 722 
    ;
    
#line 723 
    eth_hdr_0 = fm10k_port_is_vxlan(skb);
    
#line 724 
    goto ldv_56904;
    case 47: 
#line 725 
    ;
    
#line 726 
    eth_hdr_0 = fm10k_gre_is_nvgre(skb);
    
#line 727 
    goto ldv_56904;
    default: 
#line 728 
    ;
    
#line 729 
    __retres = (unsigned short)0U;
    
#line 729 
    goto return_label;
  }
  ldv_56904: 
#line 732 
  ;
  
#line 732 
  if (eth_hdr_0 == (struct ethhdr *)0) {
    
#line 733 
    __retres = (unsigned short)0U;
    
#line 733 
    goto return_label;
  }
  else ;
  
#line 735 
  switch ((int)eth_hdr_0->h_proto) {
    struct iphdr *tmp_2;
    struct ipv6hdr *tmp_3;
    case 8: 
#line 736 
    ;
    
#line 737 
    tmp_2 = inner_ip_hdr((struct sk_buff const *)skb);
    
#line 737 
    inner_l4_hdr = tmp_2->protocol;
    
#line 738 
    goto ldv_56908;
    case 56710: 
#line 739 
    ;
    
#line 740 
    tmp_3 = inner_ipv6_hdr((struct sk_buff const *)skb);
    
#line 740 
    inner_l4_hdr = tmp_3->nexthdr;
    
#line 741 
    goto ldv_56908;
    default: 
#line 742 
    ;
    
#line 743 
    __retres = (unsigned short)0U;
    
#line 743 
    goto return_label;
  }
  ldv_56908: 
#line 746 
  ;
  
#line 746 
  switch ((int)inner_l4_hdr) {
    unsigned int tmp_4;
    case 6: 
#line 747 
    ;
    
#line 748 
    tmp_4 = inner_tcp_hdrlen((struct sk_buff const *)skb);
    
#line 748 
    inner_l4_hlen = (unsigned char)tmp_4;
    
#line 749 
    goto ldv_56912;
    case 17: 
#line 750 
    ;
    
#line 751 
    inner_l4_hlen = (unsigned char)8U;
    
#line 752 
    goto ldv_56912;
    default: 
#line 753 
    ;
    
#line 754 
    __retres = (unsigned short)0U;
    
#line 754 
    goto return_label;
  }
  ldv_56912: 
#line 760 
  ;
  
#line 760 
  tmp_5 = skb_inner_transport_header((struct sk_buff const *)skb);
  
#line 760 
  tmp_6 = skb_mac_header((struct sk_buff const *)skb);
  
#line 760 
  ;
  
#line 760 
  if ((long)(tmp_5 + (int)inner_l4_hlen) - (long)tmp_6 > 184L) {
    
#line 762 
    __retres = (unsigned short)0U;
    
#line 762 
    goto return_label;
  }
  else ;
  
#line 764 
  __retres = eth_hdr_0->h_proto;
  return_label: 
#line 764 
                return __retres;
}


#line 767  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static int fm10k_tso(struct fm10k_ring *tx_ring, struct fm10k_tx_buffer *first)
{
  int __retres;
  struct fm10k_tx_desc *tx_desc;
  unsigned char *th;
  u8 hdrlen;
  int tmp_0;
  bool tmp;
  unsigned char *tmp_2;
  unsigned char *tmp_3;
  int tmp_4;
  
#line 770 
  struct sk_buff *skb = first->skb;
  
#line 775 
  if ((unsigned int)*((unsigned char *)skb + 145UL) != 6U) {
    
#line 776 
    __retres = 0;
    
#line 776 
    goto return_label;
  }
  else ;
  
#line 778 
  tmp = skb_is_gso((struct sk_buff const *)skb);
  
#line 778 
  if (tmp) 
#line 778 
           tmp_0 = 0; else 
#line 778 
                           tmp_0 = 1;
  
#line 778 
  if (tmp_0) {
    
#line 779 
    __retres = 0;
    
#line 779 
    goto return_label;
  }
  else ;
  
#line 782 
  if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) {
    __be16 tmp_1;
    
#line 783 
    tmp_1 = fm10k_tx_encap_offload(skb);
    
#line 783 
    if ((unsigned int)tmp_1 == 0U) 
#line 784 
                                   goto err_vxlan; else ;
    
#line 785 
    th = skb_inner_transport_header((struct sk_buff const *)skb);
  }
  else 
#line 787 
       th = skb_transport_header((struct sk_buff const *)skb);
  
#line 791 
  hdrlen = (unsigned char)((int)((unsigned char)((long)th - (long)skb->data)) + ((int)((unsigned char)((struct tcphdr *)th)->doff) << 2U));
  
#line 793 
  first->tx_flags = (unsigned short)((unsigned int)first->tx_flags | 1U);
  
#line 796 
  tmp_2 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 796 
  first->gso_segs = ((struct skb_shared_info *)tmp_2)->gso_segs;
  
#line 797 
  first->bytecount += (unsigned int)(((int)first->gso_segs + -1) * (int)hdrlen);
  
#line 800 
  tx_desc = (struct fm10k_tx_desc *)tx_ring->desc + (int)tx_ring->next_to_use;
  
#line 801 
  tx_desc->hdrlen = hdrlen;
  
#line 802 
  tmp_3 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 802 
  tx_desc->mss = ((struct skb_shared_info *)tmp_3)->gso_size;
  
#line 804 
  __retres = 1;
  
#line 804 
  goto return_label;
  err_vxlan: 
#line 805 
  ;
  
#line 806 
  (tx_ring->netdev)->features &= 18446744073642442751ULL;
  
#line 807 
  tmp_4 = net_ratelimit();
  
#line 807 
  if (tmp_4 == 0) 
#line 808 
                  netdev_err((struct net_device const *)tx_ring->netdev,"TSO requested for unsupported tunnel, disabling offload\n"); else ;
  
#line 810 
  __retres = -1;
  return_label: 
#line 810 
                return __retres;
}


#line 813  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_tx_csum(struct fm10k_ring *tx_ring, struct fm10k_tx_buffer *first)
{
  struct fm10k_tx_desc *tx_desc;
  union __anonunion_network_hdr_3067 network_hdr;
  __be16 protocol;
  
#line 816 
  struct sk_buff *skb = first->skb;
  
#line 824 
  u8 l4_hdr = (unsigned char)0U;
  
#line 826 
  if ((unsigned int)*((unsigned char *)skb + 145UL) != 6U) 
#line 827 
                                                           goto no_csum; else ;
  
#line 829 
  if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) {
    
#line 830 
    protocol = fm10k_tx_encap_offload(skb);
    
#line 831 
    if ((unsigned int)protocol == 0U) {
      int tmp;
      
#line 832 
      tmp = skb_checksum_help(skb);
      
#line 832 
      if (tmp != 0) {
        
#line 833 
        dev_warn((struct device const *)tx_ring->dev,"failed to offload encap csum!\n");
        
#line 835 
        tx_ring->__anonCompField_fm10k_ring_99.tx_stats.csum_err += 1ULL;
      }
      else ;
      
#line 837 
      goto no_csum;
    }
    else ;
    
#line 839 
    network_hdr.raw = skb_inner_network_header((struct sk_buff const *)skb);
  }
  else {
    
#line 841 
    protocol = vlan_get_protocol(skb);
    
#line 842 
    network_hdr.raw = skb_network_header((struct sk_buff const *)skb);
  }
  
#line 845 
  switch ((int)protocol) {
    int tmp_2;
    case 8: 
#line 846 
    ;
    
#line 847 
    l4_hdr = (network_hdr.ipv4)->protocol;
    
#line 848 
    goto ldv_56939;
    case 56710: 
#line 849 
    ;
    
#line 850 
    l4_hdr = (network_hdr.ipv6)->nexthdr;
    
#line 851 
    goto ldv_56939;
    default: 
#line 852 
    ;
    
#line 853 
    tmp_2 = net_ratelimit();
    
#line 853 
    if ((long)(tmp_2 != 0) != 0L) 
#line 854 
                                  dev_warn((struct device const *)tx_ring->dev,"partial checksum but ip version=%x!\n",(int)protocol); else ;
    
#line 858 
    tx_ring->__anonCompField_fm10k_ring_99.tx_stats.csum_err += 1ULL;
    
#line 859 
    goto no_csum;
  }
  ldv_56939: 
#line 862 
  ;
  
#line 862 
  switch ((int)l4_hdr) {
    int tmp_3;
    case 6: 
#line 863 
    ;
    case 17: 
#line 864 
    ;
    
#line 865 
    goto ldv_56944;
    case 47: 
#line 866 
    ;
    
#line 867 
    if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) 
#line 868 
                                                             goto ldv_56944; else ;
    default: 
#line 869 
    ;
    
#line 870 
    tmp_3 = net_ratelimit();
    
#line 870 
    if ((long)(tmp_3 != 0) != 0L) 
#line 871 
                                  dev_warn((struct device const *)tx_ring->dev,"partial checksum but l4 proto=%x!\n",(int)l4_hdr); else ;
    
#line 875 
    tx_ring->__anonCompField_fm10k_ring_99.tx_stats.csum_err += 1ULL;
    
#line 876 
    goto no_csum;
  }
  ldv_56944: 
#line 880 
  ;
  
#line 880 
  first->tx_flags = (unsigned short)((unsigned int)first->tx_flags | 1U);
  no_csum: 
#line 882 
  ;
  
#line 884 
  tx_desc = (struct fm10k_tx_desc *)tx_ring->desc + (int)tx_ring->next_to_use;
  
#line 885 
  tx_desc->hdrlen = (unsigned char)0U;
  
#line 886 
  tx_desc->mss = (unsigned short)0U;
  
#line 887 
  return;
}


#line 894  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static u8 fm10k_tx_desc_flags(struct sk_buff *skb, u32 tx_flags)
{
  u8 __retres;
  unsigned char *tmp;
  
#line 897 
  u32 desc_flags = 0U;
  
#line 900 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 900 
  ;
  
#line 900 
  if ((long)(((int)((struct skb_shared_info *)tmp)->tx_flags & 1) != 0) != 0L) {
    unsigned char *tmp_0;
    
#line 901 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 900 
    ;
    
#line 900 
    if ((long)(((int)((struct skb_shared_info *)tmp_0)->tx_flags & 4) != 0) != 0L) 
      
#line 902 
      desc_flags |= 2U; else ;
  }
  else ;
  
#line 905 
  desc_flags = (tx_flags & 1U) * 4U | desc_flags;
  
#line 908 
  __retres = (unsigned char)desc_flags;
  
#line 908 
  return __retres;
}


#line 911  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_tx_desc_push(struct fm10k_ring *tx_ring, struct fm10k_tx_desc *tx_desc, u16 i, dma_addr_t dma, unsigned int size, u8 desc_flags)
{
  bool __retres;
  
#line 916 
  i = (u16)((int)i + 1);
  
#line 916 
  if (((int)i & 3) == 0) 
#line 917 
                         desc_flags = (unsigned char)((unsigned int)desc_flags | 33U); else ;
  
#line 920 
  tx_desc->buffer_addr = dma;
  
#line 921 
  tx_desc->flags = desc_flags;
  
#line 922 
  tx_desc->buflen = (unsigned short)size;
  
#line 925 
  __retres = (_Bool)((int)tx_ring->count == (int)i);
  
#line 925 
  return __retres;
}


#line 928  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static int __fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)
{
  int __retres;
  u16 tmp;
  
#line 930 
  netif_start_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
  
#line 931 
  ldv_inline_asm();
  
#line 936 
  tmp = fm10k_desc_unused(tx_ring);
  
#line 936 
  ;
  
#line 936 
  if ((long)((int)tmp < (int)size) != 0L) {
    
#line 937 
    __retres = -16;
    
#line 937 
    goto return_label;
  }
  else ;
  
#line 940 
  netif_start_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
  
#line 941 
  tx_ring->__anonCompField_fm10k_ring_99.tx_stats.restart_queue += 1ULL;
  
#line 942 
  __retres = 0;
  return_label: 
#line 942 
                return __retres;
}


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
__inline static int fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)
{
  int __retres;
  u16 tmp;
  int tmp_0;
  
#line 947 
  tmp = fm10k_desc_unused(tx_ring);
  
#line 947 
  ;
  
#line 947 
  if ((long)((int)tmp >= (int)size) != 0L) {
    
#line 948 
    __retres = 0;
    
#line 948 
    goto return_label;
  }
  else ;
  
#line 949 
  tmp_0 = __fm10k_maybe_stop_tx(tx_ring,(unsigned short)((int)size));
  
#line 949 
  __retres = tmp_0;
  return_label: 
#line 949 
                return __retres;
}


#line 952  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_tx_map(struct fm10k_ring *tx_ring, struct fm10k_tx_buffer *first)
{
  struct fm10k_tx_buffer *tx_buffer;
  struct fm10k_tx_desc *tx_desc;
  struct skb_frag_struct *frag;
  unsigned char *data;
  dma_addr_t dma;
  unsigned int data_len;
  unsigned int size;
  unsigned char *tmp_0;
  int tmp_1;
  bool tmp_4;
  u16 tmp_2;
  struct fm10k_tx_desc *tmp_3;
  bool tmp_7;
  u16 tmp_5;
  struct fm10k_tx_desc *tmp_6;
  bool tmp_9;
  u16 tmp_8;
  struct netdev_queue *tmp_10;
  bool tmp_12;
  struct netdev_queue *tmp_11;
  
#line 955 
  struct sk_buff *skb = first->skb;
  
#line 962 
  u32 tx_flags = (unsigned int)first->tx_flags;
  
#line 963 
  u16 i = tx_ring->next_to_use;
  
#line 964 
  u8 flags = fm10k_tx_desc_flags(skb,tx_flags);
  
#line 966 
  tx_desc = (struct fm10k_tx_desc *)tx_ring->desc + (int)i;
  
#line 969 
  if (((int)skb->vlan_tci & 4096) != 0) 
#line 970 
                                        tx_desc->vlan = (unsigned short)((unsigned int)skb->vlan_tci & 61439U); else 
                                                                    
#line 972 
                                                                    tx_desc->vlan = (unsigned short)0U;
  
#line 974 
  size = skb_headlen((struct sk_buff const *)skb);
  
#line 975 
  data = skb->data;
  
#line 977 
  dma = dma_map_single_attrs(tx_ring->dev,(void *)data,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 979 
  data_len = skb->data_len;
  
#line 980 
  tx_buffer = first;
  
#line 982 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 982 
  frag = & ((struct skb_shared_info *)tmp_0)->frags[0];
  ldv_56988: 
#line 983 
  ;
  
#line 983 
  tmp_1 = dma_mapping_error(tx_ring->dev,dma);
  
#line 983 
  if (tmp_1 != 0) 
#line 984 
                  goto dma_error; else ;
  
#line 987 
  tx_buffer->len = size;
  
#line 988 
  tx_buffer->dma = dma;
  
#line 990 
  goto ldv_56985;
  ldv_56984: 
#line 991 
  ;
  
#line 991 
  ;
  
#line 991 
  ;
  
#line 991 
  tmp_2 = i;
  
#line 991 
  i = (u16)((int)i + 1);
  
#line 991 
  ;
  
#line 991 
  tmp_3 = tx_desc;
  
#line 991 
  tx_desc += 1;
  
#line 991 
  ;
  
#line 991 
  ;
  
#line 991 
  tmp_4 = fm10k_tx_desc_push(tx_ring,tmp_3,(unsigned short)((int)tmp_2),dma,16384U,(unsigned char)((int)flags));
  
#line 991 
  if ((int)tmp_4 != 0) {
    
#line 993 
    tx_desc = (struct fm10k_tx_desc *)tx_ring->desc;
    
#line 994 
    i = (unsigned short)0U;
  }
  else ;
  
#line 997 
  dma += 16384ULL;
  
#line 998 
  size += 4294950912U;
  ldv_56985: 
#line 999 
  ;
  
#line 990 
  if ((long)(size > 16384U) != 0L) 
#line 992 
                                   goto ldv_56984; else 
#line 995 
                                                        goto ldv_56986;
  ldv_56986: 
#line 996 
  ;
  
#line 1001 
  if ((long)(data_len == 0U) != 0L) 
#line 1002 
                                    goto ldv_56987; else ;
  
#line 1004 
  ;
  
#line 1004 
  ;
  
#line 1004 
  ;
  
#line 1004 
  tmp_5 = i;
  
#line 1004 
  i = (u16)((int)i + 1);
  
#line 1004 
  ;
  
#line 1004 
  tmp_6 = tx_desc;
  
#line 1004 
  tx_desc += 1;
  
#line 1004 
  ;
  
#line 1004 
  ;
  
#line 1004 
  tmp_7 = fm10k_tx_desc_push(tx_ring,tmp_6,(unsigned short)((int)tmp_5),dma,size,(unsigned char)((int)flags));
  
#line 1004 
  if ((int)tmp_7 != 0) {
    
#line 1006 
    tx_desc = (struct fm10k_tx_desc *)tx_ring->desc;
    
#line 1007 
    i = (unsigned short)0U;
  }
  else ;
  
#line 1010 
  size = skb_frag_size((skb_frag_t const *)frag);
  
#line 1011 
  data_len -= size;
  
#line 1013 
  dma = skb_frag_dma_map(tx_ring->dev,(skb_frag_t const *)frag,0UL,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE);
  
#line 1016 
  tx_buffer = tx_ring->__anonCompField_fm10k_ring_97.tx_buffer + (int)i;
  
#line 982 
  frag += 1;
  
#line 983 
  goto ldv_56988;
  ldv_56987: 
#line 984 
  ;
  
#line 1020 
  flags = (unsigned char)((unsigned int)flags | 64U);
  
#line 1022 
  ;
  
#line 1022 
  ;
  
#line 1022 
  ;
  
#line 1022 
  tmp_8 = i;
  
#line 1022 
  i = (u16)((int)i + 1);
  
#line 1022 
  ;
  
#line 1022 
  ;
  
#line 1022 
  ;
  
#line 1022 
  tmp_9 = fm10k_tx_desc_push(tx_ring,tx_desc,(unsigned short)((int)tmp_8),dma,size,(unsigned char)((int)flags));
  
#line 1022 
  if ((int)tmp_9 != 0) 
#line 1023 
                       i = (unsigned short)0U; else ;
  
#line 1026 
  ;
  
#line 1026 
  tmp_10 = txring_txq((struct fm10k_ring const *)tx_ring);
  
#line 1026 
  netdev_tx_sent_queue(tmp_10,first->bytecount);
  
#line 1029 
  skb_tx_timestamp(first->skb);
  
#line 1030 
  ldv_inline_asm();
  
#line 1041 
  first->next_to_watch = tx_desc;
  
#line 1043 
  tx_ring->next_to_use = i;
  
#line 1046 
  fm10k_maybe_stop_tx(tx_ring,(unsigned short)21);
  
#line 1049 
  tmp_11 = txring_txq((struct fm10k_ring const *)tx_ring);
  
#line 1049 
  tmp_12 = netif_xmit_stopped((struct netdev_queue const *)tmp_11);
  
#line 1049 
  if ((int)tmp_12 != 0) 
#line 1049 
                        goto _LOR;
  else 
    
#line 1049 
    if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) {
      _LOR: {
              
#line 1050 
              writel((unsigned int)i,(void volatile *)tx_ring->tail);
              
#line 1051 
              ldv_inline_asm();
            }
    }
    else ;
  
#line 1058 
  goto return_label;
  dma_error: 
#line 1059 
  ;
  
#line 1060 
  dev_err((struct device const *)tx_ring->dev,"TX DMA map failed\n");
  ldv_56990: 
#line 1061 
  ;
  
#line 1064 
  tx_buffer = tx_ring->__anonCompField_fm10k_ring_97.tx_buffer + (int)i;
  
#line 1065 
  fm10k_unmap_and_free_tx_resource(tx_ring,tx_buffer);
  
#line 1066 
  if (tx_buffer == first) 
#line 1067 
                          goto ldv_56989; else ;
  
#line 1068 
  if ((unsigned int)i == 0U) 
#line 1069 
                             i = tx_ring->count; else ;
  
#line 1070 
  i = (u16)((int)i - 1);
  
#line 1064 
  goto ldv_56990;
  ldv_56989: 
#line 1065 
  ;
  
#line 1073 
  tx_ring->next_to_use = i;
  return_label: 
#line 1074 
                return;
}


#line 1076  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
netdev_tx_t fm10k_xmit_frame_ring(struct sk_buff *skb, struct fm10k_ring *tx_ring)
{
  netdev_tx_t __retres;
  struct fm10k_tx_buffer *first;
  int tso;
  unsigned int tmp;
  unsigned char *tmp_0;
  int tmp_1;
  unsigned int tmp_3;
  
#line 1081 
  u32 tx_flags = 0U;
  
#line 1085 
  tmp = skb_headlen((struct sk_buff const *)skb);
  
#line 1085 
  u16 count = (unsigned short)((tmp + 16383U) / 16384U);
  
#line 1096 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1096 
  count = (unsigned short)((int)((unsigned short)((struct skb_shared_info *)tmp_0)->nr_frags) + (int)count);
  
#line 1098 
  tmp_1 = fm10k_maybe_stop_tx(tx_ring,(unsigned short)((int)((unsigned int)count + 3U)));
  
#line 1098 
  if (tmp_1 != 0) {
    
#line 1099 
    tx_ring->__anonCompField_fm10k_ring_99.tx_stats.tx_busy += 1ULL;
    
#line 1100 
    __retres = NETDEV_TX_BUSY;
    
#line 1100 
    goto return_label;
  }
  else ;
  
#line 1104 
  first = tx_ring->__anonCompField_fm10k_ring_97.tx_buffer + (int)tx_ring->next_to_use;
  
#line 1105 
  first->skb = skb;
  {
    unsigned int tmp_2;
    
#line 1106 
    unsigned int __max1 = skb->len;
    
#line 1106 
    unsigned int __max2 = 60U;
    
#line 1106 
    if (__max1 > __max2) 
#line 1106 
                         tmp_2 = __max1; else 
#line 1106 
                                              tmp_2 = __max2;
    
#line 1106 
    tmp_3 = tmp_2;
  }
  
#line 1106 
  first->bytecount = tmp_3;
  
#line 1107 
  first->gso_segs = (unsigned short)1U;
  
#line 1110 
  first->tx_flags = (unsigned short)tx_flags;
  
#line 1112 
  tso = fm10k_tso(tx_ring,first);
  
#line 1113 
  if (tso < 0) 
#line 1114 
               goto out_drop;
  else 
    
#line 1115 
    if (tso == 0) 
#line 1116 
                  fm10k_tx_csum(tx_ring,first); else ;
  
#line 1118 
  fm10k_tx_map(tx_ring,first);
  
#line 1120 
  __retres = NETDEV_TX_OK;
  
#line 1120 
  goto return_label;
  out_drop: 
#line 1122 
  ;
  
#line 1123 
  dev_kfree_skb_any(first->skb);
  
#line 1124 
  first->skb = (struct sk_buff *)0;
  
#line 1126 
  __retres = NETDEV_TX_OK;
  return_label: 
#line 1126 
                return __retres;
}


#line 1129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static u64 fm10k_get_tx_completed(struct fm10k_ring *ring)
{
  u64 __retres;
  
#line 1131 
  __retres = ring->stats.packets;
  
#line 1131 
  return __retres;
}


#line 1134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static u64 fm10k_get_tx_pending(struct fm10k_ring *ring)
{
  u64 __retres;
  unsigned int tmp;
  
#line 1137 
  u32 head = (unsigned int)ring->next_to_clean;
  
#line 1138 
  u32 tail = (unsigned int)ring->next_to_use;
  
#line 1140 
  if (head > tail) 
#line 1140 
                   tmp = (unsigned int)ring->count + tail; else 
#line 1140 
                                                                tmp = tail;
  
#line 1140 
  ;
  
#line 1140 
  __retres = (unsigned long long)(tmp - head);
  
#line 1140 
  return __retres;
}


#line 1143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
bool fm10k_check_tx_hang(struct fm10k_ring *tx_ring)
{
  bool __retres;
  u64 tmp;
  u64 tmp_0;
  int tmp_1;
  
#line 1145 
  tmp = fm10k_get_tx_completed(tx_ring);
  
#line 1145 
  u32 tx_done = (unsigned int)tmp;
  
#line 1146 
  u32 tx_done_old = (unsigned int)tx_ring->__anonCompField_fm10k_ring_99.tx_stats.tx_done_old;
  
#line 1147 
  tmp_0 = fm10k_get_tx_pending(tx_ring);
  
#line 1147 
  u32 tx_pending = (unsigned int)tmp_0;
  
#line 1149 
  clear_bit(0L,(unsigned long volatile *)(& tx_ring->state));
  
#line 1159 
  if (tx_pending == 0U || tx_done_old != tx_done) {
    
#line 1161 
    tx_ring->__anonCompField_fm10k_ring_99.tx_stats.tx_done_old = (unsigned long long)tx_done;
    
#line 1163 
    clear_bit(1L,(unsigned long volatile *)(& tx_ring->state));
    
#line 1165 
    __retres = (_Bool)0;
    
#line 1165 
    goto return_label;
  }
  else ;
  
#line 1169 
  tmp_1 = test_and_set_bit(1L,(unsigned long volatile *)(& tx_ring->state));
  
#line 1169 
  __retres = (_Bool)(tmp_1 != 0);
  return_label: 
#line 1169 
                return __retres;
}


#line 1176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
void fm10k_tx_timeout_reset(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 1179 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& interface->state));
  
#line 1179 
  if (tmp == 0) {
    
#line 1180 
    interface->tx_timeout_count += 1U;
    
#line 1181 
    interface->flags |= 1U;
    
#line 1182 
    fm10k_service_event_schedule(interface);
  }
  else ;
  
#line 1184 
  return;
}


#line 1191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_clean_tx_irq(struct fm10k_q_vector *q_vector, struct fm10k_ring *tx_ring)
{
  bool __retres;
  struct fm10k_tx_buffer *tx_buffer;
  struct fm10k_tx_desc *tx_desc;
  int tmp;
  int tmp_2;
  struct netdev_queue *tmp_4;
  int tmp_8;
  
#line 1194 
  struct fm10k_intfc *interface = q_vector->interface;
  
#line 1197 
  unsigned int total_bytes = 0U;
  
#line 1197 
  unsigned int total_packets = 0U;
  
#line 1198 
  unsigned int budget = (unsigned int)q_vector->tx.work_limit;
  
#line 1199 
  unsigned int i = (unsigned int)tx_ring->next_to_clean;
  
#line 1201 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& interface->state));
  
#line 1201 
  if (tmp != 0) {
    
#line 1202 
    __retres = (_Bool)1;
    
#line 1202 
    goto return_label;
  }
  else ;
  
#line 1204 
  tx_buffer = tx_ring->__anonCompField_fm10k_ring_97.tx_buffer + i;
  
#line 1205 
  tx_desc = (struct fm10k_tx_desc *)tx_ring->desc + i;
  
#line 1206 
  i -= (unsigned int)tx_ring->count;
  ldv_57036: 
#line 1207 
  ;
  {
    
#line 1209 
    struct fm10k_tx_desc *eop_desc = tx_buffer->next_to_watch;
    
#line 1212 
    if (eop_desc == (struct fm10k_tx_desc *)0) 
#line 1213 
                                               goto ldv_57032; else ;
    
#line 1219 
    if ((int)eop_desc->flags >= 0) 
#line 1220 
                                   goto ldv_57032; else ;
    
#line 1223 
    tx_buffer->next_to_watch = (struct fm10k_tx_desc *)0;
    
#line 1226 
    total_bytes = tx_buffer->bytecount + total_bytes;
    
#line 1227 
    total_packets = (unsigned int)tx_buffer->gso_segs + total_packets;
    
#line 1230 
    dev_consume_skb_any(tx_buffer->skb);
    
#line 1233 
    dma_unmap_single_attrs(tx_ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 1239 
    tx_buffer->skb = (struct sk_buff *)0;
    
#line 1240 
    tx_buffer->len = 0U;
    
#line 1243 
    goto ldv_57034;
    ldv_57033: 
#line 1244 
    ;
    
#line 1244 
    tx_buffer += 1;
    
#line 1245 
    tx_desc += 1;
    
#line 1246 
    i += 1U;
    
#line 1247 
    if ((long)(i == 0U) != 0L) {
      
#line 1248 
      i -= (unsigned int)tx_ring->count;
      
#line 1249 
      tx_buffer = tx_ring->__anonCompField_fm10k_ring_97.tx_buffer;
      
#line 1250 
      tx_desc = (struct fm10k_tx_desc *)tx_ring->desc;
    }
    else ;
    
#line 1254 
    if (tx_buffer->len != 0U) {
      
#line 1255 
      dma_unmap_page(tx_ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE);
      
#line 1259 
      tx_buffer->len = 0U;
    }
    else ;
    ldv_57034: 
#line 1261 
    ;
    
#line 1243 
    if (tx_desc != eop_desc) 
#line 1245 
                             goto ldv_57033; else 
#line 1248 
                                                  goto ldv_57035;
    ldv_57035: 
#line 1249 
    ;
    
#line 1264 
    tx_buffer += 1;
    
#line 1265 
    tx_desc += 1;
    
#line 1266 
    i += 1U;
    
#line 1267 
    if ((long)(i == 0U) != 0L) {
      
#line 1268 
      i -= (unsigned int)tx_ring->count;
      
#line 1269 
      tx_buffer = tx_ring->__anonCompField_fm10k_ring_97.tx_buffer;
      
#line 1270 
      tx_desc = (struct fm10k_tx_desc *)tx_ring->desc;
    }
    else ;
    
#line 1274 
    __builtin_prefetch((void const *)tx_desc);
    
#line 1277 
    budget -= 1U;
  }
  
#line 1278 
  if ((long)(budget != 0U) != 0L) 
#line 1280 
                                  goto ldv_57036; else 
#line 1283 
                                                       goto ldv_57032;
  ldv_57032: 
#line 1284 
  ;
  
#line 1280 
  i = (unsigned int)tx_ring->count + i;
  
#line 1281 
  tx_ring->next_to_clean = (unsigned short)i;
  
#line 1282 
  u64_stats_init(& tx_ring->syncp);
  
#line 1283 
  tx_ring->stats.bytes += (unsigned long long)total_bytes;
  
#line 1284 
  tx_ring->stats.packets += (unsigned long long)total_packets;
  
#line 1285 
  u64_stats_init(& tx_ring->syncp);
  
#line 1286 
  q_vector->tx.total_bytes += total_bytes;
  
#line 1287 
  q_vector->tx.total_packets += total_packets;
  
#line 1289 
  tmp_2 = constant_test_bit(0L,(unsigned long const volatile *)(& tx_ring->state));
  
#line 1289 
  if (tmp_2 != 0) {
    bool tmp_3;
    
#line 1289 
    tmp_3 = fm10k_check_tx_hang(tx_ring);
    
#line 1289 
    if ((int)tmp_3 != 0) {
      
#line 1291 
      struct fm10k_hw *hw = & interface->hw;
      
#line 1293 
      if (((int)interface->msg_enable & 1) != 0) {
        u32 tmp_0;
        u32 tmp_1;
        
#line 1293 
        ;
        
#line 1293 
        ;
        
#line 1293 
        tmp_0 = fm10k_read_reg(hw,(int)tx_ring->reg_idx * 64 + 32773);
        
#line 1293 
        tmp_1 = fm10k_read_reg(hw,(int)tx_ring->reg_idx * 64 + 32772);
        
#line 1293 
        ;
        
#line 1293 
        ;
        
#line 1293 
        netdev_err((struct net_device const *)tx_ring->netdev,"Detected Tx Unit Hang\n",(int)tx_ring->queue_index,tmp_1,tmp_0,(int)tx_ring->next_to_use,i);
      }
      else ;
      
#line 1304 
      netif_start_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
      
#line 1307 
      if (((int)interface->msg_enable & 2) != 0) 
#line 1307 
                                                 netdev_info((struct net_device const *)tx_ring->netdev,"tx hang %d detected on queue %d, resetting interface\n",interface->tx_timeout_count + 1U,(int)tx_ring->queue_index); else ;
      
#line 1312 
      fm10k_tx_timeout_reset(interface);
      
#line 1315 
      __retres = (_Bool)1;
      
#line 1315 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1319 
  ;
  
#line 1319 
  ;
  
#line 1319 
  tmp_4 = txring_txq((struct fm10k_ring const *)tx_ring);
  
#line 1319 
  netdev_tx_completed_queue(tmp_4,total_packets,total_bytes);
  
#line 1323 
  if ((long)(total_packets != 0U) != 0L) {
    bool tmp_7;
    
#line 1323 
    tmp_7 = netif_carrier_ok((struct net_device const *)tx_ring->netdev);
    
#line 1323 
    if ((long)((int)tmp_7 != 0) != 0L) 
#line 1323 
                                       tmp_8 = 1; else 
#line 1323 
                                                       tmp_8 = 0;
  }
  else 
#line 1323 
       tmp_8 = 0;
  
#line 1323 
  if (tmp_8 != 0) {
    u16 tmp_9;
    int tmp_11;
    
#line 1323 
    tmp_9 = fm10k_desc_unused(tx_ring);
    {
      int tmp_10;
      
#line 1323 
      u16 __min1 = (unsigned short)127U;
      
#line 1323 
      u16 __min2 = (unsigned short)42U;
      
#line 1323 
      if ((int)__min1 < (int)__min2) 
#line 1323 
                                     tmp_10 = (int)__min1; else 
#line 1323 
                                                                tmp_10 = (int)__min2;
      
#line 1323 
      tmp_11 = tmp_10;
    }
    
#line 1323 
    if ((long)((int)tmp_9 >= tmp_11) != 0L) {
      bool tmp_5;
      
#line 1326 
      ldv_inline_asm();
      
#line 1329 
      tmp_5 = __netif_subqueue_stopped((struct net_device const *)tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
      
#line 1329 
      if ((int)tmp_5 != 0) {
        int tmp_6;
        
#line 1330 
        tmp_6 = constant_test_bit(1L,(unsigned long const volatile *)(& interface->state));
        
#line 1330 
        if (tmp_6 == 0) {
          
#line 1332 
          netif_wake_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
          
#line 1334 
          tx_ring->__anonCompField_fm10k_ring_99.tx_stats.restart_queue += 1ULL;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1338 
  __retres = (_Bool)(budget != 0U);
  return_label: 
#line 1338 
                return __retres;
}


#line 1351  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_update_itr(struct fm10k_ring_container *ring_container)
{
  unsigned int avg_wire_size;
  unsigned int packets;
  
#line 1356 
  if ((int)ring_container->itr >= 0) 
#line 1357 
                                     goto clear_counts; else ;
  
#line 1359 
  packets = ring_container->total_packets;
  
#line 1360 
  if (packets == 0U) 
#line 1361 
                     goto clear_counts; else ;
  
#line 1363 
  avg_wire_size = ring_container->total_bytes / packets;
  
#line 1366 
  avg_wire_size += 24U;
  
#line 1369 
  if (avg_wire_size > 3000U) 
#line 1370 
                             avg_wire_size = 3000U; else ;
  
#line 1373 
  if (avg_wire_size + 4294966995U <= 898U) 
#line 1374 
                                           avg_wire_size /= 3U; else 
                                                                  
#line 1376 
                                                                  avg_wire_size /= 2U;
  
#line 1379 
  ring_container->itr = (unsigned short)((unsigned int)((unsigned short)avg_wire_size) | 32768U);
  clear_counts: 
#line 1381 
  ;
  
#line 1382 
  ring_container->total_bytes = 0U;
  
#line 1383 
  ring_container->total_packets = 0U;
  
#line 1384 
  return;
}


#line 1386  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_qv_enable(struct fm10k_q_vector *q_vector)
{
  
#line 1389 
  u32 itr = 2684354560U;
  
#line 1392 
  fm10k_update_itr(& q_vector->tx);
  
#line 1395 
  fm10k_update_itr(& q_vector->rx);
  
#line 1398 
  itr = ((unsigned int)q_vector->tx.itr & 4095U) | itr;
  
#line 1401 
  itr = ((unsigned int)((int)q_vector->rx.itr << 12) & 16773120U) | itr;
  
#line 1404 
  writel(itr,(void volatile *)q_vector->itr);
  
#line 1405 
  return;
}


#line 1407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static int fm10k_poll(struct napi_struct *napi, int budget)
{
  int __retres;
  struct fm10k_q_vector *tmp;
  struct fm10k_ring *ring;
  int per_ring_budget;
  bool tmp_0;
  bool tmp_3;
  {
    
#line 1410 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 1410 
    tmp = (struct fm10k_q_vector *)__mptr + 18446744073709551544U;
  }
  
#line 1409 
  struct fm10k_q_vector *q_vector = tmp;
  
#line 1413 
  bool clean_complete = (_Bool)1;
  
#line 1415 
  ring = q_vector->tx.ring + (int)q_vector->tx.count;
  
#line 1415 
  goto ldv_57062;
  ldv_57061: 
#line 1416 
  ;
  
#line 1416 
  tmp_0 = fm10k_clean_tx_irq(q_vector,ring);
  
#line 1416 
  clean_complete = (_Bool)(((int)clean_complete & (int)tmp_0) != 0);
  ldv_57062: 
#line 1417 
  ;
  
#line 1415 
  ring -= 1;
  
#line 1415 
  ;
  
#line 1415 
  if (ring >= q_vector->tx.ring) 
#line 1417 
                                 goto ldv_57061; else 
#line 1420 
                                                      goto ldv_57063;
  ldv_57063: 
#line 1421 
  ;
  
#line 1421 
  if ((unsigned int)q_vector->rx.count > 1U) {
    int tmp_2;
    {
      int tmp_1;
      
#line 1422 
      int _max1 = budget / (int)q_vector->rx.count;
      
#line 1422 
      int _max2 = 1;
      
#line 1422 
      if (_max1 > _max2) 
#line 1422 
                         tmp_1 = _max1; else 
#line 1422 
                                             tmp_1 = _max2;
      
#line 1422 
      tmp_2 = tmp_1;
    }
    
#line 1422 
    per_ring_budget = tmp_2;
  }
  else 
#line 1424 
       per_ring_budget = budget;
  
#line 1426 
  ring = q_vector->rx.ring + (int)q_vector->rx.count;
  
#line 1426 
  goto ldv_57068;
  ldv_57067: 
#line 1427 
  ;
  
#line 1427 
  tmp_3 = fm10k_clean_rx_irq(q_vector,ring,per_ring_budget);
  
#line 1428 
  clean_complete = (_Bool)(((int)clean_complete & (int)tmp_3) != 0);
  ldv_57068: 
#line 1428 
  ;
  
#line 1426 
  ring -= 1;
  
#line 1426 
  ;
  
#line 1426 
  if (ring >= q_vector->rx.ring) 
#line 1428 
                                 goto ldv_57067; else 
#line 1431 
                                                      goto ldv_57069;
  ldv_57069: 
#line 1432 
  ;
  
#line 1431 
  if (! clean_complete) {
    
#line 1432 
    __retres = budget;
    
#line 1432 
    goto return_label;
  }
  else ;
  
#line 1435 
  napi_complete(napi);
  
#line 1438 
  fm10k_qv_enable(q_vector);
  
#line 1440 
  __retres = 0;
  return_label: 
#line 1440 
                return __retres;
}


#line 1454  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_set_qos_queues(struct fm10k_intfc *interface)
{
  bool __retres;
  struct fm10k_ring_feature *f;
  int rss_i;
  int i;
  int pcs;
  int tmp;
  int tmp_0;
  int tmp_2;
  int tmp_3;
  
#line 1456 
  struct net_device *dev = interface->netdev;
  
#line 1462 
  pcs = netdev_get_num_tc(dev);
  
#line 1464 
  if (pcs <= 1) {
    
#line 1465 
    __retres = (_Bool)0;
    
#line 1465 
    goto return_label;
  }
  else ;
  
#line 1468 
  f = & interface->ring_feature[1];
  
#line 1469 
  f->indices = (unsigned short)pcs;
  
#line 1470 
  tmp = fls(pcs + -1);
  
#line 1470 
  f->mask = (unsigned short)((unsigned int)((unsigned short)(1 << tmp)) + 65535U);
  
#line 1473 
  rss_i = (int)interface->hw.mac.max_queues / pcs;
  
#line 1474 
  tmp_0 = fls(rss_i);
  
#line 1474 
  rss_i = 1 << (tmp_0 + -1);
  
#line 1477 
  f = & interface->ring_feature[0];
  {
    int tmp_1;
    
#line 1478 
    u16 __min1 = (unsigned short)rss_i;
    
#line 1478 
    u16 __min2 = f->limit;
    
#line 1478 
    if ((int)__min1 < (int)__min2) 
#line 1478 
                                   tmp_1 = (int)__min1; else 
#line 1478 
                                                             tmp_1 = (int)__min2;
    
#line 1478 
    tmp_2 = tmp_1;
  }
  
#line 1478 
  rss_i = tmp_2;
  
#line 1479 
  f->indices = (unsigned short)rss_i;
  
#line 1480 
  tmp_3 = fls(rss_i + -1);
  
#line 1480 
  f->mask = (unsigned short)((unsigned int)((unsigned short)(1 << tmp_3)) + 65535U);
  
#line 1483 
  i = 0;
  
#line 1483 
  goto ldv_57082;
  ldv_57081: 
#line 1484 
  ;
  
#line 1484 
  netdev_set_tc_queue(dev,(unsigned char)((int)((unsigned char)i)),(unsigned short)((int)((unsigned short)rss_i)),(unsigned short)((int)((unsigned short)rss_i) * (int)((unsigned short)i)));
  
#line 1483 
  i += 1;
  ldv_57082: 
#line 1484 
  ;
  
#line 1483 
  if (i < pcs) 
#line 1485 
               goto ldv_57081; else 
#line 1488 
                                    goto ldv_57083;
  ldv_57083: 
#line 1489 
  ;
  
#line 1486 
  interface->num_rx_queues = rss_i * pcs;
  
#line 1487 
  interface->num_tx_queues = rss_i * pcs;
  
#line 1489 
  __retres = (_Bool)1;
  return_label: 
#line 1489 
                return __retres;
}


#line 1500  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_set_rss_queues(struct fm10k_intfc *interface)
{
  bool __retres;
  struct fm10k_ring_feature *f;
  u16 rss_i;
  int tmp_0;
  int tmp_1;
  
#line 1505 
  f = & interface->ring_feature[0];
  {
    int tmp;
    
#line 1506 
    u16 __min1 = interface->hw.mac.max_queues;
    
#line 1506 
    u16 __min2 = f->limit;
    
#line 1506 
    if ((int)__min1 < (int)__min2) 
#line 1506 
                                   tmp = (int)__min1; else 
#line 1506 
                                                           tmp = (int)__min2;
    
#line 1506 
    tmp_0 = tmp;
  }
  
#line 1506 
  rss_i = (unsigned short)tmp_0;
  
#line 1509 
  f->indices = rss_i;
  
#line 1510 
  tmp_1 = fls((int)rss_i + -1);
  
#line 1510 
  f->mask = (unsigned short)((unsigned int)((unsigned short)(1 << tmp_1)) + 65535U);
  
#line 1512 
  interface->num_rx_queues = (int)rss_i;
  
#line 1513 
  interface->num_tx_queues = (int)rss_i;
  
#line 1515 
  __retres = (_Bool)1;
  
#line 1515 
  return __retres;
}


#line 1529  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_set_num_queues(struct fm10k_intfc *interface)
{
  bool tmp;
  
#line 1532 
  interface->num_rx_queues = 1;
  
#line 1533 
  interface->num_tx_queues = 1;
  
#line 1535 
  tmp = fm10k_set_qos_queues(interface);
  
#line 1535 
  if ((int)tmp != 0) 
#line 1536 
                     goto return_label; else ;
  
#line 1538 
  fm10k_set_rss_queues(interface);
  return_label: 
#line 1539 
                return;
}


#line 1621 
void __compiletime_assert_1621(void);


#line 1553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static int fm10k_alloc_q_vector(struct fm10k_intfc *interface, unsigned int v_count, unsigned int v_idx, unsigned int txr_count, unsigned int txr_idx, unsigned int rxr_count, unsigned int rxr_idx)
{
  int __retres;
  struct fm10k_q_vector *q_vector;
  struct fm10k_ring *ring;
  int ring_count;
  int size;
  struct fm10k_l2_accel * volatile *tmp_0;
  
#line 1562 
  ring_count = (int)(txr_count + rxr_count);
  
#line 1563 
  size = (int)(((unsigned long)ring_count + 1UL) * (unsigned long)4096U);
  
#line 1567 
  q_vector = (struct fm10k_q_vector *)kzalloc_1((unsigned long)size,208U);
  
#line 1568 
  if (q_vector == (struct fm10k_q_vector *)0) {
    
#line 1569 
    __retres = -12;
    
#line 1569 
    goto return_label;
  }
  else ;
  
#line 1572 
  netif_napi_add(interface->netdev,& q_vector->napi,& fm10k_poll,64);
  
#line 1576 
  interface->q_vector[v_idx] = q_vector;
  
#line 1577 
  q_vector->interface = interface;
  
#line 1578 
  q_vector->v_idx = (unsigned short)v_idx;
  
#line 1581 
  ring = (struct fm10k_ring *)(& q_vector->ring);
  
#line 1584 
  q_vector->tx.ring = ring;
  
#line 1585 
  q_vector->tx.work_limit = (unsigned short)256U;
  
#line 1586 
  q_vector->tx.itr = interface->tx_itr;
  
#line 1587 
  q_vector->tx.count = (unsigned char)txr_count;
  
#line 1589 
  goto ldv_57109;
  ldv_57108: 
#line 1590 
  ;
  
#line 1591 
  ring->dev = & (interface->pdev)->dev;
  
#line 1592 
  ring->netdev = interface->netdev;
  
#line 1595 
  ring->q_vector = q_vector;
  
#line 1598 
  ring->count = interface->tx_ring_count;
  
#line 1599 
  ring->queue_index = (unsigned char)txr_idx;
  
#line 1602 
  interface->tx_ring[txr_idx] = ring;
  
#line 1605 
  txr_count -= 1U;
  
#line 1606 
  txr_idx += v_count;
  
#line 1609 
  ring += 1;
  ldv_57109: 
#line 1610 
  ;
  
#line 1589 
  if (txr_count != 0U) 
#line 1591 
                       goto ldv_57108; else 
#line 1594 
                                            goto ldv_57110;
  ldv_57110: 
#line 1595 
  ;
  
#line 1613 
  q_vector->rx.ring = ring;
  
#line 1614 
  q_vector->rx.itr = interface->rx_itr;
  
#line 1615 
  q_vector->rx.count = (unsigned char)rxr_count;
  
#line 1617 
  goto ldv_57118;
  ldv_57117: 
#line 1618 
  ;
  
#line 1619 
  ring->dev = & (interface->pdev)->dev;
  
#line 1620 
  ring->netdev = interface->netdev;
  {
    
#line 1621 
    bool __cond = (_Bool)0;
    
#line 1621 
    if ((int)__cond != 0) 
#line 1621 
                          __compiletime_assert_1621(); else ;
  }
  
#line 1623 
  ldv_inline_asm();
  {
    
#line 1621 
    struct fm10k_l2_accel *__var = (struct fm10k_l2_accel *)0;
    
#line 1621 
    tmp_0 = (struct fm10k_l2_accel * volatile *)(& ring->l2_accel);
  }
  
#line 1621 
  *tmp_0 = interface->l2_accel;
  
#line 1624 
  ring->q_vector = q_vector;
  
#line 1627 
  ring->count = interface->rx_ring_count;
  
#line 1628 
  ring->queue_index = (unsigned char)rxr_idx;
  
#line 1631 
  interface->rx_ring[rxr_idx] = ring;
  
#line 1634 
  rxr_count -= 1U;
  
#line 1635 
  rxr_idx += v_count;
  
#line 1638 
  ring += 1;
  ldv_57118: 
#line 1639 
  ;
  
#line 1617 
  if (rxr_count != 0U) 
#line 1619 
                       goto ldv_57117; else 
#line 1622 
                                            goto ldv_57119;
  ldv_57119: 
#line 1623 
  ;
  
#line 1641 
  fm10k_dbg_q_vector_init(q_vector);
  
#line 1643 
  __retres = 0;
  return_label: 
#line 1643 
                return __retres;
}


#line 1670 
void __compiletime_assert_1670(void);


#line 1655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_free_q_vector(struct fm10k_intfc *interface, int v_idx)
{
  struct fm10k_ring *ring;
  
#line 1657 
  struct fm10k_q_vector *q_vector = interface->q_vector[v_idx];
  
#line 1660 
  fm10k_dbg_q_vector_exit(q_vector);
  
#line 1662 
  ring = q_vector->tx.ring + (int)q_vector->tx.count;
  
#line 1662 
  goto ldv_57127;
  ldv_57126: 
#line 1663 
  ;
  
#line 1663 
  interface->tx_ring[(int)ring->queue_index] = (struct fm10k_ring *)0;
  ldv_57127: 
#line 1664 
  ;
  
#line 1662 
  ring -= 1;
  
#line 1662 
  ;
  
#line 1662 
  if (ring >= q_vector->tx.ring) 
#line 1664 
                                 goto ldv_57126; else 
#line 1667 
                                                      goto ldv_57128;
  ldv_57128: 
#line 1668 
  ;
  
#line 1665 
  ring = q_vector->rx.ring + (int)q_vector->rx.count;
  
#line 1665 
  goto ldv_57130;
  ldv_57129: 
#line 1666 
  ;
  
#line 1666 
  interface->rx_ring[(int)ring->queue_index] = (struct fm10k_ring *)0;
  ldv_57130: 
#line 1667 
  ;
  
#line 1665 
  ring -= 1;
  
#line 1665 
  ;
  
#line 1665 
  if (ring >= q_vector->rx.ring) 
#line 1667 
                                 goto ldv_57129; else 
#line 1670 
                                                      goto ldv_57131;
  ldv_57131: 
#line 1671 
  ;
  
#line 1668 
  interface->q_vector[v_idx] = (struct fm10k_q_vector *)0;
  
#line 1669 
  netif_napi_del(& q_vector->napi);
  {
    
#line 1670 
    bool __cond = (_Bool)0;
    
#line 1670 
    if ((int)__cond != 0) 
#line 1670 
                          __compiletime_assert_1670(); else ;
  }
  
#line 1670 
  kfree_call_rcu(& q_vector->rcu,(void (*)(struct callback_head *))392);
  
#line 1671 
  return;
}


#line 1680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static int fm10k_alloc_q_vectors(struct fm10k_intfc *interface)
{
  int __retres;
  int err;
  unsigned int tmp;
  
#line 1682 
  unsigned int q_vectors = (unsigned int)interface->num_q_vectors;
  
#line 1683 
  unsigned int rxr_remaining = (unsigned int)interface->num_rx_queues;
  
#line 1684 
  unsigned int txr_remaining = (unsigned int)interface->num_tx_queues;
  
#line 1685 
  unsigned int rxr_idx = 0U;
  
#line 1685 
  unsigned int txr_idx = 0U;
  
#line 1685 
  unsigned int v_idx = 0U;
  
#line 1688 
  if (rxr_remaining + txr_remaining <= q_vectors) {
    
#line 1689 
    goto ldv_57149;
    ldv_57148: 
#line 1690 
    ;
    
#line 1690 
    err = fm10k_alloc_q_vector(interface,q_vectors,v_idx,0U,0U,1U,rxr_idx);
    
#line 1692 
    if (err != 0) 
#line 1693 
                  goto err_out; else ;
    
#line 1696 
    rxr_remaining -= 1U;
    
#line 1697 
    rxr_idx += 1U;
    
#line 1689 
    v_idx += 1U;
    ldv_57149: 
#line 1690 
    ;
    
#line 1689 
    if (rxr_remaining != 0U) 
#line 1691 
                             goto ldv_57148; else 
#line 1694 
                                                  goto ldv_57150;
    ldv_57150: 
#line 1695 
    ;
  }
  else ;
  
#line 1701 
  goto ldv_57154;
  ldv_57153: 
#line 1702 
  ;
  {
    
#line 1702 
    int rqpv = (int)((((q_vectors - v_idx) + rxr_remaining) + 4294967295U) / (q_vectors - v_idx));
    
#line 1703 
    int tqpv = (int)((((q_vectors - v_idx) + txr_remaining) + 4294967295U) / (q_vectors - v_idx));
    
#line 1705 
    err = fm10k_alloc_q_vector(interface,q_vectors,v_idx,(unsigned int)tqpv,txr_idx,(unsigned int)rqpv,rxr_idx);
    
#line 1709 
    if (err != 0) 
#line 1710 
                  goto err_out; else ;
    
#line 1713 
    rxr_remaining -= (unsigned int)rqpv;
    
#line 1714 
    txr_remaining -= (unsigned int)tqpv;
    
#line 1715 
    rxr_idx += 1U;
    
#line 1716 
    txr_idx += 1U;
  }
  
#line 1701 
  v_idx += 1U;
  ldv_57154: 
#line 1702 
  ;
  
#line 1701 
  if (v_idx < q_vectors) 
#line 1703 
                         goto ldv_57153; else 
#line 1706 
                                              goto ldv_57155;
  ldv_57155: 
#line 1707 
  ;
  
#line 1719 
  __retres = 0;
  
#line 1719 
  goto return_label;
  err_out: 
#line 1721 
  ;
  
#line 1722 
  interface->num_tx_queues = 0;
  
#line 1723 
  interface->num_rx_queues = 0;
  
#line 1724 
  interface->num_q_vectors = 0;
  
#line 1726 
  goto ldv_57157;
  ldv_57156: 
#line 1727 
  ;
  
#line 1727 
  fm10k_free_q_vector(interface,(int)v_idx);
  ldv_57157: 
#line 1728 
  ;
  
#line 1726 
  tmp = v_idx;
  
#line 1726 
  v_idx -= 1U;
  
#line 1726 
  ;
  
#line 1726 
  if (tmp != 0U) 
#line 1728 
                 goto ldv_57156; else 
#line 1731 
                                      goto ldv_57158;
  ldv_57158: 
#line 1732 
  ;
  
#line 1729 
  __retres = -12;
  return_label: 
#line 1729 
                return __retres;
}


#line 1740  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_free_q_vectors(struct fm10k_intfc *interface)
{
  int tmp;
  
#line 1742 
  int v_idx = interface->num_q_vectors;
  
#line 1744 
  interface->num_tx_queues = 0;
  
#line 1745 
  interface->num_rx_queues = 0;
  
#line 1746 
  interface->num_q_vectors = 0;
  
#line 1748 
  goto ldv_57164;
  ldv_57163: 
#line 1749 
  ;
  
#line 1749 
  fm10k_free_q_vector(interface,v_idx);
  ldv_57164: 
#line 1750 
  ;
  
#line 1748 
  tmp = v_idx;
  
#line 1748 
  v_idx -= 1;
  
#line 1748 
  ;
  
#line 1748 
  if (tmp != 0) 
#line 1750 
                goto ldv_57163; else 
#line 1753 
                                     goto ldv_57165;
  ldv_57165: 
#line 1754 
  ;
  
#line 1755 
  return;
}


#line 1758  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_reset_msix_capability(struct fm10k_intfc *interface)
{
  
#line 1760 
  pci_disable_msix(interface->pdev);
  
#line 1761 
  kfree((void const *)interface->msix_entries);
  
#line 1762 
  interface->msix_entries = (struct msix_entry *)0;
  
#line 1763 
  return;
}


#line 1772  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static int fm10k_init_msix_capability(struct fm10k_intfc *interface)
{
  int __retres;
  int v_budget;
  int vector;
  int tmp_0;
  int tmp_3;
  int tmp_5;
  
#line 1774 
  struct fm10k_hw *hw = & interface->hw;
  {
    int tmp;
    
#line 1783 
    int _max1 = interface->num_rx_queues;
    
#line 1783 
    int _max2 = interface->num_tx_queues;
    
#line 1783 
    if (_max1 > _max2) 
#line 1783 
                       tmp = _max1; else 
#line 1783 
                                         tmp = _max2;
    
#line 1783 
    tmp_0 = tmp;
  }
  
#line 1783 
  v_budget = tmp_0;
  {
    unsigned int tmp_1;
    int tmp_2;
    
#line 1784 
    u16 __min1 = (unsigned short)v_budget;
    
#line 1784 
    tmp_1 = cpumask_weight(cpu_online_mask);
    
#line 1784 
    u16 __min2 = (unsigned short)tmp_1;
    
#line 1784 
    if ((int)__min1 < (int)__min2) 
#line 1784 
                                   tmp_2 = (int)__min1; else 
#line 1784 
                                                             tmp_2 = (int)__min2;
    
#line 1784 
    tmp_3 = tmp_2;
  }
  
#line 1784 
  v_budget = tmp_3;
  
#line 1787 
  v_budget += 1;
  {
    int tmp_4;
    
#line 1795 
    int __min1_0 = v_budget;
    
#line 1795 
    int __min2_0 = (int)hw->mac.max_msix_vectors;
    
#line 1795 
    if (__min1_0 < __min2_0) 
#line 1795 
                             tmp_4 = __min1_0; else 
#line 1795 
                                                    tmp_4 = __min2_0;
    
#line 1795 
    tmp_5 = tmp_4;
  }
  
#line 1795 
  v_budget = tmp_5;
  
#line 1798 
  interface->msix_entries = (struct msix_entry *)kcalloc((unsigned long)v_budget,8UL,208U);
  
#line 1800 
  if (interface->msix_entries == (struct msix_entry *)0) {
    
#line 1801 
    __retres = -12;
    
#line 1801 
    goto return_label;
  }
  else ;
  
#line 1804 
  vector = 0;
  
#line 1804 
  goto ldv_57185;
  ldv_57184: 
#line 1805 
  ;
  
#line 1805 
  (interface->msix_entries + vector)->entry = (unsigned short)vector;
  
#line 1804 
  vector += 1;
  ldv_57185: 
#line 1805 
  ;
  
#line 1804 
  if (vector < v_budget) 
#line 1806 
                         goto ldv_57184; else 
#line 1809 
                                              goto ldv_57186;
  ldv_57186: 
#line 1810 
  ;
  
#line 1808 
  v_budget = pci_enable_msix_range(interface->pdev,interface->msix_entries,2,v_budget);
  
#line 1812 
  if (v_budget < 0) {
    
#line 1813 
    kfree((void const *)interface->msix_entries);
    
#line 1814 
    interface->msix_entries = (struct msix_entry *)0;
    
#line 1815 
    __retres = -12;
    
#line 1815 
    goto return_label;
  }
  else ;
  
#line 1819 
  interface->num_q_vectors = v_budget + -1;
  
#line 1821 
  __retres = 0;
  return_label: 
#line 1821 
                return __retres;
}


#line 1830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static bool fm10k_cache_ring_qos(struct fm10k_intfc *interface)
{
  bool __retres;
  int pc;
  int offset;
  int rss_i;
  int i;
  int q_idx;
  int tmp;
  
#line 1832 
  struct net_device *dev = interface->netdev;
  
#line 1834 
  u16 pc_stride = (unsigned short)((unsigned int)interface->ring_feature[1].mask + 1U);
  
#line 1835 
  tmp = netdev_get_num_tc(dev);
  
#line 1835 
  u8 num_pcs = (unsigned char)tmp;
  
#line 1837 
  if ((unsigned int)num_pcs <= 1U) {
    
#line 1838 
    __retres = (_Bool)0;
    
#line 1838 
    goto return_label;
  }
  else ;
  
#line 1840 
  rss_i = (int)interface->ring_feature[0].indices;
  
#line 1842 
  pc = 0;
  
#line 1842 
  offset = 0;
  
#line 1842 
  goto ldv_57202;
  ldv_57201: 
#line 1843 
  ;
  
#line 1843 
  q_idx = pc;
  
#line 1844 
  i = 0;
  
#line 1844 
  goto ldv_57199;
  ldv_57198: 
#line 1845 
  ;
  
#line 1845 
  (interface->tx_ring[offset + i])->reg_idx = (unsigned char)q_idx;
  
#line 1846 
  (interface->tx_ring[offset + i])->qos_pc = (unsigned char)pc;
  
#line 1847 
  (interface->rx_ring[offset + i])->reg_idx = (unsigned char)q_idx;
  
#line 1848 
  (interface->rx_ring[offset + i])->qos_pc = (unsigned char)pc;
  
#line 1849 
  q_idx = (int)pc_stride + q_idx;
  
#line 1844 
  i += 1;
  ldv_57199: 
#line 1845 
  ;
  
#line 1844 
  if (i < rss_i) 
#line 1846 
                 goto ldv_57198; else 
#line 1849 
                                      goto ldv_57200;
  ldv_57200: 
#line 1850 
  ;
  
#line 1842 
  pc += 1;
  
#line 1842 
  offset += rss_i;
  ldv_57202: 
#line 1843 
  ;
  
#line 1842 
  if ((int)num_pcs > pc) 
#line 1844 
                         goto ldv_57201; else 
#line 1847 
                                              goto ldv_57203;
  ldv_57203: 
#line 1848 
  ;
  
#line 1853 
  __retres = (_Bool)1;
  return_label: 
#line 1853 
                return __retres;
}


#line 1862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_cache_ring_rss(struct fm10k_intfc *interface)
{
  int i;
  
#line 1866 
  i = 0;
  
#line 1866 
  goto ldv_57209;
  ldv_57208: 
#line 1867 
  ;
  
#line 1867 
  (interface->rx_ring[i])->reg_idx = (unsigned char)i;
  
#line 1866 
  i += 1;
  ldv_57209: 
#line 1867 
  ;
  
#line 1866 
  if (interface->num_rx_queues > i) 
#line 1868 
                                    goto ldv_57208; else 
#line 1871 
                                                         goto ldv_57210;
  ldv_57210: 
#line 1872 
  ;
  
#line 1869 
  i = 0;
  
#line 1869 
  goto ldv_57212;
  ldv_57211: 
#line 1870 
  ;
  
#line 1870 
  (interface->tx_ring[i])->reg_idx = (unsigned char)i;
  
#line 1869 
  i += 1;
  ldv_57212: 
#line 1870 
  ;
  
#line 1869 
  if (interface->num_tx_queues > i) 
#line 1871 
                                    goto ldv_57211; else 
#line 1874 
                                                         goto ldv_57213;
  ldv_57213: 
#line 1875 
  ;
  
#line 1876 
  return;
}


#line 1881  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_assign_rings(struct fm10k_intfc *interface)
{
  bool tmp;
  
#line 1883 
  tmp = fm10k_cache_ring_qos(interface);
  
#line 1883 
  if ((int)tmp != 0) 
#line 1884 
                     goto return_label; else ;
  
#line 1886 
  fm10k_cache_ring_rss(interface);
  return_label: 
#line 1887 
                return;
}


#line 1889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
static void fm10k_init_reta(struct fm10k_intfc *interface)
{
  u16 i;
  u32 reta;
  u32 base;
  u16 tmp_0;
  
#line 1891 
  u16 rss_i = interface->ring_feature[0].indices;
  
#line 1895 
  if ((unsigned int)(interface->netdev)->reg_state != 0U) {
    u16 tmp;
    
#line 1896 
    i = (unsigned short)32U;
    
#line 1896 
    goto ldv_57224;
    ldv_57226: 
#line 1897 
    ;
    
#line 1897 
    reta = interface->reta[(int)i];
    
#line 1898 
    if ((((reta & 255U) < (unsigned int)rss_i && (reta << 16) >> 24 < (unsigned int)rss_i) && (reta << 8) >> 24 < (unsigned int)rss_i) && reta >> 24 < (unsigned int)rss_i) 
      
#line 1902 
      goto ldv_57224; else ;
    
#line 1903 
    goto repopulate_reta;
    ldv_57224: 
#line 1904 
    ;
    
#line 1896 
    tmp = i;
    
#line 1896 
    i = (u16)((int)i - 1);
    
#line 1896 
    ;
    
#line 1896 
    if ((unsigned int)tmp != 0U) 
#line 1898 
                                 goto ldv_57226; else 
#line 1901 
                                                      goto ldv_57227;
    ldv_57227: 
#line 1902 
    ;
    
#line 1907 
    goto return_label;
  }
  else ;
  repopulate_reta: 
#line 1910 
  ;
  
#line 1915 
  i = (unsigned short)32U;
  
#line 1915 
  goto ldv_57229;
  ldv_57228: 
#line 1916 
  ;
  
#line 1917 
  base = (unsigned int)(((int)i * 262148 + 131072) * (int)rss_i);
  
#line 1918 
  reta = (base >> 7) & 8323199U;
  
#line 1921 
  base = (unsigned int)((int)rss_i * 65537) + base;
  
#line 1922 
  reta = ((base << 1) & 2130738944U) | reta;
  
#line 1924 
  interface->reta[(int)i] = reta;
  ldv_57229: 
#line 1925 
  ;
  
#line 1915 
  tmp_0 = i;
  
#line 1915 
  i = (u16)((int)i - 1);
  
#line 1915 
  ;
  
#line 1915 
  if ((unsigned int)tmp_0 != 0U) 
#line 1917 
                                 goto ldv_57228; else 
#line 1920 
                                                      goto ldv_57230;
  ldv_57230: 
#line 1921 
  ;
  return_label: 
#line 1922 
                return;
}


#line 1936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
int fm10k_init_queueing_scheme(struct fm10k_intfc *interface)
{
  int __retres;
  int err;
  
#line 1941 
  fm10k_set_num_queues(interface);
  
#line 1944 
  err = fm10k_init_msix_capability(interface);
  
#line 1945 
  if (err != 0) {
    
#line 1946 
    dev_err((struct device const *)(& (interface->pdev)->dev),"Unable to initialize MSI-X capability\n");
    
#line 1948 
    __retres = err;
    
#line 1948 
    goto return_label;
  }
  else ;
  
#line 1952 
  err = fm10k_alloc_q_vectors(interface);
  
#line 1953 
  if (err != 0) {
    
#line 1954 
    __retres = err;
    
#line 1954 
    goto return_label;
  }
  else ;
  
#line 1957 
  fm10k_assign_rings(interface);
  
#line 1960 
  fm10k_init_reta(interface);
  
#line 1962 
  __retres = 0;
  return_label: 
#line 1962 
                return __retres;
}


#line 1972  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_main.c"
void fm10k_clear_queueing_scheme(struct fm10k_intfc *interface)
{
  
#line 1974 
  fm10k_free_q_vectors(interface);
  
#line 1975 
  fm10k_reset_msix_capability(interface);
  
#line 1976 
  return;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_main.c.aux"
void ldv_emg_fm10k_exit_module(void)
{
  
#line 72 
  fm10k_exit_module();
  
#line 73 
  return;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_main.c.aux"
int ldv_emg_fm10k_init_module(void)
{
  int tmp;
  
#line 76 
  tmp = fm10k_init_module();
  
#line 76 
  return tmp;
}


#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_main.c.aux"
static void atomic_inc(atomic_t *v)
{
  
#line 136 
  ldv_atomic_inc(v);
  
#line 137 
  return;
}


#line 470  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_main.c.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 473 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 473 
  return tmp;
}


#line 477  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_main.c.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 480 
  tmp = ldv_kzalloc(size,flags);
  
#line 480 
  return tmp;
}


#line 5  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __bad_udelay(void);


#line 8 
void __udelay(unsigned long);


#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.h"
s32 fm10k_sm_mbx_init(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, struct fm10k_msg_data const *msg_data);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_fifo_init(struct fm10k_mbx_fifo *fifo, u32 *buffer, u16 size)
{
  
#line 31 
  fifo->buffer = buffer;
  
#line 32 
  fifo->size = size;
  
#line 33 
  fifo->head = (unsigned short)0U;
  
#line 34 
  fifo->tail = (unsigned short)0U;
  
#line 35 
  return;
}


#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_fifo_used(struct fm10k_mbx_fifo *fifo)
{
  u16 __retres;
  
#line 45 
  __retres = (unsigned short)((int)fifo->tail - (int)fifo->head);
  
#line 45 
  return __retres;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_fifo_unused(struct fm10k_mbx_fifo *fifo)
{
  u16 __retres;
  
#line 56 
  __retres = (unsigned short)(((int)fifo->size + (int)fifo->head) - (int)fifo->tail);
  
#line 56 
  return __retres;
}


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static bool fm10k_fifo_empty(struct fm10k_mbx_fifo *fifo)
{
  bool __retres;
  
#line 67 
  __retres = (_Bool)((int)fifo->head == (int)fifo->tail);
  
#line 67 
  return __retres;
}


#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_fifo_head_offset(struct fm10k_mbx_fifo *fifo, u16 offset)
{
  u16 __retres;
  
#line 79 
  __retres = (unsigned short)((unsigned int)((int)fifo->head + (int)offset) & ((unsigned int)fifo->size + 65535U));
  
#line 79 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_fifo_tail_offset(struct fm10k_mbx_fifo *fifo, u16 offset)
{
  u16 __retres;
  
#line 91 
  __retres = (unsigned short)((unsigned int)((int)fifo->tail + (int)offset) & ((unsigned int)fifo->size + 65535U));
  
#line 91 
  return __retres;
}


#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_fifo_head_len(struct fm10k_mbx_fifo *fifo)
{
  u16 __retres;
  u16 tmp;
  bool tmp_0;
  
#line 102 
  tmp = fm10k_fifo_head_offset(fifo,(unsigned short)0);
  
#line 102 
  u32 *head = fifo->buffer + (int)tmp;
  
#line 105 
  tmp_0 = fm10k_fifo_empty(fifo);
  
#line 105 
  if ((int)tmp_0 != 0) {
    
#line 106 
    __retres = (unsigned short)0U;
    
#line 106 
    goto return_label;
  }
  else ;
  
#line 109 
  __retres = (unsigned short)((unsigned int)((unsigned short)(((unsigned long)*head + 3145728UL) >> 22)) + 1U);
  return_label: 
#line 109 
                return __retres;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_fifo_head_drop(struct fm10k_mbx_fifo *fifo)
{
  
#line 120 
  u16 len = fm10k_fifo_head_len(fifo);
  
#line 123 
  fifo->head = (unsigned short)((int)fifo->head + (int)len);
  
#line 125 
  return len;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_fifo_drop_all(struct fm10k_mbx_fifo *fifo)
{
  
#line 137 
  fifo->head = fifo->tail;
  
#line 138 
  return;
}


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_mbx_index_len(struct fm10k_mbx_info *mbx, u16 head, u16 tail)
{
  u16 __retres;
  
#line 151 
  u16 len = (unsigned short)((int)tail - (int)head);
  
#line 154 
  if ((int)len > (int)tail) 
#line 155 
                            len = (unsigned short)((unsigned int)len + 65534U); else ;
  
#line 157 
  __retres = (unsigned short)(((unsigned int)((int)mbx->mbmem_len << 1U) + 65535U) & (unsigned int)len);
  
#line 157 
  return __retres;
}


#line 168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_mbx_tail_add(struct fm10k_mbx_info *mbx, u16 offset)
{
  u16 __retres;
  int tmp;
  
#line 170 
  u16 tail = (unsigned short)(((unsigned int)((int)mbx->tail + (int)offset) + 1U) & ((unsigned int)((int)mbx->mbmem_len << 1U) + 65535U));
  
#line 173 
  if ((int)mbx->tail < (int)tail) {
    
#line 173 
    tail = (u16)((int)tail - 1);
    
#line 173 
    tmp = (int)tail;
  }
  else {
    
#line 173 
    tail = (u16)((int)tail + 1);
    
#line 173 
    tmp = (int)tail;
  }
  
#line 173 
  __retres = (unsigned short)tmp;
  
#line 173 
  return __retres;
}


#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_mbx_tail_sub(struct fm10k_mbx_info *mbx, u16 offset)
{
  u16 __retres;
  int tmp;
  
#line 186 
  u16 tail = (unsigned short)(((unsigned int)((int)mbx->tail - (int)offset) + 65535U) & ((unsigned int)((int)mbx->mbmem_len << 1U) + 65535U));
  
#line 189 
  if ((int)mbx->tail > (int)tail) {
    
#line 189 
    tail = (u16)((int)tail + 1);
    
#line 189 
    tmp = (int)tail;
  }
  else {
    
#line 189 
    tail = (u16)((int)tail - 1);
    
#line 189 
    tmp = (int)tail;
  }
  
#line 189 
  __retres = (unsigned short)tmp;
  
#line 189 
  return __retres;
}


#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_mbx_head_add(struct fm10k_mbx_info *mbx, u16 offset)
{
  u16 __retres;
  int tmp;
  
#line 202 
  u16 head = (unsigned short)(((unsigned int)((int)mbx->head + (int)offset) + 1U) & ((unsigned int)((int)mbx->mbmem_len << 1U) + 65535U));
  
#line 205 
  if ((int)mbx->head < (int)head) {
    
#line 205 
    head = (u16)((int)head - 1);
    
#line 205 
    tmp = (int)head;
  }
  else {
    
#line 205 
    head = (u16)((int)head + 1);
    
#line 205 
    tmp = (int)head;
  }
  
#line 205 
  __retres = (unsigned short)tmp;
  
#line 205 
  return __retres;
}


#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_mbx_head_sub(struct fm10k_mbx_info *mbx, u16 offset)
{
  u16 __retres;
  int tmp;
  
#line 218 
  u16 head = (unsigned short)(((unsigned int)((int)mbx->head - (int)offset) + 65535U) & ((unsigned int)((int)mbx->mbmem_len << 1U) + 65535U));
  
#line 221 
  if ((int)mbx->head > (int)head) {
    
#line 221 
    head = (u16)((int)head + 1);
    
#line 221 
    tmp = (int)head;
  }
  else {
    
#line 221 
    head = (u16)((int)head - 1);
    
#line 221 
    tmp = (int)head;
  }
  
#line 221 
  __retres = (unsigned short)tmp;
  
#line 221 
  return __retres;
}


#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_mbx_pushed_tail_len(struct fm10k_mbx_info *mbx)
{
  u16 __retres;
  u16 tmp;
  
#line 233 
  tmp = fm10k_fifo_tail_offset(& mbx->rx,(unsigned short)0);
  
#line 233 
  u32 *tail = mbx->rx.buffer + (int)tmp;
  
#line 236 
  if ((unsigned int)mbx->pushed == 0U) {
    
#line 237 
    __retres = (unsigned short)0U;
    
#line 237 
    goto return_label;
  }
  else ;
  
#line 239 
  __retres = (unsigned short)((unsigned int)((unsigned short)(((unsigned long)*tail + 3145728UL) >> 22)) + 1U);
  return_label: 
#line 239 
                return __retres;
}


#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_fifo_write_copy(struct fm10k_mbx_fifo *fifo, u32 const *msg, u16 tail_offset, u16 len)
{
  
#line 256 
  u16 end = fm10k_fifo_tail_offset(fifo,(unsigned short)((int)tail_offset));
  
#line 257 
  u32 *tail = fifo->buffer + (int)end;
  
#line 260 
  end = (unsigned short)((int)fifo->size - (int)end);
  
#line 263 
  if ((int)end < (int)len) 
#line 264 
                           memcpy((void *)fifo->buffer,(void const *)(msg + (int)end),(unsigned long)(((int)len - (int)end) << 2)); else 
                                                                    
#line 266 
                                                                    end = len;
  
#line 269 
  memcpy((void *)tail,(void const *)msg,(unsigned long)((int)end << 2));
  
#line 270 
  return;
}


#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_fifo_enqueue(struct fm10k_mbx_fifo *fifo, u32 const *msg)
{
  s32 __retres;
  u16 tmp;
  
#line 283 
  u16 len = (unsigned short)((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U);
  
#line 286 
  if ((int)fifo->size < (int)len) {
    
#line 287 
    __retres = -501;
    
#line 287 
    goto return_label;
  }
  else ;
  
#line 290 
  tmp = fm10k_fifo_unused(fifo);
  
#line 290 
  ;
  
#line 290 
  if ((int)tmp < (int)len) {
    
#line 291 
    __retres = -509;
    
#line 291 
    goto return_label;
  }
  else ;
  
#line 294 
  fm10k_fifo_write_copy(fifo,msg,(unsigned short)0,(unsigned short)((int)len));
  
#line 295 
  ldv_inline_asm();
  
#line 300 
  fifo->tail = (unsigned short)((int)fifo->tail + (int)len);
  
#line 302 
  __retres = 0;
  return_label: 
#line 302 
                return __retres;
}


#line 313  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_mbx_validate_msg_size(struct fm10k_mbx_info *mbx, u16 len)
{
  u16 __retres;
  u16 msg_len;
  u32 *msg;
  u16 tmp;
  int tmp_0;
  
#line 315 
  struct fm10k_mbx_fifo *fifo = & mbx->rx;
  
#line 316 
  u16 total_len = (unsigned short)0U;
  
#line 320 
  len = (unsigned short)((int)mbx->pushed + (int)len);
  ldv_44094: 
#line 321 
  ;
  
#line 324 
  tmp = fm10k_fifo_tail_offset(fifo,(unsigned short)((int)total_len));
  
#line 324 
  msg = fifo->buffer + (int)tmp;
  
#line 325 
  msg_len = (unsigned short)((unsigned int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + 1U);
  
#line 326 
  total_len = (unsigned short)((int)total_len + (int)msg_len);
  
#line 327 
  if ((int)total_len < (int)len) 
#line 329 
                                 goto ldv_44094; else 
#line 332 
                                                      goto ldv_44095;
  ldv_44095: 
#line 333 
  ;
  
#line 330 
  if ((int)len < (int)total_len && (int)mbx->max_size >= (int)msg_len) {
    
#line 331 
    __retres = (unsigned short)0U;
    
#line 331 
    goto return_label;
  }
  else ;
  
#line 334 
  if ((int)len >= (int)total_len) 
#line 334 
                                  tmp_0 = (int)len - (int)total_len; else 
                                                                    
#line 334 
                                                                    tmp_0 = (int)len;
  
#line 334 
  __retres = (unsigned short)tmp_0;
  return_label: 
#line 334 
                return __retres;
}


#line 345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_write_copy(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  u16 end;
  u16 len;
  u16 tail;
  u16 mask;
  
#line 348 
  struct fm10k_mbx_fifo *fifo = & mbx->tx;
  
#line 349 
  u32 mbmem = mbx->mbmem_reg;
  
#line 350 
  u32 *head = fifo->buffer;
  
#line 353 
  if ((unsigned int)mbx->tail_len == 0U) 
#line 354 
                                         goto return_label; else ;
  
#line 357 
  mask = (unsigned short)((unsigned int)mbx->mbmem_len + 65535U);
  
#line 358 
  len = mbx->tail_len;
  
#line 359 
  tail = fm10k_mbx_tail_sub(mbx,(unsigned short)((int)len));
  
#line 360 
  if ((int)tail > (int)mask) 
#line 361 
                             tail = (u16)((int)tail + 1); else ;
  
#line 364 
  end = fm10k_fifo_head_offset(fifo,(unsigned short)((int)mbx->pulled));
  
#line 365 
  head += (int)end;
  
#line 366 
  ldv_inline_asm();
  
#line 371 
  end = (unsigned short)((int)fifo->size - (int)end);
  
#line 371 
  goto ldv_44113;
  ldv_44112: 
#line 372 
  ;
  ldv_44110: 
#line 373 
  ;
  
#line 374 
  tail = (unsigned short)((int)tail & (int)mask);
  
#line 375 
  if ((unsigned int)tail == 0U) 
#line 376 
                                tail = (u16)((int)tail + 1); else ;
  {
    u32 * volatile *tmp;
    {
      
#line 379 
      u32 *__var = (u32 *)0U;
      
#line 379 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 379 
    u32 *hw_addr = *tmp;
    
#line 379 
    if ((long)(hw_addr == (u32 *)0U) == 0L) {
      u16 tmp_0;
      u32 *tmp_1;
      
#line 379 
      tmp_0 = tail;
      
#line 379 
      tail = (u16)((int)tail + 1);
      
#line 379 
      ;
      
#line 379 
      tmp_1 = head;
      
#line 379 
      head += 1;
      
#line 379 
      ;
      
#line 379 
      writel(*tmp_1,(void volatile *)(hw_addr + ((unsigned int)tmp_0 + mbmem)));
    }
    else ;
  }
  
#line 380 
  len = (u16)((int)len - 1);
  
#line 380 
  if ((unsigned int)len != 0U) {
    
#line 380 
    end = (u16)((int)end - 1);
    
#line 380 
    if ((unsigned int)end != 0U) 
#line 382 
                                 goto ldv_44110; else 
#line 385 
                                                      goto ldv_44111;
  }
  else 
#line 385 
       goto ldv_44111;
  ldv_44111: 
#line 386 
  ;
  
#line 371 
  head = fifo->buffer;
  ldv_44113: 
#line 372 
  ;
  
#line 371 
  if ((unsigned int)len != 0U) 
#line 373 
                               goto ldv_44112; else 
#line 376 
                                                    goto ldv_44114;
  ldv_44114: 
#line 377 
  ;
  return_label: 
#line 378 
                return;
}


#line 395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_pull_head(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, u16 head)
{
  u16 mbmem_len;
  u16 len;
  u16 tmp_0;
  u16 tmp_1;
  
#line 398 
  u16 ack = fm10k_mbx_index_len(mbx,(unsigned short)((int)head),(unsigned short)((int)mbx->tail));
  
#line 399 
  struct fm10k_mbx_fifo *fifo = & mbx->tx;
  
#line 402 
  mbx->pulled = (unsigned short)((int)mbx->pulled + ((int)mbx->tail_len - (int)ack));
  
#line 405 
  mbmem_len = (unsigned short)((unsigned int)mbx->mbmem_len + 65535U);
  
#line 406 
  tmp_0 = fm10k_fifo_used(fifo);
  
#line 406 
  len = (unsigned short)((int)tmp_0 - (int)mbx->pulled);
  
#line 407 
  if ((int)len > (int)mbmem_len) 
#line 408 
                                 len = mbmem_len; else ;
  
#line 411 
  mbx->tail = fm10k_mbx_tail_add(mbx,(unsigned short)((int)len - (int)ack));
  
#line 412 
  mbx->tail_len = len;
  
#line 415 
  len = fm10k_fifo_head_len(fifo);
  
#line 415 
  goto ldv_44125;
  ldv_44124: 
#line 416 
  ;
  
#line 418 
  tmp_1 = fm10k_fifo_head_drop(fifo);
  
#line 418 
  mbx->pulled = (unsigned short)((int)mbx->pulled - (int)tmp_1);
  
#line 419 
  mbx->tx_messages += 1ULL;
  
#line 420 
  mbx->tx_dwords += (unsigned long long)len;
  
#line 417 
  len = fm10k_fifo_head_len(fifo);
  ldv_44125: 
#line 418 
  ;
  
#line 415 
  if ((unsigned int)len != 0U && (int)mbx->pulled >= (int)len) 
#line 418 
                                                               goto ldv_44124; else 
                                                                    
#line 421 
                                                                    goto ldv_44126;
  ldv_44126: 
#line 422 
  ;
  
#line 424 
  fm10k_mbx_write_copy(hw,mbx);
  
#line 425 
  return;
}


#line 436  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_read_copy(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  u16 end;
  u16 len;
  u16 head;
  u32 *tmp;
  u16 tmp_0;
  
#line 439 
  struct fm10k_mbx_fifo *fifo = & mbx->rx;
  
#line 440 
  u32 mbmem = mbx->mbmem_reg ^ (unsigned int)mbx->mbmem_len;
  
#line 441 
  u32 *tail = fifo->buffer;
  
#line 445 
  len = mbx->head_len;
  
#line 446 
  head = fm10k_mbx_head_sub(mbx,(unsigned short)((int)len));
  
#line 447 
  if ((int)mbx->mbmem_len <= (int)head) 
#line 448 
                                        head = (u16)((int)head + 1); else ;
  
#line 451 
  end = fm10k_fifo_tail_offset(fifo,(unsigned short)((int)mbx->pushed));
  
#line 452 
  tail += (int)end;
  
#line 455 
  end = (unsigned short)((int)fifo->size - (int)end);
  
#line 455 
  goto ldv_44140;
  ldv_44139: 
#line 456 
  ;
  ldv_44137: 
#line 457 
  ;
  
#line 458 
  head = (unsigned short)(((unsigned int)mbx->mbmem_len + 65535U) & (unsigned int)head);
  
#line 459 
  if ((unsigned int)head == 0U) 
#line 460 
                                head = (u16)((int)head + 1); else ;
  
#line 463 
  tmp = tail;
  
#line 463 
  tail += 1;
  
#line 463 
  tmp_0 = head;
  
#line 463 
  head = (u16)((int)head + 1);
  
#line 463 
  ;
  
#line 463 
  ;
  
#line 463 
  *tmp = fm10k_read_reg(hw,(int)((unsigned int)tmp_0 + mbmem));
  
#line 464 
  len = (u16)((int)len - 1);
  
#line 464 
  if ((unsigned int)len != 0U) {
    
#line 464 
    end = (u16)((int)end - 1);
    
#line 464 
    if ((unsigned int)end != 0U) 
#line 466 
                                 goto ldv_44137; else 
#line 469 
                                                      goto ldv_44138;
  }
  else 
#line 469 
       goto ldv_44138;
  ldv_44138: 
#line 470 
  ;
  
#line 455 
  tail = fifo->buffer;
  ldv_44140: 
#line 456 
  ;
  
#line 455 
  if ((unsigned int)len != 0U) 
#line 457 
                               goto ldv_44139; else 
#line 460 
                                                    goto ldv_44141;
  ldv_44141: 
#line 461 
  ;
  
#line 462 
  ldv_inline_asm();
  
#line 463 
  return;
}


#line 482  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_push_tail(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, u16 tail)
{
  s32 __retres;
  u16 len;
  u16 tmp_0;
  u16 tmp_1;
  
#line 486 
  struct fm10k_mbx_fifo *fifo = & mbx->rx;
  
#line 487 
  u16 seq = fm10k_mbx_index_len(mbx,(unsigned short)((int)mbx->head),(unsigned short)((int)tail));
  
#line 490 
  tmp_0 = fm10k_fifo_unused(fifo);
  
#line 490 
  len = (unsigned short)((int)tmp_0 - (int)mbx->pushed);
  
#line 491 
  if ((int)len > (int)seq) 
#line 492 
                           len = seq; else ;
  
#line 495 
  mbx->head = fm10k_mbx_head_add(mbx,(unsigned short)((int)len));
  
#line 496 
  mbx->head_len = len;
  
#line 499 
  if ((unsigned int)len == 0U) {
    
#line 500 
    __retres = 0;
    
#line 500 
    goto return_label;
  }
  else ;
  
#line 503 
  fm10k_mbx_read_copy(hw,mbx);
  
#line 506 
  tmp_1 = fm10k_mbx_validate_msg_size(mbx,(unsigned short)((int)len));
  
#line 506 
  if ((unsigned int)tmp_1 != 0U) {
    
#line 507 
    __retres = -501;
    
#line 507 
    goto return_label;
  }
  else ;
  
#line 510 
  mbx->pushed = (unsigned short)((int)mbx->pushed + (int)len);
  
#line 513 
  len = fm10k_mbx_pushed_tail_len(mbx);
  
#line 513 
  goto ldv_44151;
  ldv_44150: 
#line 514 
  ;
  
#line 516 
  fifo->tail = (unsigned short)((int)fifo->tail + (int)len);
  
#line 517 
  mbx->pushed = (unsigned short)((int)mbx->pushed - (int)len);
  
#line 518 
  mbx->rx_messages += 1ULL;
  
#line 519 
  mbx->rx_dwords += (unsigned long long)len;
  
#line 515 
  len = fm10k_mbx_pushed_tail_len(mbx);
  ldv_44151: 
#line 516 
  ;
  
#line 513 
  if ((unsigned int)len != 0U && (int)mbx->pushed >= (int)len) 
#line 516 
                                                               goto ldv_44150; else 
                                                                    
#line 519 
                                                                    goto ldv_44152;
  ldv_44152: 
#line 520 
  ;
  
#line 522 
  __retres = 0;
  return_label: 
#line 522 
                return __retres;
}


#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 const fm10k_crc_16b_table[256U] = {(unsigned short)0U, (unsigned short)31062U, (unsigned short)62124U, (unsigned short)35834U, (unsigned short)48237U, (unsigned short)50491U, (unsigned short)20161U, (unsigned short)14231U, (unsigned short)8687U, (unsigned short)22713U, (unsigned short)54083U, (unsigned short)43541U, (unsigned short)40322U, (unsigned short)58580U, (unsigned short)28462U, (unsigned short)5752U, (unsigned short)17374U, (unsigned short)14984U, (unsigned short)45426U, (unsigned short)51236U, (unsigned short)65459U, (unsigned short)34533U, (unsigned short)3359U, (unsigned short)29769U, (unsigned short)25137U, (unsigned short)7015U, (unsigned short)37021U, (unsigned short)59851U, (unsigned short)56924U, (unsigned short)42762U, (unsigned short)11504U, (unsigned short)21926U, (unsigned short)34748U, (unsigned short)65258U, (unsigned short)29968U, (unsigned short)3142U, (unsigned short)15313U, (unsigned short)17031U, (unsigned short)51581U, (unsigned short)45099U, (unsigned short)42579U, (unsigned short)57093U, (unsigned short)21759U, (unsigned short)11689U, (unsigned short)6718U, (unsigned short)25448U, (unsigned short)59538U, (unsigned short)37316U, (unsigned short)50274U, (unsigned short)48436U, (unsigned short)14030U, (unsigned short)20376U, (unsigned short)30735U, (unsigned short)345U, (unsigned short)35491U, (unsigned short)62453U, (unsigned short)58765U, (unsigned short)40155U, (unsigned short)5921U, (unsigned short)28279U, (unsigned short)23008U, (unsigned short)8374U, (unsigned short)43852U, (unsigned short)53786U, (unsigned short)22093U, (unsigned short)12059U, (unsigned short)42209U, (unsigned short)56759U, (unsigned short)59936U, (unsigned short)37750U, (unsigned short)6284U, (unsigned short)25050U, (unsigned short)30626U, (unsigned short)3828U, (unsigned short)34062U, (unsigned short)64600U, (unsigned short)52175U, (unsigned short)45721U, (unsigned short)14691U, (unsigned short)16437U, (unsigned short)5523U, (unsigned short)27845U, (unsigned short)59199U, (unsigned short)40553U, (unsigned short)43518U, (unsigned short)53416U, (unsigned short)23378U, (unsigned short)8708U, (unsigned short)13436U, (unsigned short)19754U, (unsigned short)50896U, (unsigned short)49030U, (unsigned short)34833U, (unsigned short)61767U, (unsigned short)31421U, (unsigned short)1003U, (unsigned short)53745U, (unsigned short)43175U, (unsigned short)9053U, (unsigned short)23051U, (unsigned short)28060U, (unsigned short)5322U, (unsigned short)40752U, (unsigned short)58982U, (unsigned short)61470U, (unsigned short)35144U, (unsigned short)690U, (unsigned short)31716U, (unsigned short)19571U, (unsigned short)13605U, (unsigned short)48863U, (unsigned short)51081U, (unsigned short)37423U, (unsigned short)60281U, (unsigned short)24707U, (unsigned short)6613U, (unsigned short)11842U, (unsigned short)22292U, (unsigned short)56558U, (unsigned short)42424U, (unsigned short)46016U, (unsigned short)51862U, (unsigned short)16748U, (unsigned short)14394U, (unsigned short)4013U, (unsigned short)30459U, (unsigned short)64769U, (unsigned short)33879U, (unsigned short)44186U, (unsigned short)54732U, (unsigned short)24118U, (unsigned short)10080U, (unsigned short)4343U, (unsigned short)27041U, (unsigned short)57947U, (unsigned short)39693U, (unsigned short)36213U, (unsigned short)62499U, (unsigned short)32729U, (unsigned short)1679U, (unsigned short)12568U, (unsigned short)18510U, (unsigned short)50100U, (unsigned short)47842U, (unsigned short)61252U, (unsigned short)38418U, (unsigned short)7656U, (unsigned short)25790U, (unsigned short)21289U, (unsigned short)10879U, (unsigned short)41349U, (unsigned short)55507U, (unsigned short)52907U, (unsigned short)47101U, (unsigned short)15367U, (unsigned short)17745U, (unsigned short)29382U, (unsigned short)2960U, (unsigned short)32874U, (unsigned short)63804U, (unsigned short)11046U, (unsigned short)21104U, (unsigned short)55690U, (unsigned short)41180U, (unsigned short)38731U, (unsigned short)60957U, (unsigned short)26087U, (unsigned short)7345U, (unsigned short)2761U, (unsigned short)29599U, (unsigned short)63589U, (unsigned short)33075U, (unsigned short)46756U, (unsigned short)53234U, (unsigned short)17416U, (unsigned short)15710U, (unsigned short)26872U, (unsigned short)4526U, (unsigned short)39508U, (unsigned short)58114U, (unsigned short)54421U, (unsigned short)44483U, (unsigned short)9785U, (unsigned short)24431U, (unsigned short)18711U, (unsigned short)12353U, (unsigned short)48059U, (unsigned short)49901U, (unsigned short)62842U, (unsigned short)35884U, (unsigned short)2006U, (unsigned short)32384U, (unsigned short)64215U, (unsigned short)33665U, (unsigned short)2171U, (unsigned short)28973U, (unsigned short)18106U, (unsigned short)16364U, (unsigned short)46102U, (unsigned short)52544U, (unsigned short)56120U, (unsigned short)41582U, (unsigned short)10644U, (unsigned short)20674U, (unsigned short)26453U, (unsigned short)7683U, (unsigned short)38393U, (unsigned short)60591U, (unsigned short)47369U, (unsigned short)49247U, (unsigned short)19365U, (unsigned short)13043U, (unsigned short)1380U, (unsigned short)31794U, (unsigned short)63432U, (unsigned short)36510U, (unsigned short)39142U, (unsigned short)57776U, (unsigned short)27210U, (unsigned short)4892U, (unsigned short)9355U, (unsigned short)24029U, (unsigned short)54823U, (unsigned short)44913U, (unsigned short)32107U, (unsigned short)1085U, (unsigned short)36807U, (unsigned short)63121U, (unsigned short)49414U, (unsigned short)47184U, (unsigned short)13226U, (unsigned short)19196U, (unsigned short)23684U, (unsigned short)9682U, (unsigned short)44584U, (unsigned short)55166U, (unsigned short)57577U, (unsigned short)39359U, (unsigned short)4677U, (unsigned short)27411U, (unsigned short)16053U, (unsigned short)18403U, (unsigned short)52249U, (unsigned short)46415U, (unsigned short)33496U, (unsigned short)64398U, (unsigned short)28788U, (unsigned short)2338U, (unsigned short)8026U, (unsigned short)26124U, (unsigned short)60918U, (unsigned short)38048U, (unsigned short)41783U, (unsigned short)55905U, (unsigned short)20891U, (unsigned short)10445U};

#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_crc_16b(u32 const *data, u16 seed, u16 len)
{
  u16 __retres;
  u32 const *tmp;
  u16 tmp_0;
  u16 tmp_1;
  
#line 573 
  u32 result = (unsigned int)seed;
  
#line 575 
  goto ldv_44162;
  ldv_44161: 
#line 576 
  ;
  
#line 576 
  tmp = data;
  
#line 576 
  data += 1;
  
#line 576 
  result = *tmp ^ result;
  
#line 577 
  result = (result >> 8) ^ (unsigned int)fm10k_crc_16b_table[result & 255U];
  
#line 578 
  result = (result >> 8) ^ (unsigned int)fm10k_crc_16b_table[result & 255U];
  
#line 580 
  tmp_0 = len;
  
#line 580 
  len = (u16)((int)len - 1);
  
#line 580 
  ;
  
#line 580 
  if ((unsigned int)tmp_0 == 0U) 
#line 581 
                                 goto ldv_44160; else ;
  
#line 583 
  result = (result >> 8) ^ (unsigned int)fm10k_crc_16b_table[result & 255U];
  
#line 584 
  result = (result >> 8) ^ (unsigned int)fm10k_crc_16b_table[result & 255U];
  ldv_44162: 
#line 585 
  ;
  
#line 575 
  tmp_1 = len;
  
#line 575 
  len = (u16)((int)len - 1);
  
#line 575 
  ;
  
#line 575 
  if ((unsigned int)tmp_1 != 0U) 
#line 577 
                                 goto ldv_44161; else 
#line 580 
                                                      goto ldv_44160;
  ldv_44160: 
#line 581 
  ;
  
#line 587 
  __retres = (unsigned short)result;
  
#line 587 
  return __retres;
}


#line 599  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_fifo_crc(struct fm10k_mbx_fifo *fifo, u16 offset, u16 len, u16 seed)
{
  u16 tmp;
  
#line 602 
  u32 *data = fifo->buffer + (int)offset;
  
#line 605 
  offset = (unsigned short)((int)fifo->size - (int)offset);
  
#line 608 
  if ((int)offset < (int)len) {
    
#line 609 
    seed = fm10k_crc_16b((u32 const *)data,(unsigned short)((int)seed),(unsigned short)((int)((unsigned int)offset * 2U)));
    
#line 610 
    data = fifo->buffer;
    
#line 611 
    len = (unsigned short)((int)len - (int)offset);
  }
  else ;
  
#line 615 
  tmp = fm10k_crc_16b((u32 const *)data,(unsigned short)((int)seed),(unsigned short)((int)((unsigned int)len * 2U)));
  
#line 615 
  return tmp;
}


#line 628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_update_local_crc(struct fm10k_mbx_info *mbx, u16 head)
{
  u16 tmp;
  
#line 630 
  tmp = fm10k_mbx_index_len(mbx,(unsigned short)((int)head),(unsigned short)((int)mbx->tail));
  
#line 630 
  u16 len = (unsigned short)((int)mbx->tail_len - (int)tmp);
  
#line 633 
  head = fm10k_fifo_head_offset(& mbx->tx,(unsigned short)((int)mbx->pulled));
  
#line 636 
  mbx->local = fm10k_fifo_crc(& mbx->tx,(unsigned short)((int)head),(unsigned short)((int)len),(unsigned short)((int)mbx->local));
  
#line 637 
  return;
}


#line 649  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_verify_remote_crc(struct fm10k_mbx_info *mbx)
{
  u16 tmp;
  u16 crc;
  int tmp_0;
  
#line 651 
  struct fm10k_mbx_fifo *fifo = & mbx->rx;
  
#line 652 
  u16 len = mbx->head_len;
  
#line 653 
  tmp = fm10k_fifo_tail_offset(fifo,(unsigned short)((int)mbx->pushed));
  
#line 653 
  u16 offset = (unsigned short)((int)tmp - (int)len);
  
#line 657 
  if ((unsigned int)len != 0U) 
#line 658 
                               mbx->remote = fm10k_fifo_crc(fifo,(unsigned short)((int)offset),(unsigned short)((int)len),(unsigned short)((int)mbx->remote)); else ;
  
#line 661 
  crc = fm10k_crc_16b((u32 const *)(& mbx->mbx_hdr),(unsigned short)((int)mbx->remote),(unsigned short)1);
  
#line 664 
  if ((unsigned int)crc != 0U) 
#line 664 
                               tmp_0 = -497; else 
#line 664 
                                                  tmp_0 = 0;
  
#line 664 
  return tmp_0;
}


#line 673  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static bool fm10k_mbx_rx_ready(struct fm10k_mbx_info *mbx)
{
  bool __retres;
  int tmp_1;
  
#line 675 
  u16 msg_size = fm10k_fifo_head_len(& mbx->rx);
  
#line 677 
  if ((unsigned int)msg_size != 0U) {
    u16 tmp_0;
    
#line 677 
    tmp_0 = fm10k_fifo_used(& mbx->rx);
    
#line 677 
    ;
    
#line 677 
    if ((int)tmp_0 >= (int)msg_size) 
#line 677 
                                     tmp_1 = 1; else 
#line 677 
                                                     tmp_1 = 0;
  }
  else 
#line 677 
       tmp_1 = 0;
  
#line 677 
  __retres = (_Bool)(tmp_1 != 0);
  
#line 677 
  return __retres;
}


#line 687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static bool fm10k_mbx_tx_ready(struct fm10k_mbx_info *mbx, u16 len)
{
  bool __retres;
  
#line 689 
  u16 fifo_unused = fm10k_fifo_unused(& mbx->tx);
  
#line 691 
  __retres = (_Bool)((mbx->state == (unsigned int)FM10K_STATE_OPEN && (int)fifo_unused >= (int)len) != 0);
  
#line 691 
  return __retres;
}


#line 700  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static bool fm10k_mbx_tx_complete(struct fm10k_mbx_info *mbx)
{
  bool tmp;
  
#line 702 
  tmp = fm10k_fifo_empty(& mbx->tx);
  
#line 702 
  return tmp;
}


#line 713  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static u16 fm10k_mbx_dequeue_rx(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 err;
  u16 cnt;
  int tmp_0;
  bool tmp;
  
#line 716 
  struct fm10k_mbx_fifo *fifo = & mbx->rx;
  
#line 721 
  cnt = (unsigned short)0U;
  
#line 721 
  goto ldv_44202;
  ldv_44201: 
#line 722 
  ;
  
#line 722 
  err = fm10k_tlv_msg_parse(hw,fifo->buffer + (int)fifo->head,mbx,mbx->msg_data);
  
#line 724 
  if (err < 0) 
#line 725 
               mbx->rx_parse_err += 1ULL; else ;
  
#line 727 
  fm10k_fifo_head_drop(fifo);
  
#line 721 
  cnt = (u16)((int)cnt + 1);
  ldv_44202: 
#line 722 
  ;
  
#line 721 
  tmp = fm10k_fifo_empty(fifo);
  
#line 721 
  if (tmp) 
#line 721 
           tmp_0 = 0; else 
#line 721 
                           tmp_0 = 1;
  
#line 721 
  if (tmp_0) 
#line 723 
             goto ldv_44201; else 
#line 726 
                                  goto ldv_44203;
  ldv_44203: 
#line 727 
  ;
  
#line 731 
  memmove((void *)fifo->buffer,(void const *)(fifo->buffer + (int)fifo->tail),(unsigned long)((int)mbx->pushed << 2));
  
#line 734 
  fifo->tail = (unsigned short)((int)fifo->tail - (int)fifo->head);
  
#line 735 
  fifo->head = (unsigned short)0U;
  
#line 737 
  return cnt;
}


#line 750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_enqueue_tx(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, u32 const *msg)
{
  s32 __retres;
  s32 err;
  
#line 753 
  u32 countdown = mbx->timeout;
  
#line 756 
  switch ((unsigned int)mbx->state) {
    case (unsigned int)0: 
#line 757 
    ;
    case (unsigned int)3: 
#line 758 
    ;
    
#line 759 
    __retres = -511;
    
#line 759 
    goto return_label;
    default: 
#line 760 
    ;
    
#line 761 
    goto ldv_44214;
  }
  ldv_44214: 
#line 765 
  ;
  
#line 765 
  err = fm10k_fifo_enqueue(& mbx->tx,msg);
  
#line 768 
  goto ldv_44216;
  ldv_44215: 
#line 769 
  ;
  
#line 769 
  countdown -= 1U;
  
#line 770 
  if (0 != 0) 
    
#line 770 
    if (mbx->udelay > 19999U) 
#line 770 
                              __bad_udelay(); else 
#line 770 
                                                   __const_udelay((unsigned long)mbx->udelay * 4295UL);
  else 
#line 770 
       __udelay((unsigned long)mbx->udelay);
  
#line 771 
  (*(mbx->ops.process))(hw,mbx);
  
#line 772 
  err = fm10k_fifo_enqueue(& mbx->tx,msg);
  ldv_44216: 
#line 773 
  ;
  
#line 768 
  if (err != 0 && countdown != 0U) 
#line 770 
                                   goto ldv_44215; else 
#line 773 
                                                        goto ldv_44217;
  ldv_44217: 
#line 774 
  ;
  
#line 776 
  if (err != 0) {
    
#line 777 
    mbx->timeout = 0U;
    
#line 778 
    mbx->tx_busy += 1ULL;
  }
  else ;
  
#line 785 
  if ((unsigned int)mbx->tail_len == 0U) 
#line 786 
                                         (*(mbx->ops.process))(hw,mbx); else ;
  
#line 788 
  __retres = 0;
  return_label: 
#line 788 
                return __retres;
}


#line 798  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_read(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u32 tmp;
  
#line 801 
  if (mbx->mbx_hdr != 0U) {
    
#line 802 
    __retres = -500;
    
#line 802 
    goto return_label;
  }
  else ;
  
#line 805 
  tmp = fm10k_read_reg(hw,(int)mbx->mbx_reg);
  
#line 805 
  if ((tmp & 8U) != 0U) 
#line 806 
                        mbx->mbx_lock = 4U; else ;
  {
    u32 * volatile *tmp_0;
    {
      
#line 809 
      u32 *__var = (u32 *)0U;
      
#line 809 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 809 
    u32 *hw_addr = *tmp_0;
    
#line 809 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 809 
                                            writel(24U,(void volatile *)(hw_addr + mbx->mbx_reg)); else ;
  }
  
#line 813 
  mbx->mbx_hdr = fm10k_read_reg(hw,(int)(mbx->mbmem_reg ^ (unsigned int)mbx->mbmem_len));
  
#line 815 
  __retres = 0;
  return_label: 
#line 815 
                return __retres;
}


#line 825  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_write(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  
#line 827 
  u32 mbmem = mbx->mbmem_reg;
  {
    u32 * volatile *tmp;
    {
      
#line 830 
      u32 *__var = (u32 *)0U;
      
#line 830 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 830 
    u32 *hw_addr = *tmp;
    
#line 830 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 830 
                                            writel(mbx->mbx_hdr,(void volatile *)(hw_addr + mbmem)); else ;
  }
  
#line 833 
  if (mbx->mbx_lock != 0U) {
    u32 * volatile *tmp_0;
    {
      
#line 834 
      u32 *__var_0 = (u32 *)0U;
      
#line 834 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 834 
    u32 *hw_addr_0 = *tmp_0;
    
#line 834 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 834 
                                              writel(mbx->mbx_lock,(void volatile *)(hw_addr_0 + mbx->mbx_reg)); else ;
  }
  else ;
  
#line 837 
  mbx->mbx_hdr = 0U;
  
#line 838 
  mbx->mbx_lock = 0U;
  
#line 839 
  return;
}


#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_create_connect_hdr(struct fm10k_mbx_info *mbx)
{
  
#line 849 
  mbx->mbx_lock |= 2U;
  
#line 851 
  mbx->mbx_hdr = ((((unsigned int)mbx->head << 8) & 3840U) | ((unsigned int)((int)mbx->rx.size + -1) << 16)) | 12U;
  
#line 853 
  return;
}


#line 862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_create_data_hdr(struct fm10k_mbx_info *mbx)
{
  u16 crc;
  u16 tmp;
  
#line 864 
  u32 hdr = ((((unsigned int)mbx->tail << 4) & 255U) | (((unsigned int)mbx->head << 8) & 3840U)) | 8U;
  
#line 867 
  struct fm10k_mbx_fifo *fifo = & mbx->tx;
  
#line 870 
  if ((unsigned int)mbx->tail_len != 0U) 
#line 871 
                                         mbx->mbx_lock |= 2U; else ;
  
#line 874 
  ;
  
#line 874 
  ;
  
#line 874 
  tmp = fm10k_fifo_head_offset(fifo,(unsigned short)((int)mbx->pulled));
  
#line 874 
  ;
  
#line 874 
  crc = fm10k_fifo_crc(fifo,(unsigned short)((int)tmp),(unsigned short)((int)mbx->tail_len),(unsigned short)((int)mbx->local));
  
#line 876 
  crc = fm10k_crc_16b((u32 const *)(& hdr),(unsigned short)((int)crc),(unsigned short)1);
  
#line 879 
  mbx->mbx_hdr = ((unsigned int)crc << 16) | hdr;
  
#line 880 
  return;
}


#line 888  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_create_disconnect_hdr(struct fm10k_mbx_info *mbx)
{
  
#line 890 
  u32 hdr = ((((unsigned int)mbx->tail << 4) & 255U) | (((unsigned int)mbx->head << 8) & 3840U)) | 13U;
  
#line 893 
  u16 crc = fm10k_crc_16b((u32 const *)(& hdr),(unsigned short)((int)mbx->local),(unsigned short)1);
  
#line 895 
  mbx->mbx_lock |= 4U;
  
#line 898 
  mbx->mbx_hdr = ((unsigned int)crc << 16) | hdr;
  
#line 899 
  return;
}


#line 910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_create_error_msg(struct fm10k_mbx_info *mbx, s32 err)
{
  
#line 913 
  switch (err) {
    case -507: 
#line 914 
    ;
    case -506: 
#line 915 
    ;
    case -503: 
#line 916 
    ;
    case -501: 
#line 917 
    ;
    case -498: 
#line 918 
    ;
    case -497: 
#line 919 
    ;
    
#line 920 
    goto ldv_44260;
    default: 
#line 921 
    ;
    
#line 922 
    goto return_label;
  }
  ldv_44260: 
#line 925 
  ;
  
#line 925 
  mbx->mbx_lock |= 2U;
  
#line 927 
  mbx->mbx_hdr = (((unsigned int)err << 16) | (((unsigned int)mbx->head << 8) & 3840U)) | 14U;
  return_label: 
#line 929 
                return;
}


#line 941  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_validate_msg_hdr(struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u16 type;
  u16 rsvd0;
  u16 head;
  u16 tail;
  u16 size;
  
#line 944 
  u32 const *hdr = (u32 const *)(& mbx->mbx_hdr);
  
#line 946 
  type = (unsigned short)((unsigned int)((unsigned short)*hdr) & 15U);
  
#line 947 
  rsvd0 = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 12)) & 15U);
  
#line 948 
  tail = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 4)) & 15U);
  
#line 949 
  head = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 8)) & 15U);
  
#line 950 
  size = (unsigned short)(*hdr >> 16);
  
#line 952 
  if ((unsigned int)rsvd0 != 0U) {
    
#line 953 
    __retres = -498;
    
#line 953 
    goto return_label;
  }
  else ;
  
#line 955 
  switch ((int)type) {
    u16 tmp;
    u16 tmp_0;
    case 13: 
#line 956 
    ;
    
#line 958 
    if ((int)mbx->head != (int)tail) {
      
#line 959 
      __retres = -507;
      
#line 959 
      goto return_label;
    }
    else ;
    case 8: 
#line 962 
    ;
    
#line 964 
    if ((unsigned int)head == 0U || (unsigned int)head == 15U) {
      
#line 965 
      __retres = -506;
      
#line 965 
      goto return_label;
    }
    else ;
    
#line 966 
    tmp = fm10k_mbx_index_len(mbx,(unsigned short)((int)head),(unsigned short)((int)mbx->tail));
    
#line 966 
    ;
    
#line 966 
    if ((int)tmp > (int)mbx->tail_len) {
      
#line 967 
      __retres = -506;
      
#line 967 
      goto return_label;
    }
    else ;
    
#line 970 
    if ((unsigned int)tail == 0U || (unsigned int)tail == 15U) {
      
#line 971 
      __retres = -507;
      
#line 971 
      goto return_label;
    }
    else ;
    
#line 972 
    tmp_0 = fm10k_mbx_index_len(mbx,(unsigned short)((int)mbx->head),(unsigned short)((int)tail));
    
#line 972 
    ;
    
#line 972 
    if ((int)tmp_0 < (int)mbx->mbmem_len) 
#line 973 
                                          goto ldv_44273; else ;
    
#line 975 
    __retres = -507;
    
#line 975 
    goto return_label;
    case 12: 
#line 976 
    ;
    
#line 978 
    if ((unsigned int)size <= 6U || ((int)size & ((int)size + 1)) != 0) {
      
#line 979 
      __retres = -501;
      
#line 979 
      goto return_label;
    }
    else ;
    case 14: 
#line 982 
    ;
    
#line 983 
    if ((unsigned int)head == 0U || (unsigned int)head == 15U) {
      
#line 984 
      __retres = -506;
      
#line 984 
      goto return_label;
    }
    else ;
    
#line 986 
    if ((unsigned int)tail != 0U) {
      
#line 987 
      __retres = -507;
      
#line 987 
      goto return_label;
    }
    else ;
    
#line 989 
    goto ldv_44273;
    default: 
#line 990 
    ;
    
#line 991 
    __retres = -503;
    
#line 991 
    goto return_label;
  }
  ldv_44273: 
#line 994 
  ;
  
#line 994 
  __retres = 0;
  return_label: 
#line 994 
                return __retres;
}


#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_create_reply(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, u16 head)
{
  s32 __retres;
  
#line 1010 
  switch ((unsigned int)mbx->state) {
    case (unsigned int)2: 
#line 1011 
    ;
    case (unsigned int)3: 
#line 1012 
    ;
    
#line 1014 
    fm10k_mbx_update_local_crc(mbx,(unsigned short)((int)head));
    
#line 1017 
    fm10k_mbx_pull_head(hw,mbx,(unsigned short)((int)head));
    
#line 1020 
    if ((unsigned int)mbx->tail_len != 0U || mbx->state == (unsigned int)FM10K_STATE_OPEN) 
      
#line 1021 
      fm10k_mbx_create_data_hdr(mbx); else 
#line 1023 
                                           fm10k_mbx_create_disconnect_hdr(mbx);
    
#line 1024 
    goto ldv_44284;
    case (unsigned int)1: 
#line 1025 
    ;
    
#line 1027 
    fm10k_mbx_create_connect_hdr(mbx);
    
#line 1028 
    goto ldv_44284;
    case (unsigned int)0: 
#line 1029 
    ;
    
#line 1031 
    fm10k_mbx_create_disconnect_hdr(mbx);
    default: 
#line 1032 
    ;
    
#line 1033 
    goto ldv_44284;
  }
  ldv_44284: 
#line 1036 
  ;
  
#line 1036 
  __retres = 0;
  
#line 1036 
  return __retres;
}


#line 1047  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_reset_work(struct fm10k_mbx_info *mbx)
{
  
#line 1050 
  mbx->max_size = (unsigned short)((unsigned int)mbx->rx.size + 65535U);
  
#line 1053 
  mbx->pushed = (unsigned short)0U;
  
#line 1054 
  mbx->pulled = (unsigned short)0U;
  
#line 1055 
  mbx->tail_len = (unsigned short)0U;
  
#line 1056 
  mbx->head_len = (unsigned short)0U;
  
#line 1057 
  mbx->rx.tail = (unsigned short)0U;
  
#line 1058 
  mbx->rx.head = (unsigned short)0U;
  
#line 1059 
  return;
}


#line 1072  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_update_max_size(struct fm10k_mbx_info *mbx, u16 size)
{
  u16 len;
  
#line 1076 
  mbx->max_size = size;
  
#line 1079 
  len = fm10k_fifo_head_len(& mbx->tx);
  
#line 1079 
  goto ldv_44297;
  ldv_44296: 
#line 1080 
  ;
  
#line 1082 
  fm10k_fifo_head_drop(& mbx->tx);
  
#line 1083 
  mbx->tx_dropped += 1ULL;
  
#line 1081 
  len = fm10k_fifo_head_len(& mbx->tx);
  ldv_44297: 
#line 1082 
  ;
  
#line 1079 
  if ((int)len > (int)size) 
#line 1082 
                            goto ldv_44296; else 
#line 1085 
                                                 goto ldv_44298;
  ldv_44298: 
#line 1086 
  ;
  
#line 1087 
  return;
}


#line 1094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_connect_reset(struct fm10k_mbx_info *mbx)
{
  
#line 1097 
  fm10k_mbx_reset_work(mbx);
  
#line 1100 
  mbx->local = (unsigned short)65535U;
  
#line 1101 
  mbx->remote = (unsigned short)65535U;
  
#line 1104 
  if (mbx->state == (unsigned int)FM10K_STATE_OPEN) 
#line 1105 
                                                    mbx->state = FM10K_STATE_CONNECT; else 
                                                                    
#line 1107 
                                                                    mbx->state = FM10K_STATE_CLOSED;
  
#line 1108 
  return;
}


#line 1119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_process_connect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  u16 size;
  u16 head;
  s32 tmp;
  
#line 1122 
  enum fm10k_mbx_state const state = mbx->state;
  
#line 1123 
  u32 const *hdr = (u32 const *)(& mbx->mbx_hdr);
  
#line 1127 
  size = (unsigned short)(*hdr >> 16);
  
#line 1128 
  head = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 8)) & 15U);
  
#line 1130 
  switch ((unsigned int)state) {
    case (unsigned int)3: 
#line 1131 
    ;
    case (unsigned int)2: 
#line 1132 
    ;
    
#line 1134 
    fm10k_mbx_connect_reset(mbx);
    
#line 1135 
    goto ldv_44312;
    case (unsigned int)1: 
#line 1136 
    ;
    
#line 1138 
    if ((int)mbx->rx.size < (int)size) 
#line 1139 
                                       mbx->max_size = (unsigned short)((unsigned int)mbx->rx.size + 65535U);
    else {
      
#line 1142 
      mbx->state = FM10K_STATE_OPEN;
      
#line 1144 
      fm10k_mbx_update_max_size(mbx,(unsigned short)((int)size));
    }
    
#line 1146 
    goto ldv_44312;
    default: 
#line 1147 
    ;
    
#line 1148 
    goto ldv_44312;
  }
  ldv_44312: 
#line 1152 
  ;
  
#line 1152 
  mbx->tail = head;
  
#line 1154 
  tmp = fm10k_mbx_create_reply(hw,mbx,(unsigned short)((int)head));
  
#line 1154 
  return tmp;
}


#line 1165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_process_data(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u16 head;
  u16 tail;
  s32 err;
  s32 tmp;
  
#line 1168 
  u32 const *hdr = (u32 const *)(& mbx->mbx_hdr);
  
#line 1173 
  head = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 8)) & 15U);
  
#line 1174 
  tail = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 4)) & 15U);
  
#line 1177 
  if (mbx->state == (unsigned int)FM10K_STATE_CONNECT) {
    
#line 1178 
    mbx->tail = head;
    
#line 1179 
    mbx->state = FM10K_STATE_OPEN;
  }
  else ;
  
#line 1183 
  err = fm10k_mbx_push_tail(hw,mbx,(unsigned short)((int)tail));
  
#line 1184 
  if (err < 0) {
    
#line 1185 
    __retres = err;
    
#line 1185 
    goto return_label;
  }
  else ;
  
#line 1188 
  err = fm10k_mbx_verify_remote_crc(mbx);
  
#line 1189 
  if (err != 0) {
    
#line 1190 
    __retres = err;
    
#line 1190 
    goto return_label;
  }
  else ;
  
#line 1193 
  fm10k_mbx_dequeue_rx(hw,mbx);
  
#line 1195 
  tmp = fm10k_mbx_create_reply(hw,mbx,(unsigned short)((int)head));
  
#line 1195 
  __retres = tmp;
  return_label: 
#line 1195 
                return __retres;
}


#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_process_disconnect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u16 head;
  s32 err;
  s32 tmp_1;
  
#line 1209 
  enum fm10k_mbx_state const state = mbx->state;
  
#line 1210 
  u32 const *hdr = (u32 const *)(& mbx->mbx_hdr);
  
#line 1215 
  head = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 8)) & 15U);
  
#line 1218 
  if ((unsigned int)mbx->pushed != 0U) {
    
#line 1219 
    __retres = -507;
    
#line 1219 
    goto return_label;
  }
  else ;
  
#line 1222 
  mbx->head_len = (unsigned short)0U;
  
#line 1225 
  err = fm10k_mbx_verify_remote_crc(mbx);
  
#line 1226 
  if (err != 0) {
    
#line 1227 
    __retres = err;
    
#line 1227 
    goto return_label;
  }
  else ;
  
#line 1229 
  switch ((unsigned int)state) {
    int tmp_0;
    bool tmp;
    case (unsigned int)3: 
#line 1230 
    ;
    case (unsigned int)2: 
#line 1231 
    ;
    
#line 1233 
    tmp = fm10k_mbx_tx_complete(mbx);
    
#line 1233 
    if (tmp) 
#line 1233 
             tmp_0 = 0; else 
#line 1233 
                             tmp_0 = 1;
    
#line 1233 
    if (tmp_0) 
#line 1234 
               goto ldv_44333; else ;
    
#line 1237 
    if ((int)mbx->tail != (int)head) {
      
#line 1238 
      __retres = -506;
      
#line 1238 
      goto return_label;
    }
    else ;
    
#line 1241 
    fm10k_mbx_connect_reset(mbx);
    
#line 1242 
    goto ldv_44333;
    default: 
#line 1243 
    ;
    
#line 1244 
    goto ldv_44333;
  }
  ldv_44333: 
#line 1247 
  ;
  
#line 1247 
  tmp_1 = fm10k_mbx_create_reply(hw,mbx,(unsigned short)((int)head));
  
#line 1247 
  __retres = tmp_1;
  return_label: 
#line 1247 
                return __retres;
}


#line 1258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_process_error(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u16 head;
  s32 tmp;
  
#line 1261 
  u32 const *hdr = (u32 const *)(& mbx->mbx_hdr);
  
#line 1265 
  head = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 8)) & 15U);
  
#line 1267 
  switch ((unsigned int)mbx->state) {
    case (unsigned int)2: 
#line 1268 
    ;
    case (unsigned int)3: 
#line 1269 
    ;
    
#line 1271 
    fm10k_mbx_reset_work(mbx);
    
#line 1274 
    mbx->local = (unsigned short)65535U;
    
#line 1275 
    mbx->remote = (unsigned short)65535U;
    
#line 1278 
    mbx->tail = head;
    
#line 1281 
    if (mbx->state == (unsigned int)FM10K_STATE_OPEN) {
      
#line 1282 
      mbx->state = FM10K_STATE_CONNECT;
      
#line 1283 
      goto ldv_44343;
    }
    else ;
    
#line 1287 
    fm10k_mbx_create_connect_hdr(mbx);
    
#line 1288 
    __retres = 0;
    
#line 1288 
    goto return_label;
    default: 
#line 1289 
    ;
    
#line 1290 
    goto ldv_44343;
  }
  ldv_44343: 
#line 1293 
  ;
  
#line 1293 
  tmp = fm10k_mbx_create_reply(hw,mbx,(unsigned short)((int)mbx->tail));
  
#line 1293 
  __retres = tmp;
  return_label: 
#line 1293 
                return __retres;
}


#line 1305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_process(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  s32 err;
  
#line 1311 
  if (mbx->state == (unsigned int)FM10K_STATE_CLOSED) {
    
#line 1312 
    __retres = 0;
    
#line 1312 
    goto return_label;
  }
  else ;
  
#line 1315 
  err = fm10k_mbx_read(hw,mbx);
  
#line 1316 
  if (err != 0) {
    
#line 1317 
    __retres = err;
    
#line 1317 
    goto return_label;
  }
  else ;
  
#line 1320 
  err = fm10k_mbx_validate_msg_hdr(mbx);
  
#line 1321 
  if (err < 0) 
#line 1322 
               goto msg_err; else ;
  
#line 1324 
  switch ((unsigned int)((unsigned short)mbx->mbx_hdr) & 15U) {
    case (unsigned int)12: 
#line 1325 
    ;
    
#line 1326 
    err = fm10k_mbx_process_connect(hw,mbx);
    
#line 1327 
    goto ldv_44352;
    case (unsigned int)8: 
#line 1328 
    ;
    
#line 1329 
    err = fm10k_mbx_process_data(hw,mbx);
    
#line 1330 
    goto ldv_44352;
    case (unsigned int)13: 
#line 1331 
    ;
    
#line 1332 
    err = fm10k_mbx_process_disconnect(hw,mbx);
    
#line 1333 
    goto ldv_44352;
    case (unsigned int)14: 
#line 1334 
    ;
    
#line 1335 
    err = fm10k_mbx_process_error(hw,mbx);
    
#line 1336 
    goto ldv_44352;
    default: 
#line 1337 
    ;
    
#line 1338 
    err = -503;
    
#line 1339 
    goto ldv_44352;
  }
  ldv_44352: 
#line 1342 
  ;
  msg_err: 
#line 1342 
  ;
  
#line 1344 
  if (err < 0) 
#line 1345 
               fm10k_mbx_create_error_msg(mbx,err); else ;
  
#line 1348 
  fm10k_mbx_write(hw,mbx);
  
#line 1350 
  __retres = err;
  return_label: 
#line 1350 
                return __retres;
}


#line 1366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_mbx_disconnect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  int tmp;
  
#line 1369 
  if (mbx->timeout != 0U) 
#line 1369 
                          tmp = 500; else 
#line 1369 
                                          tmp = 0;
  
#line 1369 
  int timeout = tmp;
  
#line 1372 
  mbx->state = FM10K_STATE_DISCONNECT;
  {
    u32 * volatile *tmp_0;
    {
      
#line 1375 
      u32 *__var = (u32 *)0U;
      
#line 1375 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1375 
    u32 *hw_addr = *tmp_0;
    
#line 1375 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 1375 
                                            writel(66U,(void volatile *)(hw_addr + mbx->mbx_reg)); else ;
  }
  ldv_44365: 
#line 1377 
  ;
  
#line 1378 
  __const_udelay(81605UL);
  
#line 1379 
  (*(mbx->ops.process))(hw,mbx);
  
#line 1380 
  timeout += -19;
  
#line 1381 
  if (timeout > 0 && mbx->state != (unsigned int)FM10K_STATE_CLOSED) 
    
#line 1383 
    goto ldv_44365; else 
#line 1386 
                         goto ldv_44366;
  ldv_44366: 
#line 1387 
  ;
  
#line 1386 
  fm10k_mbx_connect_reset(mbx);
  
#line 1387 
  fm10k_fifo_drop_all(& mbx->tx);
  {
    u32 * volatile *tmp_1;
    {
      
#line 1389 
      u32 *__var_0 = (u32 *)0U;
      
#line 1389 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1389 
    u32 *hw_addr_0 = *tmp_1;
    
#line 1389 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 1389 
                                              writel(0U,(void volatile *)(hw_addr_0 + mbx->mbmem_reg)); else ;
  }
  
#line 1391 
  return;
}


#line 1405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_connect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  
#line 1408 
  if (mbx->rx.buffer == (u32 *)0U) {
    
#line 1409 
    __retres = -509;
    
#line 1409 
    goto return_label;
  }
  else ;
  
#line 1412 
  if (mbx->state != (unsigned int)FM10K_STATE_CLOSED) {
    
#line 1413 
    __retres = -500;
    
#line 1413 
    goto return_label;
  }
  else ;
  
#line 1416 
  mbx->timeout = 2000U;
  
#line 1419 
  mbx->state = FM10K_STATE_CONNECT;
  
#line 1422 
  fm10k_mbx_create_disconnect_hdr(mbx);
  {
    u32 * volatile *tmp;
    {
      
#line 1423 
      u32 *__var = (u32 *)0U;
      
#line 1423 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1423 
    u32 *hw_addr = *tmp;
    
#line 1423 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 1423 
                                            writel(mbx->mbx_hdr,(void volatile *)(hw_addr + (mbx->mbmem_reg ^ (unsigned int)mbx->mbmem_len))); else ;
  }
  
#line 1426 
  mbx->mbx_lock = 56U;
  
#line 1430 
  fm10k_mbx_create_connect_hdr(mbx);
  
#line 1431 
  fm10k_mbx_write(hw,mbx);
  
#line 1433 
  __retres = 0;
  return_label: 
#line 1433 
                return __retres;
}


#line 1444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_validate_handlers(struct fm10k_msg_data const *msg_data)
{
  s32 __retres;
  struct fm10k_tlv_attr const *attr;
  unsigned int id;
  
#line 1450 
  if (msg_data == (struct fm10k_msg_data const *)0) {
    
#line 1451 
    __retres = 0;
    
#line 1451 
    goto return_label;
  }
  else ;
  
#line 1453 
  goto ldv_44386;
  ldv_44385: 
#line 1454 
  ;
  
#line 1455 
  if (msg_data->func == (s32 (*)(struct fm10k_hw *, u32 **, struct fm10k_mbx_info *))0) {
    
#line 1456 
    __retres = -2;
    
#line 1456 
    goto return_label;
  }
  else ;
  
#line 1459 
  attr = msg_data->attr;
  
#line 1460 
  if (attr != (struct fm10k_tlv_attr const *)0) {
    
#line 1461 
    goto ldv_44383;
    ldv_44382: 
#line 1462 
    ;
    
#line 1462 
    id = attr->id;
    
#line 1463 
    attr += 1;
    
#line 1465 
    if (attr->id <= id) {
      
#line 1466 
      __retres = -2;
      
#line 1466 
      goto return_label;
    }
    else ;
    
#line 1468 
    if (id > 31U) {
      
#line 1469 
      __retres = -2;
      
#line 1469 
      goto return_label;
    }
    else ;
    ldv_44383: 
#line 1470 
    ;
    
#line 1461 
    if (attr->id != 4294967295U) 
#line 1463 
                                 goto ldv_44382; else 
#line 1466 
                                                      goto ldv_44384;
    ldv_44384: 
#line 1467 
    ;
    
#line 1473 
    if (attr->id != 4294967295U) {
      
#line 1474 
      __retres = -2;
      
#line 1474 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1477 
  id = msg_data->id;
  
#line 1478 
  msg_data += 1;
  
#line 1480 
  if (msg_data->id <= id) {
    
#line 1481 
    __retres = -2;
    
#line 1481 
    goto return_label;
  }
  else ;
  ldv_44386: 
#line 1482 
  ;
  
#line 1453 
  if (msg_data->id != 4294967295U) 
#line 1455 
                                   goto ldv_44385; else 
#line 1458 
                                                        goto ldv_44387;
  ldv_44387: 
#line 1459 
  ;
  
#line 1485 
  if (msg_data->id != 4294967295U || msg_data->func == (s32 (*)(struct fm10k_hw *, u32 **, struct fm10k_mbx_info *))0) {
    
#line 1486 
    __retres = -2;
    
#line 1486 
    goto return_label;
  }
  else ;
  
#line 1488 
  __retres = 0;
  return_label: 
#line 1488 
                return __retres;
}


#line 1498  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_mbx_register_handlers(struct fm10k_mbx_info *mbx, struct fm10k_msg_data const *msg_data)
{
  s32 __retres;
  s32 tmp;
  
#line 1502 
  tmp = fm10k_mbx_validate_handlers(msg_data);
  
#line 1502 
  if (tmp != 0) {
    
#line 1503 
    __retres = -2;
    
#line 1503 
    goto return_label;
  }
  else ;
  
#line 1506 
  mbx->msg_data = msg_data;
  
#line 1508 
  __retres = 0;
  return_label: 
#line 1508 
                return __retres;
}


#line 1525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
s32 fm10k_pfvf_mbx_init(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, struct fm10k_msg_data const *msg_data, u8 id)
{
  s32 __retres;
  s32 tmp;
  
#line 1529 
  switch ((unsigned int)hw->mac.type) {
    case (unsigned int)2: 
#line 1530 
    ;
    
#line 1531 
    mbx->mbx_reg = 16U;
    
#line 1532 
    mbx->mbmem_reg = 40U;
    
#line 1533 
    goto ldv_44399;
    case (unsigned int)1: 
#line 1534 
    ;
    
#line 1536 
    if ((unsigned int)id <= 63U) {
      
#line 1537 
      mbx->mbx_reg = (unsigned int)((int)id + 100352);
      
#line 1538 
      mbx->mbmem_reg = (unsigned int)(((int)id + 6144) * 16);
      
#line 1539 
      goto ldv_44399;
    }
    else ;
    default: 
#line 1542 
    ;
    
#line 1543 
    __retres = -511;
    
#line 1543 
    goto return_label;
  }
  ldv_44399: 
#line 1547 
  ;
  
#line 1547 
  mbx->state = FM10K_STATE_CLOSED;
  
#line 1550 
  tmp = fm10k_mbx_validate_handlers(msg_data);
  
#line 1550 
  if (tmp != 0) {
    
#line 1551 
    __retres = -2;
    
#line 1551 
    goto return_label;
  }
  else ;
  
#line 1554 
  mbx->msg_data = msg_data;
  
#line 1559 
  mbx->timeout = 0U;
  
#line 1560 
  mbx->udelay = 500U;
  
#line 1563 
  mbx->tail = (unsigned short)1U;
  
#line 1564 
  mbx->head = (unsigned short)1U;
  
#line 1567 
  mbx->local = (unsigned short)65535U;
  
#line 1568 
  mbx->remote = (unsigned short)65535U;
  
#line 1571 
  mbx->max_size = (unsigned short)127U;
  
#line 1572 
  mbx->mbmem_len = (unsigned short)8U;
  
#line 1575 
  fm10k_fifo_init(& mbx->tx,(u32 *)(& mbx->buffer),(unsigned short)512);
  
#line 1576 
  fm10k_fifo_init(& mbx->rx,& mbx->buffer[512],(unsigned short)128);
  
#line 1580 
  mbx->ops.connect = & fm10k_mbx_connect;
  
#line 1581 
  mbx->ops.disconnect = & fm10k_mbx_disconnect;
  
#line 1582 
  mbx->ops.rx_ready = & fm10k_mbx_rx_ready;
  
#line 1583 
  mbx->ops.tx_ready = & fm10k_mbx_tx_ready;
  
#line 1584 
  mbx->ops.tx_complete = & fm10k_mbx_tx_complete;
  
#line 1585 
  mbx->ops.enqueue_tx = & fm10k_mbx_enqueue_tx;
  
#line 1586 
  mbx->ops.process = & fm10k_mbx_process;
  
#line 1587 
  mbx->ops.register_handlers = & fm10k_mbx_register_handlers;
  
#line 1589 
  __retres = 0;
  return_label: 
#line 1589 
                return __retres;
}


#line 1598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_create_data_hdr(struct fm10k_mbx_info *mbx)
{
  
#line 1600 
  if ((unsigned int)mbx->tail_len != 0U) 
#line 1601 
                                         mbx->mbx_lock |= 2U; else ;
  
#line 1603 
  mbx->mbx_hdr = (((unsigned int)mbx->tail & 4095U) | (((unsigned int)mbx->remote << 12) & 65535U)) | (((unsigned int)mbx->head << 16) & 268369920U);
  
#line 1606 
  return;
}


#line 1615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_create_connect_hdr(struct fm10k_mbx_info *mbx, u8 err)
{
  
#line 1617 
  if ((unsigned int)mbx->local != 0U) 
#line 1618 
                                      mbx->mbx_lock |= 2U; else ;
  
#line 1620 
  mbx->mbx_hdr = ((((unsigned int)mbx->tail & 4095U) | (((unsigned int)mbx->remote << 12) & 65535U)) | (((unsigned int)mbx->head << 16) & 268369920U)) | ((unsigned int)err << 28);
  
#line 1624 
  return;
}


#line 1632  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_connect_reset(struct fm10k_mbx_info *mbx)
{
  
#line 1635 
  fm10k_mbx_reset_work(mbx);
  
#line 1638 
  mbx->local = (unsigned short)1U;
  
#line 1639 
  mbx->remote = (unsigned short)0U;
  
#line 1642 
  mbx->tail = (unsigned short)1U;
  
#line 1643 
  mbx->head = (unsigned short)1U;
  
#line 1646 
  mbx->state = FM10K_STATE_CONNECT;
  
#line 1647 
  return;
}


#line 1661  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_sm_mbx_connect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  
#line 1664 
  if (mbx->rx.buffer == (u32 *)0U) {
    
#line 1665 
    __retres = -509;
    
#line 1665 
    goto return_label;
  }
  else ;
  
#line 1668 
  if (mbx->state != (unsigned int)FM10K_STATE_CLOSED) {
    
#line 1669 
    __retres = -500;
    
#line 1669 
    goto return_label;
  }
  else ;
  
#line 1672 
  mbx->timeout = 2000U;
  
#line 1675 
  mbx->state = FM10K_STATE_CONNECT;
  
#line 1676 
  mbx->max_size = (unsigned short)127U;
  
#line 1679 
  fm10k_sm_mbx_connect_reset(mbx);
  
#line 1682 
  mbx->mbx_lock = 56U;
  
#line 1686 
  fm10k_sm_mbx_create_connect_hdr(mbx,(unsigned char)0);
  
#line 1687 
  fm10k_mbx_write(hw,mbx);
  
#line 1691 
  __retres = 0;
  return_label: 
#line 1691 
                return __retres;
}


#line 1707  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_disconnect(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  int tmp;
  
#line 1710 
  if (mbx->timeout != 0U) 
#line 1710 
                          tmp = 500; else 
#line 1710 
                                          tmp = 0;
  
#line 1710 
  int timeout = tmp;
  
#line 1713 
  mbx->state = FM10K_STATE_DISCONNECT;
  {
    u32 * volatile *tmp_0;
    {
      
#line 1716 
      u32 *__var = (u32 *)0U;
      
#line 1716 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1716 
    u32 *hw_addr = *tmp_0;
    
#line 1716 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 1716 
                                            writel(66U,(void volatile *)(hw_addr + mbx->mbx_reg)); else ;
  }
  ldv_44424: 
#line 1718 
  ;
  
#line 1719 
  __const_udelay(81605UL);
  
#line 1720 
  (*(mbx->ops.process))(hw,mbx);
  
#line 1721 
  timeout += -19;
  
#line 1722 
  if (timeout > 0 && mbx->state != (unsigned int)FM10K_STATE_CLOSED) 
    
#line 1724 
    goto ldv_44424; else 
#line 1727 
                         goto ldv_44425;
  ldv_44425: 
#line 1728 
  ;
  
#line 1725 
  mbx->state = FM10K_STATE_CLOSED;
  
#line 1726 
  mbx->remote = (unsigned short)0U;
  
#line 1727 
  fm10k_mbx_reset_work(mbx);
  
#line 1728 
  fm10k_mbx_update_max_size(mbx,(unsigned short)0);
  {
    u32 * volatile *tmp_1;
    {
      
#line 1730 
      u32 *__var_0 = (u32 *)0U;
      
#line 1730 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1730 
    u32 *hw_addr_0 = *tmp_1;
    
#line 1730 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 1730 
                                              writel(0U,(void volatile *)(hw_addr_0 + mbx->mbmem_reg)); else ;
  }
  
#line 1732 
  return;
}


#line 1741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_sm_mbx_validate_fifo_hdr(struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u16 tail;
  u16 head;
  u16 ver;
  
#line 1743 
  u32 const *hdr = (u32 const *)(& mbx->mbx_hdr);
  
#line 1746 
  tail = (unsigned short)((unsigned int)((unsigned short)*hdr) & 4095U);
  
#line 1747 
  ver = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 12)) & 15U);
  
#line 1748 
  head = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 16)) & 4095U);
  
#line 1750 
  switch ((int)ver) {
    u16 tmp;
    u16 tmp_0;
    case 0: 
#line 1751 
    ;
    
#line 1752 
    goto ldv_44437;
    case 1: 
#line 1753 
    ;
    
#line 1754 
    if ((unsigned int)head + 65535U > 510U) {
      
#line 1755 
      __retres = -506;
      
#line 1755 
      goto return_label;
    }
    else ;
    
#line 1756 
    if ((unsigned int)tail + 65535U > 510U) {
      
#line 1757 
      __retres = -507;
      
#line 1757 
      goto return_label;
    }
    else ;
    
#line 1758 
    if ((int)mbx->tail < (int)head) 
#line 1759 
                                    head = (unsigned short)((unsigned int)((int)mbx->mbmem_len + (int)head) + 65535U); else ;
    
#line 1760 
    if ((int)mbx->head > (int)tail) 
#line 1761 
                                    tail = (unsigned short)((unsigned int)((int)mbx->mbmem_len + (int)tail) + 65535U); else ;
    
#line 1762 
    tmp = fm10k_mbx_index_len(mbx,(unsigned short)((int)head),(unsigned short)((int)mbx->tail));
    
#line 1762 
    ;
    
#line 1762 
    if ((int)tmp > (int)mbx->tail_len) {
      
#line 1763 
      __retres = -506;
      
#line 1763 
      goto return_label;
    }
    else ;
    
#line 1764 
    tmp_0 = fm10k_mbx_index_len(mbx,(unsigned short)((int)mbx->head),(unsigned short)((int)tail));
    
#line 1764 
    ;
    
#line 1764 
    if ((int)tmp_0 < (int)mbx->mbmem_len) 
#line 1765 
                                          goto ldv_44437; else ;
    
#line 1766 
    __retres = -507;
    
#line 1766 
    goto return_label;
    default: 
#line 1767 
    ;
    
#line 1768 
    __retres = -504;
    
#line 1768 
    goto return_label;
  }
  ldv_44437: 
#line 1771 
  ;
  
#line 1771 
  __retres = 0;
  return_label: 
#line 1771 
                return __retres;
}


#line 1783  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_process_error(struct fm10k_mbx_info *mbx)
{
  
#line 1785 
  enum fm10k_mbx_state const state = mbx->state;
  
#line 1787 
  switch ((unsigned int)state) {
    case (unsigned int)3: 
#line 1788 
    ;
    
#line 1790 
    mbx->remote = (unsigned short)0U;
    
#line 1791 
    goto ldv_44445;
    case (unsigned int)2: 
#line 1792 
    ;
    
#line 1794 
    fm10k_sm_mbx_connect_reset(mbx);
    
#line 1795 
    goto ldv_44445;
    case (unsigned int)1: 
#line 1796 
    ;
    
#line 1798 
    if ((unsigned int)mbx->remote != 0U) {
      
#line 1799 
      goto ldv_44449;
      ldv_44448: 
#line 1800 
      ;
      
#line 1800 
      mbx->local = (u16)((int)mbx->local - 1);
      ldv_44449: 
#line 1801 
      ;
      
#line 1799 
      if ((unsigned int)mbx->local > 1U) 
#line 1801 
                                         goto ldv_44448; else 
#line 1804 
                                                              goto ldv_44450;
      ldv_44450: 
#line 1805 
      ;
      
#line 1801 
      mbx->remote = (unsigned short)0U;
    }
    else ;
    
#line 1803 
    goto ldv_44445;
    default: 
#line 1804 
    ;
    
#line 1805 
    goto ldv_44445;
  }
  ldv_44445: 
#line 1808 
  ;
  
#line 1808 
  fm10k_sm_mbx_create_connect_hdr(mbx,(unsigned char)0);
  
#line 1809 
  return;
}


#line 1819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_create_error_msg(struct fm10k_mbx_info *mbx, s32 err)
{
  
#line 1822 
  switch (err) {
    case -507: 
#line 1823 
    ;
    case -506: 
#line 1824 
    ;
    case -504: 
#line 1825 
    ;
    case -501: 
#line 1826 
    ;
    case -498: 
#line 1827 
    ;
    
#line 1828 
    goto ldv_44461;
    default: 
#line 1829 
    ;
    
#line 1830 
    goto return_label;
  }
  ldv_44461: 
#line 1834 
  ;
  
#line 1834 
  fm10k_sm_mbx_process_error(mbx);
  
#line 1835 
  fm10k_sm_mbx_create_connect_hdr(mbx,(unsigned char)1);
  return_label: 
#line 1836 
                return;
}


#line 1846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_sm_mbx_receive(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, u16 tail)
{
  s32 __retres;
  s32 err;
  
#line 1851 
  u16 mbmem_len = (unsigned short)((unsigned int)mbx->mbmem_len + 65535U);
  
#line 1855 
  if ((int)mbx->head > (int)tail) 
#line 1856 
                                  tail = (unsigned short)((int)tail + (int)mbmem_len); else ;
  
#line 1859 
  err = fm10k_mbx_push_tail(hw,mbx,(unsigned short)((int)tail));
  
#line 1860 
  if (err < 0) {
    
#line 1861 
    __retres = err;
    
#line 1861 
    goto return_label;
  }
  else ;
  
#line 1864 
  fm10k_mbx_dequeue_rx(hw,mbx);
  
#line 1867 
  mbx->head = fm10k_mbx_head_sub(mbx,(unsigned short)((int)mbx->pushed));
  
#line 1868 
  mbx->pushed = (unsigned short)0U;
  
#line 1871 
  if ((int)mbx->head > (int)mbmem_len) 
#line 1872 
                                       mbx->head = (unsigned short)((int)mbx->head - (int)mbmem_len); else ;
  
#line 1874 
  __retres = err;
  return_label: 
#line 1874 
                return __retres;
}


#line 1885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_transmit(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, u16 head)
{
  u16 tail_len;
  u32 *msg;
  u16 tmp;
  
#line 1888 
  struct fm10k_mbx_fifo *fifo = & mbx->tx;
  
#line 1890 
  u16 mbmem_len = (unsigned short)((unsigned int)mbx->mbmem_len + 65535U);
  
#line 1891 
  u16 len = (unsigned short)0U;
  
#line 1895 
  if ((int)mbx->tail < (int)head) 
#line 1896 
                                  head = (unsigned short)((int)head + (int)mbmem_len); else ;
  
#line 1898 
  fm10k_mbx_pull_head(hw,mbx,(unsigned short)((int)head));
  ldv_44480: 
#line 1899 
  ;
  
#line 1902 
  tmp = fm10k_fifo_head_offset(fifo,(unsigned short)((int)len));
  
#line 1902 
  msg = fifo->buffer + (int)tmp;
  
#line 1903 
  tail_len = len;
  
#line 1904 
  len = (unsigned short)((unsigned int)((int)((unsigned short)(((unsigned long)*msg + 3145728UL) >> 22)) + (int)len) + 1U);
  
#line 1905 
  if ((int)mbx->tail_len >= (int)len && (int)len < (int)mbmem_len) 
#line 1907 
                                                                   goto ldv_44480; else 
                                                                    
#line 1910 
                                                                    goto ldv_44481;
  ldv_44481: 
#line 1911 
  ;
  
#line 1908 
  if ((int)mbx->tail_len > (int)tail_len) {
    
#line 1909 
    mbx->tail = fm10k_mbx_tail_sub(mbx,(unsigned short)((int)mbx->tail_len - (int)tail_len));
    
#line 1910 
    mbx->tail_len = tail_len;
  }
  else ;
  
#line 1914 
  if ((int)mbx->tail > (int)mbmem_len) 
#line 1915 
                                       mbx->tail = (unsigned short)((int)mbx->tail - (int)mbmem_len); else ;
  
#line 1916 
  return;
}


#line 1928  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_create_reply(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, u16 head)
{
  
#line 1931 
  switch ((unsigned int)mbx->state) {
    case (unsigned int)2: 
#line 1932 
    ;
    case (unsigned int)3: 
#line 1933 
    ;
    
#line 1935 
    fm10k_sm_mbx_transmit(hw,mbx,(unsigned short)((int)head));
    
#line 1938 
    if ((unsigned int)mbx->tail_len != 0U || mbx->state == (unsigned int)FM10K_STATE_OPEN) 
      
#line 1939 
      fm10k_sm_mbx_create_data_hdr(mbx);
    else {
      
#line 1941 
      mbx->remote = (unsigned short)0U;
      
#line 1942 
      fm10k_sm_mbx_create_connect_hdr(mbx,(unsigned char)0);
    }
    
#line 1944 
    goto ldv_44489;
    case (unsigned int)1: 
#line 1945 
    ;
    case (unsigned int)0: 
#line 1946 
    ;
    
#line 1947 
    fm10k_sm_mbx_create_connect_hdr(mbx,(unsigned char)0);
    
#line 1948 
    goto ldv_44489;
    default: 
#line 1949 
    ;
    
#line 1950 
    goto ldv_44489;
  }
  ldv_44489: 
#line 1952 
  ;
  
#line 1953 
  return;
}


#line 1965  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static void fm10k_sm_mbx_process_reset(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  
#line 1968 
  enum fm10k_mbx_state const state = mbx->state;
  
#line 1970 
  switch ((unsigned int)state) {
    case (unsigned int)3: 
#line 1971 
    ;
    
#line 1973 
    mbx->state = FM10K_STATE_CLOSED;
    
#line 1974 
    mbx->remote = (unsigned short)0U;
    
#line 1975 
    mbx->local = (unsigned short)0U;
    
#line 1976 
    goto ldv_44499;
    case (unsigned int)2: 
#line 1977 
    ;
    
#line 1979 
    fm10k_sm_mbx_connect_reset(mbx);
    
#line 1980 
    goto ldv_44499;
    case (unsigned int)1: 
#line 1981 
    ;
    
#line 1983 
    mbx->remote = mbx->local;
    default: 
#line 1984 
    ;
    
#line 1985 
    goto ldv_44499;
  }
  ldv_44499: 
#line 1988 
  ;
  
#line 1988 
  fm10k_sm_mbx_create_reply(hw,mbx,(unsigned short)((int)mbx->tail));
  
#line 1989 
  return;
}


#line 1999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_sm_mbx_process_version_1(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u16 head;
  u16 tail;
  s32 len;
  
#line 2002 
  u32 const *hdr = (u32 const *)(& mbx->mbx_hdr);
  
#line 2007 
  tail = (unsigned short)((unsigned int)((unsigned short)*hdr) & 4095U);
  
#line 2008 
  head = (unsigned short)((unsigned int)((unsigned short)(*hdr >> 16)) & 4095U);
  
#line 2011 
  if (mbx->state == (unsigned int)FM10K_STATE_CONNECT) {
    
#line 2012 
    if ((unsigned int)mbx->remote == 0U) 
#line 2013 
                                         goto send_reply; else ;
    
#line 2014 
    if ((unsigned int)mbx->remote != 1U) {
      
#line 2015 
      __retres = -504;
      
#line 2015 
      goto return_label;
    }
    else ;
    
#line 2017 
    mbx->state = FM10K_STATE_OPEN;
  }
  else ;
  ldv_44512: 
#line 2019 
  ;
  
#line 2022 
  len = fm10k_sm_mbx_receive(hw,mbx,(unsigned short)((int)tail));
  
#line 2023 
  if (len < 0) {
    
#line 2024 
    __retres = len;
    
#line 2024 
    goto return_label;
  }
  else ;
  
#line 2027 
  if (len != 0) 
#line 2029 
                goto ldv_44512; else 
#line 2032 
                                     goto ldv_44513;
  ldv_44513: 
#line 2033 
  ;
  send_reply: 
#line 2029 
  ;
  
#line 2030 
  fm10k_sm_mbx_create_reply(hw,mbx,(unsigned short)((int)head));
  
#line 2032 
  __retres = 0;
  return_label: 
#line 2032 
                return __retres;
}


#line 2044  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
static s32 fm10k_sm_mbx_process(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  s32 err;
  
#line 2050 
  if (mbx->state == (unsigned int)FM10K_STATE_CLOSED) {
    
#line 2051 
    __retres = 0;
    
#line 2051 
    goto return_label;
  }
  else ;
  
#line 2054 
  err = fm10k_mbx_read(hw,mbx);
  
#line 2055 
  if (err != 0) {
    
#line 2056 
    __retres = err;
    
#line 2056 
    goto return_label;
  }
  else ;
  
#line 2058 
  err = fm10k_sm_mbx_validate_fifo_hdr(mbx);
  
#line 2059 
  if (err < 0) 
#line 2060 
               goto fifo_err; else ;
  
#line 2062 
  if (((unsigned int)((unsigned short)(mbx->mbx_hdr >> 28)) & 15U) != 0U) {
    
#line 2063 
    fm10k_sm_mbx_process_error(mbx);
    
#line 2064 
    goto fifo_err;
  }
  else ;
  
#line 2067 
  switch ((unsigned int)((unsigned short)(mbx->mbx_hdr >> 12)) & 15U) {
    case (unsigned int)0: 
#line 2068 
    ;
    
#line 2069 
    fm10k_sm_mbx_process_reset(hw,mbx);
    
#line 2070 
    goto ldv_44521;
    case (unsigned int)1: 
#line 2071 
    ;
    
#line 2072 
    err = fm10k_sm_mbx_process_version_1(hw,mbx);
    
#line 2073 
    goto ldv_44521;
  }
  ldv_44521: 
#line 2076 
  ;
  fifo_err: 
#line 2076 
  ;
  
#line 2077 
  if (err < 0) 
#line 2078 
               fm10k_sm_mbx_create_error_msg(mbx,err); else ;
  
#line 2081 
  fm10k_mbx_write(hw,mbx);
  
#line 2083 
  __retres = err;
  return_label: 
#line 2083 
                return __retres;
}


#line 2094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_mbx.c"
s32 fm10k_sm_mbx_init(struct fm10k_hw *hw, struct fm10k_mbx_info *mbx, struct fm10k_msg_data const *msg_data)
{
  s32 __retres;
  s32 tmp;
  
#line 2097 
  mbx->mbx_reg = 100418U;
  
#line 2098 
  mbx->mbmem_reg = 99840U;
  
#line 2100 
  mbx->state = FM10K_STATE_CLOSED;
  
#line 2103 
  tmp = fm10k_mbx_validate_handlers(msg_data);
  
#line 2103 
  if (tmp != 0) {
    
#line 2104 
    __retres = -2;
    
#line 2104 
    goto return_label;
  }
  else ;
  
#line 2107 
  mbx->msg_data = msg_data;
  
#line 2112 
  mbx->timeout = 0U;
  
#line 2113 
  mbx->udelay = 500U;
  
#line 2116 
  mbx->max_size = (unsigned short)127U;
  
#line 2117 
  mbx->mbmem_len = (unsigned short)512U;
  
#line 2120 
  fm10k_fifo_init(& mbx->tx,(u32 *)(& mbx->buffer),(unsigned short)512);
  
#line 2121 
  fm10k_fifo_init(& mbx->rx,& mbx->buffer[512],(unsigned short)128);
  
#line 2125 
  mbx->ops.connect = & fm10k_sm_mbx_connect;
  
#line 2126 
  mbx->ops.disconnect = & fm10k_sm_mbx_disconnect;
  
#line 2127 
  mbx->ops.rx_ready = & fm10k_mbx_rx_ready;
  
#line 2128 
  mbx->ops.tx_ready = & fm10k_mbx_tx_ready;
  
#line 2129 
  mbx->ops.tx_complete = & fm10k_mbx_tx_complete;
  
#line 2130 
  mbx->ops.enqueue_tx = & fm10k_mbx_enqueue_tx;
  
#line 2131 
  mbx->ops.process = & fm10k_sm_mbx_process;
  
#line 2132 
  mbx->ops.register_handlers = & fm10k_mbx_register_handlers;
  
#line 2134 
  __retres = 0;
  return_label: 
#line 2134 
                return __retres;
}


#line 1777  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netdev_set_prio_tc_map(struct net_device *dev, u8 prio, u8 tc)
{
  int __retres;
  
#line 1779 
  if ((int)dev->num_tc <= (int)tc) {
    
#line 1780 
    __retres = -22;
    
#line 1780 
    goto return_label;
  }
  else ;
  
#line 1782 
  dev->prio_tc_map[(int)prio & 15] = (unsigned char)((unsigned int)tc & 15U);
  
#line 1783 
  __retres = 0;
  return_label: 
#line 1783 
                return __retres;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c"
static int fm10k_dcbnl_ieee_getets(struct net_device *dev, struct ieee_ets *ets)
{
  int __retres;
  int i;
  int tmp;
  
#line 34 
  ets->ets_cap = (unsigned char)8U;
  
#line 35 
  ets->cbs = (unsigned char)0U;
  
#line 38 
  memset((void *)(& ets->tc_tx_bw),0,8UL);
  
#line 39 
  memset((void *)(& ets->tc_rx_bw),0,8UL);
  
#line 40 
  memset((void *)(& ets->tc_tsa),0,8UL);
  
#line 43 
  i = 0;
  
#line 43 
  goto ldv_46971;
  ldv_46970: 
#line 44 
  ;
  
#line 44 
  tmp = netdev_get_prio_tc_map((struct net_device const *)dev,(unsigned int)i);
  
#line 44 
  ets->prio_tc[i] = (unsigned char)tmp;
  
#line 43 
  i += 1;
  ldv_46971: 
#line 44 
  ;
  
#line 43 
  if (i <= 7) 
#line 45 
              goto ldv_46970; else 
#line 48 
                                   goto ldv_46972;
  ldv_46972: 
#line 49 
  ;
  
#line 46 
  __retres = 0;
  
#line 46 
  return __retres;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c"
static int fm10k_dcbnl_ieee_setets(struct net_device *dev, struct ieee_ets *ets)
{
  int __retres;
  int i;
  int err;
  int tmp;
  
#line 56 
  u8 num_tc = (unsigned char)0U;
  
#line 60 
  i = 0;
  
#line 60 
  goto ldv_46981;
  ldv_46980: 
#line 61 
  ;
  
#line 61 
  if ((unsigned int)ets->tc_tx_bw[i] != 0U || (unsigned int)ets->tc_rx_bw[i] != 0U) {
    
#line 62 
    __retres = -22;
    
#line 62 
    goto return_label;
  }
  else ;
  
#line 63 
  if ((unsigned int)ets->tc_tsa[i] != 0U) {
    
#line 64 
    __retres = -22;
    
#line 64 
    goto return_label;
  }
  else ;
  
#line 65 
  if ((int)ets->prio_tc[i] > (int)num_tc) 
#line 66 
                                          num_tc = ets->prio_tc[i]; else ;
  
#line 60 
  i += 1;
  ldv_46981: 
#line 61 
  ;
  
#line 60 
  if (i <= 7) 
#line 62 
              goto ldv_46980; else 
#line 65 
                                   goto ldv_46982;
  ldv_46982: 
#line 66 
  ;
  
#line 70 
  if ((unsigned int)num_tc != 0U) 
#line 71 
                                  num_tc = (u8)((int)num_tc + 1); else ;
  
#line 73 
  if ((unsigned int)num_tc > 8U) {
    
#line 74 
    __retres = -22;
    
#line 74 
    goto return_label;
  }
  else ;
  
#line 77 
  tmp = netdev_get_num_tc(dev);
  
#line 77 
  ;
  
#line 77 
  if ((int)num_tc != tmp) {
    
#line 78 
    err = fm10k_setup_tc(dev,(unsigned char)((int)num_tc));
    
#line 79 
    if (err != 0) {
      
#line 80 
      __retres = err;
      
#line 80 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 84 
  i = 0;
  
#line 84 
  goto ldv_46984;
  ldv_46983: 
#line 85 
  ;
  
#line 85 
  netdev_set_prio_tc_map(dev,(unsigned char)((int)((unsigned char)i)),(unsigned char)((int)ets->prio_tc[i]));
  
#line 84 
  i += 1;
  ldv_46984: 
#line 85 
  ;
  
#line 84 
  if (i <= 7) 
#line 86 
              goto ldv_46983; else 
#line 89 
                                   goto ldv_46985;
  ldv_46985: 
#line 90 
  ;
  
#line 87 
  __retres = 0;
  return_label: 
#line 87 
                return __retres;
}


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c"
static int fm10k_dcbnl_ieee_getpfc(struct net_device *dev, struct ieee_pfc *pfc)
{
  int __retres;
  
#line 97 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 100 
  pfc->pfc_cap = (unsigned char)8U;
  
#line 101 
  pfc->pfc_en = interface->pfc_en;
  
#line 103 
  __retres = 0;
  
#line 103 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c"
static int fm10k_dcbnl_ieee_setpfc(struct net_device *dev, struct ieee_pfc *pfc)
{
  int __retres;
  bool tmp_0;
  
#line 113 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 116 
  interface->pfc_en = pfc->pfc_en;
  
#line 119 
  tmp_0 = netif_running((struct net_device const *)dev);
  
#line 119 
  if ((int)tmp_0 != 0) 
#line 120 
                       fm10k_update_rx_drop_en(interface); else ;
  
#line 122 
  __retres = 0;
  
#line 122 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c"
static u8 fm10k_dcbnl_getdcbx(struct net_device *dev)
{
  u8 __retres;
  
#line 133 
  __retres = (unsigned char)9U;
  
#line 133 
  return __retres;
}


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c"
static u8 fm10k_dcbnl_setdcbx(struct net_device *dev, u8 mode)
{
  u8 __retres;
  
#line 145 
  __retres = (unsigned char)((unsigned int)mode != 9U);
  
#line 145 
  return __retres;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c"
static struct dcbnl_rtnl_ops const fm10k_dcbnl_ops = {.ieee_getets = & fm10k_dcbnl_ieee_getets, .ieee_setets = & fm10k_dcbnl_ieee_setets, .ieee_getmaxrate = (int (*)(struct net_device *, struct ieee_maxrate *))0, .ieee_setmaxrate = (int (*)(struct net_device *, struct ieee_maxrate *))0, .ieee_getqcn = (int (*)(struct net_device *, struct ieee_qcn *))0, .ieee_setqcn = (int (*)(struct net_device *, struct ieee_qcn *))0, .ieee_getqcnstats = (int (*)(struct net_device *, struct ieee_qcn_stats *))0, .ieee_getpfc = & fm10k_dcbnl_ieee_getpfc, .ieee_setpfc = & fm10k_dcbnl_ieee_setpfc, .ieee_getapp = (int (*)(struct net_device *, struct dcb_app *))0, .ieee_setapp = (int (*)(struct net_device *, struct dcb_app *))0, .ieee_delapp = (int (*)(struct net_device *, struct dcb_app *))0, .ieee_peer_getets = (int (*)(struct net_device *, struct ieee_ets *))0, .ieee_peer_getpfc = (int (*)(struct net_device *, struct ieee_pfc *))0, .getstate = (u8 (*)(struct net_device *))0, .setstate = (u8 (*)(struct net_device *, u8 ))0, .getpermhwaddr = (void (*)(struct net_device *, u8 *))0, .setpgtccfgtx = (void (*)(struct net_device *, int , u8 , u8 , u8 , u8 ))0, .setpgbwgcfgtx = (void (*)(struct net_device *, int , u8 ))0, .setpgtccfgrx = (void (*)(struct net_device *, int , u8 , u8 , u8 , u8 ))0, .setpgbwgcfgrx = (void (*)(struct net_device *, int , u8 ))0, .getpgtccfgtx = (void (*)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *))0, .getpgbwgcfgtx = (void (*)(struct net_device *, int , u8 *))0, .getpgtccfgrx = (void (*)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *))0, .getpgbwgcfgrx = (void (*)(struct net_device *, int , u8 *))0, .setpfccfg = (void (*)(struct net_device *, int , u8 ))0, .getpfccfg = (void (*)(struct net_device *, int , u8 *))0, .setall = (u8 (*)(struct net_device *))0, .getcap = (u8 (*)(struct net_device *, int , u8 *))0, .getnumtcs = (int (*)(struct net_device *, int , u8 *))0, .setnumtcs = (int (*)(struct net_device *, int , u8 ))0, .getpfcstate = (u8 (*)(struct net_device *))0, .setpfcstate = (void (*)(struct net_device *, u8 ))0, .getbcncfg = (void (*)(struct net_device *, int , u32 *))0, .setbcncfg = (void (*)(struct net_device *, int , u32 ))0, .getbcnrp = (void (*)(struct net_device *, int , u8 *))0, .setbcnrp = (void (*)(struct net_device *, int , u8 ))0, .setapp = (int (*)(struct net_device *, u8 , u16 , u8 ))0, .getapp = (int (*)(struct net_device *, u8 , u16 ))0, .getfeatcfg = (u8 (*)(struct net_device *, int , u8 *))0, .setfeatcfg = (u8 (*)(struct net_device *, int , u8 ))0, .getdcbx = & fm10k_dcbnl_getdcbx, .setdcbx = & fm10k_dcbnl_setdcbx, .peer_getappinfo = (int (*)(struct net_device *, struct dcb_peer_app_info *, u16 *))0, .peer_getapptable = (int (*)(struct net_device *, struct dcb_app *))0, .cee_peer_getpg = (int (*)(struct net_device *, struct cee_pg *))0, .cee_peer_getpfc = (int (*)(struct net_device *, struct cee_pfc *))0};

#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_dcbnl.c"
void fm10k_dcbnl_set_ops(struct net_device *dev)
{
  
#line 168 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)dev);
  
#line 169 
  struct fm10k_hw *hw = & interface->hw;
  
#line 171 
  if (hw->mac.type == (unsigned int)fm10k_mac_pf) 
#line 172 
                                                  dev->dcbnl_ops = & fm10k_dcbnl_ops; else ;
  
#line 173 
  return;
}


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.h"
s32 fm10k_msg_update_pvid_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx);


#line 132 
struct fm10k_msg_data const fm10k_iov_msg_data_pf[5U];


#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_reset_hw_pf(struct fm10k_hw *hw)
{
  s32 __retres;
  s32 err;
  u32 reg;
  u16 i;
  {
    u32 * volatile *tmp;
    {
      
#line 38 
      u32 *__var = (u32 *)0U;
      
#line 38 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 38 
    u32 *hw_addr = *tmp;
    
#line 38 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 38 
                                            writel(1431655765U,(void volatile *)(hw_addr + 7U)); else ;
  }
  {
    u32 * volatile *tmp_0;
    {
      
#line 41 
      u32 *__var_0 = (u32 *)0U;
      
#line 41 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 41 
    u32 *hw_addr_0 = *tmp_0;
    
#line 41 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 41 
                                              writel(0U,(void volatile *)(hw_addr_0 + 75776U)); else ;
  }
  {
    u32 * volatile *tmp_1;
    {
      
#line 42 
      u32 *__var_1 = (u32 *)0U;
      
#line 42 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 42 
    u32 *hw_addr_1 = *tmp_1;
    
#line 42 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 42 
                                              writel(0U,(void volatile *)(hw_addr_1 + 73728U)); else ;
  }
  
#line 47 
  i = (unsigned short)0U;
  
#line 47 
  goto ldv_44156;
  ldv_44155: 
#line 48 
  ;
  {
    u32 * volatile *tmp_2;
    {
      
#line 48 
      u32 *__var_2 = (u32 *)0U;
      
#line 48 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 48 
    u32 *hw_addr_2 = *tmp_2;
    
#line 48 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 48 
                                              writel(0U,(void volatile *)(hw_addr_2 + ((unsigned int)i + 10240U))); else ;
  }
  {
    u32 * volatile *tmp_3;
    {
      
#line 49 
      u32 *__var_3 = (u32 *)0U;
      
#line 49 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 49 
    u32 *hw_addr_3 = *tmp_3;
    
#line 49 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 49 
                                              writel(0U,(void volatile *)(hw_addr_3 + ((unsigned int)i + 12288U))); else ;
  }
  
#line 47 
  i = (u16)((int)i + 1);
  ldv_44156: 
#line 48 
  ;
  
#line 47 
  if ((unsigned int)i <= 2047U) 
#line 49 
                                goto ldv_44155; else 
#line 52 
                                                     goto ldv_44157;
  ldv_44157: 
#line 53 
  ;
  
#line 53 
  err = fm10k_disable_queues_generic(hw,(unsigned short)256);
  
#line 54 
  if (err != 0) {
    
#line 55 
    __retres = err;
    
#line 55 
    goto return_label;
  }
  else ;
  
#line 58 
  reg = fm10k_read_reg(hw,8387);
  
#line 59 
  if ((reg & 136U) != 0U) {
    
#line 60 
    __retres = -6;
    
#line 60 
    goto return_label;
  }
  else ;
  
#line 63 
  reg |= 536870912U;
  {
    u32 * volatile *tmp_4;
    {
      
#line 64 
      u32 *__var_4 = (u32 *)0U;
      
#line 64 
      tmp_4 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 64 
    u32 *hw_addr_4 = *tmp_4;
    
#line 64 
    if ((long)(hw_addr_4 == (u32 *)0U) == 0L) 
#line 64 
                                              writel(reg,(void volatile *)(hw_addr_4 + 8387U)); else ;
  }
  
#line 67 
  fm10k_read_reg(hw,0);
  
#line 68 
  __const_udelay(644250UL);
  
#line 71 
  reg = fm10k_read_reg(hw,77824);
  
#line 72 
  if ((reg & 256U) == 0U) 
#line 73 
                          err = -7; else ;
  
#line 75 
  __retres = err;
  return_label: 
#line 75 
                return __retres;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static bool fm10k_is_ari_hierarchy_pf(struct fm10k_hw *hw)
{
  bool __retres;
  
#line 86 
  u16 sriov_ctrl = fm10k_read_pci_cfg_word(hw,400U);
  
#line 88 
  __retres = (_Bool)(((int)sriov_ctrl & 16) != 0);
  
#line 88 
  return __retres;
}


#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_init_hw_pf(struct fm10k_hw *hw)
{
  s32 __retres;
  u32 dma_ctrl;
  u32 txqctl;
  u16 i;
  bool tmp_13;
  {
    u32 * volatile *tmp;
    {
      
#line 102 
      u32 *__var = (u32 *)0U;
      
#line 102 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 102 
    u32 *hw_addr = *tmp;
    
#line 102 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 102 
                                            writel(0U,(void volatile *)(hw_addr + 56U)); else ;
  }
  {
    u32 * volatile *tmp_0;
    {
      
#line 103 
      u32 *__var_0 = (u32 *)0U;
      
#line 103 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 103 
    u32 *hw_addr_0 = *tmp_0;
    
#line 103 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 103 
                                              writel(0U,(void volatile *)(hw_addr_0 + 48U)); else ;
  }
  
#line 107 
  i = (unsigned short)1U;
  
#line 107 
  goto ldv_44181;
  ldv_44180: 
#line 108 
  ;
  {
    u32 * volatile *tmp_1;
    {
      
#line 108 
      u32 *__var_1 = (u32 *)0U;
      
#line 108 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 108 
    u32 *hw_addr_1 = *tmp_1;
    
#line 108 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 108 
                                              writel(65535U,(void volatile *)(hw_addr_1 + ((unsigned int)i + 48U))); else ;
  }
  
#line 107 
  i = (u16)((int)i + 1);
  ldv_44181: 
#line 108 
  ;
  
#line 107 
  if ((unsigned int)i <= 7U) 
#line 109 
                             goto ldv_44180; else 
#line 112 
                                                  goto ldv_44182;
  ldv_44182: 
#line 113 
  ;
  {
    u32 * volatile *tmp_2;
    {
      
#line 111 
      u32 *__var_2 = (u32 *)0U;
      
#line 111 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 111 
    u32 *hw_addr_2 = *tmp_2;
    
#line 111 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 111 
                                              writel(0U,(void volatile *)(hw_addr_2 + 75776U)); else ;
  }
  {
    u32 * volatile *tmp_3;
    {
      
#line 114 
      u32 *__var_3 = (u32 *)0U;
      
#line 114 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 114 
    u32 *hw_addr_3 = *tmp_3;
    
#line 114 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 114 
                                              writel(0U,(void volatile *)(hw_addr_3 + 76288U)); else ;
  }
  
#line 117 
  i = (unsigned short)1U;
  
#line 117 
  goto ldv_44193;
  ldv_44192: 
#line 118 
  ;
  {
    u32 * volatile *tmp_4;
    {
      
#line 118 
      u32 *__var_4 = (u32 *)0U;
      
#line 118 
      tmp_4 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 118 
    u32 *hw_addr_4 = *tmp_4;
    
#line 118 
    if ((long)(hw_addr_4 == (u32 *)0U) == 0L) 
#line 118 
                                              writel((unsigned int)((int)i + -1),(void volatile *)(hw_addr_4 + ((unsigned int)((int)i * 2) + 75776U))); else ;
  }
  
#line 117 
  i = (u16)((int)i + 1);
  ldv_44193: 
#line 118 
  ;
  
#line 117 
  if ((unsigned int)i <= 255U) 
#line 119 
                               goto ldv_44192; else 
#line 122 
                                                    goto ldv_44194;
  ldv_44194: 
#line 123 
  ;
  {
    u32 * volatile *tmp_5;
    {
      
#line 121 
      u32 *__var_5 = (u32 *)0U;
      
#line 121 
      tmp_5 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 121 
    u32 *hw_addr_5 = *tmp_5;
    
#line 121 
    if ((long)(hw_addr_5 == (u32 *)0U) == 0L) 
#line 121 
                                              writel(1024U,(void volatile *)(hw_addr_5 + 73728U)); else ;
  }
  
#line 124 
  txqctl = (unsigned int)(((int)hw->mac.default_vid << 16) | 268435519);
  
#line 127 
  i = (unsigned short)0U;
  
#line 127 
  goto ldv_44211;
  ldv_44210: 
#line 128 
  ;
  {
    u32 * volatile *tmp_6;
    {
      
#line 129 
      u32 *__var_6 = (u32 *)0U;
      
#line 129 
      tmp_6 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 129 
    u32 *hw_addr_6 = *tmp_6;
    
#line 129 
    if ((long)(hw_addr_6 == (u32 *)0U) == 0L) 
#line 129 
                                              writel((unsigned int)((int)i * 8 | 327680),(void volatile *)(hw_addr_6 + ((unsigned int)((int)i * 64) + 32780U))); else ;
  }
  {
    u32 * volatile *tmp_7;
    {
      
#line 132 
      u32 *__var_7 = (u32 *)0U;
      
#line 132 
      tmp_7 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 132 
    u32 *hw_addr_7 = *tmp_7;
    
#line 132 
    if ((long)(hw_addr_7 == (u32 *)0U) == 0L) 
#line 132 
                                              writel(txqctl,(void volatile *)(hw_addr_7 + ((unsigned int)((int)i * 64) + 32775U))); else ;
  }
  {
    u32 * volatile *tmp_8;
    {
      
#line 135 
      u32 *__var_8 = (u32 *)0U;
      
#line 135 
      tmp_8 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 135 
    u32 *hw_addr_8 = *tmp_8;
    
#line 135 
    if ((long)(hw_addr_8 == (u32 *)0U) == 0L) 
#line 135 
                                              writel(10784U,(void volatile *)(hw_addr_8 + ((unsigned int)((int)i * 64) + 32771U))); else ;
  }
  {
    u32 * volatile *tmp_9;
    {
      
#line 140 
      u32 *__var_9 = (u32 *)0U;
      
#line 140 
      tmp_9 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 140 
    u32 *hw_addr_9 = *tmp_9;
    
#line 140 
    if ((long)(hw_addr_9 == (u32 *)0U) == 0L) 
#line 140 
                                              writel(41504U,(void volatile *)(hw_addr_9 + ((unsigned int)((int)i * 64) + 16387U))); else ;
  }
  
#line 127 
  i = (u16)((int)i + 1);
  ldv_44211: 
#line 128 
  ;
  
#line 127 
  if ((unsigned int)i <= 255U) 
#line 129 
                               goto ldv_44210; else 
#line 132 
                                                    goto ldv_44212;
  ldv_44212: 
#line 133 
  ;
  
#line 148 
  switch ((unsigned int)hw->bus.speed) {
    case (unsigned int)2500: 
#line 149 
    ;
    
#line 150 
    dma_ctrl = 58720256U;
    
#line 151 
    goto ldv_44214;
    case (unsigned int)5000: 
#line 152 
    ;
    
#line 153 
    dma_ctrl = 67108864U;
    
#line 154 
    goto ldv_44214;
    case (unsigned int)8000: 
#line 155 
    ;
    
#line 156 
    dma_ctrl = 75497472U;
    
#line 157 
    goto ldv_44214;
    default: 
#line 158 
    ;
    
#line 159 
    dma_ctrl = 0U;
    
#line 160 
    goto ldv_44214;
  }
  ldv_44214: 
#line 164 
  ;
  {
    u32 * volatile *tmp_10;
    {
      
#line 164 
      u32 *__var_10 = (u32 *)0U;
      
#line 164 
      tmp_10 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 164 
    u32 *hw_addr_10 = *tmp_10;
    
#line 164 
    if ((long)(hw_addr_10 == (u32 *)0U) == 0L) 
#line 164 
                                               writel(3149814U,(void volatile *)(hw_addr_10 + 8389U)); else ;
  }
  {
    u32 * volatile *tmp_11;
    {
      
#line 165 
      u32 *__var_11 = (u32 *)0U;
      
#line 165 
      tmp_11 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 165 
    u32 *hw_addr_11 = *tmp_11;
    
#line 165 
    if ((long)(hw_addr_11 == (u32 *)0U) == 0L) 
#line 165 
                                               writel(57U,(void volatile *)(hw_addr_11 + 8390U)); else ;
  }
  
#line 172 
  dma_ctrl |= 33041U;
  {
    u32 * volatile *tmp_12;
    {
      
#line 176 
      u32 *__var_12 = (u32 *)0U;
      
#line 176 
      tmp_12 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 176 
    u32 *hw_addr_12 = *tmp_12;
    
#line 176 
    if ((long)(hw_addr_12 == (u32 *)0U) == 0L) 
#line 176 
                                               writel(dma_ctrl,(void volatile *)(hw_addr_12 + 8387U)); else ;
  }
  
#line 179 
  hw->mac.max_queues = (unsigned short)128U;
  
#line 182 
  tmp_13 = fm10k_is_ari_hierarchy_pf(hw);
  
#line 182 
  if ((int)tmp_13 != 0) 
#line 182 
                        hw->iov.total_vfs = (unsigned short)64U; else 
                                                                   
#line 182 
                                                                   hw->iov.total_vfs = (unsigned short)7U;
  
#line 184 
  __retres = 0;
  
#line 184 
  return __retres;
}


#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static bool fm10k_is_slot_appropriate_pf(struct fm10k_hw *hw)
{
  bool __retres;
  
#line 196 
  __retres = (_Bool)((hw->bus.speed == hw->bus_caps.speed && hw->bus.width == hw->bus_caps.width) != 0);
  
#line 196 
  return __retres;
}


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_update_vlan_pf(struct fm10k_hw *hw, u32 vid, u8 vsi, bool set)
{
  s32 __retres;
  u32 vlan_table;
  u32 reg;
  u32 mask;
  u32 bit;
  u32 len;
  unsigned int tmp;
  u32 tmp_0;
  
#line 217 
  if ((unsigned int)vsi > 64U) {
    
#line 218 
    __retres = -2;
    
#line 218 
    goto return_label;
  }
  else ;
  
#line 233 
  len = vid >> 16;
  
#line 234 
  vid &= 32767U;
  
#line 237 
  if (len > 4095U || vid > 4095U) {
    
#line 238 
    __retres = -2;
    
#line 238 
    goto return_label;
  }
  else ;
  
#line 241 
  reg = ((unsigned int)((int)vsi * 128) + vid / 32U) + 81920U;
  
#line 241 
  bit = vid & 31U;
  
#line 241 
  goto ldv_44245;
  ldv_44244: 
#line 242 
  ;
  
#line 245 
  vlan_table = fm10k_read_reg(hw,(int)reg);
  
#line 248 
  if (len <= 30U) 
#line 248 
                  tmp = 4294967295U >> (31U - len); else 
#line 248 
                                                         tmp = 4294967295U;
  
#line 248 
  mask = tmp << bit;
  
#line 251 
  if ((int)set != 0) 
#line 251 
                     tmp_0 = ~ vlan_table; else 
#line 251 
                                                tmp_0 = vlan_table;
  
#line 251 
  mask = tmp_0 & mask;
  
#line 252 
  if (mask != 0U) {
    u32 * volatile *tmp_1;
    {
      
#line 253 
      u32 *__var = (u32 *)0U;
      
#line 253 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 253 
    u32 *hw_addr = *tmp_1;
    
#line 253 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 253 
                                            writel(vlan_table ^ mask,(void volatile *)(hw_addr + reg)); else ;
  }
  else ;
  
#line 243 
  len = (bit + len) + 4294967264U;
  
#line 243 
  reg += 1U;
  
#line 243 
  bit = 0U;
  ldv_44245: 
#line 244 
  ;
  
#line 241 
  if (len <= 4095U) 
#line 244 
                    goto ldv_44244; else 
#line 247 
                                         goto ldv_44246;
  ldv_44246: 
#line 248 
  ;
  
#line 256 
  __retres = 0;
  return_label: 
#line 256 
                return __retres;
}


#line 265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_read_mac_addr_pf(struct fm10k_hw *hw)
{
  s32 __retres;
  u8 perm_addr[6U];
  u32 serial_num;
  int i;
  
#line 271 
  serial_num = fm10k_read_reg(hw,41);
  
#line 274 
  if (~ serial_num << 24 != 0U) {
    
#line 275 
    __retres = -8;
    
#line 275 
    goto return_label;
  }
  else ;
  
#line 277 
  perm_addr[0] = (unsigned char)(serial_num >> 24);
  
#line 278 
  perm_addr[1] = (unsigned char)(serial_num >> 16);
  
#line 279 
  perm_addr[2] = (unsigned char)(serial_num >> 8);
  
#line 281 
  serial_num = fm10k_read_reg(hw,40);
  
#line 284 
  if (~ serial_num >> 24 != 0U) {
    
#line 285 
    __retres = -8;
    
#line 285 
    goto return_label;
  }
  else ;
  
#line 287 
  perm_addr[3] = (unsigned char)(serial_num >> 16);
  
#line 288 
  perm_addr[4] = (unsigned char)(serial_num >> 8);
  
#line 289 
  perm_addr[5] = (unsigned char)serial_num;
  
#line 291 
  i = 0;
  
#line 291 
  goto ldv_44254;
  ldv_44253: 
#line 292 
  ;
  
#line 292 
  hw->mac.perm_addr[i] = perm_addr[i];
  
#line 293 
  hw->mac.addr[i] = perm_addr[i];
  
#line 291 
  i += 1;
  ldv_44254: 
#line 292 
  ;
  
#line 291 
  if (i <= 5) 
#line 293 
              goto ldv_44253; else 
#line 296 
                                   goto ldv_44255;
  ldv_44255: 
#line 297 
  ;
  
#line 296 
  __retres = 0;
  return_label: 
#line 296 
                return __retres;
}


#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
bool fm10k_glort_valid_pf(struct fm10k_hw *hw, u16 glort)
{
  bool __retres;
  
#line 308 
  glort = (unsigned short)((int)((unsigned short)(hw->mac.dglort_map >> 16)) & (int)glort);
  
#line 310 
  __retres = (_Bool)((unsigned int)glort == (hw->mac.dglort_map & 65535U));
  
#line 310 
  return __retres;
}


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_update_xc_addr_pf(struct fm10k_hw *hw, u16 glort, u8 const *mac, u16 vid, bool add, u8 flags)
{
  s32 __retres;
  struct fm10k_mac_update mac_update;
  u32 msg[5U];
  int tmp_0;
  bool tmp;
  s32 tmp_1;
  
#line 328 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 333 
  vid = (unsigned short)((unsigned int)vid & 32767U);
  
#line 336 
  tmp = fm10k_glort_valid_pf(hw,(unsigned short)((int)glort));
  
#line 336 
  if (tmp) 
#line 336 
           tmp_0 = 0; else 
#line 336 
                           tmp_0 = 1;
  
#line 336 
  if (tmp_0) {
    
#line 337 
    __retres = -2;
    
#line 337 
    goto return_label;
  }
  else 
    
#line 336 
    if ((unsigned int)vid > 4095U) {
      
#line 337 
      __retres = -2;
      
#line 337 
      goto return_label;
    }
    else ;
  
#line 340 
  mac_update.mac_lower = ((((unsigned int)*(mac + 2U) << 24) | ((unsigned int)*(mac + 3U) << 16)) | ((unsigned int)*(mac + 4U) << 8)) | (unsigned int)*(mac + 5U);
  
#line 344 
  mac_update.mac_upper = (unsigned short)(((int)((unsigned short)*mac) << 8U) | (int)((unsigned short)*(mac + 1U)));
  
#line 346 
  mac_update.vlan = vid;
  
#line 347 
  mac_update.glort = glort;
  
#line 348 
  mac_update.action = (unsigned char)(! add);
  
#line 349 
  mac_update.flags = flags;
  
#line 352 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)2);
  
#line 353 
  fm10k_tlv_attr_put_le_struct((u32 *)(& msg),(unsigned short)3,(void const *)(& mac_update),12U);
  
#line 357 
  tmp_1 = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 357 
  __retres = tmp_1;
  return_label: 
#line 357 
                return __retres;
}


#line 372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_update_uc_addr_pf(struct fm10k_hw *hw, u16 glort, u8 const *mac, u16 vid, bool add, u8 flags)
{
  s32 __retres;
  int tmp_0;
  bool tmp;
  s32 tmp_1;
  
#line 376 
  tmp = is_valid_ether_addr(mac);
  
#line 376 
  if (tmp) 
#line 376 
           tmp_0 = 0; else 
#line 376 
                           tmp_0 = 1;
  
#line 376 
  if (tmp_0) {
    
#line 377 
    __retres = -2;
    
#line 377 
    goto return_label;
  }
  else ;
  
#line 379 
  tmp_1 = fm10k_update_xc_addr_pf(hw,(unsigned short)((int)glort),mac,(unsigned short)((int)vid),(_Bool)((bool)((int)add) != 0),(unsigned char)((int)flags));
  
#line 379 
  __retres = tmp_1;
  return_label: 
#line 379 
                return __retres;
}


#line 393  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_update_mc_addr_pf(struct fm10k_hw *hw, u16 glort, u8 const *mac, u16 vid, bool add)
{
  s32 __retres;
  int tmp_0;
  bool tmp;
  s32 tmp_1;
  
#line 397 
  tmp = is_multicast_ether_addr(mac);
  
#line 397 
  if (tmp) 
#line 397 
           tmp_0 = 0; else 
#line 397 
                           tmp_0 = 1;
  
#line 397 
  if (tmp_0) {
    
#line 398 
    __retres = -2;
    
#line 398 
    goto return_label;
  }
  else ;
  
#line 400 
  tmp_1 = fm10k_update_xc_addr_pf(hw,(unsigned short)((int)glort),mac,(unsigned short)((int)vid),(_Bool)((bool)((int)add) != 0),(unsigned char)0);
  
#line 400 
  __retres = tmp_1;
  return_label: 
#line 400 
                return __retres;
}


#line 413  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_update_xcast_mode_pf(struct fm10k_hw *hw, u16 glort, u8 mode)
{
  s32 __retres;
  u32 msg[3U];
  u32 xcast_mode;
  int tmp_0;
  bool tmp;
  s32 tmp_1;
  
#line 415 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 418 
  if ((unsigned int)mode > 3U) {
    
#line 419 
    __retres = -2;
    
#line 419 
    goto return_label;
  }
  else ;
  
#line 421 
  tmp = fm10k_glort_valid_pf(hw,(unsigned short)((int)glort));
  
#line 421 
  if (tmp) 
#line 421 
           tmp_0 = 0; else 
#line 421 
                           tmp_0 = 1;
  
#line 421 
  if (tmp_0) {
    
#line 422 
    __retres = -2;
    
#line 422 
    goto return_label;
  }
  else ;
  
#line 428 
  xcast_mode = ((unsigned int)mode << 16) | (unsigned int)glort;
  
#line 431 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)1);
  
#line 432 
  fm10k_tlv_attr_put_value((u32 *)(& msg),(unsigned short)2,(long long)xcast_mode,4U);
  
#line 435 
  tmp_1 = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 435 
  __retres = tmp_1;
  return_label: 
#line 435 
                return __retres;
}


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static void fm10k_update_int_moderator_pf(struct fm10k_hw *hw)
{
  u32 i;
  u32 tmp_0;
  {
    u32 * volatile *tmp;
    {
      
#line 451 
      u32 *__var = (u32 *)0U;
      
#line 451 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 451 
    u32 *hw_addr = *tmp;
    
#line 451 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 451 
                                            writel(0U,(void volatile *)(hw_addr + 73728U)); else ;
  }
  
#line 454 
  i = 255U;
  
#line 454 
  goto ldv_44303;
  ldv_44302: 
#line 455 
  ;
  
#line 455 
  tmp_0 = fm10k_read_reg(hw,(int)(i * 4U + 69635U));
  
#line 455 
  if (tmp_0 == 0U) 
#line 456 
                   goto ldv_44301; else ;
  
#line 454 
  i -= 1U;
  ldv_44303: 
#line 455 
  ;
  
#line 454 
  if (i != 0U) 
#line 456 
               goto ldv_44302; else 
#line 459 
                                    goto ldv_44301;
  ldv_44301: 
#line 460 
  ;
  {
    u32 * volatile *tmp_1;
    {
      
#line 460 
      u32 *__var_0 = (u32 *)0U;
      
#line 460 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 460 
    u32 *hw_addr_0 = *tmp_1;
    
#line 460 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 460 
                                              writel(i,(void volatile *)(hw_addr_0 + 76288U)); else ;
  }
  
#line 463 
  if ((unsigned int)hw->iov.num_vfs == 0U) {
    u32 * volatile *tmp_2;
    {
      
#line 464 
      u32 *__var_1 = (u32 *)0U;
      
#line 464 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 464 
    u32 *hw_addr_1 = *tmp_2;
    
#line 464 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 464 
                                              writel(i,(void volatile *)(hw_addr_1 + 75776U)); else ;
  }
  else ;
  {
    u32 * volatile *tmp_3;
    {
      
#line 467 
      u32 *__var_2 = (u32 *)0U;
      
#line 467 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 467 
    u32 *hw_addr_2 = *tmp_3;
    
#line 467 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 467 
                                              writel(1024U,(void volatile *)(hw_addr_2 + 73728U)); else ;
  }
  
#line 469 
  return;
}


#line 479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_update_lport_state_pf(struct fm10k_hw *hw, u16 glort, u16 count, bool enable)
{
  s32 __retres;
  u32 msg[3U];
  u32 lport_msg;
  int tmp_0;
  bool tmp;
  unsigned int tmp_1;
  s32 tmp_2;
  
#line 482 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 486 
  if ((unsigned int)count == 0U) {
    
#line 487 
    __retres = 0;
    
#line 487 
    goto return_label;
  }
  else ;
  
#line 490 
  tmp = fm10k_glort_valid_pf(hw,(unsigned short)((int)glort));
  
#line 490 
  if (tmp) 
#line 490 
           tmp_0 = 0; else 
#line 490 
                           tmp_0 = 1;
  
#line 490 
  if (tmp_0) {
    
#line 491 
    __retres = -2;
    
#line 491 
    goto return_label;
  }
  else ;
  
#line 494 
  lport_msg = ((unsigned int)count << 16) | (unsigned int)glort;
  
#line 497 
  if ((int)enable != 0) 
#line 497 
                        tmp_1 = 512U; else 
#line 497 
                                           tmp_1 = 513U;
  
#line 497 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)((int)tmp_1));
  
#line 499 
  fm10k_tlv_attr_put_value((u32 *)(& msg),(unsigned short)12,(long long)lport_msg,4U);
  
#line 502 
  tmp_2 = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 502 
  __retres = tmp_2;
  return_label: 
#line 502 
                return __retres;
}


#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_configure_dglort_map_pf(struct fm10k_hw *hw, struct fm10k_dglort_cfg *dglort)
{
  s32 __retres;
  u16 glort;
  u16 queue_count;
  u16 vsi_count;
  u16 pc_count;
  u16 vsi;
  u16 queue;
  u16 pc;
  u16 q_idx;
  u32 txqctl;
  u32 dglortdec;
  u32 dglortmap;
  
#line 522 
  if (dglort == (struct fm10k_dglort_cfg *)0) {
    
#line 523 
    __retres = -2;
    
#line 523 
    goto return_label;
  }
  else ;
  
#line 526 
  if (((((((unsigned int)dglort->idx > 7U || (unsigned int)dglort->rss_l > 7U) || (unsigned int)dglort->pc_l > 3U) || (unsigned int)dglort->vsi_l > 6U) || (unsigned int)dglort->vsi_b > 64U) || (unsigned int)dglort->queue_l > 8U) || (unsigned int)dglort->queue_b > 255U) {
    
#line 529 
    __retres = -2;
    
#line 529 
    goto return_label;
  }
  else ;
  
#line 532 
  queue_count = (unsigned short)(1 << ((int)dglort->rss_l + (int)dglort->pc_l));
  
#line 533 
  vsi_count = (unsigned short)(1 << ((int)dglort->vsi_l + (int)dglort->queue_l));
  
#line 534 
  glort = dglort->glort;
  
#line 535 
  q_idx = dglort->queue_b;
  
#line 538 
  vsi = (unsigned short)0U;
  
#line 538 
  goto ldv_44347;
  ldv_44346: 
#line 539 
  ;
  
#line 539 
  queue = (unsigned short)0U;
  
#line 539 
  goto ldv_44345;
  ldv_44344: 
#line 540 
  ;
  
#line 540 
  if ((unsigned int)q_idx > 255U) 
#line 541 
                                  goto ldv_44337; else ;
  {
    u32 * volatile *tmp;
    {
      
#line 543 
      u32 *__var = (u32 *)0U;
      
#line 543 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 543 
    u32 *hw_addr = *tmp;
    
#line 543 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 543 
                                            writel((unsigned int)glort,(void volatile *)(hw_addr + ((unsigned int)((int)q_idx * 64) + 32781U))); else ;
  }
  {
    u32 * volatile *tmp_0;
    {
      
#line 544 
      u32 *__var_0 = (u32 *)0U;
      
#line 544 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 544 
    u32 *hw_addr_0 = *tmp_0;
    
#line 544 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 544 
                                              writel((unsigned int)glort,(void volatile *)(hw_addr_0 + ((unsigned int)((int)q_idx * 64) + 16398U))); else ;
  }
  
#line 539 
  queue = (u16)((int)queue + 1);
  
#line 539 
  q_idx = (u16)((int)q_idx + 1);
  ldv_44345: 
#line 540 
  ;
  
#line 539 
  if ((int)queue < (int)queue_count) 
#line 541 
                                     goto ldv_44344; else 
#line 544 
                                                          goto ldv_44337;
  ldv_44337: 
#line 545 
  ;
  
#line 538 
  vsi = (u16)((int)vsi + 1);
  
#line 538 
  glort = (u16)((int)glort + 1);
  ldv_44347: 
#line 539 
  ;
  
#line 538 
  if ((int)vsi < (int)vsi_count) 
#line 540 
                                 goto ldv_44346; else 
#line 543 
                                                      goto ldv_44348;
  ldv_44348: 
#line 544 
  ;
  
#line 549 
  queue_count = (unsigned short)(1 << (((int)dglort->queue_l + (int)dglort->rss_l) + (int)dglort->vsi_l));
  
#line 550 
  pc_count = (unsigned short)(1 << (int)dglort->pc_l);
  
#line 553 
  pc = (unsigned short)0U;
  
#line 553 
  goto ldv_44356;
  ldv_44355: 
#line 554 
  ;
  
#line 554 
  q_idx = (unsigned short)((int)dglort->queue_b + (int)pc);
  
#line 555 
  queue = (unsigned short)0U;
  
#line 555 
  goto ldv_44354;
  ldv_44353: 
#line 556 
  ;
  
#line 556 
  if ((unsigned int)q_idx > 255U) 
#line 557 
                                  goto ldv_44349; else ;
  
#line 559 
  txqctl = fm10k_read_reg(hw,(int)q_idx * 64 + 32775);
  
#line 560 
  txqctl &= 4294966399U;
  
#line 561 
  txqctl = (unsigned int)((int)pc << 7) | txqctl;
  {
    u32 * volatile *tmp_1;
    {
      
#line 562 
      u32 *__var_1 = (u32 *)0U;
      
#line 562 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 562 
    u32 *hw_addr_1 = *tmp_1;
    
#line 562 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 562 
                                              writel(txqctl,(void volatile *)(hw_addr_1 + ((unsigned int)((int)q_idx * 64) + 32775U))); else ;
  }
  
#line 564 
  q_idx = (unsigned short)((int)q_idx + (int)pc_count);
  
#line 555 
  queue = (u16)((int)queue + 1);
  ldv_44354: 
#line 556 
  ;
  
#line 555 
  if ((int)queue < (int)queue_count) 
#line 557 
                                     goto ldv_44353; else 
#line 560 
                                                          goto ldv_44349;
  ldv_44349: 
#line 561 
  ;
  
#line 553 
  pc = (u16)((int)pc + 1);
  ldv_44356: 
#line 554 
  ;
  
#line 553 
  if ((int)pc < (int)pc_count) 
#line 555 
                               goto ldv_44355; else 
#line 558 
                                                    goto ldv_44357;
  ldv_44357: 
#line 559 
  ;
  
#line 569 
  dglortdec = ((((((unsigned int)dglort->rss_l << 24) | ((unsigned int)dglort->queue_b << 16)) | ((unsigned int)dglort->pc_l << 14)) | ((unsigned int)dglort->vsi_b << 7)) | ((unsigned int)dglort->vsi_l << 4)) | (unsigned int)dglort->queue_l;
  
#line 575 
  if ((unsigned int)dglort->inner_rss != 0U) 
#line 576 
                                             dglortdec |= 134217728U; else ;
  
#line 579 
  if ((unsigned int)dglort->idx == 0U) 
#line 579 
                                       dglortmap = 0U; else 
#line 579 
                                                            dglortmap = 4294901760U;
  
#line 581 
  dglortmap <<= ((int)dglort->vsi_l + (int)dglort->queue_l) + (int)dglort->shared_l;
  
#line 582 
  dglortmap = (unsigned int)dglort->glort | dglortmap;
  {
    u32 * volatile *tmp_2;
    {
      
#line 585 
      u32 *__var_2 = (u32 *)0U;
      
#line 585 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 585 
    u32 *hw_addr_2 = *tmp_2;
    
#line 585 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 585 
                                              writel(dglortdec,(void volatile *)(hw_addr_2 + ((unsigned int)dglort->idx + 56U))); else ;
  }
  {
    u32 * volatile *tmp_3;
    {
      
#line 586 
      u32 *__var_3 = (u32 *)0U;
      
#line 586 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 586 
    u32 *hw_addr_3 = *tmp_3;
    
#line 586 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 586 
                                              writel(dglortmap,(void volatile *)(hw_addr_3 + ((unsigned int)dglort->idx + 48U))); else ;
  }
  
#line 588 
  __retres = 0;
  return_label: 
#line 588 
                return __retres;
}


#line 591  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
u16 fm10k_queues_per_pool(struct fm10k_hw *hw)
{
  u16 __retres;
  unsigned int tmp_1;
  
#line 593 
  u16 num_pools = hw->iov.num_pools;
  
#line 595 
  if ((unsigned int)num_pools <= 32U) {
    unsigned int tmp_0;
    
#line 595 
    if ((unsigned int)num_pools <= 16U) {
      unsigned int tmp;
      
#line 595 
      if ((unsigned int)num_pools > 8U) 
#line 595 
                                        tmp = 8U; else 
#line 595 
                                                       tmp = 16U;
      
#line 595 
      tmp_0 = tmp;
    }
    else 
#line 595 
         tmp_0 = 4U;
    
#line 595 
    tmp_1 = tmp_0;
  }
  else 
#line 595 
       tmp_1 = 2U;
  
#line 595 
  __retres = (unsigned short)tmp_1;
  
#line 595 
  return __retres;
}


#line 599  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
u16 fm10k_vf_queue_index(struct fm10k_hw *hw, u16 vf_idx)
{
  u16 tmp;
  
#line 601 
  u16 num_vfs = hw->iov.num_vfs;
  
#line 602 
  u16 vf_q_idx = (unsigned short)256U;
  
#line 604 
  tmp = fm10k_queues_per_pool(hw);
  
#line 604 
  vf_q_idx = (unsigned short)((int)vf_q_idx - (int)((unsigned short)((int)tmp * ((int)num_vfs - (int)vf_idx))));
  
#line 606 
  return vf_q_idx;
}


#line 609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static u16 fm10k_vectors_per_pool(struct fm10k_hw *hw)
{
  u16 __retres;
  unsigned int tmp_0;
  
#line 611 
  u16 num_pools = hw->iov.num_pools;
  
#line 613 
  if ((unsigned int)num_pools <= 32U) {
    unsigned int tmp;
    
#line 613 
    if ((unsigned int)num_pools > 16U) 
#line 613 
                                       tmp = 16U; else 
#line 613 
                                                       tmp = 32U;
    
#line 613 
    tmp_0 = tmp;
  }
  else 
#line 613 
       tmp_0 = 8U;
  
#line 613 
  __retres = (unsigned short)tmp_0;
  
#line 613 
  return __retres;
}


#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static u16 fm10k_vf_vector_index(struct fm10k_hw *hw, u16 vf_idx)
{
  u16 tmp;
  
#line 619 
  u16 vf_v_idx = (unsigned short)256U;
  
#line 621 
  tmp = fm10k_vectors_per_pool(hw);
  
#line 621 
  vf_v_idx = (unsigned short)((int)((unsigned short)((int)tmp * (int)vf_idx)) + (int)vf_v_idx);
  
#line 623 
  return vf_v_idx;
}


#line 635  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_iov_assign_resources_pf(struct fm10k_hw *hw, u16 num_vfs, u16 num_pools)
{
  s32 __retres;
  u16 qmap_stride;
  u16 qpp;
  u16 vpp;
  u16 vf_q_idx;
  u16 vf_q_idx0;
  u16 qmap_idx;
  int i;
  int j;
  int tmp_3;
  
#line 639 
  u32 vid = (unsigned int)((int)hw->mac.default_vid << 16);
  
#line 643 
  if ((unsigned int)num_pools > 64U) {
    
#line 644 
    __retres = -2;
    
#line 644 
    goto return_label;
  }
  else ;
  
#line 647 
  if ((int)num_vfs > (int)num_pools || (int)hw->iov.total_vfs < (int)num_vfs) {
    
#line 648 
    __retres = -2;
    
#line 648 
    goto return_label;
  }
  else ;
  
#line 651 
  hw->iov.num_vfs = num_vfs;
  
#line 652 
  hw->iov.num_pools = num_pools;
  
#line 655 
  if ((unsigned int)num_vfs > 8U) 
#line 655 
                                  qmap_stride = (unsigned short)32U; else 
                                                                    
#line 655 
                                                                    qmap_stride = (unsigned short)256U;
  
#line 656 
  qpp = fm10k_queues_per_pool(hw);
  
#line 657 
  vpp = fm10k_vectors_per_pool(hw);
  
#line 660 
  vf_q_idx = fm10k_vf_queue_index(hw,(unsigned short)0);
  
#line 661 
  qmap_idx = (unsigned short)0U;
  
#line 664 
  i = 0;
  
#line 664 
  goto ldv_44407;
  ldv_44406: 
#line 665 
  ;
  {
    u32 * volatile *tmp;
    {
      
#line 665 
      u32 *__var = (u32 *)0U;
      
#line 665 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 665 
    u32 *hw_addr = *tmp;
    
#line 665 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 665 
                                            writel(0U,(void volatile *)(hw_addr + ((unsigned int)i + 8256U))); else ;
  }
  {
    u32 * volatile *tmp_0;
    {
      
#line 666 
      u32 *__var_0 = (u32 *)0U;
      
#line 666 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 666 
    u32 *hw_addr_0 = *tmp_0;
    
#line 666 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 666 
                                              writel(0U,(void volatile *)(hw_addr_0 + ((unsigned int)i + 8320U))); else ;
  }
  {
    u32 * volatile *tmp_1;
    {
      
#line 667 
      u32 *__var_1 = (u32 *)0U;
      
#line 667 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 667 
    u32 *hw_addr_1 = *tmp_1;
    
#line 667 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 667 
                                              writel(2097151U,(void volatile *)(hw_addr_1 + ((unsigned int)i + 8192U))); else ;
  }
  
#line 664 
  i += 1;
  ldv_44407: 
#line 665 
  ;
  
#line 664 
  if ((int)num_vfs > i) 
#line 666 
                        goto ldv_44406; else 
#line 669 
                                             goto ldv_44408;
  ldv_44408: 
#line 670 
  ;
  
#line 672 
  i = (int)num_vfs * 16;
  
#line 672 
  goto ldv_44413;
  ldv_44412: 
#line 673 
  ;
  {
    u32 * volatile *tmp_2;
    {
      
#line 673 
      u32 *__var_2 = (u32 *)0U;
      
#line 673 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 673 
    u32 *hw_addr_2 = *tmp_2;
    
#line 673 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 673 
                                              writel(0U,(void volatile *)(hw_addr_2 + ((unsigned int)i + 98304U))); else ;
  }
  ldv_44413: 
#line 675 
  ;
  
#line 672 
  tmp_3 = i;
  
#line 672 
  i -= 1;
  
#line 672 
  ;
  
#line 672 
  if (tmp_3 != 0) 
#line 674 
                  goto ldv_44412; else 
#line 677 
                                       goto ldv_44414;
  ldv_44414: 
#line 678 
  ;
  {
    u32 * volatile *tmp_4;
    {
      
#line 676 
      u32 *__var_3 = (u32 *)0U;
      
#line 676 
      tmp_4 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 676 
    u32 *hw_addr_3 = *tmp_4;
    
#line 676 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 676 
                                              writel(4294967295U,(void volatile *)(hw_addr_3 + 100422U)); else ;
  }
  {
    u32 * volatile *tmp_5;
    {
      
#line 677 
      u32 *__var_4 = (u32 *)0U;
      
#line 677 
      tmp_5 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 677 
    u32 *hw_addr_4 = *tmp_5;
    
#line 677 
    if ((long)(hw_addr_4 == (u32 *)0U) == 0L) 
#line 677 
                                              writel(4294967295U,(void volatile *)(hw_addr_4 + 100423U)); else ;
  }
  
#line 680 
  i = 128;
  
#line 680 
  goto ldv_44431;
  ldv_44430: 
#line 681 
  ;
  {
    u32 * volatile *tmp_6;
    {
      
#line 681 
      u32 *__var_5 = (u32 *)0U;
      
#line 681 
      tmp_6 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 681 
    u32 *hw_addr_5 = *tmp_6;
    
#line 681 
    if ((long)(hw_addr_5 == (u32 *)0U) == 0L) 
#line 681 
                                              writel(0U,(void volatile *)(hw_addr_5 + ((unsigned int)(i * 64) + 32774U))); else ;
  }
  {
    u32 * volatile *tmp_7;
    {
      
#line 682 
      u32 *__var_6 = (u32 *)0U;
      
#line 682 
      tmp_7 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 682 
    u32 *hw_addr_6 = *tmp_7;
    
#line 682 
    if ((long)(hw_addr_6 == (u32 *)0U) == 0L) 
#line 682 
                                              writel(vid | 268435519U,(void volatile *)(hw_addr_6 + ((unsigned int)(i * 64) + 32775U))); else ;
  }
  {
    u32 * volatile *tmp_8;
    {
      
#line 684 
      u32 *__var_7 = (u32 *)0U;
      
#line 684 
      tmp_8 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 684 
    u32 *hw_addr_7 = *tmp_8;
    
#line 684 
    if ((long)(hw_addr_7 == (u32 *)0U) == 0L) 
#line 684 
                                              writel(252U,(void volatile *)(hw_addr_7 + ((unsigned int)(i * 64) + 16390U))); else ;
  }
  
#line 680 
  i += 1;
  ldv_44431: 
#line 681 
  ;
  
#line 680 
  if ((int)vf_q_idx > i) 
#line 682 
                         goto ldv_44430; else 
#line 685 
                                              goto ldv_44432;
  ldv_44432: 
#line 686 
  ;
  
#line 690 
  i = 257;
  
#line 690 
  goto ldv_44440;
  ldv_44439: 
#line 691 
  ;
  
#line 691 
  if ((((int)vpp + -1) & i) == 0) {
    u32 * volatile *tmp_9;
    {
      
#line 692 
      u32 *__var_8 = (u32 *)0U;
      
#line 692 
      tmp_9 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 692 
    u32 *hw_addr_8 = *tmp_9;
    
#line 692 
    if ((long)(hw_addr_8 == (u32 *)0U) == 0L) 
#line 692 
                                              writel((unsigned int)(i - (int)vpp),(void volatile *)(hw_addr_8 + ((unsigned int)(i * 2) + 75776U))); else ;
  }
  else {
    u32 * volatile *tmp_10;
    {
      
#line 694 
      u32 *__var_9 = (u32 *)0U;
      
#line 694 
      tmp_10 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 694 
    u32 *hw_addr_9 = *tmp_10;
    
#line 694 
    if ((long)(hw_addr_9 == (u32 *)0U) == 0L) 
#line 694 
                                              writel((unsigned int)(i + -1),(void volatile *)(hw_addr_9 + ((unsigned int)(i * 2) + 75776U))); else ;
  }
  
#line 690 
  i += 1;
  ldv_44440: 
#line 691 
  ;
  
#line 690 
  if (i <= 767) 
#line 692 
                goto ldv_44439; else 
#line 695 
                                     goto ldv_44441;
  ldv_44441: 
#line 696 
  ;
  {
    u32 * volatile *tmp_11;
    {
      
#line 698 
      u32 *__var_10 = (u32 *)0U;
      
#line 698 
      tmp_11 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 698 
    u32 *hw_addr_10 = *tmp_11;
    
#line 698 
    if ((long)(hw_addr_10 == (u32 *)0U) == 0L) {
      u16 tmp_12;
      
#line 698 
      ;
      
#line 698 
      tmp_12 = fm10k_vf_vector_index(hw,(unsigned short)((int)((unsigned int)num_vfs + 65535U)));
      
#line 698 
      writel((unsigned int)tmp_12,(void volatile *)(hw_addr_10 + 75776U));
    }
    else ;
  }
  
#line 702 
  i = 0;
  
#line 702 
  goto ldv_44476;
  ldv_44475: 
#line 703 
  ;
  
#line 704 
  vf_q_idx0 = vf_q_idx;
  
#line 706 
  j = 0;
  
#line 706 
  goto ldv_44464;
  ldv_44463: 
#line 707 
  ;
  {
    u32 * volatile *tmp_13;
    {
      
#line 708 
      u32 *__var_11 = (u32 *)0U;
      
#line 708 
      tmp_13 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 708 
    u32 *hw_addr_11 = *tmp_13;
    
#line 708 
    if ((long)(hw_addr_11 == (u32 *)0U) == 0L) 
#line 708 
                                               writel(0U,(void volatile *)(hw_addr_11 + ((unsigned int)((int)vf_q_idx * 64) + 32774U))); else ;
  }
  {
    u32 * volatile *tmp_14;
    {
      
#line 709 
      u32 *__var_12 = (u32 *)0U;
      
#line 709 
      tmp_14 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 709 
    u32 *hw_addr_12 = *tmp_14;
    
#line 709 
    if ((long)(hw_addr_12 == (u32 *)0U) == 0L) 
#line 709 
                                               writel(((unsigned int)((i << 10) | i) | vid) | 64U,(void volatile *)(hw_addr_12 + ((unsigned int)((int)vf_q_idx * 64) + 32775U))); else ;
  }
  {
    u32 * volatile *tmp_15;
    {
      
#line 712 
      u32 *__var_13 = (u32 *)0U;
      
#line 712 
      tmp_15 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 712 
    u32 *hw_addr_13 = *tmp_15;
    
#line 712 
    if ((long)(hw_addr_13 == (u32 *)0U) == 0L) 
#line 712 
                                               writel(513U,(void volatile *)(hw_addr_13 + ((unsigned int)((int)vf_q_idx * 64) + 16391U))); else ;
  }
  {
    u32 * volatile *tmp_16;
    {
      
#line 715 
      u32 *__var_14 = (u32 *)0U;
      
#line 715 
      tmp_16 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 715 
    u32 *hw_addr_14 = *tmp_16;
    
#line 715 
    if ((long)(hw_addr_14 == (u32 *)0U) == 0L) 
#line 715 
                                               writel((unsigned int)((i << 2) | 256),(void volatile *)(hw_addr_14 + ((unsigned int)((int)vf_q_idx * 64) + 16390U))); else ;
  }
  {
    u32 * volatile *tmp_17;
    {
      
#line 720 
      u32 *__var_15 = (u32 *)0U;
      
#line 720 
      tmp_17 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 720 
    u32 *hw_addr_15 = *tmp_17;
    
#line 720 
    if ((long)(hw_addr_15 == (u32 *)0U) == 0L) 
#line 720 
                                               writel((unsigned int)vf_q_idx,(void volatile *)(hw_addr_15 + ((unsigned int)qmap_idx + 10240U))); else ;
  }
  {
    u32 * volatile *tmp_18;
    {
      
#line 721 
      u32 *__var_16 = (u32 *)0U;
      
#line 721 
      tmp_18 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 721 
    u32 *hw_addr_16 = *tmp_18;
    
#line 721 
    if ((long)(hw_addr_16 == (u32 *)0U) == 0L) 
#line 721 
                                               writel((unsigned int)vf_q_idx,(void volatile *)(hw_addr_16 + ((unsigned int)qmap_idx + 12288U))); else ;
  }
  
#line 706 
  j += 1;
  
#line 706 
  qmap_idx = (u16)((int)qmap_idx + 1);
  
#line 706 
  vf_q_idx = (u16)((int)vf_q_idx + 1);
  ldv_44464: 
#line 707 
  ;
  
#line 706 
  if ((int)qpp > j) 
#line 708 
                    goto ldv_44463; else 
#line 711 
                                         goto ldv_44465;
  ldv_44465: 
#line 712 
  ;
  
#line 725 
  goto ldv_44473;
  ldv_44472: 
#line 726 
  ;
  {
    u32 * volatile *tmp_19;
    {
      
#line 726 
      u32 *__var_17 = (u32 *)0U;
      
#line 726 
      tmp_19 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 726 
    u32 *hw_addr_17 = *tmp_19;
    
#line 726 
    if ((long)(hw_addr_17 == (u32 *)0U) == 0L) 
#line 726 
                                               writel((unsigned int)vf_q_idx0,(void volatile *)(hw_addr_17 + ((unsigned int)qmap_idx + 10240U))); else ;
  }
  {
    u32 * volatile *tmp_20;
    {
      
#line 727 
      u32 *__var_18 = (u32 *)0U;
      
#line 727 
      tmp_20 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 727 
    u32 *hw_addr_18 = *tmp_20;
    
#line 727 
    if ((long)(hw_addr_18 == (u32 *)0U) == 0L) 
#line 727 
                                               writel((unsigned int)vf_q_idx0,(void volatile *)(hw_addr_18 + ((unsigned int)qmap_idx + 12288U))); else ;
  }
  
#line 725 
  j += 1;
  
#line 725 
  qmap_idx = (u16)((int)qmap_idx + 1);
  ldv_44473: 
#line 726 
  ;
  
#line 725 
  if ((int)qmap_stride > j) 
#line 727 
                            goto ldv_44472; else 
#line 730 
                                                 goto ldv_44474;
  ldv_44474: 
#line 731 
  ;
  
#line 702 
  i += 1;
  ldv_44476: 
#line 703 
  ;
  
#line 702 
  if ((int)num_vfs > i) 
#line 704 
                        goto ldv_44475; else 
#line 707 
                                             goto ldv_44477;
  ldv_44477: 
#line 708 
  ;
  
#line 732 
  goto ldv_44485;
  ldv_44484: 
#line 733 
  ;
  {
    u32 * volatile *tmp_21;
    {
      
#line 733 
      u32 *__var_19 = (u32 *)0U;
      
#line 733 
      tmp_21 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 733 
    u32 *hw_addr_19 = *tmp_21;
    
#line 733 
    if ((long)(hw_addr_19 == (u32 *)0U) == 0L) 
#line 733 
                                               writel(0U,(void volatile *)(hw_addr_19 + ((unsigned int)qmap_idx + 10240U))); else ;
  }
  {
    u32 * volatile *tmp_22;
    {
      
#line 734 
      u32 *__var_20 = (u32 *)0U;
      
#line 734 
      tmp_22 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 734 
    u32 *hw_addr_20 = *tmp_22;
    
#line 734 
    if ((long)(hw_addr_20 == (u32 *)0U) == 0L) 
#line 734 
                                               writel(0U,(void volatile *)(hw_addr_20 + ((unsigned int)qmap_idx + 12288U))); else ;
  }
  
#line 735 
  qmap_idx = (u16)((int)qmap_idx + 1);
  ldv_44485: 
#line 736 
  ;
  
#line 732 
  if ((unsigned int)qmap_idx <= 2047U) 
#line 734 
                                       goto ldv_44484; else 
#line 737 
                                                            goto ldv_44486;
  ldv_44486: 
#line 738 
  ;
  
#line 738 
  __retres = 0;
  return_label: 
#line 738 
                return __retres;
}


#line 750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_iov_configure_tc_pf(struct fm10k_hw *hw, u16 vf_idx, int rate)
{
  s32 __retres;
  
#line 753 
  u32 interval = 524288U;
  
#line 754 
  u32 tc_rate = 65535U;
  
#line 757 
  if ((int)hw->iov.num_vfs <= (int)vf_idx) {
    
#line 758 
    __retres = -2;
    
#line 758 
    goto return_label;
  }
  else ;
  
#line 761 
  switch ((unsigned int)hw->bus.speed) {
    case (unsigned int)2500: 
#line 762 
    ;
    
#line 763 
    interval = 131072U;
    
#line 764 
    goto ldv_44495;
    case (unsigned int)5000: 
#line 765 
    ;
    
#line 766 
    interval = 262144U;
    
#line 767 
    goto ldv_44495;
    default: 
#line 768 
    ;
    
#line 769 
    goto ldv_44495;
  }
  ldv_44495: 
#line 772 
  ;
  
#line 772 
  if (rate != 0) {
    
#line 773 
    if ((unsigned int)rate + 4294967295U > 99999U) {
      
#line 774 
      __retres = -2;
      
#line 774 
      goto return_label;
    }
    else ;
    
#line 783 
    tc_rate = (unsigned int)((rate * 128) / 125);
    
#line 788 
    if (rate <= 3999) 
#line 789 
                      interval <<= 1; else 
#line 791 
                                           tc_rate >>= 1;
  }
  else ;
  {
    u32 * volatile *tmp;
    {
      
#line 795 
      u32 *__var = (u32 *)0U;
      
#line 795 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 795 
    u32 *hw_addr = *tmp;
    
#line 795 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 795 
                                            writel(tc_rate | interval,(void volatile *)(hw_addr + ((unsigned int)vf_idx + 8320U))); else ;
  }
  {
    u32 * volatile *tmp_0;
    {
      
#line 796 
      u32 *__var_0 = (u32 *)0U;
      
#line 796 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 796 
    u32 *hw_addr_0 = *tmp_0;
    
#line 796 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 796 
                                              writel(65536U,(void volatile *)(hw_addr_0 + ((unsigned int)vf_idx + 8256U))); else ;
  }
  {
    u32 * volatile *tmp_1;
    {
      
#line 797 
      u32 *__var_1 = (u32 *)0U;
      
#line 797 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 797 
    u32 *hw_addr_1 = *tmp_1;
    
#line 797 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 797 
                                              writel(65536U,(void volatile *)(hw_addr_1 + ((unsigned int)vf_idx + 8192U))); else ;
  }
  
#line 799 
  __retres = 0;
  return_label: 
#line 799 
                return __retres;
}


#line 810  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_iov_assign_int_moderator_pf(struct fm10k_hw *hw, u16 vf_idx)
{
  s32 __retres;
  u16 vf_v_idx;
  u16 vf_v_limit;
  u16 i;
  u16 tmp;
  u32 tmp_0;
  
#line 815 
  if ((int)hw->iov.num_vfs <= (int)vf_idx) {
    
#line 816 
    __retres = -2;
    
#line 816 
    goto return_label;
  }
  else ;
  
#line 819 
  vf_v_idx = fm10k_vf_vector_index(hw,(unsigned short)((int)vf_idx));
  
#line 820 
  tmp = fm10k_vectors_per_pool(hw);
  
#line 820 
  vf_v_limit = (unsigned short)((int)tmp + (int)vf_v_idx);
  
#line 823 
  i = (unsigned short)((unsigned int)vf_v_limit + 65535U);
  
#line 823 
  goto ldv_44516;
  ldv_44515: 
#line 824 
  ;
  
#line 824 
  tmp_0 = fm10k_read_reg(hw,(int)i * 4 + 69635);
  
#line 824 
  if (tmp_0 == 0U) 
#line 825 
                   goto ldv_44514; else ;
  
#line 823 
  i = (u16)((int)i - 1);
  ldv_44516: 
#line 824 
  ;
  
#line 823 
  if ((int)i > (int)vf_v_idx) 
#line 825 
                              goto ldv_44515; else 
#line 828 
                                                   goto ldv_44514;
  ldv_44514: 
#line 829 
  ;
  
#line 829 
  if ((int)vf_idx == (int)hw->iov.num_vfs + -1) {
    u32 * volatile *tmp_1;
    {
      
#line 830 
      u32 *__var = (u32 *)0U;
      
#line 830 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 830 
    u32 *hw_addr = *tmp_1;
    
#line 830 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 830 
                                            writel((unsigned int)i,(void volatile *)(hw_addr + 75776U)); else ;
  }
  else {
    u32 * volatile *tmp_2;
    {
      
#line 832 
      u32 *__var_0 = (u32 *)0U;
      
#line 832 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 832 
    u32 *hw_addr_0 = *tmp_2;
    
#line 832 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 832 
                                              writel((unsigned int)i,(void volatile *)(hw_addr_0 + ((unsigned int)((int)vf_v_limit * 2) + 75776U))); else ;
  }
  
#line 834 
  __retres = 0;
  return_label: 
#line 834 
                return __retres;
}


#line 844  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_iov_assign_default_mac_vlan_pf(struct fm10k_hw *hw, struct fm10k_vf_info *vf_info)
{
  s32 __retres;
  u16 qmap_stride;
  u16 queues_per_pool;
  u16 vf_q_idx;
  u16 timeout;
  u16 qmap_idx;
  u16 i;
  u32 msg[4U];
  u32 txdctl;
  u32 txqctl;
  u16 vf_idx;
  u16 vf_vid;
  bool tmp_1;
  
#line 848 
  u32 tdbal = 0U;
  
#line 848 
  u32 tdbah = 0U;
  
#line 849 
  s32 err = 0;
  
#line 853 
  if (vf_info == (struct fm10k_vf_info *)0 || (int)((unsigned short)vf_info->vf_idx) >= (int)hw->iov.num_vfs) {
    
#line 854 
    __retres = -2;
    
#line 854 
    goto return_label;
  }
  else ;
  
#line 857 
  if ((unsigned int)hw->iov.num_vfs > 8U) 
#line 857 
                                          qmap_stride = (unsigned short)32U; else 
                                                                    
#line 857 
                                                                    qmap_stride = (unsigned short)256U;
  
#line 858 
  queues_per_pool = fm10k_queues_per_pool(hw);
  
#line 861 
  vf_idx = (unsigned short)vf_info->vf_idx;
  
#line 862 
  vf_q_idx = fm10k_vf_queue_index(hw,(unsigned short)((int)vf_idx));
  
#line 863 
  qmap_idx = (unsigned short)((int)qmap_stride * (int)vf_idx);
  {
    u32 * volatile *tmp;
    {
      
#line 866 
      u32 *__var = (u32 *)0U;
      
#line 866 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 866 
    u32 *hw_addr = *tmp;
    
#line 866 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 866 
                                            writel(0U,(void volatile *)(hw_addr + ((unsigned int)qmap_idx + 10240U))); else ;
  }
  {
    u32 * volatile *tmp_0;
    {
      
#line 867 
      u32 *__var_0 = (u32 *)0U;
      
#line 867 
      tmp_0 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 867 
    u32 *hw_addr_0 = *tmp_0;
    
#line 867 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 867 
                                              writel(0U,(void volatile *)(hw_addr_0 + ((unsigned int)((int)vf_q_idx * 64) + 32774U))); else ;
  }
  
#line 870 
  if ((unsigned int)vf_info->pf_vid != 0U) 
#line 871 
                                           vf_vid = (unsigned short)((unsigned int)vf_info->pf_vid | 32768U); else 
                                                                    
#line 873 
                                                                    vf_vid = vf_info->sw_vid;
  
#line 876 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)2);
  
#line 877 
  fm10k_tlv_attr_put_mac_vlan((u32 *)(& msg),(unsigned short)3,(u8 const *)(& vf_info->mac),(unsigned short)((int)vf_vid));
  
#line 881 
  if (vf_info->mbx.ops.enqueue_tx != (s32 (*)(struct fm10k_hw *, struct fm10k_mbx_info *, u32 const *))0) 
    
#line 882 
    (*(vf_info->mbx.ops.enqueue_tx))(hw,& vf_info->mbx,(u32 const *)(& msg)); else ;
  
#line 885 
  txdctl = fm10k_read_reg(hw,(int)vf_q_idx * 64 + 32774);
  
#line 886 
  timeout = (unsigned short)0U;
  
#line 886 
  goto ldv_44549;
  ldv_44548: 
#line 887 
  ;
  
#line 888 
  if ((unsigned int)timeout == 10U) {
    
#line 889 
    err = -6;
    
#line 890 
    goto err_out;
  }
  else ;
  
#line 893 
  usleep_range(100UL,200UL);
  
#line 894 
  txdctl = fm10k_read_reg(hw,(int)vf_q_idx * 64 + 32774);
  
#line 886 
  timeout = (u16)((int)timeout + 1);
  ldv_44549: 
#line 887 
  ;
  
#line 886 
  if ((txdctl & 16384U) != 0U) 
#line 888 
                               goto ldv_44548; else 
#line 891 
                                                    goto ldv_44550;
  ldv_44550: 
#line 892 
  ;
  
#line 898 
  tmp_1 = is_valid_ether_addr((u8 const *)(& vf_info->mac));
  
#line 898 
  if ((int)tmp_1 != 0) {
    
#line 899 
    tdbal = (((unsigned int)vf_info->mac[3] << 24) | ((unsigned int)vf_info->mac[4] << 16)) | ((unsigned int)vf_info->mac[5] << 8);
    
#line 903 
    tdbah = ((((unsigned int)vf_info->mac[0] << 16) | ((unsigned int)vf_info->mac[1] << 8)) | (unsigned int)vf_info->mac[2]) | 4278190080U;
  }
  else ;
  {
    u32 * volatile *tmp_2;
    {
      
#line 910 
      u32 *__var_1 = (u32 *)0U;
      
#line 910 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 910 
    u32 *hw_addr_1 = *tmp_2;
    
#line 910 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 910 
                                              writel(tdbal,(void volatile *)(hw_addr_1 + ((unsigned int)((int)vf_q_idx * 64) + 32768U))); else ;
  }
  {
    u32 * volatile *tmp_3;
    {
      
#line 911 
      u32 *__var_2 = (u32 *)0U;
      
#line 911 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 911 
    u32 *hw_addr_2 = *tmp_3;
    
#line 911 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 911 
                                              writel(tdbah,(void volatile *)(hw_addr_2 + ((unsigned int)((int)vf_q_idx * 64) + 32769U))); else ;
  }
  err_out: 
#line 913 
  ;
  
#line 915 
  txqctl = ((unsigned int)vf_vid << 16) & 268369920U;
  
#line 917 
  txqctl = (unsigned int)((((int)vf_idx << 10) | 64) | (int)vf_idx) | txqctl;
  
#line 921 
  i = (unsigned short)0U;
  
#line 921 
  goto ldv_44561;
  ldv_44560: 
#line 922 
  ;
  {
    u32 * volatile *tmp_4;
    {
      
#line 922 
      u32 *__var_3 = (u32 *)0U;
      
#line 922 
      tmp_4 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 922 
    u32 *hw_addr_3 = *tmp_4;
    
#line 922 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 922 
                                              writel(txqctl,(void volatile *)(hw_addr_3 + ((unsigned int)(((int)vf_q_idx + (int)i) * 64) + 32775U))); else ;
  }
  
#line 921 
  i = (u16)((int)i + 1);
  ldv_44561: 
#line 922 
  ;
  
#line 921 
  if ((int)i < (int)queues_per_pool) 
#line 923 
                                     goto ldv_44560; else 
#line 926 
                                                          goto ldv_44562;
  ldv_44562: 
#line 927 
  ;
  {
    u32 * volatile *tmp_5;
    {
      
#line 925 
      u32 *__var_4 = (u32 *)0U;
      
#line 925 
      tmp_5 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 925 
    u32 *hw_addr_4 = *tmp_5;
    
#line 925 
    if ((long)(hw_addr_4 == (u32 *)0U) == 0L) 
#line 925 
                                              writel((unsigned int)vf_q_idx,(void volatile *)(hw_addr_4 + ((unsigned int)qmap_idx + 10240U))); else ;
  }
  
#line 926 
  __retres = err;
  return_label: 
#line 926 
                return __retres;
}


#line 936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_iov_reset_resources_pf(struct fm10k_hw *hw, struct fm10k_vf_info *vf_info)
{
  s32 __retres;
  u16 qmap_stride;
  u16 queues_per_pool;
  u16 vf_q_idx;
  u16 qmap_idx;
  u32 txqctl;
  u32 rxqctl;
  u16 vf_v_idx;
  u16 vf_v_limit;
  u16 vf_vid;
  int i;
  u16 tmp_0;
  int tmp_14;
  int tmp_16;
  int tmp_18;
  int tmp_20;
  bool tmp_22;
  int tmp_27;
  
#line 940 
  u32 tdbal = 0U;
  
#line 940 
  u32 tdbah = 0U;
  
#line 942 
  u8 vf_idx = vf_info->vf_idx;
  
#line 946 
  if ((int)((unsigned short)vf_idx) >= (int)hw->iov.num_vfs) {
    
#line 947 
    __retres = -2;
    
#line 947 
    goto return_label;
  }
  else ;
  {
    u32 * volatile *tmp;
    {
      
#line 950 
      u32 *__var = (u32 *)0U;
      
#line 950 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 950 
    u32 *hw_addr = *tmp;
    
#line 950 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 950 
                                            writel((unsigned int)(1 << ((int)vf_idx & 31)),(void volatile *)(hw_addr + ((unsigned int)vf_idx / 32U + 100422U))); else ;
  }
  
#line 953 
  vf_info->mbx.timeout = 0U;
  
#line 954 
  if (vf_info->mbx.ops.disconnect != (void (*)(struct fm10k_hw *, struct fm10k_mbx_info *))0) 
    
#line 955 
    (*(vf_info->mbx.ops.disconnect))(hw,& vf_info->mbx); else ;
  
#line 958 
  vf_v_idx = fm10k_vf_vector_index(hw,(unsigned short)((int)vf_idx));
  
#line 959 
  tmp_0 = fm10k_vectors_per_pool(hw);
  
#line 959 
  vf_v_limit = (unsigned short)((int)tmp_0 + (int)vf_v_idx);
  
#line 962 
  if ((unsigned int)hw->iov.num_vfs > 8U) 
#line 962 
                                          qmap_stride = (unsigned short)32U; else 
                                                                    
#line 962 
                                                                    qmap_stride = (unsigned short)256U;
  
#line 963 
  queues_per_pool = fm10k_queues_per_pool(hw);
  
#line 964 
  qmap_idx = (unsigned short)((int)((unsigned short)vf_idx) * (int)qmap_stride);
  
#line 967 
  i = (int)qmap_idx;
  
#line 967 
  goto ldv_44593;
  ldv_44592: 
#line 968 
  ;
  {
    u32 * volatile *tmp_1;
    {
      
#line 968 
      u32 *__var_0 = (u32 *)0U;
      
#line 968 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 968 
    u32 *hw_addr_0 = *tmp_1;
    
#line 968 
    if ((long)(hw_addr_0 == (u32 *)0U) == 0L) 
#line 968 
                                              writel(0U,(void volatile *)(hw_addr_0 + ((unsigned int)i + 10240U))); else ;
  }
  {
    u32 * volatile *tmp_2;
    {
      
#line 969 
      u32 *__var_1 = (u32 *)0U;
      
#line 969 
      tmp_2 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 969 
    u32 *hw_addr_1 = *tmp_2;
    
#line 969 
    if ((long)(hw_addr_1 == (u32 *)0U) == 0L) 
#line 969 
                                              writel(0U,(void volatile *)(hw_addr_1 + ((unsigned int)i + 12288U))); else ;
  }
  
#line 967 
  i += 1;
  ldv_44593: 
#line 968 
  ;
  
#line 967 
  if ((int)qmap_idx + (int)qmap_stride > i) 
#line 969 
                                            goto ldv_44592; else 
#line 972 
                                                                 goto ldv_44594;
  ldv_44594: 
#line 973 
  ;
  
#line 973 
  vf_q_idx = fm10k_vf_queue_index(hw,(unsigned short)((int)vf_idx));
  
#line 976 
  if ((unsigned int)vf_info->pf_vid != 0U) 
#line 977 
                                           vf_vid = vf_info->pf_vid; else 
                                                                    
#line 979 
                                                                    vf_vid = vf_info->sw_vid;
  
#line 982 
  txqctl = ((((unsigned int)vf_vid << 16) | (unsigned int)((int)vf_idx << 10)) | (unsigned int)vf_idx) | 64U;
  
#line 985 
  rxqctl = (unsigned int)(((int)vf_idx << 2) | 256);
  
#line 988 
  i = (int)vf_q_idx;
  
#line 988 
  goto ldv_44608;
  ldv_44607: 
#line 989 
  ;
  {
    u32 * volatile *tmp_3;
    {
      
#line 989 
      u32 *__var_2 = (u32 *)0U;
      
#line 989 
      tmp_3 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 989 
    u32 *hw_addr_2 = *tmp_3;
    
#line 989 
    if ((long)(hw_addr_2 == (u32 *)0U) == 0L) 
#line 989 
                                              writel(0U,(void volatile *)(hw_addr_2 + ((unsigned int)(i * 64) + 32774U))); else ;
  }
  {
    u32 * volatile *tmp_4;
    {
      
#line 990 
      u32 *__var_3 = (u32 *)0U;
      
#line 990 
      tmp_4 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 990 
    u32 *hw_addr_3 = *tmp_4;
    
#line 990 
    if ((long)(hw_addr_3 == (u32 *)0U) == 0L) 
#line 990 
                                              writel(txqctl,(void volatile *)(hw_addr_3 + ((unsigned int)(i * 64) + 32775U))); else ;
  }
  {
    u32 * volatile *tmp_5;
    {
      
#line 991 
      u32 *__var_4 = (u32 *)0U;
      
#line 991 
      tmp_5 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 991 
    u32 *hw_addr_4 = *tmp_5;
    
#line 991 
    if ((long)(hw_addr_4 == (u32 *)0U) == 0L) 
#line 991 
                                              writel(513U,(void volatile *)(hw_addr_4 + ((unsigned int)(i * 64) + 16391U))); else ;
  }
  {
    u32 * volatile *tmp_6;
    {
      
#line 994 
      u32 *__var_5 = (u32 *)0U;
      
#line 994 
      tmp_6 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 994 
    u32 *hw_addr_5 = *tmp_6;
    
#line 994 
    if ((long)(hw_addr_5 == (u32 *)0U) == 0L) 
#line 994 
                                              writel(rxqctl,(void volatile *)(hw_addr_5 + ((unsigned int)(i * 64) + 16390U))); else ;
  }
  
#line 988 
  i += 1;
  ldv_44608: 
#line 989 
  ;
  
#line 988 
  if ((int)queues_per_pool + (int)vf_q_idx > i) 
#line 990 
                                                goto ldv_44607; else 
                                                                  
#line 993 
                                                                  goto ldv_44609;
  ldv_44609: 
#line 994 
  ;
  {
    u32 * volatile *tmp_7;
    {
      
#line 998 
      u32 *__var_6 = (u32 *)0U;
      
#line 998 
      tmp_7 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 998 
    u32 *hw_addr_6 = *tmp_7;
    
#line 998 
    if ((long)(hw_addr_6 == (u32 *)0U) == 0L) 
#line 998 
                                              writel(0U,(void volatile *)(hw_addr_6 + ((unsigned int)vf_idx + 8256U))); else ;
  }
  {
    u32 * volatile *tmp_8;
    {
      
#line 999 
      u32 *__var_7 = (u32 *)0U;
      
#line 999 
      tmp_8 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 999 
    u32 *hw_addr_7 = *tmp_8;
    
#line 999 
    if ((long)(hw_addr_7 == (u32 *)0U) == 0L) 
#line 999 
                                              writel(0U,(void volatile *)(hw_addr_7 + ((unsigned int)vf_idx + 8320U))); else ;
  }
  {
    u32 * volatile *tmp_9;
    {
      
#line 1000 
      u32 *__var_8 = (u32 *)0U;
      
#line 1000 
      tmp_9 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1000 
    u32 *hw_addr_8 = *tmp_9;
    
#line 1000 
    if ((long)(hw_addr_8 == (u32 *)0U) == 0L) 
#line 1000 
                                              writel(2097151U,(void volatile *)(hw_addr_8 + ((unsigned int)vf_idx + 8192U))); else ;
  }
  
#line 1004 
  if ((unsigned int)vf_idx == 0U) 
#line 1005 
                                  (*(hw->mac.ops.update_int_moderator))(hw); else 
                                                                    
#line 1007 
                                                                    (*(hw->iov.ops.assign_int_moderator))(hw,(unsigned short)((int)((unsigned int)((unsigned short)vf_idx) + 65535U)));
  
#line 1010 
  if ((int)vf_idx == (int)hw->iov.num_vfs + -1) {
    u32 * volatile *tmp_10;
    {
      
#line 1011 
      u32 *__var_9 = (u32 *)0U;
      
#line 1011 
      tmp_10 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1011 
    u32 *hw_addr_9 = *tmp_10;
    
#line 1011 
    if ((long)(hw_addr_9 == (u32 *)0U) == 0L) 
#line 1011 
                                              writel((unsigned int)vf_v_idx,(void volatile *)(hw_addr_9 + 75776U)); else ;
  }
  else {
    u32 * volatile *tmp_11;
    {
      
#line 1013 
      u32 *__var_10 = (u32 *)0U;
      
#line 1013 
      tmp_11 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1013 
    u32 *hw_addr_10 = *tmp_11;
    
#line 1013 
    if ((long)(hw_addr_10 == (u32 *)0U) == 0L) 
#line 1013 
                                               writel((unsigned int)vf_v_idx,(void volatile *)(hw_addr_10 + ((unsigned int)((int)vf_v_limit * 2) + 75776U))); else ;
  }
  
#line 1016 
  vf_v_idx = (u16)((int)vf_v_idx + 1);
  
#line 1016 
  goto ldv_44629;
  ldv_44628: 
#line 1017 
  ;
  {
    u32 * volatile *tmp_12;
    {
      
#line 1017 
      u32 *__var_11 = (u32 *)0U;
      
#line 1017 
      tmp_12 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1017 
    u32 *hw_addr_11 = *tmp_12;
    
#line 1017 
    if ((long)(hw_addr_11 == (u32 *)0U) == 0L) 
#line 1017 
                                               writel((unsigned int)((int)vf_v_idx + -1),(void volatile *)(hw_addr_11 + ((unsigned int)((int)vf_v_idx * 2) + 75776U))); else ;
  }
  
#line 1016 
  vf_v_idx = (u16)((int)vf_v_idx + 1);
  ldv_44629: 
#line 1017 
  ;
  
#line 1016 
  if ((int)vf_v_idx < (int)vf_v_limit) 
#line 1018 
                                       goto ldv_44628; else 
#line 1021 
                                                            goto ldv_44630;
  ldv_44630: 
#line 1022 
  ;
  
#line 1020 
  i = 16;
  
#line 1020 
  goto ldv_44635;
  ldv_44634: 
#line 1021 
  ;
  {
    u32 * volatile *tmp_13;
    {
      
#line 1021 
      u32 *__var_12 = (u32 *)0U;
      
#line 1021 
      tmp_13 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1021 
    u32 *hw_addr_12 = *tmp_13;
    
#line 1021 
    if ((long)(hw_addr_12 == (u32 *)0U) == 0L) 
#line 1021 
                                               writel(0U,(void volatile *)(hw_addr_12 + ((unsigned int)((int)vf_idx * 16 + i) + 98304U))); else ;
  }
  ldv_44635: 
#line 1023 
  ;
  
#line 1020 
  tmp_14 = i;
  
#line 1020 
  i -= 1;
  
#line 1020 
  ;
  
#line 1020 
  if (tmp_14 != 0) 
#line 1022 
                   goto ldv_44634; else 
#line 1025 
                                        goto ldv_44636;
  ldv_44636: 
#line 1026 
  ;
  
#line 1022 
  i = 128;
  
#line 1022 
  goto ldv_44641;
  ldv_44640: 
#line 1023 
  ;
  {
    u32 * volatile *tmp_15;
    {
      
#line 1023 
      u32 *__var_13 = (u32 *)0U;
      
#line 1023 
      tmp_15 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1023 
    u32 *hw_addr_13 = *tmp_15;
    
#line 1023 
    if ((long)(hw_addr_13 == (u32 *)0U) == 0L) 
#line 1023 
                                               writel(0U,(void volatile *)(hw_addr_13 + ((unsigned int)((int)vf_info->vsi * 128 + i) + 81920U))); else ;
  }
  ldv_44641: 
#line 1025 
  ;
  
#line 1022 
  tmp_16 = i;
  
#line 1022 
  i -= 1;
  
#line 1022 
  ;
  
#line 1022 
  if (tmp_16 != 0) 
#line 1024 
                   goto ldv_44640; else 
#line 1027 
                                        goto ldv_44642;
  ldv_44642: 
#line 1028 
  ;
  
#line 1024 
  i = 32;
  
#line 1024 
  goto ldv_44647;
  ldv_44646: 
#line 1025 
  ;
  {
    u32 * volatile *tmp_17;
    {
      
#line 1025 
      u32 *__var_14 = (u32 *)0U;
      
#line 1025 
      tmp_17 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1025 
    u32 *hw_addr_14 = *tmp_17;
    
#line 1025 
    if ((long)(hw_addr_14 == (u32 *)0U) == 0L) 
#line 1025 
                                               writel(0U,(void volatile *)(hw_addr_14 + ((unsigned int)((int)vf_info->vsi * 32 + i) + 4096U))); else ;
  }
  ldv_44647: 
#line 1027 
  ;
  
#line 1024 
  tmp_18 = i;
  
#line 1024 
  i -= 1;
  
#line 1024 
  ;
  
#line 1024 
  if (tmp_18 != 0) 
#line 1026 
                   goto ldv_44646; else 
#line 1029 
                                        goto ldv_44648;
  ldv_44648: 
#line 1030 
  ;
  
#line 1026 
  i = 10;
  
#line 1026 
  goto ldv_44653;
  ldv_44652: 
#line 1027 
  ;
  {
    u32 * volatile *tmp_19;
    {
      
#line 1027 
      u32 *__var_15 = (u32 *)0U;
      
#line 1027 
      tmp_19 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1027 
    u32 *hw_addr_15 = *tmp_19;
    
#line 1027 
    if ((long)(hw_addr_15 == (u32 *)0U) == 0L) 
#line 1027 
                                               writel(0U,(void volatile *)(hw_addr_15 + ((unsigned int)((int)vf_info->vsi * 16 + i) + 2048U))); else ;
  }
  ldv_44653: 
#line 1029 
  ;
  
#line 1026 
  tmp_20 = i;
  
#line 1026 
  i -= 1;
  
#line 1026 
  ;
  
#line 1026 
  if (tmp_20 != 0) 
#line 1028 
                   goto ldv_44652; else 
#line 1031 
                                        goto ldv_44654;
  ldv_44654: 
#line 1032 
  ;
  {
    u32 * volatile *tmp_21;
    {
      
#line 1028 
      u32 *__var_16 = (u32 *)0U;
      
#line 1028 
      tmp_21 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1028 
    u32 *hw_addr_16 = *tmp_21;
    
#line 1028 
    if ((long)(hw_addr_16 == (u32 *)0U) == 0L) 
#line 1028 
                                               writel(0U,(void volatile *)(hw_addr_16 + ((unsigned int)vf_info->vsi + 8448U))); else ;
  }
  
#line 1031 
  tmp_22 = is_valid_ether_addr((u8 const *)(& vf_info->mac));
  
#line 1031 
  if ((int)tmp_22 != 0) {
    
#line 1032 
    tdbal = (((unsigned int)vf_info->mac[3] << 24) | ((unsigned int)vf_info->mac[4] << 16)) | ((unsigned int)vf_info->mac[5] << 8);
    
#line 1035 
    tdbah = ((((unsigned int)vf_info->mac[0] << 16) | ((unsigned int)vf_info->mac[1] << 8)) | (unsigned int)vf_info->mac[2]) | 4278190080U;
  }
  else ;
  
#line 1042 
  i = (int)queues_per_pool;
  
#line 1042 
  goto ldv_44671;
  ldv_44670: 
#line 1043 
  ;
  {
    u32 * volatile *tmp_23;
    {
      
#line 1043 
      u32 *__var_17 = (u32 *)0U;
      
#line 1043 
      tmp_23 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1043 
    u32 *hw_addr_17 = *tmp_23;
    
#line 1043 
    if ((long)(hw_addr_17 == (u32 *)0U) == 0L) 
#line 1043 
                                               writel(tdbal,(void volatile *)(hw_addr_17 + ((unsigned int)(((int)vf_q_idx + i) * 64) + 32768U))); else ;
  }
  {
    u32 * volatile *tmp_24;
    {
      
#line 1044 
      u32 *__var_18 = (u32 *)0U;
      
#line 1044 
      tmp_24 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1044 
    u32 *hw_addr_18 = *tmp_24;
    
#line 1044 
    if ((long)(hw_addr_18 == (u32 *)0U) == 0L) 
#line 1044 
                                               writel(tdbah,(void volatile *)(hw_addr_18 + ((unsigned int)(((int)vf_q_idx + i) * 64) + 32769U))); else ;
  }
  {
    u32 * volatile *tmp_25;
    {
      
#line 1045 
      u32 *__var_19 = (u32 *)0U;
      
#line 1045 
      tmp_25 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1045 
    u32 *hw_addr_19 = *tmp_25;
    
#line 1045 
    if ((long)(hw_addr_19 == (u32 *)0U) == 0L) 
#line 1045 
                                               writel((unsigned int)((int)vf_q_idx + i),(void volatile *)(hw_addr_19 + ((unsigned int)((int)qmap_idx + i) + 10240U))); else ;
  }
  {
    u32 * volatile *tmp_26;
    {
      
#line 1046 
      u32 *__var_20 = (u32 *)0U;
      
#line 1046 
      tmp_26 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1046 
    u32 *hw_addr_20 = *tmp_26;
    
#line 1046 
    if ((long)(hw_addr_20 == (u32 *)0U) == 0L) 
#line 1046 
                                               writel((unsigned int)((int)vf_q_idx + i),(void volatile *)(hw_addr_20 + ((unsigned int)((int)qmap_idx + i) + 12288U))); else ;
  }
  ldv_44671: 
#line 1048 
  ;
  
#line 1042 
  tmp_27 = i;
  
#line 1042 
  i -= 1;
  
#line 1042 
  ;
  
#line 1042 
  if (tmp_27 != 0) 
#line 1044 
                   goto ldv_44670; else 
#line 1047 
                                        goto ldv_44672;
  ldv_44672: 
#line 1048 
  ;
  
#line 1050 
  i = (int)queues_per_pool;
  
#line 1050 
  goto ldv_44680;
  ldv_44679: 
#line 1051 
  ;
  {
    u32 * volatile *tmp_28;
    {
      
#line 1051 
      u32 *__var_21 = (u32 *)0U;
      
#line 1051 
      tmp_28 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1051 
    u32 *hw_addr_21 = *tmp_28;
    
#line 1051 
    if ((long)(hw_addr_21 == (u32 *)0U) == 0L) 
#line 1051 
                                               writel((unsigned int)vf_q_idx,(void volatile *)(hw_addr_21 + ((unsigned int)((int)qmap_idx + i) + 10240U))); else ;
  }
  {
    u32 * volatile *tmp_29;
    {
      
#line 1052 
      u32 *__var_22 = (u32 *)0U;
      
#line 1052 
      tmp_29 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1052 
    u32 *hw_addr_22 = *tmp_29;
    
#line 1052 
    if ((long)(hw_addr_22 == (u32 *)0U) == 0L) 
#line 1052 
                                               writel((unsigned int)vf_q_idx,(void volatile *)(hw_addr_22 + ((unsigned int)((int)qmap_idx + i) + 12288U))); else ;
  }
  
#line 1050 
  i += 1;
  ldv_44680: 
#line 1051 
  ;
  
#line 1050 
  if ((int)qmap_stride > i) 
#line 1052 
                            goto ldv_44679; else 
#line 1055 
                                                 goto ldv_44681;
  ldv_44681: 
#line 1056 
  ;
  
#line 1055 
  __retres = 0;
  return_label: 
#line 1055 
                return __retres;
}


#line 1068  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_iov_set_lport_pf(struct fm10k_hw *hw, struct fm10k_vf_info *vf_info, u16 lport_idx, u8 flags)
{
  s32 __retres;
  int tmp_0;
  bool tmp;
  
#line 1072 
  u16 glort = (unsigned short)((int)((unsigned short)hw->mac.dglort_map) + (int)lport_idx);
  
#line 1075 
  tmp = fm10k_glort_valid_pf(hw,(unsigned short)((int)glort));
  
#line 1075 
  if (tmp) 
#line 1075 
           tmp_0 = 0; else 
#line 1075 
                           tmp_0 = 1;
  
#line 1075 
  if (tmp_0) {
    
#line 1076 
    __retres = -2;
    
#line 1076 
    goto return_label;
  }
  else ;
  
#line 1078 
  vf_info->vf_flags = (unsigned char)((unsigned int)flags | 8U);
  
#line 1079 
  vf_info->glort = glort;
  
#line 1081 
  __retres = 0;
  return_label: 
#line 1081 
                return __retres;
}


#line 1092  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static void fm10k_iov_reset_lport_pf(struct fm10k_hw *hw, struct fm10k_vf_info *vf_info)
{
  u32 msg[1U];
  
#line 1098 
  if ((unsigned int)((int)vf_info->vf_flags >> 4) != 0U) {
    
#line 1100 
    fm10k_update_lport_state_pf(hw,(unsigned short)((int)vf_info->glort),(unsigned short)1,(_Bool)0);
    
#line 1103 
    fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)3);
    
#line 1104 
    (*(vf_info->mbx.ops.enqueue_tx))(hw,& vf_info->mbx,(u32 const *)(& msg));
  }
  else ;
  
#line 1108 
  vf_info->vf_flags = (unsigned char)0U;
  
#line 1109 
  vf_info->glort = (unsigned short)0U;
  
#line 1110 
  return;
}


#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static void fm10k_iov_update_stats_pf(struct fm10k_hw *hw, struct fm10k_hw_stats_q *q, u16 vf_idx)
{
  u32 idx;
  u32 qpp;
  u16 tmp;
  u16 tmp_0;
  
#line 1127 
  tmp = fm10k_queues_per_pool(hw);
  
#line 1127 
  qpp = (unsigned int)tmp;
  
#line 1128 
  tmp_0 = fm10k_vf_queue_index(hw,(unsigned short)((int)vf_idx));
  
#line 1128 
  idx = (unsigned int)tmp_0;
  
#line 1129 
  fm10k_update_hw_stats_q(hw,q,idx,qpp);
  
#line 1130 
  return;
}


#line 1132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_iov_report_timestamp_pf(struct fm10k_hw *hw, struct fm10k_vf_info *vf_info, u64 timestamp)
{
  u32 msg[4U];
  s32 tmp;
  
#line 1139 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)4);
  
#line 1140 
  fm10k_tlv_attr_put_value((u32 *)(& msg),(unsigned short)0,(long long)timestamp,8U);
  
#line 1142 
  tmp = (*(vf_info->mbx.ops.enqueue_tx))(hw,& vf_info->mbx,(u32 const *)(& msg));
  
#line 1142 
  return tmp;
}


#line 1155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
s32 fm10k_iov_msg_msix_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 tmp;
  
#line 1158 
  struct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;
  
#line 1159 
  u8 vf_idx = vf_info->vf_idx;
  
#line 1161 
  tmp = (*(hw->iov.ops.assign_int_moderator))(hw,(unsigned short)((int)vf_idx));
  
#line 1161 
  return tmp;
}


#line 1174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
s32 fm10k_iov_msg_mac_vlan_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u8 mac[6U];
  u32 *result;
  u16 vlan;
  u32 vid;
  
#line 1177 
  struct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;
  
#line 1178 
  int err = 0;
  
#line 1185 
  if ((unsigned int)((int)vf_info->vf_flags >> 4) == 0U) 
#line 1186 
                                                         err = -2; else ;
  
#line 1188 
  if (err == 0 && *results != (u32 *)0U) {
    
#line 1189 
    result = *results;
    
#line 1192 
    err = fm10k_tlv_attr_get_value(result,(void *)(& vid),4U);
    
#line 1193 
    if (err != 0) {
      
#line 1194 
      __retres = err;
      
#line 1194 
      goto return_label;
    }
    else ;
    
#line 1197 
    if (vid == 0U || vid == 32768U) 
      
#line 1198 
      if ((unsigned int)vf_info->pf_vid != 0U) 
#line 1199 
                                               vid = (unsigned int)vf_info->pf_vid | vid; else 
                                                                    
#line 1201 
                                                                    vid = (unsigned int)vf_info->sw_vid | vid;
    else 
      
#line 1202 
      if ((unsigned int)vf_info->pf_vid != vid) {
        
#line 1203 
        __retres = -2;
        
#line 1203 
        goto return_label;
      }
      else ;
    
#line 1207 
    err = (*(hw->mac.ops.update_vlan))(hw,vid,(unsigned char)((int)vf_info->vsi),(_Bool)((vid & 32768U) == 0U));
  }
  else ;
  
#line 1211 
  if (err == 0 && *(results + 2U) != (u32 *)0U) {
    bool tmp;
    
#line 1212 
    result = *(results + 2U);
    
#line 1215 
    err = fm10k_tlv_attr_get_mac_vlan(result,(u8 *)(& mac),& vlan);
    
#line 1216 
    if (err != 0) {
      
#line 1217 
      __retres = err;
      
#line 1217 
      goto return_label;
    }
    else ;
    
#line 1220 
    tmp = is_valid_ether_addr((u8 const *)(& vf_info->mac));
    
#line 1220 
    if ((int)tmp != 0) {
      int tmp_0;
      
#line 1220 
      tmp_0 = memcmp((void const *)(& mac),(void const *)(& vf_info->mac),6UL);
      
#line 1220 
      if (tmp_0 != 0) {
        
#line 1222 
        __retres = -2;
        
#line 1222 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 1225 
    if ((unsigned int)vlan == 0U || (unsigned int)vlan == 32768U) 
      
#line 1226 
      if ((unsigned int)vf_info->pf_vid != 0U) 
#line 1227 
                                               vlan = (unsigned short)((int)vf_info->pf_vid | (int)vlan); else 
                                                                    
#line 1229 
                                                                    vlan = (unsigned short)((int)vf_info->sw_vid | (int)vlan);
    else 
      
#line 1230 
      if ((unsigned int)vf_info->pf_vid != 0U) {
        
#line 1231 
        __retres = -2;
        
#line 1231 
        goto return_label;
      }
      else ;
    
#line 1235 
    err = (*(hw->mac.ops.update_uc_addr))(hw,(unsigned short)((int)vf_info->glort),(u8 const *)(& mac),(unsigned short)((int)vlan),(_Bool)((int)vlan >= 0),(unsigned char)0);
  }
  else ;
  
#line 1239 
  if (err == 0 && *(results + 4U) != (u32 *)0U) {
    
#line 1240 
    result = *(results + 4U);
    
#line 1243 
    err = fm10k_tlv_attr_get_mac_vlan(result,(u8 *)(& mac),& vlan);
    
#line 1244 
    if (err != 0) {
      
#line 1245 
      __retres = err;
      
#line 1245 
      goto return_label;
    }
    else ;
    
#line 1248 
    if (((int)vf_info->vf_flags & 112) == 0) {
      
#line 1249 
      __retres = -2;
      
#line 1249 
      goto return_label;
    }
    else ;
    
#line 1252 
    if ((unsigned int)vlan == 0U || (unsigned int)vlan == 32768U) 
      
#line 1253 
      if ((unsigned int)vf_info->pf_vid != 0U) 
#line 1254 
                                               vlan = (unsigned short)((int)vf_info->pf_vid | (int)vlan); else 
                                                                    
#line 1256 
                                                                    vlan = (unsigned short)((int)vf_info->sw_vid | (int)vlan);
    else 
      
#line 1257 
      if ((unsigned int)vf_info->pf_vid != 0U) {
        
#line 1258 
        __retres = -2;
        
#line 1258 
        goto return_label;
      }
      else ;
    
#line 1262 
    err = (*(hw->mac.ops.update_mc_addr))(hw,(unsigned short)((int)vf_info->glort),(u8 const *)(& mac),(unsigned short)((int)vlan),(_Bool)((int)vlan >= 0));
  }
  else ;
  
#line 1266 
  __retres = err;
  return_label: 
#line 1266 
                return __retres;
}


#line 1277  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static u8 fm10k_iov_supported_xcast_mode_pf(struct fm10k_vf_info *vf_info, u8 mode)
{
  u8 __retres;
  
#line 1280 
  u8 vf_flags = vf_info->vf_flags;
  
#line 1283 
  switch ((int)mode) {
    case 2: 
#line 1284 
    ;
    
#line 1285 
    if (((int)vf_flags & 4) != 0) {
      
#line 1286 
      __retres = (unsigned char)2U;
      
#line 1286 
      goto return_label;
    }
    else ;
    case 0: 
#line 1288 
    ;
    
#line 1289 
    if (((int)vf_flags & 1) != 0) {
      
#line 1290 
      __retres = (unsigned char)0U;
      
#line 1290 
      goto return_label;
    }
    else ;
    case 1: 
#line 1292 
    ;
    
#line 1293 
    if (((int)vf_flags & 2) != 0) {
      
#line 1294 
      __retres = (unsigned char)1U;
      
#line 1294 
      goto return_label;
    }
    else ;
    case 3: 
#line 1296 
    ;
    
#line 1297 
    if (((int)vf_flags & 8) != 0) {
      
#line 1298 
      __retres = (unsigned char)3U;
      
#line 1298 
      goto return_label;
    }
    else ;
    default: 
#line 1300 
    ;
    
#line 1301 
    goto ldv_44735;
  }
  ldv_44735: 
#line 1305 
  ;
  
#line 1305 
  __retres = (unsigned char)4U;
  return_label: 
#line 1305 
                return __retres;
}


#line 1318  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
s32 fm10k_iov_msg_lport_state_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u32 *result;
  u32 msg[2U];
  
#line 1321 
  struct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;
  
#line 1323 
  s32 err = 0;
  
#line 1325 
  u8 mode = (unsigned char)0U;
  
#line 1328 
  if (((int)vf_info->vf_flags & 8) == 0) {
    
#line 1329 
    __retres = -2;
    
#line 1329 
    goto return_label;
  }
  else ;
  
#line 1331 
  if (*(results + 1U) != (u32 *)0U) {
    
#line 1332 
    result = *(results + 1U);
    
#line 1335 
    err = fm10k_tlv_attr_get_value(result,(void *)(& mode),1U);
    
#line 1336 
    if (err != 0) {
      
#line 1337 
      __retres = -2;
      
#line 1337 
      goto return_label;
    }
    else ;
    
#line 1340 
    mode = fm10k_iov_supported_xcast_mode_pf(vf_info,(unsigned char)((int)mode));
    
#line 1343 
    if (((((int)vf_info->vf_flags >> 4) >> (int)mode) & 1) == 0) 
#line 1344 
                                                                 fm10k_update_xcast_mode_pf(hw,(unsigned short)((int)vf_info->glort),(unsigned char)((int)mode)); else ;
    
#line 1347 
    mode = (unsigned char)(16 << (int)mode);
  }
  else 
    
#line 1348 
    if (*results == (u32 *)0U) {
      
#line 1350 
      if ((unsigned int)((int)vf_info->vf_flags >> 4) != 0U) 
#line 1351 
                                                             err = fm10k_update_lport_state_pf(hw,(unsigned short)((int)vf_info->glort),(unsigned short)1,(_Bool)0); else ;
      
#line 1359 
      if (err == 0) 
#line 1360 
                    vf_info->vf_flags = (unsigned char)((unsigned int)vf_info->vf_flags & 15U); else ;
      
#line 1363 
      (*(hw->iov.ops.configure_tc))(hw,(unsigned short)((int)vf_info->vf_idx),vf_info->rate);
      
#line 1366 
      mode = (unsigned char)128U;
      
#line 1369 
      fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)3);
      
#line 1370 
      fm10k_tlv_attr_put_bool((u32 *)(& msg),(unsigned short)2);
      
#line 1371 
      (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
    }
    else ;
  
#line 1375 
  if (err == 0 && ((unsigned int)((int)vf_info->vf_flags >> 4) == 0U) ^ ((unsigned int)mode == 0U)) 
    
#line 1376 
    err = fm10k_update_lport_state_pf(hw,(unsigned short)((int)vf_info->glort),(unsigned short)1,(_Bool)((unsigned int)mode != 0U)); else ;
  
#line 1380 
  mode = (unsigned char)(((int)vf_info->vf_flags & 15) | (int)mode);
  
#line 1381 
  if (err == 0) 
#line 1382 
                vf_info->vf_flags = mode; else ;
  
#line 1384 
  __retres = err;
  return_label: 
#line 1384 
                return __retres;
}


#line 1387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
struct fm10k_msg_data const fm10k_iov_msg_data_pf[5U] = {{.id = 0U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_tlv_msg_test_attr), .func = & fm10k_tlv_msg_test}, {.id = 1U, .attr = (struct fm10k_tlv_attr const *)0, .func = & fm10k_iov_msg_msix_pf}, {.id = 2U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_mac_vlan_msg_attr), .func = & fm10k_iov_msg_mac_vlan_pf}, {.id = 3U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_lport_state_msg_attr), .func = & fm10k_iov_msg_lport_state_pf}, {.id = 4294967295U, .attr = (struct fm10k_tlv_attr const *)0, .func = & fm10k_tlv_msg_error}};

#line 1403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static void fm10k_update_hw_stats_pf(struct fm10k_hw *hw, struct fm10k_hw_stats *stats)
{
  u32 timeout;
  u32 ur;
  u32 ca;
  u32 um;
  u32 xec;
  u32 vlan_drop;
  u32 loopback_drop;
  u32 nodesc_drop;
  u32 id;
  u32 id_prev;
  
#line 1410 
  id = fm10k_read_reg(hw,32775);
  ldv_44761: 
#line 1411 
  ;
  
#line 1414 
  timeout = fm10k_read_hw_stats_32b(hw,14336U,& stats->timeout);
  
#line 1416 
  ur = fm10k_read_hw_stats_32b(hw,14337U,& stats->ur);
  
#line 1417 
  ca = fm10k_read_hw_stats_32b(hw,14338U,& stats->ca);
  
#line 1418 
  um = fm10k_read_hw_stats_32b(hw,14339U,& stats->um);
  
#line 1419 
  xec = fm10k_read_hw_stats_32b(hw,14340U,& stats->xec);
  
#line 1420 
  vlan_drop = fm10k_read_hw_stats_32b(hw,14341U,& stats->vlan_drop);
  
#line 1422 
  loopback_drop = fm10k_read_hw_stats_32b(hw,14342U,& stats->loopback_drop);
  
#line 1425 
  nodesc_drop = fm10k_read_hw_stats_32b(hw,14343U,& stats->nodesc_drop);
  
#line 1430 
  id_prev = id;
  
#line 1431 
  id = fm10k_read_reg(hw,32775);
  
#line 1432 
  if (((id ^ id_prev) & 127U) != 0U) 
#line 1434 
                                     goto ldv_44761; else 
#line 1437 
                                                          goto ldv_44762;
  ldv_44762: 
#line 1438 
  ;
  
#line 1435 
  id &= 127U;
  
#line 1436 
  id |= 2147483648U;
  
#line 1439 
  if (stats->timeout.base_h == id) {
    
#line 1440 
    stats->timeout.count += (unsigned long long)timeout;
    
#line 1441 
    stats->ur.count += (unsigned long long)ur;
    
#line 1442 
    stats->ca.count += (unsigned long long)ca;
    
#line 1443 
    stats->um.count += (unsigned long long)um;
    
#line 1444 
    stats->xec.count += (unsigned long long)xec;
    
#line 1445 
    stats->vlan_drop.count += (unsigned long long)vlan_drop;
    
#line 1446 
    stats->loopback_drop.count += (unsigned long long)loopback_drop;
    
#line 1447 
    stats->nodesc_drop.count += (unsigned long long)nodesc_drop;
  }
  else ;
  
#line 1451 
  stats->timeout.base_l += timeout;
  
#line 1452 
  stats->ur.base_l += ur;
  
#line 1453 
  stats->ca.base_l += ca;
  
#line 1454 
  stats->um.base_l += um;
  
#line 1455 
  stats->xec.base_l += xec;
  
#line 1456 
  stats->vlan_drop.base_l += vlan_drop;
  
#line 1457 
  stats->loopback_drop.base_l += loopback_drop;
  
#line 1458 
  stats->nodesc_drop.base_l += nodesc_drop;
  
#line 1459 
  stats->timeout.base_h = id;
  
#line 1462 
  fm10k_update_hw_stats_q(hw,(struct fm10k_hw_stats_q *)(& stats->q),0U,(unsigned int)hw->mac.max_queues);
  
#line 1463 
  return;
}


#line 1473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static void fm10k_rebind_hw_stats_pf(struct fm10k_hw *hw, struct fm10k_hw_stats *stats)
{
  
#line 1477 
  stats->timeout.base_h = 0U;
  
#line 1478 
  stats->ur.base_h = 0U;
  
#line 1479 
  stats->ca.base_h = 0U;
  
#line 1480 
  stats->um.base_h = 0U;
  
#line 1481 
  stats->xec.base_h = 0U;
  
#line 1482 
  stats->vlan_drop.base_h = 0U;
  
#line 1483 
  stats->loopback_drop.base_h = 0U;
  
#line 1484 
  stats->nodesc_drop.base_h = 0U;
  
#line 1487 
  fm10k_unbind_hw_stats_q((struct fm10k_hw_stats_q *)(& stats->q),0U,(unsigned int)hw->mac.max_queues);
  
#line 1490 
  fm10k_update_hw_stats_pf(hw,stats);
  
#line 1491 
  return;
}


#line 1501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static void fm10k_set_dma_mask_pf(struct fm10k_hw *hw, u64 dma_mask)
{
  
#line 1504 
  u32 phyaddr = (unsigned int)(dma_mask >> 32);
  {
    u32 * volatile *tmp;
    {
      
#line 1506 
      u32 *__var = (u32 *)0U;
      
#line 1506 
      tmp = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1506 
    u32 *hw_addr = *tmp;
    
#line 1506 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 1506 
                                            writel(phyaddr,(void volatile *)(hw_addr + 14364U)); else ;
  }
  
#line 1508 
  return;
}


#line 1520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_get_fault_pf(struct fm10k_hw *hw, int type, struct fm10k_fault *fault)
{
  s32 __retres;
  u32 func;
  u32 tmp;
  u32 tmp_0;
  
#line 1526 
  switch (type) {
    case 8: 
#line 1527 
    ;
    case 16: 
#line 1528 
    ;
    case 28: 
#line 1529 
    ;
    
#line 1530 
    goto ldv_44784;
    default: 
#line 1531 
    ;
    
#line 1532 
    __retres = -2;
    
#line 1532 
    goto return_label;
  }
  ldv_44784: 
#line 1536 
  ;
  
#line 1536 
  func = fm10k_read_reg(hw,type + 3);
  
#line 1537 
  if ((func & 32768U) == 0U) {
    
#line 1538 
    __retres = -2;
    
#line 1538 
    goto return_label;
  }
  else ;
  
#line 1541 
  tmp = fm10k_read_reg(hw,type + 1);
  
#line 1541 
  fault->address = (unsigned long long)tmp;
  
#line 1542 
  fault->address <<= 32;
  
#line 1543 
  tmp_0 = fm10k_read_reg(hw,type);
  
#line 1543 
  fault->address = (unsigned long long)tmp_0;
  
#line 1544 
  fault->specinfo = fm10k_read_reg(hw,type + 2);
  {
    u32 * volatile *tmp_1;
    {
      
#line 1547 
      u32 *__var = (u32 *)0U;
      
#line 1547 
      tmp_1 = (u32 * volatile *)(& hw->hw_addr);
    }
    
#line 1547 
    u32 *hw_addr = *tmp_1;
    
#line 1547 
    if ((long)(hw_addr == (u32 *)0U) == 0L) 
#line 1547 
                                            writel(32768U,(void volatile *)(hw_addr + ((unsigned int)type + 3U))); else ;
  }
  
#line 1550 
  if ((func & 16384U) != 0U) 
#line 1551 
                             fault->func = (unsigned char)0U; else 
#line 1553 
                                                                   fault->func = (unsigned char)(((unsigned int)((unsigned char)(func >> 8)) & 63U) + 1U);
  
#line 1557 
  fault->type = (unsigned char)func;
  
#line 1559 
  __retres = 0;
  return_label: 
#line 1559 
                return __retres;
}


#line 1567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_request_lport_map_pf(struct fm10k_hw *hw)
{
  u32 msg[1U];
  s32 tmp;
  
#line 1569 
  struct fm10k_mbx_info *mbx = & hw->mbx;
  
#line 1573 
  fm10k_tlv_msg_init((u32 *)(& msg),(unsigned short)256);
  
#line 1576 
  tmp = (*(mbx->ops.enqueue_tx))(hw,mbx,(u32 const *)(& msg));
  
#line 1576 
  return tmp;
}


#line 1588  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_get_host_state_pf(struct fm10k_hw *hw, bool *switch_ready)
{
  u32 dma_ctrl2;
  
#line 1590 
  s32 ret_val = 0;
  
#line 1594 
  dma_ctrl2 = fm10k_read_reg(hw,8388);
  
#line 1595 
  if ((dma_ctrl2 & 8192U) == 0U) 
#line 1596 
                                 goto out; else ;
  
#line 1599 
  ret_val = fm10k_get_host_state_generic(hw,switch_ready);
  
#line 1600 
  if (ret_val != 0) 
#line 1601 
                    goto out; else ;
  
#line 1604 
  if (hw->mac.dglort_map == 65535U) 
#line 1605 
                                    ret_val = fm10k_request_lport_map_pf(hw); else ;
  out: 
#line 1607 
  ;
  
#line 1608 
  return ret_val;
}


#line 1612  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
struct fm10k_tlv_attr const fm10k_lport_map_msg_attr[2U] = {{.id = 1U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)4U}, {.id = 4294967295U, .type = 0, .len = (unsigned short)0}};

#line 1626  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
s32 fm10k_msg_lport_map_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u16 glort;
  u16 mask;
  u32 dglort_map;
  s32 err;
  
#line 1633 
  err = fm10k_tlv_attr_get_value(*(results + 1U),(void *)(& dglort_map),4U);
  
#line 1635 
  if (err != 0) {
    
#line 1636 
    __retres = err;
    
#line 1636 
    goto return_label;
  }
  else ;
  
#line 1639 
  glort = (unsigned short)dglort_map;
  
#line 1640 
  mask = (unsigned short)(dglort_map >> 16);
  
#line 1643 
  if ((unsigned int)mask == 0U || ((int)glort & ~ ((int)mask)) != 0) {
    
#line 1644 
    __retres = -2;
    
#line 1644 
    goto return_label;
  }
  else ;
  
#line 1647 
  if ((((- ((int)mask) & (int)mask) + (int)mask) & 65535) != 0) {
    
#line 1648 
    __retres = -2;
    
#line 1648 
    goto return_label;
  }
  else ;
  
#line 1651 
  hw->mac.dglort_map = dglort_map;
  
#line 1653 
  __retres = 0;
  return_label: 
#line 1653 
                return __retres;
}


#line 1656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
struct fm10k_tlv_attr const fm10k_update_pvid_msg_attr[2U] = {{.id = 13U, .type = FM10K_TLV_UNSIGNED, .len = (unsigned short)4U}, {.id = 4294967295U, .type = 0, .len = (unsigned short)0}};

#line 1669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
s32 fm10k_msg_update_pvid_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  u16 glort;
  u16 pvid;
  u32 pvid_update;
  s32 err;
  int tmp_0;
  bool tmp;
  
#line 1676 
  err = fm10k_tlv_attr_get_value(*(results + 13U),(void *)(& pvid_update),4U);
  
#line 1678 
  if (err != 0) {
    
#line 1679 
    __retres = err;
    
#line 1679 
    goto return_label;
  }
  else ;
  
#line 1682 
  glort = (unsigned short)pvid_update;
  
#line 1683 
  pvid = (unsigned short)(pvid_update >> 16);
  
#line 1686 
  tmp = fm10k_glort_valid_pf(hw,(unsigned short)((int)glort));
  
#line 1686 
  if (tmp) 
#line 1686 
           tmp_0 = 0; else 
#line 1686 
                           tmp_0 = 1;
  
#line 1686 
  if (tmp_0) {
    
#line 1687 
    __retres = -2;
    
#line 1687 
    goto return_label;
  }
  else ;
  
#line 1690 
  if ((unsigned int)pvid > 4095U) {
    
#line 1691 
    __retres = -2;
    
#line 1691 
    goto return_label;
  }
  else ;
  
#line 1694 
  hw->mac.default_vid = pvid;
  
#line 1696 
  __retres = 0;
  return_label: 
#line 1696 
                return __retres;
}


#line 1707  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static void fm10k_record_global_table_data(struct fm10k_global_table_data *from, struct fm10k_swapi_table_info *to)
{
  
#line 1711 
  to->used = from->used;
  
#line 1712 
  to->avail = from->avail;
  
#line 1713 
  return;
}


#line 1715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
struct fm10k_tlv_attr const fm10k_err_msg_attr[2U] = {{.id = 0U, .type = FM10K_TLV_LE_STRUCT, .len = (unsigned short)28U}, {.id = 4294967295U, .type = 0, .len = (unsigned short)0}};

#line 1730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
s32 fm10k_msg_err_pf(struct fm10k_hw *hw, u32 **results, struct fm10k_mbx_info *mbx)
{
  s32 __retres;
  struct fm10k_swapi_error err_msg;
  s32 err;
  
#line 1737 
  err = fm10k_tlv_attr_get_le_struct(*results,(void *)(& err_msg),28U);
  
#line 1739 
  if (err != 0) {
    
#line 1740 
    __retres = err;
    
#line 1740 
    goto return_label;
  }
  else ;
  
#line 1743 
  fm10k_record_global_table_data(& err_msg.mac,& hw->swapi.mac);
  
#line 1744 
  fm10k_record_global_table_data(& err_msg.nexthop,& hw->swapi.nexthop);
  
#line 1745 
  fm10k_record_global_table_data(& err_msg.ffu,& hw->swapi.ffu);
  
#line 1748 
  hw->swapi.status = err_msg.status;
  
#line 1750 
  __retres = 0;
  return_label: 
#line 1750 
                return __retres;
}


#line 1753  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
struct fm10k_tlv_attr const fm10k_1588_timestamp_msg_attr[2U] = {{.id = 16U, .type = FM10K_TLV_LE_STRUCT, .len = (unsigned short)20U}, {.id = 4294967295U, .type = 0, .len = (unsigned short)0}};

#line 1774  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_adjust_systime_pf(struct fm10k_hw *hw, s32 ppb)
{
  s32 __retres;
  u64 systime_adjust;
  s32 tmp_0;
  
#line 1779 
  if (hw->sw_addr == (u32 *)0U) {
    int tmp;
    
#line 1780 
    if (ppb != 0) 
#line 1780 
                  tmp = -2; else 
#line 1780 
                                 tmp = 0;
    
#line 1780 
    __retres = tmp;
    
#line 1780 
    goto return_label;
  }
  else ;
  
#line 1795 
  if (ppb < 0) 
#line 1795 
               tmp_0 = - ppb; else 
#line 1795 
                                   tmp_0 = ppb;
  
#line 1795 
  systime_adjust = (unsigned long long)tmp_0;
  
#line 1796 
  systime_adjust <<= 31;
  {
    uint32_t __rem;
    
#line 1797 
    uint32_t __base = 1953125U;
    
#line 1797 
    __rem = (unsigned int)(systime_adjust % (unsigned long long)__base);
    
#line 1797 
    systime_adjust /= (unsigned long long)__base;
    
#line 1797 
    uint32_t tmp_2 = __rem;
  }
  
#line 1800 
  if (systime_adjust > 1073741823ULL) {
    
#line 1801 
    __retres = -2;
    
#line 1801 
    goto return_label;
  }
  else ;
  
#line 1803 
  if (ppb > 0) 
#line 1804 
               systime_adjust |= 2147483648ULL; else ;
  {
    u32 * volatile *tmp_1;
    {
      
#line 1806 
      u32 *__var = (u32 *)0U;
      
#line 1806 
      tmp_1 = (u32 * volatile *)(& hw->sw_addr);
    }
    
#line 1806 
    u32 *sw_addr = *tmp_1;
    
#line 1806 
    if ((long)(sw_addr == (u32 *)0U) == 0L) 
#line 1806 
                                            writel((unsigned int)systime_adjust,(void volatile *)(sw_addr + 8781U)); else ;
  }
  
#line 1808 
  __retres = 0;
  return_label: 
#line 1808 
                return __retres;
}


#line 1821  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static u64 fm10k_read_systime_pf(struct fm10k_hw *hw)
{
  u64 __retres;
  u32 systime_l;
  u32 systime_h;
  u32 systime_tmp;
  
#line 1825 
  systime_h = fm10k_read_reg(hw,14357);
  ldv_44851: 
#line 1826 
  ;
  
#line 1828 
  systime_tmp = systime_h;
  
#line 1829 
  systime_l = fm10k_read_reg(hw,14356);
  
#line 1830 
  systime_h = fm10k_read_reg(hw,14357);
  
#line 1831 
  if (systime_tmp != systime_h) 
#line 1833 
                                goto ldv_44851; else 
#line 1836 
                                                     goto ldv_44852;
  ldv_44852: 
#line 1837 
  ;
  
#line 1833 
  __retres = ((unsigned long long)systime_h << 32) | (unsigned long long)systime_l;
  
#line 1833 
  return __retres;
}


#line 1836  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static struct fm10k_msg_data const fm10k_msg_data_pf[7U] = {{.id = 1U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_err_msg_attr), .func = & fm10k_msg_err_pf}, {.id = 2U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_err_msg_attr), .func = & fm10k_msg_err_pf}, {.id = 256U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_lport_map_msg_attr), .func = & fm10k_msg_lport_map_pf}, {.id = 512U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_err_msg_attr), .func = & fm10k_msg_err_pf}, {.id = 513U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_err_msg_attr), .func = & fm10k_msg_err_pf}, {.id = 1024U, .attr = (struct fm10k_tlv_attr const *)(& fm10k_update_pvid_msg_attr), .func = & fm10k_msg_update_pvid_pf}, {.id = 4294967295U, .attr = (struct fm10k_tlv_attr const *)0, .func = & fm10k_tlv_msg_error}};

#line 1846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static struct fm10k_mac_ops mac_ops_pf = {.reset_hw = & fm10k_reset_hw_pf, .init_hw = & fm10k_init_hw_pf, .start_hw = & fm10k_start_hw_generic, .stop_hw = & fm10k_stop_hw_generic, .get_bus_info = & fm10k_get_bus_info_generic, .get_host_state = & fm10k_get_host_state_pf, .is_slot_appropriate = & fm10k_is_slot_appropriate_pf, .update_vlan = & fm10k_update_vlan_pf, .read_mac_addr = & fm10k_read_mac_addr_pf, .update_uc_addr = & fm10k_update_uc_addr_pf, .update_mc_addr = & fm10k_update_mc_addr_pf, .update_xcast_mode = & fm10k_update_xcast_mode_pf, .update_int_moderator = & fm10k_update_int_moderator_pf, .update_lport_state = & fm10k_update_lport_state_pf, .update_hw_stats = & fm10k_update_hw_stats_pf, .rebind_hw_stats = & fm10k_rebind_hw_stats_pf, .configure_dglort_map = & fm10k_configure_dglort_map_pf, .set_dma_mask = & fm10k_set_dma_mask_pf, .get_fault = & fm10k_get_fault_pf, .request_lport_map = (void (*)(struct fm10k_hw *))0, .adjust_systime = & fm10k_adjust_systime_pf, .read_systime = & fm10k_read_systime_pf};

#line 1870  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static struct fm10k_iov_ops iov_ops_pf = {.assign_resources = & fm10k_iov_assign_resources_pf, .configure_tc = & fm10k_iov_configure_tc_pf, .assign_int_moderator = & fm10k_iov_assign_int_moderator_pf, .assign_default_mac_vlan = & fm10k_iov_assign_default_mac_vlan_pf, .reset_resources = & fm10k_iov_reset_resources_pf, .set_lport = & fm10k_iov_set_lport_pf, .reset_lport = & fm10k_iov_reset_lport_pf, .update_stats = & fm10k_iov_update_stats_pf, .report_timestamp = & fm10k_iov_report_timestamp_pf};

#line 1882  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
static s32 fm10k_get_invariants_pf(struct fm10k_hw *hw)
{
  s32 tmp;
  
#line 1884 
  fm10k_get_invariants_generic(hw);
  
#line 1886 
  tmp = fm10k_sm_mbx_init(hw,& hw->mbx,(struct fm10k_msg_data const *)(& fm10k_msg_data_pf));
  
#line 1886 
  return tmp;
}


#line 1889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_pf.c"
struct fm10k_info fm10k_pf_info = {.mac = fm10k_mac_pf, .get_invariants = & fm10k_get_invariants_pf, .mac_ops = & mac_ops_pf, .iov_ops = & iov_ops_pf};

#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_fault(char const *, int);


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static bool IS_ERR(void const *ptr);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock.h"
void __rwlock_init(rwlock_t *, char const *, struct lock_class_key *);


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_api_smp.h"
unsigned long _raw_read_lock_irqsave(rwlock_t *);


#line 26 
unsigned long _raw_write_lock_irqsave(rwlock_t *);


#line 37 
void _raw_read_unlock_irqrestore(rwlock_t *, unsigned long);


#line 40 
void _raw_write_unlock_irqrestore(rwlock_t *, unsigned long);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 444 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 445 
  return;
}


#line 474 
static void ldv_spin_unlock_irqrestore_74(spinlock_t *lock, unsigned long flags);


#line 478 
static void ldv_spin_unlock_irqrestore_76(spinlock_t *lock, unsigned long flags);


#line 482 
static void ldv_spin_unlock_irqrestore_78(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ptp.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_73(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_75(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_77(spinlock_t *ldv_func_arg1);


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec const *ts)
{
  s64 __retres;
  
#line 193 
  __retres = (long long)ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
  
#line 193 
  return __retres;
}


#line 215 
struct timespec ns_to_timespec(s64 const);


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns)
{
  
#line 285 
  ktime_t const ktime_zero = {.tv64 = 0LL};
  
#line 287 
  ktime_t __constr_expr_17 = {.tv64 = (long long)((unsigned long long)ktime_zero.tv64 + ns)};
  
#line 287 
  return __constr_expr_17;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
ktime_t ktime_get_with_offset(enum tk_offsets);


#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
__inline static ktime_t ktime_get_real(void)
{
  ktime_t tmp;
  
#line 172 
  tmp = ktime_get_with_offset((enum tk_offsets)TK_OFFS_REAL);
  
#line 172 
  return tmp;
}


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 652 
unsigned long _copy_to_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 664 
void copy_to_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 677 
void __copy_to_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void const *from, unsigned long n)
{
  
#line 730 
  int sz = -1;
  
#line 732 
  __might_fault("./arch/x86/include/asm/uaccess.h",732);
  
#line 735 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 736 
                                                                    n = _copy_to_user(to,from,(unsigned int)n);
  else 
    
#line 737 
    if (0 != 0) 
#line 738 
                copy_to_user_overflow(); else 
#line 740 
                                              __copy_to_user_overflow();
  
#line 742 
  return n;
}


#line 1331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list)
{
  struct sk_buff *tmp;
  
#line 1333 
  tmp = (struct sk_buff *)list;
  
#line 1333 
  list->next = tmp;
  
#line 1333 
  list->prev = tmp;
  
#line 1334 
  list->qlen = 0U;
  
#line 1335 
  return;
}


#line 1345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_queue_head_init(struct sk_buff_head *list)
{
  
#line 1347 
  spinlock_check(& list->lock);
  {
    struct lock_class_key __key;
    
#line 1347 
    __raw_spin_lock_init(& list->lock.__anonCompField_spinlock_18.rlock,"&(&list->lock)->rlock",& __key);
  }
  
#line 1348 
  __skb_queue_head_init(list);
  
#line 1349 
  return;
}


#line 1366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_insert(struct sk_buff *newsk, struct sk_buff *prev, struct sk_buff *next, struct sk_buff_head *list)
{
  struct sk_buff *tmp;
  
#line 1370 
  newsk->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = next;
  
#line 1371 
  newsk->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = prev;
  
#line 1372 
  tmp = newsk;
  
#line 1372 
  prev->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = tmp;
  
#line 1372 
  next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = tmp;
  
#line 1373 
  list->qlen += 1U;
  
#line 1374 
  return;
}


#line 1474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_before(struct sk_buff_head *list, struct sk_buff *next, struct sk_buff *newsk)
{
  
#line 1478 
  __skb_insert(newsk,next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev,next,list);
  
#line 1479 
  return;
}


#line 1509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
  
#line 1512 
  __skb_queue_before(list,(struct sk_buff *)list,newsk);
  
#line 1513 
  return;
}


#line 1520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
{
  struct sk_buff *next;
  struct sk_buff *prev;
  struct sk_buff *tmp;
  
#line 1524 
  list->qlen -= 1U;
  
#line 1525 
  next = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next;
  
#line 1526 
  prev = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev;
  
#line 1527 
  tmp = (struct sk_buff *)0;
  
#line 1527 
  skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = tmp;
  
#line 1527 
  skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = tmp;
  
#line 1528 
  next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = prev;
  
#line 1529 
  prev->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = next;
  
#line 1530 
  return;
}


#line 2861 
struct sk_buff *skb_clone_sk(struct sk_buff *);


#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock *ptp_clock_register(struct ptp_clock_info *, struct device *);


#line 133 
int ptp_clock_unregister(struct ptp_clock *);


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
void fm10k_systime_to_hwtstamp(struct fm10k_intfc *interface, struct skb_shared_hwtstamps *hwtstamp, u64 systime)
{
  unsigned long flags;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 34 
  flags = _raw_read_lock_irqsave(& interface->systime_lock);
  
#line 35 
  systime = (unsigned long long)interface->ptp_adjust + systime;
  {
    unsigned long __dummy_0;
    unsigned long __dummy2_0;
    
  }
  
#line 36 
  _raw_read_unlock_irqrestore(& interface->systime_lock,flags);
  
#line 38 
  hwtstamp->hwtstamp = ns_to_ktime(systime);
  
#line 39 
  return;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static struct sk_buff *fm10k_ts_tx_skb(struct fm10k_intfc *interface, __le16 dglort)
{
  struct sk_buff *__retres;
  struct sk_buff *skb;
  
#line 44 
  struct sk_buff_head *list = & interface->ts_tx_skb_queue;
  
#line 47 
  skb = list->next;
  
#line 47 
  goto ldv_47097;
  ldv_47096: 
#line 48 
  ;
  
#line 48 
  if ((int)((struct fm10k_cb *)(& skb->cb))->fi.w.dglort == (int)dglort) {
    
#line 49 
    __retres = skb;
    
#line 49 
    goto return_label;
  }
  else ;
  
#line 47 
  skb = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next;
  ldv_47097: 
#line 48 
  ;
  
#line 47 
  if (skb != (struct sk_buff *)list) 
#line 49 
                                     goto ldv_47096; else 
#line 52 
                                                          goto ldv_47098;
  ldv_47098: 
#line 53 
  ;
  
#line 52 
  __retres = (struct sk_buff *)0;
  return_label: 
#line 52 
                return __retres;
}


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
void fm10k_ts_tx_enqueue(struct fm10k_intfc *interface, struct sk_buff *skb)
{
  struct sk_buff *clone;
  unsigned long flags;
  
#line 57 
  struct sk_buff_head *list = & interface->ts_tx_skb_queue;
  
#line 62 
  clone = skb_clone_sk(skb);
  
#line 63 
  if (clone == (struct sk_buff *)0) 
#line 64 
                                    goto return_label; else ;
  
#line 66 
  ((struct fm10k_cb *)(& clone->cb))->__anonCompField_fm10k_cb_122.ts_tx_timeout = jiffies + 3750UL;
  
#line 67 
  ldv___ldv_spin_lock_73(& list->lock);
  
#line 72 
  skb = fm10k_ts_tx_skb(interface,(unsigned short)((int)((struct fm10k_cb *)(& clone->cb))->fi.w.dglort));
  
#line 73 
  if (skb == (struct sk_buff *)0) {
    unsigned char *tmp;
    unsigned char *tmp_0;
    
#line 74 
    tmp = skb_end_pointer((struct sk_buff const *)clone);
    
#line 74 
    tmp_0 = skb_end_pointer((struct sk_buff const *)clone);
    
#line 74 
    ((struct skb_shared_info *)tmp)->tx_flags = (unsigned char)((unsigned int)((struct skb_shared_info *)tmp_0)->tx_flags | 4U);
    
#line 75 
    __skb_queue_tail(list,clone);
  }
  else ;
  
#line 78 
  ldv_spin_unlock_irqrestore_74(& list->lock,flags);
  
#line 81 
  if (skb != (struct sk_buff *)0) 
#line 82 
                                  consume_skb(clone); else ;
  return_label: 
#line 83 
                return;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
void fm10k_ts_tx_hwtstamp(struct fm10k_intfc *interface, __le16 dglort, u64 systime)
{
  struct skb_shared_hwtstamps shhwtstamps;
  struct sk_buff *skb;
  unsigned long flags;
  
#line 89 
  struct sk_buff_head *list = & interface->ts_tx_skb_queue;
  
#line 93 
  ldv___ldv_spin_lock_75(& list->lock);
  
#line 96 
  skb = fm10k_ts_tx_skb(interface,(unsigned short)((int)dglort));
  
#line 97 
  if (skb != (struct sk_buff *)0) 
#line 98 
                                  __skb_unlink(skb,list); else ;
  
#line 100 
  ldv_spin_unlock_irqrestore_76(& list->lock,flags);
  
#line 103 
  if (skb == (struct sk_buff *)0) 
#line 104 
                                  goto return_label; else ;
  
#line 107 
  fm10k_systime_to_hwtstamp(interface,& shhwtstamps,systime);
  
#line 108 
  skb_tstamp_tx(skb,& shhwtstamps);
  
#line 109 
  dev_kfree_skb_any(skb);
  return_label: 
#line 110 
                return;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
void fm10k_ts_tx_subtask(struct fm10k_intfc *interface)
{
  struct sk_buff *skb;
  struct sk_buff *tmp;
  unsigned long flags;
  int tmp_0;
  int tmp_2;
  
#line 114 
  struct sk_buff_head *list = & interface->ts_tx_skb_queue;
  
#line 119 
  tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& interface->state));
  
#line 119 
  if (tmp_0 != 0) 
#line 121 
                  goto return_label;
  else {
    int tmp_1;
    
#line 119 
    tmp_1 = constant_test_bit(0L,(unsigned long const volatile *)(& interface->state));
    
#line 119 
    if (tmp_1 != 0) 
#line 121 
                    goto return_label; else ;
  }
  
#line 123 
  ldv___ldv_spin_lock_77(& list->lock);
  
#line 126 
  skb = list->next;
  
#line 126 
  tmp = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next;
  
#line 126 
  goto ldv_47130;
  ldv_47129: 
#line 127 
  ;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
#line 127 
    tmp_2 = 1;
  }
  
#line 127 
  if (tmp_2 == 0) 
#line 127 
                  goto _LOR;
  else {
    int tmp_3;
    {
      unsigned long __dummy_0;
      unsigned long volatile __dummy2_0;
      
#line 127 
      tmp_3 = 1;
    }
    
#line 127 
    if (tmp_3 == 0) 
#line 127 
                    goto _LOR;
    else 
      
#line 127 
      if ((long)(jiffies - ((struct fm10k_cb *)(& skb->cb))->__anonCompField_fm10k_cb_122.ts_tx_timeout) >= 0L) 
        _LOR: 
#line 128 
              goto ldv_47128; else ;
  }
  
#line 129 
  __skb_unlink(skb,list);
  
#line 130 
  kfree_skb(skb);
  
#line 131 
  interface->tx_hwtstamp_timeouts += 1U;
  ldv_47128: 
#line 132 
  ;
  
#line 126 
  skb = tmp;
  
#line 126 
  tmp = skb->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next;
  ldv_47130: 
#line 127 
  ;
  
#line 126 
  if (skb != (struct sk_buff *)list) 
#line 128 
                                     goto ldv_47129; else 
#line 131 
                                                          goto ldv_47131;
  ldv_47131: 
#line 132 
  ;
  
#line 134 
  ldv_spin_unlock_irqrestore_78(& list->lock,flags);
  return_label: 
#line 135 
                return;
}


#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static u64 fm10k_systime_read(struct fm10k_intfc *interface)
{
  u64 tmp;
  
#line 139 
  struct fm10k_hw *hw = & interface->hw;
  
#line 141 
  tmp = (*(hw->mac.ops.read_systime))(hw);
  
#line 141 
  return tmp;
}


#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
void fm10k_ts_reset(struct fm10k_intfc *interface)
{
  ktime_t tmp;
  unsigned long flags;
  u64 tmp_0;
  
#line 146 
  tmp = ktime_get_real();
  
#line 146 
  s64 ns = tmp.tv64;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 150 
  flags = _raw_write_lock_irqsave(& interface->systime_lock);
  
#line 151 
  tmp_0 = fm10k_systime_read(interface);
  
#line 151 
  interface->ptp_adjust = (long long)(tmp_0 - (unsigned long long)ns);
  {
    unsigned long __dummy_0;
    unsigned long __dummy2_0;
    
  }
  
#line 152 
  _raw_write_unlock_irqrestore(& interface->systime_lock,flags);
  
#line 153 
  return;
}


#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
void fm10k_ts_init(struct fm10k_intfc *interface)
{
  {
    struct lock_class_key __key;
    
#line 158 
    __rwlock_init(& interface->systime_lock,"&interface->systime_lock",& __key);
  }
  
#line 161 
  skb_queue_head_init(& interface->ts_tx_skb_queue);
  
#line 164 
  fm10k_ts_reset(interface);
  
#line 165 
  return;
}


#line 176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
int fm10k_get_ts_config(struct net_device *netdev, struct ifreq *ifr)
{
  int tmp_1;
  unsigned long tmp_0;
  
#line 178 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 179 
  struct hwtstamp_config *config = & interface->ts_config;
  
#line 182 
  tmp_0 = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)config,12UL);
  
#line 182 
  if (tmp_0 != 0UL) 
#line 182 
                    tmp_1 = -14; else 
#line 182 
                                      tmp_1 = 0;
  
#line 182 
  return tmp_1;
}


#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
int fm10k_set_ts_config(struct net_device *netdev, struct ifreq *ifr)
{
  int __retres;
  struct hwtstamp_config ts_config;
  unsigned long tmp_0;
  int tmp_2;
  unsigned long tmp_1;
  
#line 209 
  struct fm10k_intfc *interface = netdev_priv((struct net_device const *)netdev);
  
#line 212 
  tmp_0 = copy_from_user((void *)(& ts_config),(void const *)ifr->ifr_ifru.ifru_data,12UL);
  
#line 212 
  if (tmp_0 != 0UL) {
    
#line 213 
    __retres = -14;
    
#line 213 
    goto return_label;
  }
  else ;
  
#line 216 
  if (ts_config.flags != 0) {
    
#line 217 
    __retres = -22;
    
#line 217 
    goto return_label;
  }
  else ;
  
#line 219 
  switch (ts_config.tx_type) {
    case 0: 
#line 220 
    ;
    
#line 221 
    goto ldv_47164;
    case 1: 
#line 222 
    ;
    
#line 224 
    goto ldv_47164;
    default: 
#line 225 
    ;
    
#line 226 
    __retres = -34;
    
#line 226 
    goto return_label;
  }
  ldv_47164: 
#line 229 
  ;
  
#line 229 
  switch (ts_config.rx_filter) {
    case 0: 
#line 230 
    ;
    
#line 231 
    interface->flags &= 4294967287U;
    
#line 232 
    goto ldv_47168;
    case 3: 
#line 233 
    ;
    case 4: 
#line 234 
    ;
    case 5: 
#line 235 
    ;
    case 6: 
#line 236 
    ;
    case 7: 
#line 237 
    ;
    case 8: 
#line 238 
    ;
    case 9: 
#line 239 
    ;
    case 10: 
#line 240 
    ;
    case 11: 
#line 241 
    ;
    case 12: 
#line 242 
    ;
    case 13: 
#line 243 
    ;
    case 14: 
#line 244 
    ;
    case 1: 
#line 245 
    ;
    
#line 246 
    interface->flags |= 8U;
    
#line 247 
    ts_config.rx_filter = 1;
    
#line 248 
    goto ldv_47168;
    default: 
#line 249 
    ;
    
#line 250 
    __retres = -34;
    
#line 250 
    goto return_label;
  }
  ldv_47168: 
#line 254 
  ;
  
#line 254 
  interface->ts_config = ts_config;
  
#line 257 
  tmp_1 = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)(& ts_config),12UL);
  
#line 257 
  if (tmp_1 != 0UL) 
#line 257 
                    tmp_2 = -14; else 
#line 257 
                                      tmp_2 = 0;
  
#line 257 
  __retres = tmp_2;
  return_label: 
#line 257 
                return __retres;
}


#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static int fm10k_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
{
  struct fm10k_intfc *interface;
  struct fm10k_hw *hw;
  int err;
  struct fm10k_intfc *tmp;
  int tmp_0;
  {
    
#line 266 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 266 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709532816U;
  }
  
#line 266 
  interface = tmp;
  
#line 267 
  hw = & interface->hw;
  
#line 269 
  err = (*(hw->mac.ops.adjust_systime))(hw,ppb);
  
#line 272 
  if (err != -2) 
#line 272 
                 tmp_0 = err; else 
#line 272 
                                   tmp_0 = -34;
  
#line 272 
  return tmp_0;
}


#line 275  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static int fm10k_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
  int __retres;
  struct fm10k_intfc *interface;
  unsigned long flags;
  struct fm10k_intfc *tmp;
  {
    
#line 280 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 280 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709532816U;
  }
  
#line 280 
  interface = tmp;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 282 
  flags = _raw_write_lock_irqsave(& interface->systime_lock);
  
#line 283 
  interface->ptp_adjust += delta;
  {
    unsigned long __dummy_0;
    unsigned long __dummy2_0;
    
  }
  
#line 284 
  _raw_write_unlock_irqrestore(& interface->systime_lock,flags);
  
#line 286 
  __retres = 0;
  
#line 286 
  return __retres;
}


#line 289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static int fm10k_ptp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)
{
  int __retres;
  struct fm10k_intfc *interface;
  unsigned long flags;
  u64 now;
  struct fm10k_intfc *tmp;
  u64 tmp_0;
  {
    
#line 295 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 295 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709532816U;
  }
  
#line 295 
  interface = tmp;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 297 
  flags = _raw_read_lock_irqsave(& interface->systime_lock);
  
#line 298 
  tmp_0 = fm10k_systime_read(interface);
  
#line 298 
  now = tmp_0 + (unsigned long long)interface->ptp_adjust;
  {
    unsigned long __dummy_0;
    unsigned long __dummy2_0;
    
  }
  
#line 299 
  _raw_read_unlock_irqrestore(& interface->systime_lock,flags);
  
#line 301 
  *ts = ns_to_timespec((long long)now);
  
#line 303 
  __retres = 0;
  
#line 303 
  return __retres;
}


#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static int fm10k_ptp_settime(struct ptp_clock_info *ptp, struct timespec const *ts)
{
  int __retres;
  struct fm10k_intfc *interface;
  unsigned long flags;
  s64 tmp;
  struct fm10k_intfc *tmp_0;
  u64 tmp_1;
  
#line 311 
  tmp = timespec_to_ns(ts);
  
#line 311 
  u64 ns = (unsigned long long)tmp;
  {
    
#line 313 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 313 
    tmp_0 = (struct fm10k_intfc *)__mptr + 18446744073709532816U;
  }
  
#line 313 
  interface = tmp_0;
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 315 
  flags = _raw_write_lock_irqsave(& interface->systime_lock);
  
#line 316 
  tmp_1 = fm10k_systime_read(interface);
  
#line 316 
  interface->ptp_adjust = (long long)(tmp_1 - ns);
  {
    unsigned long __dummy_0;
    unsigned long __dummy2_0;
    
  }
  
#line 317 
  _raw_write_unlock_irqrestore(& interface->systime_lock,flags);
  
#line 319 
  __retres = 0;
  
#line 319 
  return __retres;
}


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static int fm10k_ptp_enable(struct ptp_clock_info *ptp, struct ptp_clock_request *rq, int on)
{
  int __retres;
  struct fm10k_intfc *interface;
  struct fm10k_hw *hw;
  u64 period;
  u32 step;
  struct fm10k_intfc *tmp;
  u32 tmp_0;
  
#line 326 
  struct ptp_clock_time *t = & rq->__anonCompField_ptp_clock_request_95.perout.period;
  
#line 333 
  if (rq->type != (unsigned int)PTP_CLK_REQ_PEROUT) {
    
#line 334 
    __retres = -22;
    
#line 334 
    goto return_label;
  }
  else ;
  
#line 337 
  if (rq->__anonCompField_ptp_clock_request_95.perout.index >= (unsigned int)ptp->n_per_out) {
    
#line 338 
    __retres = -22;
    
#line 338 
    goto return_label;
  }
  else ;
  
#line 346 
  if (t->sec > (__s64)4U) {
    
#line 347 
    __retres = -34;
    
#line 347 
    goto return_label;
  }
  else ;
  {
    
#line 349 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 349 
    tmp = (struct fm10k_intfc *)__mptr + 18446744073709532816U;
  }
  
#line 349 
  interface = tmp;
  
#line 350 
  hw = & interface->hw;
  
#line 353 
  if (hw->sw_addr == (u32 *)0U) {
    
#line 354 
    __retres = -524;
    
#line 354 
    goto return_label;
  }
  else ;
  
#line 357 
  period = (unsigned long long)(t->sec * 1000000000LL + (long long)t->nsec);
  
#line 360 
  tmp_0 = fm10k_read_reg(hw,14360);
  
#line 360 
  step = (tmp_0 & 15U) * 2U;
  
#line 364 
  if ((period != 0ULL && (unsigned long long)step > period) || period > 4294967295ULL) {
    
#line 365 
    __retres = -34;
    
#line 365 
    goto return_label;
  }
  else ;
  {
    u32 * volatile *tmp_1;
    {
      
#line 368 
      u32 *__var = (u32 *)0U;
      
#line 368 
      tmp_1 = (u32 * volatile *)(& hw->sw_addr);
    }
    
#line 368 
    u32 *sw_addr = *tmp_1;
    
#line 368 
    if ((long)(sw_addr == (u32 *)0U) == 0L) 
#line 368 
                                            writel((unsigned int)period,(void volatile *)(sw_addr + (rq->__anonCompField_ptp_clock_request_95.perout.index + 8786U))); else ;
  }
  
#line 371 
  __retres = 0;
  return_label: 
#line 371 
                return __retres;
}


#line 374  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static struct ptp_pin_desc fm10k_ptp_pd[2U] = {{.name = {(char)'I', (char)'E', (char)'E', (char)'E', (char)'1', (char)'5', (char)'8', (char)'8', (char)'_', (char)'P', (char)'U', (char)'L', (char)'S', (char)'E', (char)'0', (char)'\000'}, .index = 0U, .func = 2U, .chan = 0U, .rsv = {0U, 0U, 0U, 0U, 0U}}, {.name = {(char)'I', (char)'E', (char)'E', (char)'E', (char)'1', (char)'5', (char)'8', (char)'8', (char)'_', (char)'P', (char)'U', (char)'L', (char)'S', (char)'E', (char)'1', (char)'\000'}, .index = 1U, .func = 2U, .chan = 1U, .rsv = {0U, 0U, 0U, 0U, 0U}}};

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
static int fm10k_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin, enum ptp_pin_function func, unsigned int chan)
{
  int __retres;
  
#line 393 
  if ((unsigned int)ptp->n_pins <= pin || ptp->pin_config == (struct ptp_pin_desc *)0) {
    
#line 394 
    __retres = -22;
    
#line 394 
    goto return_label;
  }
  else ;
  
#line 397 
  if ((ptp->pin_config + pin)->chan != chan) {
    
#line 398 
    __retres = -22;
    
#line 398 
    goto return_label;
  }
  else ;
  
#line 401 
  if ((ptp->pin_config + pin)->func != (unsigned int)func) {
    
#line 402 
    __retres = -22;
    
#line 402 
    goto return_label;
  }
  else ;
  
#line 404 
  __retres = 0;
  return_label: 
#line 404 
                return __retres;
}


#line 407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
void fm10k_ptp_register(struct fm10k_intfc *interface)
{
  struct ptp_clock *ptp_clock;
  bool tmp;
  
#line 409 
  struct ptp_clock_info *ptp_caps = & interface->ptp_caps;
  
#line 410 
  struct device *dev = & (interface->pdev)->dev;
  
#line 413 
  snprintf((char *)(& ptp_caps->name),16UL,"%s",(char *)(& (interface->netdev)->name));
  
#line 415 
  ptp_caps->owner = & __this_module;
  
#line 421 
  ptp_caps->max_adj = 976562;
  
#line 422 
  ptp_caps->adjfreq = & fm10k_ptp_adjfreq;
  
#line 423 
  ptp_caps->adjtime = & fm10k_ptp_adjtime;
  
#line 424 
  ptp_caps->gettime64 = & fm10k_ptp_gettime;
  
#line 425 
  ptp_caps->settime64 = & fm10k_ptp_settime;
  
#line 428 
  if (interface->sw_addr != (u32 *)0U) {
    
#line 430 
    ptp_caps->n_per_out = 2;
    
#line 431 
    ptp_caps->enable = & fm10k_ptp_enable;
    
#line 434 
    ptp_caps->verify = & fm10k_ptp_verify;
    
#line 435 
    ptp_caps->n_pins = 2;
    
#line 436 
    ptp_caps->pin_config = (struct ptp_pin_desc *)(& fm10k_ptp_pd);
  }
  else ;
  
#line 439 
  ptp_clock = ptp_clock_register(ptp_caps,dev);
  
#line 440 
  tmp = IS_ERR((void const *)ptp_clock);
  
#line 440 
  if ((int)tmp != 0) {
    
#line 441 
    ptp_clock = (struct ptp_clock *)0;
    
#line 442 
    dev_err((struct device const *)dev,"ptp_clock_register failed\n");
  }
  else 
#line 444 
       _dev_info((struct device const *)dev,"registered PHC device %s\n",(char *)(& ptp_caps->name));
  
#line 447 
  interface->ptp_clock = ptp_clock;
  
#line 448 
  return;
}


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/fm10k/fm10k_ptp.c"
void fm10k_ptp_unregister(struct fm10k_intfc *interface)
{
  
#line 452 
  struct ptp_clock *ptp_clock = interface->ptp_clock;
  
#line 453 
  struct device *dev = & (interface->pdev)->dev;
  
#line 455 
  if (ptp_clock == (struct ptp_clock *)0) 
#line 456 
                                          goto return_label; else ;
  
#line 458 
  interface->ptp_clock = (struct ptp_clock *)0;
  
#line 460 
  ptp_clock_unregister(ptp_clock);
  
#line 461 
  _dev_info((struct device const *)dev,"removed PHC %s\n",(char *)(& interface->ptp_caps.name));
  return_label: 
#line 462 
                return;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ptp.c.aux"
static bool IS_ERR(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 88 
  ret = ldv_is_err(ptr);
  
#line 89 
  __retres = (_Bool)(ret != 0L);
  
#line 89 
  return __retres;
}


#line 748  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ptp.c.aux"
static void ldv___ldv_spin_lock_73(spinlock_t *ldv_func_arg1)
{
  
#line 752 
  ldv_spin_model_lock((char *)"lock_of_sk_buff_head");
  
#line 754 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 755 
  return;
}


#line 758  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ptp.c.aux"
static void ldv_spin_unlock_irqrestore_74(spinlock_t *lock, unsigned long flags)
{
  
#line 762 
  ldv_spin_model_unlock((char *)"lock_of_sk_buff_head");
  
#line 764 
  spin_unlock_irqrestore(lock,flags);
  
#line 765 
  return;
}


#line 768  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ptp.c.aux"
static void ldv___ldv_spin_lock_75(spinlock_t *ldv_func_arg1)
{
  
#line 772 
  ldv_spin_model_lock((char *)"lock_of_sk_buff_head");
  
#line 774 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 775 
  return;
}


#line 778  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ptp.c.aux"
static void ldv_spin_unlock_irqrestore_76(spinlock_t *lock, unsigned long flags)
{
  
#line 782 
  ldv_spin_model_unlock((char *)"lock_of_sk_buff_head");
  
#line 784 
  spin_unlock_irqrestore(lock,flags);
  
#line 785 
  return;
}


#line 788  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ptp.c.aux"
static void ldv___ldv_spin_lock_77(spinlock_t *ldv_func_arg1)
{
  
#line 792 
  ldv_spin_model_lock((char *)"lock_of_sk_buff_head");
  
#line 794 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 795 
  return;
}


#line 798  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/weaver/.tmp_fm10k_ptp.c.aux"
static void ldv_spin_unlock_irqrestore_78(spinlock_t *lock, unsigned long flags)
{
  
#line 802 
  ldv_spin_model_unlock((char *)"lock_of_sk_buff_head");
  
#line 804 
  spin_unlock_irqrestore(lock,flags);
  
#line 805 
  return;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err_or_null(void const *ptr);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 97 
void ldv_failed_register_netdev(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
__inline static void *ERR_PTR_0(long error)
{
  void *__retres;
  
#line 25 
  __retres = (void *)error;
  
#line 25 
  return __retres;
}


#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0);


#line 135 
void *ldv_character_driver_scenario_15(void *arg0);


#line 138 
void *ldv_interrupt_scenario_16(void *arg0);


#line 139 
void *ldv_traverse_kernel_items_scenario_22(void *arg0);


#line 140 
void *ldv_interrupt_scenario_21(void *arg0);


#line 141 
void ldv_dispatch_register_9_1(struct seq_file *arg0, struct seq_operations *arg1);


#line 142 
void ldv_dispatch_instance_register_3_3(struct timer_list *arg0);


#line 143 
void *ldv_interrupt_scenario_17(void *arg0);


#line 144 
void *ldv_traverse_kernel_items_scenario_23(void *arg0);


#line 145 
void ldv_dispatch_register_8_4(struct net_device *arg0);


#line 147 
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0);


#line 148 
void *ldv_random_allocationless_scenario_20(void *arg0);


#line 149 
void *ldv_initialization_1(void *arg0);


#line 152 
int main(void);


#line 153 
void ldv_dispatch_register_13_3(struct file_operations *arg0);


#line 155 
void *ldv_timer_scenario_19(void *arg0);


#line 156 
void ldv_dispatch_register_10_3(struct pci_driver *arg0);


#line 157 
void ldv_dispatch_irq_deregister_6_1(int arg0);


#line 160 
void ldv_dispatch_instance_deregister_12_1(struct timer_list *arg0);


#line 161 
void ldv_dispatch_irq_register_11_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 162 
void *ldv_pci_scenario_18(void *arg0);


#line 169  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_17;

#line 170  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 171  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_21;

#line 172  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 173  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_19;

#line 174  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_22;

#line 175  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_18;

#line 176  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_20;

#line 177  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_23;

#line 181  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_20 *cf_arg_20;
  int tmp;
  
#line 184 
  tmp = ldv_undef_int();
  
#line 184 
  switch (tmp) {
    case 0: 
#line 185 
    ;
    
#line 186 
    ret = pthread_join(ldv_thread_20,(void **)0);
    
#line 187 
    __VERIFIER_assume(ret == 0);
    
#line 188 
    goto ldv_45601;
    default: 
#line 190 
    ;
    
#line 190 
    __VERIFIER_assume(0);
  }
  ldv_45601: 
#line 191 
  ;
  
#line 192 
  return;
}


#line 196  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_del_timer_sync(struct timer_list *arg0)
{
  int __retres;
  struct timer_list *ldv_12_timer_list;
  
#line 202 
  ldv_12_timer_list = arg0;
  
#line 206 
  ldv_dispatch_instance_deregister_12_1(ldv_12_timer_list);
  
#line 207 
  ;
  
#line 207 
  __retres = 0;
  
#line 207 
  return __retres;
}


#line 215  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_15(void *arg0)
{
  void *__retres;
  struct file *ldv_15_resource_1;
  int ldv_15_ldv_param_2_3;
  long long ldv_15_ldv_param_1_2;
  char *ldv_15_ldv_param_1_4;
  struct inode *ldv_15_resource_0;
  unsigned long ldv_15_size_cnt;
  long long *ldv_15_ldv_param_3_5;
  char *ldv_15_ldv_param_1_6;
  long long *ldv_15_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 226 
  struct file_operations *ldv_15_container = ldv_emg_alias_fm10k_dbg_desc_fops_2;
  
#line 227 
  int ldv_15_ret = ldv_undef_int();
  
#line 230 
  struct ldv_struct_character_driver_scenario_15 *data = (struct ldv_struct_character_driver_scenario_15 *)arg0;
  
#line 234 
  ldv_15_ret = ldv_undef_int();
  
#line 237 
  if (data != (struct ldv_struct_character_driver_scenario_15 *)0) {
    
#line 238 
    ldv_15_container = data->arg0;
    
#line 239 
    ldv_free((void *)data);
  }
  else ;
  
#line 244 
  ldv_15_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 245 
  tmp_1 = ldv_undef_int();
  
#line 245 
  ldv_15_size_cnt = (unsigned long)tmp_1;
  
#line 252 
  goto ldv_main_15;
  
#line 254 
  __retres = (void *)0;
  
#line 254 
  goto return_label;
  ldv_main_15: 
#line 257 
  ;
  
#line 260 
  tmp_3 = ldv_undef_int();
  
#line 260 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 263 
    ldv_15_ret = ldv_emg_wrapper_fm10k_dbg_desc_open_5(ldv_15_resource_0,ldv_15_resource_1);
    
#line 265 
    ldv_15_ret = ldv_filter_err_code(ldv_15_ret);
    
#line 268 
    tmp_2 = ldv_undef_int();
    
#line 268 
    if (tmp_2 != 0) {
      
#line 270 
      __VERIFIER_assume(ldv_15_ret == 0);
      
#line 277 
      goto ldv_call_15;
    }
    else {
      
#line 281 
      __VERIFIER_assume(ldv_15_ret != 0);
      
#line 288 
      goto ldv_main_15;
    }
  }
  else {
    
#line 293 
    ldv_free((void *)ldv_15_resource_0);
    
#line 301 
    __retres = (void *)0;
    
#line 301 
    goto return_label;
  }
  
#line 304 
  __retres = (void *)0;
  
#line 304 
  goto return_label;
  ldv_call_15: 
#line 307 
  ;
  
#line 310 
  tmp_4 = ldv_undef_int();
  
#line 310 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 311 
    ;
    
#line 313 
    ldv_15_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 314 
    ldv_15_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 318 
    if (ldv_15_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 324 
      __VERIFIER_assume(ldv_15_size_cnt <= 2147479552UL);
      
#line 326 
      (*(ldv_15_container->write))(ldv_15_resource_1,(char const *)ldv_15_ldv_param_1_6,ldv_15_size_cnt,ldv_15_ldv_param_3_7);
    }
    else ;
    
#line 331 
    ldv_free((void *)ldv_15_ldv_param_3_7);
    
#line 332 
    ldv_free((void *)ldv_15_ldv_param_1_6);
    
#line 339 
    goto ldv_call_15;
    case 2: 
#line 342 
    ;
    
#line 345 
    (*ldv_emg_alias_seq_release_4)(ldv_15_resource_0,ldv_15_resource_1);
    
#line 352 
    goto ldv_main_15;
    case 3: 
#line 355 
    ;
    
#line 359 
    tmp_9 = ldv_undef_int();
    
#line 359 
    if (tmp_9 != 0) 
#line 362 
                    (*ldv_emg_alias_seq_lseek_2)(ldv_15_resource_1,ldv_15_ldv_param_1_2,ldv_15_ldv_param_2_3);
    else {
      
#line 368 
      ldv_15_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 369 
      ldv_15_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 374 
      (*ldv_emg_alias_seq_read_3)(ldv_15_resource_1,ldv_15_ldv_param_1_4,ldv_15_size_cnt,ldv_15_ldv_param_3_5);
      
#line 378 
      ldv_free((void *)ldv_15_ldv_param_3_5);
      
#line 379 
      ldv_free((void *)ldv_15_ldv_param_1_4);
    }
    
#line 383 
    goto ldv_45627;
    default: 
#line 385 
    ;
    
#line 385 
    __VERIFIER_assume(0);
  }
  ldv_45627: 
#line 394 
  ;
  
#line 394 
  goto ldv_call_15;
  
#line 396 
  __retres = (void *)0;
  return_label: 
#line 396 
                return __retres;
}


#line 401  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 404 
  struct pci_driver *ldv_10_pci_driver = ldv_emg_alias_fm10k_driver_2;
  
#line 408 
  tmp_0 = ldv_undef_int();
  
#line 408 
  if (tmp_0 != 0) {
    
#line 410 
    ldv_10_pci_driver = arg0;
    
#line 414 
    ldv_dispatch_register_10_3(ldv_10_pci_driver);
    
#line 418 
    __retres = 0;
    
#line 418 
    goto return_label;
  }
  else {
    int tmp;
    
#line 425 
    tmp = ldv_undef_int_negative();
    
#line 425 
    __retres = tmp;
    
#line 425 
    goto return_label;
  }
  return_label: 
#line 408 
                return __retres;
}


#line 435  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4)
{
  struct dentry *__retres;
  struct dentry *ldv_13_dentry;
  int tmp_1;
  
#line 439 
  struct file_operations *ldv_13_file_operations = ldv_emg_alias_fm10k_dbg_desc_fops_2;
  
#line 443 
  tmp_1 = ldv_undef_int();
  
#line 443 
  if (tmp_1 != 0) {
    
#line 445 
    ldv_13_dentry = (struct dentry *)ldv_xmalloc_unknown_size(0UL);
    
#line 446 
    ldv_13_file_operations = arg4;
    
#line 450 
    ldv_dispatch_register_13_3(ldv_13_file_operations);
    
#line 454 
    __retres = ldv_13_dentry;
    
#line 454 
    goto return_label;
  }
  else {
    struct dentry *tmp_0;
    
#line 461 
    tmp_0 = (struct dentry *)ERR_PTR_0(-19L);
    
#line 461 
    __retres = tmp_0;
    
#line 461 
    goto return_label;
  }
  return_label: 
#line 443 
                return __retres;
}


#line 471  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_18 *cf_arg_18;
  int tmp;
  
#line 474 
  tmp = ldv_undef_int();
  
#line 474 
  switch (tmp) {
    case 0: 
#line 475 
    ;
    
#line 476 
    ret = pthread_join(ldv_thread_18,(void **)0);
    
#line 477 
    __VERIFIER_assume(ret == 0);
    
#line 478 
    goto ldv_45650;
    default: 
#line 480 
    ;
    
#line 480 
    __VERIFIER_assume(0);
  }
  ldv_45650: 
#line 481 
  ;
  
#line 482 
  return;
}


#line 486  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_traverse_kernel_items_scenario_22(void *arg0)
{
  void *__retres;
  void *ldv_22_ldv_param_1_2;
  long long *ldv_22_index;
  struct seq_file *ldv_22_seq_file;
  void *ldv_22_ldv_param_1_3;
  void *ldv_22_ldv_param_1_4;
  int tmp_2;
  int tmp_6;
  
#line 492 
  struct seq_operations *ldv_22_ops = ldv_emg_alias_fm10k_dbg_rx_desc_seq_ops_6;
  
#line 493 
  int ldv_22_show_ret = ldv_undef_int();
  
#line 496 
  void *ldv_22_ret = ldv_undef_ptr();
  
#line 498 
  struct ldv_struct_traverse_kernel_items_scenario_22 *data = (struct ldv_struct_traverse_kernel_items_scenario_22 *)arg0;
  
#line 502 
  ldv_22_show_ret = ldv_undef_int();
  
#line 505 
  if (data != (struct ldv_struct_traverse_kernel_items_scenario_22 *)0) {
    
#line 506 
    ldv_22_seq_file = data->arg0;
    
#line 507 
    ldv_22_ops = data->arg1;
    
#line 508 
    ldv_free((void *)data);
  }
  else ;
  
#line 513 
  ldv_22_index = (long long *)ldv_xmalloc_unknown_size(0UL);
  
#line 520 
  goto ldv_outer_loop_22;
  
#line 522 
  __retres = (void *)0;
  
#line 522 
  goto return_label;
  ldv_outer_loop_22: 
#line 525 
  ;
  
#line 528 
  tmp_2 = ldv_undef_int();
  
#line 528 
  if (tmp_2 != 0) {
    
#line 531 
    *ldv_22_index = 0LL;
    
#line 533 
    ldv_22_ret = ldv_emg_wrapper_fm10k_dbg_desc_seq_start_2(ldv_22_seq_file,ldv_22_index);
    
#line 540 
    goto ldv_inner_loop_22;
  }
  else {
    
#line 544 
    ldv_free((void *)ldv_22_index);
    
#line 552 
    __retres = (void *)0;
    
#line 552 
    goto return_label;
  }
  
#line 555 
  __retres = (void *)0;
  
#line 555 
  goto return_label;
  ldv_inner_loop_22: 
#line 558 
  ;
  
#line 561 
  tmp_6 = ldv_undef_int();
  
#line 561 
  if (tmp_6 != 0) {
    long tmp_3;
    int tmp_4;
    
#line 563 
    tmp_3 = ldv_is_err_or_null((void const *)ldv_22_ret);
    
#line 563 
    __VERIFIER_assume(tmp_3 == 0L);
    
#line 567 
    ldv_22_ldv_param_1_3 = ldv_xmalloc_unknown_size(0UL);
    
#line 572 
    ldv_22_show_ret = ldv_emg_wrapper_fm10k_dbg_rx_desc_seq_show_4(ldv_22_seq_file,ldv_22_ldv_param_1_3);
    
#line 576 
    ldv_free(ldv_22_ldv_param_1_3);
    
#line 579 
    tmp_4 = ldv_undef_int();
    
#line 579 
    if (tmp_4 != 0) {
      
#line 581 
      __VERIFIER_assume(ldv_22_show_ret >= 0);
      
#line 585 
      ldv_22_ldv_param_1_2 = ldv_xmalloc_unknown_size(0UL);
      
#line 590 
      ldv_22_ret = ldv_emg_wrapper_fm10k_dbg_desc_seq_next_3(ldv_22_seq_file,ldv_22_ldv_param_1_2,ldv_22_index);
      
#line 594 
      ldv_free(ldv_22_ldv_param_1_2);
      
#line 601 
      goto ldv_inner_loop_22;
    }
    else {
      
#line 605 
      ldv_22_ldv_param_1_4 = ldv_xmalloc_unknown_size(0UL);
      
#line 610 
      ldv_22_seq_file->index = *ldv_22_index;
      
#line 612 
      ldv_emg_wrapper_fm10k_dbg_desc_seq_stop_5(ldv_22_seq_file,ldv_22_ldv_param_1_4);
      
#line 614 
      ldv_22_seq_file->index = *ldv_22_index;
      
#line 618 
      ldv_free(ldv_22_ldv_param_1_4);
      
#line 625 
      goto ldv_outer_loop_22;
    }
  }
  else {
    long tmp_5;
    
#line 630 
    tmp_5 = ldv_is_err_or_null((void const *)ldv_22_ret);
    
#line 630 
    __VERIFIER_assume((int)tmp_5);
    
#line 634 
    ldv_22_ldv_param_1_4 = ldv_xmalloc_unknown_size(0UL);
    
#line 639 
    ldv_22_seq_file->index = *ldv_22_index;
    
#line 641 
    ldv_emg_wrapper_fm10k_dbg_desc_seq_stop_5(ldv_22_seq_file,ldv_22_ldv_param_1_4);
    
#line 643 
    ldv_22_seq_file->index = *ldv_22_index;
    
#line 647 
    ldv_free(ldv_22_ldv_param_1_4);
    
#line 654 
    goto ldv_outer_loop_22;
  }
  
#line 657 
  __retres = (void *)0;
  return_label: 
#line 657 
                return __retres;
}


#line 662  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_21(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_21_ret_val;
  int ldv_21_line;
  void *ldv_21_data;
  enum irqreturn (*ldv_21_thread)(int , void *);
  int tmp;
  
#line 668 
  enum irqreturn (*ldv_21_callback)(int , void *) = & ldv_emg_wrapper_fm10k_msix_mbx_vf_2;
  
#line 671 
  struct ldv_struct_interrupt_scenario_16 *data = (struct ldv_struct_interrupt_scenario_16 *)arg0;
  
#line 676 
  if (data != (struct ldv_struct_interrupt_scenario_16 *)0) {
    
#line 677 
    ldv_21_line = data->arg0;
    
#line 678 
    ldv_21_callback = data->arg1;
    
#line 679 
    ldv_21_thread = data->arg2;
    
#line 680 
    ldv_21_data = data->arg3;
    
#line 681 
    ldv_free((void *)data);
  }
  else ;
  
#line 687 
  ldv_switch_to_interrupt_context();
  
#line 689 
  ldv_21_ret_val = ldv_emg_wrapper_fm10k_msix_mbx_vf_2(ldv_21_line,ldv_21_data);
  
#line 691 
  ldv_switch_to_process_context();
  
#line 694 
  tmp = ldv_undef_int();
  
#line 694 
  if (tmp != 0) {
    
#line 696 
    __VERIFIER_assume(ldv_21_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 700 
    if (ldv_21_thread != (enum irqreturn (*)(int , void *))0) 
#line 702 
                                                              (*ldv_21_thread)(ldv_21_line,ldv_21_data); else ;
  }
  else 
#line 709 
       __VERIFIER_assume(ldv_21_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 718 
  __retres = (void *)0;
  
#line 718 
  goto return_label;
  
#line 720 
  __retres = (void *)0;
  return_label: 
#line 720 
                return __retres;
}


#line 725  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_9_1(struct seq_file *arg0, struct seq_operations *arg1)
{
  int ret;
  struct ldv_struct_traverse_kernel_items_scenario_22 *cf_arg_22;
  struct ldv_struct_traverse_kernel_items_scenario_22 *cf_arg_23;
  int tmp;
  
#line 729 
  tmp = ldv_undef_int();
  
#line 729 
  switch (tmp) {
    case 0: 
#line 730 
    ;
    
#line 731 
    cf_arg_22 = (struct ldv_struct_traverse_kernel_items_scenario_22 *)ldv_xmalloc(24UL);
    
#line 732 
    cf_arg_22->arg0 = arg0;
    
#line 733 
    cf_arg_22->arg1 = arg1;
    
#line 734 
    ret = pthread_create(& ldv_thread_22,(pthread_attr_t const *)0,& ldv_traverse_kernel_items_scenario_22,(void *)cf_arg_22);
    
#line 735 
    __VERIFIER_assume(ret == 0);
    
#line 736 
    goto ldv_45687;
    case 1: 
#line 738 
    ;
    
#line 739 
    cf_arg_23 = (struct ldv_struct_traverse_kernel_items_scenario_22 *)ldv_xmalloc(24UL);
    
#line 740 
    cf_arg_23->arg0 = arg0;
    
#line 741 
    cf_arg_23->arg1 = arg1;
    
#line 742 
    ret = pthread_create(& ldv_thread_23,(pthread_attr_t const *)0,& ldv_traverse_kernel_items_scenario_23,(void *)cf_arg_23);
    
#line 743 
    __VERIFIER_assume(ret == 0);
    
#line 744 
    goto ldv_45687;
    default: 
#line 746 
    ;
    
#line 746 
    __VERIFIER_assume(0);
  }
  ldv_45687: 
#line 747 
  ;
  
#line 748 
  return;
}


#line 752  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_10_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_18 *cf_arg_18;
  int tmp;
  
#line 755 
  tmp = ldv_undef_int();
  
#line 755 
  switch (tmp) {
    case 0: 
#line 756 
    ;
    
#line 757 
    cf_arg_18 = (struct ldv_struct_pci_scenario_18 *)ldv_xmalloc(16UL);
    
#line 758 
    cf_arg_18->arg0 = arg0;
    
#line 759 
    ret = pthread_create(& ldv_thread_18,(pthread_attr_t const *)0,& ldv_pci_scenario_18,(void *)cf_arg_18);
    
#line 760 
    __VERIFIER_assume(ret == 0);
    
#line 761 
    goto ldv_45696;
    default: 
#line 763 
    ;
    
#line 763 
    __VERIFIER_assume(0);
  }
  ldv_45696: 
#line 764 
  ;
  
#line 765 
  return;
}


#line 769  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_17(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_17_ret_val;
  int ldv_17_line;
  void *ldv_17_data;
  enum irqreturn (*ldv_17_thread)(int , void *);
  int tmp;
  
#line 775 
  enum irqreturn (*ldv_17_callback)(int , void *) = & ldv_emg_wrapper_fm10k_msix_mbx_pf_2;
  
#line 778 
  struct ldv_struct_interrupt_scenario_16 *data = (struct ldv_struct_interrupt_scenario_16 *)arg0;
  
#line 783 
  if (data != (struct ldv_struct_interrupt_scenario_16 *)0) {
    
#line 784 
    ldv_17_line = data->arg0;
    
#line 785 
    ldv_17_callback = data->arg1;
    
#line 786 
    ldv_17_thread = data->arg2;
    
#line 787 
    ldv_17_data = data->arg3;
    
#line 788 
    ldv_free((void *)data);
  }
  else ;
  
#line 794 
  ldv_switch_to_interrupt_context();
  
#line 796 
  ldv_17_ret_val = ldv_emg_wrapper_fm10k_msix_mbx_pf_2(ldv_17_line,ldv_17_data);
  
#line 798 
  ldv_switch_to_process_context();
  
#line 801 
  tmp = ldv_undef_int();
  
#line 801 
  if (tmp != 0) {
    
#line 803 
    __VERIFIER_assume(ldv_17_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 807 
    if (ldv_17_thread != (enum irqreturn (*)(int , void *))0) 
#line 809 
                                                              (*ldv_17_thread)(ldv_17_line,ldv_17_data); else ;
  }
  else 
#line 816 
       __VERIFIER_assume(ldv_17_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 825 
  __retres = (void *)0;
  
#line 825 
  goto return_label;
  
#line 827 
  __retres = (void *)0;
  return_label: 
#line 827 
                return __retres;
}


#line 832  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_traverse_kernel_items_scenario_23(void *arg0)
{
  void *__retres;
  void *ldv_23_ldv_param_1_2;
  long long *ldv_23_index;
  struct seq_file *ldv_23_seq_file;
  void *ldv_23_ldv_param_1_3;
  void *ldv_23_ldv_param_1_4;
  int tmp_2;
  int tmp_6;
  
#line 838 
  struct seq_operations *ldv_23_ops = ldv_emg_alias_fm10k_dbg_tx_desc_seq_ops_3;
  
#line 839 
  int ldv_23_show_ret = ldv_undef_int();
  
#line 842 
  void *ldv_23_ret = ldv_undef_ptr();
  
#line 844 
  struct ldv_struct_traverse_kernel_items_scenario_22 *data = (struct ldv_struct_traverse_kernel_items_scenario_22 *)arg0;
  
#line 848 
  ldv_23_show_ret = ldv_undef_int();
  
#line 851 
  if (data != (struct ldv_struct_traverse_kernel_items_scenario_22 *)0) {
    
#line 852 
    ldv_23_seq_file = data->arg0;
    
#line 853 
    ldv_23_ops = data->arg1;
    
#line 854 
    ldv_free((void *)data);
  }
  else ;
  
#line 859 
  ldv_23_index = (long long *)ldv_xmalloc_unknown_size(0UL);
  
#line 866 
  goto ldv_outer_loop_23;
  
#line 868 
  __retres = (void *)0;
  
#line 868 
  goto return_label;
  ldv_outer_loop_23: 
#line 871 
  ;
  
#line 874 
  tmp_2 = ldv_undef_int();
  
#line 874 
  if (tmp_2 != 0) {
    
#line 877 
    *ldv_23_index = 0LL;
    
#line 879 
    ldv_23_ret = ldv_emg_wrapper_fm10k_dbg_desc_seq_start_2(ldv_23_seq_file,ldv_23_index);
    
#line 886 
    goto ldv_inner_loop_23;
  }
  else {
    
#line 890 
    ldv_free((void *)ldv_23_index);
    
#line 898 
    __retres = (void *)0;
    
#line 898 
    goto return_label;
  }
  
#line 901 
  __retres = (void *)0;
  
#line 901 
  goto return_label;
  ldv_inner_loop_23: 
#line 904 
  ;
  
#line 907 
  tmp_6 = ldv_undef_int();
  
#line 907 
  if (tmp_6 != 0) {
    long tmp_3;
    int tmp_4;
    
#line 909 
    tmp_3 = ldv_is_err_or_null((void const *)ldv_23_ret);
    
#line 909 
    __VERIFIER_assume(tmp_3 == 0L);
    
#line 913 
    ldv_23_ldv_param_1_3 = ldv_xmalloc_unknown_size(0UL);
    
#line 918 
    ldv_23_show_ret = ldv_emg_wrapper_fm10k_dbg_tx_desc_seq_show_2(ldv_23_seq_file,ldv_23_ldv_param_1_3);
    
#line 922 
    ldv_free(ldv_23_ldv_param_1_3);
    
#line 925 
    tmp_4 = ldv_undef_int();
    
#line 925 
    if (tmp_4 != 0) {
      
#line 927 
      __VERIFIER_assume(ldv_23_show_ret >= 0);
      
#line 931 
      ldv_23_ldv_param_1_2 = ldv_xmalloc_unknown_size(0UL);
      
#line 936 
      ldv_23_ret = ldv_emg_wrapper_fm10k_dbg_desc_seq_next_3(ldv_23_seq_file,ldv_23_ldv_param_1_2,ldv_23_index);
      
#line 940 
      ldv_free(ldv_23_ldv_param_1_2);
      
#line 947 
      goto ldv_inner_loop_23;
    }
    else {
      
#line 951 
      ldv_23_ldv_param_1_4 = ldv_xmalloc_unknown_size(0UL);
      
#line 956 
      ldv_23_seq_file->index = *ldv_23_index;
      
#line 958 
      ldv_emg_wrapper_fm10k_dbg_desc_seq_stop_5(ldv_23_seq_file,ldv_23_ldv_param_1_4);
      
#line 960 
      ldv_23_seq_file->index = *ldv_23_index;
      
#line 964 
      ldv_free(ldv_23_ldv_param_1_4);
      
#line 971 
      goto ldv_outer_loop_23;
    }
  }
  else {
    long tmp_5;
    
#line 976 
    tmp_5 = ldv_is_err_or_null((void const *)ldv_23_ret);
    
#line 976 
    __VERIFIER_assume((int)tmp_5);
    
#line 980 
    ldv_23_ldv_param_1_4 = ldv_xmalloc_unknown_size(0UL);
    
#line 985 
    ldv_23_seq_file->index = *ldv_23_index;
    
#line 987 
    ldv_emg_wrapper_fm10k_dbg_desc_seq_stop_5(ldv_23_seq_file,ldv_23_ldv_param_1_4);
    
#line 989 
    ldv_23_seq_file->index = *ldv_23_index;
    
#line 993 
    ldv_free(ldv_23_ldv_param_1_4);
    
#line 1000 
    goto ldv_outer_loop_23;
  }
  
#line 1003 
  __retres = (void *)0;
  return_label: 
#line 1003 
                return __retres;
}


#line 1008  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_8_4(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_20 *cf_arg_20;
  int tmp;
  
#line 1011 
  tmp = ldv_undef_int();
  
#line 1011 
  switch (tmp) {
    case 0: 
#line 1012 
    ;
    
#line 1013 
    cf_arg_20 = (struct ldv_struct_random_allocationless_scenario_20 *)ldv_xmalloc(16UL);
    
#line 1014 
    cf_arg_20->arg0 = arg0;
    
#line 1015 
    ret = pthread_create(& ldv_thread_20,(pthread_attr_t const *)0,& ldv_random_allocationless_scenario_20,(void *)cf_arg_20);
    
#line 1016 
    __VERIFIER_assume(ret == 0);
    
#line 1017 
    goto ldv_45731;
    default: 
#line 1019 
    ;
    
#line 1019 
    __VERIFIER_assume(0);
  }
  ldv_45731: 
#line 1020 
  ;
  
#line 1021 
  return;
}


#line 1025  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  struct net_device *__retres;
  struct net_device *ldv_4_netdev;
  int tmp_0;
  
#line 1032 
  tmp_0 = ldv_undef_int();
  
#line 1032 
  if (tmp_0 != 0) {
    
#line 1034 
    ldv_4_netdev = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    
#line 1038 
    __retres = ldv_4_netdev;
    
#line 1038 
    goto return_label;
  }
  else {
    
#line 1045 
    __retres = (struct net_device *)0;
    
#line 1045 
    goto return_label;
  }
  return_label: 
#line 1032 
                return __retres;
}


#line 1055  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_16(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_16_ret_val;
  int ldv_16_line;
  void *ldv_16_data;
  enum irqreturn (*ldv_16_thread)(int , void *);
  int tmp;
  
#line 1061 
  enum irqreturn (*ldv_16_callback)(int , void *) = & ldv_emg_wrapper_fm10k_msix_clean_rings_2;
  
#line 1064 
  struct ldv_struct_interrupt_scenario_16 *data = (struct ldv_struct_interrupt_scenario_16 *)arg0;
  
#line 1069 
  if (data != (struct ldv_struct_interrupt_scenario_16 *)0) {
    
#line 1070 
    ldv_16_line = data->arg0;
    
#line 1071 
    ldv_16_callback = data->arg1;
    
#line 1072 
    ldv_16_thread = data->arg2;
    
#line 1073 
    ldv_16_data = data->arg3;
    
#line 1074 
    ldv_free((void *)data);
  }
  else ;
  
#line 1080 
  ldv_switch_to_interrupt_context();
  
#line 1082 
  ldv_16_ret_val = ldv_emg_wrapper_fm10k_msix_clean_rings_2(ldv_16_line,ldv_16_data);
  
#line 1084 
  ldv_switch_to_process_context();
  
#line 1087 
  tmp = ldv_undef_int();
  
#line 1087 
  if (tmp != 0) {
    
#line 1089 
    __VERIFIER_assume(ldv_16_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 1093 
    if (ldv_16_thread != (enum irqreturn (*)(int , void *))0) 
#line 1095 
                                                              (*ldv_16_thread)(ldv_16_line,ldv_16_data); else ;
  }
  else 
#line 1102 
       __VERIFIER_assume(ldv_16_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 1111 
  __retres = (void *)0;
  
#line 1111 
  goto return_label;
  
#line 1113 
  __retres = (void *)0;
  return_label: 
#line 1113 
                return __retres;
}


#line 1118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_random_allocationless_scenario_20(void *arg0)
{
  void *__retres;
  void *ldv_20_ldv_param_1_50;
  int ldv_20_ldv_param_2_17;
  int ldv_20_ldv_param_1_6;
  struct ethtool_coalesce *ldv_20_ldv_param_1_55;
  void *ldv_20_ldv_param_2_52;
  void *ldv_20_ldv_param_1_14;
  struct ethtool_pauseparam *ldv_20_ldv_param_1_29;
  struct ethtool_stats *ldv_20_ldv_param_1_4;
  unsigned short ldv_20_ldv_param_1_56;
  struct ethtool_regs *ldv_20_ldv_param_1_51;
  unsigned short ldv_20_ldv_param_1_26;
  unsigned int ldv_20_ldv_param_1_30;
  struct sk_buff *ldv_20_ldv_param_0_13;
  unsigned char ldv_20_ldv_param_3_11;
  int ldv_20_ldv_param_2_19;
  int ldv_20_ldv_param_1_33;
  struct ethtool_rxnfc *ldv_20_ldv_param_1_21;
  int ldv_20_ldv_param_1_15;
  int ldv_20_ldv_param_1_58;
  struct ethtool_channels *ldv_20_ldv_param_1_32;
  struct ethtool_test *ldv_20_ldv_param_1_36;
  unsigned short ldv_20_ldv_param_2_46;
  unsigned short ldv_20_ldv_param_1_39;
  struct net_device *ldv_20_container;
  unsigned int *ldv_20_ldv_param_2_22;
  unsigned char ldv_20_ldv_param_3_35;
  unsigned char *ldv_20_ldv_param_3_25;
  struct ethtool_pauseparam *ldv_20_ldv_param_1_28;
  struct rtnl_link_stats64 *ldv_20_ldv_param_1_3;
  unsigned short ldv_20_ldv_param_2_57;
  unsigned char *ldv_20_ldv_param_2_10;
  struct ifreq *ldv_20_ldv_param_1_16;
  unsigned long long ldv_20_ldv_param_2_49;
  unsigned char *ldv_20_ldv_param_2_24;
  unsigned short ldv_20_ldv_param_2_27;
  unsigned short ldv_20_ldv_param_2_40;
  struct ifla_vf_info *ldv_20_ldv_param_2_42;
  struct ethtool_coalesce *ldv_20_ldv_param_1_47;
  unsigned char ldv_20_ldv_param_1_2;
  unsigned char *ldv_20_ldv_param_2_44;
  unsigned char *ldv_20_ldv_param_2_59;
  int ldv_20_ldv_param_3_20;
  unsigned int ldv_20_ldv_param_1_43;
  struct ethtool_channels *ldv_20_ldv_param_1_38;
  struct ethtool_drvinfo *ldv_20_ldv_param_1_8;
  unsigned long long *ldv_20_ldv_param_2_37;
  unsigned int *ldv_20_ldv_param_1_23;
  unsigned long long *ldv_20_ldv_param_2_5;
  struct ethtool_ringparam *ldv_20_ldv_param_1_12;
  int ldv_20_ldv_param_1_41;
  struct ethtool_rxnfc *ldv_20_ldv_param_1_7;
  struct net_device *ldv_20_ldv_param_1_53;
  int ldv_20_ldv_param_1_18;
  struct ethtool_ringparam *ldv_20_ldv_param_1_31;
  unsigned short ldv_20_ldv_param_2_34;
  unsigned int *ldv_20_ldv_param_1_9;
  unsigned short ldv_20_ldv_param_1_45;
  struct sk_buff *ldv_20_ldv_param_0_48;
  struct ethtool_ts_info *ldv_20_ldv_param_1_54;
  int tmp_31;
  
#line 1181 
  struct ldv_struct_random_allocationless_scenario_20 *data = (struct ldv_struct_random_allocationless_scenario_20 *)arg0;
  
#line 1186 
  if (data != (struct ldv_struct_random_allocationless_scenario_20 *)0) {
    
#line 1187 
    ldv_20_container = data->arg0;
    
#line 1188 
    ldv_free((void *)data);
  }
  else ;
  
#line 1196 
  goto ldv_call_20;
  
#line 1198 
  __retres = (void *)0;
  
#line 1198 
  goto return_label;
  ldv_call_20: 
#line 1201 
  ;
  
#line 1204 
  tmp_31 = ldv_undef_int();
  
#line 1204 
  if (tmp_31 != 0) {
    int tmp;
    
#line 1208 
    tmp = ldv_undef_int();
    
#line 1208 
    switch (tmp) {
      case 1: 
#line 1209 
      ;
      
#line 1212 
      fm10k_setup_tc(ldv_20_container,(unsigned char)((int)ldv_20_ldv_param_1_2));
      
#line 1215 
      goto ldv_45817;
      case 2: 
#line 1217 
      ;
      
#line 1219 
      ldv_20_ldv_param_2_59 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1224 
      fm10k_ndo_set_vf_mac(ldv_20_container,ldv_20_ldv_param_1_58,ldv_20_ldv_param_2_59);
      
#line 1228 
      ldv_free((void *)ldv_20_ldv_param_2_59);
      
#line 1231 
      goto ldv_45817;
      case 3: 
#line 1233 
      ;
      
#line 1236 
      fm10k_netpoll(ldv_20_container);
      
#line 1239 
      goto ldv_45817;
      case 4: 
#line 1241 
      ;
      
#line 1247 
      ldv_emg_wrapper_fm10k_vlan_rx_kill_vid_41(ldv_20_container,(unsigned short)((int)ldv_20_ldv_param_1_56),(unsigned short)((int)ldv_20_ldv_param_2_57));
      
#line 1253 
      goto ldv_45817;
      case 5: 
#line 1255 
      ;
      
#line 1258 
      ldv_emg_wrapper_fm10k_set_rx_mode_20(ldv_20_container);
      
#line 1261 
      goto ldv_45817;
      case 6: 
#line 1263 
      ;
      
#line 1265 
      ldv_20_ldv_param_1_55 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 1270 
      ldv_emg_wrapper_fm10k_set_coalesce_39(ldv_20_container,ldv_20_ldv_param_1_55);
      
#line 1274 
      ldv_free((void *)ldv_20_ldv_param_1_55);
      
#line 1277 
      goto ldv_45817;
      case 7: 
#line 1279 
      ;
      
#line 1282 
      ldv_emg_wrapper_fm10k_get_regs_len_38(ldv_20_container);
      
#line 1285 
      goto ldv_45817;
      case 8: 
#line 1287 
      ;
      
#line 1289 
      ldv_20_ldv_param_1_54 = (struct ethtool_ts_info *)ldv_xmalloc_unknown_size(0UL);
      
#line 1294 
      ldv_emg_wrapper_fm10k_get_ts_info_24(ldv_20_container,ldv_20_ldv_param_1_54);
      
#line 1298 
      ldv_free((void *)ldv_20_ldv_param_1_54);
      
#line 1301 
      goto ldv_45817;
      case 9: 
#line 1303 
      ;
      
#line 1305 
      ldv_20_ldv_param_1_53 = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
      
#line 1310 
      ldv_emg_wrapper_fm10k_dfwd_add_station_36(ldv_20_container,ldv_20_ldv_param_1_53);
      
#line 1314 
      ldv_free((void *)ldv_20_ldv_param_1_53);
      
#line 1317 
      goto ldv_45817;
      case 10: 
#line 1319 
      ;
      
#line 1322 
      ldv_emg_wrapper_fm10k_tx_timeout_13(ldv_20_container);
      
#line 1325 
      goto ldv_45817;
      case 11: 
#line 1327 
      ;
      
#line 1329 
      ldv_20_ldv_param_2_52 = ldv_xmalloc_unknown_size(0UL);
      
#line 1330 
      ldv_20_ldv_param_1_51 = (struct ethtool_regs *)ldv_xmalloc_unknown_size(0UL);
      
#line 1335 
      ldv_emg_wrapper_fm10k_get_regs_34(ldv_20_container,ldv_20_ldv_param_1_51,ldv_20_ldv_param_2_52);
      
#line 1339 
      ldv_free(ldv_20_ldv_param_2_52);
      
#line 1340 
      ldv_free((void *)ldv_20_ldv_param_1_51);
      
#line 1343 
      goto ldv_45817;
      case 12: 
#line 1345 
      ;
      
#line 1347 
      ldv_20_ldv_param_1_50 = ldv_xmalloc_unknown_size(0UL);
      
#line 1352 
      ldv_emg_wrapper_fm10k_dfwd_del_station_33(ldv_20_container,ldv_20_ldv_param_1_50);
      
#line 1356 
      ldv_free(ldv_20_ldv_param_1_50);
      
#line 1359 
      goto ldv_45817;
      case 13: 
#line 1361 
      ;
      
#line 1363 
      ldv_20_ldv_param_0_48 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
      
#line 1368 
      ldv_emg_wrapper_fm10k_features_check_32(ldv_20_ldv_param_0_48,ldv_20_container,ldv_20_ldv_param_2_49);
      
#line 1372 
      ldv_free((void *)ldv_20_ldv_param_0_48);
      
#line 1375 
      goto ldv_45817;
      case 14: 
#line 1377 
      ;
      
#line 1379 
      ldv_20_ldv_param_1_47 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 1384 
      ldv_emg_wrapper_fm10k_get_coalesce_31(ldv_20_container,ldv_20_ldv_param_1_47);
      
#line 1388 
      ldv_free((void *)ldv_20_ldv_param_1_47);
      
#line 1391 
      goto ldv_45817;
      case 15: 
#line 1393 
      ;
      
#line 1399 
      ldv_emg_wrapper_fm10k_vlan_rx_add_vid_30(ldv_20_container,(unsigned short)((int)ldv_20_ldv_param_1_45),(unsigned short)((int)ldv_20_ldv_param_2_46));
      
#line 1405 
      goto ldv_45817;
      case 16: 
#line 1407 
      ;
      
#line 1409 
      ldv_20_ldv_param_2_44 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1414 
      ldv_emg_wrapper_fm10k_get_strings_37(ldv_20_container,ldv_20_ldv_param_1_43,ldv_20_ldv_param_2_44);
      
#line 1418 
      ldv_free((void *)ldv_20_ldv_param_2_44);
      
#line 1421 
      goto ldv_45817;
      case 17: 
#line 1423 
      ;
      
#line 1425 
      ldv_20_ldv_param_2_42 = (struct ifla_vf_info *)ldv_xmalloc_unknown_size(0UL);
      
#line 1430 
      fm10k_ndo_get_vf_config(ldv_20_container,ldv_20_ldv_param_1_41,ldv_20_ldv_param_2_42);
      
#line 1434 
      ldv_free((void *)ldv_20_ldv_param_2_42);
      
#line 1437 
      goto ldv_45817;
      case 18: 
#line 1439 
      ;
      
#line 1445 
      ldv_emg_wrapper_fm10k_add_vxlan_port_7(ldv_20_container,(unsigned short)((int)ldv_20_ldv_param_1_39),(unsigned short)((int)ldv_20_ldv_param_2_40));
      
#line 1451 
      goto ldv_45817;
      case 19: 
#line 1453 
      ;
      
#line 1455 
      ldv_20_ldv_param_1_38 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
      
#line 1460 
      ldv_emg_wrapper_fm10k_set_channels_27(ldv_20_container,ldv_20_ldv_param_1_38);
      
#line 1464 
      ldv_free((void *)ldv_20_ldv_param_1_38);
      
#line 1467 
      goto ldv_45817;
      case 20: 
#line 1469 
      ;
      
#line 1471 
      ldv_20_ldv_param_2_37 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1472 
      ldv_20_ldv_param_1_36 = (struct ethtool_test *)ldv_xmalloc_unknown_size(0UL);
      
#line 1477 
      ldv_emg_wrapper_fm10k_self_test_14(ldv_20_container,ldv_20_ldv_param_1_36,ldv_20_ldv_param_2_37);
      
#line 1481 
      ldv_free((void *)ldv_20_ldv_param_2_37);
      
#line 1482 
      ldv_free((void *)ldv_20_ldv_param_1_36);
      
#line 1485 
      goto ldv_45817;
      case 21: 
#line 1487 
      ;
      
#line 1493 
      fm10k_ndo_set_vf_vlan(ldv_20_container,ldv_20_ldv_param_1_33,(unsigned short)((int)ldv_20_ldv_param_2_34),(unsigned char)((int)ldv_20_ldv_param_3_35));
      
#line 1499 
      goto ldv_45817;
      case 22: 
#line 1501 
      ;
      
#line 1503 
      ldv_20_ldv_param_1_32 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
      
#line 1508 
      ldv_emg_wrapper_fm10k_get_channels_25(ldv_20_container,ldv_20_ldv_param_1_32);
      
#line 1512 
      ldv_free((void *)ldv_20_ldv_param_1_32);
      
#line 1515 
      goto ldv_45817;
      case 23: 
#line 1517 
      ;
      
#line 1519 
      ldv_20_ldv_param_1_31 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 1524 
      ldv_emg_wrapper_fm10k_get_ringparam_17(ldv_20_container,ldv_20_ldv_param_1_31);
      
#line 1528 
      ldv_free((void *)ldv_20_ldv_param_1_31);
      
#line 1531 
      goto ldv_45817;
      case 24: 
#line 1533 
      ;
      
#line 1539 
      ldv_emg_wrapper_fm10k_set_msglevel_40(ldv_20_container,ldv_20_ldv_param_1_30);
      
#line 1545 
      goto ldv_45817;
      case 25: 
#line 1547 
      ;
      
#line 1550 
      ldv_emg_wrapper_fm10k_get_reta_size_23(ldv_20_container);
      
#line 1553 
      goto ldv_45817;
      case 26: 
#line 1555 
      ;
      
#line 1558 
      (*ldv_emg_alias_ethtool_op_get_link_22)(ldv_20_container);
      
#line 1561 
      goto ldv_45817;
      case 27: 
#line 1563 
      ;
      
#line 1565 
      ldv_20_ldv_param_1_29 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 1570 
      ldv_emg_wrapper_fm10k_get_pauseparam_21(ldv_20_container,ldv_20_ldv_param_1_29);
      
#line 1574 
      ldv_free((void *)ldv_20_ldv_param_1_29);
      
#line 1577 
      goto ldv_45817;
      case 28: 
#line 1579 
      ;
      
#line 1581 
      ldv_20_ldv_param_1_28 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 1586 
      ldv_emg_wrapper_fm10k_set_pauseparam_29(ldv_20_container,ldv_20_ldv_param_1_28);
      
#line 1590 
      ldv_free((void *)ldv_20_ldv_param_1_28);
      
#line 1593 
      goto ldv_45817;
      case 29: 
#line 1595 
      ;
      
#line 1601 
      ldv_emg_wrapper_fm10k_del_vxlan_port_19(ldv_20_container,(unsigned short)((int)ldv_20_ldv_param_1_26),(unsigned short)((int)ldv_20_ldv_param_2_27));
      
#line 1607 
      goto ldv_45817;
      case 30: 
#line 1609 
      ;
      
#line 1611 
      ldv_20_ldv_param_2_24 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1612 
      ldv_20_ldv_param_3_25 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1613 
      ldv_20_ldv_param_1_23 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 1618 
      ldv_emg_wrapper_fm10k_get_rssh_18(ldv_20_container,ldv_20_ldv_param_1_23,ldv_20_ldv_param_2_24,ldv_20_ldv_param_3_25);
      
#line 1622 
      ldv_free((void *)ldv_20_ldv_param_2_24);
      
#line 1623 
      ldv_free((void *)ldv_20_ldv_param_3_25);
      
#line 1624 
      ldv_free((void *)ldv_20_ldv_param_1_23);
      
#line 1627 
      goto ldv_45817;
      case 31: 
#line 1629 
      ;
      
#line 1631 
      ldv_20_ldv_param_2_22 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 1632 
      ldv_20_ldv_param_1_21 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
      
#line 1637 
      ldv_emg_wrapper_fm10k_get_rxnfc_16(ldv_20_container,ldv_20_ldv_param_1_21,ldv_20_ldv_param_2_22);
      
#line 1641 
      ldv_free((void *)ldv_20_ldv_param_2_22);
      
#line 1642 
      ldv_free((void *)ldv_20_ldv_param_1_21);
      
#line 1645 
      goto ldv_45817;
      case 32: 
#line 1647 
      ;
      
#line 1653 
      fm10k_ndo_set_vf_bw(ldv_20_container,ldv_20_ldv_param_1_18,ldv_20_ldv_param_2_19,ldv_20_ldv_param_3_20);
      
#line 1659 
      goto ldv_45817;
      case 33: 
#line 1661 
      ;
      
#line 1664 
      (*ldv_emg_alias_eth_validate_addr_26)(ldv_20_container);
      
#line 1667 
      goto ldv_45817;
      case 34: 
#line 1669 
      ;
      
#line 1671 
      ldv_20_ldv_param_1_16 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
      
#line 1676 
      ldv_emg_wrapper_fm10k_ioctl_15(ldv_20_container,ldv_20_ldv_param_1_16,ldv_20_ldv_param_2_17);
      
#line 1680 
      ldv_free((void *)ldv_20_ldv_param_1_16);
      
#line 1683 
      goto ldv_45817;
      case 35: 
#line 1685 
      ;
      
#line 1688 
      ldv_emg_wrapper_fm10k_get_rssrk_size_9(ldv_20_container);
      
#line 1691 
      goto ldv_45817;
      case 36: 
#line 1693 
      ;
      
#line 1699 
      ldv_emg_wrapper_fm10k_get_sset_count_35(ldv_20_container,ldv_20_ldv_param_1_15);
      
#line 1705 
      goto ldv_45817;
      case 37: 
#line 1707 
      ;
      
#line 1709 
      ldv_20_ldv_param_1_14 = ldv_xmalloc_unknown_size(0UL);
      
#line 1714 
      ldv_emg_wrapper_fm10k_set_mac_12(ldv_20_container,ldv_20_ldv_param_1_14);
      
#line 1718 
      ldv_free(ldv_20_ldv_param_1_14);
      
#line 1721 
      goto ldv_45817;
      case 38: 
#line 1723 
      ;
      
#line 1725 
      ldv_20_ldv_param_0_13 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
      
#line 1730 
      ldv_emg_wrapper_fm10k_xmit_frame_11(ldv_20_ldv_param_0_13,ldv_20_container);
      
#line 1734 
      ldv_free((void *)ldv_20_ldv_param_0_13);
      
#line 1737 
      goto ldv_45817;
      case 39: 
#line 1739 
      ;
      
#line 1742 
      ldv_emg_wrapper_fm10k_get_msglevel_10(ldv_20_container);
      
#line 1745 
      goto ldv_45817;
      case 40: 
#line 1747 
      ;
      
#line 1749 
      ldv_20_ldv_param_1_12 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 1754 
      ldv_emg_wrapper_fm10k_set_ringparam_8(ldv_20_container,ldv_20_ldv_param_1_12);
      
#line 1758 
      ldv_free((void *)ldv_20_ldv_param_1_12);
      
#line 1761 
      goto ldv_45817;
      case 41: 
#line 1763 
      ;
      
#line 1765 
      ldv_20_ldv_param_1_9 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 1766 
      ldv_20_ldv_param_2_10 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1771 
      ldv_emg_wrapper_fm10k_set_rssh_28(ldv_20_container,ldv_20_ldv_param_1_9,ldv_20_ldv_param_2_10,(unsigned char)((int)ldv_20_ldv_param_3_11));
      
#line 1775 
      ldv_free((void *)ldv_20_ldv_param_1_9);
      
#line 1776 
      ldv_free((void *)ldv_20_ldv_param_2_10);
      
#line 1779 
      goto ldv_45817;
      case 42: 
#line 1781 
      ;
      
#line 1783 
      ldv_20_ldv_param_1_8 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 1788 
      ldv_emg_wrapper_fm10k_get_drvinfo_6(ldv_20_container,ldv_20_ldv_param_1_8);
      
#line 1792 
      ldv_free((void *)ldv_20_ldv_param_1_8);
      
#line 1795 
      goto ldv_45817;
      case 43: 
#line 1797 
      ;
      
#line 1799 
      ldv_20_ldv_param_1_7 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
      
#line 1804 
      ldv_emg_wrapper_fm10k_set_rxnfc_5(ldv_20_container,ldv_20_ldv_param_1_7);
      
#line 1808 
      ldv_free((void *)ldv_20_ldv_param_1_7);
      
#line 1811 
      goto ldv_45817;
      case 44: 
#line 1813 
      ;
      
#line 1819 
      ldv_emg_wrapper_fm10k_change_mtu_4(ldv_20_container,ldv_20_ldv_param_1_6);
      
#line 1825 
      goto ldv_45817;
      case 45: 
#line 1827 
      ;
      
#line 1829 
      ldv_20_ldv_param_2_5 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1830 
      ldv_20_ldv_param_1_4 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
      
#line 1835 
      ldv_emg_wrapper_fm10k_get_ethtool_stats_3(ldv_20_container,ldv_20_ldv_param_1_4,ldv_20_ldv_param_2_5);
      
#line 1839 
      ldv_free((void *)ldv_20_ldv_param_2_5);
      
#line 1840 
      ldv_free((void *)ldv_20_ldv_param_1_4);
      
#line 1843 
      goto ldv_45817;
      case 46: 
#line 1845 
      ;
      
#line 1847 
      ldv_20_ldv_param_1_3 = (struct rtnl_link_stats64 *)ldv_xmalloc_unknown_size(0UL);
      
#line 1852 
      ldv_emg_wrapper_fm10k_get_stats64_2(ldv_20_container,ldv_20_ldv_param_1_3);
      
#line 1856 
      ldv_free((void *)ldv_20_ldv_param_1_3);
      
#line 1859 
      goto ldv_45817;
      default: 
#line 1861 
      ;
      
#line 1861 
      __VERIFIER_assume(0);
    }
    ldv_45817: 
#line 1870 
    ;
    
#line 1870 
    goto ldv_call_20;
  }
  else {
    
#line 1878 
    __retres = (void *)0;
    
#line 1878 
    goto return_label;
  }
  
#line 1881 
  __retres = (void *)0;
  return_label: 
#line 1881 
                return __retres;
}


#line 1886  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 1893 
  ldv_1_ret = ldv_emg_fm10k_init_module();
  
#line 1894 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 1897 
  tmp = ldv_undef_int();
  
#line 1897 
  if (tmp != 0) {
    
#line 1899 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 1903 
    __retres = (void *)0;
    
#line 1903 
    goto return_label;
  }
  else {
    
#line 1907 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 1912 
    ldv_emg_fm10k_exit_module();
    
#line 1916 
    __retres = (void *)0;
    
#line 1916 
    goto return_label;
  }
  
#line 1919 
  __retres = (void *)0;
  return_label: 
#line 1919 
                return __retres;
}


#line 1924  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_seq_open(struct file *arg0, struct seq_operations *arg1)
{
  int __retres;
  struct seq_file *ldv_9_seq_file;
  struct seq_operations *ldv_9_ops;
  struct file *ldv_9_file;
  
#line 1932 
  ldv_9_seq_file = (struct seq_file *)ldv_xmalloc_unknown_size(0UL);
  
#line 1933 
  ldv_9_ops = arg1;
  
#line 1934 
  ldv_9_file->private_data = (void *)ldv_9_seq_file;
  
#line 1938 
  ldv_dispatch_register_9_1(ldv_9_seq_file,ldv_9_ops);
  
#line 1939 
  ;
  
#line 1939 
  __retres = 0;
  
#line 1939 
  return __retres;
}


#line 1947  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_register_netdev(struct net_device *arg0)
{
  int __retres;
  struct net_device *ldv_8_netdev;
  int tmp_3;
  
#line 1951 
  int ldv_8_ret = ldv_undef_int();
  
#line 1954 
  ldv_8_ret = ldv_undef_int();
  
#line 1957 
  tmp_3 = ldv_undef_int();
  
#line 1957 
  if (tmp_3 != 0) {
    int tmp_1;
    
#line 1959 
    ldv_8_netdev = arg0;
    
#line 1964 
    ldv_8_ret = fm10k_open(ldv_8_netdev);
    
#line 1967 
    tmp_1 = ldv_undef_int();
    
#line 1967 
    if (tmp_1 != 0) {
      
#line 1969 
      __VERIFIER_assume(ldv_8_ret == 0);
      
#line 1973 
      ldv_dispatch_register_8_4(ldv_8_netdev);
      
#line 1977 
      __retres = 0;
      
#line 1977 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 1984 
      __VERIFIER_assume(ldv_8_ret != 0);
      
#line 1985 
      ldv_failed_register_netdev();
      
#line 1986 
      tmp_0 = ldv_undef_int_negative();
      
#line 1986 
      __retres = tmp_0;
      
#line 1986 
      goto return_label;
    }
  }
  else {
    int tmp_2;
    
#line 1994 
    ldv_failed_register_netdev();
    
#line 1995 
    tmp_2 = ldv_undef_int_negative();
    
#line 1995 
    __retres = tmp_2;
    
#line 1995 
    goto return_label;
  }
  return_label: 
#line 1957 
                return __retres;
}


#line 2005  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 2008 
  ldv_initialize();
  
#line 2011 
  ldv_initialization_1((void *)0);
  
#line 2013 
  __retres = 0;
  
#line 2013 
  return __retres;
}


#line 2018  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_13_3(struct file_operations *arg0)
{
  int ret;
  struct ldv_struct_character_driver_scenario_15 *cf_arg_15;
  int tmp;
  
#line 2021 
  tmp = ldv_undef_int();
  
#line 2021 
  switch (tmp) {
    case 0: 
#line 2022 
    ;
    
#line 2023 
    cf_arg_15 = (struct ldv_struct_character_driver_scenario_15 *)ldv_xmalloc(16UL);
    
#line 2024 
    cf_arg_15->arg0 = arg0;
    
#line 2025 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_character_driver_scenario_15,(void *)cf_arg_15);
    
#line 2026 
    __VERIFIER_assume(ret == 0);
    
#line 2027 
    goto ldv_45889;
    default: 
#line 2029 
    ;
    
#line 2029 
    __VERIFIER_assume(0);
  }
  ldv_45889: 
#line 2030 
  ;
  
#line 2031 
  return;
}


#line 2035  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 2038 
  struct pci_driver *ldv_7_pci_driver = ldv_emg_alias_fm10k_driver_2;
  
#line 2041 
  ldv_7_pci_driver = arg0;
  
#line 2045 
  ldv_dispatch_deregister_7_1(ldv_7_pci_driver);
  
#line 2049 
  goto return_label;
  return_label: 
#line 2051 
                return;
}


#line 2056  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_timer_scenario_19(void *arg0)
{
  void *__retres;
  struct timer_list *ldv_19_container;
  
#line 2061 
  struct ldv_struct_timer_scenario_19 *data = (struct ldv_struct_timer_scenario_19 *)arg0;
  
#line 2066 
  if (data != (struct ldv_struct_timer_scenario_19 *)0) {
    
#line 2067 
    ldv_19_container = data->arg0;
    
#line 2068 
    ldv_free((void *)data);
  }
  else ;
  
#line 2073 
  if (ldv_19_container->function != (void (*)(unsigned long ))0) {
    
#line 2075 
    ldv_switch_to_interrupt_context();
    
#line 2077 
    (*(ldv_19_container->function))(ldv_19_container->data);
    
#line 2079 
    ldv_switch_to_process_context();
  }
  else ;
  
#line 2088 
  __retres = (void *)0;
  
#line 2088 
  goto return_label;
  
#line 2090 
  __retres = (void *)0;
  return_label: 
#line 2090 
                return __retres;
}


#line 2095  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_register_3_3(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_19 *cf_arg_19;
  int tmp;
  
#line 2098 
  tmp = ldv_undef_int();
  
#line 2098 
  switch (tmp) {
    case 0: 
#line 2099 
    ;
    
#line 2100 
    cf_arg_19 = (struct ldv_struct_timer_scenario_19 *)ldv_xmalloc(16UL);
    
#line 2101 
    cf_arg_19->arg0 = arg0;
    
#line 2102 
    ret = pthread_create(& ldv_thread_19,(pthread_attr_t const *)0,& ldv_timer_scenario_19,(void *)cf_arg_19);
    
#line 2103 
    __VERIFIER_assume(ret == 0);
    
#line 2104 
    goto ldv_45906;
    default: 
#line 2106 
    ;
    
#line 2106 
    __VERIFIER_assume(0);
  }
  ldv_45906: 
#line 2107 
  ;
  
#line 2108 
  return;
}


#line 2112  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_6_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_6 *cf_arg_16;
  struct ldv_struct_free_irq_6 *cf_arg_17;
  struct ldv_struct_free_irq_6 *cf_arg_21;
  int tmp;
  
#line 2117 
  tmp = ldv_undef_int();
  
#line 2117 
  switch (tmp) {
    case 0: 
#line 2118 
    ;
    
#line 2119 
    ret = pthread_join(ldv_thread_16,(void **)0);
    
#line 2120 
    __VERIFIER_assume(ret == 0);
    
#line 2121 
    goto ldv_45916;
    case 1: 
#line 2123 
    ;
    
#line 2124 
    ret = pthread_join(ldv_thread_17,(void **)0);
    
#line 2125 
    __VERIFIER_assume(ret == 0);
    
#line 2126 
    goto ldv_45916;
    case 2: 
#line 2128 
    ;
    
#line 2129 
    ret = pthread_join(ldv_thread_21,(void **)0);
    
#line 2130 
    __VERIFIER_assume(ret == 0);
    
#line 2131 
    goto ldv_45916;
    default: 
#line 2133 
    ;
    
#line 2133 
    __VERIFIER_assume(0);
  }
  ldv_45916: 
#line 2134 
  ;
  
#line 2135 
  return;
}


#line 2139  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_unregister_netdev(struct net_device *arg0)
{
  struct net_device *ldv_5_netdev;
  
#line 2145 
  ldv_5_netdev = arg0;
  
#line 2150 
  fm10k_close(ldv_5_netdev);
  
#line 2154 
  ldv_dispatch_deregister_5_1(ldv_5_netdev);
  
#line 2158 
  goto return_label;
  return_label: 
#line 2160 
                return;
}


#line 2165  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_6_line;
  
#line 2171 
  ldv_6_line = (int)arg0;
  
#line 2175 
  ldv_dispatch_irq_deregister_6_1(ldv_6_line);
  
#line 2179 
  goto return_label;
  return_label: 
#line 2181 
                return;
}


#line 2186  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_deregister_12_1(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_19 *cf_arg_19;
  int tmp;
  
#line 2189 
  tmp = ldv_undef_int();
  
#line 2189 
  switch (tmp) {
    case 0: 
#line 2190 
    ;
    
#line 2191 
    ret = pthread_join(ldv_thread_19,(void **)0);
    
#line 2192 
    __VERIFIER_assume(ret == 0);
    
#line 2193 
    goto ldv_45935;
    default: 
#line 2195 
    ;
    
#line 2195 
    __VERIFIER_assume(0);
  }
  ldv_45935: 
#line 2196 
  ;
  
#line 2197 
  return;
}


#line 2201  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_11_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_16 *cf_arg_16;
  struct ldv_struct_interrupt_scenario_16 *cf_arg_17;
  struct ldv_struct_interrupt_scenario_16 *cf_arg_21;
  int tmp;
  
#line 2206 
  tmp = ldv_undef_int();
  
#line 2206 
  switch (tmp) {
    case 0: 
#line 2207 
    ;
    
#line 2208 
    cf_arg_16 = (struct ldv_struct_interrupt_scenario_16 *)ldv_xmalloc(32UL);
    
#line 2209 
    cf_arg_16->arg0 = arg0;
    
#line 2210 
    cf_arg_16->arg1 = arg1;
    
#line 2211 
    cf_arg_16->arg2 = arg2;
    
#line 2212 
    cf_arg_16->arg3 = arg3;
    
#line 2213 
    ret = pthread_create(& ldv_thread_16,(pthread_attr_t const *)0,& ldv_interrupt_scenario_16,(void *)cf_arg_16);
    
#line 2214 
    __VERIFIER_assume(ret == 0);
    
#line 2215 
    goto ldv_45952;
    case 1: 
#line 2217 
    ;
    
#line 2218 
    cf_arg_17 = (struct ldv_struct_interrupt_scenario_16 *)ldv_xmalloc(32UL);
    
#line 2219 
    cf_arg_17->arg0 = arg0;
    
#line 2220 
    cf_arg_17->arg1 = arg1;
    
#line 2221 
    cf_arg_17->arg2 = arg2;
    
#line 2222 
    cf_arg_17->arg3 = arg3;
    
#line 2223 
    ret = pthread_create(& ldv_thread_17,(pthread_attr_t const *)0,& ldv_interrupt_scenario_17,(void *)cf_arg_17);
    
#line 2224 
    __VERIFIER_assume(ret == 0);
    
#line 2225 
    goto ldv_45952;
    case 2: 
#line 2227 
    ;
    
#line 2228 
    cf_arg_21 = (struct ldv_struct_interrupt_scenario_16 *)ldv_xmalloc(32UL);
    
#line 2229 
    cf_arg_21->arg0 = arg0;
    
#line 2230 
    cf_arg_21->arg1 = arg1;
    
#line 2231 
    cf_arg_21->arg2 = arg2;
    
#line 2232 
    cf_arg_21->arg3 = arg3;
    
#line 2233 
    ret = pthread_create(& ldv_thread_21,(pthread_attr_t const *)0,& ldv_interrupt_scenario_21,(void *)cf_arg_21);
    
#line 2234 
    __VERIFIER_assume(ret == 0);
    
#line 2235 
    goto ldv_45952;
    default: 
#line 2237 
    ;
    
#line 2237 
    __VERIFIER_assume(0);
  }
  ldv_45952: 
#line 2238 
  ;
  
#line 2239 
  return;
}


#line 2243  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_18(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_18_resource_1;
  struct pci_device_id *ldv_18_ldv_param_1_2;
  int ldv_18_ldv_param_1_3;
  struct pm_message ldv_18_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 2249 
  struct pci_driver *ldv_18_container = ldv_emg_alias_fm10k_driver_2;
  
#line 2250 
  int ldv_18_ret = ldv_undef_int();
  
#line 2253 
  struct ldv_struct_pci_scenario_18 *data = (struct ldv_struct_pci_scenario_18 *)arg0;
  
#line 2257 
  ldv_18_ret = ldv_undef_int();
  
#line 2260 
  if (data != (struct ldv_struct_pci_scenario_18 *)0) {
    
#line 2261 
    ldv_18_container = data->arg0;
    
#line 2262 
    ldv_free((void *)data);
  }
  else ;
  
#line 2273 
  goto ldv_main_18;
  
#line 2275 
  __retres = (void *)0;
  
#line 2275 
  goto return_label;
  ldv_main_18: 
#line 2278 
  ;
  
#line 2281 
  tmp_2 = ldv_undef_int();
  
#line 2281 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 2283 
    ldv_18_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 2288 
    ldv_pre_probe();
    
#line 2290 
    ldv_18_ret = ldv_emg_wrapper_fm10k_probe_2(ldv_18_resource_1,ldv_18_ldv_param_1_2);
    
#line 2292 
    ldv_18_ret = ldv_post_probe(ldv_18_ret);
    
#line 2296 
    ldv_free((void *)ldv_18_ldv_param_1_2);
    
#line 2299 
    tmp_1 = ldv_undef_int();
    
#line 2299 
    if (tmp_1 != 0) {
      
#line 2301 
      __VERIFIER_assume(ldv_18_ret == 0);
      
#line 2308 
      goto ldv_call_18;
    }
    else {
      
#line 2312 
      __VERIFIER_assume(ldv_18_ret != 0);
      
#line 2319 
      goto ldv_main_18;
    }
  }
  else {
    
#line 2331 
    __retres = (void *)0;
    
#line 2331 
    goto return_label;
  }
  
#line 2334 
  __retres = (void *)0;
  
#line 2334 
  goto return_label;
  ldv_call_18: 
#line 2337 
  ;
  
#line 2340 
  tmp_3 = ldv_undef_int();
  
#line 2340 
  switch (tmp_3) {
    case 1: 
#line 2341 
    ;
    
#line 2347 
    fm10k_iov_configure(ldv_18_resource_1,ldv_18_ldv_param_1_3);
    
#line 2357 
    goto ldv_call_18;
    case 2: 
#line 2360 
    ;
    
#line 2363 
    ldv_18_ret = ldv_emg_wrapper_fm10k_suspend_3(ldv_18_resource_1,ldv_18_resource_0);
    
#line 2365 
    ldv_18_ret = ldv_filter_err_code(ldv_18_ret);
    
#line 2369 
    if (ldv_18_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 2371 
      ldv_18_ret = (*(ldv_18_container->suspend_late))(ldv_18_resource_1,ldv_18_resource_0);
      
#line 2373 
      ldv_18_ret = ldv_filter_err_code(ldv_18_ret);
    }
    else 
#line 2375 
         ldv_18_ret = ldv_undef_int();
    
#line 2380 
    if (ldv_18_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 2382 
      (*(ldv_18_container->resume_early))(ldv_18_resource_1); else ;
    
#line 2388 
    ldv_emg_wrapper_fm10k_resume_5(ldv_18_resource_1);
    
#line 2395 
    goto ldv_call_18;
    case 3: 
#line 2398 
    ;
    
#line 2400 
    if (ldv_18_container->shutdown != (void (*)(struct pci_dev *))0) 
      
#line 2402 
      (*(ldv_18_container->shutdown))(ldv_18_resource_1); else ;
    
#line 2408 
    ldv_emg_wrapper_fm10k_remove_4(ldv_18_resource_1);
    
#line 2415 
    goto ldv_main_18;
    default: 
#line 2418 
    ;
    
#line 2418 
    __VERIFIER_assume(0);
  }
  
#line 2421 
  __retres = (void *)0;
  return_label: 
#line 2421 
                return __retres;
}


#line 2426  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1)
{
  _Bool __retres;
  struct work_struct *ldv_14_work_struct;
  int tmp;
  
#line 2433 
  tmp = ldv_undef_int();
  
#line 2433 
  if (tmp != 0) {
    
#line 2435 
    ldv_14_work_struct = arg1;
    
#line 2439 
    if (ldv_14_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 2441 
      (*(ldv_14_work_struct->func))(ldv_14_work_struct); else ;
    
#line 2446 
    __retres = (_Bool)1;
    
#line 2446 
    goto return_label;
  }
  else {
    
#line 2453 
    __retres = (_Bool)0;
    
#line 2453 
    goto return_label;
  }
  return_label: 
#line 2433 
                return __retres;
}


#line 2463  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_netdev(struct net_device *arg0)
{
  struct net_device *ldv_2_netdev;
  
#line 2469 
  ldv_2_netdev = arg0;
  
#line 2470 
  ldv_free((void *)ldv_2_netdev);
  
#line 2474 
  goto return_label;
  return_label: 
#line 2476 
                return;
}


#line 2481  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1)
{
  int __retres;
  struct timer_list *ldv_3_timer_list;
  int tmp_0;
  
#line 2488 
  tmp_0 = ldv_undef_int();
  
#line 2488 
  if (tmp_0 != 0) {
    
#line 2490 
    ldv_3_timer_list = arg0;
    
#line 2494 
    ldv_dispatch_instance_register_3_3(ldv_3_timer_list);
    
#line 2498 
    __retres = 0;
    
#line 2498 
    goto return_label;
  }
  else {
    int tmp;
    
#line 2505 
    tmp = ldv_undef_int_negative();
    
#line 2505 
    __retres = tmp;
    
#line 2505 
    goto return_label;
  }
  return_label: 
#line 2488 
                return __retres;
}


#line 2515  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/fm10k/fm10k.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_11_line;
  void *ldv_11_data;
  enum irqreturn (*ldv_11_thread)(int , void *);
  int tmp_0;
  
#line 2520 
  enum irqreturn (*ldv_11_callback)(int , void *) = & ldv_emg_wrapper_fm10k_msix_mbx_vf_2;
  
#line 2525 
  tmp_0 = ldv_undef_int();
  
#line 2525 
  if (tmp_0 != 0) {
    
#line 2527 
    ldv_11_line = (int)arg0;
    
#line 2528 
    ldv_11_callback = arg1;
    
#line 2529 
    ldv_11_thread = (enum irqreturn (*)(int , void *))0;
    
#line 2530 
    ldv_11_data = arg4;
    
#line 2534 
    ldv_dispatch_irq_register_11_3(ldv_11_line,ldv_11_callback,ldv_11_thread,ldv_11_data);
    
#line 2538 
    __retres = 0;
    
#line 2538 
    goto return_label;
  }
  else {
    int tmp;
    
#line 2545 
    tmp = ldv_undef_int_negative();
    
#line 2545 
    __retres = tmp;
    
#line 2545 
    goto return_label;
  }
  return_label: 
#line 2525 
                return __retres;
}


