/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/stat.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct bio_vec;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_48 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_48 __anonCompField_iov_iter_19 ;
   unsigned long nr_segs ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 18 
struct pid;

#line 19 
struct cred;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_49 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_49 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_50 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_50 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_51 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_51 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_52 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_52 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_53 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_53 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_54 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_54 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_55 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_55 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_56 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_56 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_57 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_58 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_57 ifr_ifrn ;
   union __anonunion_ifr_ifru_58 ifr_ifru ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct hlist_bl_node;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_67 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_66 {
   struct __anonstruct_67 __anonCompField___anonunion_66_20 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_66 __anonCompField_lockref_21 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct path;

#line 51 
struct vfsmount;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_69 {
   u32 hash ;
   u32 len ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_68 {
   struct __anonstruct_69 __anonCompField___anonunion_68_22 ;
   u64 hash_len ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_68 __anonCompField_qstr_23 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct inode;

#line 90 
struct dentry_operations;

#line 90 
struct super_block;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_70 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_70 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_73 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_73 nodemask_t;

#line 520 
struct mem_cgroup;

#line 520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 189 
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_75 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_74 {
   struct __anonstruct_75 __anonCompField___anonunion_74_24 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_74 __anonCompField_radix_tree_node_25 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 97 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 104 
struct pid_namespace;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 193 
struct rw_semaphore;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 44 
struct vm_area_struct;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mpspec.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_144 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_143 {
   struct __anonstruct_144 __anonCompField___anonunion_143_26 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_143 __anonCompField_ctl_table_header_27 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_145 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_145 mm_context_t;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct block_device;

#line 31 
struct io_context;

#line 32 
struct cgroup_subsys_state;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct backing_dev_info;

#line 61 
struct bdi_writeback;

#line 62 
struct export_operations;

#line 64 
struct kobject;

#line 65 
struct pipe_inode_info;

#line 67 
struct kstatfs;

#line 68 
struct swap_info_struct;

#line 69 
struct vm_fault;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_173 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_173 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_174 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_174 __anonCompField_kqid_39 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526 
struct address_space;

#line 527 
struct writeback_control;

#line 528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_177 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_178 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_179 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_177 __anonCompField_inode_40 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_178 __anonCompField_inode_41 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_179 __anonCompField_inode_42 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_180 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_180 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 947 
struct net;

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19 
struct fasync_struct;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_182 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_181 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_182 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_181 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1061 
struct files_struct;

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct file_system_type;

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 2251 
struct kmem_cache;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_188 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_189 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_187 {
   struct __anonstruct_188 __anonCompField___anonunion_187_45 ;
   struct __anonstruct_189 __anonCompField___anonunion_187_46 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_187 __anonCompField_uprobe_task_47 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_190 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_192 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_196 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_195 {
   atomic_t _mapcount ;
   struct __anonstruct_196 __anonCompField___anonunion_195_50 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_194 {
   union __anonunion_195 __anonCompField___anonstruct_194_51 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_193 {
   unsigned long counters ;
   struct __anonstruct_194 __anonCompField___anonunion_193_52 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_191 {
   union __anonunion_192 __anonCompField___anonstruct_191_49 ;
   union __anonunion_193 __anonCompField___anonstruct_191_53 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_198 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_199 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_197 {
   struct list_head lru ;
   struct __anonstruct_198 __anonCompField___anonunion_197_55 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_199 __anonCompField___anonunion_197_56 ;
   pgtable_t pmd_huge_pte ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_200 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_190 __anonCompField_page_48 ;
   struct __anonstruct_191 __anonCompField_page_54 ;
   union __anonunion_197 __anonCompField_page_57 ;
   union __anonunion_200 __anonCompField_page_58 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_201 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct vm_operations_struct;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_201 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_203 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_203 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_205 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_206 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_207 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_208 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_210 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_209 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_210 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_211 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_212 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_204 {
   int _pad[28U] ;
   struct __anonstruct__kill_205 _kill ;
   struct __anonstruct__timer_206 _timer ;
   struct __anonstruct__rt_207 _rt ;
   struct __anonstruct__sigchld_208 _sigchld ;
   struct __anonstruct__sigfault_209 _sigfault ;
   struct __anonstruct__sigpoll_211 _sigpoll ;
   struct __anonstruct__sigsys_212 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_204 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_215 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_216 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_218 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_217 {
   struct keyring_index_key index_key ;
   struct __anonstruct_218 __anonCompField___anonunion_217_61 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_219 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_221 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_220 {
   union __anonunion_payload_221 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_215 __anonCompField_key_59 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_216 __anonCompField_key_60 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_217 __anonCompField_key_62 ;
   union __anonunion_type_data_219 type_data ;
   union __anonunion_220 __anonCompField_key_63 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
union __anonunion_222 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_222 __anonCompField_idr_layer_64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 327 
struct cgroup;

#line 328 
struct cgroup_root;

#line 329 
struct cgroup_subsys;

#line 330 
struct cgroup_taskset;

#line 331 
struct kernfs_node;

#line 332 
struct kernfs_ops;

#line 333 
struct kernfs_open_file;

#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270 
struct kernfs_root;

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 134 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct reclaim_state;

#line 846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1172 
struct uts_namespace;

#line 1173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 176 
struct kernfs_open_node;

#line 177 
struct kernfs_iattrs;

#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_255 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_255 __anonCompField_kernfs_node_68 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 477 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject_ns.h"
struct bin_attribute;

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject_ns.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dma_map_ops;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203 
struct of_device_id;

#line 203 
struct acpi_device_id;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 1283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_256 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_256 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_24719 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_261 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_262 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_24719 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_261 __anonCompField_nf_bridge_info_72 ;
   union __anonunion_262 __anonCompField_nf_bridge_info_73 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_265 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_264 {
   u64 v64 ;
   struct __anonstruct_265 __anonCompField___anonunion_264_74 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_264 __anonCompField_skb_mstamp_75 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_268 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_267 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_268 __anonCompField___anonstruct_267_76 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_266 {
   struct __anonstruct_267 __anonCompField___anonunion_266_77 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_270 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_269 {
   __wsum csum ;
   struct __anonstruct_270 __anonCompField___anonunion_269_79 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_271 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_272 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_273 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_266 __anonCompField_sk_buff_78 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_269 __anonCompField_sk_buff_80 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_271 __anonCompField_sk_buff_81 ;
   __u32 secmark ;
   union __anonunion_272 __anonCompField_sk_buff_82 ;
   union __anonunion_273 __anonCompField_sk_buff_83 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct proc_dir_entry;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_279 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_279 __anonCompField_pci_dev_84 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_295 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_295 possible_net_t;

#line 376 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_28660 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_28660 phy_interface_t;

#line 126 
enum ldv_28713 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28713 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_30425 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_30426 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_305 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_306 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_307 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_305 adj_list ;
   struct __anonstruct_all_adj_list_306 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_30425 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_30426 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_307 __anonCompField_net_device_94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
struct vxge_hw_legacy_reg {
   u8 unused00010[16U] ;
   u64 toc_swapper_fb ;
   u64 pifm_rd_swap_en ;
   u64 pifm_rd_flip_en ;
   u64 pifm_wr_swap_en ;
   u64 pifm_wr_flip_en ;
   u64 toc_first_pointer ;
   u64 host_access_en ;
};

#line 613  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-reg.h"
struct vxge_hw_toc_reg {
   u8 unused00050[80U] ;
   u64 toc_common_pointer ;
   u64 toc_memrepair_pointer ;
   u64 toc_pcicfgmgmt_pointer[17U] ;
   u8 unused001e0[248U] ;
   u64 toc_mrpcim_pointer ;
   u64 toc_srpcim_pointer[17U] ;
   u8 unused00278[8U] ;
   u64 toc_vpmgmt_pointer[17U] ;
   u8 unused00390[144U] ;
   u64 toc_vpath_pointer[17U] ;
   u8 unused004a0[136U] ;
   u64 toc_kdfc ;
   u64 toc_usdc ;
   u64 toc_kdfc_vpath_stride ;
   u64 toc_kdfc_fifo_stride ;
};

#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-reg.h"
struct vxge_hw_common_reg {
   u8 unused00a00[2560U] ;
   u64 prc_status1 ;
   u64 rxdcm_reset_in_progress ;
   u64 replicq_flush_in_progress ;
   u64 rxpe_cmds_reset_in_progress ;
   u64 mxp_cmds_reset_in_progress ;
   u64 noffload_reset_in_progress ;
   u64 rd_req_in_progress ;
   u64 rd_req_outstanding ;
   u64 kdfc_reset_in_progress ;
   u8 unused00b00[184U] ;
   u64 one_cfg_vp ;
   u64 one_common ;
   u8 unused00b80[112U] ;
   u64 tim_int_en ;
   u64 tim_set_int_en ;
   u64 tim_clr_int_en ;
   u64 tim_mask_int_during_reset ;
   u64 tim_reset_in_progress ;
   u64 tim_outstanding_bmap ;
   u8 unused00c00[80U] ;
   u64 msg_reset_in_progress ;
   u64 msg_mxp_mr_ready ;
   u64 msg_uxp_mr_ready ;
   u64 msg_dmq_noni_rtl_prefetch ;
   u64 msg_umq_rtl_bwr ;
   u8 unused00d00[216U] ;
   u64 cmn_rsthdlr_cfg0 ;
   u64 cmn_rsthdlr_cfg1 ;
   u64 cmn_rsthdlr_cfg2 ;
   u64 cmn_rsthdlr_cfg3 ;
   u64 cmn_rsthdlr_cfg4 ;
   u8 unused00d40[24U] ;
   u64 cmn_rsthdlr_cfg8 ;
   u64 stats_cfg0 ;
   u8 unused00da8[88U] ;
   u64 clear_msix_mask_vect[4U] ;
   u64 set_msix_mask_vect[4U] ;
   u64 clear_msix_mask_all_vect ;
   u64 set_msix_mask_all_vect ;
   u64 mask_vector[4U] ;
   u64 msix_pending_vector[4U] ;
   u64 clr_msix_one_shot_vec[4U] ;
   u64 titan_asic_id ;
   u64 titan_general_int_status ;
   u8 unused00e70[8U] ;
   u64 titan_mask_all_int ;
   u8 unused00e80[8U] ;
   u64 tim_int_status0 ;
   u64 tim_int_mask0 ;
   u64 tim_int_status1 ;
   u64 tim_int_mask1 ;
   u64 rti_int_status ;
   u64 rti_int_mask ;
   u64 adapter_status ;
   u64 gen_ctrl ;
   u8 unused00ed0[16U] ;
   u64 adapter_ready ;
   u64 outstanding_read ;
   u64 vpath_rst_in_prog ;
   u64 vpath_reg_modified ;
   u8 unused00fc0[208U] ;
   u64 cp_reset_in_progress ;
   u8 unused01080[184U] ;
   u64 xgmac_ready ;
   u8 unused010c0[56U] ;
   u64 fbif_ready ;
   u8 unused01100[56U] ;
   u64 vplane_assignments ;
   u64 vpath_assignments ;
   u64 resource_assignments ;
   u64 host_type_assignments ;
   u8 unused01128[8U] ;
   u64 max_resource_assignments ;
   u64 pf_vpath_assignments ;
   u8 unused01200[200U] ;
   u64 rts_access_icmp ;
   u64 rts_access_tcpsyn ;
   u64 rts_access_zl4pyld ;
   u64 rts_access_l4prtcl_tcp ;
   u64 rts_access_l4prtcl_udp ;
   u64 rts_access_l4prtcl_flex ;
   u64 rts_access_ipfrag ;
};

#line 886  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-reg.h"
struct vxge_hw_mrpcim_reg {
   u64 g3fbct_int_status ;
   u64 g3fbct_int_mask ;
   u64 g3fbct_err_reg ;
   u64 g3fbct_err_mask ;
   u64 g3fbct_err_alarm ;
   u8 unused00a00[2520U] ;
   u64 wrdma_int_status ;
   u64 wrdma_int_mask ;
   u64 rc_alarm_reg ;
   u64 rc_alarm_mask ;
   u64 rc_alarm_alarm ;
   u64 rxdrm_sm_err_reg ;
   u64 rxdrm_sm_err_mask ;
   u64 rxdrm_sm_err_alarm ;
   u64 rxdcm_sm_err_reg ;
   u64 rxdcm_sm_err_mask ;
   u64 rxdcm_sm_err_alarm ;
   u64 rxdwm_sm_err_reg ;
   u64 rxdwm_sm_err_mask ;
   u64 rxdwm_sm_err_alarm ;
   u64 rda_err_reg ;
   u64 rda_err_mask ;
   u64 rda_err_alarm ;
   u64 rda_ecc_db_reg ;
   u64 rda_ecc_db_mask ;
   u64 rda_ecc_db_alarm ;
   u64 rda_ecc_sg_reg ;
   u64 rda_ecc_sg_mask ;
   u64 rda_ecc_sg_alarm ;
   u64 rqa_err_reg ;
   u64 rqa_err_mask ;
   u64 rqa_err_alarm ;
   u64 frf_alarm_reg ;
   u64 frf_alarm_mask ;
   u64 frf_alarm_alarm ;
   u64 rocrc_alarm_reg ;
   u64 rocrc_alarm_mask ;
   u64 rocrc_alarm_alarm ;
   u64 wde0_alarm_reg ;
   u64 wde0_alarm_mask ;
   u64 wde0_alarm_alarm ;
   u64 wde1_alarm_reg ;
   u64 wde1_alarm_mask ;
   u64 wde1_alarm_alarm ;
   u64 wde2_alarm_reg ;
   u64 wde2_alarm_mask ;
   u64 wde2_alarm_alarm ;
   u64 wde3_alarm_reg ;
   u64 wde3_alarm_mask ;
   u64 wde3_alarm_alarm ;
   u8 unused00be8[136U] ;
   u64 rx_w_round_robin_0 ;
   u64 rx_w_round_robin_1 ;
   u64 rx_w_round_robin_2 ;
   u64 rx_w_round_robin_3 ;
   u64 rx_w_round_robin_4 ;
   u64 rx_w_round_robin_5 ;
   u64 rx_w_round_robin_6 ;
   u64 rx_w_round_robin_7 ;
   u64 rx_w_round_robin_8 ;
   u64 rx_w_round_robin_9 ;
   u64 rx_w_round_robin_10 ;
   u64 rx_w_round_robin_11 ;
   u64 rx_w_round_robin_12 ;
   u64 rx_w_round_robin_13 ;
   u64 rx_w_round_robin_14 ;
   u64 rx_w_round_robin_15 ;
   u64 rx_w_round_robin_16 ;
   u64 rx_w_round_robin_17 ;
   u64 rx_w_round_robin_18 ;
   u64 rx_w_round_robin_19 ;
   u64 rx_w_round_robin_20 ;
   u64 rx_w_round_robin_21 ;
   u64 rx_queue_priority_0 ;
   u64 rx_queue_priority_1 ;
   u64 rx_queue_priority_2 ;
   u8 unused00cc8[24U] ;
   u64 replication_queue_priority ;
   u64 rx_queue_select ;
   u64 rqa_vpbp_ctrl ;
   u64 rx_multi_cast_ctrl ;
   u64 wde_prm_ctrl ;
   u64 noa_ctrl ;
   u64 phase_cfg ;
   u64 rcq_bypq_cfg ;
   u8 unused00e00[248U] ;
   u64 doorbell_int_status ;
   u64 doorbell_int_mask ;
   u64 kdfc_err_reg ;
   u64 kdfc_err_mask ;
   u64 kdfc_err_reg_alarm ;
   u8 unused00e40[24U] ;
   u64 kdfc_vp_partition_0 ;
   u64 kdfc_vp_partition_1 ;
   u64 kdfc_vp_partition_2 ;
   u64 kdfc_vp_partition_3 ;
   u64 kdfc_vp_partition_4 ;
   u64 kdfc_vp_partition_5 ;
   u64 kdfc_vp_partition_6 ;
   u64 kdfc_vp_partition_7 ;
   u64 kdfc_vp_partition_8 ;
   u64 kdfc_w_round_robin_0 ;
   u8 unused0f28[152U] ;
   u64 kdfc_w_round_robin_20 ;
   u8 unused0fc8[152U] ;
   u64 kdfc_w_round_robin_40 ;
   u8 unused1068[152U] ;
   u64 kdfc_entry_type_sel_0 ;
   u64 kdfc_entry_type_sel_1 ;
   u64 kdfc_fifo_0_ctrl ;
   u8 unused1100[128U] ;
   u64 kdfc_fifo_17_ctrl ;
   u8 unused1600[1272U] ;
   u64 rxmac_int_status ;
   u64 rxmac_int_mask ;
   u8 unused01618[8U] ;
   u64 rxmac_gen_err_reg ;
   u64 rxmac_gen_err_mask ;
   u64 rxmac_gen_err_alarm ;
   u64 rxmac_ecc_err_reg ;
   u64 rxmac_ecc_err_mask ;
   u64 rxmac_ecc_err_alarm ;
   u64 rxmac_various_err_reg ;
   u64 rxmac_various_err_mask ;
   u64 rxmac_various_err_alarm ;
   u64 rxmac_gen_cfg ;
   u64 rxmac_authorize_all_addr ;
   u64 rxmac_authorize_all_vid ;
   u8 unused016c0[72U] ;
   u64 rxmac_red_rate_repl_queue ;
   u8 unused016e0[24U] ;
   u64 rxmac_cfg0_port[3U] ;
   u8 unused01710[24U] ;
   u64 rxmac_cfg2_port[3U] ;
   u64 rxmac_pause_cfg_port[3U] ;
   u8 unused01758[24U] ;
   u64 rxmac_red_cfg0_port[3U] ;
   u64 rxmac_red_cfg1_port[3U] ;
   u64 rxmac_red_cfg2_port[3U] ;
   u64 rxmac_link_util_port[3U] ;
   u8 unused017d0[24U] ;
   u64 rxmac_status_port[3U] ;
   u8 unused01800[24U] ;
   u64 rxmac_rx_pa_cfg0 ;
   u64 rxmac_rx_pa_cfg1 ;
   u8 unused01828[24U] ;
   u64 rts_mgr_cfg0 ;
   u64 rts_mgr_cfg1 ;
   u64 rts_mgr_criteria_priority ;
   u64 rts_mgr_da_pause_cfg ;
   u64 rts_mgr_da_slow_proto_cfg ;
   u8 unused01890[64U] ;
   u64 rts_mgr_cbasin_cfg ;
   u8 unused01968[208U] ;
   u64 dbg_stat_rx_any_frms ;
   u8 unused01a00[144U] ;
   u64 rxmac_red_rate_vp[17U] ;
   u8 unused01e00[888U] ;
   u64 xgmac_int_status ;
   u64 xgmac_int_mask ;
   u64 xmac_gen_err_reg ;
   u64 xmac_gen_err_mask ;
   u64 xmac_gen_err_alarm ;
   u64 xmac_link_err_port0_reg ;
   u64 xmac_link_err_port0_mask ;
   u64 xmac_link_err_port0_alarm ;
   u64 xmac_link_err_port1_reg ;
   u64 xmac_link_err_port1_mask ;
   u64 xmac_link_err_port1_alarm ;
   u64 xgxs_gen_err_reg ;
   u64 xgxs_gen_err_mask ;
   u64 xgxs_gen_err_alarm ;
   u64 asic_ntwk_err_reg ;
   u64 asic_ntwk_err_mask ;
   u64 asic_ntwk_err_alarm ;
   u64 asic_gpio_err_reg ;
   u64 asic_gpio_err_mask ;
   u64 asic_gpio_err_alarm ;
   u64 xgmac_gen_status ;
   u64 xgmac_gen_fw_memo_status ;
   u64 xgmac_gen_fw_memo_mask ;
   u64 xgmac_gen_fw_vpath_to_vsport_status ;
   u64 xgmac_main_cfg_port[2U] ;
   u8 unused01f40[112U] ;
   u64 xmac_gen_cfg ;
   u64 xmac_timestamp ;
   u64 xmac_stats_gen_cfg ;
   u64 xmac_stats_sys_cmd ;
   u64 xmac_stats_sys_data ;
   u8 unused01f80[24U] ;
   u64 asic_ntwk_ctrl ;
   u64 asic_ntwk_cfg_show_port_info ;
   u64 asic_ntwk_cfg_port_num ;
   u64 xmac_cfg_port[3U] ;
   u64 xmac_station_addr_port[2U] ;
   u8 unused02020[96U] ;
   u64 lag_cfg ;
   u64 lag_status ;
   u64 lag_active_passive_cfg ;
   u8 unused02040[8U] ;
   u64 lag_lacp_cfg ;
   u64 lag_timer_cfg_1 ;
   u64 lag_timer_cfg_2 ;
   u64 lag_sys_id ;
   u64 lag_sys_cfg ;
   u8 unused02070[8U] ;
   u64 lag_aggr_addr_cfg[2U] ;
   u64 lag_aggr_id_cfg[2U] ;
   u64 lag_aggr_admin_key[2U] ;
   u64 lag_aggr_alt_admin_key ;
   u64 lag_aggr_oper_key[2U] ;
   u64 lag_aggr_partner_sys_id[2U] ;
   u64 lag_aggr_partner_info[2U] ;
   u64 lag_aggr_state[2U] ;
   u8 unused020f0[8U] ;
   u64 lag_port_cfg[2U] ;
   u64 lag_port_actor_admin_cfg[2U] ;
   u64 lag_port_actor_admin_state[2U] ;
   u64 lag_port_partner_admin_sys_id[2U] ;
   u64 lag_port_partner_admin_cfg[2U] ;
   u64 lag_port_partner_admin_state[2U] ;
   u64 lag_port_to_aggr[2U] ;
   u64 lag_port_actor_oper_key[2U] ;
   u64 lag_port_actor_oper_state[2U] ;
   u64 lag_port_partner_oper_sys_id[2U] ;
   u64 lag_port_partner_oper_info[2U] ;
   u64 lag_port_partner_oper_state[2U] ;
   u64 lag_port_state_vars[2U] ;
   u64 lag_port_timer_cntr[2U] ;
   u8 unused02208[1328U] ;
   u64 rtdma_int_status ;
   u64 rtdma_int_mask ;
   u64 pda_alarm_reg ;
   u64 pda_alarm_mask ;
   u64 pda_alarm_alarm ;
   u64 pcc_error_reg ;
   u64 pcc_error_mask ;
   u64 pcc_error_alarm ;
   u64 lso_error_reg ;
   u64 lso_error_mask ;
   u64 lso_error_alarm ;
   u64 sm_error_reg ;
   u64 sm_error_mask ;
   u64 sm_error_alarm ;
   u8 unused027a8[56U] ;
   u64 txd_ownership_ctrl ;
   u64 pcc_cfg ;
   u64 pcc_control ;
   u64 pda_status1 ;
   u64 rtdma_bw_timer ;
   u8 unused02900[304U] ;
   u64 g3cmct_int_status ;
   u64 g3cmct_int_mask ;
   u64 g3cmct_err_reg ;
   u64 g3cmct_err_mask ;
   u64 g3cmct_err_alarm ;
   u8 unused03000[1752U] ;
   u64 mc_int_status ;
   u64 mc_int_mask ;
   u64 mc_err_reg ;
   u64 mc_err_mask ;
   u64 mc_err_alarm ;
   u64 grocrc_alarm_reg ;
   u64 grocrc_alarm_mask ;
   u64 grocrc_alarm_alarm ;
   u8 unused03100[192U] ;
   u64 rx_thresh_cfg_repl ;
   u8 unused033b8[688U] ;
   u64 fbmc_ecc_cfg ;
   u8 unused03400[64U] ;
   u64 pcipif_int_status ;
   u64 pcipif_int_mask ;
   u64 dbecc_err_reg ;
   u64 dbecc_err_mask ;
   u64 dbecc_err_alarm ;
   u64 sbecc_err_reg ;
   u64 sbecc_err_mask ;
   u64 sbecc_err_alarm ;
   u64 general_err_reg ;
   u64 general_err_mask ;
   u64 general_err_alarm ;
   u64 srpcim_msg_reg ;
   u64 srpcim_msg_mask ;
   u64 srpcim_msg_alarm ;
   u8 unused03600[400U] ;
   u64 gcmg1_int_status ;
   u64 gcmg1_int_mask ;
   u8 unused03a00[1008U] ;
   u64 pcmg1_int_status ;
   u64 pcmg1_int_mask ;
   u8 unused04000[1520U] ;
   u64 one_int_status ;
   u64 one_int_mask ;
   u8 unused04818[2056U] ;
   u64 noa_wct_ctrl ;
   u64 rc_cfg2 ;
   u64 rc_cfg3 ;
   u64 rx_multi_cast_ctrl1 ;
   u64 rxdm_dbg_rd ;
   u64 rxdm_dbg_rd_data ;
   u64 rqa_top_prty_for_vh[17U] ;
   u8 unused04900[48U] ;
   u64 tim_status ;
   u64 tim_ecc_enable ;
   u64 tim_bp_ctrl ;
   u64 tim_resource_assignment_vh[17U] ;
   u64 tim_bmap_mapping_vp_err[17U] ;
   u8 unused04b00[216U] ;
   u64 gcmg2_int_status ;
   u64 gcmg2_int_mask ;
   u64 gxtmc_err_reg ;
   u64 gxtmc_err_mask ;
   u64 gxtmc_err_alarm ;
   u64 cmc_err_reg ;
   u64 cmc_err_mask ;
   u64 cmc_err_alarm ;
   u64 gcp_err_reg ;
   u64 gcp_err_mask ;
   u64 gcp_err_alarm ;
   u8 unused04f00[936U] ;
   u64 pcmg2_int_status ;
   u64 pcmg2_int_mask ;
   u64 pxtmc_err_reg ;
   u64 pxtmc_err_mask ;
   u64 pxtmc_err_alarm ;
   u64 cp_err_reg ;
   u64 cp_err_mask ;
   u64 cp_err_alarm ;
   u8 unused04fe8[16U] ;
   u64 cp_exc_reg ;
   u64 cp_exc_mask ;
   u64 cp_exc_alarm ;
   u64 cp_exc_cause ;
   u8 unused05200[656U] ;
   u64 msg_int_status ;
   u64 msg_int_mask ;
   u64 tim_err_reg ;
   u64 tim_err_mask ;
   u64 tim_err_alarm ;
   u64 msg_err_reg ;
   u64 msg_err_mask ;
   u64 msg_err_alarm ;
   u8 unused05340[256U] ;
   u64 msg_exc_reg ;
   u64 msg_exc_mask ;
   u64 msg_exc_alarm ;
   u64 msg_exc_cause ;
   u8 unused05368[32U] ;
   u64 msg_err2_reg ;
   u64 msg_err2_mask ;
   u64 msg_err2_alarm ;
   u64 msg_err3_reg ;
   u64 msg_err3_mask ;
   u64 msg_err3_alarm ;
   u8 unused05600[592U] ;
   u64 fau_gen_err_reg ;
   u64 fau_gen_err_mask ;
   u64 fau_gen_err_alarm ;
   u64 fau_ecc_err_reg ;
   u64 fau_ecc_err_mask ;
   u64 fau_ecc_err_alarm ;
   u8 unused05658[40U] ;
   u64 fau_pa_cfg ;
   u8 unused05668[8U] ;
   u64 dbg_stats_fau_rx_path ;
   u8 unused056c0[80U] ;
   u64 fau_lag_cfg ;
   u8 unused05800[312U] ;
   u64 tpa_int_status ;
   u64 tpa_int_mask ;
   u64 orp_err_reg ;
   u64 orp_err_mask ;
   u64 orp_err_alarm ;
   u64 ptm_alarm_reg ;
   u64 ptm_alarm_mask ;
   u64 ptm_alarm_alarm ;
   u64 tpa_error_reg ;
   u64 tpa_error_mask ;
   u64 tpa_error_alarm ;
   u64 tpa_global_cfg ;
   u8 unused05868[16U] ;
   u64 ptm_ecc_cfg ;
   u64 ptm_phase_cfg ;
   u8 unused05898[24U] ;
   u64 dbg_stats_tpa_tx_path ;
   u8 unused05900[96U] ;
   u64 tmac_int_status ;
   u64 tmac_int_mask ;
   u64 txmac_gen_err_reg ;
   u64 txmac_gen_err_mask ;
   u64 txmac_gen_err_alarm ;
   u64 txmac_ecc_err_reg ;
   u64 txmac_ecc_err_mask ;
   u64 txmac_ecc_err_alarm ;
   u8 unused05978[56U] ;
   u64 dbg_stat_tx_any_frms ;
   u8 unused059a0[32U] ;
   u64 txmac_link_util_port[3U] ;
   u64 txmac_cfg0_port[3U] ;
   u64 txmac_cfg1_port[3U] ;
   u64 txmac_status_port[3U] ;
   u8 unused05a20[32U] ;
   u64 lag_distrib_dest ;
   u64 lag_marker_cfg ;
   u64 lag_tx_cfg ;
   u64 lag_tx_status ;
   u8 unused05d48[776U] ;
   u64 srpcim_to_mrpcim_vplane_rmsg[17U] ;
   u8 unused06420[1616U] ;
   u64 mrpcim_to_srpcim_vplane_wmsg[17U] ;
   u64 mrpcim_to_srpcim_vplane_wmsg_trig[17U] ;
   u64 debug_stats0 ;
   u64 debug_stats1 ;
   u64 debug_stats2 ;
   u64 debug_stats3_vplane[17U] ;
   u64 debug_stats4_vplane[17U] ;
   u8 unused07000[2472U] ;
   u64 mrpcim_general_int_status ;
   u64 mrpcim_general_int_mask ;
   u64 mrpcim_ppif_int_status ;
   u64 mrpcim_ppif_int_mask ;
   u8 unused07028[8U] ;
   u64 ini_errors_reg ;
   u64 ini_errors_mask ;
   u64 ini_errors_alarm ;
   u64 dma_errors_reg ;
   u64 dma_errors_mask ;
   u64 dma_errors_alarm ;
   u64 tgt_errors_reg ;
   u64 tgt_errors_mask ;
   u64 tgt_errors_alarm ;
   u64 config_errors_reg ;
   u64 config_errors_mask ;
   u64 config_errors_alarm ;
   u8 unused07090[8U] ;
   u64 crdt_errors_reg ;
   u64 crdt_errors_mask ;
   u64 crdt_errors_alarm ;
   u8 unused070b0[8U] ;
   u64 mrpcim_general_errors_reg ;
   u64 mrpcim_general_errors_mask ;
   u64 mrpcim_general_errors_alarm ;
   u8 unused070d0[8U] ;
   u64 pll_errors_reg ;
   u64 pll_errors_mask ;
   u64 pll_errors_alarm ;
   u64 srpcim_to_mrpcim_alarm_reg ;
   u64 srpcim_to_mrpcim_alarm_mask ;
   u64 srpcim_to_mrpcim_alarm_alarm ;
   u64 vpath_to_mrpcim_alarm_reg ;
   u64 vpath_to_mrpcim_alarm_mask ;
   u64 vpath_to_mrpcim_alarm_alarm ;
   u8 unused07128[16U] ;
   u64 crdt_errors_vplane_reg[17U] ;
   u64 crdt_errors_vplane_mask[17U] ;
   u64 crdt_errors_vplane_alarm[17U] ;
   u8 unused072f0[48U] ;
   u64 mrpcim_rst_in_prog ;
   u64 mrpcim_reg_modified ;
   u8 unused07378[120U] ;
   u64 write_arb_pending ;
   u64 read_arb_pending ;
   u64 dmaif_dmadbl_pending ;
   u64 wrcrdtarb_status0_vplane[17U] ;
   u64 wrcrdtarb_status1_vplane[17U] ;
   u8 unused07500[96U] ;
   u64 mrpcim_general_cfg1 ;
   u64 mrpcim_general_cfg2 ;
   u64 mrpcim_general_cfg3 ;
   u64 mrpcim_stats_start_host_addr ;
   u8 unused07950[1072U] ;
   u64 rdcrdtarb_cfg0 ;
   u8 unused07be8[656U] ;
   u64 bf_sw_reset ;
   u64 sw_reset_status ;
   u8 unused07d30[312U] ;
   u64 mrpcim_debug_stats0 ;
   u64 mrpcim_debug_stats1_vplane[17U] ;
   u64 mrpcim_debug_stats2_vplane[17U] ;
   u64 mrpcim_debug_stats3_vplane[17U] ;
   u64 mrpcim_debug_stats4 ;
   u64 genstats_count01 ;
   u64 genstats_count23 ;
   u64 genstats_count4 ;
   u64 genstats_count5 ;
   u8 unused07f08[16U] ;
   u64 genstats_cfg[6U] ;
   u64 genstat_64bit_cfg ;
   u8 unused08000[192U] ;
   u64 gcmg3_int_status ;
   u64 gcmg3_int_mask ;
   u8 unused09000[4080U] ;
   u64 g3ifcmd_fb_int_status ;
   u64 g3ifcmd_fb_int_mask ;
   u64 g3ifcmd_fb_err_reg ;
   u64 g3ifcmd_fb_err_mask ;
   u64 g3ifcmd_fb_err_alarm ;
   u8 unused09400[984U] ;
   u64 g3ifcmd_cmu_int_status ;
   u64 g3ifcmd_cmu_int_mask ;
   u64 g3ifcmd_cmu_err_reg ;
   u64 g3ifcmd_cmu_err_mask ;
   u64 g3ifcmd_cmu_err_alarm ;
   u8 unused09800[984U] ;
   u64 g3ifcmd_cml_int_status ;
   u64 g3ifcmd_cml_int_mask ;
   u64 g3ifcmd_cml_err_reg ;
   u64 g3ifcmd_cml_err_mask ;
   u64 g3ifcmd_cml_err_alarm ;
   u8 unused09b00[728U] ;
   u64 vpath_to_vplane_map[17U] ;
   u8 unused09c30[168U] ;
   u64 xgxs_cfg_port[2U] ;
   u64 xgxs_rxber_cfg_port[2U] ;
   u64 xgxs_rxber_status_port[2U] ;
   u64 xgxs_status_port[2U] ;
   u64 xgxs_pma_reset_port[2U] ;
   u8 unused09c90[16U] ;
   u64 xgxs_static_cfg_port[2U] ;
   u8 unused09d40[160U] ;
   u64 xgxs_info_port[2U] ;
   u64 ratemgmt_cfg_port[2U] ;
   u64 ratemgmt_status_port[2U] ;
   u8 unused09d80[16U] ;
   u64 ratemgmt_fixed_cfg_port[2U] ;
   u64 ratemgmt_antp_cfg_port[2U] ;
   u64 ratemgmt_anbe_cfg_port[2U] ;
   u64 anbe_cfg_port[2U] ;
   u64 anbe_mgr_ctrl_port[2U] ;
   u8 unused09de0[16U] ;
   u64 anbe_fw_mstr_port[2U] ;
   u64 anbe_hwfsm_gen_status_port[2U] ;
   u64 anbe_hwfsm_bp_status_port[2U] ;
   u64 anbe_hwfsm_np_status_port[2U] ;
   u8 unused09e30[16U] ;
   u64 antp_gen_cfg_port[2U] ;
   u64 antp_hwfsm_gen_status_port[2U] ;
   u64 antp_hwfsm_bp_status_port[2U] ;
   u64 antp_hwfsm_xnp_status_port[2U] ;
   u64 mdio_mgr_access_port[2U] ;
   u8 unused0a200[896U] ;
   u64 xmac_vsport_choices_vh[17U] ;
   u8 unused0a400[376U] ;
   u64 rx_thresh_cfg_vp[17U] ;
   u8 unused0ac90[2056U] ;
};

#line 3607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-reg.h"
struct vxge_hw_srpcim_reg {
   u64 tim_mr2sr_resource_assignment_vh ;
   u8 unused00100[248U] ;
   u64 srpcim_pcipif_int_status ;
   u64 srpcim_pcipif_int_mask ;
   u64 mrpcim_msg_reg ;
   u64 mrpcim_msg_mask ;
   u64 mrpcim_msg_alarm ;
   u64 vpath_msg_reg ;
   u64 vpath_msg_mask ;
   u64 vpath_msg_alarm ;
   u8 unused00160[32U] ;
   u64 srpcim_to_mrpcim_wmsg ;
   u64 srpcim_to_mrpcim_wmsg_trig ;
   u64 mrpcim_to_srpcim_rmsg ;
   u64 vpath_to_srpcim_rmsg_sel ;
   u64 vpath_to_srpcim_rmsg ;
   u8 unused00200[120U] ;
   u64 srpcim_general_int_status ;
   u8 unused00210[8U] ;
   u64 srpcim_general_int_mask ;
   u8 unused00220[8U] ;
   u64 srpcim_ppif_int_status ;
   u64 srpcim_ppif_int_mask ;
   u64 srpcim_gen_errors_reg ;
   u64 srpcim_gen_errors_mask ;
   u64 srpcim_gen_errors_alarm ;
   u64 mrpcim_to_srpcim_alarm_reg ;
   u64 mrpcim_to_srpcim_alarm_mask ;
   u64 mrpcim_to_srpcim_alarm_alarm ;
   u64 vpath_to_srpcim_alarm_reg ;
   u64 vpath_to_srpcim_alarm_mask ;
   u64 vpath_to_srpcim_alarm_alarm ;
   u8 unused00280[8U] ;
   u64 pf_sw_reset ;
   u64 srpcim_general_cfg1 ;
   u64 srpcim_interrupt_cfg1 ;
   u8 unused002a8[16U] ;
   u64 srpcim_clear_msix_mask ;
   u64 srpcim_set_msix_mask ;
   u64 srpcim_clr_msix_one_shot ;
   u64 srpcim_rst_in_prog ;
   u64 srpcim_reg_modified ;
   u64 tgt_pf_illegal_access ;
   u64 srpcim_msix_status ;
   u8 unused00880[1440U] ;
   u64 xgmac_sr_int_status ;
   u64 xgmac_sr_int_mask ;
   u64 asic_ntwk_sr_err_reg ;
   u64 asic_ntwk_sr_err_mask ;
   u64 asic_ntwk_sr_err_alarm ;
   u8 unused008c0[24U] ;
   u64 xmac_vsport_choices_sr_clone ;
   u8 unused00900[56U] ;
   u64 mr_rqa_top_prty_for_vh ;
   u64 umq_vh_data_list_empty ;
   u64 wde_cfg ;
};

#line 3755  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-reg.h"
struct vxge_hw_vpmgmt_reg {
   u8 unused00040[64U] ;
   u64 vpath_to_func_map_cfg1 ;
   u64 vpath_is_first ;
   u64 srpcim_to_vpath_wmsg ;
   u64 srpcim_to_vpath_wmsg_trig ;
   u8 unused00100[160U] ;
   u64 tim_vpath_assignment ;
   u8 unused00140[56U] ;
   u64 rqa_top_prty_for_vp ;
   u8 unused001c0[120U] ;
   u64 rxmac_rx_pa_cfg0_vpmgmt_clone ;
   u64 rts_mgr_cfg0_vpmgmt_clone ;
   u64 rts_mgr_criteria_priority_vpmgmt_clone ;
   u64 rxmac_cfg0_port_vpmgmt_clone[3U] ;
   u64 rxmac_pause_cfg_port_vpmgmt_clone[3U] ;
   u8 unused00240[56U] ;
   u64 xmac_vsport_choices_vp ;
   u8 unused00260[24U] ;
   u64 xgmac_gen_status_vpmgmt_clone ;
   u64 xgmac_status_port_vpmgmt_clone[2U] ;
   u64 xmac_gen_cfg_vpmgmt_clone ;
   u64 xmac_timestamp_vpmgmt_clone ;
   u64 xmac_stats_gen_cfg_vpmgmt_clone ;
   u64 xmac_cfg_port_vpmgmt_clone[3U] ;
   u8 unused002c0[24U] ;
   u64 txmac_gen_cfg0_vpmgmt_clone ;
   u64 txmac_cfg0_port_vpmgmt_clone[3U] ;
   u8 unused00300[32U] ;
   u64 wol_mp_crc ;
   u64 wol_mp_mask_a ;
   u64 wol_mp_mask_b ;
   u8 unused00360[72U] ;
   u64 fau_pa_cfg_vpmgmt_clone ;
   u64 rx_datapath_util_vp_clone ;
   u8 unused00380[16U] ;
   u64 tx_datapath_util_vp_clone ;
};

#line 3969  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-reg.h"
struct vxge_hw_vpath_reg {
   u8 unused00300[768U] ;
   u64 usdc_vpath ;
   u8 unused00a00[1784U] ;
   u64 wrdma_alarm_status ;
   u64 wrdma_alarm_mask ;
   u8 unused00a30[32U] ;
   u64 prc_alarm_reg ;
   u64 prc_alarm_mask ;
   u64 prc_alarm_alarm ;
   u64 prc_cfg1 ;
   u8 unused00a60[16U] ;
   u64 prc_cfg4 ;
   u64 prc_cfg5 ;
   u64 prc_cfg6 ;
   u64 prc_cfg7 ;
   u64 tim_dest_addr ;
   u64 prc_rxd_doorbell ;
   u64 rqa_prty_for_vp ;
   u64 rxdmem_size ;
   u64 frm_in_progress_cnt ;
   u64 rx_multi_cast_stats ;
   u64 rx_frm_transferred ;
   u64 rxd_returned ;
   u8 unused00c00[320U] ;
   u64 kdfc_fifo_trpl_partition ;
   u64 kdfc_fifo_trpl_ctrl ;
   u64 kdfc_trpl_fifo_0_ctrl ;
   u64 kdfc_trpl_fifo_1_ctrl ;
   u64 kdfc_trpl_fifo_2_ctrl ;
   u64 kdfc_trpl_fifo_0_wb_address ;
   u64 kdfc_trpl_fifo_1_wb_address ;
   u64 kdfc_trpl_fifo_2_wb_address ;
   u64 kdfc_trpl_fifo_offset ;
   u64 kdfc_drbl_triplet_total ;
   u8 unused00c60[16U] ;
   u64 usdc_drbl_ctrl ;
   u64 usdc_vp_ready ;
   u64 kdfc_status ;
   u8 unused00c80[8U] ;
   u64 xmac_rpa_vcfg ;
   u64 rxmac_vcfg0 ;
   u64 rxmac_vcfg1 ;
   u64 rts_access_steer_ctrl ;
   u64 rts_access_steer_data0 ;
   u64 rts_access_steer_data1 ;
   u8 unused00d00[80U] ;
   u64 xmac_vsport_choice ;
   u64 xmac_stats_cfg ;
   u64 xmac_stats_access_cmd ;
   u64 xmac_stats_access_data ;
   u64 asic_ntwk_vp_ctrl ;
   u8 unused00d30[8U] ;
   u64 xgmac_vp_int_status ;
   u64 xgmac_vp_int_mask ;
   u64 asic_ntwk_vp_err_reg ;
   u64 asic_ntwk_vp_err_mask ;
   u64 asic_ntwk_vp_err_alarm ;
   u8 unused00d80[40U] ;
   u64 rtdma_bw_ctrl ;
   u64 rtdma_rd_optimization_ctrl ;
   u64 pda_pcc_job_monitor ;
   u64 tx_protocol_assist_cfg ;
   u8 unused01000[608U] ;
   u64 tim_cfg1_int_num[4U] ;
   u64 tim_cfg2_int_num[4U] ;
   u64 tim_cfg3_int_num[4U] ;
   u64 tim_wrkld_clc ;
   u64 tim_bitmap ;
   u64 tim_ring_assn ;
   u64 tim_remap ;
   u64 tim_vpath_map ;
   u64 tim_pci_cfg ;
   u8 unused01100[112U] ;
   u64 sgrp_assign ;
   u64 sgrp_aoa_and_result ;
   u64 rpe_pci_cfg ;
   u64 rpe_lro_cfg ;
   u64 pe_mr2vp_ack_blk_limit ;
   u64 pe_mr2vp_rirr_lirr_blk_limit ;
   u64 txpe_pci_nce_cfg ;
   u8 unused01180[72U] ;
   u64 msg_qpad_en_cfg ;
   u64 msg_pci_cfg ;
   u64 umqdmq_ir_init ;
   u64 dmq_ir_int ;
   u64 dmq_bwr_init_add ;
   u64 dmq_bwr_init_byte ;
   u64 dmq_ir ;
   u64 umq_int ;
   u64 umq_mr2vp_bwr_pfch_init ;
   u64 umq_bwr_pfch_ctrl ;
   u64 umq_mr2vp_bwr_eol ;
   u64 umq_bwr_init_add ;
   u64 umq_bwr_init_byte ;
   u64 gendma_int ;
   u64 umqdmq_ir_init_notify ;
   u64 dmq_init_notify ;
   u64 umq_init_notify ;
   u8 unused01380[376U] ;
   u64 tpa_cfg ;
   u8 unused01400[120U] ;
   u64 tx_vp_reset_discarded_frms ;
   u8 unused01480[120U] ;
   u64 fau_rpa_vcfg ;
   u8 unused014d0[72U] ;
   u64 dbg_stats_rx_mpa ;
   u64 dbg_stats_rx_fau ;
   u8 unused014f0[16U] ;
   u64 fbmc_vp_rdy ;
   u8 unused01e00[2312U] ;
   u64 vpath_pcipif_int_status ;
   u64 vpath_pcipif_int_mask ;
   u8 unused01e20[16U] ;
   u64 srpcim_msg_to_vpath_reg ;
   u64 srpcim_msg_to_vpath_mask ;
   u64 srpcim_msg_to_vpath_alarm ;
   u8 unused01ea0[104U] ;
   u64 vpath_to_srpcim_wmsg ;
   u64 vpath_to_srpcim_wmsg_trig ;
   u8 unused02000[336U] ;
   u64 vpath_general_int_status ;
   u64 vpath_general_int_mask ;
   u64 vpath_ppif_int_status ;
   u64 vpath_ppif_int_mask ;
   u64 kdfcctl_errors_reg ;
   u64 kdfcctl_errors_mask ;
   u64 kdfcctl_errors_alarm ;
   u8 unused02040[8U] ;
   u64 general_errors_reg ;
   u64 general_errors_mask ;
   u64 general_errors_alarm ;
   u64 pci_config_errors_reg ;
   u64 pci_config_errors_mask ;
   u64 pci_config_errors_alarm ;
   u64 mrpcim_to_vpath_alarm_reg ;
   u64 mrpcim_to_vpath_alarm_mask ;
   u64 mrpcim_to_vpath_alarm_alarm ;
   u64 srpcim_to_vpath_alarm_reg ;
   u64 srpcim_to_vpath_alarm_mask ;
   u64 srpcim_to_vpath_alarm_alarm ;
   u8 unused02108[104U] ;
   u64 kdfcctl_status ;
   u64 rsthdlr_status ;
   u64 fifo0_status ;
   u64 fifo1_status ;
   u64 fifo2_status ;
   u8 unused02158[40U] ;
   u64 tgt_illegal_access ;
   u8 unused02200[160U] ;
   u64 vpath_general_cfg1 ;
   u64 vpath_general_cfg2 ;
   u64 vpath_general_cfg3 ;
   u8 unused02220[8U] ;
   u64 kdfcctl_cfg0 ;
   u8 unused02268[64U] ;
   u64 stats_cfg ;
   u64 interrupt_cfg0 ;
   u8 unused02280[8U] ;
   u64 interrupt_cfg2 ;
   u64 one_shot_vect0_en ;
   u64 one_shot_vect1_en ;
   u64 one_shot_vect2_en ;
   u64 one_shot_vect3_en ;
   u8 unused022b0[8U] ;
   u64 pci_config_access_cfg1 ;
   u64 pci_config_access_cfg2 ;
   u64 pci_config_access_status ;
   u8 unused02300[56U] ;
   u64 vpath_debug_stats0 ;
   u64 vpath_debug_stats1 ;
   u64 vpath_debug_stats2 ;
   u64 vpath_debug_stats3 ;
   u64 vpath_debug_stats4 ;
   u64 vpath_debug_stats5 ;
   u64 vpath_debug_stats6 ;
   u64 vpath_genstats_count01 ;
   u64 vpath_genstats_count23 ;
   u64 vpath_genstats_count4 ;
   u64 vpath_genstats_count5 ;
   u8 unused02648[752U] ;
};

#line 4628 
struct __vxge_hw_device;

#line 4629 
struct __vxge_hw_vpath_handle;

#line 4630 
struct vxge_hw_vp_config;

#line 4631 
struct __vxge_hw_virtualpath;

#line 4632 
struct __vxge_hw_channel;

#line 4633 
struct __vxge_hw_fifo;

#line 4634 
struct __vxge_hw_ring;

#line 4636 
struct vxge_hw_mempool;

#line 4637 
enum vxge_hw_event {
    VXGE_HW_EVENT_UNKNOWN = 0,
    VXGE_HW_EVENT_RESET_START = 1,
    VXGE_HW_EVENT_RESET_COMPLETE = 2,
    VXGE_HW_EVENT_LINK_DOWN = 3,
    VXGE_HW_EVENT_LINK_UP = 4,
    VXGE_HW_EVENT_ALARM_CLEARED = 5,
    VXGE_HW_EVENT_ECCERR = 6,
    VXGE_HW_EVENT_MRPCIM_ECCERR = 7,
    VXGE_HW_EVENT_FIFO_ERR = 8,
    VXGE_HW_EVENT_VPATH_ERR = 9,
    VXGE_HW_EVENT_CRITICAL_ERR = 10,
    VXGE_HW_EVENT_SERR = 11,
    VXGE_HW_EVENT_SRPCIM_SERR = 12,
    VXGE_HW_EVENT_MRPCIM_SERR = 13,
    VXGE_HW_EVENT_SLOT_FREEZE = 14
};

#line 4655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-reg.h"
struct vxge_hw_mempool_dma {
   dma_addr_t addr ;
   struct pci_dev *handle ;
   struct pci_dev *acc_handle ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_mempool {
   void (*item_func_alloc)(struct vxge_hw_mempool *, u32 , struct vxge_hw_mempool_dma *, u32 , u32 ) ;
   void *userdata ;
   void **memblocks_arr ;
   void **memblocks_priv_arr ;
   struct vxge_hw_mempool_dma *memblocks_dma_arr ;
   struct __vxge_hw_device *devh ;
   u32 memblock_size ;
   u32 memblocks_max ;
   u32 memblocks_allocated ;
   u32 item_size ;
   u32 items_max ;
   u32 items_initial ;
   u32 items_current ;
   u32 items_per_memblock ;
   void **items_arr ;
   u32 items_priv_size ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_tim_intr_config {
   u32 intr_enable ;
   u32 btimer_val ;
   u32 timer_ac_en ;
   u32 timer_ci_en ;
   u32 timer_ri_en ;
   u32 rtimer_val ;
   u32 util_sel ;
   u32 ltimer_val ;
   u32 urange_a ;
   u32 uec_a ;
   u32 urange_b ;
   u32 uec_b ;
   u32 urange_c ;
   u32 uec_c ;
   u32 uec_d ;
};

#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_xmac_aggr_stats {
   u64 tx_frms ;
   u64 tx_data_octets ;
   u64 tx_mcast_frms ;
   u64 tx_bcast_frms ;
   u64 tx_discarded_frms ;
   u64 tx_errored_frms ;
   u64 rx_frms ;
   u64 rx_data_octets ;
   u64 rx_mcast_frms ;
   u64 rx_bcast_frms ;
   u64 rx_discarded_frms ;
   u64 rx_errored_frms ;
   u64 rx_unknown_slow_proto_frms ;
};

#line 399  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_xmac_port_stats {
   u64 tx_ttl_frms ;
   u64 tx_ttl_octets ;
   u64 tx_data_octets ;
   u64 tx_mcast_frms ;
   u64 tx_bcast_frms ;
   u64 tx_ucast_frms ;
   u64 tx_tagged_frms ;
   u64 tx_vld_ip ;
   u64 tx_vld_ip_octets ;
   u64 tx_icmp ;
   u64 tx_tcp ;
   u64 tx_rst_tcp ;
   u64 tx_udp ;
   u32 tx_parse_error ;
   u32 tx_unknown_protocol ;
   u64 tx_pause_ctrl_frms ;
   u32 tx_marker_pdu_frms ;
   u32 tx_lacpdu_frms ;
   u32 tx_drop_ip ;
   u32 tx_marker_resp_pdu_frms ;
   u32 tx_xgmii_char2_match ;
   u32 tx_xgmii_char1_match ;
   u32 tx_xgmii_column2_match ;
   u32 tx_xgmii_column1_match ;
   u32 unused1 ;
   u16 tx_any_err_frms ;
   u16 tx_drop_frms ;
   u64 rx_ttl_frms ;
   u64 rx_vld_frms ;
   u64 rx_offload_frms ;
   u64 rx_ttl_octets ;
   u64 rx_data_octets ;
   u64 rx_offload_octets ;
   u64 rx_vld_mcast_frms ;
   u64 rx_vld_bcast_frms ;
   u64 rx_accepted_ucast_frms ;
   u64 rx_accepted_nucast_frms ;
   u64 rx_tagged_frms ;
   u64 rx_long_frms ;
   u64 rx_usized_frms ;
   u64 rx_osized_frms ;
   u64 rx_frag_frms ;
   u64 rx_jabber_frms ;
   u64 rx_ttl_64_frms ;
   u64 rx_ttl_65_127_frms ;
   u64 rx_ttl_128_255_frms ;
   u64 rx_ttl_256_511_frms ;
   u64 rx_ttl_512_1023_frms ;
   u64 rx_ttl_1024_1518_frms ;
   u64 rx_ttl_1519_4095_frms ;
   u64 rx_ttl_4096_8191_frms ;
   u64 rx_ttl_8192_max_frms ;
   u64 rx_ttl_gt_max_frms ;
   u64 rx_ip ;
   u64 rx_accepted_ip ;
   u64 rx_ip_octets ;
   u64 rx_err_ip ;
   u64 rx_icmp ;
   u64 rx_tcp ;
   u64 rx_udp ;
   u64 rx_err_tcp ;
   u64 rx_pause_count ;
   u64 rx_pause_ctrl_frms ;
   u64 rx_unsup_ctrl_frms ;
   u64 rx_fcs_err_frms ;
   u64 rx_in_rng_len_err_frms ;
   u64 rx_out_rng_len_err_frms ;
   u64 rx_drop_frms ;
   u64 rx_discarded_frms ;
   u64 rx_drop_ip ;
   u64 rx_drop_udp ;
   u32 rx_marker_pdu_frms ;
   u32 rx_lacpdu_frms ;
   u32 rx_unknown_pdu_frms ;
   u32 rx_marker_resp_pdu_frms ;
   u32 rx_fcs_discard ;
   u32 rx_illegal_pdu_frms ;
   u32 rx_switch_discard ;
   u32 rx_len_discard ;
   u32 rx_rpa_discard ;
   u32 rx_l2_mgmt_discard ;
   u32 rx_rts_discard ;
   u32 rx_trash_discard ;
   u32 rx_buff_full_discard ;
   u32 rx_red_discard ;
   u32 rx_xgmii_ctrl_err_cnt ;
   u32 rx_xgmii_data_err_cnt ;
   u32 rx_xgmii_char1_match ;
   u32 rx_xgmii_err_sym ;
   u32 rx_xgmii_column1_match ;
   u32 rx_xgmii_char2_match ;
   u32 rx_local_fault ;
   u32 rx_xgmii_column2_match ;
   u32 rx_jettison ;
   u32 rx_remote_fault ;
};

#line 836  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_xmac_vpath_tx_stats {
   u64 tx_ttl_eth_frms ;
   u64 tx_ttl_eth_octets ;
   u64 tx_data_octets ;
   u64 tx_mcast_frms ;
   u64 tx_bcast_frms ;
   u64 tx_ucast_frms ;
   u64 tx_tagged_frms ;
   u64 tx_vld_ip ;
   u64 tx_vld_ip_octets ;
   u64 tx_icmp ;
   u64 tx_tcp ;
   u64 tx_rst_tcp ;
   u64 tx_udp ;
   u32 tx_unknown_protocol ;
   u32 tx_lost_ip ;
   u32 unused1 ;
   u32 tx_parse_error ;
   u64 tx_tcp_offload ;
   u64 tx_retx_tcp_offload ;
   u64 tx_lost_ip_offload ;
};

#line 912  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_xmac_vpath_rx_stats {
   u64 rx_ttl_eth_frms ;
   u64 rx_vld_frms ;
   u64 rx_offload_frms ;
   u64 rx_ttl_eth_octets ;
   u64 rx_data_octets ;
   u64 rx_offload_octets ;
   u64 rx_vld_mcast_frms ;
   u64 rx_vld_bcast_frms ;
   u64 rx_accepted_ucast_frms ;
   u64 rx_accepted_nucast_frms ;
   u64 rx_tagged_frms ;
   u64 rx_long_frms ;
   u64 rx_usized_frms ;
   u64 rx_osized_frms ;
   u64 rx_frag_frms ;
   u64 rx_jabber_frms ;
   u64 rx_ttl_64_frms ;
   u64 rx_ttl_65_127_frms ;
   u64 rx_ttl_128_255_frms ;
   u64 rx_ttl_256_511_frms ;
   u64 rx_ttl_512_1023_frms ;
   u64 rx_ttl_1024_1518_frms ;
   u64 rx_ttl_1519_4095_frms ;
   u64 rx_ttl_4096_8191_frms ;
   u64 rx_ttl_8192_max_frms ;
   u64 rx_ttl_gt_max_frms ;
   u64 rx_ip ;
   u64 rx_accepted_ip ;
   u64 rx_ip_octets ;
   u64 rx_err_ip ;
   u64 rx_icmp ;
   u64 rx_tcp ;
   u64 rx_udp ;
   u64 rx_err_tcp ;
   u64 rx_lost_frms ;
   u64 rx_lost_ip ;
   u64 rx_lost_ip_offload ;
   u16 rx_various_discard ;
   u16 rx_sleep_discard ;
   u16 rx_red_discard ;
   u16 rx_queue_full_discard ;
   u64 rx_mpa_ok_frms ;
};

#line 1084  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_xmac_stats {
   struct vxge_hw_xmac_aggr_stats aggr_stats[2U] ;
   struct vxge_hw_xmac_port_stats port_stats[3U] ;
   struct vxge_hw_xmac_vpath_tx_stats vpath_tx_stats[17U] ;
   struct vxge_hw_xmac_vpath_rx_stats vpath_rx_stats[17U] ;
};

#line 1105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_vpath_stats_hw_info {
   u32 ini_num_mwr_sent ;
   u32 unused1 ;
   u32 ini_num_mrd_sent ;
   u32 unused2 ;
   u32 ini_num_cpl_rcvd ;
   u32 unused3 ;
   u64 ini_num_mwr_byte_sent ;
   u64 ini_num_cpl_byte_rcvd ;
   u32 wrcrdtarb_xoff ;
   u32 unused4 ;
   u32 rdcrdtarb_xoff ;
   u32 unused5 ;
   u32 vpath_genstats_count0 ;
   u32 vpath_genstats_count1 ;
   u32 vpath_genstats_count2 ;
   u32 vpath_genstats_count3 ;
   u32 vpath_genstats_count4 ;
   u32 unused6 ;
   u32 vpath_genstats_count5 ;
   u32 unused7 ;
   struct vxge_hw_xmac_vpath_tx_stats tx_stats ;
   struct vxge_hw_xmac_vpath_rx_stats rx_stats ;
   u64 unused9 ;
   u32 prog_event_vnum1 ;
   u32 prog_event_vnum0 ;
   u32 prog_event_vnum3 ;
   u32 prog_event_vnum2 ;
   u16 rx_multi_cast_frame_discard ;
   u8 unused10[6U] ;
   u32 rx_frm_transferred ;
   u32 unused11 ;
   u16 rxd_returned ;
   u8 unused12[6U] ;
   u16 rx_mpa_len_fail_frms ;
   u16 rx_mpa_mrk_fail_frms ;
   u16 rx_mpa_crc_fail_frms ;
   u16 rx_permitted_frms ;
   u64 rx_vp_reset_discarded_frms ;
   u64 rx_wol_frms ;
   u64 tx_vp_reset_discarded_frms ;
};

#line 1528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_device_stats_hw_info {
   struct vxge_hw_vpath_stats_hw_info *vpath_info[17U] ;
   struct vxge_hw_vpath_stats_hw_info vpath_info_sav[17U] ;
};

#line 1542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_vpath_stats_sw_common_info {
   u32 full_cnt ;
   u32 usage_cnt ;
   u32 usage_max ;
   u32 reserve_free_swaps_cnt ;
   u32 total_compl_cnt ;
};

#line 1563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_vpath_stats_sw_fifo_info {
   struct vxge_hw_vpath_stats_sw_common_info common_stats ;
   u32 total_posts ;
   u32 total_buffers ;
   u32 txd_t_code_err_cnt[16U] ;
};

#line 1585  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_vpath_stats_sw_ring_info {
   struct vxge_hw_vpath_stats_sw_common_info common_stats ;
   u32 rxd_t_code_err_cnt[16U] ;
};

#line 1604  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_vpath_stats_sw_err {
   u32 unknown_alarms ;
   u32 network_sustained_fault ;
   u32 network_sustained_ok ;
   u32 kdfcctl_fifo0_overwrite ;
   u32 kdfcctl_fifo0_poison ;
   u32 kdfcctl_fifo0_dma_error ;
   u32 dblgen_fifo0_overflow ;
   u32 statsb_pif_chain_error ;
   u32 statsb_drop_timeout ;
   u32 target_illegal_access ;
   u32 ini_serr_det ;
   u32 prc_ring_bumps ;
   u32 prc_rxdcm_sc_err ;
   u32 prc_rxdcm_sc_abort ;
   u32 prc_quanta_size_err ;
};

#line 1643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_vpath_stats_sw_info {
   u32 soft_reset_cnt ;
   struct vxge_hw_vpath_stats_sw_err error_stats ;
   struct vxge_hw_vpath_stats_sw_ring_info ring_stats ;
   struct vxge_hw_vpath_stats_sw_fifo_info fifo_stats ;
};

#line 1660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_device_stats_sw_info {
   u32 not_traffic_intr_cnt ;
   u32 traffic_intr_cnt ;
   u32 total_intr_cnt ;
   u32 soft_reset_cnt ;
   struct vxge_hw_vpath_stats_sw_info vpath_info[17U] ;
};

#line 1683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_device_stats_sw_err {
   u32 vpath_alarms ;
};

#line 1693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_device_stats {
   struct __vxge_hw_device *devh ;
   struct vxge_hw_device_stats_hw_info hw_dev_info_stats ;
   struct vxge_hw_device_stats_sw_err sw_dev_err_stats ;
   struct vxge_hw_device_stats_sw_info sw_dev_info_stats ;
};

#line 1728 
enum vxge_hw_status;

#line 1753 
enum vxge_hw_mgmt_reg_type {
    vxge_hw_mgmt_reg_type_legacy = 0,
    vxge_hw_mgmt_reg_type_toc = 1,
    vxge_hw_mgmt_reg_type_common = 2,
    vxge_hw_mgmt_reg_type_mrpcim = 3,
    vxge_hw_mgmt_reg_type_srpcim = 4,
    vxge_hw_mgmt_reg_type_vpmgmt = 5,
    vxge_hw_mgmt_reg_type_vpath = 6
};

#line 1787 
enum vxge_hw_rxd_state {
    VXGE_HW_RXD_STATE_NONE = 0,
    VXGE_HW_RXD_STATE_AVAIL = 1,
    VXGE_HW_RXD_STATE_POSTED = 2,
    VXGE_HW_RXD_STATE_FREED = 3
};

#line 1958 
enum vxge_hw_fifo_tcode {
    VXGE_HW_FIFO_T_CODE_OK = 0,
    VXGE_HW_FIFO_T_CODE_PCI_READ_CORRUPT = 1,
    VXGE_HW_FIFO_T_CODE_PCI_READ_FAIL = 2,
    VXGE_HW_FIFO_T_CODE_INVALID_MSS = 3,
    VXGE_HW_FIFO_T_CODE_LSO_ERROR = 4,
    VXGE_HW_FIFO_T_CODE_UNUSED = 7,
    VXGE_HW_FIFO_T_CODE_MULTI_ERROR = 8
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
enum vxge_hw_status {
    VXGE_HW_OK = 0,
    VXGE_HW_FAIL = 1,
    VXGE_HW_PENDING = 2,
    VXGE_HW_COMPLETIONS_REMAIN = 3,
    VXGE_HW_INF_NO_MORE_COMPLETED_DESCRIPTORS = 101,
    VXGE_HW_INF_OUT_OF_DESCRIPTORS = 102,
    VXGE_HW_ERR_INVALID_HANDLE = 201,
    VXGE_HW_ERR_OUT_OF_MEMORY = 202,
    VXGE_HW_ERR_VPATH_NOT_AVAILABLE = 203,
    VXGE_HW_ERR_VPATH_NOT_OPEN = 204,
    VXGE_HW_ERR_WRONG_IRQ = 205,
    VXGE_HW_ERR_SWAPPER_CTRL = 206,
    VXGE_HW_ERR_INVALID_MTU_SIZE = 207,
    VXGE_HW_ERR_INVALID_INDEX = 208,
    VXGE_HW_ERR_INVALID_TYPE = 209,
    VXGE_HW_ERR_INVALID_OFFSET = 210,
    VXGE_HW_ERR_INVALID_DEVICE = 211,
    VXGE_HW_ERR_VERSION_CONFLICT = 212,
    VXGE_HW_ERR_INVALID_PCI_INFO = 213,
    VXGE_HW_ERR_INVALID_TCODE = 214,
    VXGE_HW_ERR_INVALID_BLOCK_SIZE = 215,
    VXGE_HW_ERR_INVALID_STATE = 216,
    VXGE_HW_ERR_PRIVILAGED_OPEARATION = 217,
    VXGE_HW_ERR_INVALID_PORT = 218,
    VXGE_HW_ERR_FIFO = 219,
    VXGE_HW_ERR_VPATH = 220,
    VXGE_HW_ERR_CRITICAL = 221,
    VXGE_HW_ERR_SLOT_FREEZE = 222,
    VXGE_HW_BADCFG_RING_INDICATE_MAX_PKTS = 301,
    VXGE_HW_BADCFG_FIFO_BLOCKS = 302,
    VXGE_HW_BADCFG_VPATH_MTU = 303,
    VXGE_HW_BADCFG_VPATH_RPA_STRIP_VLAN_TAG = 304,
    VXGE_HW_BADCFG_VPATH_MIN_BANDWIDTH = 305,
    VXGE_HW_BADCFG_INTR_MODE = 306,
    VXGE_HW_BADCFG_RTS_MAC_EN = 307,
    VXGE_HW_EOF_TRACE_BUF = -1
};

#line 87 
enum vxge_hw_device_link_state {
    VXGE_HW_LINK_NONE = 0,
    VXGE_HW_LINK_DOWN = 1,
    VXGE_HW_LINK_UP = 2
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_device_date {
   u32 day ;
   u32 month ;
   u32 year ;
   char date[32U] ;
};

#line 219  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_device_version {
   u32 major ;
   u32 minor ;
   u32 build ;
   char version[32U] ;
};

#line 226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_fifo_config {
   u32 enable ;
   u32 fifo_blocks ;
   u32 max_frags ;
   u32 memblock_size ;
   u32 alignment_size ;
   u32 intr ;
   u32 no_snoop_bits ;
};

#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_ring_config {
   u32 enable ;
   u32 ring_blocks ;
   u32 buffer_mode ;
   u32 scatter_mode ;
   u64 rxds_limit ;
};

#line 337  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_vp_config {
   u32 vp_id ;
   u32 min_bandwidth ;
   struct vxge_hw_ring_config ring ;
   struct vxge_hw_fifo_config fifo ;
   struct vxge_hw_tim_intr_config tti ;
   struct vxge_hw_tim_intr_config rti ;
   u32 mtu ;
   u32 rpa_strip_vlan_tag ;
};

#line 384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_device_config {
   u32 device_poll_millis ;
   u32 dma_blockpool_initial ;
   u32 dma_blockpool_max ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) intr_mode : 2 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rth_en : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rth_it_type : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rts_mac_en : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hwts_en : 1 ;
   struct vxge_hw_vp_config vp_config[17U] ;
};

#line 460  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_uld_cbs {
   void (*link_up)(struct __vxge_hw_device *) ;
   void (*link_down)(struct __vxge_hw_device *) ;
   void (*crit_err)(struct __vxge_hw_device *, enum vxge_hw_event , u64 ) ;
};

#line 517  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_blockpool_entry {
   struct list_head item ;
   u32 length ;
   void *memblock ;
   dma_addr_t dma_addr ;
   struct pci_dev *dma_handle ;
   struct pci_dev *acc_handle ;
};

#line 539  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_blockpool {
   struct __vxge_hw_device *hldev ;
   u32 block_size ;
   u32 pool_size ;
   u32 pool_max ;
   u32 req_out ;
   struct list_head free_block_list ;
   struct list_head free_entry_list ;
};

#line 561 
enum __vxge_hw_channel_type {
    VXGE_HW_CHANNEL_TYPE_UNKNOWN = 0,
    VXGE_HW_CHANNEL_TYPE_FIFO = 1,
    VXGE_HW_CHANNEL_TYPE_RING = 2,
    VXGE_HW_CHANNEL_TYPE_MAX = 3
};

#line 568  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_channel {
   struct list_head item ;
   enum __vxge_hw_channel_type type ;
   struct __vxge_hw_device *devh ;
   struct __vxge_hw_vpath_handle *vph ;
   u32 length ;
   u32 vp_id ;
   void **reserve_arr ;
   u32 reserve_ptr ;
   u32 reserve_top ;
   void **work_arr ;
   u32 post_index ;
   u32 compl_index ;
   void **free_arr ;
   u32 free_ptr ;
   void **orig_arr ;
   u32 per_dtr_space ;
   void *userdata ;
   struct vxge_hw_common_reg *common_reg ;
   u32 first_vp_id ;
   struct vxge_hw_vpath_stats_sw_common_info *stats ;
};

#line 647 
struct __vxge_hw_non_offload_db_wrapper;

#line 647  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_virtualpath {
   u32 vp_id ;
   u32 vp_open ;
   struct __vxge_hw_device *hldev ;
   struct vxge_hw_vp_config *vp_config ;
   struct vxge_hw_vpath_reg *vp_reg ;
   struct vxge_hw_vpmgmt_reg *vpmgmt_reg ;
   struct __vxge_hw_non_offload_db_wrapper *nofl_db ;
   u32 max_mtu ;
   u32 vsport_number ;
   u32 max_kdfc_db ;
   u32 max_nofl_db ;
   u64 tim_tti_cfg1_saved ;
   u64 tim_tti_cfg3_saved ;
   u64 tim_rti_cfg1_saved ;
   u64 tim_rti_cfg3_saved ;
   struct __vxge_hw_ring *ringh ;
   struct __vxge_hw_fifo *fifoh ;
   struct list_head vpath_handles ;
   struct __vxge_hw_blockpool_entry *stats_block ;
   struct vxge_hw_vpath_stats_hw_info *hw_stats ;
   struct vxge_hw_vpath_stats_hw_info *hw_stats_sav ;
   struct vxge_hw_vpath_stats_sw_info *sw_stats ;
   spinlock_t lock ;
};

#line 705  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_vpath_handle {
   struct list_head item ;
   struct __vxge_hw_virtualpath *vpath ;
};

#line 717  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_device {
   u32 magic ;
   void *bar0 ;
   struct pci_dev *pdev ;
   struct net_device *ndev ;
   struct vxge_hw_device_config config ;
   enum vxge_hw_device_link_state link_state ;
   struct vxge_hw_uld_cbs const *uld_callbacks ;
   u32 host_type ;
   u32 func_id ;
   u32 access_rights ;
   struct vxge_hw_legacy_reg *legacy_reg ;
   struct vxge_hw_toc_reg *toc_reg ;
   struct vxge_hw_common_reg *common_reg ;
   struct vxge_hw_mrpcim_reg *mrpcim_reg ;
   struct vxge_hw_srpcim_reg *srpcim_reg[17U] ;
   struct vxge_hw_vpmgmt_reg *vpmgmt_reg[17U] ;
   struct vxge_hw_vpath_reg *vpath_reg[17U] ;
   u8 *kdfc ;
   u8 *usdc ;
   struct __vxge_hw_virtualpath virtual_paths[17U] ;
   u64 vpath_assignments ;
   u64 vpaths_deployed ;
   u32 first_vp_id ;
   u64 tim_int_mask0[4U] ;
   u32 tim_int_mask1[4U] ;
   struct __vxge_hw_blockpool block_pool ;
   struct vxge_hw_device_stats stats ;
   u32 debug_module_mask ;
   u32 debug_level ;
   u32 level_err ;
   u32 level_trace ;
   u16 eprom_versions[8U] ;
};

#line 779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_device_hw_info {
   u32 host_type ;
   u64 function_mode ;
   u32 func_id ;
   u64 vpath_mask ;
   struct vxge_hw_device_version fw_version ;
   struct vxge_hw_device_date fw_date ;
   struct vxge_hw_device_version flash_version ;
   struct vxge_hw_device_date flash_date ;
   u8 serial_number[64U] ;
   u8 part_number[64U] ;
   u8 product_desc[64U] ;
   u8 mac_addrs[17U][6U] ;
   u8 mac_addr_masks[17U][6U] ;
};

#line 845  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_ring {
   struct __vxge_hw_channel channel ;
   struct vxge_hw_mempool *mempool ;
   struct vxge_hw_vpath_reg *vp_reg ;
   struct vxge_hw_common_reg *common_reg ;
   u32 ring_length ;
   u32 buffer_mode ;
   u32 rxd_size ;
   u32 rxd_priv_size ;
   u32 per_rxd_space ;
   u32 rxds_per_block ;
   u32 rxdblock_priv_size ;
   u32 cmpl_cnt ;
   u32 vp_id ;
   u32 doorbell_cnt ;
   u32 total_db_cnt ;
   u64 rxds_limit ;
   u32 rtimer ;
   u64 tim_rti_cfg1_saved ;
   u64 tim_rti_cfg3_saved ;
   enum vxge_hw_status (*callback)(struct __vxge_hw_ring *, void *, u8 , void *) ;
   enum vxge_hw_status (*rxd_init)(void *, void *) ;
   void (*rxd_term)(void *, enum vxge_hw_rxd_state , void *) ;
   struct vxge_hw_vpath_stats_sw_ring_info *stats ;
   struct vxge_hw_ring_config *config ;
};

#line 956 
enum vxge_hw_txdl_state {
    VXGE_HW_TXDL_STATE_NONE = 0,
    VXGE_HW_TXDL_STATE_AVAIL = 1,
    VXGE_HW_TXDL_STATE_POSTED = 2,
    VXGE_HW_TXDL_STATE_FREED = 3
};

#line 963  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_fifo {
   struct __vxge_hw_channel channel ;
   struct vxge_hw_mempool *mempool ;
   struct vxge_hw_fifo_config *config ;
   struct vxge_hw_vpath_reg *vp_reg ;
   struct __vxge_hw_non_offload_db_wrapper *nofl_db ;
   u64 interrupt_type ;
   u32 no_snoop_bits ;
   u32 txdl_per_memblock ;
   u32 txdl_size ;
   u32 priv_size ;
   u32 per_txdl_space ;
   u32 vp_id ;
   u32 tx_intr_num ;
   u32 rtimer ;
   u64 tim_tti_cfg1_saved ;
   u64 tim_tti_cfg3_saved ;
   enum vxge_hw_status (*callback)(struct __vxge_hw_fifo *, void *, enum vxge_hw_fifo_tcode , void *, struct sk_buff ***, int , int *) ;
   void (*txdl_term)(void *, enum vxge_hw_txdl_state , void *) ;
   struct vxge_hw_vpath_stats_sw_fifo_info *stats ;
};

#line 1095  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_non_offload_db_wrapper {
   u64 control_0 ;
   u64 txdl_ptr ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_config {
   int tx_pause_enable ;
   int rx_pause_enable ;
   int napi_weight ;
   int intr_type ;
   int addr_learn_en ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) rth_steering : 2 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) rth_algorithm : 2 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rth_hash_type_tcpipv4 : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rth_hash_type_ipv4 : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rth_hash_type_tcpipv6 : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rth_hash_type_ipv6 : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rth_hash_type_tcpipv6ex : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rth_hash_type_ipv6ex : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) rth_bkt_sz : 8 ;
   int rth_jhash_golden_ratio ;
   int tx_steering_type ;
   int fifo_indicate_max_pkts ;
   struct vxge_hw_device_hw_info device_hw_info ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_msix_entry {
   u16 vector ;
   u16 entry ;
   u16 in_use ;
   void *arg ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_sw_stats {
   unsigned long vpaths_open ;
   unsigned long vpath_open_fail ;
   unsigned long link_up ;
   unsigned long link_down ;
};

#line 222 
struct vxgedev;

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_fifo_stats {
   struct u64_stats_sync syncp ;
   u64 tx_frms ;
   u64 tx_bytes ;
   unsigned long tx_errors ;
   unsigned long txd_not_free ;
   unsigned long txd_out_of_desc ;
   unsigned long pci_map_fail ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_fifo {
   struct net_device *ndev ;
   struct pci_dev *pdev ;
   struct __vxge_hw_fifo *handle ;
   struct netdev_queue *txq ;
   int tx_steering_type ;
   int indicate_max_pkts ;
   unsigned long interrupt_count ;
   unsigned long jiffies ;
   u32 tx_vector_no ;
   struct vxge_fifo_stats stats ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_ring_stats {
   struct u64_stats_sync syncp ;
   u64 rx_frms ;
   u64 rx_mcast ;
   u64 rx_bytes ;
   unsigned long rx_errors ;
   unsigned long rx_dropped ;
   unsigned long prev_rx_frms ;
   unsigned long pci_map_fail ;
   unsigned long skb_alloc_fail ;
};

#line 266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_ring {
   struct net_device *ndev ;
   struct pci_dev *pdev ;
   struct __vxge_hw_ring *handle ;
   int driver_id ;
   unsigned long interrupt_count ;
   unsigned long jiffies ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rx_hwts : 1 ;
   int pkts_processed ;
   int budget ;
   struct napi_struct napi ;
   struct napi_struct *napi_p ;
   int vlan_tag_strip ;
   u32 rx_vector_no ;
   enum vxge_hw_status last_status ;
   struct vxge_ring_stats stats ;
};

#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_vpath {
   struct vxge_fifo fifo ;
   struct vxge_ring ring ;
   struct __vxge_hw_vpath_handle *handle ;
   int device_id ;
   int max_mac_addr_cnt ;
   int is_configured ;
   int is_open ;
   struct vxgedev *vdev ;
   u8 macaddr[6U] ;
   u8 macmask[6U] ;
   u16 mac_addr_cnt ;
   u16 mcast_addr_cnt ;
   struct list_head mac_addr_list ;
   u32 level_err ;
   u32 level_trace ;
};

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxgedev {
   struct net_device *ndev ;
   struct pci_dev *pdev ;
   struct __vxge_hw_device *devh ;
   unsigned long active_vlans[64U] ;
   int vlan_tag_strip ;
   struct vxge_config config ;
   unsigned long state ;
   unsigned long vp_reset ;
   struct timer_list vp_reset_timer ;
   struct timer_list vp_lockup_timer ;
   u16 all_multi_flg ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rx_hwts : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) titan1 : 1 ;
   struct vxge_msix_entry *vxge_entries ;
   struct msix_entry *entries ;
   char desc[68U][80U] ;
   enum vxge_hw_event cric_err_event ;
   int max_vpath_supported ;
   int no_of_vpath ;
   struct napi_struct napi ;
   int exec_mode ;
   int max_config_port ;
   struct vxge_vpath *vpaths ;
   struct __vxge_hw_vpath_handle *vp_handles[17U] ;
   void *bar0 ;
   struct vxge_sw_stats stats ;
   int mtu ;
   u8 vpath_selector[17U] ;
   u64 vpaths_deployed ;
   u32 intr_cnt ;
   u32 level_err ;
   u32 level_trace ;
   char fw_version[32U] ;
   struct work_struct reset_task ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __sum16;

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11836 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
enum ldv_23510 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_23510 socket_state;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct;

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_page_588 {
   struct page *p ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_588 page ;
   __u32 page_offset ;
   __u32 size ;
};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};

#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};

#line 767 
struct rtable;

#line 890 
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/xfrm.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct xfrm_policy;

#line 98 
struct xfrm_state;

#line 114 
struct request_sock;

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};

#line 331 
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;

#line 2893 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/cacheflush.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) dst_reg : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
};

#line 273 
struct bpf_prog_aux;

#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
union __anonunion_650 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff const *, struct bpf_insn const *) ;
   union __anonunion_650 __anonCompField_bpf_prog_99 ;
};

#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   int maxtype ;
   struct nla_policy const *policy ;
   int (*validate)(struct nlattr **, struct nlattr **) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device const *) ;
   int (*fill_info)(struct sk_buff *, struct net_device const *) ;
   size_t (*get_xstats_size)(struct net_device const *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device const *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy const *slave_policy ;
   int (*slave_validate)(struct nlattr **, struct nlattr **) ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **) ;
   size_t (*get_slave_size)(struct net_device const *, struct net_device const *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device const *, struct net_device const *) ;
   struct net *(*get_link_net)(struct net_device const *) ;
};

#line 171 
struct neigh_table;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   void (*neigh_cleanup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};

#line 129 
struct neigh_ops;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops const *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const *, struct net_device const *, __u32 *) ;
   bool (*key_eq)(struct neighbour const *, void const *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};

#line 519 
struct dn_route;

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
union __anonunion_658 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_658 __anonCompField_dst_entry_100 ;
};

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_socket_lock_t_659 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_659 socket_lock_t;

#line 124 
struct proto;

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u32 __portpair;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u64 __addrpair;

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_661 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_660 {
   __addrpair skc_addrpair ;
   struct __anonstruct_661 __anonCompField___anonunion_660_101 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_662 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_664 {
   __be16 skc_dport ;
   __u16 skc_num ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_663 {
   __portpair skc_portpair ;
   struct __anonstruct_664 __anonCompField___anonunion_663_104 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_665 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_666 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock_common {
   union __anonunion_660 __anonCompField_sock_common_102 ;
   union __anonunion_662 __anonCompField_sock_common_103 ;
   union __anonunion_663 __anonCompField_sock_common_105 ;
   unsigned short skc_family ;
   unsigned char volatile skc_state ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) skc_reuse : 4 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_reuseport : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_ipv6only : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_665 __anonCompField_sock_common_106 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_666 __anonCompField_sock_common_107 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};

#line 219 
struct cg_proto;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_sk_backlog_667 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_667 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) sk_shutdown : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_tx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_rx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) sk_userlocks : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) sk_protocol : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred const *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
};

#line 914 
struct request_sock_ops;

#line 915 
struct timewait_sock_ops;

#line 916 
struct inet_hashinfo;

#line 917 
struct raw_hashinfo;

#line 932 
struct udp_table;

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_h_670 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   void (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   void (*clear_sk)(struct sock *, int ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock const *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_670 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup *, struct cgroup_subsys *) ;
   void (*destroy_cgroup)(struct mem_cgroup *) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup *) ;
};

#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock const *) ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cookie_ts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops const *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};

#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) res1 : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) doff : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) fin : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syn : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rst : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) psh : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ack : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) urg : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ece : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};

#line 410  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
struct iphdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ihl : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
union __anonunion_690 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_690 __anonCompField_inetpeer_addr_base_109 ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_691 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct __anonstruct_693 {
   atomic_t rid ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_692 {
   struct __anonstruct_693 __anonCompField___anonunion_692_111 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_691 __anonCompField_inet_peer_110 ;
   union __anonunion_692 __anonCompField_inet_peer_112 ;
   __u32 dtime ;
   atomic_t refcnt ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct uncached_list;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};

#line 587  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ip.h"
struct firmware {
   size_t size ;
   u8 const *data ;
   struct page **pages ;
   void *priv ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct kernel_param;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_699 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_699 __anonCompField_kernel_param_114 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 4635  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-reg.h"
struct vxge_hw_ring_attr;

#line 1794  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_ring_rxd_info {
   u32 syn_flag ;
   u32 is_icmp ;
   u32 fast_path_eligible ;
   u32 l3_cksum_valid ;
   u32 l3_cksum ;
   u32 l4_cksum_valid ;
   u32 l4_cksum ;
   u32 frame ;
   u32 proto ;
   u32 is_vlan ;
   u32 vlan ;
   u32 rth_bucket ;
   u32 rth_it_hit ;
   u32 rth_spdm_hit ;
   u32 rth_hash_type ;
   u32 rth_value ;
};

#line 2147 
enum vxge_hw_vpath_mac_addr_add_mode {
    VXGE_HW_VPATH_MAC_ADDR_ADD_DUPLICATE = 0,
    VXGE_HW_VPATH_MAC_ADDR_DISCARD_DUPLICATE = 1,
    VXGE_HW_VPATH_MAC_ADDR_REPLACE_DUPLICATE = 2
};

#line 2289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct eprom_image {
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_valid : 1 ;
   u8 index ;
   u8 type ;
   u16 version ;
};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
enum vxge_debug_level {
    VXGE_NONE = 0,
    VXGE_TRACE = 1,
    VXGE_ERR = 2
};

#line 831  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_device_attr {
   void *bar0 ;
   struct pci_dev *pdev ;
   struct vxge_hw_uld_cbs const *uld_callbacks ;
};

#line 1036 
struct vxge_hw_fifo_txd;

#line 1127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_fifo_txd {
   u64 control_0 ;
   u64 control_1 ;
   u64 buffer_pointer ;
   u64 host_control ;
};

#line 1296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_ring_rxd_1 {
   u64 host_control ;
   u64 control_0 ;
   u64 control_1 ;
   u64 buffer0_ptr ;
};

#line 1435 
enum vxge_hw_rth_algoritms {
    RTH_ALG_JENKINS = 0,
    RTH_ALG_MS_RSS = 1,
    RTH_ALG_CRC32C = 2
};

#line 1441  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_rth_hash_types {
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hash_type_tcpipv4_en : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hash_type_ipv4_en : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hash_type_tcpipv6_en : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hash_type_ipv6_en : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hash_type_tcpipv6ex_en : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hash_type_ipv6ex_en : 1 ;
};

#line 1695  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_ring_attr {
   enum vxge_hw_status (*callback)(struct __vxge_hw_ring *, void *, u8 , void *) ;
   enum vxge_hw_status (*rxd_init)(void *, void *) ;
   void (*rxd_term)(void *, enum vxge_hw_rxd_state , void *) ;
   void *userdata ;
   u32 per_rxd_space ;
};

#line 1738  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_fifo_attr {
   enum vxge_hw_status (*callback)(struct __vxge_hw_fifo *, void *, enum vxge_hw_fifo_tcode , void *, struct sk_buff ***, int , int *) ;
   void (*txdl_term)(void *, enum vxge_hw_txdl_state , void *) ;
   void *userdata ;
   u32 per_txdl_space ;
};

#line 1833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_hw_vpath_attr {
   u32 vp_id ;
   struct vxge_hw_ring_attr ring_attr ;
   struct vxge_hw_fifo_attr fifo_attr ;
};

#line 2124 
enum vxge_mac_addr_state {
    VXGE_LL_MAC_ADDR_IN_LIST = 0,
    VXGE_LL_MAC_ADDR_IN_DA_TABLE = 1
};

#line 2129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct vxge_drv_config {
   int config_dev_cnt ;
   int total_dev_cnt ;
   int g_no_cpus ;
   unsigned int vpath_per_dev ;
};

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct macInfo {
   unsigned char macaddr[6U] ;
   unsigned char macmask[6U] ;
   unsigned int vpath_no ;
   enum vxge_mac_addr_state state ;
};

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_mac_addrs {
   struct list_head item ;
   u64 macaddr ;
   u64 macmask ;
   enum vxge_mac_addr_state state ;
};

#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_rx_priv {
   struct sk_buff *skb ;
   unsigned char *skb_data ;
   dma_addr_t data_dma ;
   dma_addr_t data_size ;
};

#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
struct vxge_tx_priv {
   struct sk_buff *skb ;
   dma_addr_t dma_buffers[18U] ;
};

#line 753  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
typedef int ldv_func_ret_type;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ptrdiff_t;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ptrdiff_t ptrdiff_t;

#line 1911  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct hotplug_slot_ops {
   struct module *owner ;
   char const *mod_name ;
   int (*enable_slot)(struct hotplug_slot *) ;
   int (*disable_slot)(struct hotplug_slot *) ;
   int (*set_attention_status)(struct hotplug_slot *, u8 ) ;
   int (*hardware_test)(struct hotplug_slot *, u32 ) ;
   int (*get_power_status)(struct hotplug_slot *, u8 *) ;
   int (*get_attention_status)(struct hotplug_slot *, u8 *) ;
   int (*get_latch_status)(struct hotplug_slot *, u8 *) ;
   int (*get_adapter_status)(struct hotplug_slot *, u8 *) ;
   int (*reset_slot)(struct hotplug_slot *, int ) ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci_hotplug.h"
struct hotplug_slot_info {
   u8 power_status ;
   u8 attention_status ;
   u8 latch_status ;
   u8 adapter_status ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci_hotplug.h"
struct hotplug_slot {
   struct hotplug_slot_ops *ops ;
   struct hotplug_slot_info *info ;
   void (*release)(struct hotplug_slot *) ;
   void *private ;
   struct list_head slot_list ;
   struct pci_slot *pci_slot ;
};

#line 2077  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
struct vxge_hw_mempool_cbs {
   void (*item_func_alloc)(struct vxge_hw_mempool *, u32 , struct vxge_hw_mempool_dma *, u32 , u32 ) ;
};

#line 1036  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
struct __vxge_hw_fifo_txdl_priv {
   dma_addr_t dma_addr ;
   struct pci_dev *dma_handle ;
   ptrdiff_t dma_offset ;
   u32 frags ;
   u8 *align_vaddr_start ;
   u8 *align_vaddr ;
   dma_addr_t align_dma_addr ;
   struct pci_dev *align_dma_handle ;
   struct pci_dev *align_dma_acch ;
   ptrdiff_t align_dma_offset ;
   u32 align_used_frags ;
   u32 alloc_frags ;
   u32 unused ;
   struct __vxge_hw_fifo_txdl_priv *next_txdl_priv ;
   struct vxge_hw_fifo_txd *first_txdp ;
   void *memblock ;
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct ldv_struct_free_irq_6 {
   int arg0 ;
   int signal_pending ;
};

#line 19  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_17 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_16 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_random_allocationless_scenario_14 {
   struct net_device *arg0 ;
   int signal_pending ;
};

#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_timer_scenario_15 {
   struct timer_list *arg0 ;
   int signal_pending ;
};

#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int snprintf(char *, size_t, char const * , ...);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 56 
void *memset(void *, int, size_t);


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
size_t strlcpy(char *, char const *, size_t);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep, __u32 speed)
{
  
#line 117 
  ep->speed = (unsigned short)speed;
  
#line 118 
  ep->speed_hi = (unsigned short)(speed >> 16);
  
#line 119 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd const *ep)
{
  __u32 __retres;
  
#line 123 
  __retres = (unsigned int)(((int)ep->speed_hi << 16) | (int)ep->speed);
  
#line 123 
  return __retres;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
u32 ethtool_op_get_link(struct net_device *);


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static char const *pci_name(struct pci_dev const *pdev)
{
  char const *tmp;
  
#line 1486 
  tmp = dev_name(& pdev->dev);
  
#line 1486 
  return tmp;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device const *dev)
{
  void *__retres;
  
#line 1882 
  __retres = (void *)dev + 3008U;
  
#line 1882 
  return __retres;
}


#line 2769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 2771 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev->state));
  
#line 2771 
  __retres = (_Bool)(tmp != 0);
  
#line 2771 
  return __retres;
}


#line 3038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 3040 
  tmp = constant_test_bit(2L,(unsigned long const volatile *)(& dev->state));
  
#line 3040 
  __retres = (_Bool)(tmp == 0);
  
#line 3040 
  return __retres;
}


#line 1731  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
enum vxge_hw_status vxge_hw_device_stats_get(struct __vxge_hw_device *hldev, struct vxge_hw_device_stats_hw_info *hw_stats);


#line 1735 
enum vxge_hw_status vxge_hw_driver_stats_get(struct __vxge_hw_device *hldev, struct vxge_hw_device_stats_sw_info *sw_stats);


#line 1752 
enum vxge_hw_status vxge_hw_device_xmac_stats_get(struct __vxge_hw_device *hldev, struct vxge_hw_xmac_stats *xmac_stats);


#line 1779 
enum vxge_hw_status vxge_hw_mgmt_reg_read(struct __vxge_hw_device *hldev, enum vxge_hw_mgmt_reg_type type, u32 index, u32 offset, u64 *value);


#line 1885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
enum vxge_hw_status vxge_hw_device_getpause_data(struct __vxge_hw_device *hldev, u32 port, u32 *tx, u32 *rx);


#line 1891 
enum vxge_hw_status vxge_hw_device_setpause_data(struct __vxge_hw_device *hldev, u32 port, u32 tx, u32 rx);


#line 2045 
enum vxge_hw_status vxge_hw_device_flick_link_led(struct __vxge_hw_device *hldev, u64 on_off);


#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
void vxge_initialize_ethtool_ops(struct net_device *ndev);


#line 430 
int vxge_fw_upgrade(struct vxgedev *vdev, char *fw_name, int override);


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.h"
static int vxge_ethtool_get_sset_count(struct net_device *dev, int sset);


#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.h"
static char const ethtool_driver_stats_keys[16U][32U] = {{(char)'\n', (char)' ', (char)'D', (char)'R', (char)'I', (char)'V', (char)'E', (char)'R', (char)' ', (char)'S', (char)'T', (char)'A', (char)'T', (char)'I', (char)'S', (char)'T', (char)'I', (char)'C', (char)'S', (char)'\000'}, {(char)'v', (char)'p', (char)'a', (char)'t', (char)'h', (char)'s', (char)'_', (char)'o', (char)'p', (char)'e', (char)'n', (char)'e', (char)'d', (char)'\000'}, {(char)'v', (char)'p', (char)'a', (char)'t', (char)'h', (char)'_', (char)'o', (char)'p', (char)'e', (char)'n', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l', (char)'_', (char)'c', (char)'n', (char)'t', (char)'\000'}, {(char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'u', (char)'p', (char)'_', (char)'c', (char)'n', (char)'t', (char)'\000'}, {(char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'d', (char)'o', (char)'w', (char)'n', (char)'_', (char)'c', (char)'n', (char)'t', (char)'\000'}, {(char)'t', (char)'x', (char)'_', (char)'f', (char)'r', (char)'m', (char)'s', (char)'\000'}, {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'t', (char)'x', (char)'d', (char)'_', (char)'n', (char)'o', (char)'t', (char)'_', (char)'f', (char)'r', (char)'e', (char)'e', (char)'\000'}, {(char)'t', (char)'x', (char)'d', (char)'_', (char)'o', (char)'u', (char)'t', (char)'_', (char)'o', (char)'f', (char)'_', (char)'d', (char)'e', (char)'s', (char)'c', (char)'\000'}, {(char)'r', (char)'x', (char)'_', (char)'f', (char)'r', (char)'m', (char)'s', (char)'\000'}, {(char)'r', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, {(char)'r', (char)'x', (char)'_', (char)'m', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, {(char)'p', (char)'c', (char)'i', (char)'_', (char)'m', (char)'a', (char)'p', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l', (char)'_', (char)'c', (char)'n', (char)'t', (char)'\000'}, {(char)'s', (char)'k', (char)'b', (char)'_', (char)'a', (char)'l', (char)'l', (char)'o', (char)'c', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l', (char)'_', (char)'c', (char)'n', (char)'t', (char)'\000'}};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static int vxge_ethtool_sset(struct net_device *dev, struct ethtool_cmd *info)
{
  int __retres;
  
#line 54 
  if ((unsigned int)info->autoneg == 1U) {
    
#line 57 
    __retres = -22;
    
#line 57 
    goto return_label;
  }
  else {
    __u32 tmp;
    
#line 54 
    tmp = ethtool_cmd_speed((struct ethtool_cmd const *)info);
    
#line 54 
    if (tmp != 10000U) {
      
#line 57 
      __retres = -22;
      
#line 57 
      goto return_label;
    }
    else 
      
#line 55 
      if ((unsigned int)info->duplex != 1U) {
        
#line 57 
        __retres = -22;
        
#line 57 
        goto return_label;
      }
      else ;
  }
  
#line 59 
  __retres = 0;
  return_label: 
#line 59 
                return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static int vxge_ethtool_gset(struct net_device *dev, struct ethtool_cmd *info)
{
  int __retres;
  bool tmp;
  
#line 74 
  info->supported = 5120U;
  
#line 75 
  info->advertising = 5120U;
  
#line 76 
  info->port = (unsigned char)3U;
  
#line 78 
  info->transceiver = (unsigned char)1U;
  
#line 80 
  tmp = netif_carrier_ok((struct net_device const *)dev);
  
#line 80 
  if ((int)tmp != 0) {
    
#line 81 
    ethtool_cmd_speed_set(info,10000U);
    
#line 82 
    info->duplex = (unsigned char)1U;
  }
  else {
    
#line 84 
    ethtool_cmd_speed_set(info,4294967295U);
    
#line 85 
    info->duplex = (unsigned char)255U;
  }
  
#line 88 
  info->autoneg = (unsigned char)0U;
  
#line 89 
  __retres = 0;
  
#line 89 
  return __retres;
}


#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static void vxge_ethtool_gdrvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
  char const *tmp_0;
  
#line 103 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 104 
  strlcpy((char *)(& info->driver),"vxge",32UL);
  
#line 105 
  strlcpy((char *)(& info->version),"2",32UL);
  
#line 106 
  strlcpy((char *)(& info->fw_version),(char const *)(& vdev->fw_version),32UL);
  
#line 107 
  tmp_0 = pci_name((struct pci_dev const *)vdev->pdev);
  
#line 107 
  ;
  
#line 107 
  strlcpy((char *)(& info->bus_info),tmp_0,32UL);
  
#line 108 
  info->regdump_len = (unsigned int)((unsigned long)vdev->no_of_vpath) * 9800U;
  
#line 111 
  info->n_stats = 271U;
  
#line 112 
  return;
}


#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static void vxge_ethtool_gregs(struct net_device *dev, struct ethtool_regs *regs, void *space)
{
  int index;
  int offset;
  enum vxge_hw_status status;
  u64 reg;
  u64 *tmp_0;
  
#line 130 
  u64 *reg_space = (u64 *)space;
  
#line 131 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 132 
  struct __vxge_hw_device *hldev = vdev->devh;
  
#line 134 
  regs->len = (unsigned int)((unsigned long)vdev->no_of_vpath) * 9800U;
  
#line 135 
  regs->version = (unsigned int)(vdev->pdev)->subsystem_device;
  
#line 136 
  index = 0;
  
#line 136 
  goto ldv_48098;
  ldv_48097: 
#line 137 
  ;
  
#line 137 
  offset = 0;
  
#line 137 
  goto ldv_48095;
  ldv_48094: 
#line 138 
  ;
  
#line 139 
  status = vxge_hw_mgmt_reg_read(hldev,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_vpath,(unsigned int)(vdev->vpaths + index)->device_id,(unsigned int)offset,& reg);
  
#line 143 
  if (status != VXGE_HW_OK) {
    
#line 144 
    printk("%s:%d Getting reg dump Failed","vxge_ethtool_gregs",146);
    
#line 147 
    goto return_label;
  }
  else ;
  
#line 149 
  tmp_0 = reg_space;
  
#line 149 
  reg_space += 1;
  
#line 149 
  *tmp_0 = reg;
  
#line 138 
  offset += 8;
  ldv_48095: 
#line 139 
  ;
  
#line 137 
  if ((unsigned int)offset <= 9799U) 
#line 139 
                                     goto ldv_48094; else 
#line 142 
                                                          goto ldv_48096;
  ldv_48096: 
#line 143 
  ;
  
#line 136 
  index += 1;
  ldv_48098: 
#line 137 
  ;
  
#line 136 
  if (vdev->no_of_vpath > index) 
#line 138 
                                 goto ldv_48097; else 
#line 141 
                                                      goto ldv_48099;
  ldv_48099: 
#line 142 
  ;
  return_label: 
#line 143 
                return;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static int vxge_ethtool_idnic(struct net_device *dev, enum ethtool_phys_id_state state)
{
  int __retres;
  
#line 165 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 166 
  struct __vxge_hw_device *hldev = vdev->devh;
  
#line 168 
  switch ((unsigned int)state) {
    case (unsigned int)1: 
#line 169 
    ;
    
#line 170 
    vxge_hw_device_flick_link_led(hldev,1ULL);
    
#line 171 
    goto ldv_48107;
    case (unsigned int)0: 
#line 173 
    ;
    
#line 174 
    vxge_hw_device_flick_link_led(hldev,0ULL);
    
#line 175 
    goto ldv_48107;
    default: 
#line 177 
    ;
    
#line 178 
    __retres = -22;
    
#line 178 
    goto return_label;
  }
  ldv_48107: 
#line 181 
  ;
  
#line 181 
  __retres = 0;
  return_label: 
#line 181 
                return __retres;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static void vxge_ethtool_getpause_data(struct net_device *dev, struct ethtool_pauseparam *ep)
{
  
#line 196 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 197 
  struct __vxge_hw_device *hldev = vdev->devh;
  
#line 199 
  vxge_hw_device_getpause_data(hldev,0U,& ep->tx_pause,& ep->rx_pause);
  
#line 200 
  return;
}


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static int vxge_ethtool_setpause_data(struct net_device *dev, struct ethtool_pauseparam *ep)
{
  int __retres;
  
#line 215 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 216 
  struct __vxge_hw_device *hldev = vdev->devh;
  
#line 218 
  vxge_hw_device_setpause_data(hldev,0U,ep->tx_pause,ep->rx_pause);
  
#line 220 
  vdev->config.tx_pause_enable = (int)ep->tx_pause;
  
#line 221 
  vdev->config.rx_pause_enable = (int)ep->rx_pause;
  
#line 223 
  __retres = 0;
  
#line 223 
  return __retres;
}


#line 226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static void vxge_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *estats, u64 *tmp_stats)
{
  int j;
  int k;
  enum vxge_hw_status status;
  enum vxge_hw_status swstatus;
  struct vxge_hw_xmac_stats *xmac_stats;
  struct vxge_hw_device_stats_sw_info *sw_stats;
  struct vxge_hw_device_stats_hw_info *hw_stats;
  int tmp_0;
  u64 *tmp_4;
  u64 *tmp_66;
  u64 *tmp_67;
  u64 *tmp_68;
  u64 *tmp_69;
  u64 *tmp_70;
  u64 *tmp_71;
  u64 *tmp_72;
  u64 *tmp_73;
  u64 *tmp_74;
  u64 *tmp_75;
  u64 *tmp_76;
  u64 *tmp_77;
  u64 *tmp_78;
  u64 *tmp_79;
  u64 *tmp_80;
  u64 *tmp_81;
  u64 *tmp_82;
  u64 *tmp_83;
  u64 *tmp_84;
  u64 *tmp_85;
  u64 *tmp_86;
  u64 *tmp_87;
  u64 *tmp_88;
  u64 *tmp_89;
  u64 *tmp_90;
  u64 *tmp_91;
  u64 *tmp_92;
  u64 *tmp_93;
  u64 *tmp_94;
  u64 *tmp_95;
  u64 *tmp_96;
  u64 *tmp_97;
  u64 *tmp_98;
  u64 *tmp_99;
  u64 *tmp_100;
  u64 *tmp_101;
  u64 *tmp_102;
  u64 *tmp_103;
  u64 *tmp_104;
  u64 *tmp_105;
  u64 *tmp_106;
  u64 *tmp_107;
  u64 *tmp_108;
  u64 *tmp_109;
  u64 *tmp_110;
  u64 *tmp_111;
  u64 *tmp_112;
  u64 *tmp_113;
  u64 *tmp_114;
  u64 *tmp_115;
  u64 *tmp_116;
  u64 *tmp_117;
  u64 *tmp_118;
  u64 *tmp_119;
  u64 *tmp_120;
  u64 *tmp_121;
  u64 *tmp_122;
  u64 *tmp_123;
  u64 *tmp_124;
  u64 *tmp_125;
  u64 *tmp_126;
  u64 *tmp_127;
  u64 *tmp_128;
  u64 *tmp_129;
  u64 *tmp_130;
  u64 *tmp_131;
  u64 *tmp_132;
  u64 *tmp_133;
  u64 *tmp_134;
  u64 *tmp_135;
  u64 *tmp_136;
  u64 *tmp_137;
  u64 *tmp_138;
  u64 *tmp_139;
  u64 *tmp_140;
  u64 *tmp_141;
  u64 *tmp_142;
  u64 *tmp_143;
  u64 *tmp_144;
  u64 *tmp_145;
  u64 *tmp_146;
  u64 *tmp_147;
  u64 *tmp_148;
  u64 *tmp_149;
  u64 *tmp_150;
  u64 *tmp_151;
  u64 *tmp_152;
  u64 *tmp_153;
  u64 *tmp_154;
  u64 *tmp_155;
  u64 *tmp_156;
  u64 *tmp_157;
  u64 *tmp_158;
  u64 *tmp_159;
  u64 *tmp_160;
  u64 *tmp_161;
  u64 *tmp_162;
  u64 *tmp_163;
  u64 *tmp_164;
  u64 *tmp_165;
  u64 *tmp_166;
  u64 *tmp_167;
  u64 *tmp_168;
  u64 *tmp_169;
  u64 *tmp_170;
  u64 *tmp_171;
  u64 *tmp_172;
  u64 *tmp_173;
  u64 *tmp_174;
  u64 *tmp_175;
  u64 *tmp_206;
  u64 *tmp_234;
  u64 *tmp_235;
  u64 *tmp_236;
  u64 *tmp_237;
  u64 *tmp_238;
  
#line 232 
  struct vxge_vpath *vpath = (struct vxge_vpath *)0;
  
#line 233 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 234 
  struct __vxge_hw_device *hldev = vdev->devh;
  
#line 239 
  u64 *ptr = tmp_stats;
  
#line 242 
  tmp_0 = vxge_ethtool_get_sset_count(dev,1);
  
#line 241 
  ;
  
#line 241 
  memset((void *)tmp_stats,0,(unsigned long)tmp_0 * 8UL);
  
#line 244 
  xmac_stats = (struct vxge_hw_xmac_stats *)kzalloc(9784UL,208U);
  
#line 245 
  if (xmac_stats == (struct vxge_hw_xmac_stats *)0) {
    
#line 246 
    printk("%s : %d Memory Allocation failed for xmac_stats","vxge_get_ethtool_stats",248);
    
#line 249 
    goto return_label;
  }
  else ;
  
#line 252 
  sw_stats = (struct vxge_hw_device_stats_sw_info *)kzalloc(4096UL,208U);
  
#line 254 
  if (sw_stats == (struct vxge_hw_device_stats_sw_info *)0) {
    
#line 255 
    kfree((void const *)xmac_stats);
    
#line 256 
    printk("%s : %d Memory Allocation failed for sw_stats","vxge_get_ethtool_stats",258);
    
#line 259 
    goto return_label;
  }
  else ;
  
#line 262 
  hw_stats = (struct vxge_hw_device_stats_hw_info *)kzalloc(10744UL,208U);
  
#line 264 
  if (hw_stats == (struct vxge_hw_device_stats_hw_info *)0) {
    
#line 265 
    kfree((void const *)xmac_stats);
    
#line 266 
    kfree((void const *)sw_stats);
    
#line 267 
    printk("%s : %d Memory Allocation failed for hw_stats","vxge_get_ethtool_stats",269);
    
#line 270 
    goto return_label;
  }
  else ;
  
#line 273 
  tmp_4 = ptr;
  
#line 273 
  ptr += 1;
  
#line 273 
  *tmp_4 = 0ULL;
  
#line 274 
  status = vxge_hw_device_xmac_stats_get(hldev,xmac_stats);
  
#line 275 
  if (status != VXGE_HW_OK) {
    
#line 276 
    if (status != VXGE_HW_ERR_PRIVILAGED_OPEARATION) 
#line 277 
                                                     printk("%s : %d Failure in getting xmac stats","vxge_get_ethtool_stats",279); else ;
  }
  else ;
  
#line 282 
  swstatus = vxge_hw_driver_stats_get(hldev,sw_stats);
  
#line 283 
  if (swstatus != VXGE_HW_OK) 
#line 284 
                              printk("%s : %d Failure in getting sw stats","vxge_get_ethtool_stats",286); else ;
  
#line 289 
  status = vxge_hw_device_stats_get(hldev,hw_stats);
  
#line 290 
  if (status != VXGE_HW_OK) 
#line 291 
                            printk("%s : %d hw_stats_get error","vxge_get_ethtool_stats",292); else ;
  
#line 295 
  k = 0;
  
#line 295 
  goto ldv_48142;
  ldv_48141: 
#line 296 
  ;
  {
    struct vxge_hw_vpath_stats_hw_info *vpath_info;
    u64 *tmp_5;
    u64 *tmp_6;
    u64 *tmp_7;
    u64 *tmp_8;
    u64 *tmp_9;
    u64 *tmp_10;
    u64 *tmp_11;
    u64 *tmp_12;
    u64 *tmp_13;
    u64 *tmp_14;
    u64 *tmp_15;
    u64 *tmp_16;
    u64 *tmp_17;
    u64 *tmp_18;
    u64 *tmp_19;
    u64 *tmp_20;
    u64 *tmp_21;
    u64 *tmp_22;
    u64 *tmp_23;
    u64 *tmp_24;
    u64 *tmp_25;
    u64 *tmp_26;
    u64 *tmp_27;
    u64 *tmp_28;
    u64 *tmp_29;
    u64 *tmp_30;
    u64 *tmp_31;
    u64 *tmp_32;
    u64 *tmp_33;
    u64 *tmp_34;
    u64 *tmp_35;
    u64 *tmp_36;
    u64 *tmp_37;
    u64 *tmp_38;
    u64 *tmp_39;
    u64 *tmp_40;
    u64 *tmp_41;
    u64 *tmp_42;
    u64 *tmp_43;
    u64 *tmp_44;
    u64 *tmp_45;
    u64 *tmp_46;
    u64 *tmp_47;
    u64 *tmp_48;
    u64 *tmp_49;
    u64 *tmp_50;
    u64 *tmp_51;
    u64 *tmp_52;
    u64 *tmp_53;
    u64 *tmp_54;
    u64 *tmp_55;
    u64 *tmp_56;
    u64 *tmp_57;
    u64 *tmp_58;
    u64 *tmp_59;
    u64 *tmp_60;
    u64 *tmp_61;
    u64 *tmp_62;
    u64 *tmp_63;
    u64 *tmp_64;
    u64 *tmp_65;
    
#line 298 
    vpath = vdev->vpaths + k;
    
#line 299 
    j = vpath->device_id;
    
#line 300 
    vpath_info = hw_stats->vpath_info[j];
    
#line 301 
    if (vpath_info == (struct vxge_hw_vpath_stats_hw_info *)0) {
      
#line 302 
      memset((void *)ptr,0,488UL);
      
#line 304 
      ptr += 61U;
      
#line 306 
      goto ldv_48140;
    }
    else ;
    
#line 309 
    tmp_5 = ptr;
    
#line 309 
    ptr += 1;
    
#line 309 
    *tmp_5 = vpath_info->tx_stats.tx_ttl_eth_frms;
    
#line 310 
    tmp_6 = ptr;
    
#line 310 
    ptr += 1;
    
#line 310 
    *tmp_6 = vpath_info->tx_stats.tx_ttl_eth_octets;
    
#line 311 
    tmp_7 = ptr;
    
#line 311 
    ptr += 1;
    
#line 311 
    *tmp_7 = vpath_info->tx_stats.tx_data_octets;
    
#line 312 
    tmp_8 = ptr;
    
#line 312 
    ptr += 1;
    
#line 312 
    *tmp_8 = vpath_info->tx_stats.tx_mcast_frms;
    
#line 313 
    tmp_9 = ptr;
    
#line 313 
    ptr += 1;
    
#line 313 
    *tmp_9 = vpath_info->tx_stats.tx_bcast_frms;
    
#line 314 
    tmp_10 = ptr;
    
#line 314 
    ptr += 1;
    
#line 314 
    *tmp_10 = vpath_info->tx_stats.tx_ucast_frms;
    
#line 315 
    tmp_11 = ptr;
    
#line 315 
    ptr += 1;
    
#line 315 
    *tmp_11 = vpath_info->tx_stats.tx_tagged_frms;
    
#line 316 
    tmp_12 = ptr;
    
#line 316 
    ptr += 1;
    
#line 316 
    *tmp_12 = vpath_info->tx_stats.tx_vld_ip;
    
#line 317 
    tmp_13 = ptr;
    
#line 317 
    ptr += 1;
    
#line 317 
    *tmp_13 = vpath_info->tx_stats.tx_vld_ip_octets;
    
#line 318 
    tmp_14 = ptr;
    
#line 318 
    ptr += 1;
    
#line 318 
    *tmp_14 = vpath_info->tx_stats.tx_icmp;
    
#line 319 
    tmp_15 = ptr;
    
#line 319 
    ptr += 1;
    
#line 319 
    *tmp_15 = vpath_info->tx_stats.tx_tcp;
    
#line 320 
    tmp_16 = ptr;
    
#line 320 
    ptr += 1;
    
#line 320 
    *tmp_16 = vpath_info->tx_stats.tx_rst_tcp;
    
#line 321 
    tmp_17 = ptr;
    
#line 321 
    ptr += 1;
    
#line 321 
    *tmp_17 = vpath_info->tx_stats.tx_udp;
    
#line 322 
    tmp_18 = ptr;
    
#line 322 
    ptr += 1;
    
#line 322 
    *tmp_18 = (unsigned long long)vpath_info->tx_stats.tx_unknown_protocol;
    
#line 323 
    tmp_19 = ptr;
    
#line 323 
    ptr += 1;
    
#line 323 
    *tmp_19 = (unsigned long long)vpath_info->tx_stats.tx_lost_ip;
    
#line 324 
    tmp_20 = ptr;
    
#line 324 
    ptr += 1;
    
#line 324 
    *tmp_20 = (unsigned long long)vpath_info->tx_stats.tx_parse_error;
    
#line 325 
    tmp_21 = ptr;
    
#line 325 
    ptr += 1;
    
#line 325 
    *tmp_21 = vpath_info->tx_stats.tx_tcp_offload;
    
#line 326 
    tmp_22 = ptr;
    
#line 326 
    ptr += 1;
    
#line 326 
    *tmp_22 = vpath_info->tx_stats.tx_retx_tcp_offload;
    
#line 327 
    tmp_23 = ptr;
    
#line 327 
    ptr += 1;
    
#line 327 
    *tmp_23 = vpath_info->tx_stats.tx_lost_ip_offload;
    
#line 328 
    tmp_24 = ptr;
    
#line 328 
    ptr += 1;
    
#line 328 
    *tmp_24 = vpath_info->rx_stats.rx_ttl_eth_frms;
    
#line 329 
    tmp_25 = ptr;
    
#line 329 
    ptr += 1;
    
#line 329 
    *tmp_25 = vpath_info->rx_stats.rx_vld_frms;
    
#line 330 
    tmp_26 = ptr;
    
#line 330 
    ptr += 1;
    
#line 330 
    *tmp_26 = vpath_info->rx_stats.rx_offload_frms;
    
#line 331 
    tmp_27 = ptr;
    
#line 331 
    ptr += 1;
    
#line 331 
    *tmp_27 = vpath_info->rx_stats.rx_ttl_eth_octets;
    
#line 332 
    tmp_28 = ptr;
    
#line 332 
    ptr += 1;
    
#line 332 
    *tmp_28 = vpath_info->rx_stats.rx_data_octets;
    
#line 333 
    tmp_29 = ptr;
    
#line 333 
    ptr += 1;
    
#line 333 
    *tmp_29 = vpath_info->rx_stats.rx_offload_octets;
    
#line 334 
    tmp_30 = ptr;
    
#line 334 
    ptr += 1;
    
#line 334 
    *tmp_30 = vpath_info->rx_stats.rx_vld_mcast_frms;
    
#line 335 
    tmp_31 = ptr;
    
#line 335 
    ptr += 1;
    
#line 335 
    *tmp_31 = vpath_info->rx_stats.rx_vld_bcast_frms;
    
#line 336 
    tmp_32 = ptr;
    
#line 336 
    ptr += 1;
    
#line 336 
    *tmp_32 = vpath_info->rx_stats.rx_accepted_ucast_frms;
    
#line 337 
    tmp_33 = ptr;
    
#line 337 
    ptr += 1;
    
#line 337 
    *tmp_33 = vpath_info->rx_stats.rx_accepted_nucast_frms;
    
#line 338 
    tmp_34 = ptr;
    
#line 338 
    ptr += 1;
    
#line 338 
    *tmp_34 = vpath_info->rx_stats.rx_tagged_frms;
    
#line 339 
    tmp_35 = ptr;
    
#line 339 
    ptr += 1;
    
#line 339 
    *tmp_35 = vpath_info->rx_stats.rx_long_frms;
    
#line 340 
    tmp_36 = ptr;
    
#line 340 
    ptr += 1;
    
#line 340 
    *tmp_36 = vpath_info->rx_stats.rx_usized_frms;
    
#line 341 
    tmp_37 = ptr;
    
#line 341 
    ptr += 1;
    
#line 341 
    *tmp_37 = vpath_info->rx_stats.rx_osized_frms;
    
#line 342 
    tmp_38 = ptr;
    
#line 342 
    ptr += 1;
    
#line 342 
    *tmp_38 = vpath_info->rx_stats.rx_frag_frms;
    
#line 343 
    tmp_39 = ptr;
    
#line 343 
    ptr += 1;
    
#line 343 
    *tmp_39 = vpath_info->rx_stats.rx_jabber_frms;
    
#line 344 
    tmp_40 = ptr;
    
#line 344 
    ptr += 1;
    
#line 344 
    *tmp_40 = vpath_info->rx_stats.rx_ttl_64_frms;
    
#line 345 
    tmp_41 = ptr;
    
#line 345 
    ptr += 1;
    
#line 345 
    *tmp_41 = vpath_info->rx_stats.rx_ttl_65_127_frms;
    
#line 346 
    tmp_42 = ptr;
    
#line 346 
    ptr += 1;
    
#line 346 
    *tmp_42 = vpath_info->rx_stats.rx_ttl_128_255_frms;
    
#line 347 
    tmp_43 = ptr;
    
#line 347 
    ptr += 1;
    
#line 347 
    *tmp_43 = vpath_info->rx_stats.rx_ttl_256_511_frms;
    
#line 348 
    tmp_44 = ptr;
    
#line 348 
    ptr += 1;
    
#line 348 
    *tmp_44 = vpath_info->rx_stats.rx_ttl_512_1023_frms;
    
#line 349 
    tmp_45 = ptr;
    
#line 349 
    ptr += 1;
    
#line 349 
    *tmp_45 = vpath_info->rx_stats.rx_ttl_1024_1518_frms;
    
#line 350 
    tmp_46 = ptr;
    
#line 350 
    ptr += 1;
    
#line 350 
    *tmp_46 = vpath_info->rx_stats.rx_ttl_1519_4095_frms;
    
#line 351 
    tmp_47 = ptr;
    
#line 351 
    ptr += 1;
    
#line 351 
    *tmp_47 = vpath_info->rx_stats.rx_ttl_4096_8191_frms;
    
#line 352 
    tmp_48 = ptr;
    
#line 352 
    ptr += 1;
    
#line 352 
    *tmp_48 = vpath_info->rx_stats.rx_ttl_8192_max_frms;
    
#line 353 
    tmp_49 = ptr;
    
#line 353 
    ptr += 1;
    
#line 353 
    *tmp_49 = vpath_info->rx_stats.rx_ttl_gt_max_frms;
    
#line 354 
    tmp_50 = ptr;
    
#line 354 
    ptr += 1;
    
#line 354 
    *tmp_50 = vpath_info->rx_stats.rx_ip;
    
#line 355 
    tmp_51 = ptr;
    
#line 355 
    ptr += 1;
    
#line 355 
    *tmp_51 = vpath_info->rx_stats.rx_accepted_ip;
    
#line 356 
    tmp_52 = ptr;
    
#line 356 
    ptr += 1;
    
#line 356 
    *tmp_52 = vpath_info->rx_stats.rx_ip_octets;
    
#line 357 
    tmp_53 = ptr;
    
#line 357 
    ptr += 1;
    
#line 357 
    *tmp_53 = vpath_info->rx_stats.rx_err_ip;
    
#line 358 
    tmp_54 = ptr;
    
#line 358 
    ptr += 1;
    
#line 358 
    *tmp_54 = vpath_info->rx_stats.rx_icmp;
    
#line 359 
    tmp_55 = ptr;
    
#line 359 
    ptr += 1;
    
#line 359 
    *tmp_55 = vpath_info->rx_stats.rx_tcp;
    
#line 360 
    tmp_56 = ptr;
    
#line 360 
    ptr += 1;
    
#line 360 
    *tmp_56 = vpath_info->rx_stats.rx_udp;
    
#line 361 
    tmp_57 = ptr;
    
#line 361 
    ptr += 1;
    
#line 361 
    *tmp_57 = vpath_info->rx_stats.rx_err_tcp;
    
#line 362 
    tmp_58 = ptr;
    
#line 362 
    ptr += 1;
    
#line 362 
    *tmp_58 = vpath_info->rx_stats.rx_lost_frms;
    
#line 363 
    tmp_59 = ptr;
    
#line 363 
    ptr += 1;
    
#line 363 
    *tmp_59 = vpath_info->rx_stats.rx_lost_ip;
    
#line 364 
    tmp_60 = ptr;
    
#line 364 
    ptr += 1;
    
#line 364 
    *tmp_60 = vpath_info->rx_stats.rx_lost_ip_offload;
    
#line 365 
    tmp_61 = ptr;
    
#line 365 
    ptr += 1;
    
#line 365 
    *tmp_61 = (unsigned long long)vpath_info->rx_stats.rx_various_discard;
    
#line 366 
    tmp_62 = ptr;
    
#line 366 
    ptr += 1;
    
#line 366 
    *tmp_62 = (unsigned long long)vpath_info->rx_stats.rx_sleep_discard;
    
#line 367 
    tmp_63 = ptr;
    
#line 367 
    ptr += 1;
    
#line 367 
    *tmp_63 = (unsigned long long)vpath_info->rx_stats.rx_red_discard;
    
#line 368 
    tmp_64 = ptr;
    
#line 368 
    ptr += 1;
    
#line 368 
    *tmp_64 = (unsigned long long)vpath_info->rx_stats.rx_queue_full_discard;
    
#line 369 
    tmp_65 = ptr;
    
#line 369 
    ptr += 1;
    
#line 369 
    *tmp_65 = vpath_info->rx_stats.rx_mpa_ok_frms;
  }
  ldv_48140: 
#line 371 
  ;
  
#line 295 
  k += 1;
  ldv_48142: 
#line 296 
  ;
  
#line 295 
  if (vdev->no_of_vpath > k) 
#line 297 
                             goto ldv_48141; else 
#line 300 
                                                  goto ldv_48143;
  ldv_48143: 
#line 301 
  ;
  
#line 371 
  tmp_66 = ptr;
  
#line 371 
  ptr += 1;
  
#line 371 
  *tmp_66 = 0ULL;
  
#line 372 
  k = 0;
  
#line 372 
  goto ldv_48145;
  ldv_48144: 
#line 373 
  ;
  
#line 373 
  tmp_67 = ptr;
  
#line 373 
  ptr += 1;
  
#line 373 
  *tmp_67 = xmac_stats->aggr_stats[k].tx_frms;
  
#line 374 
  tmp_68 = ptr;
  
#line 374 
  ptr += 1;
  
#line 374 
  *tmp_68 = xmac_stats->aggr_stats[k].tx_data_octets;
  
#line 375 
  tmp_69 = ptr;
  
#line 375 
  ptr += 1;
  
#line 375 
  *tmp_69 = xmac_stats->aggr_stats[k].tx_mcast_frms;
  
#line 376 
  tmp_70 = ptr;
  
#line 376 
  ptr += 1;
  
#line 376 
  *tmp_70 = xmac_stats->aggr_stats[k].tx_bcast_frms;
  
#line 377 
  tmp_71 = ptr;
  
#line 377 
  ptr += 1;
  
#line 377 
  *tmp_71 = xmac_stats->aggr_stats[k].tx_discarded_frms;
  
#line 378 
  tmp_72 = ptr;
  
#line 378 
  ptr += 1;
  
#line 378 
  *tmp_72 = xmac_stats->aggr_stats[k].tx_errored_frms;
  
#line 379 
  tmp_73 = ptr;
  
#line 379 
  ptr += 1;
  
#line 379 
  *tmp_73 = xmac_stats->aggr_stats[k].rx_frms;
  
#line 380 
  tmp_74 = ptr;
  
#line 380 
  ptr += 1;
  
#line 380 
  *tmp_74 = xmac_stats->aggr_stats[k].rx_data_octets;
  
#line 381 
  tmp_75 = ptr;
  
#line 381 
  ptr += 1;
  
#line 381 
  *tmp_75 = xmac_stats->aggr_stats[k].rx_mcast_frms;
  
#line 382 
  tmp_76 = ptr;
  
#line 382 
  ptr += 1;
  
#line 382 
  *tmp_76 = xmac_stats->aggr_stats[k].rx_bcast_frms;
  
#line 383 
  tmp_77 = ptr;
  
#line 383 
  ptr += 1;
  
#line 383 
  *tmp_77 = xmac_stats->aggr_stats[k].rx_discarded_frms;
  
#line 384 
  tmp_78 = ptr;
  
#line 384 
  ptr += 1;
  
#line 384 
  *tmp_78 = xmac_stats->aggr_stats[k].rx_errored_frms;
  
#line 385 
  tmp_79 = ptr;
  
#line 385 
  ptr += 1;
  
#line 385 
  *tmp_79 = xmac_stats->aggr_stats[k].rx_unknown_slow_proto_frms;
  
#line 372 
  k += 1;
  ldv_48145: 
#line 373 
  ;
  
#line 372 
  if (vdev->max_config_port > k) 
#line 374 
                                 goto ldv_48144; else 
#line 377 
                                                      goto ldv_48146;
  ldv_48146: 
#line 378 
  ;
  
#line 387 
  tmp_80 = ptr;
  
#line 387 
  ptr += 1;
  
#line 387 
  *tmp_80 = 0ULL;
  
#line 388 
  k = 0;
  
#line 388 
  goto ldv_48148;
  ldv_48147: 
#line 389 
  ;
  
#line 389 
  tmp_81 = ptr;
  
#line 389 
  ptr += 1;
  
#line 389 
  *tmp_81 = xmac_stats->port_stats[k].tx_ttl_frms;
  
#line 390 
  tmp_82 = ptr;
  
#line 390 
  ptr += 1;
  
#line 390 
  *tmp_82 = xmac_stats->port_stats[k].tx_ttl_octets;
  
#line 391 
  tmp_83 = ptr;
  
#line 391 
  ptr += 1;
  
#line 391 
  *tmp_83 = xmac_stats->port_stats[k].tx_data_octets;
  
#line 392 
  tmp_84 = ptr;
  
#line 392 
  ptr += 1;
  
#line 392 
  *tmp_84 = xmac_stats->port_stats[k].tx_mcast_frms;
  
#line 393 
  tmp_85 = ptr;
  
#line 393 
  ptr += 1;
  
#line 393 
  *tmp_85 = xmac_stats->port_stats[k].tx_bcast_frms;
  
#line 394 
  tmp_86 = ptr;
  
#line 394 
  ptr += 1;
  
#line 394 
  *tmp_86 = xmac_stats->port_stats[k].tx_ucast_frms;
  
#line 395 
  tmp_87 = ptr;
  
#line 395 
  ptr += 1;
  
#line 395 
  *tmp_87 = xmac_stats->port_stats[k].tx_tagged_frms;
  
#line 396 
  tmp_88 = ptr;
  
#line 396 
  ptr += 1;
  
#line 396 
  *tmp_88 = xmac_stats->port_stats[k].tx_vld_ip;
  
#line 397 
  tmp_89 = ptr;
  
#line 397 
  ptr += 1;
  
#line 397 
  *tmp_89 = xmac_stats->port_stats[k].tx_vld_ip_octets;
  
#line 398 
  tmp_90 = ptr;
  
#line 398 
  ptr += 1;
  
#line 398 
  *tmp_90 = xmac_stats->port_stats[k].tx_icmp;
  
#line 399 
  tmp_91 = ptr;
  
#line 399 
  ptr += 1;
  
#line 399 
  *tmp_91 = xmac_stats->port_stats[k].tx_tcp;
  
#line 400 
  tmp_92 = ptr;
  
#line 400 
  ptr += 1;
  
#line 400 
  *tmp_92 = xmac_stats->port_stats[k].tx_rst_tcp;
  
#line 401 
  tmp_93 = ptr;
  
#line 401 
  ptr += 1;
  
#line 401 
  *tmp_93 = xmac_stats->port_stats[k].tx_udp;
  
#line 402 
  tmp_94 = ptr;
  
#line 402 
  ptr += 1;
  
#line 402 
  *tmp_94 = (unsigned long long)xmac_stats->port_stats[k].tx_parse_error;
  
#line 403 
  tmp_95 = ptr;
  
#line 403 
  ptr += 1;
  
#line 403 
  *tmp_95 = (unsigned long long)xmac_stats->port_stats[k].tx_unknown_protocol;
  
#line 404 
  tmp_96 = ptr;
  
#line 404 
  ptr += 1;
  
#line 404 
  *tmp_96 = xmac_stats->port_stats[k].tx_pause_ctrl_frms;
  
#line 405 
  tmp_97 = ptr;
  
#line 405 
  ptr += 1;
  
#line 405 
  *tmp_97 = (unsigned long long)xmac_stats->port_stats[k].tx_marker_pdu_frms;
  
#line 406 
  tmp_98 = ptr;
  
#line 406 
  ptr += 1;
  
#line 406 
  *tmp_98 = (unsigned long long)xmac_stats->port_stats[k].tx_lacpdu_frms;
  
#line 407 
  tmp_99 = ptr;
  
#line 407 
  ptr += 1;
  
#line 407 
  *tmp_99 = (unsigned long long)xmac_stats->port_stats[k].tx_drop_ip;
  
#line 408 
  tmp_100 = ptr;
  
#line 408 
  ptr += 1;
  
#line 408 
  *tmp_100 = (unsigned long long)xmac_stats->port_stats[k].tx_marker_resp_pdu_frms;
  
#line 409 
  tmp_101 = ptr;
  
#line 409 
  ptr += 1;
  
#line 409 
  *tmp_101 = (unsigned long long)xmac_stats->port_stats[k].tx_xgmii_char2_match;
  
#line 410 
  tmp_102 = ptr;
  
#line 410 
  ptr += 1;
  
#line 410 
  *tmp_102 = (unsigned long long)xmac_stats->port_stats[k].tx_xgmii_char1_match;
  
#line 411 
  tmp_103 = ptr;
  
#line 411 
  ptr += 1;
  
#line 411 
  *tmp_103 = (unsigned long long)xmac_stats->port_stats[k].tx_xgmii_column2_match;
  
#line 412 
  tmp_104 = ptr;
  
#line 412 
  ptr += 1;
  
#line 412 
  *tmp_104 = (unsigned long long)xmac_stats->port_stats[k].tx_xgmii_column1_match;
  
#line 413 
  tmp_105 = ptr;
  
#line 413 
  ptr += 1;
  
#line 413 
  *tmp_105 = (unsigned long long)xmac_stats->port_stats[k].tx_any_err_frms;
  
#line 414 
  tmp_106 = ptr;
  
#line 414 
  ptr += 1;
  
#line 414 
  *tmp_106 = (unsigned long long)xmac_stats->port_stats[k].tx_drop_frms;
  
#line 415 
  tmp_107 = ptr;
  
#line 415 
  ptr += 1;
  
#line 415 
  *tmp_107 = xmac_stats->port_stats[k].rx_ttl_frms;
  
#line 416 
  tmp_108 = ptr;
  
#line 416 
  ptr += 1;
  
#line 416 
  *tmp_108 = xmac_stats->port_stats[k].rx_vld_frms;
  
#line 417 
  tmp_109 = ptr;
  
#line 417 
  ptr += 1;
  
#line 417 
  *tmp_109 = xmac_stats->port_stats[k].rx_offload_frms;
  
#line 418 
  tmp_110 = ptr;
  
#line 418 
  ptr += 1;
  
#line 418 
  *tmp_110 = xmac_stats->port_stats[k].rx_ttl_octets;
  
#line 419 
  tmp_111 = ptr;
  
#line 419 
  ptr += 1;
  
#line 419 
  *tmp_111 = xmac_stats->port_stats[k].rx_data_octets;
  
#line 420 
  tmp_112 = ptr;
  
#line 420 
  ptr += 1;
  
#line 420 
  *tmp_112 = xmac_stats->port_stats[k].rx_offload_octets;
  
#line 421 
  tmp_113 = ptr;
  
#line 421 
  ptr += 1;
  
#line 421 
  *tmp_113 = xmac_stats->port_stats[k].rx_vld_mcast_frms;
  
#line 422 
  tmp_114 = ptr;
  
#line 422 
  ptr += 1;
  
#line 422 
  *tmp_114 = xmac_stats->port_stats[k].rx_vld_bcast_frms;
  
#line 423 
  tmp_115 = ptr;
  
#line 423 
  ptr += 1;
  
#line 423 
  *tmp_115 = xmac_stats->port_stats[k].rx_accepted_ucast_frms;
  
#line 424 
  tmp_116 = ptr;
  
#line 424 
  ptr += 1;
  
#line 424 
  *tmp_116 = xmac_stats->port_stats[k].rx_accepted_nucast_frms;
  
#line 425 
  tmp_117 = ptr;
  
#line 425 
  ptr += 1;
  
#line 425 
  *tmp_117 = xmac_stats->port_stats[k].rx_tagged_frms;
  
#line 426 
  tmp_118 = ptr;
  
#line 426 
  ptr += 1;
  
#line 426 
  *tmp_118 = xmac_stats->port_stats[k].rx_long_frms;
  
#line 427 
  tmp_119 = ptr;
  
#line 427 
  ptr += 1;
  
#line 427 
  *tmp_119 = xmac_stats->port_stats[k].rx_usized_frms;
  
#line 428 
  tmp_120 = ptr;
  
#line 428 
  ptr += 1;
  
#line 428 
  *tmp_120 = xmac_stats->port_stats[k].rx_osized_frms;
  
#line 429 
  tmp_121 = ptr;
  
#line 429 
  ptr += 1;
  
#line 429 
  *tmp_121 = xmac_stats->port_stats[k].rx_frag_frms;
  
#line 430 
  tmp_122 = ptr;
  
#line 430 
  ptr += 1;
  
#line 430 
  *tmp_122 = xmac_stats->port_stats[k].rx_jabber_frms;
  
#line 431 
  tmp_123 = ptr;
  
#line 431 
  ptr += 1;
  
#line 431 
  *tmp_123 = xmac_stats->port_stats[k].rx_ttl_64_frms;
  
#line 432 
  tmp_124 = ptr;
  
#line 432 
  ptr += 1;
  
#line 432 
  *tmp_124 = xmac_stats->port_stats[k].rx_ttl_65_127_frms;
  
#line 433 
  tmp_125 = ptr;
  
#line 433 
  ptr += 1;
  
#line 433 
  *tmp_125 = xmac_stats->port_stats[k].rx_ttl_128_255_frms;
  
#line 434 
  tmp_126 = ptr;
  
#line 434 
  ptr += 1;
  
#line 434 
  *tmp_126 = xmac_stats->port_stats[k].rx_ttl_256_511_frms;
  
#line 435 
  tmp_127 = ptr;
  
#line 435 
  ptr += 1;
  
#line 435 
  *tmp_127 = xmac_stats->port_stats[k].rx_ttl_512_1023_frms;
  
#line 436 
  tmp_128 = ptr;
  
#line 436 
  ptr += 1;
  
#line 436 
  *tmp_128 = xmac_stats->port_stats[k].rx_ttl_1024_1518_frms;
  
#line 437 
  tmp_129 = ptr;
  
#line 437 
  ptr += 1;
  
#line 437 
  *tmp_129 = xmac_stats->port_stats[k].rx_ttl_1519_4095_frms;
  
#line 438 
  tmp_130 = ptr;
  
#line 438 
  ptr += 1;
  
#line 438 
  *tmp_130 = xmac_stats->port_stats[k].rx_ttl_4096_8191_frms;
  
#line 439 
  tmp_131 = ptr;
  
#line 439 
  ptr += 1;
  
#line 439 
  *tmp_131 = xmac_stats->port_stats[k].rx_ttl_8192_max_frms;
  
#line 440 
  tmp_132 = ptr;
  
#line 440 
  ptr += 1;
  
#line 440 
  *tmp_132 = xmac_stats->port_stats[k].rx_ttl_gt_max_frms;
  
#line 441 
  tmp_133 = ptr;
  
#line 441 
  ptr += 1;
  
#line 441 
  *tmp_133 = xmac_stats->port_stats[k].rx_ip;
  
#line 442 
  tmp_134 = ptr;
  
#line 442 
  ptr += 1;
  
#line 442 
  *tmp_134 = xmac_stats->port_stats[k].rx_accepted_ip;
  
#line 443 
  tmp_135 = ptr;
  
#line 443 
  ptr += 1;
  
#line 443 
  *tmp_135 = xmac_stats->port_stats[k].rx_ip_octets;
  
#line 444 
  tmp_136 = ptr;
  
#line 444 
  ptr += 1;
  
#line 444 
  *tmp_136 = xmac_stats->port_stats[k].rx_err_ip;
  
#line 445 
  tmp_137 = ptr;
  
#line 445 
  ptr += 1;
  
#line 445 
  *tmp_137 = xmac_stats->port_stats[k].rx_icmp;
  
#line 446 
  tmp_138 = ptr;
  
#line 446 
  ptr += 1;
  
#line 446 
  *tmp_138 = xmac_stats->port_stats[k].rx_tcp;
  
#line 447 
  tmp_139 = ptr;
  
#line 447 
  ptr += 1;
  
#line 447 
  *tmp_139 = xmac_stats->port_stats[k].rx_udp;
  
#line 448 
  tmp_140 = ptr;
  
#line 448 
  ptr += 1;
  
#line 448 
  *tmp_140 = xmac_stats->port_stats[k].rx_err_tcp;
  
#line 449 
  tmp_141 = ptr;
  
#line 449 
  ptr += 1;
  
#line 449 
  *tmp_141 = xmac_stats->port_stats[k].rx_pause_count;
  
#line 450 
  tmp_142 = ptr;
  
#line 450 
  ptr += 1;
  
#line 450 
  *tmp_142 = xmac_stats->port_stats[k].rx_pause_ctrl_frms;
  
#line 451 
  tmp_143 = ptr;
  
#line 451 
  ptr += 1;
  
#line 451 
  *tmp_143 = xmac_stats->port_stats[k].rx_unsup_ctrl_frms;
  
#line 452 
  tmp_144 = ptr;
  
#line 452 
  ptr += 1;
  
#line 452 
  *tmp_144 = xmac_stats->port_stats[k].rx_fcs_err_frms;
  
#line 453 
  tmp_145 = ptr;
  
#line 453 
  ptr += 1;
  
#line 453 
  *tmp_145 = xmac_stats->port_stats[k].rx_in_rng_len_err_frms;
  
#line 454 
  tmp_146 = ptr;
  
#line 454 
  ptr += 1;
  
#line 454 
  *tmp_146 = xmac_stats->port_stats[k].rx_out_rng_len_err_frms;
  
#line 455 
  tmp_147 = ptr;
  
#line 455 
  ptr += 1;
  
#line 455 
  *tmp_147 = xmac_stats->port_stats[k].rx_drop_frms;
  
#line 456 
  tmp_148 = ptr;
  
#line 456 
  ptr += 1;
  
#line 456 
  *tmp_148 = xmac_stats->port_stats[k].rx_discarded_frms;
  
#line 457 
  tmp_149 = ptr;
  
#line 457 
  ptr += 1;
  
#line 457 
  *tmp_149 = xmac_stats->port_stats[k].rx_drop_ip;
  
#line 458 
  tmp_150 = ptr;
  
#line 458 
  ptr += 1;
  
#line 458 
  *tmp_150 = xmac_stats->port_stats[k].rx_drop_udp;
  
#line 459 
  tmp_151 = ptr;
  
#line 459 
  ptr += 1;
  
#line 459 
  *tmp_151 = (unsigned long long)xmac_stats->port_stats[k].rx_marker_pdu_frms;
  
#line 460 
  tmp_152 = ptr;
  
#line 460 
  ptr += 1;
  
#line 460 
  *tmp_152 = (unsigned long long)xmac_stats->port_stats[k].rx_lacpdu_frms;
  
#line 461 
  tmp_153 = ptr;
  
#line 461 
  ptr += 1;
  
#line 461 
  *tmp_153 = (unsigned long long)xmac_stats->port_stats[k].rx_unknown_pdu_frms;
  
#line 462 
  tmp_154 = ptr;
  
#line 462 
  ptr += 1;
  
#line 462 
  *tmp_154 = (unsigned long long)xmac_stats->port_stats[k].rx_marker_resp_pdu_frms;
  
#line 463 
  tmp_155 = ptr;
  
#line 463 
  ptr += 1;
  
#line 463 
  *tmp_155 = (unsigned long long)xmac_stats->port_stats[k].rx_fcs_discard;
  
#line 464 
  tmp_156 = ptr;
  
#line 464 
  ptr += 1;
  
#line 464 
  *tmp_156 = (unsigned long long)xmac_stats->port_stats[k].rx_illegal_pdu_frms;
  
#line 465 
  tmp_157 = ptr;
  
#line 465 
  ptr += 1;
  
#line 465 
  *tmp_157 = (unsigned long long)xmac_stats->port_stats[k].rx_switch_discard;
  
#line 466 
  tmp_158 = ptr;
  
#line 466 
  ptr += 1;
  
#line 466 
  *tmp_158 = (unsigned long long)xmac_stats->port_stats[k].rx_len_discard;
  
#line 467 
  tmp_159 = ptr;
  
#line 467 
  ptr += 1;
  
#line 467 
  *tmp_159 = (unsigned long long)xmac_stats->port_stats[k].rx_rpa_discard;
  
#line 468 
  tmp_160 = ptr;
  
#line 468 
  ptr += 1;
  
#line 468 
  *tmp_160 = (unsigned long long)xmac_stats->port_stats[k].rx_l2_mgmt_discard;
  
#line 469 
  tmp_161 = ptr;
  
#line 469 
  ptr += 1;
  
#line 469 
  *tmp_161 = (unsigned long long)xmac_stats->port_stats[k].rx_rts_discard;
  
#line 470 
  tmp_162 = ptr;
  
#line 470 
  ptr += 1;
  
#line 470 
  *tmp_162 = (unsigned long long)xmac_stats->port_stats[k].rx_trash_discard;
  
#line 471 
  tmp_163 = ptr;
  
#line 471 
  ptr += 1;
  
#line 471 
  *tmp_163 = (unsigned long long)xmac_stats->port_stats[k].rx_buff_full_discard;
  
#line 472 
  tmp_164 = ptr;
  
#line 472 
  ptr += 1;
  
#line 472 
  *tmp_164 = (unsigned long long)xmac_stats->port_stats[k].rx_red_discard;
  
#line 473 
  tmp_165 = ptr;
  
#line 473 
  ptr += 1;
  
#line 473 
  *tmp_165 = (unsigned long long)xmac_stats->port_stats[k].rx_xgmii_ctrl_err_cnt;
  
#line 474 
  tmp_166 = ptr;
  
#line 474 
  ptr += 1;
  
#line 474 
  *tmp_166 = (unsigned long long)xmac_stats->port_stats[k].rx_xgmii_data_err_cnt;
  
#line 475 
  tmp_167 = ptr;
  
#line 475 
  ptr += 1;
  
#line 475 
  *tmp_167 = (unsigned long long)xmac_stats->port_stats[k].rx_xgmii_char1_match;
  
#line 476 
  tmp_168 = ptr;
  
#line 476 
  ptr += 1;
  
#line 476 
  *tmp_168 = (unsigned long long)xmac_stats->port_stats[k].rx_xgmii_err_sym;
  
#line 477 
  tmp_169 = ptr;
  
#line 477 
  ptr += 1;
  
#line 477 
  *tmp_169 = (unsigned long long)xmac_stats->port_stats[k].rx_xgmii_column1_match;
  
#line 478 
  tmp_170 = ptr;
  
#line 478 
  ptr += 1;
  
#line 478 
  *tmp_170 = (unsigned long long)xmac_stats->port_stats[k].rx_xgmii_char2_match;
  
#line 479 
  tmp_171 = ptr;
  
#line 479 
  ptr += 1;
  
#line 479 
  *tmp_171 = (unsigned long long)xmac_stats->port_stats[k].rx_local_fault;
  
#line 480 
  tmp_172 = ptr;
  
#line 480 
  ptr += 1;
  
#line 480 
  *tmp_172 = (unsigned long long)xmac_stats->port_stats[k].rx_xgmii_column2_match;
  
#line 481 
  tmp_173 = ptr;
  
#line 481 
  ptr += 1;
  
#line 481 
  *tmp_173 = (unsigned long long)xmac_stats->port_stats[k].rx_jettison;
  
#line 482 
  tmp_174 = ptr;
  
#line 482 
  ptr += 1;
  
#line 482 
  *tmp_174 = (unsigned long long)xmac_stats->port_stats[k].rx_remote_fault;
  
#line 388 
  k += 1;
  ldv_48148: 
#line 389 
  ;
  
#line 388 
  if (vdev->max_config_port > k) 
#line 390 
                                 goto ldv_48147; else 
#line 393 
                                                      goto ldv_48149;
  ldv_48149: 
#line 394 
  ;
  
#line 485 
  tmp_175 = ptr;
  
#line 485 
  ptr += 1;
  
#line 485 
  *tmp_175 = 0ULL;
  
#line 486 
  k = 0;
  
#line 486 
  goto ldv_48158;
  ldv_48157: 
#line 487 
  ;
  {
    struct vxge_hw_vpath_stats_sw_info *vpath_info_0;
    u64 *tmp_176;
    u64 *tmp_177;
    u64 *tmp_178;
    u64 *tmp_179;
    u64 *tmp_180;
    u64 *tmp_181;
    u64 *tmp_182;
    u64 *tmp_183;
    u64 *tmp_184;
    u64 *tmp_185;
    u64 *tmp_186;
    u64 *tmp_187;
    u64 *tmp_188;
    u64 *tmp_189;
    u64 *tmp_190;
    u64 *tmp_191;
    u64 *tmp_192;
    u64 *tmp_193;
    u64 *tmp_194;
    u64 *tmp_195;
    u64 *tmp_196;
    u64 *tmp_197;
    u64 *tmp_198;
    u64 *tmp_199;
    u64 *tmp_200;
    u64 *tmp_201;
    u64 *tmp_202;
    u64 *tmp_203;
    u64 *tmp_204;
    u64 *tmp_205;
    
#line 489 
    vpath = vdev->vpaths + k;
    
#line 490 
    j = vpath->device_id;
    
#line 491 
    vpath_info_0 = & sw_stats->vpath_info[j];
    
#line 493 
    tmp_176 = ptr;
    
#line 493 
    ptr += 1;
    
#line 493 
    *tmp_176 = (unsigned long long)vpath_info_0->soft_reset_cnt;
    
#line 494 
    tmp_177 = ptr;
    
#line 494 
    ptr += 1;
    
#line 494 
    *tmp_177 = (unsigned long long)vpath_info_0->error_stats.unknown_alarms;
    
#line 495 
    tmp_178 = ptr;
    
#line 495 
    ptr += 1;
    
#line 495 
    *tmp_178 = (unsigned long long)vpath_info_0->error_stats.network_sustained_fault;
    
#line 496 
    tmp_179 = ptr;
    
#line 496 
    ptr += 1;
    
#line 496 
    *tmp_179 = (unsigned long long)vpath_info_0->error_stats.network_sustained_ok;
    
#line 497 
    tmp_180 = ptr;
    
#line 497 
    ptr += 1;
    
#line 497 
    *tmp_180 = (unsigned long long)vpath_info_0->error_stats.kdfcctl_fifo0_overwrite;
    
#line 498 
    tmp_181 = ptr;
    
#line 498 
    ptr += 1;
    
#line 498 
    *tmp_181 = (unsigned long long)vpath_info_0->error_stats.kdfcctl_fifo0_poison;
    
#line 499 
    tmp_182 = ptr;
    
#line 499 
    ptr += 1;
    
#line 499 
    *tmp_182 = (unsigned long long)vpath_info_0->error_stats.kdfcctl_fifo0_dma_error;
    
#line 500 
    tmp_183 = ptr;
    
#line 500 
    ptr += 1;
    
#line 500 
    *tmp_183 = (unsigned long long)vpath_info_0->error_stats.dblgen_fifo0_overflow;
    
#line 501 
    tmp_184 = ptr;
    
#line 501 
    ptr += 1;
    
#line 501 
    *tmp_184 = (unsigned long long)vpath_info_0->error_stats.statsb_pif_chain_error;
    
#line 502 
    tmp_185 = ptr;
    
#line 502 
    ptr += 1;
    
#line 502 
    *tmp_185 = (unsigned long long)vpath_info_0->error_stats.statsb_drop_timeout;
    
#line 503 
    tmp_186 = ptr;
    
#line 503 
    ptr += 1;
    
#line 503 
    *tmp_186 = (unsigned long long)vpath_info_0->error_stats.target_illegal_access;
    
#line 504 
    tmp_187 = ptr;
    
#line 504 
    ptr += 1;
    
#line 504 
    *tmp_187 = (unsigned long long)vpath_info_0->error_stats.ini_serr_det;
    
#line 505 
    tmp_188 = ptr;
    
#line 505 
    ptr += 1;
    
#line 505 
    *tmp_188 = (unsigned long long)vpath_info_0->error_stats.prc_ring_bumps;
    
#line 506 
    tmp_189 = ptr;
    
#line 506 
    ptr += 1;
    
#line 506 
    *tmp_189 = (unsigned long long)vpath_info_0->error_stats.prc_rxdcm_sc_err;
    
#line 507 
    tmp_190 = ptr;
    
#line 507 
    ptr += 1;
    
#line 507 
    *tmp_190 = (unsigned long long)vpath_info_0->error_stats.prc_rxdcm_sc_abort;
    
#line 508 
    tmp_191 = ptr;
    
#line 508 
    ptr += 1;
    
#line 508 
    *tmp_191 = (unsigned long long)vpath_info_0->error_stats.prc_quanta_size_err;
    
#line 509 
    tmp_192 = ptr;
    
#line 509 
    ptr += 1;
    
#line 509 
    *tmp_192 = (unsigned long long)vpath_info_0->ring_stats.common_stats.full_cnt;
    
#line 510 
    tmp_193 = ptr;
    
#line 510 
    ptr += 1;
    
#line 510 
    *tmp_193 = (unsigned long long)vpath_info_0->ring_stats.common_stats.usage_cnt;
    
#line 511 
    tmp_194 = ptr;
    
#line 511 
    ptr += 1;
    
#line 511 
    *tmp_194 = (unsigned long long)vpath_info_0->ring_stats.common_stats.usage_max;
    
#line 512 
    tmp_195 = ptr;
    
#line 512 
    ptr += 1;
    
#line 512 
    *tmp_195 = (unsigned long long)vpath_info_0->ring_stats.common_stats.reserve_free_swaps_cnt;
    
#line 514 
    tmp_196 = ptr;
    
#line 514 
    ptr += 1;
    
#line 514 
    *tmp_196 = (unsigned long long)vpath_info_0->ring_stats.common_stats.total_compl_cnt;
    
#line 515 
    j = 0;
    
#line 515 
    goto ldv_48152;
    ldv_48151: 
#line 516 
    ;
    
#line 516 
    tmp_197 = ptr;
    
#line 516 
    ptr += 1;
    
#line 516 
    *tmp_197 = (unsigned long long)vpath_info_0->ring_stats.rxd_t_code_err_cnt[j];
    
#line 515 
    j += 1;
    ldv_48152: 
#line 516 
    ;
    
#line 515 
    if (j <= 15) 
#line 517 
                 goto ldv_48151; else 
#line 520 
                                      goto ldv_48153;
    ldv_48153: 
#line 521 
    ;
    
#line 517 
    tmp_198 = ptr;
    
#line 517 
    ptr += 1;
    
#line 517 
    *tmp_198 = (unsigned long long)vpath_info_0->fifo_stats.common_stats.full_cnt;
    
#line 518 
    tmp_199 = ptr;
    
#line 518 
    ptr += 1;
    
#line 518 
    *tmp_199 = (unsigned long long)vpath_info_0->fifo_stats.common_stats.usage_cnt;
    
#line 519 
    tmp_200 = ptr;
    
#line 519 
    ptr += 1;
    
#line 519 
    *tmp_200 = (unsigned long long)vpath_info_0->fifo_stats.common_stats.usage_max;
    
#line 520 
    tmp_201 = ptr;
    
#line 520 
    ptr += 1;
    
#line 520 
    *tmp_201 = (unsigned long long)vpath_info_0->fifo_stats.common_stats.reserve_free_swaps_cnt;
    
#line 522 
    tmp_202 = ptr;
    
#line 522 
    ptr += 1;
    
#line 522 
    *tmp_202 = (unsigned long long)vpath_info_0->fifo_stats.common_stats.total_compl_cnt;
    
#line 523 
    tmp_203 = ptr;
    
#line 523 
    ptr += 1;
    
#line 523 
    *tmp_203 = (unsigned long long)vpath_info_0->fifo_stats.total_posts;
    
#line 524 
    tmp_204 = ptr;
    
#line 524 
    ptr += 1;
    
#line 524 
    *tmp_204 = (unsigned long long)vpath_info_0->fifo_stats.total_buffers;
    
#line 525 
    j = 0;
    
#line 525 
    goto ldv_48155;
    ldv_48154: 
#line 526 
    ;
    
#line 526 
    tmp_205 = ptr;
    
#line 526 
    ptr += 1;
    
#line 526 
    *tmp_205 = (unsigned long long)vpath_info_0->fifo_stats.txd_t_code_err_cnt[j];
    
#line 525 
    j += 1;
    ldv_48155: 
#line 526 
    ;
    
#line 525 
    if (j <= 15) 
#line 527 
                 goto ldv_48154; else 
#line 530 
                                      goto ldv_48156;
    ldv_48156: 
#line 531 
    ;
  }
  
#line 486 
  k += 1;
  ldv_48158: 
#line 487 
  ;
  
#line 486 
  if (vdev->no_of_vpath > k) 
#line 488 
                             goto ldv_48157; else 
#line 491 
                                                  goto ldv_48159;
  ldv_48159: 
#line 492 
  ;
  
#line 529 
  tmp_206 = ptr;
  
#line 529 
  ptr += 1;
  
#line 529 
  *tmp_206 = 0ULL;
  
#line 530 
  k = 0;
  
#line 530 
  goto ldv_48163;
  ldv_48162: 
#line 531 
  ;
  {
    struct vxge_hw_vpath_stats_hw_info *vpath_info_1;
    u64 *tmp_207;
    u64 *tmp_208;
    u64 *tmp_209;
    u64 *tmp_210;
    u64 *tmp_211;
    u64 *tmp_212;
    u64 *tmp_213;
    u64 *tmp_214;
    u64 *tmp_215;
    u64 *tmp_216;
    u64 *tmp_217;
    u64 *tmp_218;
    u64 *tmp_219;
    u64 *tmp_220;
    u64 *tmp_221;
    u64 *tmp_222;
    u64 *tmp_223;
    u64 *tmp_224;
    u64 *tmp_225;
    u64 *tmp_226;
    u64 *tmp_227;
    u64 *tmp_228;
    u64 *tmp_229;
    u64 *tmp_230;
    u64 *tmp_231;
    u64 *tmp_232;
    u64 *tmp_233;
    
#line 532 
    vpath = vdev->vpaths + k;
    
#line 533 
    j = vpath->device_id;
    
#line 534 
    vpath_info_1 = hw_stats->vpath_info[j];
    
#line 535 
    if (vpath_info_1 == (struct vxge_hw_vpath_stats_hw_info *)0) {
      
#line 536 
      memset((void *)ptr,0,216UL);
      
#line 537 
      ptr += 27U;
      
#line 538 
      goto ldv_48161;
    }
    else ;
    
#line 540 
    tmp_207 = ptr;
    
#line 540 
    ptr += 1;
    
#line 540 
    *tmp_207 = (unsigned long long)vpath_info_1->ini_num_mwr_sent;
    
#line 541 
    tmp_208 = ptr;
    
#line 541 
    ptr += 1;
    
#line 541 
    *tmp_208 = (unsigned long long)vpath_info_1->ini_num_mrd_sent;
    
#line 542 
    tmp_209 = ptr;
    
#line 542 
    ptr += 1;
    
#line 542 
    *tmp_209 = (unsigned long long)vpath_info_1->ini_num_cpl_rcvd;
    
#line 543 
    tmp_210 = ptr;
    
#line 543 
    ptr += 1;
    
#line 543 
    *tmp_210 = vpath_info_1->ini_num_mwr_byte_sent;
    
#line 544 
    tmp_211 = ptr;
    
#line 544 
    ptr += 1;
    
#line 544 
    *tmp_211 = vpath_info_1->ini_num_cpl_byte_rcvd;
    
#line 545 
    tmp_212 = ptr;
    
#line 545 
    ptr += 1;
    
#line 545 
    *tmp_212 = (unsigned long long)vpath_info_1->wrcrdtarb_xoff;
    
#line 546 
    tmp_213 = ptr;
    
#line 546 
    ptr += 1;
    
#line 546 
    *tmp_213 = (unsigned long long)vpath_info_1->rdcrdtarb_xoff;
    
#line 547 
    tmp_214 = ptr;
    
#line 547 
    ptr += 1;
    
#line 547 
    *tmp_214 = (unsigned long long)vpath_info_1->vpath_genstats_count0;
    
#line 548 
    tmp_215 = ptr;
    
#line 548 
    ptr += 1;
    
#line 548 
    *tmp_215 = (unsigned long long)vpath_info_1->vpath_genstats_count1;
    
#line 549 
    tmp_216 = ptr;
    
#line 549 
    ptr += 1;
    
#line 549 
    *tmp_216 = (unsigned long long)vpath_info_1->vpath_genstats_count2;
    
#line 550 
    tmp_217 = ptr;
    
#line 550 
    ptr += 1;
    
#line 550 
    *tmp_217 = (unsigned long long)vpath_info_1->vpath_genstats_count3;
    
#line 551 
    tmp_218 = ptr;
    
#line 551 
    ptr += 1;
    
#line 551 
    *tmp_218 = (unsigned long long)vpath_info_1->vpath_genstats_count4;
    
#line 552 
    tmp_219 = ptr;
    
#line 552 
    ptr += 1;
    
#line 552 
    *tmp_219 = (unsigned long long)vpath_info_1->vpath_genstats_count5;
    
#line 553 
    tmp_220 = ptr;
    
#line 553 
    ptr += 1;
    
#line 553 
    *tmp_220 = (unsigned long long)vpath_info_1->prog_event_vnum0;
    
#line 554 
    tmp_221 = ptr;
    
#line 554 
    ptr += 1;
    
#line 554 
    *tmp_221 = (unsigned long long)vpath_info_1->prog_event_vnum1;
    
#line 555 
    tmp_222 = ptr;
    
#line 555 
    ptr += 1;
    
#line 555 
    *tmp_222 = (unsigned long long)vpath_info_1->prog_event_vnum2;
    
#line 556 
    tmp_223 = ptr;
    
#line 556 
    ptr += 1;
    
#line 556 
    *tmp_223 = (unsigned long long)vpath_info_1->prog_event_vnum3;
    
#line 557 
    tmp_224 = ptr;
    
#line 557 
    ptr += 1;
    
#line 557 
    *tmp_224 = (unsigned long long)vpath_info_1->rx_multi_cast_frame_discard;
    
#line 558 
    tmp_225 = ptr;
    
#line 558 
    ptr += 1;
    
#line 558 
    *tmp_225 = (unsigned long long)vpath_info_1->rx_frm_transferred;
    
#line 559 
    tmp_226 = ptr;
    
#line 559 
    ptr += 1;
    
#line 559 
    *tmp_226 = (unsigned long long)vpath_info_1->rxd_returned;
    
#line 560 
    tmp_227 = ptr;
    
#line 560 
    ptr += 1;
    
#line 560 
    *tmp_227 = (unsigned long long)vpath_info_1->rx_mpa_len_fail_frms;
    
#line 561 
    tmp_228 = ptr;
    
#line 561 
    ptr += 1;
    
#line 561 
    *tmp_228 = (unsigned long long)vpath_info_1->rx_mpa_mrk_fail_frms;
    
#line 562 
    tmp_229 = ptr;
    
#line 562 
    ptr += 1;
    
#line 562 
    *tmp_229 = (unsigned long long)vpath_info_1->rx_mpa_crc_fail_frms;
    
#line 563 
    tmp_230 = ptr;
    
#line 563 
    ptr += 1;
    
#line 563 
    *tmp_230 = (unsigned long long)vpath_info_1->rx_permitted_frms;
    
#line 564 
    tmp_231 = ptr;
    
#line 564 
    ptr += 1;
    
#line 564 
    *tmp_231 = vpath_info_1->rx_vp_reset_discarded_frms;
    
#line 565 
    tmp_232 = ptr;
    
#line 565 
    ptr += 1;
    
#line 565 
    *tmp_232 = vpath_info_1->rx_wol_frms;
    
#line 566 
    tmp_233 = ptr;
    
#line 566 
    ptr += 1;
    
#line 566 
    *tmp_233 = vpath_info_1->tx_vp_reset_discarded_frms;
  }
  ldv_48161: 
#line 568 
  ;
  
#line 530 
  k += 1;
  ldv_48163: 
#line 531 
  ;
  
#line 530 
  if (vdev->no_of_vpath > k) 
#line 532 
                             goto ldv_48162; else 
#line 535 
                                                  goto ldv_48164;
  ldv_48164: 
#line 536 
  ;
  
#line 569 
  tmp_234 = ptr;
  
#line 569 
  ptr += 1;
  
#line 569 
  *tmp_234 = 0ULL;
  
#line 570 
  tmp_235 = ptr;
  
#line 570 
  ptr += 1;
  
#line 570 
  *tmp_235 = (unsigned long long)vdev->stats.vpaths_open;
  
#line 571 
  tmp_236 = ptr;
  
#line 571 
  ptr += 1;
  
#line 571 
  *tmp_236 = (unsigned long long)vdev->stats.vpath_open_fail;
  
#line 572 
  tmp_237 = ptr;
  
#line 572 
  ptr += 1;
  
#line 572 
  *tmp_237 = (unsigned long long)vdev->stats.link_up;
  
#line 573 
  tmp_238 = ptr;
  
#line 573 
  ptr += 1;
  
#line 573 
  *tmp_238 = (unsigned long long)vdev->stats.link_down;
  
#line 575 
  k = 0;
  
#line 575 
  goto ldv_48166;
  ldv_48165: 
#line 576 
  ;
  
#line 576 
  *ptr += (vdev->vpaths + k)->fifo.stats.tx_frms;
  
#line 577 
  *(ptr + 1U) += (unsigned long long)(vdev->vpaths + k)->fifo.stats.tx_errors;
  
#line 578 
  *(ptr + 2U) += (vdev->vpaths + k)->fifo.stats.tx_bytes;
  
#line 579 
  *(ptr + 3U) += (unsigned long long)(vdev->vpaths + k)->fifo.stats.txd_not_free;
  
#line 580 
  *(ptr + 4U) += (unsigned long long)(vdev->vpaths + k)->fifo.stats.txd_out_of_desc;
  
#line 581 
  *(ptr + 5U) += (vdev->vpaths + k)->ring.stats.rx_frms;
  
#line 582 
  *(ptr + 6U) += (unsigned long long)(vdev->vpaths + k)->ring.stats.rx_errors;
  
#line 583 
  *(ptr + 7U) += (vdev->vpaths + k)->ring.stats.rx_bytes;
  
#line 584 
  *(ptr + 8U) += (vdev->vpaths + k)->ring.stats.rx_mcast;
  
#line 585 
  *(ptr + 9U) += (unsigned long long)((vdev->vpaths + k)->fifo.stats.pci_map_fail + (vdev->vpaths + k)->ring.stats.pci_map_fail);
  
#line 587 
  *(ptr + 10U) += (unsigned long long)(vdev->vpaths + k)->ring.stats.skb_alloc_fail;
  
#line 575 
  k += 1;
  ldv_48166: 
#line 576 
  ;
  
#line 575 
  if (vdev->no_of_vpath > k) 
#line 577 
                             goto ldv_48165; else 
#line 580 
                                                  goto ldv_48167;
  ldv_48167: 
#line 581 
  ;
  
#line 590 
  ptr += 12U;
  
#line 592 
  kfree((void const *)xmac_stats);
  
#line 593 
  kfree((void const *)sw_stats);
  
#line 594 
  kfree((void const *)hw_stats);
  return_label: 
#line 595 
                return;
}


#line 597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static void vxge_ethtool_get_strings(struct net_device *dev, u32 stringset, u8 *data)
{
  int i;
  int j;
  
#line 600 
  int stat_size = 0;
  
#line 602 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 603 
  switch (stringset) {
    case (u32)1: 
#line 604 
    ;
    
#line 605 
    snprintf((char *)(data + stat_size),32UL,"VPATH STATISTICS%s\t\t\t",(char *)"");
    
#line 605 
    stat_size += 32;
    
#line 607 
    i = 0;
    
#line 607 
    goto ldv_48179;
    ldv_48178: 
#line 608 
    ;
    
#line 608 
    snprintf((char *)(data + stat_size),32UL,"tx_ttl_eth_frms_%d\t\t\t",i);
    
#line 608 
    stat_size += 32;
    
#line 610 
    snprintf((char *)(data + stat_size),32UL,"tx_ttl_eth_octects_%d\t\t",i);
    
#line 610 
    stat_size += 32;
    
#line 612 
    snprintf((char *)(data + stat_size),32UL,"tx_data_octects_%d\t\t\t",i);
    
#line 612 
    stat_size += 32;
    
#line 614 
    snprintf((char *)(data + stat_size),32UL,"tx_mcast_frms_%d\t\t\t",i);
    
#line 614 
    stat_size += 32;
    
#line 616 
    snprintf((char *)(data + stat_size),32UL,"tx_bcast_frms_%d\t\t\t",i);
    
#line 616 
    stat_size += 32;
    
#line 618 
    snprintf((char *)(data + stat_size),32UL,"tx_ucast_frms_%d\t\t\t",i);
    
#line 618 
    stat_size += 32;
    
#line 620 
    snprintf((char *)(data + stat_size),32UL,"tx_tagged_frms_%d\t\t\t",i);
    
#line 620 
    stat_size += 32;
    
#line 622 
    snprintf((char *)(data + stat_size),32UL,"tx_vld_ip_%d\t\t\t",i);
    
#line 622 
    stat_size += 32;
    
#line 624 
    snprintf((char *)(data + stat_size),32UL,"tx_vld_ip_octects_%d\t\t",i);
    
#line 624 
    stat_size += 32;
    
#line 626 
    snprintf((char *)(data + stat_size),32UL,"tx_icmp_%d\t\t\t\t",i);
    
#line 626 
    stat_size += 32;
    
#line 628 
    snprintf((char *)(data + stat_size),32UL,"tx_tcp_%d\t\t\t\t",i);
    
#line 628 
    stat_size += 32;
    
#line 630 
    snprintf((char *)(data + stat_size),32UL,"tx_rst_tcp_%d\t\t\t",i);
    
#line 630 
    stat_size += 32;
    
#line 632 
    snprintf((char *)(data + stat_size),32UL,"tx_udp_%d\t\t\t\t",i);
    
#line 632 
    stat_size += 32;
    
#line 634 
    snprintf((char *)(data + stat_size),32UL,"tx_unknown_proto_%d\t\t\t",i);
    
#line 634 
    stat_size += 32;
    
#line 636 
    snprintf((char *)(data + stat_size),32UL,"tx_lost_ip_%d\t\t\t",i);
    
#line 636 
    stat_size += 32;
    
#line 638 
    snprintf((char *)(data + stat_size),32UL,"tx_parse_error_%d\t\t\t",i);
    
#line 638 
    stat_size += 32;
    
#line 640 
    snprintf((char *)(data + stat_size),32UL,"tx_tcp_offload_%d\t\t\t",i);
    
#line 640 
    stat_size += 32;
    
#line 642 
    snprintf((char *)(data + stat_size),32UL,"tx_retx_tcp_offload_%d\t\t",i);
    
#line 642 
    stat_size += 32;
    
#line 644 
    snprintf((char *)(data + stat_size),32UL,"tx_lost_ip_offload_%d\t\t",i);
    
#line 644 
    stat_size += 32;
    
#line 646 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_eth_frms_%d\t\t\t",i);
    
#line 646 
    stat_size += 32;
    
#line 648 
    snprintf((char *)(data + stat_size),32UL,"rx_vld_frms_%d\t\t\t",i);
    
#line 648 
    stat_size += 32;
    
#line 650 
    snprintf((char *)(data + stat_size),32UL,"rx_offload_frms_%d\t\t\t",i);
    
#line 650 
    stat_size += 32;
    
#line 652 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_eth_octects_%d\t\t",i);
    
#line 652 
    stat_size += 32;
    
#line 654 
    snprintf((char *)(data + stat_size),32UL,"rx_data_octects_%d\t\t\t",i);
    
#line 654 
    stat_size += 32;
    
#line 656 
    snprintf((char *)(data + stat_size),32UL,"rx_offload_octects_%d\t\t",i);
    
#line 656 
    stat_size += 32;
    
#line 658 
    snprintf((char *)(data + stat_size),32UL,"rx_vld_mcast_frms_%d\t\t",i);
    
#line 658 
    stat_size += 32;
    
#line 660 
    snprintf((char *)(data + stat_size),32UL,"rx_vld_bcast_frms_%d\t\t",i);
    
#line 660 
    stat_size += 32;
    
#line 662 
    snprintf((char *)(data + stat_size),32UL,"rx_accepted_ucast_frms_%d\t\t",i);
    
#line 662 
    stat_size += 32;
    
#line 664 
    snprintf((char *)(data + stat_size),32UL,"rx_accepted_nucast_frms_%d\t\t",i);
    
#line 664 
    stat_size += 32;
    
#line 666 
    snprintf((char *)(data + stat_size),32UL,"rx_tagged_frms_%d\t\t\t",i);
    
#line 666 
    stat_size += 32;
    
#line 668 
    snprintf((char *)(data + stat_size),32UL,"rx_long_frms_%d\t\t\t",i);
    
#line 668 
    stat_size += 32;
    
#line 670 
    snprintf((char *)(data + stat_size),32UL,"rx_usized_frms_%d\t\t\t",i);
    
#line 670 
    stat_size += 32;
    
#line 672 
    snprintf((char *)(data + stat_size),32UL,"rx_osized_frms_%d\t\t\t",i);
    
#line 672 
    stat_size += 32;
    
#line 674 
    snprintf((char *)(data + stat_size),32UL,"rx_frag_frms_%d\t\t\t",i);
    
#line 674 
    stat_size += 32;
    
#line 676 
    snprintf((char *)(data + stat_size),32UL,"rx_jabber_frms_%d\t\t\t",i);
    
#line 676 
    stat_size += 32;
    
#line 678 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_64_frms_%d\t\t\t",i);
    
#line 678 
    stat_size += 32;
    
#line 680 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_65_127_frms_%d\t\t",i);
    
#line 680 
    stat_size += 32;
    
#line 682 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_128_255_frms_%d\t\t",i);
    
#line 682 
    stat_size += 32;
    
#line 684 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_256_511_frms_%d\t\t",i);
    
#line 684 
    stat_size += 32;
    
#line 686 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_512_1023_frms_%d\t\t",i);
    
#line 686 
    stat_size += 32;
    
#line 688 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_1024_1518_frms_%d\t\t",i);
    
#line 688 
    stat_size += 32;
    
#line 690 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_1519_4095_frms_%d\t\t",i);
    
#line 690 
    stat_size += 32;
    
#line 692 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_4096_8191_frms_%d\t\t",i);
    
#line 692 
    stat_size += 32;
    
#line 694 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_8192_max_frms_%d\t\t",i);
    
#line 694 
    stat_size += 32;
    
#line 696 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_gt_max_frms_%d\t\t",i);
    
#line 696 
    stat_size += 32;
    
#line 698 
    snprintf((char *)(data + stat_size),32UL,"rx_ip%d\t\t\t\t",i);
    
#line 698 
    stat_size += 32;
    
#line 700 
    snprintf((char *)(data + stat_size),32UL,"rx_accepted_ip_%d\t\t\t",i);
    
#line 700 
    stat_size += 32;
    
#line 702 
    snprintf((char *)(data + stat_size),32UL,"rx_ip_octects_%d\t\t\t",i);
    
#line 702 
    stat_size += 32;
    
#line 704 
    snprintf((char *)(data + stat_size),32UL,"rx_err_ip_%d\t\t\t",i);
    
#line 704 
    stat_size += 32;
    
#line 706 
    snprintf((char *)(data + stat_size),32UL,"rx_icmp_%d\t\t\t\t",i);
    
#line 706 
    stat_size += 32;
    
#line 708 
    snprintf((char *)(data + stat_size),32UL,"rx_tcp_%d\t\t\t\t",i);
    
#line 708 
    stat_size += 32;
    
#line 710 
    snprintf((char *)(data + stat_size),32UL,"rx_udp_%d\t\t\t\t",i);
    
#line 710 
    stat_size += 32;
    
#line 712 
    snprintf((char *)(data + stat_size),32UL,"rx_err_tcp_%d\t\t\t",i);
    
#line 712 
    stat_size += 32;
    
#line 714 
    snprintf((char *)(data + stat_size),32UL,"rx_lost_frms_%d\t\t\t",i);
    
#line 714 
    stat_size += 32;
    
#line 716 
    snprintf((char *)(data + stat_size),32UL,"rx_lost_ip_%d\t\t\t",i);
    
#line 716 
    stat_size += 32;
    
#line 718 
    snprintf((char *)(data + stat_size),32UL,"rx_lost_ip_offload_%d\t\t",i);
    
#line 718 
    stat_size += 32;
    
#line 720 
    snprintf((char *)(data + stat_size),32UL,"rx_various_discard_%d\t\t",i);
    
#line 720 
    stat_size += 32;
    
#line 722 
    snprintf((char *)(data + stat_size),32UL,"rx_sleep_discard_%d\t\t\t",i);
    
#line 722 
    stat_size += 32;
    
#line 724 
    snprintf((char *)(data + stat_size),32UL,"rx_red_discard_%d\t\t\t",i);
    
#line 724 
    stat_size += 32;
    
#line 726 
    snprintf((char *)(data + stat_size),32UL,"rx_queue_full_discard_%d\t\t",i);
    
#line 726 
    stat_size += 32;
    
#line 728 
    snprintf((char *)(data + stat_size),32UL,"rx_mpa_ok_frms_%d\t\t\t",i);
    
#line 728 
    stat_size += 32;
    
#line 607 
    i += 1;
    ldv_48179: 
#line 608 
    ;
    
#line 607 
    if (vdev->no_of_vpath > i) 
#line 609 
                               goto ldv_48178; else 
#line 612 
                                                    goto ldv_48180;
    ldv_48180: 
#line 613 
    ;
    
#line 732 
    snprintf((char *)(data + stat_size),32UL,"\nAGGR STATISTICS%s\t\t\t\t",(char *)"");
    
#line 732 
    stat_size += 32;
    
#line 734 
    i = 0;
    
#line 734 
    goto ldv_48182;
    ldv_48181: 
#line 735 
    ;
    
#line 735 
    snprintf((char *)(data + stat_size),32UL,"tx_frms_%d\t\t\t\t",i);
    
#line 735 
    stat_size += 32;
    
#line 737 
    snprintf((char *)(data + stat_size),32UL,"tx_data_octects_%d\t\t\t",i);
    
#line 737 
    stat_size += 32;
    
#line 739 
    snprintf((char *)(data + stat_size),32UL,"tx_mcast_frms_%d\t\t\t",i);
    
#line 739 
    stat_size += 32;
    
#line 741 
    snprintf((char *)(data + stat_size),32UL,"tx_bcast_frms_%d\t\t\t",i);
    
#line 741 
    stat_size += 32;
    
#line 743 
    snprintf((char *)(data + stat_size),32UL,"tx_discarded_frms_%d\t\t",i);
    
#line 743 
    stat_size += 32;
    
#line 745 
    snprintf((char *)(data + stat_size),32UL,"tx_errored_frms_%d\t\t\t",i);
    
#line 745 
    stat_size += 32;
    
#line 747 
    snprintf((char *)(data + stat_size),32UL,"rx_frms_%d\t\t\t\t",i);
    
#line 747 
    stat_size += 32;
    
#line 749 
    snprintf((char *)(data + stat_size),32UL,"rx_data_octects_%d\t\t\t",i);
    
#line 749 
    stat_size += 32;
    
#line 751 
    snprintf((char *)(data + stat_size),32UL,"rx_mcast_frms_%d\t\t\t",i);
    
#line 751 
    stat_size += 32;
    
#line 753 
    snprintf((char *)(data + stat_size),32UL,"rx_bcast_frms_%d\t\t\t",i);
    
#line 753 
    stat_size += 32;
    
#line 755 
    snprintf((char *)(data + stat_size),32UL,"rx_discarded_frms_%d\t\t",i);
    
#line 755 
    stat_size += 32;
    
#line 757 
    snprintf((char *)(data + stat_size),32UL,"rx_errored_frms_%d\t\t\t",i);
    
#line 757 
    stat_size += 32;
    
#line 759 
    snprintf((char *)(data + stat_size),32UL,"rx_unknown_slow_proto_frms_%d\t",i);
    
#line 759 
    stat_size += 32;
    
#line 734 
    i += 1;
    ldv_48182: 
#line 735 
    ;
    
#line 734 
    if (vdev->max_config_port > i) 
#line 736 
                                   goto ldv_48181; else 
#line 739 
                                                        goto ldv_48183;
    ldv_48183: 
#line 740 
    ;
    
#line 763 
    snprintf((char *)(data + stat_size),32UL,"\nPORT STATISTICS%s\t\t\t\t",(char *)"");
    
#line 763 
    stat_size += 32;
    
#line 765 
    i = 0;
    
#line 765 
    goto ldv_48185;
    ldv_48184: 
#line 766 
    ;
    
#line 766 
    snprintf((char *)(data + stat_size),32UL,"tx_ttl_frms_%d\t\t\t",i);
    
#line 766 
    stat_size += 32;
    
#line 768 
    snprintf((char *)(data + stat_size),32UL,"tx_ttl_octects_%d\t\t\t",i);
    
#line 768 
    stat_size += 32;
    
#line 770 
    snprintf((char *)(data + stat_size),32UL,"tx_data_octects_%d\t\t\t",i);
    
#line 770 
    stat_size += 32;
    
#line 772 
    snprintf((char *)(data + stat_size),32UL,"tx_mcast_frms_%d\t\t\t",i);
    
#line 772 
    stat_size += 32;
    
#line 774 
    snprintf((char *)(data + stat_size),32UL,"tx_bcast_frms_%d\t\t\t",i);
    
#line 774 
    stat_size += 32;
    
#line 776 
    snprintf((char *)(data + stat_size),32UL,"tx_ucast_frms_%d\t\t\t",i);
    
#line 776 
    stat_size += 32;
    
#line 778 
    snprintf((char *)(data + stat_size),32UL,"tx_tagged_frms_%d\t\t\t",i);
    
#line 778 
    stat_size += 32;
    
#line 780 
    snprintf((char *)(data + stat_size),32UL,"tx_vld_ip_%d\t\t\t",i);
    
#line 780 
    stat_size += 32;
    
#line 782 
    snprintf((char *)(data + stat_size),32UL,"tx_vld_ip_octects_%d\t\t",i);
    
#line 782 
    stat_size += 32;
    
#line 784 
    snprintf((char *)(data + stat_size),32UL,"tx_icmp_%d\t\t\t\t",i);
    
#line 784 
    stat_size += 32;
    
#line 786 
    snprintf((char *)(data + stat_size),32UL,"tx_tcp_%d\t\t\t\t",i);
    
#line 786 
    stat_size += 32;
    
#line 788 
    snprintf((char *)(data + stat_size),32UL,"tx_rst_tcp_%d\t\t\t",i);
    
#line 788 
    stat_size += 32;
    
#line 790 
    snprintf((char *)(data + stat_size),32UL,"tx_udp_%d\t\t\t\t",i);
    
#line 790 
    stat_size += 32;
    
#line 792 
    snprintf((char *)(data + stat_size),32UL,"tx_parse_error_%d\t\t\t",i);
    
#line 792 
    stat_size += 32;
    
#line 794 
    snprintf((char *)(data + stat_size),32UL,"tx_unknown_protocol_%d\t\t",i);
    
#line 794 
    stat_size += 32;
    
#line 796 
    snprintf((char *)(data + stat_size),32UL,"tx_pause_ctrl_frms_%d\t\t",i);
    
#line 796 
    stat_size += 32;
    
#line 798 
    snprintf((char *)(data + stat_size),32UL,"tx_marker_pdu_frms_%d\t\t",i);
    
#line 798 
    stat_size += 32;
    
#line 800 
    snprintf((char *)(data + stat_size),32UL,"tx_lacpdu_frms_%d\t\t\t",i);
    
#line 800 
    stat_size += 32;
    
#line 802 
    snprintf((char *)(data + stat_size),32UL,"tx_drop_ip_%d\t\t\t",i);
    
#line 802 
    stat_size += 32;
    
#line 804 
    snprintf((char *)(data + stat_size),32UL,"tx_marker_resp_pdu_frms_%d\t\t",i);
    
#line 804 
    stat_size += 32;
    
#line 806 
    snprintf((char *)(data + stat_size),32UL,"tx_xgmii_char2_match_%d\t\t",i);
    
#line 806 
    stat_size += 32;
    
#line 808 
    snprintf((char *)(data + stat_size),32UL,"tx_xgmii_char1_match_%d\t\t",i);
    
#line 808 
    stat_size += 32;
    
#line 810 
    snprintf((char *)(data + stat_size),32UL,"tx_xgmii_column2_match_%d\t\t",i);
    
#line 810 
    stat_size += 32;
    
#line 812 
    snprintf((char *)(data + stat_size),32UL,"tx_xgmii_column1_match_%d\t\t",i);
    
#line 812 
    stat_size += 32;
    
#line 814 
    snprintf((char *)(data + stat_size),32UL,"tx_any_err_frms_%d\t\t\t",i);
    
#line 814 
    stat_size += 32;
    
#line 816 
    snprintf((char *)(data + stat_size),32UL,"tx_drop_frms_%d\t\t\t",i);
    
#line 816 
    stat_size += 32;
    
#line 818 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_frms_%d\t\t\t",i);
    
#line 818 
    stat_size += 32;
    
#line 820 
    snprintf((char *)(data + stat_size),32UL,"rx_vld_frms_%d\t\t\t",i);
    
#line 820 
    stat_size += 32;
    
#line 822 
    snprintf((char *)(data + stat_size),32UL,"rx_offload_frms_%d\t\t\t",i);
    
#line 822 
    stat_size += 32;
    
#line 824 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_octects_%d\t\t\t",i);
    
#line 824 
    stat_size += 32;
    
#line 826 
    snprintf((char *)(data + stat_size),32UL,"rx_data_octects_%d\t\t\t",i);
    
#line 826 
    stat_size += 32;
    
#line 828 
    snprintf((char *)(data + stat_size),32UL,"rx_offload_octects_%d\t\t",i);
    
#line 828 
    stat_size += 32;
    
#line 830 
    snprintf((char *)(data + stat_size),32UL,"rx_vld_mcast_frms_%d\t\t",i);
    
#line 830 
    stat_size += 32;
    
#line 832 
    snprintf((char *)(data + stat_size),32UL,"rx_vld_bcast_frms_%d\t\t",i);
    
#line 832 
    stat_size += 32;
    
#line 834 
    snprintf((char *)(data + stat_size),32UL,"rx_accepted_ucast_frms_%d\t\t",i);
    
#line 834 
    stat_size += 32;
    
#line 836 
    snprintf((char *)(data + stat_size),32UL,"rx_accepted_nucast_frms_%d\t\t",i);
    
#line 836 
    stat_size += 32;
    
#line 838 
    snprintf((char *)(data + stat_size),32UL,"rx_tagged_frms_%d\t\t\t",i);
    
#line 838 
    stat_size += 32;
    
#line 840 
    snprintf((char *)(data + stat_size),32UL,"rx_long_frms_%d\t\t\t",i);
    
#line 840 
    stat_size += 32;
    
#line 842 
    snprintf((char *)(data + stat_size),32UL,"rx_usized_frms_%d\t\t\t",i);
    
#line 842 
    stat_size += 32;
    
#line 844 
    snprintf((char *)(data + stat_size),32UL,"rx_osized_frms_%d\t\t\t",i);
    
#line 844 
    stat_size += 32;
    
#line 846 
    snprintf((char *)(data + stat_size),32UL,"rx_frag_frms_%d\t\t\t",i);
    
#line 846 
    stat_size += 32;
    
#line 848 
    snprintf((char *)(data + stat_size),32UL,"rx_jabber_frms_%d\t\t\t",i);
    
#line 848 
    stat_size += 32;
    
#line 850 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_64_frms_%d\t\t\t",i);
    
#line 850 
    stat_size += 32;
    
#line 852 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_65_127_frms_%d\t\t",i);
    
#line 852 
    stat_size += 32;
    
#line 854 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_128_255_frms_%d\t\t",i);
    
#line 854 
    stat_size += 32;
    
#line 856 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_256_511_frms_%d\t\t",i);
    
#line 856 
    stat_size += 32;
    
#line 858 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_512_1023_frms_%d\t\t",i);
    
#line 858 
    stat_size += 32;
    
#line 860 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_1024_1518_frms_%d\t\t",i);
    
#line 860 
    stat_size += 32;
    
#line 862 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_1519_4095_frms_%d\t\t",i);
    
#line 862 
    stat_size += 32;
    
#line 864 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_4096_8191_frms_%d\t\t",i);
    
#line 864 
    stat_size += 32;
    
#line 866 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_8192_max_frms_%d\t\t",i);
    
#line 866 
    stat_size += 32;
    
#line 868 
    snprintf((char *)(data + stat_size),32UL,"rx_ttl_gt_max_frms_%d\t\t",i);
    
#line 868 
    stat_size += 32;
    
#line 870 
    snprintf((char *)(data + stat_size),32UL,"rx_ip_%d\t\t\t\t",i);
    
#line 870 
    stat_size += 32;
    
#line 872 
    snprintf((char *)(data + stat_size),32UL,"rx_accepted_ip_%d\t\t\t",i);
    
#line 872 
    stat_size += 32;
    
#line 874 
    snprintf((char *)(data + stat_size),32UL,"rx_ip_octets_%d\t\t\t",i);
    
#line 874 
    stat_size += 32;
    
#line 876 
    snprintf((char *)(data + stat_size),32UL,"rx_err_ip_%d\t\t\t",i);
    
#line 876 
    stat_size += 32;
    
#line 878 
    snprintf((char *)(data + stat_size),32UL,"rx_icmp_%d\t\t\t\t",i);
    
#line 878 
    stat_size += 32;
    
#line 880 
    snprintf((char *)(data + stat_size),32UL,"rx_tcp_%d\t\t\t\t",i);
    
#line 880 
    stat_size += 32;
    
#line 882 
    snprintf((char *)(data + stat_size),32UL,"rx_udp_%d\t\t\t\t",i);
    
#line 882 
    stat_size += 32;
    
#line 884 
    snprintf((char *)(data + stat_size),32UL,"rx_err_tcp_%d\t\t\t",i);
    
#line 884 
    stat_size += 32;
    
#line 886 
    snprintf((char *)(data + stat_size),32UL,"rx_pause_count_%d\t\t\t",i);
    
#line 886 
    stat_size += 32;
    
#line 888 
    snprintf((char *)(data + stat_size),32UL,"rx_pause_ctrl_frms_%d\t\t",i);
    
#line 888 
    stat_size += 32;
    
#line 890 
    snprintf((char *)(data + stat_size),32UL,"rx_unsup_ctrl_frms_%d\t\t",i);
    
#line 890 
    stat_size += 32;
    
#line 892 
    snprintf((char *)(data + stat_size),32UL,"rx_fcs_err_frms_%d\t\t\t",i);
    
#line 892 
    stat_size += 32;
    
#line 894 
    snprintf((char *)(data + stat_size),32UL,"rx_in_rng_len_err_frms_%d\t\t",i);
    
#line 894 
    stat_size += 32;
    
#line 896 
    snprintf((char *)(data + stat_size),32UL,"rx_out_rng_len_err_frms_%d\t\t",i);
    
#line 896 
    stat_size += 32;
    
#line 898 
    snprintf((char *)(data + stat_size),32UL,"rx_drop_frms_%d\t\t\t",i);
    
#line 898 
    stat_size += 32;
    
#line 900 
    snprintf((char *)(data + stat_size),32UL,"rx_discard_frms_%d\t\t\t",i);
    
#line 900 
    stat_size += 32;
    
#line 902 
    snprintf((char *)(data + stat_size),32UL,"rx_drop_ip_%d\t\t\t",i);
    
#line 902 
    stat_size += 32;
    
#line 904 
    snprintf((char *)(data + stat_size),32UL,"rx_drop_udp_%d\t\t\t",i);
    
#line 904 
    stat_size += 32;
    
#line 906 
    snprintf((char *)(data + stat_size),32UL,"rx_marker_pdu_frms_%d\t\t",i);
    
#line 906 
    stat_size += 32;
    
#line 908 
    snprintf((char *)(data + stat_size),32UL,"rx_lacpdu_frms_%d\t\t\t",i);
    
#line 908 
    stat_size += 32;
    
#line 910 
    snprintf((char *)(data + stat_size),32UL,"rx_unknown_pdu_frms_%d\t\t",i);
    
#line 910 
    stat_size += 32;
    
#line 912 
    snprintf((char *)(data + stat_size),32UL,"rx_marker_resp_pdu_frms_%d\t\t",i);
    
#line 912 
    stat_size += 32;
    
#line 914 
    snprintf((char *)(data + stat_size),32UL,"rx_fcs_discard_%d\t\t\t",i);
    
#line 914 
    stat_size += 32;
    
#line 916 
    snprintf((char *)(data + stat_size),32UL,"rx_illegal_pdu_frms_%d\t\t",i);
    
#line 916 
    stat_size += 32;
    
#line 918 
    snprintf((char *)(data + stat_size),32UL,"rx_switch_discard_%d\t\t",i);
    
#line 918 
    stat_size += 32;
    
#line 920 
    snprintf((char *)(data + stat_size),32UL,"rx_len_discard_%d\t\t\t",i);
    
#line 920 
    stat_size += 32;
    
#line 922 
    snprintf((char *)(data + stat_size),32UL,"rx_rpa_discard_%d\t\t\t",i);
    
#line 922 
    stat_size += 32;
    
#line 924 
    snprintf((char *)(data + stat_size),32UL,"rx_l2_mgmt_discard_%d\t\t",i);
    
#line 924 
    stat_size += 32;
    
#line 926 
    snprintf((char *)(data + stat_size),32UL,"rx_rts_discard_%d\t\t\t",i);
    
#line 926 
    stat_size += 32;
    
#line 928 
    snprintf((char *)(data + stat_size),32UL,"rx_trash_discard_%d\t\t\t",i);
    
#line 928 
    stat_size += 32;
    
#line 930 
    snprintf((char *)(data + stat_size),32UL,"rx_buff_full_discard_%d\t\t",i);
    
#line 930 
    stat_size += 32;
    
#line 932 
    snprintf((char *)(data + stat_size),32UL,"rx_red_discard_%d\t\t\t",i);
    
#line 932 
    stat_size += 32;
    
#line 934 
    snprintf((char *)(data + stat_size),32UL,"rx_xgmii_ctrl_err_cnt_%d\t\t",i);
    
#line 934 
    stat_size += 32;
    
#line 936 
    snprintf((char *)(data + stat_size),32UL,"rx_xgmii_data_err_cnt_%d\t\t",i);
    
#line 936 
    stat_size += 32;
    
#line 938 
    snprintf((char *)(data + stat_size),32UL,"rx_xgmii_char1_match_%d\t\t",i);
    
#line 938 
    stat_size += 32;
    
#line 940 
    snprintf((char *)(data + stat_size),32UL,"rx_xgmii_err_sym_%d\t\t\t",i);
    
#line 940 
    stat_size += 32;
    
#line 942 
    snprintf((char *)(data + stat_size),32UL,"rx_xgmii_column1_match_%d\t\t",i);
    
#line 942 
    stat_size += 32;
    
#line 944 
    snprintf((char *)(data + stat_size),32UL,"rx_xgmii_char2_match_%d\t\t",i);
    
#line 944 
    stat_size += 32;
    
#line 946 
    snprintf((char *)(data + stat_size),32UL,"rx_local_fault_%d\t\t\t",i);
    
#line 946 
    stat_size += 32;
    
#line 948 
    snprintf((char *)(data + stat_size),32UL,"rx_xgmii_column2_match_%d\t\t",i);
    
#line 948 
    stat_size += 32;
    
#line 950 
    snprintf((char *)(data + stat_size),32UL,"rx_jettison_%d\t\t\t",i);
    
#line 950 
    stat_size += 32;
    
#line 952 
    snprintf((char *)(data + stat_size),32UL,"rx_remote_fault_%d\t\t\t",i);
    
#line 952 
    stat_size += 32;
    
#line 765 
    i += 1;
    ldv_48185: 
#line 766 
    ;
    
#line 765 
    if (vdev->max_config_port > i) 
#line 767 
                                   goto ldv_48184; else 
#line 770 
                                                        goto ldv_48186;
    ldv_48186: 
#line 771 
    ;
    
#line 956 
    snprintf((char *)(data + stat_size),32UL,"\n SOFTWARE STATISTICS%s\t\t\t",(char *)"");
    
#line 956 
    stat_size += 32;
    
#line 958 
    i = 0;
    
#line 958 
    goto ldv_48194;
    ldv_48193: 
#line 959 
    ;
    
#line 959 
    snprintf((char *)(data + stat_size),32UL,"soft_reset_cnt_%d\t\t\t",i);
    
#line 959 
    stat_size += 32;
    
#line 961 
    snprintf((char *)(data + stat_size),32UL,"unknown_alarms_%d\t\t\t",i);
    
#line 961 
    stat_size += 32;
    
#line 963 
    snprintf((char *)(data + stat_size),32UL,"network_sustained_fault_%d\t\t",i);
    
#line 963 
    stat_size += 32;
    
#line 965 
    snprintf((char *)(data + stat_size),32UL,"network_sustained_ok_%d\t\t",i);
    
#line 965 
    stat_size += 32;
    
#line 967 
    snprintf((char *)(data + stat_size),32UL,"kdfcctl_fifo0_overwrite_%d\t\t",i);
    
#line 967 
    stat_size += 32;
    
#line 969 
    snprintf((char *)(data + stat_size),32UL,"kdfcctl_fifo0_poison_%d\t\t",i);
    
#line 969 
    stat_size += 32;
    
#line 971 
    snprintf((char *)(data + stat_size),32UL,"kdfcctl_fifo0_dma_error_%d\t\t",i);
    
#line 971 
    stat_size += 32;
    
#line 973 
    snprintf((char *)(data + stat_size),32UL,"dblgen_fifo0_overflow_%d\t\t",i);
    
#line 973 
    stat_size += 32;
    
#line 975 
    snprintf((char *)(data + stat_size),32UL,"statsb_pif_chain_error_%d\t\t",i);
    
#line 975 
    stat_size += 32;
    
#line 977 
    snprintf((char *)(data + stat_size),32UL,"statsb_drop_timeout_%d\t\t",i);
    
#line 977 
    stat_size += 32;
    
#line 979 
    snprintf((char *)(data + stat_size),32UL,"target_illegal_access_%d\t\t",i);
    
#line 979 
    stat_size += 32;
    
#line 981 
    snprintf((char *)(data + stat_size),32UL,"ini_serr_det_%d\t\t\t",i);
    
#line 981 
    stat_size += 32;
    
#line 983 
    snprintf((char *)(data + stat_size),32UL,"prc_ring_bumps_%d\t\t\t",i);
    
#line 983 
    stat_size += 32;
    
#line 985 
    snprintf((char *)(data + stat_size),32UL,"prc_rxdcm_sc_err_%d\t\t\t",i);
    
#line 985 
    stat_size += 32;
    
#line 987 
    snprintf((char *)(data + stat_size),32UL,"prc_rxdcm_sc_abort_%d\t\t",i);
    
#line 987 
    stat_size += 32;
    
#line 989 
    snprintf((char *)(data + stat_size),32UL,"prc_quanta_size_err_%d\t\t",i);
    
#line 989 
    stat_size += 32;
    
#line 991 
    snprintf((char *)(data + stat_size),32UL,"ring_full_cnt_%d\t\t\t",i);
    
#line 991 
    stat_size += 32;
    
#line 993 
    snprintf((char *)(data + stat_size),32UL,"ring_usage_cnt_%d\t\t\t",i);
    
#line 993 
    stat_size += 32;
    
#line 995 
    snprintf((char *)(data + stat_size),32UL,"ring_usage_max_%d\t\t\t",i);
    
#line 995 
    stat_size += 32;
    
#line 997 
    snprintf((char *)(data + stat_size),32UL,"ring_reserve_free_swaps_cnt_%d\t",i);
    
#line 997 
    stat_size += 32;
    
#line 999 
    snprintf((char *)(data + stat_size),32UL,"ring_total_compl_cnt_%d\t\t",i);
    
#line 999 
    stat_size += 32;
    
#line 1001 
    j = 0;
    
#line 1001 
    goto ldv_48188;
    ldv_48187: 
#line 1002 
    ;
    
#line 1002 
    snprintf((char *)(data + stat_size),32UL,"rxd_t_code_err_cnt%d_%d\t\t",j,i);
    
#line 1002 
    stat_size += 32;
    
#line 1001 
    j += 1;
    ldv_48188: 
#line 1002 
    ;
    
#line 1001 
    if (j <= 15) 
#line 1003 
                 goto ldv_48187; else 
#line 1006 
                                      goto ldv_48189;
    ldv_48189: 
#line 1007 
    ;
    
#line 1004 
    snprintf((char *)(data + stat_size),32UL,"fifo_full_cnt_%d\t\t\t",i);
    
#line 1004 
    stat_size += 32;
    
#line 1006 
    snprintf((char *)(data + stat_size),32UL,"fifo_usage_cnt_%d\t\t\t",i);
    
#line 1006 
    stat_size += 32;
    
#line 1008 
    snprintf((char *)(data + stat_size),32UL,"fifo_usage_max_%d\t\t\t",i);
    
#line 1008 
    stat_size += 32;
    
#line 1010 
    snprintf((char *)(data + stat_size),32UL,"fifo_reserve_free_swaps_cnt_%d\t",i);
    
#line 1010 
    stat_size += 32;
    
#line 1012 
    snprintf((char *)(data + stat_size),32UL,"fifo_total_compl_cnt_%d\t\t",i);
    
#line 1012 
    stat_size += 32;
    
#line 1014 
    snprintf((char *)(data + stat_size),32UL,"fifo_total_posts_%d\t\t\t",i);
    
#line 1014 
    stat_size += 32;
    
#line 1016 
    snprintf((char *)(data + stat_size),32UL,"fifo_total_buffers_%d\t\t",i);
    
#line 1016 
    stat_size += 32;
    
#line 1018 
    j = 0;
    
#line 1018 
    goto ldv_48191;
    ldv_48190: 
#line 1019 
    ;
    
#line 1019 
    snprintf((char *)(data + stat_size),32UL,"txd_t_code_err_cnt%d_%d\t\t",j,i);
    
#line 1019 
    stat_size += 32;
    
#line 1018 
    j += 1;
    ldv_48191: 
#line 1019 
    ;
    
#line 1018 
    if (j <= 15) 
#line 1020 
                 goto ldv_48190; else 
#line 1023 
                                      goto ldv_48192;
    ldv_48192: 
#line 1024 
    ;
    
#line 958 
    i += 1;
    ldv_48194: 
#line 959 
    ;
    
#line 958 
    if (vdev->no_of_vpath > i) 
#line 960 
                               goto ldv_48193; else 
#line 963 
                                                    goto ldv_48195;
    ldv_48195: 
#line 964 
    ;
    
#line 1023 
    snprintf((char *)(data + stat_size),32UL,"\n HARDWARE STATISTICS%s\t\t\t",(char *)"");
    
#line 1023 
    stat_size += 32;
    
#line 1025 
    i = 0;
    
#line 1025 
    goto ldv_48197;
    ldv_48196: 
#line 1026 
    ;
    
#line 1026 
    snprintf((char *)(data + stat_size),32UL,"ini_num_mwr_sent_%d\t\t\t",i);
    
#line 1026 
    stat_size += 32;
    
#line 1028 
    snprintf((char *)(data + stat_size),32UL,"ini_num_mrd_sent_%d\t\t\t",i);
    
#line 1028 
    stat_size += 32;
    
#line 1030 
    snprintf((char *)(data + stat_size),32UL,"ini_num_cpl_rcvd_%d\t\t\t",i);
    
#line 1030 
    stat_size += 32;
    
#line 1032 
    snprintf((char *)(data + stat_size),32UL,"ini_num_mwr_byte_sent_%d\t\t",i);
    
#line 1032 
    stat_size += 32;
    
#line 1034 
    snprintf((char *)(data + stat_size),32UL,"ini_num_cpl_byte_rcvd_%d\t\t",i);
    
#line 1034 
    stat_size += 32;
    
#line 1036 
    snprintf((char *)(data + stat_size),32UL,"wrcrdtarb_xoff_%d\t\t\t",i);
    
#line 1036 
    stat_size += 32;
    
#line 1038 
    snprintf((char *)(data + stat_size),32UL,"rdcrdtarb_xoff_%d\t\t\t",i);
    
#line 1038 
    stat_size += 32;
    
#line 1040 
    snprintf((char *)(data + stat_size),32UL,"vpath_genstats_count0_%d\t\t",i);
    
#line 1040 
    stat_size += 32;
    
#line 1042 
    snprintf((char *)(data + stat_size),32UL,"vpath_genstats_count1_%d\t\t",i);
    
#line 1042 
    stat_size += 32;
    
#line 1044 
    snprintf((char *)(data + stat_size),32UL,"vpath_genstats_count2_%d\t\t",i);
    
#line 1044 
    stat_size += 32;
    
#line 1046 
    snprintf((char *)(data + stat_size),32UL,"vpath_genstats_count3_%d\t\t",i);
    
#line 1046 
    stat_size += 32;
    
#line 1048 
    snprintf((char *)(data + stat_size),32UL,"vpath_genstats_count4_%d\t\t",i);
    
#line 1048 
    stat_size += 32;
    
#line 1050 
    snprintf((char *)(data + stat_size),32UL,"vpath_genstats_count5_%d\t\t",i);
    
#line 1050 
    stat_size += 32;
    
#line 1052 
    snprintf((char *)(data + stat_size),32UL,"prog_event_vnum0_%d\t\t\t",i);
    
#line 1052 
    stat_size += 32;
    
#line 1054 
    snprintf((char *)(data + stat_size),32UL,"prog_event_vnum1_%d\t\t\t",i);
    
#line 1054 
    stat_size += 32;
    
#line 1056 
    snprintf((char *)(data + stat_size),32UL,"prog_event_vnum2_%d\t\t\t",i);
    
#line 1056 
    stat_size += 32;
    
#line 1058 
    snprintf((char *)(data + stat_size),32UL,"prog_event_vnum3_%d\t\t\t",i);
    
#line 1058 
    stat_size += 32;
    
#line 1060 
    snprintf((char *)(data + stat_size),32UL,"rx_multi_cast_frame_discard_%d\t",i);
    
#line 1060 
    stat_size += 32;
    
#line 1062 
    snprintf((char *)(data + stat_size),32UL,"rx_frm_transferred_%d\t\t",i);
    
#line 1062 
    stat_size += 32;
    
#line 1064 
    snprintf((char *)(data + stat_size),32UL,"rxd_returned_%d\t\t\t",i);
    
#line 1064 
    stat_size += 32;
    
#line 1066 
    snprintf((char *)(data + stat_size),32UL,"rx_mpa_len_fail_frms_%d\t\t",i);
    
#line 1066 
    stat_size += 32;
    
#line 1068 
    snprintf((char *)(data + stat_size),32UL,"rx_mpa_mrk_fail_frms_%d\t\t",i);
    
#line 1068 
    stat_size += 32;
    
#line 1070 
    snprintf((char *)(data + stat_size),32UL,"rx_mpa_crc_fail_frms_%d\t\t",i);
    
#line 1070 
    stat_size += 32;
    
#line 1072 
    snprintf((char *)(data + stat_size),32UL,"rx_permitted_frms_%d\t\t",i);
    
#line 1072 
    stat_size += 32;
    
#line 1074 
    snprintf((char *)(data + stat_size),32UL,"rx_vp_reset_discarded_frms_%d\t",i);
    
#line 1074 
    stat_size += 32;
    
#line 1076 
    snprintf((char *)(data + stat_size),32UL,"rx_wol_frms_%d\t\t\t",i);
    
#line 1076 
    stat_size += 32;
    
#line 1078 
    snprintf((char *)(data + stat_size),32UL,"tx_vp_reset_discarded_frms_%d\t",i);
    
#line 1078 
    stat_size += 32;
    
#line 1025 
    i += 1;
    ldv_48197: 
#line 1026 
    ;
    
#line 1025 
    if (vdev->no_of_vpath > i) 
#line 1027 
                               goto ldv_48196; else 
#line 1030 
                                                    goto ldv_48198;
    ldv_48198: 
#line 1031 
    ;
    
#line 1082 
    memcpy((void *)(data + stat_size),(void const *)(& ethtool_driver_stats_keys),512UL);
  }
  
#line 1084 
  return;
}


#line 1087  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static int vxge_ethtool_get_regs_len(struct net_device *dev)
{
  int __retres;
  
#line 1089 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 1091 
  __retres = (int)((unsigned long)vdev->no_of_vpath * (unsigned long)9800U);
  
#line 1091 
  return __retres;
}


#line 1094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static int vxge_ethtool_get_sset_count(struct net_device *dev, int sset)
{
  int __retres;
  
#line 1096 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 1098 
  switch (sset) {
    case 1: 
#line 1099 
    ;
    
#line 1106 
    __retres = (int)((unsigned int)((((((vdev->no_of_vpath * 27 + 5) + vdev->max_config_port * 13) + vdev->max_config_port * 94) + vdev->no_of_vpath * 19) + vdev->no_of_vpath * 42) + vdev->no_of_vpath * 60) + 16U);
    
#line 1106 
    goto return_label;
    default: 
#line 1108 
    ;
    
#line 1109 
    __retres = -95;
    
#line 1109 
    goto return_label;
  }
  return_label: 
#line 1098 
                return __retres;
}


#line 1113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static int vxge_fw_flash(struct net_device *dev, struct ethtool_flash *parms)
{
  int __retres;
  bool tmp_0;
  int tmp_1;
  
#line 1115 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 1117 
  if (vdev->max_vpath_supported != 17) {
    
#line 1118 
    printk("\001");
    
#line 1120 
    __retres = -22;
    
#line 1120 
    goto return_label;
  }
  else ;
  
#line 1123 
  tmp_0 = netif_running((struct net_device const *)dev);
  
#line 1123 
  if ((int)tmp_0 != 0) {
    
#line 1124 
    printk("\001",(char *)(& dev->name));
    
#line 1126 
    __retres = -16;
    
#line 1126 
    goto return_label;
  }
  else ;
  
#line 1129 
  tmp_1 = vxge_fw_upgrade(vdev,(char *)(& parms->data),1);
  
#line 1129 
  __retres = tmp_1;
  return_label: 
#line 1129 
                return __retres;
}


#line 1132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
static struct ethtool_ops const vxge_ethtool_ops = {.get_settings = & vxge_ethtool_gset, .set_settings = & vxge_ethtool_sset, .get_drvinfo = & vxge_ethtool_gdrvinfo, .get_regs_len = & vxge_ethtool_get_regs_len, .get_regs = & vxge_ethtool_gregs, .get_wol = (void (*)(struct net_device *, struct ethtool_wolinfo *))0, .set_wol = (int (*)(struct net_device *, struct ethtool_wolinfo *))0, .get_msglevel = (u32 (*)(struct net_device *))0, .set_msglevel = (void (*)(struct net_device *, u32 ))0, .nway_reset = (int (*)(struct net_device *))0, .get_link = & ethtool_op_get_link, .get_eeprom_len = (int (*)(struct net_device *))0, .get_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .set_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_coalesce = (int (*)(struct net_device *, struct ethtool_coalesce *))0, .set_coalesce = (int (*)(struct net_device *, struct ethtool_coalesce *))0, .get_ringparam = (void (*)(struct net_device *, struct ethtool_ringparam *))0, .set_ringparam = (int (*)(struct net_device *, struct ethtool_ringparam *))0, .get_pauseparam = & vxge_ethtool_getpause_data, .set_pauseparam = & vxge_ethtool_setpause_data, .self_test = (void (*)(struct net_device *, struct ethtool_test *, u64 *))0, .get_strings = & vxge_ethtool_get_strings, .set_phys_id = & vxge_ethtool_idnic, .get_ethtool_stats = & vxge_get_ethtool_stats, .begin = (int (*)(struct net_device *))0, .complete = (void (*)(struct net_device *))0, .get_priv_flags = (u32 (*)(struct net_device *))0, .set_priv_flags = (int (*)(struct net_device *, u32 ))0, .get_sset_count = & vxge_ethtool_get_sset_count, .get_rxnfc = (int (*)(struct net_device *, struct ethtool_rxnfc *, u32 *))0, .set_rxnfc = (int (*)(struct net_device *, struct ethtool_rxnfc *))0, .flash_device = & vxge_fw_flash, .reset = (int (*)(struct net_device *, u32 *))0, .get_rxfh_key_size = (u32 (*)(struct net_device *))0, .get_rxfh_indir_size = (u32 (*)(struct net_device *))0, .get_rxfh = (int (*)(struct net_device *, u32 *, u8 *, u8 *))0, .set_rxfh = (int (*)(struct net_device *, u32 const *, u8 const *, u8 const ))0, .get_channels = (void (*)(struct net_device *, struct ethtool_channels *))0, .set_channels = (int (*)(struct net_device *, struct ethtool_channels *))0, .get_dump_flag = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_dump_data = (int (*)(struct net_device *, struct ethtool_dump *, void *))0, .set_dump = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_ts_info = (int (*)(struct net_device *, struct ethtool_ts_info *))0, .get_module_info = (int (*)(struct net_device *, struct ethtool_modinfo *))0, .get_module_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .set_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .get_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void *))0, .set_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void const *))0};

#line 1148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c"
void vxge_initialize_ethtool_ops(struct net_device *ndev)
{
  
#line 1150 
  ndev->ethtool_ops = & vxge_ethtool_ops;
  
#line 1151 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
unsigned int (*ldv_emg_alias_ethtool_op_get_link_9)(struct net_device *) = & ethtool_op_get_link;

#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
int ldv_emg_wrapper_vxge_ethtool_sset_3(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 75 
  tmp = vxge_ethtool_sset(arg0,arg1);
  
#line 75 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
void ldv_emg_wrapper_vxge_ethtool_gregs_20(struct net_device *arg0, struct ethtool_regs *arg1, void *arg2)
{
  
#line 80 
  vxge_ethtool_gregs(arg0,arg1,arg2);
  
#line 81 
  return;
}


#line 84  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
void ldv_emg_wrapper_vxge_ethtool_get_strings_22(struct net_device *arg0, unsigned int arg1, unsigned char *arg2)
{
  
#line 85 
  vxge_ethtool_get_strings(arg0,arg1,arg2);
  
#line 86 
  return;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
int ldv_emg_wrapper_vxge_ethtool_get_sset_count_16(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 90 
  tmp = vxge_ethtool_get_sset_count(arg0,arg1);
  
#line 90 
  return tmp;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
int ldv_emg_wrapper_vxge_ethtool_get_regs_len_23(struct net_device *arg0)
{
  int tmp;
  
#line 95 
  tmp = vxge_ethtool_get_regs_len(arg0);
  
#line 95 
  return tmp;
}


#line 99  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
void ldv_emg_wrapper_vxge_ethtool_gdrvinfo_11(struct net_device *arg0, struct ethtool_drvinfo *arg1)
{
  
#line 100 
  vxge_ethtool_gdrvinfo(arg0,arg1);
  
#line 101 
  return;
}


#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
int ldv_emg_wrapper_vxge_ethtool_setpause_data_24(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  int tmp;
  
#line 105 
  tmp = vxge_ethtool_setpause_data(arg0,arg1);
  
#line 105 
  return tmp;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
void ldv_emg_wrapper_vxge_ethtool_getpause_data_2(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  
#line 110 
  vxge_ethtool_getpause_data(arg0,arg1);
  
#line 111 
  return;
}


#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
void ldv_emg_wrapper_vxge_get_ethtool_stats_7(struct net_device *arg0, struct ethtool_stats *arg1, unsigned long long *arg2)
{
  
#line 115 
  vxge_get_ethtool_stats(arg0,arg1,arg2);
  
#line 116 
  return;
}


#line 119  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
int ldv_emg_wrapper_vxge_fw_flash_19(struct net_device *arg0, struct ethtool_flash *arg1)
{
  int tmp;
  
#line 120 
  tmp = vxge_fw_flash(arg0,arg1);
  
#line 120 
  return tmp;
}


#line 124  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
int ldv_emg_wrapper_vxge_ethtool_gset_15(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 125 
  tmp = vxge_ethtool_gset(arg0,arg1);
  
#line 125 
  return tmp;
}


#line 129  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
int ldv_emg_wrapper_vxge_ethtool_idnic_4(struct net_device *arg0, enum ethtool_phys_id_state arg1)
{
  int tmp;
  
#line 130 
  tmp = vxge_ethtool_idnic(arg0,arg1);
  
#line 130 
  return tmp;
}


#line 564  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-ethtool.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 567 
  tmp = ldv_kzalloc(size,flags);
  
#line 567 
  return tmp;
}

unsigned short __builtin_bswap16(unsigned short);

void __builtin_prefetch(void const * , ...);

void __builtin_unreachable(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/fvtp/.tmp_vxge-main.c"
void ldv_inline_asm(void);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bitops/find.h"
unsigned long find_next_bit(unsigned long const *, unsigned long, unsigned long);


#line 42 
unsigned long find_first_bit(unsigned long const *, unsigned long);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val)
{
  __u16 tmp;
  
#line 49 
  tmp = __builtin_bswap16((unsigned short)((int)val));
  
#line 49 
  return tmp;
}


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_fault(char const *, int);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 48 
void __list_add(struct list_head *, struct list_head *, struct list_head *);


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add(struct list_head *new, struct list_head *head)
{
  
#line 63 
  __list_add(new,head,head->next);
  
#line 64 
  return;
}


#line 113 
void list_del(struct list_head *);


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_empty(struct list_head const *head)
{
  int __retres;
  
#line 189 
  __retres = (struct list_head const *)head->next == head;
  
#line 189 
  return __retres;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-defs.h"
void __bad_size_call_parameter(void);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
char *strcpy(char *, char const *);


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
int _raw_spin_trylock(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static int spin_trylock(spinlock_t *lock)
{
  int tmp;
  
#line 382 
  tmp = _raw_spin_trylock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 382 
  return tmp;
}


#line 343 
static int ldv_spin_trylock_62(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_63(spinlock_t *lock);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
void ldv_spin_model_lock(char *);


#line 75 
void ldv_spin_model_unlock(char *);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns)
{
  
#line 285 
  ktime_t const ktime_zero = {.tv64 = 0LL};
  
#line 287 
  ktime_t __constr_expr_17 = {.tv64 = (long long)((unsigned long long)ktime_zero.tv64 + ns)};
  
#line 287 
  return __constr_expr_17;
}


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 173 
static int ldv_mod_timer_73(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 177 
static int ldv_mod_timer_80(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 181 
static int ldv_mod_timer_81(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_82(struct timer_list *ldv_func_arg1);


#line 236 
static int ldv_del_timer_sync_83(struct timer_list *ldv_func_arg1);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
void msleep(unsigned int);


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void __init_work(struct work_struct *, int);


#line 446 
static bool ldv_flush_work_88(struct work_struct *ldv_func_arg1);


#line 560 
static bool ldv_schedule_work_84(struct work_struct *work);


#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
void iounmap(void volatile *);


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page const *page)
{
  void *__retres;
  
#line 947 
  __retres = (void *)((unsigned long)((unsigned long long)(((long)page + 24189255811072L) / 64L) << 12) + 18446612132314218496UL);
  
#line 947 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_0(size_t size, gfp_t flags);


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 652 
unsigned long _copy_to_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 664 
void copy_to_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 677 
void __copy_to_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void const *from, unsigned long n)
{
  
#line 730 
  int sz = -1;
  
#line 732 
  __might_fault("./arch/x86/include/asm/uaccess.h",732);
  
#line 735 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 736 
                                                                    n = _copy_to_user(to,from,(unsigned int)n);
  else 
    
#line 737 
    if (0 != 0) 
#line 738 
                copy_to_user_overflow(); else 
#line 740 
                                              __copy_to_user_overflow();
  
#line 742 
  return n;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 44 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 59 
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);


#line 63 
void debug_dma_sync_single_for_device(struct device *, dma_addr_t, size_t, int);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t addr;
  void *tmp_0;
  int tmp_1;
  
#line 80 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 83 
  ;
  
#line 83 
  tmp_0 = lowmem_page_address((struct page const *)page);
  
#line 83 
  ;
  
#line 83 
  kmemcheck_mark_initialized(tmp_0 + offset,(unsigned int)size);
  
#line 84 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 84 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 86 
    ldv_inline_asm();
    
#line 84 
    ;
  }
  else ;
  
#line 85 
  addr = (*(ops->map_page))(dev,page,offset,size,dir,(struct dma_attrs *)0);
  
#line 86 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr,(_Bool)0);
  
#line 88 
  return addr;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 94 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 96 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 96 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 98 
    ldv_inline_asm();
    
#line 96 
    ;
  }
  else ;
  
#line 97 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 98 
    (*(ops->unmap_page))(dev,addr,size,dir,(struct dma_attrs *)0); else ;
  
#line 99 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)0);
  
#line 100 
  return;
}


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 106 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 108 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 108 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 110 
    ldv_inline_asm();
    
#line 108 
    ;
  }
  else ;
  
#line 109 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 110 
    (*(ops->sync_single_for_cpu))(dev,addr,size,dir); else ;
  
#line 111 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  
#line 112 
  return;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 118 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 120 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 120 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 122 
    ldv_inline_asm();
    
#line 120 
    ;
  }
  else ;
  
#line 121 
  if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 122 
    (*(ops->sync_single_for_device))(dev,addr,size,dir); else ;
  
#line 123 
  debug_dma_sync_single_for_device(dev,addr,size,(int)dir);
  
#line 124 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 60 
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const *frag)
{
  unsigned int __retres;
  
#line 232 
  __retres = frag->size;
  
#line 232 
  return __retres;
}


#line 775 
void consume_skb(struct sk_buff *);


#line 926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
{
  
#line 928 
  skb->l4_hash = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))(type == (unsigned int)PKT_HASH_TYPE_L4);
  
#line 929 
  skb->sw_hash = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 930 
  skb->hash = hash;
  
#line 931 
  return;
}


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 978 
  __retres = skb->head + skb->end;
  
#line 978 
  return __retres;
}


#line 1000  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
  struct skb_shared_hwtstamps *__retres;
  unsigned char *tmp;
  
#line 1002 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1002 
  __retres = & ((struct skb_shared_info *)tmp)->hwtstamps;
  
#line 1002 
  return __retres;
}


#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1574 
  __retres = skb->len - skb->data_len;
  
#line 1574 
  return __retres;
}


#line 1688 
unsigned char *skb_put(struct sk_buff *, unsigned int);


#line 1789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  
#line 1791 
  skb->data += len;
  
#line 1792 
  skb->tail += (unsigned int)len;
  
#line 1793 
  return;
}


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1899 
  __retres = skb->head + (int)skb->network_header;
  
#line 1899 
  return __retres;
}


#line 2140 
struct sk_buff *__netdev_alloc_skb(struct net_device *, unsigned int, gfp_t);


#line 2156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev, unsigned int length)
{
  struct sk_buff *tmp;
  
#line 2159 
  tmp = __netdev_alloc_skb(dev,length,32U);
  
#line 2159 
  return tmp;
}


#line 2272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const *frag)
{
  struct page *__retres;
  
#line 2274 
  __retres = frag->page.p;
  
#line 2274 
  return __retres;
}


#line 2390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev, skb_frag_t const *frag, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t tmp_0;
  struct page *tmp;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  tmp = skb_frag_page(frag);
  
#line 2395 
  ;
  
#line 2395 
  tmp_0 = dma_map_page(dev,tmp,(unsigned long)frag->page_offset + offset,size,dir);
  
#line 2395 
  return tmp_0;
}


#line 3295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff const *skb)
{
  u16 __retres;
  
#line 3297 
  __retres = skb->queue_mapping;
  
#line 3297 
  return __retres;
}


#line 3305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb, u16 rx_queue)
{
  
#line 3307 
  skb->queue_mapping = (unsigned short)((unsigned int)rx_queue + 1U);
  
#line 3308 
  return;
}


#line 3426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff const *skb)
{
  
#line 3428 
  return;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static void u64_stats_init(struct u64_stats_sync *syncp)
{
  
#line 73 
  return;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_irq(struct u64_stats_sync const *syncp)
{
  unsigned int __retres;
  
#line 131 
  __retres = 0U;
  
#line 131 
  return __retres;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_irq(struct u64_stats_sync const *syncp, unsigned int start)
{
  bool __retres;
  
#line 144 
  __retres = (_Bool)0;
  
#line 144 
  return __retres;
}


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
void synchronize_irq(unsigned int);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_76(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 145 
static int ldv_request_irq_77(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 149 
static int ldv_request_irq_78(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 153 
static int ldv_request_irq_79(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 165 
static void ldv_free_irq_74(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 169 
static void ldv_free_irq_75(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 192 
void disable_irq(unsigned int);


#line 194 
void enable_irq(unsigned int);


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __napi_schedule(struct napi_struct *);


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n)
{
  bool __retres;
  int tmp;
  
#line 396 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& n->state));
  
#line 396 
  __retres = (_Bool)(tmp != 0);
  
#line 396 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n)
{
  bool __retres;
  int tmp_2;
  int tmp_0;
  bool tmp;
  
#line 410 
  tmp = napi_disable_pending(n);
  
#line 410 
  if (tmp) 
#line 410 
           tmp_0 = 0; else 
#line 410 
                           tmp_0 = 1;
  
#line 410 
  if (tmp_0) {
    int tmp_1;
    
#line 410 
    tmp_1 = test_and_set_bit(0L,(unsigned long volatile *)(& n->state));
    
#line 410 
    if (tmp_1 == 0) 
#line 410 
                    tmp_2 = 1; else 
#line 410 
                                    tmp_2 = 0;
  }
  else 
#line 410 
       tmp_2 = 0;
  
#line 410 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 410 
  return __retres;
}


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n)
{
  bool tmp;
  
#line 423 
  tmp = napi_schedule_prep(n);
  
#line 423 
  if ((int)tmp != 0) 
#line 424 
                     __napi_schedule(n); else ;
  
#line 425 
  return;
}


#line 450 
void napi_complete_done(struct napi_struct *, int);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n)
{
  
#line 460 
  napi_complete_done(n,0);
  
#line 461 
  return;
}


#line 496 
void napi_disable(struct napi_struct *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  int tmp;
  
#line 507 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& n->state));
  
#line 507 
  if ((long)(tmp == 0) != 0L) {
    
#line 509 
    ldv_inline_asm();
    
#line 507 
    ;
  }
  else ;
  
#line 509 
  ldv_inline_asm();
  
#line 509 
  set_bit(0L,(unsigned long volatile *)(& n->state));
  
#line 510 
  return;
}


#line 1822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev, unsigned int index)
{
  struct netdev_queue *__retres;
  
#line 1825 
  __retres = dev->_tx + index;
  
#line 1825 
  return __retres;
}


#line 1911 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);


#line 1920 
void netif_napi_del(struct napi_struct *);


#line 2205 
static void ldv_free_netdev_87(struct net_device *ldv_func_arg1);


#line 2209 
static void ldv_free_netdev_90(struct net_device *ldv_func_arg1);


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  
#line 2517 
  set_bit(0L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2518 
  return;
}


#line 2531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2535 
  i = 0U;
  
#line 2535 
  goto ldv_42314;
  ldv_42313: 
#line 2536 
  ;
  {
    
#line 2536 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2537 
    netif_tx_start_queue(txq);
  }
  
#line 2535 
  i += 1U;
  ldv_42314: 
#line 2536 
  ;
  
#line 2535 
  if (dev->num_tx_queues > i) 
#line 2537 
                              goto ldv_42313; else 
#line 2540 
                                                   goto ldv_42315;
  ldv_42315: 
#line 2541 
  ;
  
#line 2542 
  return;
}


#line 2541 
void netif_tx_wake_queue(struct netdev_queue *);


#line 2555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2559 
  i = 0U;
  
#line 2559 
  goto ldv_42327;
  ldv_42326: 
#line 2560 
  ;
  {
    
#line 2560 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2561 
    netif_tx_wake_queue(txq);
  }
  
#line 2559 
  i += 1U;
  ldv_42327: 
#line 2560 
  ;
  
#line 2559 
  if (dev->num_tx_queues > i) 
#line 2561 
                              goto ldv_42326; else 
#line 2564 
                                                   goto ldv_42328;
  ldv_42328: 
#line 2565 
  ;
  
#line 2566 
  return;
}


#line 2582 
void netif_tx_stop_all_queues(struct net_device *);


#line 2584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  int tmp;
  
#line 2586 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev_queue->state));
  
#line 2586 
  __retres = (_Bool)(tmp != 0);
  
#line 2586 
  return __retres;
}


#line 2892 
int netif_get_num_default_rss_queues(void);


#line 2899 
void __dev_kfree_skb_irq(struct sk_buff *, enum skb_free_reason);


#line 2900 
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);


#line 2921  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_irq(struct sk_buff *skb)
{
  
#line 2923 
  __dev_kfree_skb_irq(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2924 
  return;
}


#line 2931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  
#line 2933 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2934 
  return;
}


#line 2948 
gro_result_t napi_gro_receive(struct napi_struct *, struct sk_buff *);


#line 3047 
void netif_carrier_on(struct net_device *);


#line 3049 
void netif_carrier_off(struct net_device *);


#line 3117 
void netif_device_detach(struct net_device *);


#line 3119 
void netif_device_attach(struct net_device *);


#line 3182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool __netif_tx_trylock(struct netdev_queue *txq)
{
  int tmp;
  
#line 3184 
  tmp = ldv_spin_trylock_62(& txq->_xmit_lock);
  
#line 3184 
  bool ok = (_Bool)(tmp != 0);
  
#line 3185 
  if ((long)((int)ok != 0) != 0L) {
    int tmp_4;
    {
      int pscr_ret__;
      {
        
#line 3186 
        void const *__vpp_verify = (void const *)0;
        
#line 3186 
        void const *tmp_2 = __vpp_verify;
      }
      
#line 3186 
      switch (4UL) {
        int tmp_0;
        int tmp_1;
        int tmp_2_0;
        int tmp_3;
        case (unsigned long)1: 
#line 3186 
        ;
        {
          int pfo_ret__;
          
#line 3186 
          switch (4UL) {
            case (unsigned long)1: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42769;
            case (unsigned long)2: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42769;
            case (unsigned long)4: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42769;
            case (unsigned long)8: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42769;
            default: 
#line 3186 
            ;
            
#line 3186 
            __bad_percpu_size();
          }
          ldv_42769: 
#line 3186 
          ;
          
#line 3186 
          tmp_0 = pfo_ret__;
        }
        
#line 3186 
        pscr_ret__ = tmp_0;
        
#line 3186 
        goto ldv_42775;
        case (unsigned long)2: 
#line 3186 
        ;
        {
          int pfo_ret___0;
          
#line 3186 
          switch (4UL) {
            case (unsigned long)1: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42779;
            case (unsigned long)2: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42779;
            case (unsigned long)4: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42779;
            case (unsigned long)8: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42779;
            default: 
#line 3186 
            ;
            
#line 3186 
            __bad_percpu_size();
          }
          ldv_42779: 
#line 3186 
          ;
          
#line 3186 
          tmp_1 = pfo_ret___0;
        }
        
#line 3186 
        pscr_ret__ = tmp_1;
        
#line 3186 
        goto ldv_42775;
        case (unsigned long)4: 
#line 3186 
        ;
        {
          int pfo_ret___1;
          
#line 3186 
          switch (4UL) {
            case (unsigned long)1: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42788;
            case (unsigned long)2: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42788;
            case (unsigned long)4: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42788;
            case (unsigned long)8: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42788;
            default: 
#line 3186 
            ;
            
#line 3186 
            __bad_percpu_size();
          }
          ldv_42788: 
#line 3186 
          ;
          
#line 3186 
          tmp_2_0 = pfo_ret___1;
        }
        
#line 3186 
        pscr_ret__ = tmp_2_0;
        
#line 3186 
        goto ldv_42775;
        case (unsigned long)8: 
#line 3186 
        ;
        {
          int pfo_ret___2;
          
#line 3186 
          switch (4UL) {
            case (unsigned long)1: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42797;
            case (unsigned long)2: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42797;
            case (unsigned long)4: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42797;
            case (unsigned long)8: 
#line 3186 
            ;
            
#line 3187 
            ldv_inline_asm();
            
#line 3186 
            goto ldv_42797;
            default: 
#line 3186 
            ;
            
#line 3186 
            __bad_percpu_size();
          }
          ldv_42797: 
#line 3186 
          ;
          
#line 3186 
          tmp_3 = pfo_ret___2;
        }
        
#line 3186 
        pscr_ret__ = tmp_3;
        
#line 3186 
        goto ldv_42775;
        default: 
#line 3186 
        ;
        
#line 3186 
        __bad_size_call_parameter();
        
#line 3186 
        goto ldv_42775;
      }
      ldv_42775: 
#line 3186 
      ;
      
#line 3186 
      tmp_4 = pscr_ret__;
    }
    
#line 3186 
    txq->xmit_lock_owner = tmp_4;
  }
  else ;
  
#line 3187 
  return ok;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_63(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3355 
static int ldv_register_netdev_86(struct net_device *ldv_func_arg1);


#line 3360 
static void ldv_unregister_netdev_89(struct net_device *ldv_func_arg1);


#line 3828 
void netdev_err(struct net_device const *, char const * , ...);


#line 3832 
void netdev_notice(struct net_device const *, char const * , ...);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__be16 eth_type_trans(struct sk_buff *, struct net_device *);


#line 47 
int eth_validate_addr(struct net_device *);


#line 53 
static struct net_device *ldv_alloc_etherdev_mqs_85(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 96 
  __retres = (_Bool)((*((u32 const *)addr) | (unsigned int)*((u16 const *)(addr + 4U))) == 0U);
  
#line 96 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_3;
  int tmp_0;
  bool tmp;
  
#line 190 
  tmp = is_multicast_ether_addr(addr);
  
#line 190 
  if (tmp) 
#line 190 
           tmp_0 = 0; else 
#line 190 
                           tmp_0 = 1;
  
#line 190 
  if (tmp_0) {
    int tmp_2;
    bool tmp_1;
    
#line 190 
    tmp_1 = is_zero_ether_addr(addr);
    
#line 190 
    if (tmp_1) 
#line 190 
               tmp_2 = 0; else 
#line 190 
                               tmp_2 = 1;
    
#line 190 
    if (tmp_2) 
#line 190 
               tmp_3 = 1; else 
#line 190 
                               tmp_3 = 0;
  }
  else 
#line 190 
       tmp_3 = 0;
  
#line 190 
  __retres = (_Bool)(tmp_3 != 0);
  
#line 190 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const *addr1, u8 const *addr2)
{
  bool __retres;
  
#line 313 
  u32 fold = (*((u32 const *)addr1) ^ *((u32 const *)addr2)) | (unsigned int)((int)*((u16 const *)(addr1 + 4U)) ^ (int)*((u16 const *)(addr2 + 4U)));
  
#line 316 
  __retres = (_Bool)(fold == 0U);
  
#line 316 
  return __retres;
}


#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)
{
  
#line 412 
  skb->vlan_proto = vlan_proto;
  
#line 413 
  skb->vlan_tci = (unsigned short)((unsigned int)vlan_tci | 4096U);
  
#line 414 
  return;
}


#line 401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev)
{
  int __retres;
  
#line 403 
  __retres = pdev->error_state != 1U;
  
#line 403 
  return __retres;
}


#line 837 
int pci_find_ext_capability(struct pci_dev *, int);


#line 861 
int pci_bus_read_config_word(struct pci_bus *, unsigned int, int, u16 *);


#line 887  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev const *dev, int where, u16 *val)
{
  int tmp;
  
#line 889 
  tmp = pci_bus_read_config_word(dev->bus,dev->devfn,where,val);
  
#line 889 
  return tmp;
}


#line 951 
int pci_enable_device(struct pci_dev *);


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1097 
int pci_request_region(struct pci_dev *, int, char const *);


#line 1099 
void pci_release_region(struct pci_dev *, int);


#line 1146 
static int ldv___pci_register_driver_91(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_92(struct pci_driver *ldv_func_arg1);


#line 1216 
void pci_disable_msix(struct pci_dev *);


#line 1227 
int pci_enable_msix_range(struct pci_dev *, struct msix_entry *, int, int);


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr, size_t size, int direction)
{
  dma_addr_t tmp_0;
  struct device *tmp;
  
#line 40 
  ;
  
#line 40 
  ;
  
#line 40 
  ;
  
#line 40 
  if (hwdev != (struct pci_dev *)0) 
#line 40 
                                    tmp = & hwdev->dev; else 
#line 40 
                                                             tmp = (struct device *)0;
  
#line 40 
  tmp_0 = dma_map_single_attrs(tmp,ptr,size,(enum dma_data_direction)direction,(struct dma_attrs *)0);
  
#line 40 
  return tmp_0;
}


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr, size_t size, int direction)
{
  struct device *tmp;
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  if (hwdev != (struct pci_dev *)0) 
#line 47 
                                    tmp = & hwdev->dev; else 
#line 47 
                                                             tmp = (struct device *)0;
  
#line 47 
  dma_unmap_single_attrs(tmp,dma_addr,size,(enum dma_data_direction)direction,(struct dma_attrs *)0);
  
#line 48 
  return;
}


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev, dma_addr_t dma_address, size_t size, int direction)
{
  struct device *tmp;
  
#line 61 
  ;
  
#line 61 
  ;
  
#line 61 
  ;
  
#line 61 
  if (hwdev != (struct pci_dev *)0) 
#line 61 
                                    tmp = & hwdev->dev; else 
#line 61 
                                                             tmp = (struct device *)0;
  
#line 61 
  dma_unmap_page(tmp,dma_address,size,(enum dma_data_direction)direction);
  
#line 62 
  return;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev, dma_addr_t dma_handle, size_t size, int direction)
{
  struct device *tmp;
  
#line 82 
  ;
  
#line 82 
  ;
  
#line 82 
  ;
  
#line 82 
  if (hwdev != (struct pci_dev *)0) 
#line 82 
                                    tmp = & hwdev->dev; else 
#line 82 
                                                             tmp = (struct device *)0;
  
#line 82 
  dma_sync_single_for_cpu(tmp,dma_handle,size,(enum dma_data_direction)direction);
  
#line 83 
  return;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev, dma_addr_t dma_handle, size_t size, int direction)
{
  struct device *tmp;
  
#line 89 
  ;
  
#line 89 
  ;
  
#line 89 
  ;
  
#line 89 
  if (hwdev != (struct pci_dev *)0) 
#line 89 
                                    tmp = & hwdev->dev; else 
#line 89 
                                                             tmp = (struct device *)0;
  
#line 89 
  dma_sync_single_for_device(tmp,dma_handle,size,(enum dma_data_direction)direction);
  
#line 90 
  return;
}


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_mapping_error(struct pci_dev *pdev, dma_addr_t dma_addr)
{
  int tmp;
  
#line 109 
  tmp = dma_mapping_error(& pdev->dev,dma_addr);
  
#line 109 
  return tmp;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
{
  int tmp;
  
#line 115 
  tmp = dma_set_mask(& dev->dev,mask);
  
#line 115 
  return tmp;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
{
  int tmp;
  
#line 120 
  tmp = dma_set_coherent_mask(& dev->dev,mask);
  
#line 120 
  return tmp;
}


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 1666 
void *pci_ioremap_bar(struct pci_dev *, int);


#line 1672 
int pci_enable_sriov(struct pci_dev *, int);


#line 1673 
void pci_disable_sriov(struct pci_dev *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 25 
  tmp = (struct iphdr *)skb_network_header(skb);
  
#line 25 
  return tmp;
}


#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ip.h"
__inline static bool ip_is_fragment(struct iphdr const *iph)
{
  bool __retres;
  
#line 257 
  __retres = (_Bool)(((int)iph->frag_off & 65343) != 0);
  
#line 257 
  return __retres;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/firmware.h"
int request_firmware(struct firmware const **, char const *, struct device *);


#line 51 
void release_firmware(struct firmware const *);


#line 1744  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
enum vxge_hw_status vxge_hw_mrpcim_stats_access(struct __vxge_hw_device *hldev, u32 operation, u32 location, u32 offset, u64 *stat);


#line 1786 
enum vxge_hw_status vxge_hw_mgmt_reg_write(struct __vxge_hw_device *hldev, enum vxge_hw_mgmt_reg_type type, u32 index, u32 offset, u64 value);


#line 1912 
void vxge_hw_ring_rxd_pre_post(struct __vxge_hw_ring *ring, void *rxdh);


#line 1917 
void vxge_hw_ring_rxd_post_post(struct __vxge_hw_ring *ring, void *rxdh);


#line 1922 
void vxge_hw_ring_rxd_post_post_wmb(struct __vxge_hw_ring *ring, void *rxdh);


#line 1930 
enum vxge_hw_status vxge_hw_ring_rxd_next_completed(struct __vxge_hw_ring *ring, void **rxdh, u8 *t_code);


#line 1935 
enum vxge_hw_status vxge_hw_ring_handle_tcode(struct __vxge_hw_ring *ring, void *rxdh, u8 t_code);


#line 2012 
enum vxge_hw_status vxge_hw_fifo_txdl_reserve(struct __vxge_hw_fifo *fifo, void **txdlh, void **txdl_priv);


#line 2017 
void vxge_hw_fifo_txdl_buffer_set(struct __vxge_hw_fifo *fifo, void *txdlh, u32 frag_idx, dma_addr_t dma_pointer, u32 size);


#line 2024 
void vxge_hw_fifo_txdl_post(struct __vxge_hw_fifo *fifo, void *txdlh);


#line 2028 
u32 vxge_hw_fifo_free_txdl_count_get(struct __vxge_hw_fifo *fifoh);


#line 2031 
enum vxge_hw_status vxge_hw_fifo_txdl_next_completed(struct __vxge_hw_fifo *fifo, void **txdlh, enum vxge_hw_fifo_tcode *t_code);


#line 2036 
enum vxge_hw_status vxge_hw_fifo_handle_tcode(struct __vxge_hw_fifo *fifo, void *txdlh, enum vxge_hw_fifo_tcode t_code);


#line 2041 
void vxge_hw_fifo_txdl_free(struct __vxge_hw_fifo *fifo, void *txdlh);


#line 2116 
void vxge_hw_device_intr_enable(struct __vxge_hw_device *hldev);


#line 2119 
u32 vxge_hw_device_set_intr_type(struct __vxge_hw_device *hldev, u32 intr_mode);


#line 2121 
void vxge_hw_device_intr_disable(struct __vxge_hw_device *hldev);


#line 2124 
void vxge_hw_device_mask_all(struct __vxge_hw_device *hldev);


#line 2127 
void vxge_hw_device_unmask_all(struct __vxge_hw_device *hldev);


#line 2130 
enum vxge_hw_status vxge_hw_device_begin_irq(struct __vxge_hw_device *hldev, u32 skip_alarms, u64 *reason);


#line 2135 
void vxge_hw_device_clear_tx_rx(struct __vxge_hw_device *hldev);


#line 2142 
void vxge_hw_vpath_dynamic_rti_rtimer_set(struct __vxge_hw_ring *ring);


#line 2144 
void vxge_hw_vpath_dynamic_tti_rtimer_set(struct __vxge_hw_fifo *fifo);


#line 2156 
enum vxge_hw_status vxge_hw_vpath_mac_addr_add(struct __vxge_hw_vpath_handle *vp, u8 *macaddr, u8 *macaddr_mask, enum vxge_hw_vpath_mac_addr_add_mode duplicate_mode);


#line 2163 
enum vxge_hw_status vxge_hw_vpath_mac_addr_get(struct __vxge_hw_vpath_handle *vp, u8 *macaddr, u8 *macaddr_mask);


#line 2169 
enum vxge_hw_status vxge_hw_vpath_mac_addr_get_next(struct __vxge_hw_vpath_handle *vp, u8 *macaddr, u8 *macaddr_mask);


#line 2175 
enum vxge_hw_status vxge_hw_vpath_mac_addr_delete(struct __vxge_hw_vpath_handle *vp, u8 *macaddr, u8 *macaddr_mask);


#line 2181 
enum vxge_hw_status vxge_hw_vpath_vid_add(struct __vxge_hw_vpath_handle *vp, u64 vid);


#line 2186 
enum vxge_hw_status vxge_hw_vpath_vid_delete(struct __vxge_hw_vpath_handle *vp, u64 vid);


#line 2210 
enum vxge_hw_status vxge_hw_vpath_promisc_enable(struct __vxge_hw_vpath_handle *vp);


#line 2213 
enum vxge_hw_status vxge_hw_vpath_promisc_disable(struct __vxge_hw_vpath_handle *vp);


#line 2216 
enum vxge_hw_status vxge_hw_vpath_bcast_enable(struct __vxge_hw_vpath_handle *vp);


#line 2219 
enum vxge_hw_status vxge_hw_vpath_mcast_enable(struct __vxge_hw_vpath_handle *vp);


#line 2222 
enum vxge_hw_status vxge_hw_vpath_mcast_disable(struct __vxge_hw_vpath_handle *vp);


#line 2225 
enum vxge_hw_status vxge_hw_vpath_poll_rx(struct __vxge_hw_ring *ring);


#line 2228 
enum vxge_hw_status vxge_hw_vpath_poll_tx(struct __vxge_hw_fifo *fifo, struct sk_buff ***skb_ptr, int nr_skb, int *more);


#line 2232 
enum vxge_hw_status vxge_hw_vpath_alarm_process(struct __vxge_hw_vpath_handle *vp, u32 skip_alarms);


#line 2237 
void vxge_hw_vpath_msix_set(struct __vxge_hw_vpath_handle *vp, int *tim_msix_id, int alarm_msix_id);


#line 2241 
void vxge_hw_vpath_msix_mask(struct __vxge_hw_vpath_handle *vp, int msix_id);


#line 2244 
void vxge_hw_vpath_msix_clear(struct __vxge_hw_vpath_handle *vp, int msix_id);


#line 2246 
void vxge_hw_device_flush_io(struct __vxge_hw_device *hldev);


#line 2249 
void vxge_hw_vpath_msix_unmask(struct __vxge_hw_vpath_handle *vp, int msix_id);


#line 2252 
enum vxge_hw_status vxge_hw_vpath_intr_enable(struct __vxge_hw_vpath_handle *vp);


#line 2255 
enum vxge_hw_status vxge_hw_vpath_intr_disable(struct __vxge_hw_vpath_handle *vp);


#line 2258 
void vxge_hw_vpath_inta_mask_tx_rx(struct __vxge_hw_vpath_handle *vp);


#line 2261 
void vxge_hw_vpath_inta_unmask_tx_rx(struct __vxge_hw_vpath_handle *vp);


#line 2265 
void vxge_hw_channel_msix_mask(struct __vxge_hw_channel *channel, int msix_id);


#line 2268 
void vxge_hw_channel_msix_unmask(struct __vxge_hw_channel *channel, int msix_id);


#line 2271 
void vxge_hw_channel_msix_clear(struct __vxge_hw_channel *channel, int msix_id);


#line 2286 
void vxge_hw_vpath_tti_ci_set(struct __vxge_hw_fifo *fifo);


#line 2288 
void vxge_hw_vpath_dynamic_rti_ci_set(struct __vxge_hw_ring *ring);


#line 1464  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
void vxge_hw_device_debug_set(struct __vxge_hw_device *hldev, enum vxge_debug_level level, u32 mask);


#line 1470 
u32 vxge_hw_device_error_level_get(struct __vxge_hw_device *hldev);


#line 1473 
u32 vxge_hw_device_trace_level_get(struct __vxge_hw_device *hldev);


#line 1514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void vxge_hw_ring_rxd_1b_set(void *rxdh, dma_addr_t dma_pointer, u32 size)
{
  
#line 1519 
  struct vxge_hw_ring_rxd_1 *rxdp = (struct vxge_hw_ring_rxd_1 *)rxdh;
  
#line 1520 
  rxdp->buffer0_ptr = dma_pointer;
  
#line 1521 
  rxdp->control_1 &= 13835339530258874367ULL;
  
#line 1522 
  rxdp->control_1 |= (unsigned long long)size << 48;
  
#line 1523 
  return;
}


#line 1540  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void vxge_hw_ring_rxd_1b_get(struct __vxge_hw_ring *ring_handle, void *rxdh, u32 *pkt_length)
{
  
#line 1545 
  struct vxge_hw_ring_rxd_1 *rxdp = (struct vxge_hw_ring_rxd_1 *)rxdh;
  
#line 1547 
  *pkt_length = (unsigned int)(rxdp->control_1 >> 48) & 16383U;
  
#line 1549 
  return;
}


#line 1562  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void vxge_hw_ring_rxd_1b_info_get(struct __vxge_hw_ring *ring_handle, void *rxdh, struct vxge_hw_ring_rxd_info *rxd_info)
{
  
#line 1568 
  struct vxge_hw_ring_rxd_1 *rxdp = (struct vxge_hw_ring_rxd_1 *)rxdh;
  
#line 1569 
  rxd_info->syn_flag = (unsigned int)(rxdp->control_0 >> 47) & 1U;
  
#line 1571 
  rxd_info->is_icmp = (unsigned int)(rxdp->control_0 >> 46) & 1U;
  
#line 1573 
  rxd_info->fast_path_eligible = (unsigned int)(rxdp->control_0 >> 55) & 1U;
  
#line 1575 
  rxd_info->l3_cksum_valid = (unsigned int)(rxdp->control_0 >> 54) & 1U;
  
#line 1577 
  rxd_info->l3_cksum = (unsigned int)(rxdp->control_0 >> 16) & 65535U;
  
#line 1579 
  rxd_info->l4_cksum_valid = (unsigned int)(rxdp->control_0 >> 53) & 1U;
  
#line 1581 
  rxd_info->l4_cksum = (unsigned int)rxdp->control_0 & 65535U;
  
#line 1583 
  rxd_info->frame = (unsigned int)(rxdp->control_0 >> 37) & 3U;
  
#line 1585 
  rxd_info->proto = (unsigned int)(rxdp->control_0 >> 32) & 31U;
  
#line 1587 
  rxd_info->is_vlan = (unsigned int)(rxdp->control_0 >> 39) & 1U;
  
#line 1589 
  rxd_info->vlan = (unsigned int)rxdp->control_1 & 65535U;
  
#line 1591 
  rxd_info->rth_bucket = (unsigned int)(rxdp->control_0 >> 57) & 127U;
  
#line 1593 
  rxd_info->rth_it_hit = (unsigned int)(rxdp->control_0 >> 44) & 1U;
  
#line 1595 
  rxd_info->rth_spdm_hit = (unsigned int)(rxdp->control_0 >> 45) & 1U;
  
#line 1597 
  rxd_info->rth_hash_type = (unsigned int)(rxdp->control_0 >> 40) & 15U;
  
#line 1599 
  rxd_info->rth_value = (unsigned int)(rxdp->control_1 >> 16);
  
#line 1601 
  return;
}


#line 1612  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void *vxge_hw_ring_rxd_private_get(void *rxdh)
{
  void *__retres;
  
#line 1614 
  struct vxge_hw_ring_rxd_1 *rxdp = (struct vxge_hw_ring_rxd_1 *)rxdh;
  
#line 1615 
  __retres = (void *)rxdp->host_control;
  
#line 1615 
  return __retres;
}


#line 1634  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void vxge_hw_fifo_txdl_cksum_set_bits(void *txdlh, u64 cksum_bits)
{
  
#line 1636 
  struct vxge_hw_fifo_txd *txdp = (struct vxge_hw_fifo_txd *)txdlh;
  
#line 1637 
  txdp->control_1 |= cksum_bits;
  
#line 1638 
  return;
}


#line 1654  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void vxge_hw_fifo_txdl_mss_set(void *txdlh, int mss)
{
  
#line 1656 
  struct vxge_hw_fifo_txd *txdp = (struct vxge_hw_fifo_txd *)txdlh;
  
#line 1658 
  txdp->control_0 |= 8589934592ULL;
  
#line 1659 
  txdp->control_0 |= (unsigned long long)mss << 16;
  
#line 1660 
  return;
}


#line 1670  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void vxge_hw_fifo_txdl_vlan_set(void *txdlh, u16 vlan_tag)
{
  
#line 1672 
  struct vxge_hw_fifo_txd *txdp = (struct vxge_hw_fifo_txd *)txdlh;
  
#line 1674 
  txdp->control_1 |= 281474976710656ULL;
  
#line 1675 
  txdp->control_1 |= (unsigned long long)vlan_tag << 32;
  
#line 1676 
  return;
}


#line 1689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void *vxge_hw_fifo_txdl_private_get(void *txdlh)
{
  void *__retres;
  
#line 1691 
  struct vxge_hw_fifo_txd *txdp = (struct vxge_hw_fifo_txd *)txdlh;
  
#line 1693 
  __retres = (void *)txdp->host_control;
  
#line 1693 
  return __retres;
}


#line 1849 
enum vxge_hw_status vxge_hw_device_hw_info_get(void *bar0, struct vxge_hw_device_hw_info *hw_info);


#line 1853 
enum vxge_hw_status vxge_hw_device_config_default_get(struct vxge_hw_device_config *device_config);


#line 1864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static enum vxge_hw_device_link_state vxge_hw_device_link_state_get(struct __vxge_hw_device *devh)
{
  enum vxge_hw_device_link_state __retres;
  
#line 1867 
  __retres = devh->link_state;
  
#line 1867 
  return __retres;
}


#line 1870 
void vxge_hw_device_terminate(struct __vxge_hw_device *hldev);


#line 1875 
u16 vxge_hw_device_link_width_get(struct __vxge_hw_device *hldev);


#line 1880 
enum vxge_hw_status vxge_hw_device_initialize(struct __vxge_hw_device **devh, struct vxge_hw_device_attr *attr, struct vxge_hw_device_config *device_config);


#line 1985 
enum vxge_hw_status vxge_hw_vpath_open(struct __vxge_hw_device *hldev, struct vxge_hw_vpath_attr *attr, struct __vxge_hw_vpath_handle **vpath_handle);


#line 1990 
enum vxge_hw_status vxge_hw_vpath_close(struct __vxge_hw_vpath_handle *vp);


#line 1994 
enum vxge_hw_status vxge_hw_vpath_reset(struct __vxge_hw_vpath_handle *vp);


#line 1998 
enum vxge_hw_status vxge_hw_vpath_recover_from_reset(struct __vxge_hw_vpath_handle *vp);


#line 2002 
void vxge_hw_vpath_enable(struct __vxge_hw_vpath_handle *vp);


#line 2005 
enum vxge_hw_status vxge_hw_vpath_check_leak(struct __vxge_hw_ring *ring);


#line 2007 
enum vxge_hw_status vxge_hw_vpath_mtu_set(struct __vxge_hw_vpath_handle *vp, u32 new_mtu);


#line 2012 
void vxge_hw_vpath_rx_doorbell_init(struct __vxge_hw_vpath_handle *vp);


#line 2048 
enum vxge_hw_status vxge_hw_vpath_strip_fcs_check(struct __vxge_hw_device *hldev, u64 vpath_mask);


#line 2074 
enum vxge_hw_status vxge_hw_vpath_rts_rth_itable_set(struct __vxge_hw_vpath_handle **vpath_handles, u32 vpath_count, u8 *mtable, u8 *itable, u32 itable_size);


#line 2081 
enum vxge_hw_status vxge_hw_vpath_rts_rth_set(struct __vxge_hw_vpath_handle *vp, enum vxge_hw_rth_algoritms algorithm, struct vxge_hw_rth_hash_types *hash_type, u16 bucket_size);


#line 2088 
enum vxge_hw_status __vxge_hw_device_is_privilaged(u32 host_type, u32 func_id);


#line 2094 
void vxge_hw_device_wait_receive_idle(struct __vxge_hw_device *hldev);


#line 2097 
enum vxge_hw_status vxge_hw_upgrade_read_version(struct __vxge_hw_device *hldev, u32 *major, u32 *minor, u32 *build);


#line 2100 
enum vxge_hw_status vxge_hw_flash_fw(struct __vxge_hw_device *hldev);


#line 2103 
enum vxge_hw_status vxge_update_fw_image(struct __vxge_hw_device *hldev, u8 const *fwdata, int size);


#line 2107 
enum vxge_hw_status vxge_hw_vpath_eprom_img_ver_get(struct __vxge_hw_device *hldev, struct eprom_image *img);


#line 2110 
int vxge_hw_vpath_wait_receive_idle(struct __vxge_hw_device *hldev, u32 vp_id);


#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.h"
__inline static void vxge_os_timer(struct timer_list *timer, void (*func)(unsigned long ), struct vxgedev *vdev, unsigned long timeout)
{
  {
    struct lock_class_key __key;
    
#line 423 
    init_timer_key(timer,0U,"(timer)",& __key);
  }
  
#line 424 
  timer->function = func;
  
#line 425 
  timer->data = (unsigned long)vdev;
  
#line 426 
  ldv_mod_timer_73(timer,jiffies + timeout);
  
#line 427 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static struct pci_device_id const vxge_id_table[3U] = {{.vendor = 6101U, .device = 22323U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 6101U, .device = 22579U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
struct pci_device_id const __mod_pci__vxge_id_table_device_table[3U];

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vlan_tag_strip = 1;

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int addr_learn_en = 0;

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int max_config_port = 1;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int max_config_vpath = -1;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int max_mac_vpath = 30;

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int max_config_dev = 255;

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static u16 vpath_selector[17U] = {(unsigned short)0U, (unsigned short)1U, (unsigned short)3U, (unsigned short)3U, (unsigned short)7U, (unsigned short)7U, (unsigned short)7U, (unsigned short)7U, (unsigned short)15U, (unsigned short)15U, (unsigned short)15U, (unsigned short)15U, (unsigned short)15U, (unsigned short)15U, (unsigned short)15U, (unsigned short)15U, (unsigned short)31U};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static unsigned int bw_percentage[17U] = {255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U, 255U};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static struct vxge_drv_config *driver_config;

#line 90 
static enum vxge_hw_status vxge_reset_all_vpaths(struct vxgedev *vdev);


#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
__inline static int is_vxge_card_up(struct vxgedev *vdev)
{
  int tmp;
  
#line 94 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vdev->state));
  
#line 94 
  return tmp;
}


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
__inline static void VXGE_COMPLETE_VPATH_TX(struct vxge_fifo *fifo)
{
  struct sk_buff **temp;
  struct sk_buff *completed[128U];
  int more;
  bool tmp;
  
#line 99 
  struct sk_buff **skb_ptr = (struct sk_buff **)0;
  ldv_55873: 
#line 104 
  ;
  
#line 106 
  more = 0;
  
#line 107 
  skb_ptr = (struct sk_buff **)(& completed);
  
#line 109 
  tmp = __netif_tx_trylock(fifo->txq);
  
#line 109 
  if ((int)tmp != 0) {
    
#line 110 
    vxge_hw_vpath_poll_tx(fifo->handle,& skb_ptr,128,& more);
    
#line 112 
    __netif_tx_unlock(fifo->txq);
  }
  else ;
  
#line 116 
  temp = (struct sk_buff **)(& completed);
  
#line 116 
  goto ldv_55871;
  ldv_55870: 
#line 117 
  ;
  
#line 117 
  dev_kfree_skb_irq(*temp);
  
#line 116 
  temp += 1;
  ldv_55871: 
#line 117 
  ;
  
#line 116 
  if (temp != skb_ptr) 
#line 118 
                       goto ldv_55870; else 
#line 121 
                                            goto ldv_55872;
  ldv_55872: 
#line 122 
  ;
  
#line 118 
  if (more != 0) 
#line 120 
                 goto ldv_55873; else 
#line 123 
                                      goto ldv_55874;
  ldv_55874: 
#line 124 
  ;
  
#line 125 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
__inline static void VXGE_COMPLETE_ALL_TX(struct vxgedev *vdev)
{
  int i;
  
#line 126 
  i = 0;
  
#line 126 
  goto ldv_55880;
  ldv_55879: 
#line 127 
  ;
  
#line 127 
  VXGE_COMPLETE_VPATH_TX(& (vdev->vpaths + i)->fifo);
  
#line 126 
  i += 1;
  ldv_55880: 
#line 127 
  ;
  
#line 126 
  if (vdev->no_of_vpath > i) 
#line 128 
                             goto ldv_55879; else 
#line 131 
                                                  goto ldv_55881;
  ldv_55881: 
#line 132 
  ;
  
#line 133 
  return;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
__inline static void VXGE_COMPLETE_ALL_RX(struct vxgedev *vdev)
{
  int i;
  struct vxge_ring *ring;
  
#line 136 
  i = 0;
  
#line 136 
  goto ldv_55888;
  ldv_55887: 
#line 137 
  ;
  
#line 137 
  ring = & (vdev->vpaths + i)->ring;
  
#line 138 
  vxge_hw_vpath_poll_rx(ring->handle);
  
#line 136 
  i += 1;
  ldv_55888: 
#line 137 
  ;
  
#line 136 
  if (vdev->no_of_vpath > i) 
#line 138 
                             goto ldv_55887; else 
#line 141 
                                                  goto ldv_55889;
  ldv_55889: 
#line 142 
  ;
  
#line 143 
  return;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_callback_link_up(struct __vxge_hw_device *hldev)
{
  
#line 150 
  struct net_device *dev = hldev->ndev;
  
#line 151 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 153 
  printk("%s: %s:%d",(char *)(& (vdev->ndev)->name),"vxge_callback_link_up",154);
  
#line 155 
  netdev_notice((struct net_device const *)vdev->ndev,"Link Up\n");
  
#line 156 
  vdev->stats.link_up += 1UL;
  
#line 158 
  netif_carrier_on(vdev->ndev);
  
#line 159 
  netif_tx_wake_all_queues(vdev->ndev);
  
#line 161 
  printk("%s: %s:%d Exiting...",(char *)(& (vdev->ndev)->name),"vxge_callback_link_up",162);
  
#line 162 
  return;
}


#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_callback_link_down(struct __vxge_hw_device *hldev)
{
  
#line 173 
  struct net_device *dev = hldev->ndev;
  
#line 174 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 176 
  printk("%s: %s:%d",(char *)(& (vdev->ndev)->name),"vxge_callback_link_down",177);
  
#line 178 
  netdev_notice((struct net_device const *)vdev->ndev,"Link Down\n");
  
#line 180 
  vdev->stats.link_down += 1UL;
  
#line 181 
  netif_carrier_off(vdev->ndev);
  
#line 182 
  netif_tx_stop_all_queues(vdev->ndev);
  
#line 184 
  printk("%s: %s:%d Exiting...",(char *)(& (vdev->ndev)->name),"vxge_callback_link_down",185);
  
#line 185 
  return;
}


#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static struct sk_buff *vxge_rx_alloc(void *dtrh, struct vxge_ring *ring, int const skb_size)
{
  struct sk_buff *__retres;
  struct net_device *dev;
  struct sk_buff *skb;
  struct vxge_rx_priv *rx_priv;
  
#line 200 
  dev = ring->ndev;
  
#line 201 
  printk("%s: %s:%d",(char *)(& (ring->ndev)->name),"vxge_rx_alloc",202);
  
#line 204 
  rx_priv = (struct vxge_rx_priv *)vxge_hw_ring_rxd_private_get(dtrh);
  
#line 207 
  skb = netdev_alloc_skb(dev,(unsigned int)(skb_size + 2));
  
#line 209 
  if (skb == (struct sk_buff *)0) {
    
#line 210 
    printk("%s: out of memory to allocate SKB",(char *)(& dev->name));
    
#line 212 
    ring->stats.skb_alloc_fail += 1UL;
    
#line 213 
    __retres = (struct sk_buff *)0;
    
#line 213 
    goto return_label;
  }
  else ;
  
#line 216 
  printk("%s: %s:%d  Skb : 0x%p",(char *)(& (ring->ndev)->name),"vxge_rx_alloc",218,skb);
  
#line 220 
  skb_reserve(skb,2);
  
#line 222 
  rx_priv->skb = skb;
  
#line 223 
  rx_priv->skb_data = (unsigned char *)0U;
  
#line 224 
  rx_priv->data_size = (unsigned long long)skb_size;
  
#line 225 
  printk("%s: %s:%d Exiting...",(char *)(& (ring->ndev)->name),"vxge_rx_alloc",226);
  
#line 228 
  __retres = skb;
  return_label: 
#line 228 
                return __retres;
}


#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_rx_map(void *dtrh, struct vxge_ring *ring)
{
  int __retres;
  struct vxge_rx_priv *rx_priv;
  dma_addr_t dma_addr;
  int tmp_0;
  
#line 239 
  printk("%s: %s:%d",(char *)(& (ring->ndev)->name),"vxge_rx_map",240);
  
#line 241 
  rx_priv = (struct vxge_rx_priv *)vxge_hw_ring_rxd_private_get(dtrh);
  
#line 243 
  rx_priv->skb_data = (rx_priv->skb)->data;
  
#line 244 
  dma_addr = pci_map_single(ring->pdev,(void *)rx_priv->skb_data,(unsigned long)rx_priv->data_size,2);
  
#line 247 
  tmp_0 = pci_dma_mapping_error(ring->pdev,dma_addr);
  
#line 247 
  if ((long)(tmp_0 != 0) != 0L) {
    
#line 248 
    ring->stats.pci_map_fail += 1UL;
    
#line 249 
    __retres = -5;
    
#line 249 
    goto return_label;
  }
  else ;
  
#line 251 
  printk("%s: %s:%d  1 buffer mode dma_addr = 0x%llx",(char *)(& (ring->ndev)->name),"vxge_rx_map",254,dma_addr);
  
#line 255 
  vxge_hw_ring_rxd_1b_set(dtrh,dma_addr,(unsigned int)rx_priv->data_size);
  
#line 257 
  rx_priv->data_dma = dma_addr;
  
#line 258 
  printk("%s: %s:%d Exiting...",(char *)(& (ring->ndev)->name),"vxge_rx_map",259);
  
#line 261 
  __retres = 0;
  return_label: 
#line 261 
                return __retres;
}


#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_rx_initial_replenish(void *dtrh, void *userdata)
{
  enum vxge_hw_status __retres;
  struct vxge_rx_priv *rx_priv;
  struct sk_buff *tmp;
  int tmp_1;
  
#line 271 
  struct vxge_ring *ring = (struct vxge_ring *)userdata;
  
#line 274 
  printk("%s: %s:%d",(char *)(& (ring->ndev)->name),"vxge_rx_initial_replenish",275);
  
#line 276 
  tmp = vxge_rx_alloc(dtrh,ring,(int)((ring->ndev)->mtu + 26U));
  
#line 276 
  if (tmp == (struct sk_buff *)0) {
    
#line 278 
    __retres = VXGE_HW_FAIL;
    
#line 278 
    goto return_label;
  }
  else ;
  
#line 280 
  tmp_1 = vxge_rx_map(dtrh,ring);
  
#line 280 
  if (tmp_1 != 0) {
    
#line 281 
    rx_priv = (struct vxge_rx_priv *)vxge_hw_ring_rxd_private_get(dtrh);
    
#line 282 
    consume_skb(rx_priv->skb);
    
#line 284 
    __retres = VXGE_HW_FAIL;
    
#line 284 
    goto return_label;
  }
  else ;
  
#line 286 
  printk("%s: %s:%d Exiting...",(char *)(& (ring->ndev)->name),"vxge_rx_initial_replenish",287);
  
#line 289 
  __retres = VXGE_HW_OK;
  return_label: 
#line 289 
                return __retres;
}


#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
__inline static void vxge_rx_complete(struct vxge_ring *ring, struct sk_buff *skb, u16 vlan, int pkt_length, struct vxge_hw_ring_rxd_info *ext_info)
{
  
#line 297 
  printk("%s: %s:%d",(char *)(& (ring->ndev)->name),"vxge_rx_complete",298);
  
#line 299 
  skb_record_rx_queue(skb,(unsigned short)((int)((unsigned short)ring->driver_id)));
  
#line 300 
  skb->protocol = eth_type_trans(skb,ring->ndev);
  
#line 302 
  u64_stats_init(& ring->stats.syncp);
  
#line 303 
  ring->stats.rx_frms += 1ULL;
  
#line 304 
  ring->stats.rx_bytes += (unsigned long long)pkt_length;
  
#line 306 
  if ((unsigned int)*((unsigned char *)skb + 144UL) == 2U) 
#line 307 
                                                           ring->stats.rx_mcast += 1ULL; else ;
  
#line 308 
  u64_stats_init(& ring->stats.syncp);
  
#line 310 
  printk("%s: %s:%d  skb protocol = %d",(char *)(& (ring->ndev)->name),"vxge_rx_complete",312,(int)skb->protocol);
  
#line 314 
  if (ext_info->vlan != 0U && ring->vlan_tag_strip == 1) 
#line 316 
                                                         __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)((int)((unsigned short)ext_info->vlan))); else ;
  
#line 317 
  napi_gro_receive(ring->napi_p,skb);
  
#line 319 
  printk("%s: %s:%d Exiting...",(char *)(& (ring->ndev)->name),"vxge_rx_complete",320);
  
#line 320 
  return;
}


#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
__inline static void vxge_re_pre_post(void *dtr, struct vxge_ring *ring, struct vxge_rx_priv *rx_priv)
{
  
#line 326 
  pci_dma_sync_single_for_device(ring->pdev,rx_priv->data_dma,(unsigned long)rx_priv->data_size,2);
  
#line 329 
  vxge_hw_ring_rxd_1b_set(dtr,rx_priv->data_dma,(unsigned int)rx_priv->data_size);
  
#line 330 
  vxge_hw_ring_rxd_pre_post(ring->handle,dtr);
  
#line 331 
  return;
}


#line 333  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
__inline static void vxge_post(int *dtr_cnt, void **first_dtr, void *post_dtr, struct __vxge_hw_ring *ringh)
{
  
#line 336 
  int dtr_count = *dtr_cnt;
  
#line 337 
  if (((unsigned int)*dtr_cnt & 3U) == 0U) {
    
#line 338 
    if (*first_dtr != (void *)0) 
#line 339 
                                 vxge_hw_ring_rxd_post_post_wmb(ringh,*first_dtr); else ;
    
#line 340 
    *first_dtr = post_dtr;
  }
  else 
#line 342 
       vxge_hw_ring_rxd_post_post(ringh,post_dtr);
  
#line 343 
  dtr_count += 1;
  
#line 344 
  *dtr_cnt = dtr_count;
  
#line 345 
  return;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_rx_1b_compl(struct __vxge_hw_ring *ringh, void *dtr, u8 t_code, void *userdata)
{
  enum vxge_hw_status __retres;
  unsigned int dma_sizes;
  int data_size;
  dma_addr_t data_dma;
  int pkt_length;
  struct sk_buff *skb;
  struct vxge_rx_priv *rx_priv;
  struct vxge_hw_ring_rxd_info ext_info;
  enum vxge_hw_status tmp_3;
  
#line 357 
  struct vxge_ring *ring = (struct vxge_ring *)userdata;
  
#line 358 
  struct net_device *dev = ring->ndev;
  
#line 360 
  void *first_dtr = (void *)0;
  
#line 361 
  int dtr_cnt = 0;
  
#line 368 
  printk("%s: %s:%d",(char *)(& (ring->ndev)->name),"vxge_rx_1b_compl",369);
  
#line 371 
  if (ring->budget <= 0) 
#line 372 
                         goto out; else ;
  ldv_55969: 
#line 373 
  ;
  
#line 375 
  __builtin_prefetch((void const *)dtr + 64U);
  
#line 376 
  rx_priv = (struct vxge_rx_priv *)vxge_hw_ring_rxd_private_get(dtr);
  
#line 377 
  skb = rx_priv->skb;
  
#line 378 
  data_size = (int)rx_priv->data_size;
  
#line 379 
  data_dma = rx_priv->data_dma;
  
#line 380 
  __builtin_prefetch((void const *)rx_priv->skb_data);
  
#line 382 
  printk("%s: %s:%d  skb = 0x%p",(char *)(& (ring->ndev)->name),"vxge_rx_1b_compl",384,skb);
  
#line 386 
  vxge_hw_ring_rxd_1b_get(ringh,dtr,& dma_sizes);
  
#line 387 
  pkt_length = (int)dma_sizes;
  
#line 389 
  pkt_length += -4;
  
#line 391 
  printk("%s: %s:%d  Packet Length = %d",(char *)(& (ring->ndev)->name),"vxge_rx_1b_compl",393,pkt_length);
  
#line 395 
  vxge_hw_ring_rxd_1b_info_get(ringh,dtr,& ext_info);
  
#line 400 
  __builtin_prefetch((void const *)skb + 64U);
  
#line 401 
  if ((long)((unsigned int)t_code != 0U) != 0L) {
    enum vxge_hw_status tmp_0;
    
#line 402 
    tmp_0 = vxge_hw_ring_handle_tcode(ringh,dtr,(unsigned char)((int)t_code));
    
#line 402 
    if (tmp_0 != VXGE_HW_OK) {
      
#line 405 
      ring->stats.rx_errors += 1UL;
      
#line 406 
      printk("%s: %s :%d Rx T_code is %d",(char *)(& (ring->ndev)->name),"vxge_rx_1b_compl",409,(int)t_code);
      
#line 415 
      vxge_re_pre_post(dtr,ring,rx_priv);
      
#line 417 
      vxge_post(& dtr_cnt,& first_dtr,dtr,ringh);
      
#line 418 
      ring->stats.rx_dropped += 1UL;
      
#line 419 
      goto ldv_55964;
    }
    else ;
  }
  else ;
  
#line 423 
  if (pkt_length > 256) {
    struct sk_buff *tmp_2;
    
#line 424 
    tmp_2 = vxge_rx_alloc(dtr,ring,data_size);
    
#line 424 
    if (tmp_2 != (struct sk_buff *)0) {
      int tmp_1;
      
#line 425 
      tmp_1 = vxge_rx_map(dtr,ring);
      
#line 425 
      if (tmp_1 == 0) {
        
#line 426 
        skb_put(skb,(unsigned int)pkt_length);
        
#line 428 
        pci_unmap_single(ring->pdev,data_dma,(unsigned long)data_size,2);
        
#line 431 
        vxge_hw_ring_rxd_pre_post(ringh,dtr);
        
#line 432 
        vxge_post(& dtr_cnt,& first_dtr,dtr,ringh);
      }
      else {
        
#line 435 
        consume_skb(rx_priv->skb);
        
#line 436 
        rx_priv->skb = skb;
        
#line 437 
        rx_priv->data_size = (unsigned long long)data_size;
        
#line 438 
        vxge_re_pre_post(dtr,ring,rx_priv);
        
#line 440 
        vxge_post(& dtr_cnt,& first_dtr,dtr,ringh);
        
#line 442 
        ring->stats.rx_dropped += 1UL;
        
#line 443 
        goto ldv_55965;
      }
    }
    else {
      
#line 446 
      vxge_re_pre_post(dtr,ring,rx_priv);
      
#line 448 
      vxge_post(& dtr_cnt,& first_dtr,dtr,ringh);
      
#line 449 
      ring->stats.rx_dropped += 1UL;
      
#line 450 
      goto ldv_55965;
    }
  }
  else {
    struct sk_buff *skb_up;
    
#line 455 
    skb_up = netdev_alloc_skb(dev,(unsigned int)(pkt_length + 2));
    
#line 457 
    if (skb_up != (struct sk_buff *)0) {
      
#line 458 
      skb_reserve(skb_up,2);
      
#line 461 
      pci_dma_sync_single_for_cpu(ring->pdev,data_dma,(unsigned long)data_size,2);
      
#line 465 
      printk("%s: %s:%d  skb_up = %p",(char *)(& (ring->ndev)->name),"vxge_rx_1b_compl",468,skb);
      
#line 469 
      memcpy((void *)skb_up->data,(void const *)skb->data,(unsigned long)pkt_length);
      
#line 471 
      vxge_re_pre_post(dtr,ring,rx_priv);
      
#line 473 
      vxge_post(& dtr_cnt,& first_dtr,dtr,ringh);
      
#line 476 
      skb = skb_up;
      
#line 477 
      skb_put(skb,(unsigned int)pkt_length);
    }
    else {
      
#line 479 
      vxge_re_pre_post(dtr,ring,rx_priv);
      
#line 481 
      vxge_post(& dtr_cnt,& first_dtr,dtr,ringh);
      
#line 482 
      printk("%s: vxge_rx_1b_compl: out of ",(char *)(& dev->name));
      
#line 485 
      ring->stats.skb_alloc_fail += 1UL;
      
#line 486 
      goto ldv_55965;
    }
  }
  
#line 490 
  if (((((ext_info.proto & 3U) != 0U && (ext_info.proto & 4U) == 0U) && (dev->features & 17179869184ULL) != 0ULL) && ext_info.l3_cksum == 65535U) && ext_info.l4_cksum == 65535U) 
    
#line 495 
    skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U; else 
                                                                    
#line 497 
                                                                    skb_checksum_none_assert((struct sk_buff const *)skb);
  
#line 500 
  if ((unsigned int)*((unsigned char *)ring + 48UL) != 0U) {
    struct skb_shared_hwtstamps *skb_hwts;
    
#line 502 
    u32 ns = *((u32 *)(skb->head + pkt_length));
    
#line 504 
    skb_hwts = skb_hwtstamps(skb);
    
#line 505 
    skb_hwts->hwtstamp = ns_to_ktime((unsigned long long)ns);
  }
  else ;
  
#line 512 
  if (ext_info.rth_value != 0U) 
#line 513 
                                skb_set_hash(skb,ext_info.rth_value,(enum pkt_hash_types)PKT_HASH_TYPE_L3); else ;
  
#line 516 
  vxge_rx_complete(ring,skb,(unsigned short)((int)((unsigned short)ext_info.vlan)),pkt_length,& ext_info);
  
#line 519 
  ring->budget -= 1;
  
#line 520 
  ring->pkts_processed += 1;
  
#line 521 
  if (ring->budget == 0) 
#line 522 
                         goto ldv_55965; else ;
  ldv_55964: 
#line 523 
  ;
  
#line 525 
  tmp_3 = vxge_hw_ring_rxd_next_completed(ringh,& dtr,& t_code);
  
#line 525 
  if (tmp_3 == VXGE_HW_OK) 
#line 527 
                           goto ldv_55969; else 
#line 530 
                                                goto ldv_55965;
  ldv_55965: 
#line 531 
  ;
  
#line 527 
  if (first_dtr != (void *)0) 
#line 528 
                              vxge_hw_ring_rxd_post_post_wmb(ringh,first_dtr); else ;
  out: 
#line 530 
  ;
  
#line 531 
  printk("%s:%d  Exiting...","vxge_rx_1b_compl",533);
  
#line 534 
  __retres = VXGE_HW_OK;
  
#line 534 
  return __retres;
}


#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_xmit_compl(struct __vxge_hw_fifo *fifo_hw, void *dtr, enum vxge_hw_fifo_tcode t_code, void *userdata, struct sk_buff ***skb_ptr, int nr_skb, int *more)
{
  enum vxge_hw_status __retres;
  struct sk_buff *skb;
  enum vxge_hw_status tmp_7;
  bool tmp_8;
  
#line 550 
  struct vxge_fifo *fifo = (struct vxge_fifo *)userdata;
  
#line 551 
  struct sk_buff **done_skb = *skb_ptr;
  
#line 552 
  int pkt_cnt = 0;
  
#line 554 
  printk("%s:%d Entered....","vxge_xmit_compl",555);
  ldv_55993: 
#line 555 
  ;
  {
    int frg_cnt;
    skb_frag_t *frag;
    int j;
    unsigned char *tmp_0;
    unsigned char *tmp_1;
    unsigned int tmp_2;
    int tmp_3;
    unsigned int tmp_4;
    int tmp_5;
    struct sk_buff **tmp_6;
    
#line 560 
    int i = 0;
    
#line 562 
    struct vxge_tx_priv *txd_priv = vxge_hw_fifo_txdl_private_get(dtr);
    
#line 564 
    skb = txd_priv->skb;
    
#line 565 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 565 
    frg_cnt = (int)((struct skb_shared_info *)tmp_0)->nr_frags;
    
#line 566 
    tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 566 
    frag = & ((struct skb_shared_info *)tmp_1)->frags[0];
    
#line 568 
    printk("%s: %s:%d fifo_hw = %p dtr = %p ",(char *)(& (fifo->ndev)->name),"vxge_xmit_compl",571,fifo_hw,dtr,(unsigned int)t_code);
    
#line 574 
    printk("%s: %s:%d skb = %p itxd_priv = %p frg_cnt = %d",(char *)(& (fifo->ndev)->name),"vxge_xmit_compl",577,skb,txd_priv,frg_cnt);
    
#line 578 
    if ((long)(t_code != (unsigned int)VXGE_HW_FIFO_T_CODE_OK) != 0L) {
      
#line 579 
      fifo->stats.tx_errors += 1UL;
      
#line 580 
      printk("%s: tx: dtr %p completed due to ",(char *)(& (fifo->ndev)->name),dtr,(unsigned int)t_code);
      
#line 584 
      vxge_hw_fifo_handle_tcode(fifo_hw,dtr,t_code);
    }
    else ;
    
#line 589 
    tmp_2 = skb_headlen((struct sk_buff const *)skb);
    
#line 588 
    tmp_3 = i;
    
#line 588 
    i += 1;
    
#line 588 
    ;
    
#line 588 
    ;
    
#line 588 
    pci_unmap_single(fifo->pdev,txd_priv->dma_buffers[tmp_3],(unsigned long)tmp_2,1);
    
#line 591 
    j = 0;
    
#line 591 
    goto ldv_55990;
    ldv_55989: 
#line 592 
    ;
    
#line 594 
    tmp_4 = skb_frag_size((skb_frag_t const *)frag);
    
#line 593 
    tmp_5 = i;
    
#line 593 
    i += 1;
    
#line 592 
    ;
    
#line 592 
    ;
    
#line 592 
    pci_unmap_page(fifo->pdev,txd_priv->dma_buffers[tmp_5],(unsigned long)tmp_4,1);
    
#line 595 
    frag += 1U;
    
#line 591 
    j += 1;
    ldv_55990: 
#line 592 
    ;
    
#line 591 
    if (j < frg_cnt) 
#line 593 
                     goto ldv_55989; else 
#line 596 
                                          goto ldv_55991;
    ldv_55991: 
#line 597 
    ;
    
#line 598 
    vxge_hw_fifo_txdl_free(fifo_hw,dtr);
    
#line 601 
    u64_stats_init(& fifo->stats.syncp);
    
#line 602 
    fifo->stats.tx_frms += 1ULL;
    
#line 603 
    fifo->stats.tx_bytes += (unsigned long long)skb->len;
    
#line 604 
    u64_stats_init(& fifo->stats.syncp);
    
#line 606 
    tmp_6 = done_skb;
    
#line 606 
    done_skb += 1;
    
#line 606 
    *tmp_6 = skb;
    
#line 608 
    nr_skb -= 1;
    
#line 608 
    if (nr_skb <= 0) {
      
#line 609 
      *more = 1;
      
#line 610 
      goto ldv_55992;
    }
    else ;
    
#line 613 
    pkt_cnt += 1;
    
#line 614 
    if (fifo->indicate_max_pkts < pkt_cnt) 
#line 615 
                                           goto ldv_55992; else ;
  }
  
#line 618 
  tmp_7 = vxge_hw_fifo_txdl_next_completed(fifo_hw,& dtr,& t_code);
  
#line 618 
  if (tmp_7 == VXGE_HW_OK) 
#line 620 
                           goto ldv_55993; else 
#line 623 
                                                goto ldv_55992;
  ldv_55992: 
#line 624 
  ;
  
#line 620 
  *skb_ptr = done_skb;
  
#line 621 
  tmp_8 = netif_tx_queue_stopped((struct netdev_queue const *)fifo->txq);
  
#line 621 
  if ((int)tmp_8 != 0) 
#line 622 
                       netif_tx_wake_queue(fifo->txq); else ;
  
#line 624 
  printk("%s: %s:%d  Exiting...",(char *)(& (fifo->ndev)->name),"vxge_xmit_compl",626);
  
#line 627 
  __retres = VXGE_HW_OK;
  
#line 627 
  return __retres;
}


#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static u32 vxge_get_vpath_no(struct vxgedev *vdev, struct sk_buff *skb)
{
  u32 __retres;
  u16 queue_len;
  
#line 633 
  u16 counter = (unsigned short)0U;
  
#line 634 
  if ((unsigned int)skb->protocol == 8U) {
    struct iphdr *ip;
    struct tcphdr *th;
    int tmp_4;
    bool tmp_3;
    
#line 638 
    ip = ip_hdr((struct sk_buff const *)skb);
    
#line 640 
    tmp_3 = ip_is_fragment((struct iphdr const *)ip);
    
#line 640 
    if (tmp_3) 
#line 640 
               tmp_4 = 0; else 
#line 640 
                               tmp_4 = 1;
    
#line 640 
    if (tmp_4) {
      int tmp_0;
      int tmp_2;
      
#line 641 
      th = (struct tcphdr *)ip + (int)ip->ihl * 4;
      
#line 644 
      queue_len = (unsigned short)vdev->no_of_vpath;
      
#line 646 
      if (0 != 0) 
#line 646 
                  tmp_0 = ((int)th->source << 8) | ((int)th->source >> 8);
      else {
        __u16 tmp;
        
#line 645 
        tmp = __fswab16((unsigned short)((int)th->source));
        
#line 646 
        tmp_0 = (int)tmp;
      }
      
#line 645 
      if (0 != 0) 
#line 645 
                  tmp_2 = ((int)th->dest << 8) | ((int)th->dest >> 8);
      else {
        __u16 tmp_1;
        
#line 646 
        tmp_1 = __fswab16((unsigned short)((int)th->dest));
        
#line 645 
        tmp_2 = (int)tmp_1;
      }
      
#line 645 
      counter = (unsigned short)((tmp_0 + tmp_2) & (int)vdev->vpath_selector[(int)queue_len + -1]);
      
#line 648 
      if ((int)counter >= (int)queue_len) 
#line 649 
                                          counter = (unsigned short)((unsigned int)queue_len + 65535U); else ;
    }
    else ;
  }
  else ;
  
#line 652 
  __retres = (unsigned int)counter;
  
#line 652 
  return __retres;
}


#line 655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_search_mac_addr_in_list(struct vxge_vpath *vpath, u64 del_mac)
{
  enum vxge_hw_status __retres;
  struct list_head *entry;
  struct list_head *next;
  
#line 659 
  entry = vpath->mac_addr_list.next;
  
#line 659 
  next = entry->next;
  
#line 659 
  goto ldv_56009;
  ldv_56008: 
#line 660 
  ;
  
#line 660 
  if (((struct vxge_mac_addrs *)entry)->macaddr == del_mac) {
    
#line 661 
    __retres = VXGE_HW_FAIL;
    
#line 661 
    goto return_label;
  }
  else ;
  
#line 659 
  entry = next;
  
#line 659 
  next = entry->next;
  ldv_56009: 
#line 660 
  ;
  
#line 659 
  if (& vpath->mac_addr_list != entry) 
#line 661 
                                       goto ldv_56008; else 
#line 664 
                                                            goto ldv_56010;
  ldv_56010: 
#line 665 
  ;
  
#line 663 
  __retres = VXGE_HW_OK;
  return_label: 
#line 663 
                return __retres;
}


#line 666  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_mac_list_add(struct vxge_vpath *vpath, struct macInfo *mac)
{
  int __retres;
  struct vxge_mac_addrs *new_mac_entry;
  bool tmp_0;
  
#line 669 
  u8 *mac_address = (u8 *)0U;
  
#line 671 
  if ((unsigned int)vpath->mac_addr_cnt > 2047U) {
    
#line 672 
    __retres = 1;
    
#line 672 
    goto return_label;
  }
  else ;
  
#line 674 
  new_mac_entry = (struct vxge_mac_addrs *)kzalloc_0(40UL,32U);
  
#line 675 
  if (new_mac_entry == (struct vxge_mac_addrs *)0) {
    
#line 676 
    printk("%s: memory allocation failed",(char *)"vxge");
    
#line 679 
    __retres = 0;
    
#line 679 
    goto return_label;
  }
  else ;
  
#line 682 
  list_add(& new_mac_entry->item,& vpath->mac_addr_list);
  
#line 685 
  mac_address = (u8 *)(& new_mac_entry->macaddr);
  
#line 686 
  memcpy((void *)mac_address,(void const *)(& mac->macaddr),6UL);
  
#line 688 
  new_mac_entry->state = mac->state;
  
#line 689 
  vpath->mac_addr_cnt = (u16)((int)vpath->mac_addr_cnt + 1);
  
#line 691 
  tmp_0 = is_multicast_ether_addr((u8 const *)(& mac->macaddr));
  
#line 691 
  if ((int)tmp_0 != 0) 
#line 692 
                       vpath->mcast_addr_cnt = (u16)((int)vpath->mcast_addr_cnt + 1); else ;
  
#line 694 
  __retres = 1;
  return_label: 
#line 694 
                return __retres;
}


#line 699  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_add_mac_addr(struct vxgedev *vdev, struct macInfo *mac)
{
  struct vxge_vpath *vpath;
  enum vxge_hw_vpath_mac_addr_add_mode duplicate_mode;
  bool tmp;
  
#line 701 
  enum vxge_hw_status status = 0;
  
#line 705 
  tmp = is_multicast_ether_addr((u8 const *)(& mac->macaddr));
  
#line 705 
  if ((int)tmp != 0) 
#line 706 
                     duplicate_mode = VXGE_HW_VPATH_MAC_ADDR_ADD_DUPLICATE; else 
                                                                    
#line 708 
                                                                    duplicate_mode = VXGE_HW_VPATH_MAC_ADDR_REPLACE_DUPLICATE;
  
#line 710 
  vpath = vdev->vpaths + mac->vpath_no;
  
#line 711 
  status = vxge_hw_vpath_mac_addr_add(vpath->handle,(u8 *)(& mac->macaddr),(u8 *)(& mac->macmask),duplicate_mode);
  
#line 713 
  if (status != VXGE_HW_OK) 
#line 714 
                            printk("DA config add entry failed for vpath:%d",vpath->device_id);
  else {
    int tmp_0;
    
#line 718 
    tmp_0 = vxge_mac_list_add(vpath,mac);
    
#line 718 
    if (tmp_0 == 0) 
#line 719 
                    status = VXGE_HW_EOF_TRACE_BUF; else ;
  }
  
#line 721 
  return status;
}


#line 724  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_learn_mac(struct vxgedev *vdev, u8 *mac_header)
{
  int __retres;
  struct macInfo mac_info;
  enum vxge_hw_status tmp;
  int tmp_1;
  
#line 727 
  u8 *mac_address = (u8 *)0U;
  
#line 728 
  u64 mac_addr = 0ULL;
  
#line 728 
  u64 vpath_vector = 0ULL;
  
#line 729 
  int vpath_idx = 0;
  
#line 730 
  enum vxge_hw_status status = 0;
  
#line 731 
  struct vxge_vpath *vpath = (struct vxge_vpath *)0;
  
#line 733 
  mac_address = (u8 *)(& mac_addr);
  
#line 734 
  memcpy((void *)mac_address,(void const *)mac_header,6UL);
  
#line 737 
  vpath_idx = 0;
  
#line 737 
  goto ldv_56036;
  ldv_56035: 
#line 738 
  ;
  
#line 738 
  vpath = vdev->vpaths + vpath_idx;
  
#line 739 
  tmp = vxge_search_mac_addr_in_list(vpath,mac_addr);
  
#line 739 
  if (tmp != VXGE_HW_OK) {
    
#line 740 
    __retres = vpath_idx;
    
#line 740 
    goto return_label;
  }
  else ;
  
#line 737 
  vpath_idx += 1;
  ldv_56036: 
#line 738 
  ;
  
#line 737 
  if (vdev->no_of_vpath > vpath_idx) 
#line 739 
                                     goto ldv_56035; else 
#line 742 
                                                          goto ldv_56037;
  ldv_56037: 
#line 743 
  ;
  
#line 743 
  memset((void *)(& mac_info),0,20UL);
  
#line 744 
  memcpy((void *)(& mac_info.macaddr),(void const *)mac_header,6UL);
  
#line 747 
  vpath_idx = 0;
  
#line 747 
  goto ldv_56039;
  ldv_56038: 
#line 748 
  ;
  
#line 748 
  vpath = vdev->vpaths + vpath_idx;
  
#line 749 
  if ((int)vpath->mac_addr_cnt < vpath->max_mac_addr_cnt) {
    
#line 751 
    mac_info.vpath_no = (unsigned int)vpath_idx;
    
#line 752 
    mac_info.state = VXGE_LL_MAC_ADDR_IN_DA_TABLE;
    
#line 753 
    status = vxge_add_mac_addr(vdev,& mac_info);
    
#line 754 
    if (status != VXGE_HW_OK) {
      
#line 755 
      __retres = -1;
      
#line 755 
      goto return_label;
    }
    else ;
    
#line 756 
    __retres = vpath_idx;
    
#line 756 
    goto return_label;
  }
  else ;
  
#line 747 
  vpath_idx += 1;
  ldv_56039: 
#line 748 
  ;
  
#line 747 
  if (vdev->no_of_vpath > vpath_idx) 
#line 749 
                                     goto ldv_56038; else 
#line 752 
                                                          goto ldv_56040;
  ldv_56040: 
#line 753 
  ;
  
#line 760 
  mac_info.state = VXGE_LL_MAC_ADDR_IN_LIST;
  
#line 761 
  vpath_idx = 0;
  
#line 762 
  mac_info.vpath_no = (unsigned int)vpath_idx;
  
#line 764 
  vpath = vdev->vpaths + vpath_idx;
  
#line 765 
  if ((int)vpath->mac_addr_cnt > vpath->max_mac_addr_cnt) {
    int tmp_0;
    
#line 767 
    tmp_0 = vxge_mac_list_add(vpath,& mac_info);
    
#line 767 
    if (tmp_0 == 0) {
      
#line 768 
      __retres = -1;
      
#line 768 
      goto return_label;
    }
    else ;
    
#line 769 
    __retres = vpath_idx;
    
#line 769 
    goto return_label;
  }
  else ;
  
#line 773 
  vpath_vector = 9223372036854775808ULL >> vpath->device_id;
  
#line 774 
  status = vxge_hw_mgmt_reg_write((vpath->vdev)->devh,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_mrpcim,0U,6288U,vpath_vector);
  
#line 781 
  if (status != VXGE_HW_OK) {
    
#line 782 
    printk("%s: Unable to set the vpath-%d in catch-basin mode",(char *)"vxge",vpath->device_id);
    
#line 785 
    __retres = -1;
    
#line 785 
    goto return_label;
  }
  else ;
  
#line 788 
  tmp_1 = vxge_mac_list_add(vpath,& mac_info);
  
#line 788 
  if (tmp_1 == 0) {
    
#line 789 
    __retres = -1;
    
#line 789 
    goto return_label;
  }
  else ;
  
#line 791 
  __retres = vpath_idx;
  return_label: 
#line 791 
                return __retres;
}


#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static netdev_tx_t vxge_xmit(struct sk_buff *skb, struct net_device *dev)
{
  netdev_tx_t __retres;
  void *dtr_priv;
  enum vxge_hw_status status;
  int frg_cnt;
  int first_frg_len;
  skb_frag_t *frag;
  int avail;
  u64 dma_pointer;
  struct __vxge_hw_fifo *fifo_hw;
  int offload_type;
  int tmp_0;
  bool tmp_3;
  u32 tmp_4;
  unsigned int tmp_5;
  int tmp_6;
  unsigned char *tmp_8;
  int tmp_9;
  unsigned char *tmp_10;
  unsigned int tmp_11;
  dma_addr_t tmp_13;
  unsigned int tmp_12;
  int tmp_14;
  unsigned int tmp_15;
  int tmp_16;
  unsigned char *tmp_17;
  unsigned char *tmp_19;
  unsigned int tmp_20;
  int tmp_21;
  unsigned int tmp_22;
  
#line 805 
  struct vxge_fifo *fifo = (struct vxge_fifo *)0;
  
#line 807 
  void *dtr = (void *)0;
  
#line 808 
  struct vxgedev *vdev = (struct vxgedev *)0;
  
#line 812 
  int i = 0;
  
#line 812 
  int j = 0;
  
#line 814 
  struct vxge_tx_priv *txdl_priv = (struct vxge_tx_priv *)0;
  
#line 817 
  int vpath_no = 0;
  
#line 819 
  printk("%s: %s:%d",(char *)(& dev->name),"vxge_xmit",820);
  
#line 823 
  if ((long)(skb->len == 0U) != 0L) {
    
#line 824 
    printk("%s: Buffer has no data..",(char *)(& dev->name));
    
#line 826 
    dev_kfree_skb_any(skb);
    
#line 827 
    __retres = NETDEV_TX_OK;
    
#line 827 
    goto return_label;
  }
  else ;
  
#line 830 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)dev);
  
#line 832 
  tmp_0 = is_vxge_card_up(vdev);
  
#line 832 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 833 
    printk("%s: vdev not initialized",(char *)(& dev->name));
    
#line 835 
    dev_kfree_skb_any(skb);
    
#line 836 
    __retres = NETDEV_TX_OK;
    
#line 836 
    goto return_label;
  }
  else ;
  
#line 839 
  if (vdev->config.addr_learn_en != 0) {
    
#line 840 
    vpath_no = vxge_learn_mac(vdev,skb->data + 6U);
    
#line 841 
    if (vpath_no == -1) {
      
#line 842 
      printk("%s: Failed to store the mac address",(char *)(& dev->name));
      
#line 845 
      dev_kfree_skb_any(skb);
      
#line 846 
      __retres = NETDEV_TX_OK;
      
#line 846 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 850 
  if (vdev->config.tx_steering_type == 4) {
    u16 tmp_1;
    
#line 851 
    tmp_1 = skb_get_queue_mapping((struct sk_buff const *)skb);
    
#line 851 
    vpath_no = (int)tmp_1;
  }
  else 
    
#line 852 
    if (vdev->config.tx_steering_type == 3) {
      u32 tmp_2;
      
#line 853 
      tmp_2 = vxge_get_vpath_no(vdev,skb);
      
#line 853 
      vpath_no = (int)tmp_2;
    }
    else ;
  
#line 855 
  printk("%s: vpath_no= %d",(char *)(& dev->name),vpath_no);
  
#line 857 
  if (vdev->no_of_vpath <= vpath_no) 
#line 858 
                                     vpath_no = 0; else ;
  
#line 860 
  fifo = & (vdev->vpaths + vpath_no)->fifo;
  
#line 861 
  fifo_hw = fifo->handle;
  
#line 863 
  tmp_3 = netif_tx_queue_stopped((struct netdev_queue const *)fifo->txq);
  
#line 863 
  if ((int)tmp_3 != 0) {
    
#line 864 
    __retres = NETDEV_TX_BUSY;
    
#line 864 
    goto return_label;
  }
  else ;
  
#line 866 
  tmp_4 = vxge_hw_fifo_free_txdl_count_get(fifo_hw);
  
#line 866 
  avail = (int)tmp_4;
  
#line 867 
  if (avail == 0) {
    
#line 868 
    printk("%s: No free TXDs available",(char *)(& dev->name));
    
#line 870 
    fifo->stats.txd_not_free += 1UL;
    
#line 871 
    goto _exit0;
  }
  else ;
  
#line 877 
  if (avail == 1) 
#line 878 
                  netif_tx_start_queue(fifo->txq); else ;
  
#line 880 
  status = vxge_hw_fifo_txdl_reserve(fifo_hw,& dtr,& dtr_priv);
  
#line 881 
  if ((long)(status != VXGE_HW_OK) != 0L) {
    
#line 882 
    printk("%s: Out of descriptors .",(char *)(& dev->name));
    
#line 884 
    fifo->stats.txd_out_of_desc += 1UL;
    
#line 885 
    goto _exit0;
  }
  else ;
  
#line 888 
  printk("%s: %s:%d fifo_hw = %p dtr = %p dtr_priv = %p",(char *)(& dev->name),"vxge_xmit",891,fifo_hw,dtr,dtr_priv);
  
#line 893 
  if (((int)skb->vlan_tci & 4096) != 0) {
    
#line 894 
    u16 vlan_tag = (unsigned short)((unsigned int)skb->vlan_tci & 61439U);
    
#line 895 
    vxge_hw_fifo_txdl_vlan_set(dtr,(unsigned short)((int)vlan_tag));
  }
  else ;
  
#line 898 
  tmp_5 = skb_headlen((struct sk_buff const *)skb);
  
#line 898 
  first_frg_len = (int)tmp_5;
  
#line 900 
  dma_pointer = pci_map_single(fifo->pdev,(void *)skb->data,(unsigned long)first_frg_len,1);
  
#line 903 
  tmp_6 = pci_dma_mapping_error(fifo->pdev,dma_pointer);
  
#line 903 
  if ((long)(tmp_6 != 0) != 0L) {
    
#line 904 
    vxge_hw_fifo_txdl_free(fifo_hw,dtr);
    
#line 905 
    fifo->stats.pci_map_fail += 1UL;
    
#line 906 
    goto _exit0;
  }
  else ;
  
#line 909 
  txdl_priv = (struct vxge_tx_priv *)vxge_hw_fifo_txdl_private_get(dtr);
  
#line 910 
  txdl_priv->skb = skb;
  
#line 911 
  txdl_priv->dma_buffers[j] = dma_pointer;
  
#line 913 
  tmp_8 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 913 
  frg_cnt = (int)((struct skb_shared_info *)tmp_8)->nr_frags;
  
#line 914 
  printk("%s: %s:%d skb = %p txdl_priv = %p ",(char *)(& dev->name),"vxge_xmit",918,skb,txdl_priv,frg_cnt,dma_pointer);
  
#line 920 
  ;
  
#line 920 
  ;
  
#line 920 
  tmp_9 = j;
  
#line 920 
  j += 1;
  
#line 920 
  ;
  
#line 920 
  ;
  
#line 920 
  ;
  
#line 920 
  vxge_hw_fifo_txdl_buffer_set(fifo_hw,dtr,(unsigned int)tmp_9,dma_pointer,(unsigned int)first_frg_len);
  
#line 923 
  tmp_10 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 923 
  frag = & ((struct skb_shared_info *)tmp_10)->frags[0];
  
#line 924 
  i = 0;
  
#line 924 
  goto ldv_56067;
  ldv_56066: 
#line 925 
  ;
  
#line 926 
  tmp_11 = skb_frag_size((skb_frag_t const *)frag);
  
#line 926 
  if (tmp_11 == 0U) 
#line 927 
                    goto ldv_56064; else ;
  
#line 930 
  tmp_12 = skb_frag_size((skb_frag_t const *)frag);
  
#line 929 
  ;
  
#line 929 
  ;
  
#line 929 
  tmp_13 = skb_frag_dma_map(& (fifo->pdev)->dev,(skb_frag_t const *)frag,0UL,(unsigned long)tmp_12,(enum dma_data_direction)DMA_TO_DEVICE);
  
#line 929 
  dma_pointer = tmp_13;
  
#line 933 
  tmp_14 = dma_mapping_error(& (fifo->pdev)->dev,dma_pointer);
  
#line 933 
  if ((long)(tmp_14 != 0) != 0L) 
#line 934 
                                 goto _exit2; else ;
  
#line 935 
  printk("%s: %s:%d frag = %d dma_pointer = 0x%llx",(char *)(& dev->name),"vxge_xmit",938,i,dma_pointer);
  
#line 940 
  txdl_priv->dma_buffers[j] = dma_pointer;
  
#line 941 
  tmp_15 = skb_frag_size((skb_frag_t const *)frag);
  
#line 941 
  ;
  
#line 941 
  tmp_16 = j;
  
#line 941 
  j += 1;
  
#line 941 
  ;
  
#line 941 
  ;
  
#line 941 
  ;
  
#line 941 
  vxge_hw_fifo_txdl_buffer_set(fifo_hw,dtr,(unsigned int)tmp_16,dma_pointer,tmp_15);
  
#line 943 
  frag += 1U;
  ldv_56064: 
#line 944 
  ;
  
#line 924 
  i += 1;
  ldv_56067: 
#line 925 
  ;
  
#line 924 
  if (i < frg_cnt) 
#line 926 
                   goto ldv_56066; else 
#line 929 
                                        goto ldv_56068;
  ldv_56068: 
#line 930 
  ;
  
#line 946 
  tmp_17 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 946 
  offload_type = (int)((struct skb_shared_info *)tmp_17)->gso_type;
  
#line 948 
  if ((offload_type & 17) != 0) {
    unsigned char *tmp_18;
    
#line 949 
    tmp_18 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 949 
    int mss = (int)((struct skb_shared_info *)tmp_18)->gso_size;
    
#line 950 
    if (mss != 0) {
      
#line 951 
      printk("%s: %s:%d mss = %d",(char *)(& dev->name),"vxge_xmit",952,mss);
      
#line 953 
      vxge_hw_fifo_txdl_mss_set(dtr,mss);
    }
    else 
#line 958 
         goto _exit1;
  }
  else ;
  
#line 962 
  if ((unsigned int)*((unsigned char *)skb + 145UL) == 6U) 
#line 963 
                                                           vxge_hw_fifo_txdl_cksum_set_bits(dtr,504403158265495552ULL); else ;
  
#line 968 
  vxge_hw_fifo_txdl_post(fifo_hw,dtr);
  
#line 970 
  printk("%s: %s:%d  Exiting...",(char *)(& dev->name),"vxge_xmit",971);
  
#line 972 
  __retres = NETDEV_TX_OK;
  
#line 972 
  goto return_label;
  _exit2: 
#line 974 
  ;
  
#line 975 
  printk("%s: pci_map_page failed",(char *)(& dev->name));
  _exit1: 
#line 976 
  ;
  
#line 977 
  j = 0;
  
#line 978 
  tmp_19 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 978 
  frag = & ((struct skb_shared_info *)tmp_19)->frags[0];
  
#line 981 
  tmp_20 = skb_headlen((struct sk_buff const *)skb);
  
#line 980 
  tmp_21 = j;
  
#line 980 
  j += 1;
  
#line 980 
  ;
  
#line 980 
  ;
  
#line 980 
  pci_unmap_single(fifo->pdev,txdl_priv->dma_buffers[tmp_21],(unsigned long)tmp_20,1);
  
#line 983 
  goto ldv_56072;
  ldv_56071: 
#line 984 
  ;
  
#line 985 
  tmp_22 = skb_frag_size((skb_frag_t const *)frag);
  
#line 984 
  ;
  
#line 984 
  ;
  
#line 984 
  pci_unmap_page(fifo->pdev,txdl_priv->dma_buffers[j],(unsigned long)tmp_22,1);
  
#line 986 
  frag += 1U;
  
#line 983 
  j += 1;
  ldv_56072: 
#line 984 
  ;
  
#line 983 
  if (j < i) 
#line 985 
             goto ldv_56071; else 
#line 988 
                                  goto ldv_56073;
  ldv_56073: 
#line 989 
  ;
  
#line 989 
  vxge_hw_fifo_txdl_free(fifo_hw,dtr);
  _exit0: 
#line 990 
  ;
  
#line 991 
  netif_tx_start_queue(fifo->txq);
  
#line 992 
  dev_kfree_skb_any(skb);
  
#line 994 
  __retres = NETDEV_TX_OK;
  return_label: 
#line 994 
                return __retres;
}


#line 1004  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_rx_term(void *dtrh, enum vxge_hw_rxd_state state, void *userdata)
{
  
#line 1006 
  struct vxge_ring *ring = (struct vxge_ring *)userdata;
  
#line 1008 
  struct vxge_rx_priv *rx_priv = vxge_hw_ring_rxd_private_get(dtrh);
  
#line 1010 
  printk("%s: %s:%d",(char *)(& (ring->ndev)->name),"vxge_rx_term",1011);
  
#line 1012 
  if (state != (unsigned int)VXGE_HW_RXD_STATE_POSTED) 
#line 1013 
                                                       goto return_label; else ;
  
#line 1015 
  pci_unmap_single(ring->pdev,rx_priv->data_dma,(unsigned long)rx_priv->data_size,2);
  
#line 1018 
  consume_skb(rx_priv->skb);
  
#line 1019 
  rx_priv->skb_data = (unsigned char *)0U;
  
#line 1021 
  printk("%s: %s:%d  Exiting...",(char *)(& (ring->ndev)->name),"vxge_rx_term",1023);
  return_label: 
#line 1022 
                return;
}


#line 1032  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_tx_term(void *dtrh, enum vxge_hw_txdl_state state, void *userdata)
{
  skb_frag_t *frag;
  int j;
  int frg_cnt;
  unsigned char *tmp_0;
  unsigned char *tmp_1;
  unsigned int tmp_2;
  int tmp_3;
  unsigned int tmp_4;
  int tmp_5;
  
#line 1034 
  struct vxge_fifo *fifo = (struct vxge_fifo *)userdata;
  
#line 1036 
  int i = 0;
  
#line 1037 
  struct vxge_tx_priv *txd_priv = vxge_hw_fifo_txdl_private_get(dtrh);
  
#line 1038 
  struct sk_buff *skb = txd_priv->skb;
  
#line 1040 
  printk("%s:%d","vxge_tx_term",1040);
  
#line 1042 
  if (state != (unsigned int)VXGE_HW_TXDL_STATE_POSTED) 
#line 1043 
                                                        goto return_label; else ;
  
#line 1047 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1047 
  frg_cnt = (int)((struct skb_shared_info *)tmp_0)->nr_frags;
  
#line 1048 
  tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1048 
  frag = & ((struct skb_shared_info *)tmp_1)->frags[0];
  
#line 1052 
  tmp_2 = skb_headlen((struct sk_buff const *)skb);
  
#line 1051 
  tmp_3 = i;
  
#line 1051 
  i += 1;
  
#line 1051 
  ;
  
#line 1051 
  ;
  
#line 1051 
  pci_unmap_single(fifo->pdev,txd_priv->dma_buffers[tmp_3],(unsigned long)tmp_2,1);
  
#line 1054 
  j = 0;
  
#line 1054 
  goto ldv_56096;
  ldv_56095: 
#line 1055 
  ;
  
#line 1056 
  tmp_4 = skb_frag_size((skb_frag_t const *)frag);
  
#line 1055 
  tmp_5 = i;
  
#line 1055 
  i += 1;
  
#line 1055 
  ;
  
#line 1055 
  ;
  
#line 1055 
  pci_unmap_page(fifo->pdev,txd_priv->dma_buffers[tmp_5],(unsigned long)tmp_4,1);
  
#line 1057 
  frag += 1U;
  
#line 1054 
  j += 1;
  ldv_56096: 
#line 1055 
  ;
  
#line 1054 
  if (j < frg_cnt) 
#line 1056 
                   goto ldv_56095; else 
#line 1059 
                                        goto ldv_56097;
  ldv_56097: 
#line 1060 
  ;
  
#line 1060 
  consume_skb(skb);
  
#line 1062 
  printk("%s:%d  Exiting...","vxge_tx_term",1063);
  return_label: 
#line 1063 
                return;
}


#line 1066  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_mac_list_del(struct vxge_vpath *vpath, struct macInfo *mac)
{
  int __retres;
  struct list_head *entry;
  struct list_head *next;
  
#line 1069 
  u64 del_mac = 0ULL;
  
#line 1070 
  u8 *mac_address = (u8 *)(& del_mac);
  
#line 1073 
  memcpy((void *)mac_address,(void const *)(& mac->macaddr),6UL);
  
#line 1075 
  entry = vpath->mac_addr_list.next;
  
#line 1075 
  next = entry->next;
  
#line 1075 
  goto ldv_56107;
  ldv_56106: 
#line 1076 
  ;
  
#line 1076 
  if (((struct vxge_mac_addrs *)entry)->macaddr == del_mac) {
    bool tmp;
    
#line 1077 
    list_del(entry);
    
#line 1078 
    kfree((void const *)entry);
    
#line 1079 
    vpath->mac_addr_cnt = (u16)((int)vpath->mac_addr_cnt - 1);
    
#line 1081 
    tmp = is_multicast_ether_addr((u8 const *)(& mac->macaddr));
    
#line 1081 
    if ((int)tmp != 0) 
#line 1082 
                       vpath->mcast_addr_cnt = (u16)((int)vpath->mcast_addr_cnt - 1); else ;
    
#line 1083 
    __retres = 1;
    
#line 1083 
    goto return_label;
  }
  else ;
  
#line 1075 
  entry = next;
  
#line 1075 
  next = entry->next;
  ldv_56107: 
#line 1076 
  ;
  
#line 1075 
  if (& vpath->mac_addr_list != entry) 
#line 1077 
                                       goto ldv_56106; else 
#line 1080 
                                                            goto ldv_56108;
  ldv_56108: 
#line 1081 
  ;
  
#line 1087 
  __retres = 0;
  return_label: 
#line 1087 
                return __retres;
}


#line 1092  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_del_mac_addr(struct vxgedev *vdev, struct macInfo *mac)
{
  struct vxge_vpath *vpath;
  
#line 1094 
  enum vxge_hw_status status = 0;
  
#line 1097 
  vpath = vdev->vpaths + mac->vpath_no;
  
#line 1098 
  status = vxge_hw_vpath_mac_addr_delete(vpath->handle,(u8 *)(& mac->macaddr),(u8 *)(& mac->macmask));
  
#line 1100 
  if (status != VXGE_HW_OK) 
#line 1101 
                            printk("DA config delete entry failed for vpath:%d",vpath->device_id); else 
                                                                    
#line 1105 
                                                                    vxge_mac_list_del(vpath,mac);
  
#line 1106 
  return status;
}


#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_set_multicast(struct net_device *dev)
{
  struct netdev_hw_addr *ha;
  struct vxgedev *vdev;
  int i;
  struct __vxge_hw_device *hldev;
  struct vxge_vpath *vpath;
  struct macInfo mac_info;
  struct vxge_mac_addrs *mac_entry;
  struct list_head *list_head;
  struct list_head *entry;
  struct list_head *next;
  int tmp_0;
  
#line 1124 
  int mcast_cnt = 0;
  
#line 1127 
  enum vxge_hw_status status = 0;
  
#line 1129 
  int vpath_idx = 0;
  
#line 1133 
  u8 *mac_address = (u8 *)0U;
  
#line 1135 
  printk("%s:%d","vxge_set_multicast",1136);
  
#line 1138 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)dev);
  
#line 1139 
  hldev = vdev->devh;
  
#line 1141 
  tmp_0 = is_vxge_card_up(vdev);
  
#line 1141 
  if ((long)(tmp_0 == 0) != 0L) 
#line 1142 
                                goto return_label; else ;
  
#line 1144 
  if ((dev->flags & 512U) != 0U && (unsigned int)vdev->all_multi_flg == 0U) {
    
#line 1145 
    i = 0;
    
#line 1145 
    goto ldv_56134;
    ldv_56133: 
#line 1146 
    ;
    
#line 1146 
    vpath = vdev->vpaths + i;
    
#line 1148 
    status = vxge_hw_vpath_mcast_enable(vpath->handle);
    
#line 1149 
    if (status != VXGE_HW_OK) 
#line 1150 
                              printk("failed to enable ",(int)status); else ;
    
#line 1152 
    vdev->all_multi_flg = (unsigned short)1U;
    
#line 1145 
    i += 1;
    ldv_56134: 
#line 1146 
    ;
    
#line 1145 
    if (vdev->no_of_vpath > i) 
#line 1147 
                               goto ldv_56133; else 
#line 1150 
                                                    goto ldv_56135;
    ldv_56135: 
#line 1151 
    ;
  }
  else 
    
#line 1154 
    if ((dev->flags & 512U) == 0U && (unsigned int)vdev->all_multi_flg != 0U) {
      
#line 1155 
      i = 0;
      
#line 1155 
      goto ldv_56137;
      ldv_56136: 
#line 1156 
      ;
      
#line 1156 
      vpath = vdev->vpaths + i;
      
#line 1158 
      status = vxge_hw_vpath_mcast_disable(vpath->handle);
      
#line 1159 
      if (status != VXGE_HW_OK) 
#line 1160 
                                printk("failed to disable ",(int)status); else ;
      
#line 1162 
      vdev->all_multi_flg = (unsigned short)0U;
      
#line 1155 
      i += 1;
      ldv_56137: 
#line 1156 
      ;
      
#line 1155 
      if (vdev->no_of_vpath > i) 
#line 1157 
                                 goto ldv_56136; else 
#line 1160 
                                                      goto ldv_56138;
      ldv_56138: 
#line 1161 
      ;
    }
    else ;
  
#line 1167 
  if (vdev->config.addr_learn_en == 0) {
    
#line 1168 
    i = 0;
    
#line 1168 
    goto ldv_56140;
    ldv_56139: 
#line 1169 
    ;
    
#line 1169 
    vpath = vdev->vpaths + i;
    
#line 1172 
    if ((dev->flags & 256U) != 0U) 
#line 1173 
                                   status = vxge_hw_vpath_promisc_enable(vpath->handle); else 
                                                                    
#line 1176 
                                                                    status = vxge_hw_vpath_promisc_disable(vpath->handle);
    
#line 1178 
    if (status != VXGE_HW_OK) {
      char *tmp_1;
      
#line 1179 
      ;
      
#line 1179 
      if ((dev->flags & 256U) != 0U) 
#line 1179 
                                     tmp_1 = (char *)"enable"; else 
#line 1179 
                                                                    tmp_1 = (char *)"disable";
      
#line 1179 
      printk("failed to %s promisc",tmp_1,(int)status);
    }
    else ;
    
#line 1168 
    i += 1;
    ldv_56140: 
#line 1169 
    ;
    
#line 1168 
    if (vdev->no_of_vpath > i) 
#line 1170 
                               goto ldv_56139; else 
#line 1173 
                                                    goto ldv_56141;
    ldv_56141: 
#line 1174 
    ;
  }
  else ;
  
#line 1185 
  memset((void *)(& mac_info),0,20UL);
  
#line 1187 
  if ((unsigned int)vdev->all_multi_flg == 0U && dev->mc.count != 0) {
    bool tmp_2;
    struct netdev_hw_addr *tmp_3;
    struct netdev_hw_addr *tmp_4;
    bool tmp_5;
    
#line 1188 
    mcast_cnt = (int)(vdev->vpaths)->mcast_addr_cnt;
    
#line 1189 
    list_head = & (vdev->vpaths)->mac_addr_list;
    
#line 1190 
    if (dev->mc.count + ((int)(vdev->vpaths)->mac_addr_cnt - mcast_cnt) > (vdev->vpaths)->max_mac_addr_cnt) 
      
#line 1193 
      goto _set_all_mcast; else ;
    
#line 1196 
    i = 0;
    
#line 1196 
    goto ldv_56150;
    ldv_56149: 
#line 1197 
    ;
    
#line 1197 
    entry = list_head->next;
    
#line 1197 
    next = entry->next;
    
#line 1197 
    goto ldv_56147;
    ldv_56146: 
#line 1198 
    ;
    
#line 1198 
    mac_entry = (struct vxge_mac_addrs *)entry;
    
#line 1200 
    mac_address = (u8 *)(& mac_entry->macaddr);
    
#line 1201 
    memcpy((void *)(& mac_info.macaddr),(void const *)mac_address,6UL);
    
#line 1203 
    tmp_2 = is_multicast_ether_addr((u8 const *)(& mac_info.macaddr));
    
#line 1203 
    if ((int)tmp_2 != 0) {
      
#line 1204 
      vpath_idx = 0;
      
#line 1204 
      goto ldv_56144;
      ldv_56143: 
#line 1205 
      ;
      
#line 1207 
      mac_info.vpath_no = (unsigned int)vpath_idx;
      
#line 1208 
      status = vxge_del_mac_addr(vdev,& mac_info);
      
#line 1206 
      vpath_idx += 1;
      ldv_56144: 
#line 1207 
      ;
      
#line 1204 
      if (vdev->no_of_vpath > vpath_idx) 
#line 1206 
                                         goto ldv_56143; else 
#line 1209 
                                                              goto ldv_56145;
      ldv_56145: 
#line 1210 
      ;
    }
    else ;
    
#line 1197 
    entry = next;
    
#line 1197 
    next = entry->next;
    ldv_56147: 
#line 1198 
    ;
    
#line 1197 
    if (entry != list_head) 
#line 1199 
                            goto ldv_56146; else 
#line 1202 
                                                 goto ldv_56148;
    ldv_56148: 
#line 1203 
    ;
    
#line 1196 
    i += 1;
    ldv_56150: 
#line 1197 
    ;
    
#line 1196 
    if (i < mcast_cnt) 
#line 1198 
                       goto ldv_56149; else 
#line 1201 
                                            goto ldv_56151;
    ldv_56151: 
#line 1202 
    ;
    {
      
#line 1217 
      struct list_head const *__mptr = (struct list_head const *)dev->mc.list.next;
      
#line 1217 
      tmp_3 = (struct netdev_hw_addr *)__mptr;
    }
    
#line 1217 
    ha = tmp_3;
    
#line 1217 
    goto ldv_56160;
    ldv_56159: 
#line 1218 
    ;
    
#line 1218 
    memcpy((void *)(& mac_info.macaddr),(void const *)(& ha->addr),6UL);
    
#line 1219 
    vpath_idx = 0;
    
#line 1219 
    goto ldv_56157;
    ldv_56156: 
#line 1220 
    ;
    
#line 1221 
    mac_info.vpath_no = (unsigned int)vpath_idx;
    
#line 1222 
    mac_info.state = VXGE_LL_MAC_ADDR_IN_DA_TABLE;
    
#line 1223 
    status = vxge_add_mac_addr(vdev,& mac_info);
    
#line 1224 
    if (status != VXGE_HW_OK) {
      
#line 1225 
      printk("%s:%d Setting individual","vxge_set_multicast",1228);
      
#line 1229 
      goto _set_all_mcast;
    }
    else ;
    
#line 1220 
    vpath_idx += 1;
    ldv_56157: 
#line 1221 
    ;
    
#line 1219 
    if (vdev->no_of_vpath > vpath_idx) 
#line 1221 
                                       goto ldv_56156; else 
#line 1224 
                                                            goto ldv_56158;
    ldv_56158: 
#line 1225 
    ;
    {
      
#line 1217 
      struct list_head const *__mptr_0 = (struct list_head const *)ha->list.next;
      
#line 1217 
      tmp_4 = (struct netdev_hw_addr *)__mptr_0;
    }
    
#line 1217 
    ha = tmp_4;
    ldv_56160: 
#line 1219 
    ;
    
#line 1217 
    if (& ha->list != & dev->mc.list) 
#line 1219 
                                      goto ldv_56159; else 
#line 1222 
                                                           goto ldv_56161;
    ldv_56161: 
#line 1223 
    ;
    
#line 1234 
    goto return_label;
    _set_all_mcast: 
#line 1235 
    ;
    
#line 1236 
    mcast_cnt = (int)(vdev->vpaths)->mcast_addr_cnt;
    
#line 1238 
    i = 0;
    
#line 1238 
    goto ldv_56169;
    ldv_56168: 
#line 1239 
    ;
    
#line 1239 
    entry = list_head->next;
    
#line 1239 
    next = entry->next;
    
#line 1239 
    goto ldv_56164;
    ldv_56163: 
#line 1240 
    ;
    
#line 1240 
    mac_entry = (struct vxge_mac_addrs *)entry;
    
#line 1242 
    mac_address = (u8 *)(& mac_entry->macaddr);
    
#line 1243 
    memcpy((void *)(& mac_info.macaddr),(void const *)mac_address,6UL);
    
#line 1245 
    tmp_5 = is_multicast_ether_addr((u8 const *)(& mac_info.macaddr));
    
#line 1245 
    if ((int)tmp_5 != 0) 
#line 1246 
                         goto ldv_56162; else ;
    
#line 1239 
    entry = next;
    
#line 1239 
    next = entry->next;
    ldv_56164: 
#line 1240 
    ;
    
#line 1239 
    if (entry != list_head) 
#line 1241 
                            goto ldv_56163; else 
#line 1244 
                                                 goto ldv_56162;
    ldv_56162: 
#line 1245 
    ;
    
#line 1249 
    vpath_idx = 0;
    
#line 1249 
    goto ldv_56166;
    ldv_56165: 
#line 1250 
    ;
    
#line 1251 
    mac_info.vpath_no = (unsigned int)vpath_idx;
    
#line 1252 
    status = vxge_del_mac_addr(vdev,& mac_info);
    
#line 1250 
    vpath_idx += 1;
    ldv_56166: 
#line 1251 
    ;
    
#line 1249 
    if (vdev->no_of_vpath > vpath_idx) 
#line 1251 
                                       goto ldv_56165; else 
#line 1254 
                                                            goto ldv_56167;
    ldv_56167: 
#line 1255 
    ;
    
#line 1238 
    i += 1;
    ldv_56169: 
#line 1239 
    ;
    
#line 1238 
    if (i < mcast_cnt) 
#line 1240 
                       goto ldv_56168; else 
#line 1243 
                                            goto ldv_56170;
    ldv_56170: 
#line 1244 
    ;
    
#line 1257 
    i = 0;
    
#line 1257 
    goto ldv_56172;
    ldv_56171: 
#line 1258 
    ;
    
#line 1258 
    vpath = vdev->vpaths + i;
    
#line 1261 
    status = vxge_hw_vpath_mcast_enable(vpath->handle);
    
#line 1262 
    if (status != VXGE_HW_OK) 
#line 1263 
                              printk("%s:%d Enabling all multicasts failed","vxge_set_multicast",1265); else ;
    
#line 1267 
    vdev->all_multi_flg = (unsigned short)1U;
    
#line 1257 
    i += 1;
    ldv_56172: 
#line 1258 
    ;
    
#line 1257 
    if (vdev->no_of_vpath > i) 
#line 1259 
                               goto ldv_56171; else 
#line 1262 
                                                    goto ldv_56173;
    ldv_56173: 
#line 1263 
    ;
    
#line 1269 
    dev->flags |= 512U;
  }
  else ;
  
#line 1272 
  printk("%s:%d  Exiting...","vxge_set_multicast",1273);
  return_label: 
#line 1273 
                return;
}


#line 1282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_set_mac_addr(struct net_device *dev, void *p)
{
  int __retres;
  struct vxgedev *vdev;
  struct __vxge_hw_device *hldev;
  struct macInfo mac_info_new;
  struct macInfo mac_info_old;
  int tmp_1;
  bool tmp_0;
  int tmp_2;
  
#line 1284 
  struct sockaddr *addr = (struct sockaddr *)p;
  
#line 1287 
  enum vxge_hw_status status = 0;
  
#line 1289 
  int vpath_idx = 0;
  
#line 1291 
  printk("%s:%d","vxge_set_mac_addr",1291);
  
#line 1293 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)dev);
  
#line 1294 
  hldev = vdev->devh;
  
#line 1296 
  tmp_0 = is_valid_ether_addr((u8 const *)(& addr->sa_data));
  
#line 1296 
  if (tmp_0) 
#line 1296 
             tmp_1 = 0; else 
#line 1296 
                             tmp_1 = 1;
  
#line 1296 
  if (tmp_1) {
    
#line 1297 
    __retres = -22;
    
#line 1297 
    goto return_label;
  }
  else ;
  
#line 1299 
  memset((void *)(& mac_info_new),0,20UL);
  
#line 1300 
  memset((void *)(& mac_info_old),0,20UL);
  
#line 1302 
  printk("%s:%d  Exiting...","vxge_set_mac_addr",1303);
  
#line 1306 
  memcpy((void *)(& mac_info_old.macaddr),(void const *)dev->dev_addr,(unsigned long)dev->addr_len);
  
#line 1309 
  memcpy((void *)(& mac_info_new.macaddr),(void const *)(& addr->sa_data),(unsigned long)dev->addr_len);
  
#line 1313 
  vpath_idx = 0;
  
#line 1313 
  goto ldv_56189;
  ldv_56188: 
#line 1314 
  ;
  {
    
#line 1314 
    struct vxge_vpath *vpath = vdev->vpaths + vpath_idx;
    
#line 1315 
    if (vpath->is_open == 0) {
      
#line 1319 
      vxge_mac_list_del(vpath,& mac_info_old);
      
#line 1323 
      vxge_mac_list_add(vpath,& mac_info_new);
      
#line 1325 
      goto ldv_56187;
    }
    else ;
    
#line 1328 
    mac_info_old.vpath_no = (unsigned int)vpath_idx;
    
#line 1329 
    status = vxge_del_mac_addr(vdev,& mac_info_old);
  }
  ldv_56187: 
#line 1331 
  ;
  
#line 1313 
  vpath_idx += 1;
  ldv_56189: 
#line 1314 
  ;
  
#line 1313 
  if (vdev->no_of_vpath > vpath_idx) 
#line 1315 
                                     goto ldv_56188; else 
#line 1318 
                                                          goto ldv_56190;
  ldv_56190: 
#line 1319 
  ;
  
#line 1332 
  tmp_2 = is_vxge_card_up(vdev);
  
#line 1332 
  if ((long)(tmp_2 == 0) != 0L) {
    
#line 1333 
    memcpy((void *)dev->dev_addr,(void const *)(& addr->sa_data),(unsigned long)dev->addr_len);
    
#line 1334 
    __retres = 0;
    
#line 1334 
    goto return_label;
  }
  else ;
  
#line 1338 
  vpath_idx = 0;
  
#line 1338 
  goto ldv_56192;
  ldv_56191: 
#line 1339 
  ;
  
#line 1339 
  mac_info_new.vpath_no = (unsigned int)vpath_idx;
  
#line 1340 
  mac_info_new.state = VXGE_LL_MAC_ADDR_IN_DA_TABLE;
  
#line 1341 
  status = vxge_add_mac_addr(vdev,& mac_info_new);
  
#line 1342 
  if (status != VXGE_HW_OK) {
    
#line 1343 
    __retres = -22;
    
#line 1343 
    goto return_label;
  }
  else ;
  
#line 1338 
  vpath_idx += 1;
  ldv_56192: 
#line 1339 
  ;
  
#line 1338 
  if (vdev->no_of_vpath > vpath_idx) 
#line 1340 
                                     goto ldv_56191; else 
#line 1343 
                                                          goto ldv_56193;
  ldv_56193: 
#line 1344 
  ;
  
#line 1346 
  memcpy((void *)dev->dev_addr,(void const *)(& addr->sa_data),(unsigned long)dev->addr_len);
  
#line 1348 
  __retres = (int)status;
  return_label: 
#line 1348 
                return __retres;
}


#line 1358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_vpath_intr_enable(struct vxgedev *vdev, int vp_id)
{
  
#line 1360 
  struct vxge_vpath *vpath = vdev->vpaths + vp_id;
  
#line 1361 
  int msix_id = 0;
  
#line 1362 
  int tim_msix_id[4U] = {0, 1, 0, 0};
  
#line 1363 
  int alarm_msix_id = 2;
  
#line 1365 
  vxge_hw_vpath_intr_enable(vpath->handle);
  
#line 1367 
  if (vdev->config.intr_type == 0) 
#line 1368 
                                   vxge_hw_vpath_inta_unmask_tx_rx(vpath->handle);
  else {
    
#line 1370 
    vxge_hw_vpath_msix_set(vpath->handle,(int *)(& tim_msix_id),alarm_msix_id);
    
#line 1373 
    msix_id = vpath->device_id * 4;
    
#line 1374 
    vxge_hw_vpath_msix_unmask(vpath->handle,msix_id);
    
#line 1375 
    vxge_hw_vpath_msix_unmask(vpath->handle,msix_id + 1);
    
#line 1378 
    msix_id = (int)((((vpath->handle)->vpath)->hldev)->first_vp_id * 4U + (unsigned int)alarm_msix_id);
    
#line 1380 
    vxge_hw_vpath_msix_unmask(vpath->handle,msix_id);
  }
  
#line 1382 
  return;
}


#line 1391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_vpath_intr_disable(struct vxgedev *vdev, int vp_id)
{
  struct __vxge_hw_device *hldev;
  int msix_id;
  
#line 1393 
  struct vxge_vpath *vpath = vdev->vpaths + vp_id;
  
#line 1397 
  hldev = (struct __vxge_hw_device *)pci_get_drvdata(vdev->pdev);
  
#line 1399 
  vxge_hw_vpath_wait_receive_idle(hldev,(unsigned int)vpath->device_id);
  
#line 1401 
  vxge_hw_vpath_intr_disable(vpath->handle);
  
#line 1403 
  if (vdev->config.intr_type == 0) 
#line 1404 
                                   vxge_hw_vpath_inta_mask_tx_rx(vpath->handle);
  else {
    
#line 1406 
    msix_id = vpath->device_id * 4;
    
#line 1407 
    vxge_hw_vpath_msix_mask(vpath->handle,msix_id);
    
#line 1408 
    vxge_hw_vpath_msix_mask(vpath->handle,msix_id + 1);
    
#line 1411 
    msix_id = (int)((((vpath->handle)->vpath)->hldev)->first_vp_id * 4U + 2U);
    
#line 1413 
    vxge_hw_vpath_msix_mask(vpath->handle,msix_id);
  }
  
#line 1415 
  return;
}


#line 1419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_search_mac_addr_in_da_table(struct vxge_vpath *vpath, struct macInfo *mac)
{
  enum vxge_hw_status __retres;
  unsigned char macmask[6U];
  unsigned char macaddr[6U];
  int tmp_0;
  bool tmp;
  
#line 1421 
  enum vxge_hw_status status = 0;
  
#line 1425 
  status = vxge_hw_vpath_mac_addr_get(vpath->handle,(u8 *)(& macaddr),(u8 *)(& macmask));
  
#line 1427 
  if (status != VXGE_HW_OK) {
    
#line 1428 
    printk("DA config list entry failed for vpath:%d",vpath->device_id);
    
#line 1431 
    __retres = status;
    
#line 1431 
    goto return_label;
  }
  else ;
  
#line 1434 
  goto ldv_56218;
  ldv_56217: 
#line 1435 
  ;
  
#line 1435 
  status = vxge_hw_vpath_mac_addr_get_next(vpath->handle,(u8 *)(& macaddr),(u8 *)(& macmask));
  
#line 1437 
  if (status != VXGE_HW_OK) 
#line 1438 
                            goto ldv_56216; else ;
  ldv_56218: 
#line 1439 
  ;
  
#line 1434 
  tmp = ether_addr_equal((u8 const *)(& mac->macaddr),(u8 const *)(& macaddr));
  
#line 1434 
  if (tmp) 
#line 1434 
           tmp_0 = 0; else 
#line 1434 
                           tmp_0 = 1;
  
#line 1434 
  if (tmp_0) 
#line 1436 
             goto ldv_56217; else 
#line 1439 
                                  goto ldv_56216;
  ldv_56216: 
#line 1440 
  ;
  
#line 1441 
  __retres = status;
  return_label: 
#line 1441 
                return __retres;
}


#line 1445  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_restore_vpath_mac_addr(struct vxge_vpath *vpath)
{
  struct macInfo mac_info;
  struct list_head *entry;
  struct list_head *next;
  
#line 1447 
  enum vxge_hw_status status = 0;
  
#line 1449 
  u8 *mac_address = (u8 *)0U;
  
#line 1452 
  memset((void *)(& mac_info),0,20UL);
  
#line 1454 
  if (vpath->is_open != 0) {
    
#line 1455 
    entry = vpath->mac_addr_list.next;
    
#line 1455 
    next = entry->next;
    
#line 1455 
    goto ldv_56228;
    ldv_56227: 
#line 1456 
    ;
    
#line 1456 
    mac_address = (u8 *)(& ((struct vxge_mac_addrs *)entry)->macaddr);
    
#line 1459 
    memcpy((void *)(& mac_info.macaddr),(void const *)mac_address,6UL);
    
#line 1460 
    ((struct vxge_mac_addrs *)entry)->state = VXGE_LL_MAC_ADDR_IN_DA_TABLE;
    
#line 1463 
    status = vxge_search_mac_addr_in_da_table(vpath,& mac_info);
    
#line 1465 
    if (status != VXGE_HW_OK) {
      
#line 1467 
      status = vxge_hw_vpath_mac_addr_add(vpath->handle,(u8 *)(& mac_info.macaddr),(u8 *)(& mac_info.macmask),(enum vxge_hw_vpath_mac_addr_add_mode)VXGE_HW_VPATH_MAC_ADDR_ADD_DUPLICATE);
      
#line 1471 
      if (status != VXGE_HW_OK) {
        
#line 1472 
        printk("DA add entry failed for vpath:%d",vpath->device_id);
        
#line 1476 
        ((struct vxge_mac_addrs *)entry)->state = VXGE_LL_MAC_ADDR_IN_LIST;
      }
      else ;
    }
    else ;
    
#line 1455 
    entry = next;
    
#line 1455 
    next = entry->next;
    ldv_56228: 
#line 1456 
    ;
    
#line 1455 
    if (& vpath->mac_addr_list != entry) 
#line 1457 
                                         goto ldv_56227; else 
#line 1460 
                                                              goto ldv_56229;
    ldv_56229: 
#line 1461 
    ;
  }
  else ;
  
#line 1482 
  return status;
}


#line 1487  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_restore_vpath_vid_table(struct vxge_vpath *vpath)
{
  enum vxge_hw_status __retres;
  u16 vid;
  unsigned long tmp;
  unsigned long tmp_0;
  
#line 1489 
  enum vxge_hw_status status = 0;
  
#line 1490 
  struct vxgedev *vdev = vpath->vdev;
  
#line 1493 
  if (vpath->is_open == 0) {
    
#line 1494 
    __retres = status;
    
#line 1494 
    goto return_label;
  }
  else ;
  
#line 1496 
  tmp = find_first_bit((unsigned long const *)(& vdev->active_vlans),4096UL);
  
#line 1496 
  vid = (unsigned short)tmp;
  
#line 1496 
  goto ldv_56237;
  ldv_56236: 
#line 1497 
  ;
  
#line 1497 
  status = vxge_hw_vpath_vid_add(vpath->handle,(unsigned long long)vid);
  
#line 1496 
  tmp_0 = find_next_bit((unsigned long const *)(& vdev->active_vlans),4096UL,(unsigned long)((int)vid + 1));
  
#line 1496 
  vid = (unsigned short)tmp_0;
  ldv_56237: 
#line 1497 
  ;
  
#line 1496 
  if ((unsigned int)vid <= 4095U) 
#line 1498 
                                  goto ldv_56236; else 
#line 1501 
                                                       goto ldv_56238;
  ldv_56238: 
#line 1502 
  ;
  
#line 1499 
  __retres = status;
  return_label: 
#line 1499 
                return __retres;
}


#line 1509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_reset_vpath(struct vxgedev *vdev, int vp_id)
{
  int __retres;
  int tmp;
  int tmp_0;
  bool tmp_4;
  
#line 1511 
  enum vxge_hw_status status = 0;
  
#line 1512 
  struct vxge_vpath *vpath = vdev->vpaths + vp_id;
  
#line 1513 
  int ret = 0;
  
#line 1516 
  tmp = is_vxge_card_up(vdev);
  
#line 1516 
  if ((long)(tmp == 0) != 0L) {
    
#line 1517 
    __retres = 0;
    
#line 1517 
    goto return_label;
  }
  else ;
  
#line 1520 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vdev->state));
  
#line 1520 
  if (tmp_0 != 0) {
    
#line 1521 
    __retres = 0;
    
#line 1521 
    goto return_label;
  }
  else ;
  
#line 1523 
  if (vpath->handle != (struct __vxge_hw_vpath_handle *)0) {
    enum vxge_hw_status tmp_3;
    
#line 1524 
    tmp_3 = vxge_hw_vpath_reset(vpath->handle);
    
#line 1524 
    if (tmp_3 == VXGE_HW_OK) {
      int tmp_1;
      
#line 1525 
      tmp_1 = is_vxge_card_up(vdev);
      
#line 1525 
      if (tmp_1 != 0) {
        enum vxge_hw_status tmp_2;
        
#line 1525 
        tmp_2 = vxge_hw_vpath_recover_from_reset(vpath->handle);
        
#line 1525 
        if (tmp_2 != VXGE_HW_OK) {
          
#line 1528 
          printk("vxge_hw_vpath_recover_from_reset",vp_id);
          
#line 1531 
          __retres = (int)status;
          
#line 1531 
          goto return_label;
        }
        else ;
      }
      else ;
    }
    else {
      
#line 1534 
      printk("vxge_hw_vpath_reset failed for",vp_id);
      
#line 1537 
      __retres = (int)status;
      
#line 1537 
      goto return_label;
    }
  }
  else {
    
#line 1540 
    __retres = 1;
    
#line 1540 
    goto return_label;
  }
  
#line 1542 
  vxge_restore_vpath_mac_addr(vpath);
  
#line 1543 
  vxge_restore_vpath_vid_table(vpath);
  
#line 1546 
  vxge_hw_vpath_bcast_enable(vpath->handle);
  
#line 1549 
  if ((unsigned int)vdev->all_multi_flg != 0U) {
    
#line 1550 
    status = vxge_hw_vpath_mcast_enable(vpath->handle);
    
#line 1551 
    if (status != VXGE_HW_OK) 
#line 1552 
                              printk("%s:%d Enabling multicast failed","vxge_reset_vpath",1554); else ;
  }
  else ;
  
#line 1558 
  vxge_vpath_intr_enable(vdev,vp_id);
  
#line 1559 
  ldv_inline_asm();
  
#line 1563 
  vxge_hw_vpath_enable(vpath->handle);
  
#line 1564 
  ldv_inline_asm();
  
#line 1566 
  vxge_hw_vpath_rx_doorbell_init(vpath->handle);
  
#line 1567 
  vpath->ring.last_status = VXGE_HW_OK;
  
#line 1570 
  set_bit((long)vp_id,(unsigned long volatile *)(& vdev->vp_reset));
  
#line 1573 
  tmp_4 = netif_tx_queue_stopped((struct netdev_queue const *)vpath->fifo.txq);
  
#line 1573 
  if ((int)tmp_4 != 0) 
#line 1574 
                       netif_tx_wake_queue(vpath->fifo.txq); else ;
  
#line 1576 
  __retres = ret;
  return_label: 
#line 1576 
                return __retres;
}


#line 1580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_config_ci_for_tti_rti(struct vxgedev *vdev)
{
  
#line 1582 
  int i = 0;
  
#line 1585 
  if (vdev->config.intr_type == 2) {
    
#line 1586 
    i = 0;
    
#line 1586 
    goto ldv_56253;
    ldv_56252: 
#line 1587 
    ;
    {
      struct __vxge_hw_ring *hw_ring;
      
#line 1589 
      hw_ring = (vdev->vpaths + i)->ring.handle;
      
#line 1590 
      vxge_hw_vpath_dynamic_rti_ci_set(hw_ring);
    }
    
#line 1586 
    i += 1;
    ldv_56253: 
#line 1587 
    ;
    
#line 1586 
    if (vdev->no_of_vpath > i) 
#line 1588 
                               goto ldv_56252; else 
#line 1591 
                                                    goto ldv_56254;
    ldv_56254: 
#line 1592 
    ;
  }
  else ;
  
#line 1595 
  i = 0;
  
#line 1595 
  goto ldv_56258;
  ldv_56257: 
#line 1596 
  ;
  {
    
#line 1596 
    struct __vxge_hw_fifo *hw_fifo = (vdev->vpaths + i)->fifo.handle;
    
#line 1597 
    vxge_hw_vpath_tti_ci_set(hw_fifo);
    
#line 1602 
    if (vdev->config.intr_type == 0 && i == 0) 
#line 1603 
                                               goto ldv_56256; else ;
  }
  
#line 1595 
  i += 1;
  ldv_56258: 
#line 1596 
  ;
  
#line 1595 
  if (vdev->no_of_vpath > i) 
#line 1597 
                             goto ldv_56257; else 
#line 1600 
                                                  goto ldv_56256;
  ldv_56256: 
#line 1601 
  ;
  
#line 1606 
  return;
}


#line 1609  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int do_vxge_reset(struct vxgedev *vdev, int event)
{
  int __retres;
  enum vxge_hw_status status;
  int vp_id;
  int i;
  
#line 1612 
  int ret = 0;
  
#line 1614 
  printk("%s:%d","do_vxge_reset",1614);
  
#line 1616 
  if ((unsigned int)event + 4294967294U <= 1U) {
    int tmp;
    int tmp_0;
    
#line 1618 
    tmp = is_vxge_card_up(vdev);
    
#line 1618 
    if ((long)(tmp == 0) != 0L) {
      
#line 1619 
      __retres = 0;
      
#line 1619 
      goto return_label;
    }
    else ;
    
#line 1622 
    tmp_0 = test_and_set_bit(0L,(unsigned long volatile *)(& vdev->state));
    
#line 1622 
    if (tmp_0 != 0) {
      
#line 1623 
      __retres = 0;
      
#line 1623 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1626 
  if (event == 2) {
    int tmp_3;
    
#line 1627 
    netif_carrier_off(vdev->ndev);
    
#line 1630 
    vp_id = 0;
    
#line 1630 
    goto ldv_56272;
    ldv_56271: 
#line 1631 
    ;
    
#line 1631 
    goto ldv_56269;
    ldv_56268: 
#line 1632 
    ;
    
#line 1632 
    msleep(50U);
    ldv_56269: 
#line 1633 
    ;
    
#line 1631 
    if (0 != 0) {
      int tmp_1;
      
#line 1631 
      tmp_1 = constant_test_bit((long)vp_id,(unsigned long const volatile *)(& vdev->vp_reset));
      
#line 1631 
      tmp_3 = tmp_1 != 0;
    }
    else {
      int tmp_2;
      
#line 1631 
      tmp_2 = variable_test_bit((long)vp_id,(unsigned long const volatile *)(& vdev->vp_reset));
      
#line 1631 
      tmp_3 = tmp_2 != 0;
    }
    
#line 1631 
    if (tmp_3) 
#line 1633 
               goto ldv_56268; else 
#line 1636 
                                    goto ldv_56270;
    ldv_56270: 
#line 1637 
    ;
    
#line 1630 
    vp_id += 1;
    ldv_56272: 
#line 1631 
    ;
    
#line 1630 
    if (vdev->no_of_vpath > vp_id) 
#line 1632 
                                   goto ldv_56271; else 
#line 1635 
                                                        goto ldv_56273;
    ldv_56273: 
#line 1636 
    ;
    
#line 1635 
    netif_carrier_on(vdev->ndev);
    
#line 1638 
    if ((long)(vdev->exec_mode != 0) != 0L) {
      
#line 1639 
      printk("%s: execution mode is debug, returning..",(char *)(& (vdev->ndev)->name));
      
#line 1642 
      set_bit(1L,(unsigned long volatile *)(& vdev->state));
      
#line 1643 
      netif_tx_stop_all_queues(vdev->ndev);
      
#line 1644 
      __retres = 0;
      
#line 1644 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1648 
  if (event == 2) {
    
#line 1649 
    vxge_hw_device_wait_receive_idle(vdev->devh);
    
#line 1650 
    vxge_hw_device_intr_disable(vdev->devh);
    
#line 1652 
    switch ((unsigned int)vdev->cric_err_event) {
      case (unsigned int)0: 
#line 1653 
      ;
      
#line 1654 
      netif_tx_stop_all_queues(vdev->ndev);
      
#line 1655 
      printk("fatal: %s: Disabling device due to",(char *)(& (vdev->ndev)->name));
      
#line 1659 
      ret = -1;
      
#line 1660 
      goto out;
      case (unsigned int)1: 
#line 1661 
      ;
      
#line 1662 
      goto ldv_56277;
      case (unsigned int)2: 
#line 1663 
      ;
      case (unsigned int)3: 
#line 1664 
      ;
      case (unsigned int)4: 
#line 1665 
      ;
      case (unsigned int)5: 
#line 1666 
      ;
      case (unsigned int)6: 
#line 1667 
      ;
      case (unsigned int)7: 
#line 1668 
      ;
      
#line 1669 
      ret = -1;
      
#line 1670 
      goto out;
      case (unsigned int)8: 
#line 1671 
      ;
      case (unsigned int)9: 
#line 1672 
      ;
      
#line 1673 
      goto ldv_56277;
      case (unsigned int)10: 
#line 1674 
      ;
      
#line 1675 
      netif_tx_stop_all_queues(vdev->ndev);
      
#line 1676 
      printk("fatal: %s: Disabling device due to",(char *)(& (vdev->ndev)->name));
      
#line 1682 
      ret = -1;
      
#line 1683 
      goto out;
      case (unsigned int)11: 
#line 1684 
      ;
      
#line 1685 
      netif_tx_stop_all_queues(vdev->ndev);
      
#line 1686 
      printk("fatal: %s: Disabling device due to",(char *)(& (vdev->ndev)->name));
      
#line 1690 
      ret = -1;
      
#line 1691 
      goto out;
      case (unsigned int)12: 
#line 1692 
      ;
      case (unsigned int)13: 
#line 1693 
      ;
      
#line 1694 
      ret = -1;
      
#line 1695 
      goto out;
      case (unsigned int)14: 
#line 1696 
      ;
      
#line 1697 
      netif_tx_stop_all_queues(vdev->ndev);
      
#line 1698 
      printk("fatal: %s: Disabling device due to",(char *)(& (vdev->ndev)->name));
      
#line 1702 
      ret = -1;
      
#line 1703 
      goto out;
      default: 
#line 1704 
      ;
      
#line 1705 
      goto ldv_56277;
    }
    ldv_56277: 
#line 1708 
    ;
  }
  else ;
  
#line 1710 
  if ((unsigned int)event + 4294967294U <= 1U) 
#line 1711 
                                               netif_tx_stop_all_queues(vdev->ndev); else ;
  
#line 1713 
  if (event == 2) {
    
#line 1714 
    status = vxge_reset_all_vpaths(vdev);
    
#line 1715 
    if (status != VXGE_HW_OK) {
      
#line 1716 
      printk("fatal: %s: can not reset vpaths",(char *)(& (vdev->ndev)->name));
      
#line 1719 
      ret = -1;
      
#line 1720 
      goto out;
    }
    else ;
  }
  else ;
  
#line 1724 
  if (event == 4) {
    
#line 1725 
    i = 0;
    
#line 1725 
    goto ldv_56293;
    ldv_56292: 
#line 1726 
    ;
    
#line 1726 
    if ((vdev->vpaths + i)->handle != (struct __vxge_hw_vpath_handle *)0) {
      enum vxge_hw_status tmp_4;
      
#line 1727 
      tmp_4 = vxge_hw_vpath_recover_from_reset((vdev->vpaths + i)->handle);
      
#line 1727 
      if (tmp_4 != VXGE_HW_OK) {
        
#line 1730 
        printk("vxge_hw_vpath_recover_",i);
        
#line 1734 
        ret = -1;
        
#line 1735 
        goto out;
      }
      else ;
    }
    else {
      
#line 1738 
      printk("vxge_hw_vpath_reset failed for ",i);
      
#line 1741 
      ret = -1;
      
#line 1742 
      goto out;
    }
    
#line 1725 
    i += 1;
    ldv_56293: 
#line 1726 
    ;
    
#line 1725 
    if (vdev->no_of_vpath > i) 
#line 1727 
                               goto ldv_56292; else 
#line 1730 
                                                    goto ldv_56294;
    ldv_56294: 
#line 1731 
    ;
  }
  else ;
  
#line 1746 
  if (event == 2 || event == 4) {
    
#line 1748 
    vp_id = 0;
    
#line 1748 
    goto ldv_56296;
    ldv_56295: 
#line 1749 
    ;
    
#line 1749 
    vxge_restore_vpath_mac_addr(vdev->vpaths + vp_id);
    
#line 1750 
    vxge_restore_vpath_vid_table(vdev->vpaths + vp_id);
    
#line 1748 
    vp_id += 1;
    ldv_56296: 
#line 1749 
    ;
    
#line 1748 
    if (vdev->no_of_vpath > vp_id) 
#line 1750 
                                   goto ldv_56295; else 
#line 1753 
                                                        goto ldv_56297;
    ldv_56297: 
#line 1754 
    ;
    
#line 1754 
    i = 0;
    
#line 1754 
    goto ldv_56299;
    ldv_56298: 
#line 1755 
    ;
    
#line 1755 
    vxge_vpath_intr_enable(vdev,i);
    
#line 1754 
    i += 1;
    ldv_56299: 
#line 1755 
    ;
    
#line 1754 
    if (vdev->no_of_vpath > i) 
#line 1756 
                               goto ldv_56298; else 
#line 1759 
                                                    goto ldv_56300;
    ldv_56300: 
#line 1760 
    ;
    
#line 1757 
    vxge_hw_device_intr_enable(vdev->devh);
    
#line 1758 
    ldv_inline_asm();
    
#line 1762 
    set_bit(1L,(unsigned long volatile *)(& vdev->state));
    
#line 1765 
    i = 0;
    
#line 1765 
    goto ldv_56302;
    ldv_56301: 
#line 1766 
    ;
    
#line 1766 
    vxge_hw_vpath_enable((vdev->vpaths + i)->handle);
    
#line 1767 
    ldv_inline_asm();
    
#line 1768 
    vxge_hw_vpath_rx_doorbell_init((vdev->vpaths + i)->handle);
    
#line 1765 
    i += 1;
    ldv_56302: 
#line 1766 
    ;
    
#line 1765 
    if (vdev->no_of_vpath > i) 
#line 1767 
                               goto ldv_56301; else 
#line 1770 
                                                    goto ldv_56303;
    ldv_56303: 
#line 1771 
    ;
    
#line 1771 
    netif_tx_wake_all_queues(vdev->ndev);
  }
  else ;
  
#line 1775 
  vxge_config_ci_for_tti_rti(vdev);
  out: 
#line 1777 
  ;
  
#line 1778 
  printk("%s:%d  Exiting...","do_vxge_reset",1779);
  
#line 1782 
  if (event == 2 || event == 4) 
#line 1783 
                                set_bit(0L,(unsigned long volatile *)(& vdev->state)); else ;
  
#line 1784 
  __retres = ret;
  return_label: 
#line 1784 
                return __retres;
}


#line 1793  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_reset(struct work_struct *work)
{
  struct vxgedev *tmp;
  int tmp_1;
  bool tmp_0;
  {
    
#line 1795 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 1795 
    tmp = (struct vxgedev *)__mptr + 18446744073709544120U;
  }
  
#line 1795 
  struct vxgedev *vdev = tmp;
  
#line 1797 
  tmp_0 = netif_running((struct net_device const *)vdev->ndev);
  
#line 1797 
  if (tmp_0) 
#line 1797 
             tmp_1 = 0; else 
#line 1797 
                             tmp_1 = 1;
  
#line 1797 
  if (tmp_1) 
#line 1798 
             goto return_label; else ;
  
#line 1800 
  do_vxge_reset(vdev,2);
  return_label: 
#line 1801 
                return;
}


#line 1815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_poll_msix(struct napi_struct *napi, int budget)
{
  struct vxge_ring *tmp;
  int pkts_processed;
  {
    
#line 1817 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 1817 
    tmp = (struct vxge_ring *)__mptr + 18446744073709551552U;
  }
  
#line 1817 
  struct vxge_ring *ring = tmp;
  
#line 1819 
  int budget_org = budget;
  
#line 1821 
  ring->budget = budget;
  
#line 1822 
  ring->pkts_processed = 0;
  
#line 1823 
  vxge_hw_vpath_poll_rx(ring->handle);
  
#line 1824 
  pkts_processed = ring->pkts_processed;
  
#line 1826 
  if (ring->pkts_processed < budget_org) {
    
#line 1827 
    napi_complete(napi);
    
#line 1830 
    vxge_hw_channel_msix_unmask((struct __vxge_hw_channel *)ring->handle,(int)ring->rx_vector_no);
    
#line 1833 
    ldv_inline_asm();
  }
  else ;
  
#line 1839 
  return pkts_processed;
}


#line 1842  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_poll_inta(struct napi_struct *napi, int budget)
{
  struct vxgedev *tmp;
  int i;
  struct vxge_ring *ring;
  {
    
#line 1844 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 1844 
    tmp = (struct vxgedev *)__mptr + 18446744073709544672U;
  }
  
#line 1844 
  struct vxgedev *vdev = tmp;
  
#line 1845 
  int pkts_processed = 0;
  
#line 1847 
  int budget_org = budget;
  
#line 1850 
  struct __vxge_hw_device *hldev = pci_get_drvdata(vdev->pdev);
  
#line 1852 
  i = 0;
  
#line 1852 
  goto ldv_56333;
  ldv_56332: 
#line 1853 
  ;
  
#line 1853 
  ring = & (vdev->vpaths + i)->ring;
  
#line 1854 
  ring->budget = budget;
  
#line 1855 
  ring->pkts_processed = 0;
  
#line 1856 
  vxge_hw_vpath_poll_rx(ring->handle);
  
#line 1857 
  pkts_processed = ring->pkts_processed + pkts_processed;
  
#line 1858 
  budget -= ring->pkts_processed;
  
#line 1859 
  if (budget <= 0) 
#line 1860 
                   goto ldv_56331; else ;
  
#line 1852 
  i += 1;
  ldv_56333: 
#line 1853 
  ;
  
#line 1852 
  if (vdev->no_of_vpath > i) 
#line 1854 
                             goto ldv_56332; else 
#line 1857 
                                                  goto ldv_56331;
  ldv_56331: 
#line 1858 
  ;
  
#line 1863 
  VXGE_COMPLETE_ALL_TX(vdev);
  
#line 1865 
  if (pkts_processed < budget_org) {
    
#line 1866 
    napi_complete(napi);
    
#line 1868 
    vxge_hw_device_unmask_all(hldev);
    
#line 1869 
    vxge_hw_device_flush_io(hldev);
  }
  else ;
  
#line 1872 
  return pkts_processed;
}


#line 1885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_netpoll(struct net_device *dev)
{
  int tmp_1;
  
#line 1887 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 1888 
  struct pci_dev *pdev = vdev->pdev;
  
#line 1889 
  struct __vxge_hw_device *hldev = pci_get_drvdata(pdev);
  
#line 1890 
  int const irq = (int)pdev->irq;
  
#line 1892 
  printk("%s:%d","vxge_netpoll",1892);
  
#line 1894 
  tmp_1 = pci_channel_offline(pdev);
  
#line 1894 
  if (tmp_1 != 0) 
#line 1895 
                  goto return_label; else ;
  
#line 1897 
  disable_irq((unsigned int)irq);
  
#line 1898 
  vxge_hw_device_clear_tx_rx(hldev);
  
#line 1900 
  vxge_hw_device_clear_tx_rx(hldev);
  
#line 1901 
  VXGE_COMPLETE_ALL_RX(vdev);
  
#line 1902 
  VXGE_COMPLETE_ALL_TX(vdev);
  
#line 1904 
  enable_irq((unsigned int)irq);
  
#line 1906 
  printk("%s:%d  Exiting...","vxge_netpoll",1907);
  return_label: 
#line 1907 
                return;
}


#line 1912  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_rth_configure(struct vxgedev *vdev)
{
  enum vxge_hw_status __retres;
  struct vxge_hw_rth_hash_types hash_types;
  int index;
  
#line 1914 
  enum vxge_hw_status status = 0;
  
#line 1916 
  u8 itable[256U] = {(unsigned char)0U};
  
#line 1917 
  u8 mtable[256U] = {(unsigned char)0U};
  
#line 1925 
  index = 0;
  
#line 1925 
  goto ldv_56351;
  ldv_56350: 
#line 1926 
  ;
  
#line 1926 
  itable[index] = (unsigned char)index;
  
#line 1927 
  mtable[index] = (unsigned char)(index % vdev->no_of_vpath);
  
#line 1925 
  index += 1;
  ldv_56351: 
#line 1926 
  ;
  
#line 1925 
  if (1 << (int)vdev->config.rth_bkt_sz > index) 
#line 1927 
                                                 goto ldv_56350; else 
                                                                   
#line 1930 
                                                                   goto ldv_56352;
  ldv_56352: 
#line 1931 
  ;
  
#line 1931 
  status = vxge_hw_vpath_rts_rth_itable_set((struct __vxge_hw_vpath_handle **)(& vdev->vp_handles),(unsigned int)vdev->no_of_vpath,(u8 *)(& mtable),(u8 *)(& itable),(unsigned int)vdev->config.rth_bkt_sz);
  
#line 1935 
  if (status != VXGE_HW_OK) {
    
#line 1936 
    printk("RTH indirection table configuration failed ",(vdev->vpaths)->device_id);
    
#line 1939 
    __retres = status;
    
#line 1939 
    goto return_label;
  }
  else ;
  
#line 1943 
  hash_types.hash_type_tcpipv4_en = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))vdev->config.rth_hash_type_tcpipv4;
  
#line 1944 
  hash_types.hash_type_ipv4_en = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))vdev->config.rth_hash_type_ipv4;
  
#line 1945 
  hash_types.hash_type_tcpipv6_en = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))vdev->config.rth_hash_type_tcpipv6;
  
#line 1946 
  hash_types.hash_type_ipv6_en = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))vdev->config.rth_hash_type_ipv6;
  
#line 1947 
  hash_types.hash_type_tcpipv6ex_en = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))vdev->config.rth_hash_type_tcpipv6ex;
  
#line 1949 
  hash_types.hash_type_ipv6ex_en = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))vdev->config.rth_hash_type_ipv6ex;
  
#line 1957 
  index = 0;
  
#line 1957 
  goto ldv_56354;
  ldv_56353: 
#line 1958 
  ;
  
#line 1958 
  status = vxge_hw_vpath_rts_rth_set((vdev->vpaths + index)->handle,(enum vxge_hw_rth_algoritms)vdev->config.rth_algorithm,& hash_types,(unsigned short)((int)vdev->config.rth_bkt_sz));
  
#line 1963 
  if (status != VXGE_HW_OK) {
    
#line 1964 
    printk("RTH configuration failed for vpath:%d",(vdev->vpaths + index)->device_id);
    
#line 1967 
    __retres = status;
    
#line 1967 
    goto return_label;
  }
  else ;
  
#line 1957 
  index += 1;
  ldv_56354: 
#line 1958 
  ;
  
#line 1957 
  if (vdev->no_of_vpath > index) 
#line 1959 
                                 goto ldv_56353; else 
#line 1962 
                                                      goto ldv_56355;
  ldv_56355: 
#line 1963 
  ;
  
#line 1971 
  __retres = status;
  return_label: 
#line 1971 
                return __retres;
}


#line 1975  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_reset_all_vpaths(struct vxgedev *vdev)
{
  enum vxge_hw_status __retres;
  struct vxge_vpath *vpath;
  int i;
  
#line 1977 
  enum vxge_hw_status status = 0;
  
#line 1981 
  i = 0;
  
#line 1981 
  goto ldv_56363;
  ldv_56362: 
#line 1982 
  ;
  
#line 1982 
  vpath = vdev->vpaths + i;
  
#line 1983 
  if (vpath->handle != (struct __vxge_hw_vpath_handle *)0) {
    enum vxge_hw_status tmp_1;
    
#line 1984 
    tmp_1 = vxge_hw_vpath_reset(vpath->handle);
    
#line 1984 
    if (tmp_1 == VXGE_HW_OK) {
      int tmp;
      
#line 1985 
      tmp = is_vxge_card_up(vdev);
      
#line 1985 
      if (tmp != 0) {
        enum vxge_hw_status tmp_0;
        
#line 1985 
        tmp_0 = vxge_hw_vpath_recover_from_reset(vpath->handle);
        
#line 1985 
        if (tmp_0 != VXGE_HW_OK) {
          
#line 1988 
          printk("vxge_hw_vpath_recover_",i);
          
#line 1992 
          __retres = status;
          
#line 1992 
          goto return_label;
        }
        else ;
      }
      else ;
    }
    else {
      
#line 1995 
      printk("vxge_hw_vpath_reset failed for ",i);
      
#line 1998 
      __retres = status;
      
#line 1998 
      goto return_label;
    }
  }
  else ;
  
#line 1981 
  i += 1;
  ldv_56363: 
#line 1982 
  ;
  
#line 1981 
  if (vdev->no_of_vpath > i) 
#line 1983 
                             goto ldv_56362; else 
#line 1986 
                                                  goto ldv_56364;
  ldv_56364: 
#line 1987 
  ;
  
#line 2003 
  __retres = status;
  return_label: 
#line 2003 
                return __retres;
}


#line 2007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_close_vpaths(struct vxgedev *vdev, int index)
{
  struct vxge_vpath *vpath;
  int i;
  
#line 2012 
  i = index;
  
#line 2012 
  goto ldv_56372;
  ldv_56371: 
#line 2013 
  ;
  
#line 2013 
  vpath = vdev->vpaths + i;
  
#line 2015 
  if (vpath->handle != (struct __vxge_hw_vpath_handle *)0 && vpath->is_open != 0) {
    
#line 2016 
    vxge_hw_vpath_close(vpath->handle);
    
#line 2017 
    vdev->stats.vpaths_open -= 1UL;
  }
  else ;
  
#line 2019 
  vpath->is_open = 0;
  
#line 2020 
  vpath->handle = (struct __vxge_hw_vpath_handle *)0;
  
#line 2012 
  i += 1;
  ldv_56372: 
#line 2013 
  ;
  
#line 2012 
  if (vdev->no_of_vpath > i) 
#line 2014 
                             goto ldv_56371; else 
#line 2017 
                                                  goto ldv_56373;
  ldv_56373: 
#line 2018 
  ;
  
#line 2019 
  return;
}


#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_open_vpaths(struct vxgedev *vdev)
{
  int __retres;
  struct vxge_hw_vpath_attr attr;
  enum vxge_hw_status status;
  struct vxge_vpath *vpath;
  int i;
  
#line 2030 
  u32 vp_id = 0U;
  
#line 2033 
  i = 0;
  
#line 2033 
  goto ldv_56384;
  ldv_56383: 
#line 2034 
  ;
  
#line 2034 
  vpath = vdev->vpaths + i;
  
#line 2037 
  if ((unsigned int)*((unsigned char *)vdev + 1466UL) == 0U) {
    struct vxge_hw_vp_config *vcfg;
    
#line 2039 
    vcfg = & (vdev->devh)->config.vp_config[vpath->device_id];
    
#line 2041 
    vcfg->rti.urange_a = 1U;
    
#line 2042 
    vcfg->rti.urange_b = 20U;
    
#line 2043 
    vcfg->rti.urange_c = 50U;
    
#line 2044 
    vcfg->tti.uec_a = 30U;
    
#line 2045 
    vcfg->tti.uec_b = 80U;
    
#line 2046 
    vcfg->tti.uec_c = (unsigned int)((9600 - vdev->mtu) / 93 + 60);
    
#line 2047 
    vcfg->tti.uec_d = (unsigned int)((9600 - vdev->mtu) / 37 + 100);
    
#line 2048 
    vcfg->tti.ltimer_val = 80U;
    
#line 2049 
    vcfg->tti.rtimer_val = 400U;
  }
  else ;
  
#line 2052 
  attr.vp_id = (unsigned int)vpath->device_id;
  
#line 2053 
  attr.fifo_attr.callback = & vxge_xmit_compl;
  
#line 2054 
  attr.fifo_attr.txdl_term = & vxge_tx_term;
  
#line 2055 
  attr.fifo_attr.per_txdl_space = 152U;
  
#line 2056 
  attr.fifo_attr.userdata = (void *)(& vpath->fifo);
  
#line 2058 
  attr.ring_attr.callback = & vxge_rx_1b_compl;
  
#line 2059 
  attr.ring_attr.rxd_init = & vxge_rx_initial_replenish;
  
#line 2060 
  attr.ring_attr.rxd_term = & vxge_rx_term;
  
#line 2061 
  attr.ring_attr.per_rxd_space = 32U;
  
#line 2062 
  attr.ring_attr.userdata = (void *)(& vpath->ring);
  
#line 2064 
  vpath->ring.ndev = vdev->ndev;
  
#line 2065 
  vpath->ring.pdev = vdev->pdev;
  
#line 2067 
  status = vxge_hw_vpath_open(vdev->devh,& attr,& vpath->handle);
  
#line 2068 
  if (status == VXGE_HW_OK) {
    
#line 2069 
    vpath->fifo.handle = (struct __vxge_hw_fifo *)attr.fifo_attr.userdata;
    
#line 2071 
    vpath->ring.handle = (struct __vxge_hw_ring *)attr.ring_attr.userdata;
    
#line 2073 
    vpath->fifo.tx_steering_type = vdev->config.tx_steering_type;
    
#line 2075 
    vpath->fifo.ndev = vdev->ndev;
    
#line 2076 
    vpath->fifo.pdev = vdev->pdev;
    
#line 2078 
    u64_stats_init(& vpath->fifo.stats.syncp);
    
#line 2079 
    u64_stats_init(& vpath->ring.stats.syncp);
    
#line 2081 
    if (vdev->config.tx_steering_type != 0) 
#line 2082 
                                            vpath->fifo.txq = netdev_get_tx_queue((struct net_device const *)vdev->ndev,(unsigned int)i); else 
                                                                    
#line 2085 
                                                                    vpath->fifo.txq = netdev_get_tx_queue((struct net_device const *)vdev->ndev,0U);
    
#line 2087 
    vpath->fifo.indicate_max_pkts = vdev->config.fifo_indicate_max_pkts;
    
#line 2089 
    vpath->fifo.tx_vector_no = 0U;
    
#line 2090 
    vpath->ring.rx_vector_no = 0U;
    
#line 2091 
    vpath->ring.rx_hwts = vdev->rx_hwts;
    
#line 2092 
    vpath->is_open = 1;
    
#line 2093 
    vdev->vp_handles[i] = vpath->handle;
    
#line 2094 
    vpath->ring.vlan_tag_strip = vdev->vlan_tag_strip;
    
#line 2095 
    vdev->stats.vpaths_open += 1UL;
  }
  else {
    
#line 2097 
    vdev->stats.vpath_open_fail += 1UL;
    
#line 2098 
    printk("%s: vpath: %d failed to ",(char *)(& (vdev->ndev)->name),vpath->device_id,(int)status);
    
#line 2102 
    vxge_close_vpaths(vdev,0);
    
#line 2103 
    __retres = -1;
    
#line 2103 
    goto return_label;
  }
  
#line 2106 
  vp_id = ((vpath->handle)->vpath)->vp_id;
  
#line 2107 
  vdev->vpaths_deployed |= 9223372036854775808ULL >> vp_id;
  
#line 2033 
  i += 1;
  ldv_56384: 
#line 2034 
  ;
  
#line 2033 
  if (vdev->no_of_vpath > i) 
#line 2035 
                             goto ldv_56383; else 
#line 2038 
                                                  goto ldv_56385;
  ldv_56385: 
#line 2039 
  ;
  
#line 2110 
  __retres = 0;
  return_label: 
#line 2110 
                return __retres;
}


#line 2121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void adaptive_coalesce_tx_interrupts(struct vxge_fifo *fifo)
{
  int tmp;
  
#line 2123 
  fifo->interrupt_count += 1UL;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 2124 
    tmp = 1;
  }
  
#line 2124 
  if (tmp != 0) {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 2124 
      tmp_0 = 1;
    }
    
#line 2124 
    if (tmp_0 != 0) {
      
#line 2124 
      if ((long)((fifo->jiffies - jiffies) + 2UL) < 0L) {
        
#line 2125 
        struct __vxge_hw_fifo *hw_fifo = fifo->handle;
        
#line 2127 
        fifo->jiffies = jiffies;
        
#line 2128 
        if (fifo->interrupt_count > 200UL && hw_fifo->rtimer != 10U) {
          
#line 2130 
          hw_fifo->rtimer = 10U;
          
#line 2131 
          vxge_hw_vpath_dynamic_tti_rtimer_set(hw_fifo);
        }
        else 
          
#line 2132 
          if (hw_fifo->rtimer != 0U) {
            
#line 2133 
            hw_fifo->rtimer = 0U;
            
#line 2134 
            vxge_hw_vpath_dynamic_tti_rtimer_set(hw_fifo);
          }
          else ;
        
#line 2136 
        fifo->interrupt_count = 0UL;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 2138 
  return;
}


#line 2149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void adaptive_coalesce_rx_interrupts(struct vxge_ring *ring)
{
  int tmp;
  
#line 2151 
  ring->interrupt_count += 1UL;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 2152 
    tmp = 1;
  }
  
#line 2152 
  if (tmp != 0) {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 2152 
      tmp_0 = 1;
    }
    
#line 2152 
    if (tmp_0 != 0) {
      
#line 2152 
      if ((long)((ring->jiffies - jiffies) + 2UL) < 0L) {
        
#line 2153 
        struct __vxge_hw_ring *hw_ring = ring->handle;
        
#line 2155 
        ring->jiffies = jiffies;
        
#line 2156 
        if (ring->interrupt_count > 100UL && hw_ring->rtimer != 15U) {
          
#line 2158 
          hw_ring->rtimer = 15U;
          
#line 2159 
          vxge_hw_vpath_dynamic_rti_rtimer_set(hw_ring);
        }
        else 
          
#line 2160 
          if (hw_ring->rtimer != 0U) {
            
#line 2161 
            hw_ring->rtimer = 0U;
            
#line 2162 
            vxge_hw_vpath_dynamic_rti_rtimer_set(hw_ring);
          }
          else ;
        
#line 2164 
        ring->interrupt_count = 0UL;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 2166 
  return;
}


#line 2178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static irqreturn_t vxge_isr_napi(int irq, void *dev_id)
{
  irqreturn_t __retres;
  struct net_device *dev;
  struct __vxge_hw_device *hldev;
  u64 reason;
  enum vxge_hw_status status;
  int tmp_0;
  int tmp_1;
  
#line 2184 
  struct vxgedev *vdev = (struct vxgedev *)dev_id;
  
#line 2186 
  printk("%s:%d","vxge_isr_napi",2186);
  
#line 2188 
  dev = vdev->ndev;
  
#line 2189 
  hldev = (struct __vxge_hw_device *)pci_get_drvdata(vdev->pdev);
  
#line 2191 
  tmp_0 = pci_channel_offline(vdev->pdev);
  
#line 2191 
  if (tmp_0 != 0) {
    
#line 2192 
    __retres = IRQ_NONE;
    
#line 2192 
    goto return_label;
  }
  else ;
  
#line 2194 
  tmp_1 = is_vxge_card_up(vdev);
  
#line 2194 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 2195 
    __retres = IRQ_HANDLED;
    
#line 2195 
    goto return_label;
  }
  else ;
  
#line 2197 
  status = vxge_hw_device_begin_irq(hldev,(unsigned int)vdev->exec_mode,& reason);
  
#line 2198 
  if (status == VXGE_HW_OK) {
    
#line 2199 
    vxge_hw_device_mask_all(hldev);
    
#line 2201 
    if ((((vdev->vpaths_deployed >> 47) << 44) & reason) != 0ULL) {
      
#line 2206 
      vxge_hw_device_clear_tx_rx(hldev);
      
#line 2207 
      napi_schedule(& vdev->napi);
      
#line 2208 
      printk("%s:%d  Exiting...","vxge_isr_napi",2209);
      
#line 2210 
      __retres = IRQ_HANDLED;
      
#line 2210 
      goto return_label;
    }
    else 
#line 2212 
         vxge_hw_device_unmask_all(hldev);
  }
  else 
    
#line 2213 
    if ((long)((unsigned int)status + 4294967077U <= 2U) != 0L) {
      
#line 2216 
      vxge_hw_device_mask_all(hldev);
      
#line 2217 
      vxge_hw_device_flush_io(hldev);
      
#line 2218 
      __retres = IRQ_HANDLED;
      
#line 2218 
      goto return_label;
    }
    else 
      
#line 2219 
      if ((long)(status == VXGE_HW_ERR_SLOT_FREEZE) != 0L) {
        
#line 2220 
        __retres = IRQ_HANDLED;
        
#line 2220 
        goto return_label;
      }
      else ;
  
#line 2222 
  printk("%s:%d  Exiting...","vxge_isr_napi",2222);
  
#line 2223 
  __retres = IRQ_NONE;
  return_label: 
#line 2223 
                return __retres;
}


#line 2228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static irqreturn_t vxge_tx_msix_handle(int irq, void *dev_id)
{
  irqreturn_t __retres;
  
#line 2230 
  struct vxge_fifo *fifo = (struct vxge_fifo *)dev_id;
  
#line 2232 
  adaptive_coalesce_tx_interrupts(fifo);
  
#line 2234 
  vxge_hw_channel_msix_mask((struct __vxge_hw_channel *)fifo->handle,(int)fifo->tx_vector_no);
  
#line 2237 
  vxge_hw_channel_msix_clear((struct __vxge_hw_channel *)fifo->handle,(int)fifo->tx_vector_no);
  
#line 2240 
  VXGE_COMPLETE_VPATH_TX(fifo);
  
#line 2242 
  vxge_hw_channel_msix_unmask((struct __vxge_hw_channel *)fifo->handle,(int)fifo->tx_vector_no);
  
#line 2244 
  ldv_inline_asm();
  
#line 2247 
  __retres = IRQ_HANDLED;
  
#line 2247 
  return __retres;
}


#line 2250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static irqreturn_t vxge_rx_msix_napi_handle(int irq, void *dev_id)
{
  irqreturn_t __retres;
  
#line 2252 
  struct vxge_ring *ring = (struct vxge_ring *)dev_id;
  
#line 2254 
  adaptive_coalesce_rx_interrupts(ring);
  
#line 2256 
  vxge_hw_channel_msix_mask((struct __vxge_hw_channel *)ring->handle,(int)ring->rx_vector_no);
  
#line 2259 
  vxge_hw_channel_msix_clear((struct __vxge_hw_channel *)ring->handle,(int)ring->rx_vector_no);
  
#line 2262 
  napi_schedule(& ring->napi);
  
#line 2263 
  __retres = IRQ_HANDLED;
  
#line 2263 
  return __retres;
}


#line 2267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static irqreturn_t vxge_alarm_msix_handle(int irq, void *dev_id)
{
  irqreturn_t __retres;
  int i;
  enum vxge_hw_status status;
  
#line 2271 
  struct vxge_vpath *vpath = (struct vxge_vpath *)dev_id;
  
#line 2272 
  struct vxgedev *vdev = vpath->vdev;
  
#line 2273 
  int msix_id = (int)(((vpath->handle)->vpath)->vp_id * 4U + 2U);
  
#line 2276 
  i = 0;
  
#line 2276 
  goto ldv_56437;
  ldv_56436: 
#line 2277 
  ;
  
#line 2281 
  vxge_hw_vpath_msix_mask((vdev->vpaths + i)->handle,msix_id);
  
#line 2282 
  vxge_hw_vpath_msix_clear((vdev->vpaths + i)->handle,msix_id);
  
#line 2283 
  ldv_inline_asm();
  
#line 2285 
  status = vxge_hw_vpath_alarm_process((vdev->vpaths + i)->handle,(unsigned int)vdev->exec_mode);
  
#line 2287 
  if (status == VXGE_HW_OK) {
    
#line 2288 
    vxge_hw_vpath_msix_unmask((vdev->vpaths + i)->handle,msix_id);
    
#line 2289 
    ldv_inline_asm();
    
#line 2291 
    goto ldv_56435;
  }
  else ;
  
#line 2293 
  printk("%s: vxge_hw_vpath_alarm_process failed %x ",(char *)"vxge",(int)status);
  ldv_56435: 
#line 2294 
  ;
  
#line 2276 
  i += 1;
  ldv_56437: 
#line 2277 
  ;
  
#line 2276 
  if (vdev->no_of_vpath > i) 
#line 2278 
                             goto ldv_56436; else 
#line 2281 
                                                  goto ldv_56438;
  ldv_56438: 
#line 2282 
  ;
  
#line 2297 
  __retres = IRQ_HANDLED;
  
#line 2297 
  return __retres;
}


#line 2300  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_alloc_msix(struct vxgedev *vdev)
{
  int __retres;
  int j;
  int i;
  int temp;
  
#line 2302 
  int ret = 0;
  
#line 2303 
  int msix_intr_vect = 0;
  
#line 2304 
  vdev->intr_cnt = 0U;
  start: 
#line 2306 
  ;
  
#line 2308 
  vdev->intr_cnt = (unsigned int)(vdev->no_of_vpath * 2);
  
#line 2311 
  vdev->intr_cnt += 1U;
  
#line 2313 
  vdev->entries = (struct msix_entry *)kcalloc((unsigned long)vdev->intr_cnt,8UL,208U);
  
#line 2315 
  if (vdev->entries == (struct msix_entry *)0) {
    
#line 2316 
    printk("%s: memory allocation failed",(char *)"vxge");
    
#line 2319 
    ret = -12;
    
#line 2320 
    goto alloc_entries_failed;
  }
  else ;
  
#line 2323 
  vdev->vxge_entries = (struct vxge_msix_entry *)kcalloc((unsigned long)vdev->intr_cnt,16UL,208U);
  
#line 2326 
  if (vdev->vxge_entries == (struct vxge_msix_entry *)0) {
    
#line 2327 
    printk("%s: memory allocation failed",(char *)"vxge");
    
#line 2329 
    ret = -12;
    
#line 2330 
    goto alloc_vxge_entries_failed;
  }
  else ;
  
#line 2333 
  i = 0;
  
#line 2333 
  j = 0;
  
#line 2333 
  goto ldv_56451;
  ldv_56450: 
#line 2334 
  ;
  
#line 2335 
  msix_intr_vect = i * 4;
  
#line 2338 
  (vdev->entries + j)->entry = (unsigned short)msix_intr_vect;
  
#line 2339 
  (vdev->vxge_entries + j)->entry = (unsigned short)msix_intr_vect;
  
#line 2340 
  (vdev->vxge_entries + j)->in_use = (unsigned short)0U;
  
#line 2341 
  j += 1;
  
#line 2344 
  (vdev->entries + j)->entry = (unsigned short)((unsigned int)((unsigned short)msix_intr_vect) + 1U);
  
#line 2345 
  (vdev->vxge_entries + j)->entry = (unsigned short)((unsigned int)((unsigned short)msix_intr_vect) + 1U);
  
#line 2346 
  (vdev->vxge_entries + j)->in_use = (unsigned short)0U;
  
#line 2347 
  j += 1;
  
#line 2333 
  i += 1;
  ldv_56451: 
#line 2334 
  ;
  
#line 2333 
  if (vdev->no_of_vpath > i) 
#line 2335 
                             goto ldv_56450; else 
#line 2338 
                                                  goto ldv_56452;
  ldv_56452: 
#line 2339 
  ;
  
#line 2351 
  (vdev->entries + j)->entry = (unsigned short)2U;
  
#line 2352 
  (vdev->vxge_entries + j)->entry = (unsigned short)2U;
  
#line 2353 
  (vdev->vxge_entries + j)->in_use = (unsigned short)0U;
  
#line 2355 
  ret = pci_enable_msix_range(vdev->pdev,vdev->entries,3,(int)vdev->intr_cnt);
  
#line 2357 
  if (ret < 0) {
    
#line 2358 
    ret = -19;
    
#line 2359 
    goto enable_msix_failed;
  }
  else 
    
#line 2360 
    if (vdev->intr_cnt > (unsigned int)ret) {
      
#line 2361 
      pci_disable_msix(vdev->pdev);
      
#line 2363 
      printk("%s: MSI-X enable failed for %d vectors, ret: %d",(char *)"vxge",vdev->intr_cnt,ret);
      
#line 2366 
      if (max_config_vpath != -1) {
        
#line 2367 
        ret = -19;
        
#line 2368 
        goto enable_msix_failed;
      }
      else ;
      
#line 2371 
      kfree((void const *)vdev->entries);
      
#line 2372 
      kfree((void const *)vdev->vxge_entries);
      
#line 2373 
      vdev->entries = (struct msix_entry *)0;
      
#line 2374 
      vdev->vxge_entries = (struct vxge_msix_entry *)0;
      
#line 2376 
      temp = (ret + -1) / 2;
      
#line 2377 
      vxge_close_vpaths(vdev,temp);
      
#line 2378 
      vdev->no_of_vpath = temp;
      
#line 2379 
      goto start;
    }
    else ;
  
#line 2381 
  __retres = 0;
  
#line 2381 
  goto return_label;
  enable_msix_failed: 
#line 2383 
  ;
  
#line 2384 
  kfree((void const *)vdev->vxge_entries);
  alloc_vxge_entries_failed: 
#line 2385 
  ;
  
#line 2386 
  kfree((void const *)vdev->entries);
  alloc_entries_failed: 
#line 2387 
  ;
  
#line 2388 
  __retres = ret;
  return_label: 
#line 2388 
                return __retres;
}


#line 2391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_enable_msix(struct vxgedev *vdev)
{
  int i;
  
#line 2394 
  int ret = 0;
  
#line 2396 
  int tim_msix_id[4U] = {0, 1, 0, 0};
  
#line 2398 
  vdev->intr_cnt = 0U;
  
#line 2401 
  ret = vxge_alloc_msix(vdev);
  
#line 2402 
  if (ret == 0) {
    
#line 2403 
    i = 0;
    
#line 2403 
    goto ldv_56462;
    ldv_56461: 
#line 2404 
    ;
    {
      
#line 2404 
      struct vxge_vpath *vpath = vdev->vpaths + i;
      
#line 2409 
      vpath->ring.rx_vector_no = (unsigned int)(vpath->device_id * 4 + 1);
      
#line 2412 
      vpath->fifo.tx_vector_no = (unsigned int)(vpath->device_id * 4);
      
#line 2415 
      vxge_hw_vpath_msix_set(vpath->handle,(int *)(& tim_msix_id),2);
    }
    
#line 2403 
    i += 1;
    ldv_56462: 
#line 2404 
    ;
    
#line 2403 
    if (vdev->no_of_vpath > i) 
#line 2405 
                               goto ldv_56461; else 
#line 2408 
                                                    goto ldv_56463;
    ldv_56463: 
#line 2409 
    ;
  }
  else ;
  
#line 2420 
  return ret;
}


#line 2423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_rem_msix_isr(struct vxgedev *vdev)
{
  int intr_cnt;
  
#line 2427 
  intr_cnt = 0;
  
#line 2427 
  goto ldv_56469;
  ldv_56468: 
#line 2428 
  ;
  
#line 2429 
  if ((unsigned int)(vdev->vxge_entries + intr_cnt)->in_use != 0U) {
    
#line 2430 
    synchronize_irq((vdev->entries + intr_cnt)->vector);
    
#line 2431 
    ldv_free_irq_74((vdev->entries + intr_cnt)->vector,(vdev->vxge_entries + intr_cnt)->arg);
    
#line 2433 
    (vdev->vxge_entries + intr_cnt)->in_use = (unsigned short)0U;
  }
  else ;
  
#line 2428 
  intr_cnt += 1;
  ldv_56469: 
#line 2429 
  ;
  
#line 2427 
  if (vdev->no_of_vpath * 2 + 1 > intr_cnt) 
#line 2429 
                                            goto ldv_56468; else 
#line 2432 
                                                                 goto ldv_56470;
  ldv_56470: 
#line 2433 
  ;
  
#line 2437 
  kfree((void const *)vdev->entries);
  
#line 2438 
  kfree((void const *)vdev->vxge_entries);
  
#line 2439 
  vdev->entries = (struct msix_entry *)0;
  
#line 2440 
  vdev->vxge_entries = (struct vxge_msix_entry *)0;
  
#line 2442 
  if (vdev->config.intr_type == 2) 
#line 2443 
                                   pci_disable_msix(vdev->pdev); else ;
  
#line 2444 
  return;
}


#line 2447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_rem_isr(struct vxgedev *vdev)
{
  
#line 2450 
  if (vdev->config.intr_type == 2) 
#line 2451 
                                   vxge_rem_msix_isr(vdev);
  else 
    
#line 2454 
    if (vdev->config.intr_type == 0) {
      
#line 2455 
      synchronize_irq((vdev->pdev)->irq);
      
#line 2456 
      ldv_free_irq_75((vdev->pdev)->irq,(void *)vdev);
    }
    else ;
  
#line 2458 
  return;
}


#line 2460  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_add_isr(struct vxgedev *vdev)
{
  int __retres;
  
#line 2462 
  int ret = 0;
  
#line 2464 
  int vp_idx = 0;
  
#line 2464 
  int intr_idx = 0;
  
#line 2464 
  int intr_cnt = 0;
  
#line 2464 
  int msix_idx = 0;
  
#line 2464 
  int irq_req = 0;
  
#line 2465 
  int pci_fun = (int)(vdev->pdev)->devfn & 7;
  
#line 2467 
  if (vdev->config.intr_type == 2) 
#line 2468 
                                   ret = vxge_enable_msix(vdev); else ;
  
#line 2470 
  if (ret != 0) {
    
#line 2471 
    printk("%s: Enabling MSI-X Failed",(char *)"vxge");
    
#line 2473 
    printk("%s: Defaulting to INTA",(char *)"vxge");
    
#line 2475 
    vdev->config.intr_type = 0;
  }
  else ;
  
#line 2478 
  if (vdev->config.intr_type == 2) {
    
#line 2479 
    intr_idx = 0;
    
#line 2479 
    goto ldv_56489;
    ldv_56488: 
#line 2480 
    ;
    
#line 2483 
    msix_idx = intr_idx % 4;
    
#line 2484 
    irq_req = 0;
    
#line 2486 
    switch (msix_idx) {
      case 0: 
#line 2487 
      ;
      
#line 2488 
      snprintf((char *)(& vdev->desc[intr_cnt]),80UL,"%s:vxge:MSI-X %d - Tx - fn:%d vpath:%d",(char *)(& (vdev->ndev)->name),(int)(vdev->entries + intr_cnt)->entry,pci_fun,vp_idx);
      
#line 2493 
      ret = ldv_request_irq_76((vdev->entries + intr_cnt)->vector,& vxge_tx_msix_handle,0UL,(char const *)(& vdev->desc[intr_cnt]),(void *)(& (vdev->vpaths + vp_idx)->fifo));
      
#line 2498 
      (vdev->vxge_entries + intr_cnt)->arg = (void *)(& (vdev->vpaths + vp_idx)->fifo);
      
#line 2500 
      irq_req = 1;
      
#line 2501 
      goto ldv_56485;
      case 1: 
#line 2502 
      ;
      
#line 2503 
      snprintf((char *)(& vdev->desc[intr_cnt]),80UL,"%s:vxge:MSI-X %d - Rx - fn:%d vpath:%d",(char *)(& (vdev->ndev)->name),(int)(vdev->entries + intr_cnt)->entry,pci_fun,vp_idx);
      
#line 2508 
      ret = ldv_request_irq_77((vdev->entries + intr_cnt)->vector,& vxge_rx_msix_napi_handle,0UL,(char const *)(& vdev->desc[intr_cnt]),(void *)(& (vdev->vpaths + vp_idx)->ring));
      
#line 2514 
      (vdev->vxge_entries + intr_cnt)->arg = (void *)(& (vdev->vpaths + vp_idx)->ring);
      
#line 2516 
      irq_req = 1;
      
#line 2517 
      goto ldv_56485;
    }
    ldv_56485: 
#line 2520 
    ;
    
#line 2520 
    if (ret != 0) {
      
#line 2521 
      printk("%s: MSIX - %d  Registration failed",(char *)(& (vdev->ndev)->name),intr_cnt);
      
#line 2524 
      vxge_rem_msix_isr(vdev);
      
#line 2525 
      vdev->config.intr_type = 0;
      
#line 2526 
      printk("%s: Defaulting to INTA",(char *)(& (vdev->ndev)->name));
      
#line 2529 
      goto INTA_MODE;
    }
    else ;
    
#line 2532 
    if (irq_req != 0) {
      
#line 2534 
      (vdev->vxge_entries + intr_cnt)->in_use = (unsigned short)1U;
      
#line 2535 
      msix_idx = (vdev->vpaths + vp_idx)->device_id * 4 + msix_idx;
      
#line 2537 
      vxge_hw_vpath_msix_unmask((vdev->vpaths + vp_idx)->handle,msix_idx);
      
#line 2540 
      intr_cnt += 1;
    }
    else ;
    
#line 2544 
    if (((unsigned int)(intr_idx + 1) & 3U) == 0U && vdev->no_of_vpath + -1 > vp_idx) 
      
#line 2546 
      vp_idx += 1; else ;
    
#line 2481 
    intr_idx += 1;
    ldv_56489: 
#line 2482 
    ;
    
#line 2479 
    if (vdev->no_of_vpath * 4 > intr_idx) 
#line 2482 
                                          goto ldv_56488; else 
#line 2485 
                                                               goto ldv_56490;
    ldv_56490: 
#line 2486 
    ;
    
#line 2549 
    intr_cnt = vdev->no_of_vpath * 2;
    
#line 2550 
    snprintf((char *)(& vdev->desc[intr_cnt]),80UL,"%s:vxge:MSI-X %d - Alarm - fn:%d",(char *)(& (vdev->ndev)->name),(int)(vdev->entries + intr_cnt)->entry,pci_fun);
    
#line 2556 
    ret = ldv_request_irq_78((vdev->entries + intr_cnt)->vector,& vxge_alarm_msix_handle,0UL,(char const *)(& vdev->desc[intr_cnt]),(void *)vdev->vpaths);
    
#line 2560 
    if (ret != 0) {
      
#line 2561 
      printk("%s: MSIX - %d Registration failed",(char *)(& (vdev->ndev)->name),intr_cnt);
      
#line 2564 
      vxge_rem_msix_isr(vdev);
      
#line 2565 
      vdev->config.intr_type = 0;
      
#line 2566 
      printk("%s: Defaulting to INTA",(char *)(& (vdev->ndev)->name));
      
#line 2569 
      goto INTA_MODE;
    }
    else ;
    
#line 2572 
    msix_idx = (int)((((vdev->vpaths)->handle)->vpath)->vp_id * 4U + 2U);
    
#line 2574 
    vxge_hw_vpath_msix_unmask((vdev->vpaths + vp_idx)->handle,msix_idx);
    
#line 2576 
    (vdev->vxge_entries + intr_cnt)->in_use = (unsigned short)1U;
    
#line 2577 
    (vdev->vxge_entries + intr_cnt)->arg = (void *)vdev->vpaths;
  }
  else ;
  INTA_MODE: 
#line 2579 
  ;
  
#line 2582 
  if (vdev->config.intr_type == 0) {
    
#line 2583 
    snprintf((char *)(& vdev->desc[0]),80UL,"%s:vxge:INTA",(char *)(& (vdev->ndev)->name));
    
#line 2585 
    vxge_hw_device_set_intr_type(vdev->devh,0U);
    
#line 2588 
    vxge_hw_vpath_tti_ci_set((vdev->vpaths)->fifo.handle);
    
#line 2590 
    ret = ldv_request_irq_79((vdev->pdev)->irq,& vxge_isr_napi,128UL,(char const *)(& vdev->desc[0]),(void *)vdev);
    
#line 2593 
    if (ret != 0) {
      
#line 2594 
      printk("%s %s-%d: ISR registration failed",(char *)"vxge",(char *)"IRQ",(vdev->pdev)->irq);
      
#line 2597 
      __retres = -19;
      
#line 2597 
      goto return_label;
    }
    else ;
    
#line 2599 
    printk("new %s-%d line allocated",(char *)"IRQ",(vdev->pdev)->irq);
  }
  else ;
  
#line 2604 
  __retres = 0;
  return_label: 
#line 2604 
                return __retres;
}


#line 2607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_poll_vp_reset(unsigned long data)
{
  int i;
  int tmp_1;
  
#line 2609 
  struct vxgedev *vdev = (struct vxgedev *)data;
  
#line 2610 
  int j = 0;
  
#line 2612 
  i = 0;
  
#line 2612 
  goto ldv_56498;
  ldv_56497: 
#line 2613 
  ;
  
#line 2613 
  if (0 != 0) {
    int tmp;
    
#line 2613 
    tmp = constant_test_bit((long)i,(unsigned long const volatile *)(& vdev->vp_reset));
    
#line 2613 
    tmp_1 = tmp != 0;
  }
  else {
    int tmp_0;
    
#line 2613 
    tmp_0 = variable_test_bit((long)i,(unsigned long const volatile *)(& vdev->vp_reset));
    
#line 2613 
    tmp_1 = tmp_0 != 0;
  }
  
#line 2613 
  if (tmp_1) {
    
#line 2614 
    vxge_reset_vpath(vdev,i);
    
#line 2615 
    j += 1;
  }
  else ;
  
#line 2612 
  i += 1;
  ldv_56498: 
#line 2613 
  ;
  
#line 2612 
  if (vdev->no_of_vpath > i) 
#line 2614 
                             goto ldv_56497; else 
#line 2617 
                                                  goto ldv_56499;
  ldv_56499: 
#line 2618 
  ;
  
#line 2618 
  if (j != 0 && vdev->config.intr_type != 2) {
    
#line 2619 
    vxge_hw_device_unmask_all(vdev->devh);
    
#line 2620 
    vxge_hw_device_flush_io(vdev->devh);
  }
  else ;
  
#line 2623 
  ldv_mod_timer_80(& vdev->vp_reset_timer,jiffies + 125UL);
  
#line 2624 
  return;
}


#line 2626  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_poll_vp_lockup(unsigned long data)
{
  struct vxge_vpath *vpath;
  struct vxge_ring *ring;
  int i;
  unsigned long rx_frms;
  u64 volatile *tmp;
  
#line 2628 
  struct vxgedev *vdev = (struct vxgedev *)data;
  
#line 2629 
  enum vxge_hw_status status = 0;
  
#line 2635 
  i = 0;
  
#line 2635 
  goto ldv_56513;
  ldv_56512: 
#line 2636 
  ;
  
#line 2636 
  ring = & (vdev->vpaths + i)->ring;
  {
    
#line 2639 
    u64 __var = 0ULL;
    
#line 2639 
    tmp = (u64 volatile *)(& ring->stats.rx_frms);
  }
  
#line 2639 
  rx_frms = (unsigned long)*tmp;
  
#line 2642 
  if (ring->stats.prev_rx_frms == rx_frms) {
    
#line 2643 
    status = vxge_hw_vpath_check_leak(ring->handle);
    
#line 2646 
    if (status == VXGE_HW_FAIL && ring->last_status == VXGE_HW_FAIL) {
      int tmp_0;
      
#line 2650 
      tmp_0 = test_and_set_bit((long)i,(unsigned long volatile *)(& vdev->vp_reset));
      
#line 2650 
      if (tmp_0 == 0) {
        
#line 2651 
        vpath = vdev->vpaths + i;
        
#line 2654 
        vxge_vpath_intr_disable(vdev,i);
        
#line 2657 
        netif_tx_start_queue(vpath->fifo.txq);
        
#line 2658 
        goto ldv_56511;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 2662 
  ring->stats.prev_rx_frms = rx_frms;
  
#line 2663 
  ring->last_status = status;
  ldv_56511: 
#line 2664 
  ;
  
#line 2635 
  i += 1;
  ldv_56513: 
#line 2636 
  ;
  
#line 2635 
  if (vdev->no_of_vpath > i) 
#line 2637 
                             goto ldv_56512; else 
#line 2640 
                                                  goto ldv_56514;
  ldv_56514: 
#line 2641 
  ;
  
#line 2667 
  ldv_mod_timer_81(& vdev->vp_lockup_timer,jiffies);
  
#line 2668 
  return;
}


#line 2670  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static netdev_features_t vxge_fix_features(struct net_device *dev, netdev_features_t features)
{
  
#line 2673 
  netdev_features_t changed = dev->features ^ features;
  
#line 2679 
  if ((changed & 8589934592ULL) != 0ULL) {
    bool tmp;
    
#line 2679 
    tmp = netif_running((struct net_device const *)dev);
    
#line 2679 
    if ((int)tmp != 0) 
#line 2680 
                       features ^= 8589934592ULL; else ;
  }
  else ;
  
#line 2682 
  return features;
}


#line 2685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_set_features(struct net_device *dev, netdev_features_t features)
{
  int __retres;
  enum vxge_hw_status tmp_0;
  
#line 2687 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 2688 
  netdev_features_t changed = dev->features ^ features;
  
#line 2690 
  if ((changed & 8589934592ULL) == 0ULL) {
    
#line 2691 
    __retres = 0;
    
#line 2691 
    goto return_label;
  }
  else ;
  
#line 2695 
  (vdev->devh)->config.rth_en = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))((features & 8589934592ULL) != 0ULL);
  
#line 2696 
  tmp_0 = vxge_reset_all_vpaths(vdev);
  
#line 2696 
  if (tmp_0 != VXGE_HW_OK) {
    
#line 2697 
    dev->features = features ^ 8589934592ULL;
    
#line 2698 
    (vdev->devh)->config.rth_en = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))((dev->features & 8589934592ULL) != 0ULL);
    
#line 2699 
    __retres = -5;
    
#line 2699 
    goto return_label;
  }
  else ;
  
#line 2702 
  __retres = 0;
  return_label: 
#line 2702 
                return __retres;
}


#line 2715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_open(struct net_device *dev)
{
  enum vxge_hw_status status;
  struct vxgedev *vdev;
  struct __vxge_hw_device *hldev;
  struct vxge_vpath *vpath;
  int i;
  u64 val64;
  u64 function_mode;
  int tmp_1;
  int tmp_2;
  char *tmp_3;
  enum vxge_hw_device_link_state tmp_4;
  
#line 2721 
  int ret = 0;
  
#line 2725 
  printk("%s: %s:%d",(char *)(& dev->name),"vxge_open",2726);
  
#line 2728 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)dev);
  
#line 2729 
  hldev = (struct __vxge_hw_device *)pci_get_drvdata(vdev->pdev);
  
#line 2730 
  function_mode = vdev->config.device_hw_info.function_mode;
  
#line 2734 
  netif_carrier_off(dev);
  
#line 2737 
  tmp_1 = vxge_open_vpaths(vdev);
  
#line 2737 
  status = (enum vxge_hw_status)tmp_1;
  
#line 2738 
  if (status != VXGE_HW_OK) {
    
#line 2739 
    printk("%s: fatal: Vpath open failed",(char *)(& (vdev->ndev)->name));
    
#line 2741 
    ret = -1;
    
#line 2742 
    goto out0;
  }
  else ;
  
#line 2745 
  vdev->mtu = (int)dev->mtu;
  
#line 2747 
  tmp_2 = vxge_add_isr(vdev);
  
#line 2747 
  status = (enum vxge_hw_status)tmp_2;
  
#line 2748 
  if (status != VXGE_HW_OK) {
    
#line 2749 
    printk("%s: fatal: ISR add failed",(char *)(& dev->name));
    
#line 2751 
    ret = -1;
    
#line 2752 
    goto out1;
  }
  else ;
  
#line 2755 
  if (vdev->config.intr_type != 2) {
    
#line 2756 
    netif_napi_add(dev,& vdev->napi,& vxge_poll_inta,vdev->config.napi_weight);
    
#line 2758 
    napi_enable(& vdev->napi);
    
#line 2759 
    i = 0;
    
#line 2759 
    goto ldv_56541;
    ldv_56540: 
#line 2760 
    ;
    
#line 2760 
    vpath = vdev->vpaths + i;
    
#line 2761 
    vpath->ring.napi_p = & vdev->napi;
    
#line 2759 
    i += 1;
    ldv_56541: 
#line 2760 
    ;
    
#line 2759 
    if (vdev->no_of_vpath > i) 
#line 2761 
                               goto ldv_56540; else 
#line 2764 
                                                    goto ldv_56542;
    ldv_56542: 
#line 2765 
    ;
  }
  else {
    
#line 2764 
    i = 0;
    
#line 2764 
    goto ldv_56544;
    ldv_56543: 
#line 2765 
    ;
    
#line 2765 
    vpath = vdev->vpaths + i;
    
#line 2766 
    netif_napi_add(dev,& vpath->ring.napi,& vxge_poll_msix,vdev->config.napi_weight);
    
#line 2768 
    napi_enable(& vpath->ring.napi);
    
#line 2769 
    vpath->ring.napi_p = & vpath->ring.napi;
    
#line 2764 
    i += 1;
    ldv_56544: 
#line 2765 
    ;
    
#line 2764 
    if (vdev->no_of_vpath > i) 
#line 2766 
                               goto ldv_56543; else 
#line 2769 
                                                    goto ldv_56545;
    ldv_56545: 
#line 2770 
    ;
  }
  
#line 2774 
  if ((unsigned int)*((unsigned char *)(& vdev->config) + 20UL) != 0U) {
    
#line 2775 
    status = vxge_rth_configure(vdev);
    
#line 2776 
    if (status != VXGE_HW_OK) {
      
#line 2777 
      printk("%s: fatal: RTH configuration failed",(char *)(& dev->name));
      
#line 2780 
      ret = -1;
      
#line 2781 
      goto out2;
    }
    else ;
  }
  else ;
  
#line 2784 
  if ((unsigned int)*((unsigned char *)(& hldev->config) + 12UL) != 0U) 
    
#line 2784 
    tmp_3 = (char *)"enabled"; else 
#line 2784 
                                    tmp_3 = (char *)"disabled";
  
#line 2784 
  ;
  
#line 2784 
  printk("\001",(char *)(& dev->name),tmp_3);
  
#line 2787 
  i = 0;
  
#line 2787 
  goto ldv_56548;
  ldv_56547: 
#line 2788 
  ;
  
#line 2788 
  vpath = vdev->vpaths + i;
  
#line 2791 
  status = vxge_hw_vpath_mtu_set(vpath->handle,(unsigned int)vdev->mtu);
  
#line 2792 
  if (status != VXGE_HW_OK) {
    
#line 2793 
    printk("%s: fatal: can not set new MTU",(char *)(& dev->name));
    
#line 2795 
    ret = -1;
    
#line 2796 
    goto out2;
  }
  else ;
  
#line 2787 
  i += 1;
  ldv_56548: 
#line 2788 
  ;
  
#line 2787 
  if (vdev->no_of_vpath > i) 
#line 2789 
                             goto ldv_56547; else 
#line 2792 
                                                  goto ldv_56549;
  ldv_56549: 
#line 2793 
  ;
  
#line 2800 
  vxge_hw_device_debug_set(vdev->devh,(enum vxge_debug_level)VXGE_TRACE,536870912U);
  
#line 2800 
  i = 0;
  
#line 2800 
  goto ldv_56551;
  ldv_56550: 
#line 2801 
  ;
  
#line 2800 
  (vdev->vpaths + i)->level_err = vxge_hw_device_error_level_get(vdev->devh);
  
#line 2800 
  (vdev->vpaths + i)->level_trace = vxge_hw_device_trace_level_get(vdev->devh);
  
#line 2800 
  i += 1;
  ldv_56551: 
#line 2801 
  ;
  
#line 2800 
  if (vdev->no_of_vpath > i) 
#line 2802 
                             goto ldv_56550; else 
#line 2805 
                                                  goto ldv_56552;
  ldv_56552: 
#line 2806 
  ;
  
#line 2800 
  vdev->level_err = vxge_hw_device_error_level_get(vdev->devh);
  
#line 2800 
  vdev->level_trace = vxge_hw_device_trace_level_get(vdev->devh);
  
#line 2801 
  if (vdev->level_trace != 0U) 
#line 2801 
                               printk("%s: MTU is %d",(char *)(& (vdev->ndev)->name),vdev->mtu); else ;
  
#line 2803 
  vxge_hw_device_debug_set(vdev->devh,(enum vxge_debug_level)VXGE_ERR,536870912U);
  
#line 2803 
  i = 0;
  
#line 2803 
  goto ldv_56554;
  ldv_56553: 
#line 2804 
  ;
  
#line 2803 
  (vdev->vpaths + i)->level_err = vxge_hw_device_error_level_get(vdev->devh);
  
#line 2803 
  (vdev->vpaths + i)->level_trace = vxge_hw_device_trace_level_get(vdev->devh);
  
#line 2803 
  i += 1;
  ldv_56554: 
#line 2804 
  ;
  
#line 2803 
  if (vdev->no_of_vpath > i) 
#line 2805 
                             goto ldv_56553; else 
#line 2808 
                                                  goto ldv_56555;
  ldv_56555: 
#line 2809 
  ;
  
#line 2803 
  vdev->level_err = vxge_hw_device_error_level_get(vdev->devh);
  
#line 2803 
  vdev->level_trace = vxge_hw_device_trace_level_get(vdev->devh);
  
#line 2808 
  if ((unsigned int)vdev->all_multi_flg != 0U) {
    
#line 2809 
    i = 0;
    
#line 2809 
    goto ldv_56557;
    ldv_56556: 
#line 2810 
    ;
    
#line 2810 
    vpath = vdev->vpaths + i;
    
#line 2811 
    vxge_restore_vpath_mac_addr(vpath);
    
#line 2812 
    vxge_restore_vpath_vid_table(vpath);
    
#line 2814 
    status = vxge_hw_vpath_mcast_enable(vpath->handle);
    
#line 2815 
    if (status != VXGE_HW_OK) 
#line 2816 
                              printk("%s:%d Enabling multicast failed","vxge_open",2818); else ;
    
#line 2809 
    i += 1;
    ldv_56557: 
#line 2810 
    ;
    
#line 2809 
    if (vdev->no_of_vpath > i) 
#line 2811 
                               goto ldv_56556; else 
#line 2814 
                                                    goto ldv_56558;
    ldv_56558: 
#line 2815 
    ;
  }
  else ;
  
#line 2826 
  val64 = 0ULL;
  
#line 2827 
  i = 0;
  
#line 2827 
  goto ldv_56560;
  ldv_56559: 
#line 2828 
  ;
  
#line 2828 
  val64 = (9223372036854775808ULL >> i) | val64;
  
#line 2827 
  i += 1;
  ldv_56560: 
#line 2828 
  ;
  
#line 2827 
  if (i <= 16) 
#line 2829 
               goto ldv_56559; else 
#line 2832 
                                    goto ldv_56561;
  ldv_56561: 
#line 2833 
  ;
  
#line 2830 
  vxge_hw_mgmt_reg_write(vdev->devh,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_mrpcim,0U,5736U,val64);
  
#line 2837 
  vxge_hw_mgmt_reg_write(vdev->devh,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_mrpcim,0U,5744U,val64);
  
#line 2844 
  vxge_set_multicast(dev);
  
#line 2847 
  i = 0;
  
#line 2847 
  goto ldv_56563;
  ldv_56562: 
#line 2848 
  ;
  
#line 2848 
  vpath = vdev->vpaths + i;
  
#line 2849 
  status = vxge_hw_vpath_bcast_enable(vpath->handle);
  
#line 2850 
  if (status != VXGE_HW_OK) 
#line 2851 
                            printk("%s : Can not enable bcast for vpath ",(char *)(& dev->name),i); else ;
  
#line 2854 
  if (vdev->config.addr_learn_en != 0) {
    
#line 2855 
    status = vxge_hw_vpath_mcast_enable(vpath->handle);
    
#line 2856 
    if (status != VXGE_HW_OK) 
#line 2857 
                              printk("%s : Can not enable mcast for vpath ",(char *)(& dev->name),i); else ;
  }
  else ;
  
#line 2847 
  i += 1;
  ldv_56563: 
#line 2848 
  ;
  
#line 2847 
  if (vdev->no_of_vpath > i) 
#line 2849 
                             goto ldv_56562; else 
#line 2852 
                                                  goto ldv_56564;
  ldv_56564: 
#line 2853 
  ;
  
#line 2863 
  vxge_hw_device_setpause_data(vdev->devh,0U,(unsigned int)vdev->config.tx_pause_enable,(unsigned int)vdev->config.rx_pause_enable);
  
#line 2867 
  if (vdev->vp_reset_timer.function == (void (*)(unsigned long ))0) 
#line 2868 
                                                                    vxge_os_timer(& vdev->vp_reset_timer,& vxge_poll_vp_reset,vdev,125UL); else ;
  
#line 2872 
  if ((unsigned int)*((unsigned char *)vdev + 1466UL) != 0U && vdev->vp_lockup_timer.function == (void (*)(unsigned long ))0) 
    
#line 2873 
    vxge_os_timer(& vdev->vp_lockup_timer,& vxge_poll_vp_lockup,vdev,125UL); else ;
  
#line 2876 
  set_bit(1L,(unsigned long volatile *)(& vdev->state));
  
#line 2877 
  ldv_inline_asm();
  
#line 2880 
  tmp_4 = vxge_hw_device_link_state_get(vdev->devh);
  
#line 2880 
  if (tmp_4 == (unsigned int)VXGE_HW_LINK_UP) {
    
#line 2881 
    netif_carrier_on(vdev->ndev);
    
#line 2882 
    netdev_notice((struct net_device const *)vdev->ndev,"Link Up\n");
    
#line 2883 
    vdev->stats.link_up += 1UL;
  }
  else ;
  
#line 2886 
  vxge_hw_device_intr_enable(vdev->devh);
  
#line 2887 
  ldv_inline_asm();
  
#line 2890 
  i = 0;
  
#line 2890 
  goto ldv_56566;
  ldv_56565: 
#line 2891 
  ;
  
#line 2891 
  vpath = vdev->vpaths + i;
  
#line 2893 
  vxge_hw_vpath_enable(vpath->handle);
  
#line 2894 
  ldv_inline_asm();
  
#line 2895 
  vxge_hw_vpath_rx_doorbell_init(vpath->handle);
  
#line 2890 
  i += 1;
  ldv_56566: 
#line 2891 
  ;
  
#line 2890 
  if (vdev->no_of_vpath > i) 
#line 2892 
                             goto ldv_56565; else 
#line 2895 
                                                  goto ldv_56567;
  ldv_56567: 
#line 2896 
  ;
  
#line 2898 
  netif_tx_start_all_queues(vdev->ndev);
  
#line 2901 
  vxge_config_ci_for_tti_rti(vdev);
  
#line 2903 
  goto out0;
  out2: 
#line 2905 
  ;
  
#line 2906 
  vxge_rem_isr(vdev);
  
#line 2909 
  if (vdev->config.intr_type != 2) 
#line 2910 
                                   napi_disable(& vdev->napi);
  else {
    
#line 2912 
    i = 0;
    
#line 2912 
    goto ldv_56569;
    ldv_56568: 
#line 2913 
    ;
    
#line 2913 
    napi_disable(& (vdev->vpaths + i)->ring.napi);
    
#line 2912 
    i += 1;
    ldv_56569: 
#line 2913 
    ;
    
#line 2912 
    if (vdev->no_of_vpath > i) 
#line 2914 
                               goto ldv_56568; else 
#line 2917 
                                                    goto ldv_56570;
    ldv_56570: 
#line 2918 
    ;
  }
  out1: 
#line 2916 
  ;
  
#line 2917 
  vxge_close_vpaths(vdev,0);
  out0: 
#line 2918 
  ;
  
#line 2919 
  printk("%s: %s:%d  Exiting...",(char *)(& dev->name),"vxge_open",2921);
  
#line 2922 
  return ret;
}


#line 2926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_free_mac_add_list(struct vxge_vpath *vpath)
{
  struct list_head *entry;
  struct list_head *next;
  int tmp;
  
#line 2930 
  tmp = list_empty((struct list_head const *)(& vpath->mac_addr_list));
  
#line 2930 
  if (tmp != 0) 
#line 2931 
                goto return_label; else ;
  
#line 2933 
  entry = vpath->mac_addr_list.next;
  
#line 2933 
  next = entry->next;
  
#line 2933 
  goto ldv_56577;
  ldv_56576: 
#line 2934 
  ;
  
#line 2934 
  list_del(entry);
  
#line 2935 
  kfree((void const *)entry);
  
#line 2933 
  entry = next;
  
#line 2933 
  next = entry->next;
  ldv_56577: 
#line 2934 
  ;
  
#line 2933 
  if (& vpath->mac_addr_list != entry) 
#line 2935 
                                       goto ldv_56576; else 
#line 2938 
                                                            goto ldv_56578;
  ldv_56578: 
#line 2939 
  ;
  return_label: 
#line 2940 
                return;
}


#line 2939  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_napi_del_all(struct vxgedev *vdev)
{
  int i;
  
#line 2942 
  if (vdev->config.intr_type != 2) 
#line 2943 
                                   netif_napi_del(& vdev->napi);
  else {
    
#line 2945 
    i = 0;
    
#line 2945 
    goto ldv_56584;
    ldv_56583: 
#line 2946 
    ;
    
#line 2946 
    netif_napi_del(& (vdev->vpaths + i)->ring.napi);
    
#line 2945 
    i += 1;
    ldv_56584: 
#line 2946 
    ;
    
#line 2945 
    if (vdev->no_of_vpath > i) 
#line 2947 
                               goto ldv_56583; else 
#line 2950 
                                                    goto ldv_56585;
    ldv_56585: 
#line 2951 
    ;
  }
  
#line 2953 
  return;
}


#line 2950  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int do_vxge_close(struct net_device *dev, int do_io)
{
  int __retres;
  enum vxge_hw_status status;
  struct vxgedev *vdev;
  struct __vxge_hw_device *hldev;
  int i;
  u64 val64;
  u64 vpath_vector;
  int tmp_1;
  int tmp_2;
  
#line 2957 
  printk("%s: %s:%d",(char *)(& dev->name),"do_vxge_close",2958);
  
#line 2960 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)dev);
  
#line 2961 
  hldev = (struct __vxge_hw_device *)pci_get_drvdata(vdev->pdev);
  
#line 2963 
  tmp_1 = is_vxge_card_up(vdev);
  
#line 2963 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 2964 
    __retres = 0;
    
#line 2964 
    goto return_label;
  }
  else ;
  
#line 2968 
  goto ldv_56598;
  ldv_56597: 
#line 2969 
  ;
  
#line 2969 
  msleep(50U);
  ldv_56598: 
#line 2970 
  ;
  
#line 2968 
  tmp_2 = test_and_set_bit(0L,(unsigned long volatile *)(& vdev->state));
  
#line 2968 
  if (tmp_2 != 0) 
#line 2970 
                  goto ldv_56597; else 
#line 2973 
                                       goto ldv_56599;
  ldv_56599: 
#line 2974 
  ;
  
#line 2971 
  if (do_io != 0) {
    
#line 2973 
    vpath_vector = 9223372036854775808ULL >> (vdev->vpaths)->device_id;
    
#line 2974 
    status = vxge_hw_mgmt_reg_read(vdev->devh,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_mrpcim,0U,6288U,& val64);
    
#line 2981 
    if (status == VXGE_HW_OK) {
      
#line 2982 
      val64 = ~ vpath_vector & val64;
      
#line 2983 
      status = vxge_hw_mgmt_reg_write(vdev->devh,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_mrpcim,0U,6288U,val64);
    }
    else ;
    
#line 2993 
    vxge_hw_mgmt_reg_write(vdev->devh,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_mrpcim,0U,5736U,0ULL);
    
#line 3000 
    vxge_hw_mgmt_reg_write(vdev->devh,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_mrpcim,0U,5744U,0ULL);
    
#line 3001 
    ldv_inline_asm();
  }
  else ;
  
#line 3010 
  if ((unsigned int)*((unsigned char *)vdev + 1466UL) != 0U) 
#line 3011 
                                                             ldv_del_timer_sync_82(& vdev->vp_lockup_timer); else ;
  
#line 3013 
  ldv_del_timer_sync_83(& vdev->vp_reset_timer);
  
#line 3015 
  if (do_io != 0) 
#line 3016 
                  vxge_hw_device_wait_receive_idle(hldev); else ;
  
#line 3018 
  set_bit(1L,(unsigned long volatile *)(& vdev->state));
  
#line 3021 
  if (vdev->config.intr_type != 2) 
#line 3022 
                                   napi_disable(& vdev->napi);
  else {
    
#line 3024 
    i = 0;
    
#line 3024 
    goto ldv_56601;
    ldv_56600: 
#line 3025 
    ;
    
#line 3025 
    napi_disable(& (vdev->vpaths + i)->ring.napi);
    
#line 3024 
    i += 1;
    ldv_56601: 
#line 3025 
    ;
    
#line 3024 
    if (vdev->no_of_vpath > i) 
#line 3026 
                               goto ldv_56600; else 
#line 3029 
                                                    goto ldv_56602;
    ldv_56602: 
#line 3030 
    ;
  }
  
#line 3028 
  netif_carrier_off(vdev->ndev);
  
#line 3029 
  netdev_notice((struct net_device const *)vdev->ndev,"Link Down\n");
  
#line 3030 
  netif_tx_stop_all_queues(vdev->ndev);
  
#line 3033 
  if (do_io != 0) 
#line 3034 
                  vxge_hw_device_intr_disable(vdev->devh); else ;
  
#line 3036 
  vxge_rem_isr(vdev);
  
#line 3038 
  vxge_napi_del_all(vdev);
  
#line 3040 
  if (do_io != 0) 
#line 3041 
                  vxge_reset_all_vpaths(vdev); else ;
  
#line 3043 
  vxge_close_vpaths(vdev,0);
  
#line 3045 
  printk("%s: %s:%d  Exiting...",(char *)(& dev->name),"do_vxge_close",3046);
  
#line 3048 
  set_bit(0L,(unsigned long volatile *)(& vdev->state));
  
#line 3050 
  __retres = 0;
  return_label: 
#line 3050 
                return __retres;
}


#line 3064  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_close(struct net_device *dev)
{
  int __retres;
  
#line 3066 
  do_vxge_close(dev,1);
  
#line 3067 
  __retres = 0;
  
#line 3067 
  return __retres;
}


#line 3078  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_change_mtu(struct net_device *dev, int new_mtu)
{
  int __retres;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  
#line 3080 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 3082 
  if (vdev->level_trace != 0U) 
#line 3082 
                               printk("%s:%d","vxge_change_mtu",3083); else ;
  
#line 3084 
  if ((unsigned int)new_mtu + 4294967228U > 9532U) {
    
#line 3085 
    if (vdev->level_err != 0U) 
#line 3085 
                               printk("%s: mtu size is invalid",(char *)(& dev->name)); else ;
    
#line 3087 
    __retres = -1;
    
#line 3087 
    goto return_label;
  }
  else ;
  
#line 3091 
  tmp_0 = is_vxge_card_up(vdev);
  
#line 3091 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 3093 
    dev->mtu = (unsigned int)new_mtu;
    
#line 3094 
    if (vdev->level_err != 0U) 
#line 3094 
                               printk("%s",(char *)"device is down on MTU change"); else ;
    
#line 3096 
    __retres = 0;
    
#line 3096 
    goto return_label;
  }
  else ;
  
#line 3099 
  if (vdev->level_trace != 0U) 
#line 3099 
                               printk("trying to apply new MTU %d",new_mtu); else ;
  
#line 3102 
  tmp_1 = vxge_close(dev);
  
#line 3102 
  if (tmp_1 != 0) {
    
#line 3103 
    __retres = -5;
    
#line 3103 
    goto return_label;
  }
  else ;
  
#line 3105 
  dev->mtu = (unsigned int)new_mtu;
  
#line 3106 
  vdev->mtu = new_mtu;
  
#line 3108 
  tmp_2 = vxge_open(dev);
  
#line 3108 
  if (tmp_2 != 0) {
    
#line 3109 
    __retres = -5;
    
#line 3109 
    goto return_label;
  }
  else ;
  
#line 3111 
  if (vdev->level_trace != 0U) 
#line 3111 
                               printk("%s: MTU changed to %d",(char *)(& (vdev->ndev)->name),new_mtu); else ;
  
#line 3114 
  if (vdev->level_trace != 0U) 
#line 3114 
                               printk("%s:%d  Exiting...","vxge_change_mtu",3115); else ;
  
#line 3117 
  __retres = 0;
  return_label: 
#line 3117 
                return __retres;
}


#line 3127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static struct rtnl_link_stats64 *vxge_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *net_stats)
{
  int k;
  
#line 3129 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 3133 
  k = 0;
  
#line 3133 
  goto ldv_56629;
  ldv_56628: 
#line 3134 
  ;
  {
    unsigned int start;
    u64 packets;
    u64 bytes;
    u64 multicast;
    bool tmp_0;
    bool tmp_1;
    
#line 3134 
    struct vxge_ring_stats *rxstats = & (vdev->vpaths + k)->ring.stats;
    
#line 3135 
    struct vxge_fifo_stats *txstats = & (vdev->vpaths + k)->fifo.stats;
    ldv_56624: 
#line 3138 
    ;
    
#line 3140 
    start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& rxstats->syncp));
    
#line 3142 
    packets = rxstats->rx_frms;
    
#line 3143 
    multicast = rxstats->rx_mcast;
    
#line 3144 
    bytes = rxstats->rx_bytes;
    
#line 3145 
    tmp_0 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& rxstats->syncp),start);
    
#line 3145 
    if ((int)tmp_0 != 0) 
#line 3147 
                         goto ldv_56624; else 
#line 3150 
                                              goto ldv_56625;
    ldv_56625: 
#line 3151 
    ;
    
#line 3147 
    net_stats->rx_packets += packets;
    
#line 3148 
    net_stats->rx_bytes += bytes;
    
#line 3149 
    net_stats->multicast += multicast;
    
#line 3151 
    net_stats->rx_errors += (unsigned long long)rxstats->rx_errors;
    
#line 3152 
    net_stats->rx_dropped += (unsigned long long)rxstats->rx_dropped;
    ldv_56626: 
#line 3153 
    ;
    
#line 3155 
    start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& txstats->syncp));
    
#line 3157 
    packets = txstats->tx_frms;
    
#line 3158 
    bytes = txstats->tx_bytes;
    
#line 3159 
    tmp_1 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& txstats->syncp),start);
    
#line 3159 
    if ((int)tmp_1 != 0) 
#line 3161 
                         goto ldv_56626; else 
#line 3164 
                                              goto ldv_56627;
    ldv_56627: 
#line 3165 
    ;
    
#line 3161 
    net_stats->tx_packets += packets;
    
#line 3162 
    net_stats->tx_bytes += bytes;
    
#line 3163 
    net_stats->tx_errors += (unsigned long long)txstats->tx_errors;
  }
  
#line 3133 
  k += 1;
  ldv_56629: 
#line 3134 
  ;
  
#line 3133 
  if (vdev->no_of_vpath > k) 
#line 3135 
                             goto ldv_56628; else 
#line 3138 
                                                  goto ldv_56630;
  ldv_56630: 
#line 3139 
  ;
  
#line 3166 
  return net_stats;
}


#line 3169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static enum vxge_hw_status vxge_timestamp_config(struct __vxge_hw_device *devh)
{
  enum vxge_hw_status status;
  u64 val64;
  
#line 3179 
  val64 = 1152921504606846976ULL;
  
#line 3183 
  status = vxge_hw_mgmt_reg_write(devh,(enum vxge_hw_mgmt_reg_type)vxge_hw_mgmt_reg_type_mrpcim,0U,8008U,val64);
  
#line 3189 
  vxge_hw_device_flush_io(devh);
  
#line 3190 
  devh->config.hwts_en = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  
#line 3191 
  return status;
}


#line 3194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_hwtstamp_set(struct vxgedev *vdev, void *data)
{
  int __retres;
  struct hwtstamp_config config;
  int i;
  unsigned long tmp;
  unsigned long tmp_0;
  
#line 3199 
  tmp = copy_from_user((void *)(& config),(void const *)data,12UL);
  
#line 3199 
  if (tmp != 0UL) {
    
#line 3200 
    __retres = -14;
    
#line 3200 
    goto return_label;
  }
  else ;
  
#line 3203 
  if (config.flags != 0) {
    
#line 3204 
    __retres = -22;
    
#line 3204 
    goto return_label;
  }
  else ;
  
#line 3207 
  switch (config.tx_type) {
    case 0: 
#line 3208 
    ;
    
#line 3209 
    goto ldv_56643;
    case 1: 
#line 3210 
    ;
    default: 
#line 3211 
    ;
    
#line 3212 
    __retres = -34;
    
#line 3212 
    goto return_label;
  }
  ldv_56643: 
#line 3215 
  ;
  
#line 3215 
  switch (config.rx_filter) {
    case 0: 
#line 3216 
    ;
    
#line 3217 
    vdev->rx_hwts = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
    
#line 3218 
    config.rx_filter = 0;
    
#line 3219 
    goto ldv_56647;
    case 1: 
#line 3221 
    ;
    case 2: 
#line 3222 
    ;
    case 3: 
#line 3223 
    ;
    case 4: 
#line 3224 
    ;
    case 5: 
#line 3225 
    ;
    case 6: 
#line 3226 
    ;
    case 7: 
#line 3227 
    ;
    case 8: 
#line 3228 
    ;
    case 9: 
#line 3229 
    ;
    case 10: 
#line 3230 
    ;
    case 11: 
#line 3231 
    ;
    case 12: 
#line 3232 
    ;
    case 13: 
#line 3233 
    ;
    case 14: 
#line 3234 
    ;
    
#line 3235 
    if ((unsigned int)*((unsigned char *)(& (vdev->devh)->config) + 12UL) == 0U) {
      
#line 3236 
      __retres = -14;
      
#line 3236 
      goto return_label;
    }
    else ;
    
#line 3238 
    vdev->rx_hwts = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
    
#line 3239 
    config.rx_filter = 1;
    
#line 3240 
    goto ldv_56647;
    default: 
#line 3242 
    ;
    
#line 3243 
    __retres = -34;
    
#line 3243 
    goto return_label;
  }
  ldv_56647: 
#line 3246 
  ;
  
#line 3246 
  i = 0;
  
#line 3246 
  goto ldv_56664;
  ldv_56663: 
#line 3247 
  ;
  
#line 3247 
  (vdev->vpaths + i)->ring.rx_hwts = vdev->rx_hwts;
  
#line 3246 
  i += 1;
  ldv_56664: 
#line 3247 
  ;
  
#line 3246 
  if (vdev->no_of_vpath > i) 
#line 3248 
                             goto ldv_56663; else 
#line 3251 
                                                  goto ldv_56665;
  ldv_56665: 
#line 3252 
  ;
  
#line 3249 
  tmp_0 = copy_to_user(data,(void const *)(& config),12UL);
  
#line 3249 
  if (tmp_0 != 0UL) {
    
#line 3250 
    __retres = -14;
    
#line 3250 
    goto return_label;
  }
  else ;
  
#line 3252 
  __retres = 0;
  return_label: 
#line 3252 
                return __retres;
}


#line 3255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_hwtstamp_get(struct vxgedev *vdev, void *data)
{
  int __retres;
  struct hwtstamp_config config;
  unsigned long tmp;
  
#line 3259 
  config.flags = 0;
  
#line 3260 
  config.tx_type = 0;
  
#line 3261 
  config.rx_filter = (int)*((unsigned char *)vdev + 1466UL) & 1;
  
#line 3264 
  tmp = copy_to_user(data,(void const *)(& config),12UL);
  
#line 3264 
  if (tmp != 0UL) {
    
#line 3265 
    __retres = -14;
    
#line 3265 
    goto return_label;
  }
  else ;
  
#line 3267 
  __retres = 0;
  return_label: 
#line 3267 
                return __retres;
}


#line 3280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
  int __retres;
  
#line 3282 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 3284 
  switch (cmd) {
    int tmp_0;
    int tmp_1;
    case 35248: 
#line 3285 
    ;
    
#line 3286 
    tmp_0 = vxge_hwtstamp_set(vdev,rq->ifr_ifru.ifru_data);
    
#line 3286 
    __retres = tmp_0;
    
#line 3286 
    goto return_label;
    case 35249: 
#line 3287 
    ;
    
#line 3288 
    tmp_1 = vxge_hwtstamp_get(vdev,rq->ifr_ifru.ifru_data);
    
#line 3288 
    __retres = tmp_1;
    
#line 3288 
    goto return_label;
    default: 
#line 3289 
    ;
    
#line 3290 
    __retres = -95;
    
#line 3290 
    goto return_label;
  }
  return_label: 
#line 3284 
                return __retres;
}


#line 3302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_tx_watchdog(struct net_device *dev)
{
  struct vxgedev *vdev;
  
#line 3306 
  printk("%s:%d","vxge_tx_watchdog",3306);
  
#line 3308 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)dev);
  
#line 3310 
  vdev->cric_err_event = VXGE_HW_EVENT_RESET_START;
  
#line 3312 
  ldv_schedule_work_84(& vdev->reset_task);
  
#line 3313 
  printk("%s:%d  Exiting...","vxge_tx_watchdog",3314);
  
#line 3314 
  return;
}


#line 3326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)
{
  int __retres;
  struct vxge_vpath *vpath;
  int vp_id;
  
#line 3328 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 3333 
  vp_id = 0;
  
#line 3333 
  goto ldv_56695;
  ldv_56694: 
#line 3334 
  ;
  
#line 3334 
  vpath = vdev->vpaths + vp_id;
  
#line 3335 
  if (vpath->is_open == 0) 
#line 3336 
                           goto ldv_56693; else ;
  
#line 3337 
  vxge_hw_vpath_vid_add(vpath->handle,(unsigned long long)vid);
  ldv_56693: 
#line 3338 
  ;
  
#line 3333 
  vp_id += 1;
  ldv_56695: 
#line 3334 
  ;
  
#line 3333 
  if (vdev->no_of_vpath > vp_id) 
#line 3335 
                                 goto ldv_56694; else 
#line 3338 
                                                      goto ldv_56696;
  ldv_56696: 
#line 3339 
  ;
  
#line 3339 
  set_bit((long)vid,(unsigned long volatile *)(& vdev->active_vlans));
  
#line 3340 
  __retres = 0;
  
#line 3340 
  return __retres;
}


#line 3352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)
{
  int __retres;
  struct vxge_vpath *vpath;
  int vp_id;
  
#line 3354 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 3358 
  printk("%s:%d","vxge_vlan_rx_kill_vid",3358);
  
#line 3361 
  vp_id = 0;
  
#line 3361 
  goto ldv_56708;
  ldv_56707: 
#line 3362 
  ;
  
#line 3362 
  vpath = vdev->vpaths + vp_id;
  
#line 3363 
  if (vpath->is_open == 0) 
#line 3364 
                           goto ldv_56706; else ;
  
#line 3365 
  vxge_hw_vpath_vid_delete(vpath->handle,(unsigned long long)vid);
  ldv_56706: 
#line 3366 
  ;
  
#line 3361 
  vp_id += 1;
  ldv_56708: 
#line 3362 
  ;
  
#line 3361 
  if (vdev->no_of_vpath > vp_id) 
#line 3363 
                                 goto ldv_56707; else 
#line 3366 
                                                      goto ldv_56709;
  ldv_56709: 
#line 3367 
  ;
  
#line 3367 
  printk("%s:%d  Exiting...","vxge_vlan_rx_kill_vid",3368);
  
#line 3369 
  set_bit((long)vid,(unsigned long volatile *)(& vdev->active_vlans));
  
#line 3370 
  __retres = 0;
  
#line 3370 
  return __retres;
}


#line 3373  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static struct net_device_ops const vxge_netdev_ops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & vxge_open, .ndo_stop = & vxge_close, .ndo_start_xmit = & vxge_xmit, .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & vxge_set_multicast, .ndo_set_mac_address = & vxge_set_mac_addr, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & vxge_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & vxge_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = & vxge_tx_watchdog, .ndo_get_stats64 = & vxge_get_stats64, .ndo_get_stats = (struct net_device_stats *(*)(struct net_device *))0, .ndo_vlan_rx_add_vid = & vxge_vlan_rx_add_vid, .ndo_vlan_rx_kill_vid = & vxge_vlan_rx_kill_vid, .ndo_poll_controller = & vxge_netpoll, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = (int (*)(struct napi_struct *))0, .ndo_set_vf_mac = (int (*)(struct net_device *, int , u8 *))0, .ndo_set_vf_vlan = (int (*)(struct net_device *, int , u16 , u8 ))0, .ndo_set_vf_rate = (int (*)(struct net_device *, int , int , int ))0, .ndo_set_vf_spoofchk = (int (*)(struct net_device *, int , bool ))0, .ndo_get_vf_config = (int (*)(struct net_device *, int , struct ifla_vf_info *))0, .ndo_set_vf_link_state = (int (*)(struct net_device *, int , int ))0, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = (int (*)(struct net_device *, u8 ))0, .ndo_fcoe_enable = (int (*)(struct net_device *))0, .ndo_fcoe_disable = (int (*)(struct net_device *))0, .ndo_fcoe_ddp_setup = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_ddp_done = (int (*)(struct net_device *, u16 ))0, .ndo_fcoe_ddp_target = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = (int (*)(struct net_device *, struct sk_buff const *, u16 , u32 ))0, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = & vxge_fix_features, .ndo_set_features = & vxge_set_features, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ))0, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = (int (*)(struct net_device *, struct netdev_phys_item_id *))0, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_del_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_dfwd_add_station = (void *(*)(struct net_device *, struct net_device *))0, .ndo_dfwd_del_station = (void (*)(struct net_device *, void *))0, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = (netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t ))0, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 3393  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_device_register(struct __vxge_hw_device *hldev, struct vxge_config *config, int high_dma, int no_of_vpath, struct vxgedev **vdev_out)
{
  int __retres;
  struct net_device *ndev;
  struct vxgedev *vdev;
  u64 stat;
  u32 tmp_1;
  u32 tmp_5;
  u32 tmp_11;
  u32 tmp_15;
  
#line 3398 
  enum vxge_hw_status status = 0;
  
#line 3400 
  int ret = 0;
  
#line 3400 
  int no_of_queue = 1;
  
#line 3403 
  *vdev_out = (struct vxgedev *)0;
  
#line 3404 
  if (config->tx_steering_type != 0) 
#line 3405 
                                     no_of_queue = no_of_vpath; else ;
  
#line 3407 
  ndev = ldv_alloc_etherdev_mqs_85(7576,(unsigned int)no_of_queue,(unsigned int)no_of_queue);
  
#line 3409 
  if (ndev == (struct net_device *)0) {
    u32 tmp;
    
#line 3410 
    tmp = vxge_hw_device_trace_level_get(hldev);
    
#line 3410 
    if (tmp > 1U) 
#line 3410 
                  printk("%s : device allocation failed","vxge_device_register");
    else {
      u32 tmp_0;
      
#line 3410 
      tmp_0 = vxge_hw_device_trace_level_get(hldev);
      
#line 3410 
      if (tmp_0 != 0U) 
#line 3410 
                       printk("%s : device allocation failed","vxge_device_register"); else ;
    }
    
#line 3413 
    ret = -19;
    
#line 3414 
    goto _out0;
  }
  else ;
  
#line 3417 
  tmp_1 = vxge_hw_device_trace_level_get(hldev);
  
#line 3417 
  if (tmp_1 > 1U) 
#line 3417 
                  printk("%s: %s:%d  Entering...",(char *)(& ndev->name),"vxge_device_register",3420);
  else {
    u32 tmp_2;
    
#line 3417 
    tmp_2 = vxge_hw_device_trace_level_get(hldev);
    
#line 3417 
    if (tmp_2 != 0U) 
#line 3417 
                     printk("%s: %s:%d  Entering...",(char *)(& ndev->name),"vxge_device_register",3420); else ;
  }
  
#line 3422 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)ndev);
  
#line 3423 
  memset((void *)vdev,0,7576UL);
  
#line 3425 
  vdev->ndev = ndev;
  
#line 3426 
  vdev->devh = hldev;
  
#line 3427 
  vdev->pdev = hldev->pdev;
  
#line 3428 
  memcpy((void *)(& vdev->config),(void const *)config,648UL);
  
#line 3429 
  vdev->rx_hwts = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 3430 
  vdev->titan1 = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))((unsigned int)(vdev->pdev)->revision == 1U);
  
#line 3432 
  ndev->dev.parent = & (vdev->pdev)->dev;
  
#line 3434 
  ndev->hw_features = 17180983443ULL;
  
#line 3438 
  if ((unsigned int)*((unsigned char *)(& vdev->config) + 20UL) != 0U) 
    
#line 3439 
    ndev->hw_features |= 8589934592ULL; else ;
  
#line 3441 
  ndev->features = (ndev->features | ndev->hw_features) | 768ULL;
  
#line 3445 
  ndev->netdev_ops = & vxge_netdev_ops;
  
#line 3447 
  ndev->watchdog_timeo = 3750;
  {
    struct lock_class_key __key;
    
#line 3448 
    __init_work(& vdev->reset_task,0);
    
#line 3448 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 3448 
    vdev->reset_task.data = __constr_expr_37;
    
#line 3448 
    lockdep_init_map(& vdev->reset_task.lockdep_map,"(&vdev->reset_task)",& __key,0);
    
#line 3448 
    INIT_LIST_HEAD(& vdev->reset_task.entry);
    
#line 3448 
    vdev->reset_task.func = & vxge_reset;
  }
  
#line 3450 
  vxge_initialize_ethtool_ops(ndev);
  
#line 3453 
  vdev->vpaths = (struct vxge_vpath *)kzalloc_0((unsigned long)no_of_vpath * 704UL,208U);
  
#line 3455 
  if (vdev->vpaths == (struct vxge_vpath *)0) {
    
#line 3456 
    printk("%s: vpath memory allocation failed",(char *)(& (vdev->ndev)->name));
    
#line 3459 
    ret = -12;
    
#line 3460 
    goto _out1;
  }
  else ;
  
#line 3463 
  tmp_5 = vxge_hw_device_trace_level_get(hldev);
  
#line 3463 
  if (tmp_5 > 1U) 
#line 3463 
                  printk("%s : checksumming enabled","vxge_device_register");
  else {
    u32 tmp_6;
    
#line 3463 
    tmp_6 = vxge_hw_device_trace_level_get(hldev);
    
#line 3463 
    if (tmp_6 != 0U) 
#line 3463 
                     printk("%s : checksumming enabled","vxge_device_register"); else ;
  }
  
#line 3466 
  if (high_dma != 0) {
    u32 tmp_7;
    
#line 3467 
    ndev->features |= 32ULL;
    
#line 3468 
    tmp_7 = vxge_hw_device_trace_level_get(hldev);
    
#line 3468 
    if (tmp_7 > 1U) 
#line 3468 
                    printk("%s : using High DMA","vxge_device_register");
    else {
      u32 tmp_8;
      
#line 3468 
      tmp_8 = vxge_hw_device_trace_level_get(hldev);
      
#line 3468 
      if (tmp_8 != 0U) 
#line 3468 
                       printk("%s : using High DMA","vxge_device_register"); else ;
    }
  }
  else ;
  
#line 3472 
  ret = ldv_register_netdev_86(ndev);
  
#line 3473 
  if (ret != 0) {
    u32 tmp_9;
    
#line 3474 
    tmp_9 = vxge_hw_device_trace_level_get(hldev);
    
#line 3474 
    if (tmp_9 > 1U) 
#line 3474 
                    printk("%s: %s : device registration failed!",(char *)(& ndev->name),"vxge_device_register");
    else {
      u32 tmp_10;
      
#line 3474 
      tmp_10 = vxge_hw_device_trace_level_get(hldev);
      
#line 3474 
      if (tmp_10 != 0U) 
#line 3474 
                        printk("%s: %s : device registration failed!",(char *)(& ndev->name),"vxge_device_register"); else ;
    }
    
#line 3477 
    goto _out2;
  }
  else ;
  
#line 3481 
  ndev->addr_len = (unsigned char)6U;
  
#line 3487 
  netif_carrier_off(ndev);
  
#line 3489 
  tmp_11 = vxge_hw_device_trace_level_get(hldev);
  
#line 3489 
  if (tmp_11 > 1U) 
#line 3489 
                   printk("%s: Ethernet device registered",(char *)(& ndev->name));
  else {
    u32 tmp_12;
    
#line 3489 
    tmp_12 = vxge_hw_device_trace_level_get(hldev);
    
#line 3489 
    if (tmp_12 != 0U) 
#line 3489 
                      printk("%s: Ethernet device registered",(char *)(& ndev->name)); else ;
  }
  
#line 3493 
  hldev->ndev = ndev;
  
#line 3494 
  *vdev_out = vdev;
  
#line 3497 
  status = vxge_hw_mrpcim_stats_access(hldev,3U,0U,0U,& stat);
  
#line 3504 
  if (status == VXGE_HW_ERR_PRIVILAGED_OPEARATION) {
    u32 tmp_13;
    
#line 3505 
    tmp_13 = vxge_hw_device_trace_level_get(hldev);
    
#line 3505 
    if (tmp_13 > 1U) 
#line 3505 
                     printk("%s: device stats clear returns",(char *)(& ndev->name));
    else {
      u32 tmp_14;
      
#line 3505 
      tmp_14 = vxge_hw_device_trace_level_get(hldev);
      
#line 3505 
      if (tmp_14 != 0U) 
#line 3505 
                        printk("%s: device stats clear returns",(char *)(& ndev->name)); else ;
    }
  }
  else ;
  
#line 3510 
  tmp_15 = vxge_hw_device_trace_level_get(hldev);
  
#line 3510 
  if (tmp_15 > 1U) 
#line 3510 
                   printk("%s: %s:%d  Exiting...",(char *)(& ndev->name),"vxge_device_register",3512);
  else {
    u32 tmp_16;
    
#line 3510 
    tmp_16 = vxge_hw_device_trace_level_get(hldev);
    
#line 3510 
    if (tmp_16 != 0U) 
#line 3510 
                      printk("%s: %s:%d  Exiting...",(char *)(& ndev->name),"vxge_device_register",3512); else ;
  }
  
#line 3514 
  __retres = ret;
  
#line 3514 
  goto return_label;
  _out2: 
#line 3515 
  ;
  
#line 3516 
  kfree((void const *)vdev->vpaths);
  _out1: 
#line 3517 
  ;
  
#line 3518 
  ldv_free_netdev_87(ndev);
  _out0: 
#line 3519 
  ;
  
#line 3520 
  __retres = ret;
  return_label: 
#line 3520 
                return __retres;
}


#line 3528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_device_unregister(struct __vxge_hw_device *hldev)
{
  struct vxgedev *vdev;
  struct net_device *dev;
  char buf[16U];
  
#line 3534 
  dev = hldev->ndev;
  
#line 3535 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)dev);
  
#line 3537 
  if (vdev->level_trace != 0U) 
#line 3537 
                               printk("%s: %s:%d",(char *)(& (vdev->ndev)->name),"vxge_device_unregister",3538); else ;
  
#line 3540 
  strlcpy((char *)(& buf),(char const *)(& dev->name),16UL);
  
#line 3542 
  ldv_flush_work_88(& vdev->reset_task);
  
#line 3545 
  ldv_unregister_netdev_89(dev);
  
#line 3547 
  kfree((void const *)vdev->vpaths);
  
#line 3550 
  ldv_free_netdev_90(dev);
  
#line 3552 
  if (vdev->level_trace != 0U) 
#line 3552 
                               printk("%s: ethernet device unregistered",(char *)(& buf)); else ;
  
#line 3554 
  if (vdev->level_trace != 0U) 
#line 3554 
                               printk("%s: %s:%d  Exiting...",(char *)(& buf),"vxge_device_unregister",3555); else ;
  
#line 3555 
  return;
}


#line 3565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_callback_crit_err(struct __vxge_hw_device *hldev, enum vxge_hw_event type, u64 vp_id)
{
  int vpath_idx;
  int tmp_0;
  
#line 3568 
  struct net_device *dev = hldev->ndev;
  
#line 3569 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)dev);
  
#line 3570 
  struct vxge_vpath *vpath = (struct vxge_vpath *)0;
  
#line 3573 
  if (vdev->level_trace != 0U) 
#line 3573 
                               printk("%s: %s:%d",(char *)(& (vdev->ndev)->name),"vxge_callback_crit_err",3574); else ;
  
#line 3579 
  vdev->cric_err_event = type;
  
#line 3581 
  vpath_idx = 0;
  
#line 3581 
  goto ldv_56749;
  ldv_56748: 
#line 3582 
  ;
  
#line 3582 
  vpath = vdev->vpaths + vpath_idx;
  
#line 3583 
  if ((unsigned long long)vpath->device_id == vp_id) 
#line 3584 
                                                     goto ldv_56747; else ;
  
#line 3581 
  vpath_idx += 1;
  ldv_56749: 
#line 3582 
  ;
  
#line 3581 
  if (vdev->no_of_vpath > vpath_idx) 
#line 3583 
                                     goto ldv_56748; else 
#line 3586 
                                                          goto ldv_56747;
  ldv_56747: 
#line 3587 
  ;
  
#line 3587 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vdev->state));
  
#line 3587 
  if (tmp_0 == 0) {
    
#line 3588 
    if (type == (unsigned int)VXGE_HW_EVENT_SLOT_FREEZE) 
#line 3589 
                                                         printk("%s: Slot is frozen",(char *)(& (vdev->ndev)->name));
    else 
      
#line 3591 
      if (type == (unsigned int)VXGE_HW_EVENT_SERR) 
#line 3592 
                                                    printk("%s: Encountered Serious Error",(char *)(& (vdev->ndev)->name));
      else 
        
#line 3595 
        if (type == (unsigned int)VXGE_HW_EVENT_CRITICAL_ERR) 
#line 3596 
                                                              printk("%s: Encountered Critical Error",(char *)(& (vdev->ndev)->name)); else ;
  }
  else ;
  
#line 3601 
  if (type == (unsigned int)VXGE_HW_EVENT_SERR || type == (unsigned int)VXGE_HW_EVENT_SLOT_FREEZE) {
    
#line 3603 
    if ((long)(vdev->exec_mode != 0) != 0L) 
#line 3604 
                                            set_bit(1L,(unsigned long volatile *)(& vdev->state)); else ;
  }
  else 
    
#line 3605 
    if (type == (unsigned int)VXGE_HW_EVENT_CRITICAL_ERR) {
      
#line 3606 
      vxge_hw_device_mask_all(hldev);
      
#line 3607 
      if ((long)(vdev->exec_mode != 0) != 0L) 
#line 3608 
                                              set_bit(1L,(unsigned long volatile *)(& vdev->state)); else ;
    }
    else 
      
#line 3609 
      if ((unsigned int)type + 4294967288U <= 1U) 
        
#line 3612 
        if ((long)(vdev->exec_mode != 0) != 0L) 
#line 3613 
                                                set_bit(1L,(unsigned long volatile *)(& vdev->state));
        else {
          int tmp_1;
          
#line 3616 
          tmp_1 = test_and_set_bit((long)vpath_idx,(unsigned long volatile *)(& vdev->vp_reset));
          
#line 3616 
          if (tmp_1 == 0) {
            
#line 3619 
            vxge_vpath_intr_disable(vdev,vpath_idx);
            
#line 3622 
            netif_tx_start_queue(vpath->fifo.txq);
          }
          else ;
        }
      else ;
  
#line 3627 
  if (vdev->level_trace != 0U) 
#line 3627 
                               printk("%s: %s:%d  Exiting...",(char *)(& (vdev->ndev)->name),"vxge_callback_crit_err",3629); else ;
  
#line 3628 
  return;
}


#line 3632  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void verify_bandwidth(void)
{
  int i;
  int band_width;
  
#line 3634 
  int total = 0;
  
#line 3634 
  int equal_priority = 0;
  
#line 3637 
  i = 0;
  
#line 3637 
  goto ldv_56759;
  ldv_56758: 
#line 3638 
  ;
  
#line 3638 
  if (bw_percentage[i] == 0U) {
    
#line 3639 
    equal_priority = 1;
    
#line 3640 
    goto ldv_56757;
  }
  else ;
  
#line 3637 
  i += 1;
  ldv_56759: 
#line 3638 
  ;
  
#line 3637 
  if (i <= 16) 
#line 3639 
               goto ldv_56758; else 
#line 3642 
                                    goto ldv_56757;
  ldv_56757: 
#line 3643 
  ;
  
#line 3644 
  if (equal_priority == 0) {
    
#line 3646 
    i = 0;
    
#line 3646 
    goto ldv_56762;
    ldv_56761: 
#line 3647 
    ;
    
#line 3647 
    if (bw_percentage[i] == 255U) 
#line 3648 
                                  goto ldv_56760; else ;
    
#line 3650 
    total = (int)(bw_percentage[i] + (unsigned int)total);
    
#line 3651 
    if (total > 100) {
      
#line 3652 
      equal_priority = 1;
      
#line 3653 
      goto ldv_56760;
    }
    else ;
    
#line 3646 
    i += 1;
    ldv_56762: 
#line 3647 
    ;
    
#line 3646 
    if (i <= 16) 
#line 3648 
                 goto ldv_56761; else 
#line 3651 
                                      goto ldv_56760;
    ldv_56760: 
#line 3652 
    ;
  }
  else ;
  
#line 3658 
  if (equal_priority == 0) {
    
#line 3660 
    if (total <= 99) {
      
#line 3661 
      if (i <= 16) {
        
#line 3663 
        band_width = (100 - total) / (17 - i);
        
#line 3666 
        if (band_width <= 1) 
#line 3667 
                             equal_priority = 1;
        else {
          
#line 3669 
          goto ldv_56764;
          ldv_56763: 
#line 3670 
          ;
          
#line 3671 
          bw_percentage[i] = (unsigned int)band_width;
          
#line 3670 
          i += 1;
          ldv_56764: 
#line 3671 
          ;
          
#line 3669 
          if (i <= 16) 
#line 3671 
                       goto ldv_56763; else 
#line 3674 
                                            goto ldv_56765;
          ldv_56765: 
#line 3675 
          ;
        }
      }
      else ;
    }
    else 
      
#line 3675 
      if (i <= 16) 
#line 3676 
                   equal_priority = 1; else ;
  }
  else ;
  
#line 3679 
  if (equal_priority != 0) {
    
#line 3680 
    printk("%s: Assigning equal bandwidth to all the vpaths",(char *)"vxge");
    
#line 3683 
    bw_percentage[0] = 5U;
    
#line 3685 
    i = 1;
    
#line 3685 
    goto ldv_56767;
    ldv_56766: 
#line 3686 
    ;
    
#line 3686 
    bw_percentage[i] = bw_percentage[0];
    
#line 3685 
    i += 1;
    ldv_56767: 
#line 3686 
    ;
    
#line 3685 
    if (i <= 16) 
#line 3687 
                 goto ldv_56766; else 
#line 3690 
                                      goto ldv_56768;
    ldv_56768: 
#line 3691 
    ;
  }
  else ;
  
#line 3693 
  return;
}


#line 3693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_config_vpaths(struct vxge_hw_device_config *device_config, u64 vpath_mask, struct vxge_config *config_param)
{
  int __retres;
  int i;
  int temp;
  u32 txdl_size;
  u32 txdl_per_memblock;
  
#line 3696 
  int no_of_vpaths = 0;
  
#line 3696 
  int default_no_vpath = 0;
  
#line 3699 
  temp = (int)driver_config->vpath_per_dev;
  
#line 3700 
  if (driver_config->vpath_per_dev == 4294967295U && max_config_dev == 255) {
    
#line 3703 
    if (driver_config->g_no_cpus == -1) {
      
#line 3704 
      __retres = 0;
      
#line 3704 
      goto return_label;
    }
    else ;
    
#line 3706 
    if (driver_config->g_no_cpus == 0) 
#line 3707 
                                       driver_config->g_no_cpus = netif_get_num_default_rss_queues(); else ;
    
#line 3710 
    driver_config->vpath_per_dev = (unsigned int)(driver_config->g_no_cpus >> 1);
    
#line 3711 
    if (driver_config->vpath_per_dev == 0U) 
#line 3712 
                                            driver_config->vpath_per_dev = 1U; else ;
    
#line 3714 
    i = 0;
    
#line 3714 
    goto ldv_56782;
    ldv_56781: 
#line 3715 
    ;
    
#line 3715 
    if (((vpath_mask >> (63 - i)) & 1ULL) == 0ULL) 
#line 3716 
                                                   goto ldv_56780; else 
                                                                    
#line 3718 
                                                                    default_no_vpath += 1;
    ldv_56780: 
#line 3719 
    ;
    
#line 3714 
    i += 1;
    ldv_56782: 
#line 3715 
    ;
    
#line 3714 
    if (i <= 16) 
#line 3716 
                 goto ldv_56781; else 
#line 3719 
                                      goto ldv_56783;
    ldv_56783: 
#line 3720 
    ;
    
#line 3719 
    if (driver_config->vpath_per_dev > (unsigned int)default_no_vpath) 
      
#line 3720 
      driver_config->vpath_per_dev = (unsigned int)default_no_vpath; else ;
    
#line 3722 
    driver_config->g_no_cpus = (int)((unsigned int)driver_config->g_no_cpus - driver_config->vpath_per_dev * 2U);
    
#line 3724 
    if (driver_config->g_no_cpus <= 0) 
#line 3725 
                                       driver_config->g_no_cpus = -1; else ;
  }
  else ;
  
#line 3728 
  if (driver_config->vpath_per_dev == 1U) {
    
#line 3729 
    printk("%s: Disable tx and rx steering, ",(char *)"vxge");
    
#line 3732 
    config_param->rth_steering = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
    
#line 3733 
    config_param->tx_steering_type = 0;
    
#line 3734 
    device_config->rth_en = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  }
  else ;
  
#line 3738 
  i = 0;
  
#line 3738 
  goto ldv_56785;
  ldv_56784: 
#line 3739 
  ;
  
#line 3739 
  device_config->vp_config[i].min_bandwidth = bw_percentage[i];
  
#line 3738 
  i += 1;
  ldv_56785: 
#line 3739 
  ;
  
#line 3738 
  if (i <= 16) 
#line 3740 
               goto ldv_56784; else 
#line 3743 
                                    goto ldv_56786;
  ldv_56786: 
#line 3744 
  ;
  
#line 3741 
  i = 0;
  
#line 3741 
  goto ldv_56790;
  ldv_56789: 
#line 3742 
  ;
  
#line 3742 
  device_config->vp_config[i].vp_id = (unsigned int)i;
  
#line 3743 
  device_config->vp_config[i].mtu = 1500U;
  
#line 3744 
  if (driver_config->vpath_per_dev > (unsigned int)no_of_vpaths) 
    
#line 3745 
    if (((vpath_mask >> (63 - i)) & 1ULL) == 0ULL) {
      
#line 3746 
      printk("%s: vpath: %d is not available",(char *)"vxge",i);
      
#line 3749 
      goto ldv_56787;
    }
    else {
      
#line 3751 
      printk("%s: vpath: %d available",(char *)"vxge",i);
      
#line 3754 
      no_of_vpaths += 1;
    }
  else {
    
#line 3757 
    printk("%s: vpath: %d is not configured, ",(char *)"vxge",i);
    
#line 3761 
    goto ldv_56788;
  }
  
#line 3765 
  device_config->vp_config[i].fifo.enable = 1U;
  
#line 3767 
  device_config->vp_config[i].fifo.max_frags = 18U;
  
#line 3769 
  device_config->vp_config[i].fifo.memblock_size = 4096U;
  
#line 3772 
  txdl_size = device_config->vp_config[i].fifo.max_frags * 32U;
  
#line 3774 
  txdl_per_memblock = 4096U / txdl_size;
  
#line 3776 
  device_config->vp_config[i].fifo.fifo_blocks = 83U / txdl_per_memblock + 1U;
  
#line 3779 
  device_config->vp_config[i].fifo.intr = 0U;
  
#line 3783 
  device_config->vp_config[i].tti.intr_enable = 1U;
  
#line 3786 
  device_config->vp_config[i].tti.btimer_val = 919117U;
  
#line 3789 
  device_config->vp_config[i].tti.timer_ac_en = 1U;
  
#line 3795 
  device_config->vp_config[i].tti.timer_ci_en = 0U;
  
#line 3798 
  device_config->vp_config[i].tti.timer_ri_en = 0U;
  
#line 3801 
  device_config->vp_config[i].tti.util_sel = 17U;
  
#line 3804 
  device_config->vp_config[i].tti.ltimer_val = 3676U;
  
#line 3807 
  device_config->vp_config[i].tti.rtimer_val = 0U;
  
#line 3810 
  device_config->vp_config[i].tti.urange_a = 5U;
  
#line 3811 
  device_config->vp_config[i].tti.urange_b = 15U;
  
#line 3812 
  device_config->vp_config[i].tti.urange_c = 40U;
  
#line 3813 
  device_config->vp_config[i].tti.uec_a = 5U;
  
#line 3814 
  device_config->vp_config[i].tti.uec_b = 40U;
  
#line 3815 
  device_config->vp_config[i].tti.uec_c = 60U;
  
#line 3816 
  device_config->vp_config[i].tti.uec_d = 100U;
  
#line 3819 
  device_config->vp_config[i].ring.enable = 1U;
  
#line 3822 
  device_config->vp_config[i].ring.ring_blocks = 2U;
  
#line 3825 
  device_config->vp_config[i].ring.buffer_mode = 1U;
  
#line 3828 
  device_config->vp_config[i].ring.rxds_limit = 44ULL;
  
#line 3831 
  device_config->vp_config[i].ring.scatter_mode = 0U;
  
#line 3835 
  device_config->vp_config[i].rti.intr_enable = 1U;
  
#line 3838 
  device_config->vp_config[i].rti.btimer_val = 919U;
  
#line 3841 
  device_config->vp_config[i].rti.timer_ac_en = 1U;
  
#line 3844 
  device_config->vp_config[i].rti.timer_ci_en = 0U;
  
#line 3847 
  device_config->vp_config[i].rti.timer_ri_en = 0U;
  
#line 3850 
  device_config->vp_config[i].rti.util_sel = 18U;
  
#line 3853 
  device_config->vp_config[i].rti.urange_a = 5U;
  
#line 3855 
  device_config->vp_config[i].rti.urange_b = 15U;
  
#line 3857 
  device_config->vp_config[i].rti.urange_c = 40U;
  
#line 3859 
  device_config->vp_config[i].rti.uec_a = 1U;
  
#line 3860 
  device_config->vp_config[i].rti.uec_b = 5U;
  
#line 3861 
  device_config->vp_config[i].rti.uec_c = 10U;
  
#line 3862 
  device_config->vp_config[i].rti.uec_d = 15U;
  
#line 3864 
  device_config->vp_config[i].rti.rtimer_val = 0U;
  
#line 3867 
  device_config->vp_config[i].rti.ltimer_val = 367U;
  
#line 3870 
  device_config->vp_config[i].rpa_strip_vlan_tag = (unsigned int)vlan_tag_strip;
  ldv_56787: 
#line 3871 
  ;
  
#line 3741 
  i += 1;
  ldv_56790: 
#line 3742 
  ;
  
#line 3741 
  if (i <= 16) 
#line 3743 
               goto ldv_56789; else 
#line 3746 
                                    goto ldv_56788;
  ldv_56788: 
#line 3747 
  ;
  
#line 3874 
  driver_config->vpath_per_dev = (unsigned int)temp;
  
#line 3875 
  __retres = no_of_vpaths;
  return_label: 
#line 3875 
                return __retres;
}


#line 3879  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_device_config_init(struct vxge_hw_device_config *device_config, int *intr_type)
{
  
#line 3883 
  device_config->dma_blockpool_initial = 0U;
  
#line 3886 
  device_config->dma_blockpool_max = 4096U;
  
#line 3889 
  if (max_mac_vpath > 30) 
#line 3890 
                          max_mac_vpath = 30; else ;
  
#line 3900 
  switch (*intr_type) {
    case 0: 
#line 3901 
    ;
    
#line 3902 
    device_config->intr_mode = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
    
#line 3903 
    goto ldv_56796;
    case 2: 
#line 3905 
    ;
    
#line 3906 
    device_config->intr_mode = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U;
    
#line 3907 
    goto ldv_56796;
  }
  ldv_56796: 
#line 3911 
  ;
  
#line 3911 
  device_config->device_poll_millis = 10000U;
  
#line 3914 
  device_config->rts_mac_en = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))addr_learn_en;
  
#line 3917 
  device_config->rth_it_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  
#line 3919 
  printk("%s : Device Config Params ","vxge_device_config_init");
  
#line 3921 
  printk("intr_mode : %d",(int)device_config->intr_mode);
  
#line 3923 
  printk("device_poll_millis : %d",device_config->device_poll_millis);
  
#line 3925 
  printk("rth_en : %d",(int)device_config->rth_en);
  
#line 3927 
  printk("rth_it_type : %d",(int)device_config->rth_it_type);
  
#line 3928 
  return;
}


#line 3931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_print_parm(struct vxgedev *vdev, u64 vpath_mask)
{
  int i;
  char *tmp;
  
#line 3935 
  printk("%s: %d Vpath(s) opened",(char *)(& (vdev->ndev)->name),vdev->no_of_vpath);
  
#line 3939 
  switch (vdev->config.intr_type) {
    case 0: 
#line 3940 
    ;
    
#line 3941 
    printk("%s: Interrupt type INTA",(char *)(& (vdev->ndev)->name));
    
#line 3943 
    goto ldv_56805;
    case 2: 
#line 3945 
    ;
    
#line 3946 
    printk("%s: Interrupt type MSI-X",(char *)(& (vdev->ndev)->name));
    
#line 3948 
    goto ldv_56805;
  }
  ldv_56805: 
#line 3951 
  ;
  
#line 3951 
  if ((unsigned int)*((unsigned char *)(& vdev->config) + 20UL) != 0U) 
    
#line 3952 
    printk("%s: RTH steering enabled for TCP_IPV4",(char *)(& (vdev->ndev)->name)); else 
                                                                    
#line 3956 
                                                                    printk("%s: RTH steering disabled",(char *)(& (vdev->ndev)->name));
  
#line 3960 
  switch (vdev->config.tx_steering_type) {
    case 0: 
#line 3961 
    ;
    
#line 3962 
    printk("%s: Tx steering disabled",(char *)(& (vdev->ndev)->name));
    
#line 3964 
    goto ldv_56808;
    case 1: 
#line 3965 
    ;
    
#line 3966 
    printk("%s: Unsupported tx steering option",(char *)(& (vdev->ndev)->name));
    
#line 3969 
    printk("%s: Tx steering disabled",(char *)(& (vdev->ndev)->name));
    
#line 3971 
    vdev->config.tx_steering_type = 0;
    
#line 3972 
    goto ldv_56808;
    case 2: 
#line 3973 
    ;
    
#line 3974 
    printk("%s: Unsupported tx steering option",(char *)(& (vdev->ndev)->name));
    
#line 3977 
    printk("%s: Tx steering disabled",(char *)(& (vdev->ndev)->name));
    
#line 3979 
    vdev->config.tx_steering_type = 0;
    
#line 3980 
    goto ldv_56808;
    case 4: 
#line 3981 
    ;
    
#line 3982 
    printk("%s: Tx multiqueue steering enabled",(char *)(& (vdev->ndev)->name));
    
#line 3985 
    goto ldv_56808;
    case 3: 
#line 3986 
    ;
    
#line 3987 
    printk("%s: Tx port steering enabled",(char *)(& (vdev->ndev)->name));
    
#line 3990 
    goto ldv_56808;
    default: 
#line 3991 
    ;
    
#line 3992 
    printk("%s: Unsupported tx steering type",(char *)(& (vdev->ndev)->name));
    
#line 3995 
    printk("%s: Tx steering disabled",(char *)(& (vdev->ndev)->name));
    
#line 3997 
    vdev->config.tx_steering_type = 0;
  }
  ldv_56808: 
#line 4000 
  ;
  
#line 4000 
  if (vdev->config.addr_learn_en != 0) 
#line 4001 
                                       printk("%s: MAC Address learning enabled",(char *)(& (vdev->ndev)->name)); else ;
  
#line 4004 
  i = 0;
  
#line 4004 
  goto ldv_56817;
  ldv_56816: 
#line 4005 
  ;
  
#line 4005 
  if (((vpath_mask >> (63 - i)) & 1ULL) == 0ULL) 
#line 4006 
                                                 goto ldv_56814; else ;
  
#line 4007 
  printk("%s: MTU size - %d",(char *)(& (vdev->ndev)->name),(vdev->devh)->config.vp_config[i].mtu);
  
#line 4011 
  if ((vdev->devh)->config.vp_config[i].rpa_strip_vlan_tag != 0U) 
#line 4011 
                                                                  tmp = (char *)"Enabled"; else 
                                                                    
#line 4011 
                                                                    tmp = (char *)"Disabled";
  
#line 4011 
  ;
  
#line 4011 
  printk("%s: VLAN tag stripping %s",(char *)(& (vdev->ndev)->name),tmp);
  
#line 4016 
  printk("%s: Max frags : %d",(char *)(& (vdev->ndev)->name),(vdev->devh)->config.vp_config[i].fifo.max_frags);
  
#line 4020 
  goto ldv_56815;
  ldv_56814: 
#line 4021 
  ;
  
#line 4004 
  i += 1;
  ldv_56817: 
#line 4005 
  ;
  
#line 4004 
  if (i <= 16) 
#line 4006 
               goto ldv_56816; else 
#line 4009 
                                    goto ldv_56815;
  ldv_56815: 
#line 4010 
  ;
  
#line 4011 
  return;
}


#line 4029  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_pm_suspend(struct pci_dev *pdev, pm_message_t state)
{
  int __retres;
  
#line 4031 
  __retres = -38;
  
#line 4031 
  return __retres;
}


#line 4037  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_pm_resume(struct pci_dev *pdev)
{
  int __retres;
  
#line 4039 
  __retres = -38;
  
#line 4039 
  return __retres;
}


#line 4052  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static pci_ers_result_t vxge_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
{
  pci_ers_result_t __retres;
  bool tmp_0;
  
#line 4055 
  struct __vxge_hw_device *hldev = pci_get_drvdata(pdev);
  
#line 4056 
  struct net_device *netdev = hldev->ndev;
  
#line 4058 
  netif_device_detach(netdev);
  
#line 4060 
  if (state == 3U) {
    
#line 4061 
    __retres = 4U;
    
#line 4061 
    goto return_label;
  }
  else ;
  
#line 4063 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 4063 
  if ((int)tmp_0 != 0) 
#line 4065 
                       do_vxge_close(netdev,0); else ;
  
#line 4068 
  pci_disable_device(pdev);
  
#line 4070 
  __retres = 3U;
  return_label: 
#line 4070 
                return __retres;
}


#line 4082  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static pci_ers_result_t vxge_io_slot_reset(struct pci_dev *pdev)
{
  pci_ers_result_t __retres;
  int tmp_1;
  
#line 4084 
  struct __vxge_hw_device *hldev = pci_get_drvdata(pdev);
  
#line 4085 
  struct net_device *netdev = hldev->ndev;
  
#line 4087 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)netdev);
  
#line 4089 
  tmp_1 = pci_enable_device(pdev);
  
#line 4089 
  if (tmp_1 != 0) {
    
#line 4090 
    netdev_err((struct net_device const *)netdev,"Cannot re-enable device after reset\n");
    
#line 4091 
    __retres = 4U;
    
#line 4091 
    goto return_label;
  }
  else ;
  
#line 4094 
  pci_set_master(pdev);
  
#line 4095 
  do_vxge_reset(vdev,2);
  
#line 4097 
  __retres = 5U;
  return_label: 
#line 4097 
                return __retres;
}


#line 4107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_io_resume(struct pci_dev *pdev)
{
  bool tmp_1;
  
#line 4109 
  struct __vxge_hw_device *hldev = pci_get_drvdata(pdev);
  
#line 4110 
  struct net_device *netdev = hldev->ndev;
  
#line 4112 
  tmp_1 = netif_running((struct net_device const *)netdev);
  
#line 4112 
  if ((int)tmp_1 != 0) {
    int tmp_0;
    
#line 4113 
    tmp_0 = vxge_open(netdev);
    
#line 4113 
    if (tmp_0 != 0) {
      
#line 4114 
      netdev_err((struct net_device const *)netdev,"Can\'t bring device back up after reset\n");
      
#line 4116 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 4120 
  netif_device_attach(netdev);
  return_label: 
#line 4121 
                return;
}


#line 4123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
__inline static u32 vxge_get_num_vfs(u64 function_mode)
{
  
#line 4125 
  u32 num_functions = 0U;
  
#line 4127 
  switch (function_mode) {
    case (u64)1: 
#line 4128 
    ;
    case (u64)6: 
#line 4129 
    ;
    
#line 4130 
    num_functions = 8U;
    
#line 4131 
    goto ldv_56848;
    case (u64)0: 
#line 4132 
    ;
    
#line 4133 
    num_functions = 1U;
    
#line 4134 
    goto ldv_56848;
    case (u64)2: 
#line 4135 
    ;
    case (u64)3: 
#line 4136 
    ;
    case (u64)5: 
#line 4137 
    ;
    
#line 4138 
    num_functions = 17U;
    
#line 4139 
    goto ldv_56848;
    case (u64)7: 
#line 4140 
    ;
    
#line 4141 
    num_functions = 4U;
    
#line 4142 
    goto ldv_56848;
    case (u64)8: 
#line 4143 
    ;
    
#line 4144 
    num_functions = 2U;
    
#line 4145 
    goto ldv_56848;
    case (u64)4: 
#line 4146 
    ;
    
#line 4147 
    num_functions = 8U;
    
#line 4148 
    goto ldv_56848;
  }
  ldv_56848: 
#line 4150 
  ;
  
#line 4150 
  return num_functions;
}


#line 4153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
int vxge_fw_upgrade(struct vxgedev *vdev, char *fw_name, int override)
{
  u32 maj;
  u32 min;
  u32 bld;
  u32 cmaj;
  u32 cmin;
  u32 cbld;
  enum vxge_hw_status status;
  struct firmware const *fw;
  int ret;
  
#line 4155 
  struct __vxge_hw_device *hldev = vdev->devh;
  
#line 4161 
  ret = request_firmware(& fw,(char const *)fw_name,& (vdev->pdev)->dev);
  
#line 4162 
  if (ret != 0) {
    
#line 4163 
    printk("%s: Firmware file \'%s\' not found",(char *)"vxge",fw_name);
    
#line 4165 
    goto out;
  }
  else ;
  
#line 4169 
  status = vxge_update_fw_image(hldev,fw->data,(int)fw->size);
  
#line 4170 
  if (status != VXGE_HW_OK) {
    
#line 4171 
    printk("%s: FW image download to adapter failed \'%s\'.",(char *)"vxge",fw_name);
    
#line 4174 
    ret = -5;
    
#line 4175 
    goto out;
  }
  else ;
  
#line 4179 
  status = vxge_hw_upgrade_read_version(hldev,& maj,& min,& bld);
  
#line 4180 
  if (status != VXGE_HW_OK) {
    
#line 4181 
    printk("%s: Upgrade read version failed \'%s\'.",(char *)"vxge",fw_name);
    
#line 4184 
    ret = -5;
    
#line 4185 
    goto out;
  }
  else ;
  
#line 4188 
  cmaj = vdev->config.device_hw_info.fw_version.major;
  
#line 4189 
  cmin = vdev->config.device_hw_info.fw_version.minor;
  
#line 4190 
  cbld = vdev->config.device_hw_info.fw_version.build;
  
#line 4195 
  if (((maj << 16) + (min << 8)) + bld == ((cmaj << 16) + (cmin << 8)) + cbld && override == 0) {
    
#line 4197 
    ret = -22;
    
#line 4198 
    goto out;
  }
  else ;
  
#line 4201 
  printk("\001",maj,min,bld);
  
#line 4205 
  status = vxge_hw_flash_fw(hldev);
  
#line 4206 
  if (status != VXGE_HW_OK) {
    
#line 4207 
    printk("%s: Upgrade commit failed \'%s\'.",(char *)"vxge",fw_name);
    
#line 4209 
    ret = -5;
    
#line 4210 
    goto out;
  }
  else ;
  
#line 4213 
  printk("\001");
  out: 
#line 4217 
  ;
  
#line 4218 
  release_firmware(fw);
  
#line 4219 
  return ret;
}


#line 4222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_probe_fw_update(struct vxgedev *vdev)
{
  int __retres;
  u32 maj;
  u32 min;
  u32 bld;
  int ret;
  char *fw_name;
  
#line 4225 
  int gpxe = 0;
  
#line 4228 
  maj = vdev->config.device_hw_info.fw_version.major;
  
#line 4229 
  min = vdev->config.device_hw_info.fw_version.minor;
  
#line 4230 
  bld = vdev->config.device_hw_info.fw_version.build;
  
#line 4232 
  if (((maj << 16) + (min << 8)) + bld == 67585U) {
    
#line 4233 
    __retres = 0;
    
#line 4233 
    goto return_label;
  }
  else ;
  
#line 4238 
  if ((maj << 16) + (min << 8) > 67585U) {
    
#line 4239 
    printk("%s: Firmware newer than last known ",(char *)"vxge");
    
#line 4242 
    __retres = -22;
    
#line 4242 
    goto return_label;
  }
  else ;
  
#line 4248 
  if (((maj << 16) + (min << 8)) + bld <= 66564U) {
    
#line 4249 
    printk("%s: Firmware %d.%d.%d cannot be ",(char *)"vxge",maj,min,bld);
    
#line 4251 
    __retres = -22;
    
#line 4251 
    goto return_label;
  }
  else ;
  
#line 4255 
  if (((maj << 16) + (min << 8)) + bld > 67072U) {
    int i;
    
#line 4257 
    i = 0;
    
#line 4257 
    goto ldv_56884;
    ldv_56883: 
#line 4258 
    ;
    
#line 4258 
    if ((unsigned int)(vdev->devh)->eprom_versions[i] != 0U) {
      
#line 4259 
      gpxe = 1;
      
#line 4260 
      goto ldv_56882;
    }
    else ;
    
#line 4257 
    i += 1;
    ldv_56884: 
#line 4258 
    ;
    
#line 4257 
    if (i <= 7) 
#line 4259 
                goto ldv_56883; else 
#line 4262 
                                     goto ldv_56882;
    ldv_56882: 
#line 4263 
    ;
  }
  else ;
  
#line 4263 
  if (gpxe != 0) 
#line 4264 
                 fw_name = (char *)"vxge/X3fw-pxe.ncf"; else 
#line 4266 
                                                             fw_name = (char *)"vxge/X3fw.ncf";
  
#line 4268 
  ret = vxge_fw_upgrade(vdev,fw_name,0);
  
#line 4272 
  if (ret != -22 && ret != -2) {
    
#line 4273 
    __retres = -5;
    
#line 4273 
    goto return_label;
  }
  else 
#line 4275 
       ret = 0;
  
#line 4277 
  if ((maj << 16) + (min << 8) <= 67583U) {
    
#line 4279 
    printk("%s: Firmware %d.%d.%d is too old to",(char *)"vxge",maj,min,bld);
    
#line 4282 
    __retres = -22;
    
#line 4282 
    goto return_label;
  }
  else ;
  
#line 4285 
  __retres = ret;
  return_label: 
#line 4285 
                return __retres;
}


#line 4288  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int is_sriov_initialized(struct pci_dev *pdev)
{
  int __retres;
  int pos;
  u16 ctrl;
  
#line 4293 
  pos = pci_find_ext_capability(pdev,16);
  
#line 4294 
  if (pos != 0) {
    
#line 4295 
    pci_read_config_word((struct pci_dev const *)pdev,pos + 8,& ctrl);
    
#line 4296 
    if (((int)ctrl & 1) != 0) {
      
#line 4297 
      __retres = 1;
      
#line 4297 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 4299 
  __retres = 0;
  return_label: 
#line 4299 
                return __retres;
}


#line 4302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static struct vxge_hw_uld_cbs const vxge_callbacks = {.link_up = & vxge_callback_link_up, .link_down = & vxge_callback_link_down, .crit_err = & vxge_callback_crit_err};

#line 4320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_probe(struct pci_dev *pdev, struct pci_device_id const *pre)
{
  int __retres;
  struct __vxge_hw_device *hldev;
  enum vxge_hw_status status;
  int ret;
  struct vxgedev *vdev;
  struct vxge_hw_device_attr attr;
  int i;
  int j;
  u8 *macaddr;
  struct vxge_mac_addrs *entry;
  u32 host_type;
  enum vxge_hw_status is_privileged;
  u32 function_mode;
  int tmp_3;
  u16 tmp_6;
  
#line 4325 
  int high_dma = 0;
  
#line 4326 
  u64 vpath_mask = 0ULL;
  
#line 4328 
  struct vxge_config *ll_config = (struct vxge_config *)0;
  
#line 4329 
  struct vxge_hw_device_config *device_config = (struct vxge_hw_device_config *)0;
  
#line 4331 
  int no_of_vpath = 0;
  
#line 4331 
  int max_vpath_supported = 0;
  
#line 4334 
  int bus = -1;
  
#line 4334 
  int device = -1;
  
#line 4336 
  u8 new_device = (unsigned char)0U;
  
#line 4339 
  u32 num_vfs = 0U;
  
#line 4341 
  printk("%s:%d","vxge_probe",4341);
  
#line 4342 
  attr.pdev = pdev;
  
#line 4347 
  if (((int)(pdev->bus)->number != bus || ((pdev->devfn >> 3) & 31U) != (unsigned int)device) && (unsigned int)*((unsigned char *)pdev + 2531UL) == 0U) 
    
#line 4349 
    new_device = (unsigned char)1U; else ;
  
#line 4351 
  bus = (int)(pdev->bus)->number;
  
#line 4352 
  device = (int)(pdev->devfn >> 3) & 31;
  
#line 4354 
  if ((unsigned int)new_device != 0U) {
    
#line 4355 
    if (driver_config->config_dev_cnt != 0 && driver_config->config_dev_cnt != driver_config->total_dev_cnt) 
      
#line 4358 
      printk("%s: Configured %d of %d devices",(char *)"vxge",driver_config->config_dev_cnt,driver_config->total_dev_cnt); else ;
    
#line 4363 
    driver_config->config_dev_cnt = 0;
    
#line 4364 
    driver_config->total_dev_cnt = 0;
  }
  else ;
  
#line 4370 
  driver_config->g_no_cpus = 0;
  
#line 4371 
  driver_config->vpath_per_dev = (unsigned int)max_config_vpath;
  
#line 4373 
  driver_config->total_dev_cnt += 1;
  
#line 4374 
  driver_config->config_dev_cnt += 1;
  
#line 4374 
  ;
  
#line 4374 
  if (driver_config->config_dev_cnt > max_config_dev) {
    
#line 4375 
    ret = 0;
    
#line 4376 
    goto _exit0;
  }
  else ;
  
#line 4379 
  device_config = (struct vxge_hw_device_config *)kzalloc_0(3280UL,208U);
  
#line 4381 
  if (device_config == (struct vxge_hw_device_config *)0) {
    
#line 4382 
    ret = -12;
    
#line 4383 
    printk("device_config : malloc failed %s %d",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c",4385);
    
#line 4386 
    goto _exit0;
  }
  else ;
  
#line 4389 
  ll_config = (struct vxge_config *)kzalloc_0(648UL,208U);
  
#line 4390 
  if (ll_config == (struct vxge_config *)0) {
    
#line 4391 
    ret = -12;
    
#line 4392 
    printk("device_config : malloc failed %s %d",(char *)"/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c",4394);
    
#line 4395 
    goto _exit0;
  }
  else ;
  
#line 4397 
  ll_config->tx_steering_type = 4;
  
#line 4398 
  ll_config->intr_type = 2;
  
#line 4399 
  ll_config->napi_weight = 64;
  
#line 4400 
  ll_config->rth_steering = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U;
  
#line 4403 
  vxge_hw_device_config_default_get(device_config);
  
#line 4406 
  vxge_device_config_init(device_config,& ll_config->intr_type);
  
#line 4408 
  ret = pci_enable_device(pdev);
  
#line 4409 
  if (ret != 0) {
    
#line 4410 
    printk("%s : can not enable PCI device","vxge_probe");
    
#line 4412 
    goto _exit0;
  }
  else ;
  
#line 4415 
  tmp_3 = pci_set_dma_mask(pdev,18446744073709551615ULL);
  
#line 4415 
  if (tmp_3 == 0) {
    int tmp_1;
    
#line 4416 
    printk("%s : using 64bit DMA","vxge_probe");
    
#line 4419 
    high_dma = 1;
    
#line 4421 
    tmp_1 = pci_set_consistent_dma_mask(pdev,18446744073709551615ULL);
    
#line 4421 
    if (tmp_1 != 0) {
      
#line 4423 
      printk("%s : unable to obtain 64bit DMA for ","vxge_probe");
      
#line 4426 
      ret = -12;
      
#line 4427 
      goto _exit1;
    }
    else ;
  }
  else {
    int tmp_2;
    
#line 4429 
    tmp_2 = pci_set_dma_mask(pdev,4294967295ULL);
    
#line 4429 
    if (tmp_2 == 0) 
#line 4430 
                    printk("%s : using 32bit DMA","vxge_probe");
    else {
      
#line 4433 
      ret = -12;
      
#line 4434 
      goto _exit1;
    }
  }
  
#line 4437 
  ret = pci_request_region(pdev,0,"vxge");
  
#line 4438 
  if (ret != 0) {
    
#line 4439 
    printk("%s : request regions failed","vxge_probe");
    
#line 4441 
    goto _exit1;
  }
  else ;
  
#line 4444 
  pci_set_master(pdev);
  
#line 4446 
  attr.bar0 = pci_ioremap_bar(pdev,0);
  
#line 4447 
  if (attr.bar0 == (void *)0) {
    
#line 4448 
    printk("%s : cannot remap io memory bar0","vxge_probe");
    
#line 4450 
    ret = -19;
    
#line 4451 
    goto _exit2;
  }
  else ;
  
#line 4453 
  printk("pci ioremap bar0: %p:0x%llx",attr.bar0,pdev->resource[0].start);
  
#line 4458 
  status = vxge_hw_device_hw_info_get(attr.bar0,& ll_config->device_hw_info);
  
#line 4460 
  if (status != VXGE_HW_OK) {
    
#line 4461 
    printk("%s: Reading of hardware info failed.",(char *)"vxge");
    
#line 4464 
    ret = -22;
    
#line 4465 
    goto _exit3;
  }
  else ;
  
#line 4468 
  vpath_mask = ll_config->device_hw_info.vpath_mask;
  
#line 4469 
  if (vpath_mask == 0ULL) {
    
#line 4470 
    printk("%s: No vpaths available in device",(char *)"vxge");
    
#line 4472 
    ret = -22;
    
#line 4473 
    goto _exit3;
  }
  else ;
  
#line 4476 
  printk("%s:%d  Vpath mask = %llx","vxge_probe",4478,vpath_mask);
  
#line 4480 
  function_mode = (unsigned int)ll_config->device_hw_info.function_mode;
  
#line 4481 
  host_type = ll_config->device_hw_info.host_type;
  
#line 4482 
  is_privileged = __vxge_hw_device_is_privilaged(host_type,ll_config->device_hw_info.func_id);
  
#line 4486 
  i = 0;
  
#line 4486 
  goto ldv_56924;
  ldv_56923: 
#line 4487 
  ;
  
#line 4487 
  if (((9223372036854775808ULL >> i) & vpath_mask) == 0ULL) 
#line 4488 
                                                            goto ldv_56922; else ;
  
#line 4489 
  max_vpath_supported += 1;
  ldv_56922: 
#line 4490 
  ;
  
#line 4486 
  i += 1;
  ldv_56924: 
#line 4487 
  ;
  
#line 4486 
  if (i <= 16) 
#line 4488 
               goto ldv_56923; else 
#line 4491 
                                    goto ldv_56925;
  ldv_56925: 
#line 4492 
  ;
  
#line 4492 
  if ((unsigned int)new_device != 0U) {
    u32 tmp_4;
    
#line 4493 
    tmp_4 = vxge_get_num_vfs((unsigned long long)function_mode);
    
#line 4493 
    num_vfs = tmp_4 + 4294967295U;
  }
  else ;
  
#line 4496 
  if ((function_mode == 2U || function_mode == 6U) || function_mode == 7U) {
    int tmp_5;
    
#line 4496 
    tmp_5 = is_sriov_initialized(pdev);
    
#line 4496 
    if (tmp_5 == 0) {
      
#line 4496 
      if (ll_config->intr_type != 0) {
        
#line 4498 
        ret = pci_enable_sriov(pdev,(int)num_vfs);
        
#line 4499 
        if (ret != 0) 
#line 4500 
                      printk("Failed in enabling SRIOV mode: %d\n",ret); else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 4509 
  no_of_vpath = vxge_config_vpaths(device_config,vpath_mask,ll_config);
  
#line 4510 
  if (no_of_vpath == 0) {
    
#line 4511 
    printk("%s: No more vpaths to configure",(char *)"vxge");
    
#line 4513 
    ret = 0;
    
#line 4514 
    goto _exit3;
  }
  else ;
  
#line 4518 
  attr.uld_callbacks = & vxge_callbacks;
  
#line 4520 
  status = vxge_hw_device_initialize(& hldev,& attr,device_config);
  
#line 4521 
  if (status != VXGE_HW_OK) {
    
#line 4522 
    printk("Failed to initialize device (%d)",(int)status);
    
#line 4524 
    ret = -22;
    
#line 4525 
    goto _exit3;
  }
  else ;
  
#line 4528 
  if (((ll_config->device_hw_info.fw_version.major << 16) + (ll_config->device_hw_info.fw_version.minor << 8)) + ll_config->device_hw_info.fw_version.build > 67072U) {
    struct eprom_image img[8U];
    
#line 4534 
    status = vxge_hw_vpath_eprom_img_ver_get(hldev,(struct eprom_image *)(& img));
    
#line 4535 
    if (status != VXGE_HW_OK) 
#line 4536 
                              printk("%s: Reading of EPROM failed",(char *)"vxge"); else ;
    
#line 4541 
    i = 0;
    
#line 4541 
    goto ldv_56929;
    ldv_56928: 
#line 4542 
    ;
    
#line 4542 
    hldev->eprom_versions[i] = img[i].version;
    
#line 4543 
    if ((unsigned int)img[i].is_valid == 0U) 
#line 4544 
                                             goto ldv_56927; else ;
    
#line 4545 
    printk("%s: EPROM %d, version ",(char *)"vxge",i,(unsigned int)((int)img[i].version >> 12) & 15U,(unsigned int)((int)img[i].version >> 8) & 15U,(unsigned int)((int)img[i].version >> 4) & 15U,(unsigned int)img[i].version & 15U);
    
#line 4541 
    i += 1;
    ldv_56929: 
#line 4542 
    ;
    
#line 4541 
    if (i <= 7) 
#line 4543 
                goto ldv_56928; else 
#line 4546 
                                     goto ldv_56927;
    ldv_56927: 
#line 4547 
    ;
  }
  else ;
  
#line 4555 
  status = vxge_hw_vpath_strip_fcs_check(hldev,vpath_mask);
  
#line 4556 
  if (status != VXGE_HW_OK) {
    
#line 4557 
    printk("%s: FCS stripping is enabled in MAC",(char *)"vxge");
    
#line 4559 
    ret = -22;
    
#line 4560 
    goto _exit4;
  }
  else ;
  
#line 4571 
  if (is_privileged == VXGE_HW_OK) {
    
#line 4572 
    status = vxge_timestamp_config(hldev);
    
#line 4573 
    if (status != VXGE_HW_OK) {
      
#line 4574 
      printk("%s: HWTS enable failed",(char *)"vxge");
      
#line 4576 
      ret = -14;
      
#line 4577 
      goto _exit4;
    }
    else ;
  }
  else ;
  
#line 4581 
  vxge_hw_device_debug_set(hldev,(enum vxge_debug_level)VXGE_ERR,536870912U);
  
#line 4584 
  pci_set_drvdata(pdev,(void *)hldev);
  
#line 4586 
  ll_config->fifo_indicate_max_pkts = 84;
  
#line 4587 
  ll_config->addr_learn_en = addr_learn_en;
  
#line 4588 
  ll_config->rth_algorithm = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
  
#line 4589 
  ll_config->rth_hash_type_tcpipv4 = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U;
  
#line 4590 
  ll_config->rth_hash_type_ipv4 = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 4591 
  ll_config->rth_hash_type_tcpipv6 = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 4592 
  ll_config->rth_hash_type_ipv6 = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 4593 
  ll_config->rth_hash_type_tcpipv6ex = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 4594 
  ll_config->rth_hash_type_ipv6ex = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 4595 
  ll_config->rth_bkt_sz = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))4U;
  
#line 4596 
  ll_config->tx_pause_enable = 1;
  
#line 4597 
  ll_config->rx_pause_enable = 1;
  
#line 4599 
  ret = vxge_device_register(hldev,ll_config,high_dma,no_of_vpath,& vdev);
  
#line 4601 
  if (ret != 0) {
    
#line 4602 
    ret = -22;
    
#line 4603 
    goto _exit4;
  }
  else ;
  
#line 4606 
  ret = vxge_probe_fw_update(vdev);
  
#line 4607 
  if (ret != 0) 
#line 4608 
                goto _exit5; else ;
  
#line 4610 
  vxge_hw_device_debug_set(hldev,(enum vxge_debug_level)VXGE_TRACE,536870912U);
  
#line 4611 
  i = 0;
  
#line 4611 
  goto ldv_56933;
  ldv_56932: 
#line 4612 
  ;
  
#line 4611 
  (vdev->vpaths + i)->level_err = vxge_hw_device_error_level_get(hldev);
  
#line 4611 
  (vdev->vpaths + i)->level_trace = vxge_hw_device_trace_level_get(hldev);
  
#line 4611 
  i += 1;
  ldv_56933: 
#line 4612 
  ;
  
#line 4611 
  if (vdev->no_of_vpath > i) 
#line 4613 
                             goto ldv_56932; else 
#line 4616 
                                                  goto ldv_56934;
  ldv_56934: 
#line 4617 
  ;
  
#line 4611 
  vdev->level_err = vxge_hw_device_error_level_get(hldev);
  
#line 4611 
  vdev->level_trace = vxge_hw_device_trace_level_get(hldev);
  
#line 4615 
  vdev->mtu = 1500;
  
#line 4616 
  vdev->bar0 = attr.bar0;
  
#line 4617 
  vdev->max_vpath_supported = max_vpath_supported;
  
#line 4618 
  vdev->no_of_vpath = no_of_vpath;
  
#line 4621 
  i = 0;
  
#line 4621 
  j = 0;
  
#line 4621 
  goto ldv_56938;
  ldv_56937: 
#line 4622 
  ;
  
#line 4622 
  if (((vpath_mask >> (63 - i)) & 1ULL) == 0ULL) 
#line 4623 
                                                 goto ldv_56935; else ;
  
#line 4624 
  if (vdev->no_of_vpath <= j) 
#line 4625 
                              goto ldv_56936; else ;
  
#line 4627 
  (vdev->vpaths + j)->is_configured = 1;
  
#line 4628 
  (vdev->vpaths + j)->device_id = i;
  
#line 4629 
  (vdev->vpaths + j)->ring.driver_id = j;
  
#line 4630 
  (vdev->vpaths + j)->vdev = vdev;
  
#line 4631 
  (vdev->vpaths + j)->max_mac_addr_cnt = max_mac_vpath;
  
#line 4632 
  memcpy((void *)(& (vdev->vpaths + j)->macaddr),(void const *)(& ll_config->device_hw_info.mac_addrs[i]),6UL);
  
#line 4637 
  INIT_LIST_HEAD(& (vdev->vpaths + j)->mac_addr_list);
  
#line 4639 
  (vdev->vpaths + j)->mac_addr_cnt = (unsigned short)0U;
  
#line 4640 
  (vdev->vpaths + j)->mcast_addr_cnt = (unsigned short)0U;
  
#line 4641 
  j += 1;
  ldv_56935: 
#line 4642 
  ;
  
#line 4621 
  i += 1;
  ldv_56938: 
#line 4622 
  ;
  
#line 4621 
  if (i <= 16) 
#line 4623 
               goto ldv_56937; else 
#line 4626 
                                    goto ldv_56936;
  ldv_56936: 
#line 4627 
  ;
  
#line 4643 
  vdev->exec_mode = 0;
  
#line 4644 
  vdev->max_config_port = max_config_port;
  
#line 4646 
  vdev->vlan_tag_strip = vlan_tag_strip;
  
#line 4649 
  i = 0;
  
#line 4649 
  goto ldv_56940;
  ldv_56939: 
#line 4650 
  ;
  
#line 4650 
  vdev->vpath_selector[i] = (unsigned char)vpath_selector[i];
  
#line 4649 
  i += 1;
  ldv_56940: 
#line 4650 
  ;
  
#line 4649 
  if (vdev->no_of_vpath > i) 
#line 4651 
                             goto ldv_56939; else 
#line 4654 
                                                  goto ldv_56941;
  ldv_56941: 
#line 4655 
  ;
  
#line 4652 
  macaddr = (u8 *)(& (vdev->vpaths)->macaddr);
  
#line 4654 
  ll_config->device_hw_info.serial_number[63] = (unsigned char)0U;
  
#line 4655 
  ll_config->device_hw_info.product_desc[63] = (unsigned char)0U;
  
#line 4656 
  ll_config->device_hw_info.part_number[63] = (unsigned char)0U;
  
#line 4658 
  printk("%s: SERIAL NUMBER: %s",(char *)(& (vdev->ndev)->name),(u8 *)(& ll_config->device_hw_info.serial_number));
  
#line 4661 
  printk("%s: PART NUMBER: %s",(char *)(& (vdev->ndev)->name),(u8 *)(& ll_config->device_hw_info.part_number));
  
#line 4664 
  printk("%s: Neterion %s Server Adapter",(char *)(& (vdev->ndev)->name),(u8 *)(& ll_config->device_hw_info.product_desc));
  
#line 4667 
  printk("%s: MAC ADDR: %pM",(char *)(& (vdev->ndev)->name),macaddr);
  
#line 4670 
  tmp_6 = vxge_hw_device_link_width_get(hldev);
  
#line 4670 
  ;
  
#line 4670 
  printk("%s: Link Width x%d",(char *)(& (vdev->ndev)->name),(int)tmp_6);
  
#line 4673 
  printk("%s: Firmware version : %s Date : %s",(char *)(& (vdev->ndev)->name),(char *)(& ll_config->device_hw_info.fw_version.version),(char *)(& ll_config->device_hw_info.fw_date.date));
  
#line 4678 
  if ((unsigned int)new_device != 0U) {
    
#line 4679 
    switch (ll_config->device_hw_info.function_mode) {
      case (u64)0: 
#line 4680 
      ;
      
#line 4681 
      printk("%s: Single Function Mode Enabled",(char *)(& (vdev->ndev)->name));
      
#line 4683 
      goto ldv_56943;
      case (u64)1: 
#line 4684 
      ;
      
#line 4685 
      printk("%s: Multi Function Mode Enabled",(char *)(& (vdev->ndev)->name));
      
#line 4687 
      goto ldv_56943;
      case (u64)2: 
#line 4688 
      ;
      
#line 4689 
      printk("%s: Single Root IOV Mode Enabled",(char *)(& (vdev->ndev)->name));
      
#line 4691 
      goto ldv_56943;
      case (u64)3: 
#line 4692 
      ;
      
#line 4693 
      printk("%s: Multi Root IOV Mode Enabled",(char *)(& (vdev->ndev)->name));
      
#line 4695 
      goto ldv_56943;
    }
    ldv_56943: 
#line 4697 
    ;
  }
  else ;
  
#line 4699 
  vxge_print_parm(vdev,vpath_mask);
  
#line 4702 
  strcpy((char *)(& vdev->fw_version),(char const *)(& ll_config->device_hw_info.fw_version.version));
  
#line 4703 
  memcpy((void *)(vdev->ndev)->dev_addr,(void const *)(& (vdev->vpaths)->macaddr),6UL);
  
#line 4706 
  i = 0;
  
#line 4706 
  goto ldv_56949;
  ldv_56948: 
#line 4707 
  ;
  
#line 4707 
  entry = (struct vxge_mac_addrs *)kzalloc_0(40UL,208U);
  
#line 4708 
  if (entry == (struct vxge_mac_addrs *)0) {
    
#line 4709 
    printk("%s: mac_addr_list : memory allocation failed",(char *)(& (vdev->ndev)->name));
    
#line 4712 
    ret = -1;
    
#line 4713 
    goto _exit6;
  }
  else ;
  
#line 4715 
  macaddr = (u8 *)(& entry->macaddr);
  
#line 4716 
  memcpy((void *)macaddr,(void const *)(vdev->ndev)->dev_addr,6UL);
  
#line 4717 
  list_add(& entry->item,& (vdev->vpaths + i)->mac_addr_list);
  
#line 4718 
  (vdev->vpaths + i)->mac_addr_cnt = (unsigned short)1U;
  
#line 4706 
  i += 1;
  ldv_56949: 
#line 4707 
  ;
  
#line 4706 
  if (vdev->no_of_vpath > i) 
#line 4708 
                             goto ldv_56948; else 
#line 4711 
                                                  goto ldv_56950;
  ldv_56950: 
#line 4712 
  ;
  
#line 4721 
  kfree((void const *)device_config);
  
#line 4738 
  if (ll_config->device_hw_info.function_mode == 1ULL) {
    
#line 4740 
    if (vdev->config.intr_type == 0) 
#line 4741 
                                     vxge_hw_device_unmask_all(hldev); else ;
  }
  else ;
  
#line 4743 
  printk("%s: %s:%d  Exiting...",(char *)(& (vdev->ndev)->name),"vxge_probe",4744);
  
#line 4746 
  vxge_hw_device_debug_set(hldev,(enum vxge_debug_level)VXGE_ERR,536870912U);
  
#line 4747 
  i = 0;
  
#line 4747 
  goto ldv_56952;
  ldv_56951: 
#line 4748 
  ;
  
#line 4747 
  (vdev->vpaths + i)->level_err = vxge_hw_device_error_level_get(hldev);
  
#line 4747 
  (vdev->vpaths + i)->level_trace = vxge_hw_device_trace_level_get(hldev);
  
#line 4747 
  i += 1;
  ldv_56952: 
#line 4748 
  ;
  
#line 4747 
  if (vdev->no_of_vpath > i) 
#line 4749 
                             goto ldv_56951; else 
#line 4752 
                                                  goto ldv_56953;
  ldv_56953: 
#line 4753 
  ;
  
#line 4747 
  vdev->level_err = vxge_hw_device_error_level_get(hldev);
  
#line 4747 
  vdev->level_trace = vxge_hw_device_trace_level_get(hldev);
  
#line 4750 
  kfree((void const *)ll_config);
  
#line 4751 
  __retres = 0;
  
#line 4751 
  goto return_label;
  _exit6: 
#line 4753 
  ;
  
#line 4754 
  i = 0;
  
#line 4754 
  goto ldv_56955;
  ldv_56954: 
#line 4755 
  ;
  
#line 4755 
  vxge_free_mac_add_list(vdev->vpaths + i);
  
#line 4754 
  i += 1;
  ldv_56955: 
#line 4755 
  ;
  
#line 4754 
  if (vdev->no_of_vpath > i) 
#line 4756 
                             goto ldv_56954; else 
#line 4759 
                                                  goto ldv_56956;
  ldv_56956: 
#line 4760 
  ;
  _exit5: 
#line 4756 
  ;
  
#line 4757 
  vxge_device_unregister(hldev);
  _exit4: 
#line 4758 
  ;
  
#line 4759 
  vxge_hw_device_terminate(hldev);
  
#line 4760 
  pci_disable_sriov(pdev);
  _exit3: 
#line 4761 
  ;
  
#line 4762 
  iounmap((void volatile *)attr.bar0);
  _exit2: 
#line 4763 
  ;
  
#line 4764 
  pci_release_region(pdev,0);
  _exit1: 
#line 4765 
  ;
  
#line 4766 
  pci_disable_device(pdev);
  _exit0: 
#line 4767 
  ;
  
#line 4768 
  kfree((void const *)ll_config);
  
#line 4769 
  kfree((void const *)device_config);
  
#line 4770 
  driver_config->config_dev_cnt -= 1;
  
#line 4771 
  driver_config->total_dev_cnt -= 1;
  
#line 4772 
  __retres = ret;
  return_label: 
#line 4772 
                return __retres;
}


#line 4781  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_remove(struct pci_dev *pdev)
{
  struct __vxge_hw_device *hldev;
  struct vxgedev *vdev;
  int i;
  
#line 4787 
  hldev = (struct __vxge_hw_device *)pci_get_drvdata(pdev);
  
#line 4788 
  if (hldev == (struct __vxge_hw_device *)0) 
#line 4789 
                                             goto return_label; else ;
  
#line 4791 
  vdev = (struct vxgedev *)netdev_priv((struct net_device const *)hldev->ndev);
  
#line 4793 
  if (vdev->level_trace != 0U) 
#line 4793 
                               printk("%s:%d","vxge_remove",4793); else ;
  
#line 4794 
  if (vdev->level_trace != 0U) 
#line 4794 
                               printk("%s : removing PCI device...","vxge_remove"); else ;
  
#line 4797 
  i = 0;
  
#line 4797 
  goto ldv_56965;
  ldv_56964: 
#line 4798 
  ;
  
#line 4798 
  vxge_free_mac_add_list(vdev->vpaths + i);
  
#line 4797 
  i += 1;
  ldv_56965: 
#line 4798 
  ;
  
#line 4797 
  if (vdev->no_of_vpath > i) 
#line 4799 
                             goto ldv_56964; else 
#line 4802 
                                                  goto ldv_56966;
  ldv_56966: 
#line 4803 
  ;
  
#line 4800 
  vxge_device_unregister(hldev);
  
#line 4802 
  vxge_hw_device_terminate(hldev);
  
#line 4803 
  iounmap((void volatile *)vdev->bar0);
  
#line 4804 
  pci_release_region(pdev,0);
  
#line 4805 
  pci_disable_device(pdev);
  
#line 4806 
  driver_config->config_dev_cnt -= 1;
  
#line 4807 
  driver_config->total_dev_cnt -= 1;
  
#line 4809 
  if (vdev->level_trace != 0U) 
#line 4809 
                               printk("%s:%d Device unregistered","vxge_remove",4810); else ;
  
#line 4811 
  if (vdev->level_trace != 0U) 
#line 4811 
                               printk("%s:%d  Exiting...","vxge_remove",4812); else ;
  return_label: 
#line 4812 
                return;
}


#line 4815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static struct pci_error_handlers const vxge_err_handler = {.error_detected = (pci_ers_result_t (*)(struct pci_dev *, enum pci_channel_state ))(& vxge_io_error_detected), .mmio_enabled = (pci_ers_result_t (*)(struct pci_dev *))0, .link_reset = (pci_ers_result_t (*)(struct pci_dev *))0, .slot_reset = & vxge_io_slot_reset, .reset_notify = (void (*)(struct pci_dev *, bool ))0, .resume = & vxge_io_resume};

#line 4821  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static struct pci_driver vxge_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = "vxge", .id_table = (struct pci_device_id const *)(& vxge_id_table), .probe = & vxge_probe, .remove = & vxge_remove, .suspend = & vxge_pm_suspend, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = & vxge_pm_resume, .shutdown = (void (*)(struct pci_dev *))0, .sriov_configure = (int (*)(struct pci_dev *, int ))0, .err_handler = & vxge_err_handler, .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 4834  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static int vxge_starter(void)
{
  int __retres;
  
#line 4836 
  int ret = 0;
  
#line 4838 
  printk("\001");
  
#line 4839 
  printk("\001",(char *)"2");
  
#line 4841 
  verify_bandwidth();
  
#line 4843 
  driver_config = (struct vxge_drv_config *)kzalloc_0(16UL,208U);
  
#line 4844 
  if (driver_config == (struct vxge_drv_config *)0) {
    
#line 4845 
    __retres = -12;
    
#line 4845 
    goto return_label;
  }
  else ;
  
#line 4847 
  ret = ldv___pci_register_driver_91(& vxge_driver,& __this_module,"vxge");
  
#line 4848 
  if (ret != 0) {
    
#line 4849 
    kfree((void const *)driver_config);
    
#line 4850 
    goto err;
  }
  else ;
  
#line 4853 
  if (driver_config->config_dev_cnt != 0 && driver_config->config_dev_cnt != driver_config->total_dev_cnt) 
    
#line 4855 
    printk("%s: Configured %d of %d devices",(char *)"vxge",driver_config->config_dev_cnt,driver_config->total_dev_cnt); else ;
  err: 
#line 4859 
  ;
  
#line 4860 
  __retres = ret;
  return_label: 
#line 4860 
                return __retres;
}


#line 4864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-main.c"
static void vxge_closer(void)
{
  
#line 4866 
  ldv_pci_unregister_driver_92(& vxge_driver);
  
#line 4867 
  kfree((void const *)driver_config);
  
#line 4868 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int (*ldv_emg_alias_eth_validate_addr_6)(struct net_device *) = & eth_validate_addr;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
struct pci_driver *ldv_emg_alias_vxge_driver_2 = & vxge_driver;

#line 60 
int ldv_emg_del_timer_sync(struct timer_list *arg0);


#line 61 
void ldv_emg_free_netdev(struct net_device *arg0);


#line 62 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 63 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 64 
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);


#line 65 
void ldv_emg_unregister_netdev(struct net_device *arg0);


#line 66 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 67 
int ldv_emg_register_netdev(struct net_device *arg0);


#line 68 
_Bool ldv_emg_flush_work(struct work_struct *arg0);


#line 69 
_Bool ldv_emg_schedule_work(struct work_struct *arg0);


#line 70 
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1);


#line 71 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
void ldv_emg_wrapper_vxge_tx_watchdog_21(struct net_device *arg0)
{
  
#line 76 
  vxge_tx_watchdog(arg0);
  
#line 77 
  return;
}


#line 80  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_close_2(struct net_device *arg0)
{
  int tmp;
  
#line 81 
  tmp = vxge_close(arg0);
  
#line 81 
  return tmp;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_pm_resume_5(struct pci_dev *arg0)
{
  int tmp;
  
#line 86 
  tmp = vxge_pm_resume(arg0);
  
#line 86 
  return tmp;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_vlan_rx_add_vid_17(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  int tmp;
  
#line 91 
  tmp = vxge_vlan_rx_add_vid(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 91 
  return tmp;
}


#line 95  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_change_mtu_8(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 96 
  tmp = vxge_change_mtu(arg0,arg1);
  
#line 96 
  return tmp;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
void ldv_emg_wrapper_vxge_remove_4(struct pci_dev *arg0)
{
  
#line 101 
  vxge_remove(arg0);
  
#line 102 
  return;
}


#line 105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
enum irqreturn ldv_emg_wrapper_vxge_isr_napi_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 106 
  tmp = vxge_isr_napi(arg0,arg1);
  
#line 106 
  return tmp;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
struct rtnl_link_stats64 *ldv_emg_wrapper_vxge_get_stats64_5(struct net_device *arg0, struct rtnl_link_stats64 *arg1)
{
  struct rtnl_link_stats64 *tmp;
  
#line 111 
  tmp = vxge_get_stats64(arg0,arg1);
  
#line 111 
  return tmp;
}


#line 115  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_probe_2(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 116 
  tmp = vxge_probe(arg0,(struct pci_device_id const *)arg1);
  
#line 116 
  return tmp;
}


#line 120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
enum netdev_tx ldv_emg_wrapper_vxge_xmit_13(struct sk_buff *arg0, struct net_device *arg1)
{
  enum netdev_tx tmp;
  
#line 121 
  tmp = vxge_xmit(arg0,arg1);
  
#line 121 
  return tmp;
}


#line 125  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_set_mac_addr_14(struct net_device *arg0, void *arg1)
{
  int tmp;
  
#line 126 
  tmp = vxge_set_mac_addr(arg0,arg1);
  
#line 126 
  return tmp;
}


#line 130  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
void ldv_emg_wrapper_vxge_set_multicast_27(struct net_device *arg0)
{
  
#line 131 
  vxge_set_multicast(arg0);
  
#line 132 
  return;
}


#line 135  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_set_features_10(struct net_device *arg0, unsigned long long arg1)
{
  int tmp;
  
#line 136 
  tmp = vxge_set_features(arg0,arg1);
  
#line 136 
  return tmp;
}


#line 140  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_vxge_starter(void)
{
  int tmp;
  
#line 141 
  tmp = vxge_starter();
  
#line 141 
  return tmp;
}


#line 144  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_vlan_rx_kill_vid_25(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  int tmp;
  
#line 145 
  tmp = vxge_vlan_rx_kill_vid(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 145 
  return tmp;
}


#line 149  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
void ldv_emg_wrapper_vxge_netpoll_26(struct net_device *arg0)
{
  
#line 150 
  vxge_netpoll(arg0);
  
#line 151 
  return;
}


#line 154  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
enum irqreturn ldv_emg_wrapper_vxge_tx_msix_handle_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 155 
  tmp = vxge_tx_msix_handle(arg0,arg1);
  
#line 155 
  return tmp;
}


#line 159  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
unsigned long long ldv_emg_wrapper_vxge_fix_features_12(struct net_device *arg0, unsigned long long arg1)
{
  unsigned long long tmp;
  
#line 160 
  tmp = vxge_fix_features(arg0,arg1);
  
#line 160 
  return tmp;
}


#line 164  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
enum irqreturn ldv_emg_wrapper_vxge_alarm_msix_handle_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 165 
  tmp = vxge_alarm_msix_handle(arg0,arg1);
  
#line 165 
  return tmp;
}


#line 169  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_pm_suspend_3(struct pci_dev *arg0, struct pm_message arg1)
{
  int tmp;
  
#line 170 
  tmp = vxge_pm_suspend(arg0,arg1);
  
#line 170 
  return tmp;
}


#line 174  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
void ldv_emg_vxge_closer(void)
{
  
#line 175 
  vxge_closer();
  
#line 176 
  return;
}


#line 178  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_ioctl_18(struct net_device *arg0, struct ifreq *arg1, int arg2)
{
  int tmp;
  
#line 179 
  tmp = vxge_ioctl(arg0,arg1,arg2);
  
#line 179 
  return tmp;
}


#line 183  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
enum irqreturn ldv_emg_wrapper_vxge_rx_msix_napi_handle_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 184 
  tmp = vxge_rx_msix_napi_handle(arg0,arg1);
  
#line 184 
  return tmp;
}


#line 188  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
int ldv_emg_wrapper_vxge_open_2(struct net_device *arg0)
{
  int tmp;
  
#line 189 
  tmp = vxge_open(arg0);
  
#line 189 
  return tmp;
}


#line 717  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 720 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 720 
  return tmp;
}


#line 724  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 727 
  tmp = ldv_kzalloc(size,flags);
  
#line 727 
  return tmp;
}


#line 751  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_spin_trylock_62(spinlock_t *lock)
{
  int __retres;
  
#line 755 
  ldv_func_ret_type ldv_func_res = spin_trylock(lock);
  
#line 757 
  int is_spin_held_by_another_thread = ldv_undef_int();
  
#line 759 
  if (is_spin_held_by_another_thread != 0) {
    
#line 762 
    __retres = 0;
    
#line 762 
    goto return_label;
  }
  else {
    
#line 765 
    ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
    
#line 767 
    __retres = 1;
    
#line 767 
    goto return_label;
  }
  
#line 770 
  __retres = ldv_func_res;
  return_label: 
#line 770 
                return __retres;
}


#line 774  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void ldv_spin_unlock_63(spinlock_t *lock)
{
  
#line 778 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 780 
  spin_unlock(lock);
  
#line 781 
  return;
}


#line 874  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_mod_timer_73(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 878 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 878 
  return tmp;
}


#line 882  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void ldv_free_irq_74(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 886 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 887 
  return;
}


#line 890  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void ldv_free_irq_75(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 894 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 895 
  return;
}


#line 898  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_request_irq_76(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 902 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 902 
  return tmp;
}


#line 906  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_request_irq_77(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 910 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 910 
  return tmp;
}


#line 914  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_request_irq_78(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 918 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 918 
  return tmp;
}


#line 922  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_request_irq_79(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 926 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 926 
  return tmp;
}


#line 930  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_mod_timer_80(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 934 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 934 
  return tmp;
}


#line 938  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_mod_timer_81(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 942 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 942 
  return tmp;
}


#line 946  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_del_timer_sync_82(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 950 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 950 
  return tmp;
}


#line 954  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_del_timer_sync_83(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 958 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 958 
  return tmp;
}


#line 962  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static bool ldv_schedule_work_84(struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 966 
  tmp = ldv_emg_schedule_work(work);
  
#line 966 
  __retres = tmp != 0;
  
#line 966 
  return __retres;
}


#line 970  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_85(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3)
{
  struct net_device *tmp;
  
#line 974 
  tmp = ldv_emg_alloc_etherdev_mqs(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 974 
  return tmp;
}


#line 978  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv_register_netdev_86(struct net_device *ldv_func_arg1)
{
  int tmp;
  
#line 982 
  tmp = ldv_emg_register_netdev(ldv_func_arg1);
  
#line 982 
  return tmp;
}


#line 986  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void ldv_free_netdev_87(struct net_device *ldv_func_arg1)
{
  
#line 990 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 991 
  return;
}


#line 994  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static bool ldv_flush_work_88(struct work_struct *ldv_func_arg1)
{
  bool __retres;
  bool tmp;
  
#line 998 
  tmp = ldv_emg_flush_work(ldv_func_arg1);
  
#line 998 
  __retres = tmp != 0;
  
#line 998 
  return __retres;
}


#line 1002  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void ldv_unregister_netdev_89(struct net_device *ldv_func_arg1)
{
  
#line 1006 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 1007 
  return;
}


#line 1010  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void ldv_free_netdev_90(struct net_device *ldv_func_arg1)
{
  
#line 1014 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 1015 
  return;
}


#line 1018  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static int ldv___pci_register_driver_91(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 1022 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 1022 
  return tmp;
}


#line 1026  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-main.c.aux"
static void ldv_pci_unregister_driver_92(struct pci_driver *ldv_func_arg1)
{
  
#line 1030 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 1031 
  return;
}

unsigned long __builtin_bswap64(unsigned long);


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val)
{
  __u64 tmp;
  
#line 71 
  tmp = (__u64)__builtin_bswap64((unsigned long)val);
  
#line 71 
  return tmp;
}


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  int __retres;
  int tmp;
  {
    int pfo_ret__;
    
#line 22 
    switch (4UL) {
      case (unsigned long)1: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)2: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)4: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)8: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      default: 
#line 22 
      ;
      
#line 22 
      __bad_percpu_size();
    }
    ldv_6320: 
#line 22 
    ;
    
#line 22 
    tmp = pfo_ret__;
  }
  
#line 22 
  __retres = tmp & 2147483647;
  
#line 22 
  return __retres;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_73(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_76(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_0(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_74(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_75(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_77(spinlock_t *lock);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vmalloc(unsigned long);


#line 70 
void *vzalloc(unsigned long);


#line 83 
void vfree(void const *);


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile *addr)
{
  unsigned int ret;
  
#line 59 
  ldv_inline_asm();
  
#line 58 
  return ret;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void volatile *addr)
{
  
#line 68 
  ldv_inline_asm();
  
#line 69 
  return;
}


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile *addr)
{
  unsigned long ret;
  
#line 91 
  ldv_inline_asm();
  
#line 90 
  return ret;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val, void volatile *addr)
{
  
#line 93 
  ldv_inline_asm();
  
#line 94 
  return;
}


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc(size_t size, gfp_t flags);


#line 581 
static void *kzalloc_1(size_t size, gfp_t flags);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 867  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_bus_write_config_word(struct pci_bus *, unsigned int, int, u16);


#line 900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev const *dev, int where, u16 val)
{
  int tmp;
  
#line 902 
  tmp = pci_bus_write_config_word(dev->bus,dev->devfn,where,(unsigned short)((int)val));
  
#line 902 
  return tmp;
}


#line 910 
int pcie_capability_read_word(struct pci_dev *, int, u16 *);


#line 1026 
int pci_save_state(struct pci_dev *);


#line 1907  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.h"
enum vxge_hw_status vxge_hw_ring_rxd_reserve(struct __vxge_hw_ring *ring, void **rxdh);


#line 1926 
void vxge_hw_ring_rxd_post(struct __vxge_hw_ring *ring, void *rxdh);


#line 1940 
void vxge_hw_ring_rxd_free(struct __vxge_hw_ring *ring, void *rxdh);


#line 2094 
enum vxge_hw_status __vxge_hw_vpath_rts_table_get(struct __vxge_hw_vpath_handle *vp, u32 action, u32 rts_table, u32 offset, u64 *data0, u64 *data1);


#line 2103 
enum vxge_hw_status __vxge_hw_vpath_rts_table_set(struct __vxge_hw_vpath_handle *vp, u32 action, u32 rts_table, u32 offset, u64 steer_data0, u64 steer_data1);


#line 2274 
void vxge_hw_channel_dtr_try_complete(struct __vxge_hw_channel *channel, void **dtrh);


#line 2278 
void vxge_hw_channel_dtr_complete(struct __vxge_hw_channel *channel);


#line 2281 
void vxge_hw_channel_dtr_free(struct __vxge_hw_channel *channel, void *dtrh);


#line 2284 
int vxge_hw_channel_dtr_count(struct __vxge_hw_channel *channel);


#line 1481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static u32 vxge_hw_ring_rxd_size_get(u32 buf_mode)
{
  u32 __retres;
  
#line 1483 
  __retres = 32U;
  
#line 1483 
  return __retres;
}


#line 1492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static u32 vxge_hw_ring_rxds_per_block_get(u32 buf_mode)
{
  u32 __retres;
  
#line 1494 
  __retres = 127U;
  
#line 1494 
  return __retres;
}


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void *vxge_os_dma_malloc(struct pci_dev *pdev, unsigned long size, struct pci_dev **p_dmah, struct pci_dev **p_dma_acch)
{
  void *__retres;
  gfp_t flags;
  void *vaddr;
  struct pci_dev *tmp;
  int tmp_0;
  
#line 1904 
  unsigned long misaligned = 0UL;
  
#line 1905 
  int realloc_flag = 0;
  
#line 1906 
  tmp = (struct pci_dev *)0;
  
#line 1906 
  *p_dmah = tmp;
  
#line 1906 
  *p_dma_acch = tmp;
  
#line 1908 
  tmp_0 = preempt_count();
  
#line 1908 
  if (((unsigned long)tmp_0 & 2096896UL) != 0UL) 
#line 1909 
                                                 flags = 33U; else 
#line 1911 
                                                                   flags = 209U;
  realloc: 
#line 1912 
  ;
  
#line 1913 
  vaddr = kmalloc(size,flags);
  
#line 1914 
  if (vaddr == (void *)0) {
    
#line 1915 
    __retres = vaddr;
    
#line 1915 
    goto return_label;
  }
  else ;
  
#line 1916 
  misaligned = (unsigned long)(- ((unsigned long long)vaddr)) & 127UL;
  
#line 1918 
  if (realloc_flag != 0) 
#line 1919 
                         goto out; else ;
  
#line 1921 
  if (misaligned != 0UL) {
    
#line 1925 
    kfree((void const *)vaddr);
    
#line 1926 
    size += 128UL;
    
#line 1927 
    realloc_flag = 1;
    
#line 1928 
    goto realloc;
  }
  else ;
  out: 
#line 1930 
  ;
  
#line 1931 
  *((unsigned long *)p_dma_acch) = misaligned;
  
#line 1932 
  vaddr += misaligned;
  
#line 1933 
  __retres = vaddr;
  return_label: 
#line 1933 
                return __retres;
}


#line 1936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void vxge_os_dma_free(struct pci_dev *pdev, void const *vaddr, struct pci_dev **p_dma_acch)
{
  
#line 1939 
  unsigned long misaligned = *((unsigned long *)p_dma_acch);
  
#line 1940 
  u8 *tmp = (u8 *)vaddr;
  
#line 1941 
  tmp += - misaligned;
  
#line 1942 
  kfree((void const *)tmp);
  
#line 1943 
  return;
}


#line 1949  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void *__vxge_hw_mempool_item_priv(struct vxge_hw_mempool *mempool, u32 memblock_idx, void *item, u32 *memblock_item_idx)
{
  void *__retres;
  ptrdiff_t offset;
  
#line 1956 
  void *memblock = *(mempool->memblocks_arr + memblock_idx);
  
#line 1959 
  offset = (long)((unsigned int)((long)item - (long)memblock));
  
#line 1962 
  *memblock_item_idx = (unsigned int)offset / mempool->item_size;
  
#line 1965 
  __retres = *(mempool->memblocks_priv_arr + memblock_idx) + *memblock_item_idx * mempool->items_priv_size;
  
#line 1965 
  return __retres;
}


#line 1976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static struct __vxge_hw_fifo_txdl_priv *__vxge_hw_fifo_txdl_priv(struct __vxge_hw_fifo *fifo, struct vxge_hw_fifo_txd *txdp)
{
  struct __vxge_hw_fifo_txdl_priv *__retres;
  
#line 1980 
  __retres = (struct __vxge_hw_fifo_txdl_priv *)((u64)fifo->per_txdl_space + txdp->host_control);
  
#line 1980 
  return __retres;
}


#line 2034  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void __vxge_hw_pio_mem_write32_upper(u32 val, void *addr)
{
  
#line 2036 
  writel(val,(void volatile *)(addr + 4U));
  
#line 2037 
  return;
}


#line 2039  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.h"
__inline static void __vxge_hw_pio_mem_write32_lower(u32 val, void *addr)
{
  
#line 2041 
  writel(val,(void volatile *)addr);
  
#line 2042 
  return;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void vxge_hw_vpath_set_zero_rx_frm_len(struct vxge_hw_vpath_reg *vp_reg)
{
  u64 val64;
  
#line 38 
  val64 = (u64)readq((void const volatile *)(& vp_reg->rxmac_vcfg0));
  
#line 39 
  val64 &= 13835339530258874367ULL;
  
#line 40 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->rxmac_vcfg0));
  
#line 41 
  val64 = (u64)readq((void const volatile *)(& vp_reg->rxmac_vcfg0));
  
#line 42 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
int vxge_hw_vpath_wait_receive_idle(struct __vxge_hw_device *hldev, u32 vp_id)
{
  struct vxge_hw_vpath_reg *vp_reg;
  struct __vxge_hw_virtualpath *vpath;
  u64 val64;
  u64 rxd_count;
  u64 rxd_spat;
  
#line 52 
  int count = 0;
  
#line 52 
  int total_count = 0;
  
#line 54 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 55 
  vp_reg = vpath->vp_reg;
  
#line 57 
  vxge_hw_vpath_set_zero_rx_frm_len(vp_reg);
  
#line 64 
  val64 = (u64)readq((void const volatile *)(& vp_reg->prc_cfg6));
  
#line 65 
  rxd_spat = ((val64 >> 19) & 511ULL) + 1ULL;
  
#line 69 
  rxd_spat *= 2ULL;
  ldv_52081: 
#line 70 
  ;
  
#line 72 
  if (1) 
#line 72 
         __const_udelay(4295000UL);
  else {
    
#line 72 
    unsigned long __ms = 1UL;
    {
      unsigned long tmp_0;
      
#line 72 
      goto ldv_52079;
      ldv_52078: 
#line 73 
      ;
      
#line 72 
      __const_udelay(4295000UL);
      ldv_52079: 
#line 74 
      ;
      
#line 72 
      tmp_0 = __ms;
      
#line 72 
      __ms -= 1UL;
      
#line 72 
      ;
      
#line 72 
      if (tmp_0 != 0UL) 
#line 74 
                        goto ldv_52078; else 
#line 77 
                                             goto ldv_52080;
      ldv_52080: 
#line 78 
      ;
    }
  }
  
#line 74 
  rxd_count = (u64)readq((void const volatile *)(& vp_reg->prc_rxd_doorbell));
  
#line 79 
  val64 = (u64)readq((void const volatile *)(& vp_reg->frm_in_progress_cnt));
  
#line 80 
  if (rxd_count <= rxd_spat || val64 != 0ULL) 
#line 81 
                                              count = 0; else 
#line 83 
                                                              count += 1;
  
#line 84 
  total_count += 1;
  
#line 86 
  if (count <= 4 && total_count <= 99) 
#line 88 
                                       goto ldv_52081; else 
#line 91 
                                                            goto ldv_52082;
  ldv_52082: 
#line 92 
  ;
  
#line 88 
  if (total_count > 99) 
#line 89 
                        printk("\001","vxge_hw_vpath_wait_receive_idle"); else ;
  
#line 92 
  return total_count;
}


#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
void vxge_hw_device_wait_receive_idle(struct __vxge_hw_device *hldev)
{
  int i;
  int tmp;
  
#line 101 
  int total_count = 0;
  
#line 103 
  i = 0;
  
#line 103 
  goto ldv_52092;
  ldv_52091: 
#line 104 
  ;
  
#line 104 
  if ((hldev->vpaths_deployed & (9223372036854775808ULL >> i)) == 0ULL) 
    
#line 105 
    goto ldv_52089; else ;
  
#line 107 
  tmp = vxge_hw_vpath_wait_receive_idle(hldev,(unsigned int)i);
  
#line 107 
  total_count = tmp + total_count;
  
#line 108 
  if (total_count > 99) 
#line 109 
                        goto ldv_52090; else ;
  ldv_52089: 
#line 110 
  ;
  
#line 103 
  i += 1;
  ldv_52092: 
#line 104 
  ;
  
#line 103 
  if (i <= 16) 
#line 105 
               goto ldv_52091; else 
#line 108 
                                    goto ldv_52090;
  ldv_52090: 
#line 109 
  ;
  
#line 110 
  return;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_device_register_poll(void *reg, u64 mask, u32 max_millis)
{
  enum vxge_hw_status __retres;
  u64 val64;
  
#line 122 
  u32 i = 0U;
  
#line 124 
  __const_udelay(42950UL);
  ldv_52100: 
#line 126 
  ;
  
#line 127 
  val64 = (u64)readq((void const volatile *)reg);
  
#line 128 
  if ((val64 & mask) == 0ULL) {
    
#line 129 
    __retres = VXGE_HW_OK;
    
#line 129 
    goto return_label;
  }
  else ;
  
#line 130 
  __const_udelay(429500UL);
  
#line 131 
  i += 1U;
  
#line 131 
  if (i <= 9U) 
#line 133 
               goto ldv_52100; else 
#line 136 
                                    goto ldv_52101;
  ldv_52101: 
#line 137 
  ;
  
#line 133 
  i = 0U;
  ldv_52106: 
#line 134 
  ;
  
#line 135 
  val64 = (u64)readq((void const volatile *)reg);
  
#line 136 
  if ((val64 & mask) == 0ULL) {
    
#line 137 
    __retres = VXGE_HW_OK;
    
#line 137 
    goto return_label;
  }
  else ;
  
#line 138 
  if (1) 
#line 138 
         __const_udelay(4295000UL);
  else {
    
#line 138 
    unsigned long __ms = 1UL;
    {
      unsigned long tmp_1;
      
#line 138 
      goto ldv_52104;
      ldv_52103: 
#line 139 
      ;
      
#line 138 
      __const_udelay(4295000UL);
      ldv_52104: 
#line 140 
      ;
      
#line 138 
      tmp_1 = __ms;
      
#line 138 
      __ms -= 1UL;
      
#line 138 
      ;
      
#line 138 
      if (tmp_1 != 0UL) 
#line 140 
                        goto ldv_52103; else 
#line 143 
                                             goto ldv_52105;
      ldv_52105: 
#line 144 
      ;
    }
  }
  
#line 139 
  i += 1U;
  
#line 139 
  ;
  
#line 139 
  if (i <= max_millis) 
#line 141 
                       goto ldv_52106; else 
#line 144 
                                            goto ldv_52107;
  ldv_52107: 
#line 145 
  ;
  
#line 141 
  __retres = VXGE_HW_FAIL;
  return_label: 
#line 141 
                return __retres;
}


#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
__inline static enum vxge_hw_status __vxge_hw_pio_mem_write64(u64 val64, void *addr, u64 mask, u32 max_millis)
{
  enum vxge_hw_status tmp;
  
#line 148 
  __vxge_hw_pio_mem_write32_lower((unsigned int)val64,addr);
  
#line 149 
  ldv_inline_asm();
  
#line 150 
  __vxge_hw_pio_mem_write32_upper((unsigned int)(val64 >> 32),addr);
  
#line 151 
  ldv_inline_asm();
  
#line 153 
  tmp = __vxge_hw_device_register_poll(addr,mask,max_millis);
  
#line 153 
  return tmp;
}


#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status vxge_hw_vpath_fw_api(struct __vxge_hw_virtualpath *vpath, u32 action, u32 fw_memo, u32 offset, u64 *data0, u64 *data1, u64 *steer_ctrl)
{
  enum vxge_hw_status status;
  u64 val64;
  
#line 161 
  struct vxge_hw_vpath_reg *vp_reg = vpath->vp_reg;
  
#line 164 
  u32 retry = 0U;
  
#line 164 
  u32 max_retry = 3U;
  
#line 166 
  ldv_spin_lock_73(& vpath->lock);
  
#line 167 
  if (vpath->vp_open == 0U) {
    
#line 168 
    ldv_spin_unlock_74(& vpath->lock);
    
#line 169 
    max_retry = 100U;
  }
  else ;
  
#line 172 
  writeq((unsigned long)*data0,(void volatile *)(& vp_reg->rts_access_steer_data0));
  
#line 173 
  writeq((unsigned long)*data1,(void volatile *)(& vp_reg->rts_access_steer_data1));
  
#line 174 
  ldv_inline_asm();
  
#line 176 
  val64 = (((((unsigned long long)action << 56) | ((unsigned long long)fw_memo << 52)) | ((unsigned long long)offset << 16)) | *steer_ctrl) | 281474976710656ULL;
  
#line 182 
  status = __vxge_hw_pio_mem_write64(val64,(void *)(& vp_reg->rts_access_steer_ctrl),281474976710656ULL,1000U);
  
#line 195 
  goto ldv_52129;
  ldv_52128: 
#line 196 
  ;
  
#line 196 
  if (vpath->vp_open == 0U) 
#line 197 
                            msleep(20U); else ;
  
#line 198 
  status = __vxge_hw_device_register_poll((void *)(& vp_reg->rts_access_steer_ctrl),281474976710656ULL,1000U);
  ldv_52129: 
#line 200 
  ;
  
#line 195 
  if (status != VXGE_HW_OK) {
    u32 tmp;
    
#line 195 
    tmp = retry;
    
#line 195 
    retry += 1U;
    
#line 195 
    ;
    
#line 195 
    if (tmp < max_retry) 
#line 197 
                         goto ldv_52128; else 
#line 200 
                                              goto ldv_52130;
  }
  else 
#line 200 
       goto ldv_52130;
  ldv_52130: 
#line 201 
  ;
  
#line 204 
  if (status != VXGE_HW_OK) 
#line 205 
                            goto out; else ;
  
#line 207 
  val64 = (u64)readq((void const volatile *)(& vp_reg->rts_access_steer_ctrl));
  
#line 208 
  if (val64 < (u64)0) {
    
#line 209 
    *data0 = (u64)readq((void const volatile *)(& vp_reg->rts_access_steer_data0));
    
#line 210 
    *data1 = (u64)readq((void const volatile *)(& vp_reg->rts_access_steer_data1));
    
#line 211 
    *steer_ctrl = val64;
  }
  else 
#line 213 
       status = VXGE_HW_FAIL;
  out: 
#line 215 
  ;
  
#line 216 
  if (vpath->vp_open != 0U) 
#line 217 
                            ldv_spin_unlock_75(& vpath->lock); else ;
  
#line 218 
  return status;
}


#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_upgrade_read_version(struct __vxge_hw_device *hldev, u32 *major, u32 *minor, u32 *build)
{
  enum vxge_hw_status __retres;
  struct __vxge_hw_virtualpath *vpath;
  enum vxge_hw_status status;
  
#line 225 
  u64 data0 = 0ULL;
  
#line 225 
  u64 data1 = 0ULL;
  
#line 225 
  u64 steer_ctrl = 0ULL;
  
#line 229 
  vpath = & hldev->virtual_paths[hldev->first_vp_id];
  
#line 231 
  status = vxge_hw_vpath_fw_api(vpath,16U,13U,5U,& data0,& data1,& steer_ctrl);
  
#line 236 
  if (status != VXGE_HW_OK) {
    
#line 237 
    __retres = status;
    
#line 237 
    goto return_label;
  }
  else ;
  
#line 239 
  *major = (unsigned int)(data0 >> 24) & 255U;
  
#line 240 
  *minor = (unsigned int)(data0 >> 16) & 255U;
  
#line 241 
  *build = (unsigned int)data0 & 65535U;
  
#line 243 
  __retres = status;
  return_label: 
#line 243 
                return __retres;
}


#line 246  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_flash_fw(struct __vxge_hw_device *hldev)
{
  struct __vxge_hw_virtualpath *vpath;
  enum vxge_hw_status status;
  u32 ret;
  
#line 248 
  u64 data0 = 0ULL;
  
#line 248 
  u64 data1 = 0ULL;
  
#line 248 
  u64 steer_ctrl = 0ULL;
  
#line 253 
  vpath = & hldev->virtual_paths[hldev->first_vp_id];
  
#line 255 
  status = vxge_hw_vpath_fw_api(vpath,16U,13U,4U,& data0,& data1,& steer_ctrl);
  
#line 260 
  if (status != VXGE_HW_OK) {
    
#line 261 
    printk("%s: FW upgrade failed","vxge_hw_flash_fw");
    
#line 262 
    goto exit;
  }
  else ;
  
#line 265 
  ret = (unsigned int)(steer_ctrl >> 56) & 127U;
  
#line 266 
  if (ret != 1U) {
    
#line 267 
    printk("%s: FW commit failed with error %d","vxge_hw_flash_fw",ret);
    
#line 269 
    status = VXGE_HW_FAIL;
  }
  else ;
  exit: 
#line 272 
  ;
  
#line 273 
  return status;
}


#line 277  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_update_fw_image(struct __vxge_hw_device *hldev, u8 const *fwdata, int size)
{
  enum vxge_hw_status __retres;
  struct __vxge_hw_virtualpath *vpath;
  enum vxge_hw_status status;
  int ret_code;
  int sec_code;
  
#line 279 
  u64 data0 = 0ULL;
  
#line 279 
  u64 data1 = 0ULL;
  
#line 279 
  u64 steer_ctrl = 0ULL;
  
#line 284 
  vpath = & hldev->virtual_paths[hldev->first_vp_id];
  
#line 287 
  status = vxge_hw_vpath_fw_api(vpath,16U,13U,2U,& data0,& data1,& steer_ctrl);
  
#line 292 
  if (status != VXGE_HW_OK) {
    
#line 293 
    printk(" %s: Upgrade start cmd failed","vxge_update_fw_image");
    
#line 295 
    __retres = status;
    
#line 295 
    goto return_label;
  }
  else ;
  
#line 299 
  goto ldv_52187;
  ldv_52186: 
#line 300 
  ;
  
#line 300 
  steer_ctrl = 0ULL;
  
#line 303 
  data0 = *((u64 *)fwdata);
  
#line 304 
  data1 = *((u64 *)fwdata + 1U);
  
#line 306 
  status = vxge_hw_vpath_fw_api(vpath,16U,13U,3U,& data0,& data1,& steer_ctrl);
  
#line 311 
  if (status != VXGE_HW_OK) {
    
#line 312 
    printk("%s: Upgrade send failed","vxge_update_fw_image");
    
#line 314 
    goto out;
  }
  else ;
  
#line 317 
  ret_code = (int)data0 & 255;
  
#line 318 
  switch (ret_code) {
    case 0: 
#line 319 
    ;
    
#line 321 
    goto ldv_52169;
    case 3: 
#line 322 
    ;
    
#line 324 
    fwdata += (data0 >> 8) & (unsigned long long)4294967295U;
    
#line 325 
    goto ldv_52169;
    case 1: 
#line 326 
    ;
    
#line 327 
    goto out;
    case 2: 
#line 328 
    ;
    
#line 329 
    sec_code = (int)(data0 >> 8) & 255;
    
#line 330 
    switch (sec_code) {
      case 1: 
#line 331 
      ;
      case 7: 
#line 332 
      ;
      
#line 333 
      printk("\001");
      
#line 335 
      goto ldv_52175;
      case 3: 
#line 336 
      ;
      case 4: 
#line 337 
      ;
      case 5: 
#line 338 
      ;
      case 6: 
#line 339 
      ;
      case 8: 
#line 340 
      ;
      
#line 341 
      printk("\001");
      
#line 342 
      goto ldv_52175;
      case 2: 
#line 343 
      ;
      
#line 344 
      printk("\001");
      
#line 345 
      goto ldv_52175;
      case 10: 
#line 346 
      ;
      
#line 347 
      printk("\001");
      
#line 348 
      goto ldv_52175;
      case 9: 
#line 349 
      ;
      
#line 350 
      printk("\001");
      
#line 352 
      goto ldv_52175;
      default: 
#line 353 
      ;
      
#line 354 
      printk("\001",sec_code);
      
#line 356 
      goto ldv_52175;
    }
    ldv_52175: 
#line 358 
    ;
    
#line 358 
    status = VXGE_HW_FAIL;
    
#line 359 
    goto out;
    default: 
#line 360 
    ;
    
#line 361 
    printk("\001",ret_code);
    
#line 362 
    status = VXGE_HW_FAIL;
    
#line 363 
    goto out;
  }
  ldv_52169: 
#line 366 
  ;
  
#line 366 
  fwdata += 16U;
  
#line 299 
  size += -16;
  ldv_52187: 
#line 300 
  ;
  
#line 299 
  if (size > 0) 
#line 301 
                goto ldv_52186; else 
#line 304 
                                     goto ldv_52188;
  ldv_52188: 
#line 305 
  ;
  out: 
#line 368 
  ;
  
#line 369 
  __retres = status;
  return_label: 
#line 369 
                return __retres;
}


#line 373  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_eprom_img_ver_get(struct __vxge_hw_device *hldev, struct eprom_image *img)
{
  struct __vxge_hw_virtualpath *vpath;
  enum vxge_hw_status status;
  int i;
  
#line 376 
  u64 data0 = 0ULL;
  
#line 376 
  u64 data1 = 0ULL;
  
#line 376 
  u64 steer_ctrl = 0ULL;
  
#line 381 
  vpath = & hldev->virtual_paths[hldev->first_vp_id];
  
#line 383 
  i = 0;
  
#line 383 
  goto ldv_52201;
  ldv_52200: 
#line 384 
  ;
  
#line 384 
  data0 = (unsigned long long)i << 40;
  
#line 385 
  steer_ctrl = 0ULL;
  
#line 385 
  data1 = steer_ctrl;
  
#line 387 
  status = vxge_hw_vpath_fw_api(vpath,31U,13U,0U,& data0,& data1,& steer_ctrl);
  
#line 391 
  if (status != VXGE_HW_OK) 
#line 392 
                            goto ldv_52199; else ;
  
#line 394 
  (img + i)->is_valid = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))(data0 >> 32);
  
#line 395 
  (img + i)->index = (unsigned char)(data0 >> 40);
  
#line 396 
  (img + i)->type = (unsigned char)(data0 >> 16);
  
#line 397 
  (img + i)->version = (unsigned short)data0;
  
#line 383 
  i += 1;
  ldv_52201: 
#line 384 
  ;
  
#line 383 
  if (i <= 7) 
#line 385 
              goto ldv_52200; else 
#line 388 
                                   goto ldv_52199;
  ldv_52199: 
#line 389 
  ;
  
#line 400 
  return status;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_channel_free(struct __vxge_hw_channel *channel)
{
  
#line 410 
  kfree((void const *)channel->work_arr);
  
#line 411 
  kfree((void const *)channel->free_arr);
  
#line 412 
  kfree((void const *)channel->reserve_arr);
  
#line 413 
  kfree((void const *)channel->orig_arr);
  
#line 414 
  kfree((void const *)channel);
  
#line 415 
  return;
}


#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_channel_initialize(struct __vxge_hw_channel *channel)
{
  enum vxge_hw_status __retres;
  u32 i;
  struct __vxge_hw_virtualpath *vpath;
  
#line 428 
  vpath = (channel->vph)->vpath;
  
#line 430 
  if (channel->reserve_arr != (void **)0 && channel->orig_arr != (void **)0) {
    
#line 431 
    i = 0U;
    
#line 431 
    goto ldv_52211;
    ldv_52210: 
#line 432 
    ;
    
#line 432 
    *(channel->orig_arr + i) = *(channel->reserve_arr + i);
    
#line 431 
    i += 1U;
    ldv_52211: 
#line 432 
    ;
    
#line 431 
    if (channel->length > i) 
#line 433 
                             goto ldv_52210; else 
#line 436 
                                                  goto ldv_52212;
    ldv_52212: 
#line 437 
    ;
  }
  else ;
  
#line 435 
  switch ((unsigned int)channel->type) {
    case (unsigned int)1: 
#line 436 
    ;
    
#line 437 
    vpath->fifoh = (struct __vxge_hw_fifo *)channel;
    
#line 438 
    channel->stats = & (((struct __vxge_hw_fifo *)channel)->stats)->common_stats;
    
#line 440 
    goto ldv_52214;
    case (unsigned int)2: 
#line 441 
    ;
    
#line 442 
    vpath->ringh = (struct __vxge_hw_ring *)channel;
    
#line 443 
    channel->stats = & (((struct __vxge_hw_ring *)channel)->stats)->common_stats;
    
#line 445 
    goto ldv_52214;
    default: 
#line 446 
    ;
    
#line 447 
    goto ldv_52214;
  }
  ldv_52214: 
#line 450 
  ;
  
#line 450 
  __retres = VXGE_HW_OK;
  
#line 450 
  return __retres;
}


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_channel_reset(struct __vxge_hw_channel *channel)
{
  enum vxge_hw_status __retres;
  u32 i;
  
#line 462 
  i = 0U;
  
#line 462 
  goto ldv_52222;
  ldv_52221: 
#line 463 
  ;
  
#line 463 
  if (channel->reserve_arr != (void **)0) 
#line 464 
                                          *(channel->reserve_arr + i) = *(channel->orig_arr + i); else ;
  
#line 465 
  if (channel->free_arr != (void **)0) 
#line 466 
                                       *(channel->free_arr + i) = (void *)0; else ;
  
#line 467 
  if (channel->work_arr != (void **)0) 
#line 468 
                                       *(channel->work_arr + i) = (void *)0; else ;
  
#line 462 
  i += 1U;
  ldv_52222: 
#line 463 
  ;
  
#line 462 
  if (channel->length > i) 
#line 464 
                           goto ldv_52221; else 
#line 467 
                                                goto ldv_52223;
  ldv_52223: 
#line 468 
  ;
  
#line 470 
  channel->free_ptr = channel->length;
  
#line 471 
  channel->reserve_ptr = channel->length;
  
#line 472 
  channel->reserve_top = 0U;
  
#line 473 
  channel->post_index = 0U;
  
#line 474 
  channel->compl_index = 0U;
  
#line 476 
  __retres = VXGE_HW_OK;
  
#line 476 
  return __retres;
}


#line 484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_device_pci_e_init(struct __vxge_hw_device *hldev)
{
  
#line 486 
  u16 cmd = (unsigned short)0U;
  
#line 489 
  pci_read_config_word((struct pci_dev const *)hldev->pdev,4,& cmd);
  
#line 490 
  cmd = (unsigned short)((unsigned int)cmd | 320U);
  
#line 491 
  pci_write_config_word((struct pci_dev const *)hldev->pdev,4,(unsigned short)((int)cmd));
  
#line 493 
  pci_save_state(hldev->pdev);
  
#line 494 
  return;
}


#line 501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_device_vpath_reset_in_prog_check(u64 *vpath_rst_in_prog)
{
  enum vxge_hw_status status;
  
#line 504 
  status = __vxge_hw_device_register_poll((void *)vpath_rst_in_prog,18446603336221196288ULL,1000U);
  
#line 507 
  return status;
}


#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_legacy_swapper_set(struct vxge_hw_legacy_reg *legacy_reg)
{
  enum vxge_hw_status __retres;
  u64 val64;
  
#line 518 
  enum vxge_hw_status status = 0;
  
#line 520 
  val64 = (u64)readq((void const volatile *)(& legacy_reg->toc_swapper_fb));
  
#line 521 
  ldv_inline_asm();
  
#line 524 
  switch (val64) {
    case (u64)(-1985229329): 
#line 525 
    ;
    
#line 526 
    __retres = status;
    
#line 526 
    goto return_label;
    case (u64)(-425540480): 
#line 528 
    ;
    
#line 529 
    writeq(18446744073709551615UL,(void volatile *)(& legacy_reg->pifm_rd_swap_en));
    
#line 531 
    writeq(18446744073709551615UL,(void volatile *)(& legacy_reg->pifm_rd_flip_en));
    
#line 533 
    writeq(18446744073709551615UL,(void volatile *)(& legacy_reg->pifm_wr_swap_en));
    
#line 535 
    writeq(18446744073709551615UL,(void volatile *)(& legacy_reg->pifm_wr_flip_en));
    
#line 537 
    goto ldv_52239;
    case (u64)1732584193: 
#line 539 
    ;
    
#line 540 
    writeq(18446744073709551615UL,(void volatile *)(& legacy_reg->pifm_rd_swap_en));
    
#line 542 
    writeq(18446744073709551615UL,(void volatile *)(& legacy_reg->pifm_wr_swap_en));
    
#line 544 
    goto ldv_52239;
    case (u64)(-1848265737): 
#line 546 
    ;
    
#line 547 
    writeq(18446744073709551615UL,(void volatile *)(& legacy_reg->pifm_rd_flip_en));
    
#line 549 
    writeq(18446744073709551615UL,(void volatile *)(& legacy_reg->pifm_wr_flip_en));
    
#line 551 
    goto ldv_52239;
  }
  ldv_52239: 
#line 554 
  ;
  
#line 555 
  ldv_inline_asm();
  
#line 556 
  val64 = (u64)readq((void const volatile *)(& legacy_reg->toc_swapper_fb));
  
#line 558 
  if (val64 != 81985529216486895ULL) 
#line 559 
                                     status = VXGE_HW_ERR_SWAPPER_CTRL; else ;
  
#line 561 
  __retres = status;
  return_label: 
#line 561 
                return __retres;
}


#line 570  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static struct vxge_hw_toc_reg *__vxge_hw_device_toc_get(void *bar0)
{
  u64 val64;
  enum vxge_hw_status status;
  
#line 573 
  struct vxge_hw_toc_reg *toc = (struct vxge_hw_toc_reg *)0;
  
#line 576 
  struct vxge_hw_legacy_reg *legacy_reg = (struct vxge_hw_legacy_reg *)bar0;
  
#line 579 
  status = __vxge_hw_legacy_swapper_set(legacy_reg);
  
#line 580 
  if (status != VXGE_HW_OK) 
#line 581 
                            goto exit; else ;
  
#line 583 
  val64 = (u64)readq((void const volatile *)(& legacy_reg->toc_first_pointer));
  
#line 584 
  toc = (struct vxge_hw_toc_reg *)(bar0 + val64);
  exit: 
#line 585 
  ;
  
#line 586 
  return toc;
}


#line 596  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_device_reg_addr_get(struct __vxge_hw_device *hldev)
{
  u64 val64;
  u32 i;
  
#line 600 
  enum vxge_hw_status status = 0;
  
#line 602 
  hldev->legacy_reg = (struct vxge_hw_legacy_reg *)hldev->bar0;
  
#line 604 
  hldev->toc_reg = __vxge_hw_device_toc_get(hldev->bar0);
  
#line 605 
  if (hldev->toc_reg == (struct vxge_hw_toc_reg *)0) {
    
#line 606 
    status = VXGE_HW_FAIL;
    
#line 607 
    goto exit;
  }
  else ;
  
#line 610 
  val64 = (u64)readq((void const volatile *)(& (hldev->toc_reg)->toc_common_pointer));
  
#line 611 
  hldev->common_reg = (struct vxge_hw_common_reg *)(hldev->bar0 + val64);
  
#line 613 
  val64 = (u64)readq((void const volatile *)(& (hldev->toc_reg)->toc_mrpcim_pointer));
  
#line 614 
  hldev->mrpcim_reg = (struct vxge_hw_mrpcim_reg *)(hldev->bar0 + val64);
  
#line 616 
  i = 0U;
  
#line 616 
  goto ldv_52258;
  ldv_52257: 
#line 617 
  ;
  
#line 617 
  val64 = (u64)readq((void const volatile *)(& (hldev->toc_reg)->toc_srpcim_pointer[i]));
  
#line 618 
  hldev->srpcim_reg[i] = (struct vxge_hw_srpcim_reg *)(hldev->bar0 + val64);
  
#line 616 
  i += 1U;
  ldv_52258: 
#line 617 
  ;
  
#line 616 
  if (i <= 16U) 
#line 618 
                goto ldv_52257; else 
#line 621 
                                     goto ldv_52259;
  ldv_52259: 
#line 622 
  ;
  
#line 621 
  i = 0U;
  
#line 621 
  goto ldv_52261;
  ldv_52260: 
#line 622 
  ;
  
#line 622 
  val64 = (u64)readq((void const volatile *)(& (hldev->toc_reg)->toc_vpmgmt_pointer[i]));
  
#line 623 
  hldev->vpmgmt_reg[i] = (struct vxge_hw_vpmgmt_reg *)(hldev->bar0 + val64);
  
#line 621 
  i += 1U;
  ldv_52261: 
#line 622 
  ;
  
#line 621 
  if (i <= 16U) 
#line 623 
                goto ldv_52260; else 
#line 626 
                                     goto ldv_52262;
  ldv_52262: 
#line 627 
  ;
  
#line 626 
  i = 0U;
  
#line 626 
  goto ldv_52264;
  ldv_52263: 
#line 627 
  ;
  
#line 627 
  val64 = (u64)readq((void const volatile *)(& (hldev->toc_reg)->toc_vpath_pointer[i]));
  
#line 628 
  hldev->vpath_reg[i] = (struct vxge_hw_vpath_reg *)(hldev->bar0 + val64);
  
#line 626 
  i += 1U;
  ldv_52264: 
#line 627 
  ;
  
#line 626 
  if (i <= 16U) 
#line 628 
                goto ldv_52263; else 
#line 631 
                                     goto ldv_52265;
  ldv_52265: 
#line 632 
  ;
  
#line 631 
  val64 = (u64)readq((void const volatile *)(& (hldev->toc_reg)->toc_kdfc));
  
#line 633 
  switch (val64 & 7ULL) {
    case (unsigned long long)0: 
#line 634 
    ;
    
#line 635 
    hldev->kdfc = (u8 *)(hldev->bar0 + (val64 & (unsigned long long)18446744073709551608U));
    
#line 636 
    goto ldv_52267;
    default: 
#line 637 
    ;
    
#line 638 
    goto ldv_52267;
  }
  ldv_52267: 
#line 641 
  ;
  
#line 641 
  status = __vxge_hw_device_vpath_reset_in_prog_check(& (hldev->common_reg)->vpath_rst_in_prog);
  exit: 
#line 643 
  ;
  
#line 644 
  return status;
}


#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static u32 __vxge_hw_device_access_rights_get(u32 host_type, u32 func_id)
{
  
#line 654 
  u32 access_rights = 1U;
  
#line 656 
  switch (host_type) {
    case (u32)0: 
#line 657 
    ;
    
#line 658 
    if (func_id == 0U) 
#line 659 
                       access_rights |= 6U; else ;
    
#line 662 
    goto ldv_52275;
    case (u32)1: 
#line 663 
    ;
    
#line 664 
    access_rights |= 6U;
    
#line 666 
    goto ldv_52275;
    case (u32)2: 
#line 667 
    ;
    
#line 668 
    access_rights |= 6U;
    
#line 670 
    goto ldv_52275;
    case (u32)3: 
#line 671 
    ;
    case (u32)6: 
#line 672 
    ;
    case (u32)4: 
#line 673 
    ;
    
#line 674 
    goto ldv_52275;
    case (u32)5: 
#line 675 
    ;
    case (u32)7: 
#line 676 
    ;
    
#line 677 
    access_rights |= 2U;
    
#line 678 
    goto ldv_52275;
  }
  ldv_52275: 
#line 681 
  ;
  
#line 681 
  return access_rights;
}


#line 689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status __vxge_hw_device_is_privilaged(u32 host_type, u32 func_id)
{
  enum vxge_hw_status __retres;
  u32 tmp;
  
#line 691 
  tmp = __vxge_hw_device_access_rights_get(host_type,func_id);
  
#line 691 
  if ((tmp & 4U) != 0U) {
    
#line 694 
    __retres = VXGE_HW_OK;
    
#line 694 
    goto return_label;
  }
  else {
    
#line 696 
    __retres = VXGE_HW_ERR_PRIVILAGED_OPEARATION;
    
#line 696 
    goto return_label;
  }
  return_label: 
#line 691 
                return __retres;
}


#line 704  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static u32 __vxge_hw_vpath_func_id_get(struct vxge_hw_vpmgmt_reg *vpmgmt_reg)
{
  u32 __retres;
  u64 val64;
  
#line 708 
  val64 = (u64)readq((void const volatile *)(& vpmgmt_reg->vpath_to_func_map_cfg1));
  
#line 711 
  __retres = (unsigned int)(val64 >> 56) & 31U;
  
#line 711 
  return __retres;
}


#line 718  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_device_host_info_get(struct __vxge_hw_device *hldev)
{
  u64 val64;
  u32 i;
  
#line 723 
  val64 = (u64)readq((void const volatile *)(& (hldev->common_reg)->host_type_assignments));
  
#line 725 
  hldev->host_type = (unsigned int)(val64 >> 56) & 7U;
  
#line 728 
  hldev->vpath_assignments = (u64)readq((void const volatile *)(& (hldev->common_reg)->vpath_assignments));
  
#line 730 
  i = 0U;
  
#line 730 
  goto ldv_52299;
  ldv_52298: 
#line 731 
  ;
  
#line 731 
  if ((hldev->vpath_assignments & (9223372036854775808ULL >> i)) == 0ULL) 
    
#line 732 
    goto ldv_52296; else ;
  
#line 734 
  hldev->func_id = __vxge_hw_vpath_func_id_get(hldev->vpmgmt_reg[i]);
  
#line 737 
  hldev->access_rights = __vxge_hw_device_access_rights_get(hldev->host_type,hldev->func_id);
  
#line 740 
  hldev->virtual_paths[i].vp_open = 0U;
  
#line 741 
  hldev->virtual_paths[i].vp_reg = hldev->vpath_reg[i];
  
#line 743 
  hldev->first_vp_id = i;
  
#line 744 
  goto ldv_52297;
  ldv_52296: 
#line 745 
  ;
  
#line 730 
  i += 1U;
  ldv_52299: 
#line 731 
  ;
  
#line 730 
  if (i <= 16U) 
#line 732 
                goto ldv_52298; else 
#line 735 
                                     goto ldv_52297;
  ldv_52297: 
#line 736 
  ;
  
#line 737 
  return;
}


#line 753  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_verify_pci_e_info(struct __vxge_hw_device *hldev)
{
  enum vxge_hw_status __retres;
  u16 lnk;
  
#line 755 
  struct pci_dev *dev = hldev->pdev;
  
#line 759 
  pcie_capability_read_word(dev,18,& lnk);
  
#line 761 
  if (((int)lnk & 15) != 1) {
    
#line 762 
    __retres = VXGE_HW_ERR_INVALID_PCI_INFO;
    
#line 762 
    goto return_label;
  }
  else ;
  
#line 764 
  switch (((int)lnk >> 4) & 63) {
    case 0: 
#line 765 
    ;
    case 1: 
#line 766 
    ;
    case 2: 
#line 767 
    ;
    case 4: 
#line 768 
    ;
    case 8: 
#line 769 
    ;
    
#line 770 
    goto ldv_52310;
    default: 
#line 771 
    ;
    
#line 772 
    __retres = VXGE_HW_ERR_INVALID_PCI_INFO;
    
#line 772 
    goto return_label;
  }
  ldv_52310: 
#line 775 
  ;
  
#line 775 
  __retres = VXGE_HW_OK;
  return_label: 
#line 775 
                return __retres;
}


#line 783  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_device_initialize(struct __vxge_hw_device *hldev)
{
  enum vxge_hw_status tmp;
  
#line 785 
  enum vxge_hw_status status = 0;
  
#line 787 
  tmp = __vxge_hw_device_is_privilaged(hldev->host_type,hldev->func_id);
  
#line 787 
  if (tmp == VXGE_HW_OK) {
    
#line 790 
    status = __vxge_hw_verify_pci_e_info(hldev);
    
#line 791 
    if (status != VXGE_HW_OK) 
#line 792 
                              goto exit; else ;
  }
  else ;
  exit: 
#line 795 
  ;
  
#line 796 
  return status;
}


#line 804  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_fw_ver_get(struct __vxge_hw_virtualpath *vpath, struct vxge_hw_device_hw_info *hw_info)
{
  u64 data0;
  enum vxge_hw_status status;
  
#line 807 
  struct vxge_hw_device_version *fw_version = & hw_info->fw_version;
  
#line 808 
  struct vxge_hw_device_date *fw_date = & hw_info->fw_date;
  
#line 809 
  struct vxge_hw_device_version *flash_version = & hw_info->flash_version;
  
#line 810 
  struct vxge_hw_device_date *flash_date = & hw_info->flash_date;
  
#line 811 
  u64 data1 = 0ULL;
  
#line 811 
  u64 steer_ctrl = 0ULL;
  
#line 814 
  status = vxge_hw_vpath_fw_api(vpath,0U,13U,0U,& data0,& data1,& steer_ctrl);
  
#line 818 
  if (status != VXGE_HW_OK) 
#line 819 
                            goto exit; else ;
  
#line 821 
  fw_date->day = (unsigned int)(data0 >> 56) & 255U;
  
#line 823 
  fw_date->month = (unsigned int)(data0 >> 48) & 255U;
  
#line 825 
  fw_date->year = (unsigned int)(data0 >> 32) & 65535U;
  
#line 828 
  snprintf((char *)(& fw_date->date),32UL,"%2.2d/%2.2d/%4.4d",fw_date->month,fw_date->day,fw_date->year);
  
#line 831 
  fw_version->major = (unsigned int)(data0 >> 24) & 255U;
  
#line 833 
  fw_version->minor = (unsigned int)(data0 >> 16) & 255U;
  
#line 835 
  fw_version->build = (unsigned int)data0 & 65535U;
  
#line 838 
  snprintf((char *)(& fw_version->version),32UL,"%d.%d.%d",fw_version->major,fw_version->minor,fw_version->build);
  
#line 841 
  flash_date->day = (unsigned int)(data1 >> 56) & 255U;
  
#line 843 
  flash_date->month = (unsigned int)(data1 >> 48) & 255U;
  
#line 845 
  flash_date->year = (unsigned int)(data1 >> 32) & 65535U;
  
#line 848 
  snprintf((char *)(& flash_date->date),32UL,"%2.2d/%2.2d/%4.4d",flash_date->month,flash_date->day,flash_date->year);
  
#line 851 
  flash_version->major = (unsigned int)(data1 >> 24) & 255U;
  
#line 853 
  flash_version->minor = (unsigned int)(data1 >> 16) & 255U;
  
#line 855 
  flash_version->build = (unsigned int)data1 & 65535U;
  
#line 858 
  snprintf((char *)(& flash_version->version),32UL,"%d.%d.%d",flash_version->major,flash_version->minor,flash_version->build);
  exit: 
#line 862 
  ;
  
#line 863 
  return status;
}


#line 871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_card_info_get(struct __vxge_hw_virtualpath *vpath, struct vxge_hw_device_hw_info *hw_info)
{
  enum vxge_hw_status __retres;
  enum vxge_hw_status status;
  u64 data0;
  u32 i;
  u32 tmp_3;
  u32 tmp_5;
  
#line 875 
  u64 data1 = 0ULL;
  
#line 875 
  u64 steer_ctrl = 0ULL;
  
#line 876 
  u8 *serial_number = (u8 *)(& hw_info->serial_number);
  
#line 877 
  u8 *part_number = (u8 *)(& hw_info->part_number);
  
#line 878 
  u8 *product_desc = (u8 *)(& hw_info->product_desc);
  
#line 879 
  u32 j = 0U;
  
#line 881 
  data0 = 1ULL;
  
#line 883 
  status = vxge_hw_vpath_fw_api(vpath,3U,13U,0U,& data0,& data1,& steer_ctrl);
  
#line 887 
  if (status != VXGE_HW_OK) {
    
#line 888 
    __retres = status;
    
#line 888 
    goto return_label;
  }
  else ;
  
#line 890 
  if (0 != 0) 
#line 890 
              *((u64 *)serial_number) = (((((((data0 << 56) | ((data0 << 40) & 71776119061217280ULL)) | ((data0 << 24) & 280375465082880ULL)) | ((data0 << 8) & 1095216660480ULL)) | ((data0 >> 8) & 4278190080ULL)) | ((data0 >> 24) & 16711680ULL)) | ((data0 >> 40) & 65280ULL)) | (data0 >> 56); else 
                                                                    
#line 890 
                                                                    *((u64 *)serial_number) = __fswab64(data0);
  
#line 891 
  if (0 != 0) 
#line 891 
              *((u64 *)serial_number + 1U) = (((((((data1 << 56) | ((data1 << 40) & 71776119061217280ULL)) | ((data1 << 24) & 280375465082880ULL)) | ((data1 << 8) & 1095216660480ULL)) | ((data1 >> 8) & 4278190080ULL)) | ((data1 >> 24) & 16711680ULL)) | ((data1 >> 40) & 65280ULL)) | (data1 >> 56); else 
                                                                    
#line 891 
                                                                    *((u64 *)serial_number + 1U) = __fswab64(data1);
  
#line 893 
  data0 = 0ULL;
  
#line 894 
  steer_ctrl = 0ULL;
  
#line 894 
  data1 = steer_ctrl;
  
#line 896 
  status = vxge_hw_vpath_fw_api(vpath,3U,13U,0U,& data0,& data1,& steer_ctrl);
  
#line 900 
  if (status != VXGE_HW_OK) {
    
#line 901 
    __retres = status;
    
#line 901 
    goto return_label;
  }
  else ;
  
#line 903 
  if (0 != 0) 
#line 903 
              *((u64 *)part_number) = (((((((data0 << 56) | ((data0 << 40) & 71776119061217280ULL)) | ((data0 << 24) & 280375465082880ULL)) | ((data0 << 8) & 1095216660480ULL)) | ((data0 >> 8) & 4278190080ULL)) | ((data0 >> 24) & 16711680ULL)) | ((data0 >> 40) & 65280ULL)) | (data0 >> 56); else 
                                                                    
#line 903 
                                                                    *((u64 *)part_number) = __fswab64(data0);
  
#line 904 
  if (0 != 0) 
#line 904 
              *((u64 *)part_number + 1U) = (((((((data1 << 56) | ((data1 << 40) & 71776119061217280ULL)) | ((data1 << 24) & 280375465082880ULL)) | ((data1 << 8) & 1095216660480ULL)) | ((data1 >> 8) & 4278190080ULL)) | ((data1 >> 24) & 16711680ULL)) | ((data1 >> 40) & 65280ULL)) | (data1 >> 56); else 
                                                                    
#line 904 
                                                                    *((u64 *)part_number + 1U) = __fswab64(data1);
  
#line 906 
  i = 4U;
  
#line 906 
  goto ldv_52344;
  ldv_52343: 
#line 907 
  ;
  
#line 908 
  data0 = (unsigned long long)i;
  
#line 909 
  steer_ctrl = 0ULL;
  
#line 909 
  data1 = steer_ctrl;
  
#line 911 
  status = vxge_hw_vpath_fw_api(vpath,3U,13U,0U,& data0,& data1,& steer_ctrl);
  
#line 915 
  if (status != VXGE_HW_OK) {
    
#line 916 
    __retres = status;
    
#line 916 
    goto return_label;
  }
  else ;
  
#line 918 
  tmp_3 = j;
  
#line 918 
  j += 1U;
  
#line 918 
  if (0 != 0) 
#line 918 
              *((u64 *)product_desc + tmp_3) = (((((((data0 << 56) | ((data0 << 40) & 71776119061217280ULL)) | ((data0 << 24) & 280375465082880ULL)) | ((data0 << 8) & 1095216660480ULL)) | ((data0 >> 8) & 4278190080ULL)) | ((data0 >> 24) & 16711680ULL)) | ((data0 >> 40) & 65280ULL)) | (data0 >> 56); else 
                                                                    
#line 918 
                                                                    *((u64 *)product_desc + tmp_3) = __fswab64(data0);
  
#line 919 
  tmp_5 = j;
  
#line 919 
  j += 1U;
  
#line 919 
  if (0 != 0) 
#line 919 
              *((u64 *)product_desc + tmp_5) = (((((((data1 << 56) | ((data1 << 40) & 71776119061217280ULL)) | ((data1 << 24) & 280375465082880ULL)) | ((data1 << 8) & 1095216660480ULL)) | ((data1 >> 8) & 4278190080ULL)) | ((data1 >> 24) & 16711680ULL)) | ((data1 >> 40) & 65280ULL)) | (data1 >> 56); else 
                                                                    
#line 919 
                                                                    *((u64 *)product_desc + tmp_5) = __fswab64(data1);
  
#line 907 
  i += 1U;
  ldv_52344: 
#line 908 
  ;
  
#line 906 
  if (i <= 7U) 
#line 909 
               goto ldv_52343; else 
#line 912 
                                    goto ldv_52345;
  ldv_52345: 
#line 913 
  ;
  
#line 922 
  __retres = status;
  return_label: 
#line 922 
                return __retres;
}


#line 930  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_pci_func_mode_get(struct __vxge_hw_virtualpath *vpath, struct vxge_hw_device_hw_info *hw_info)
{
  enum vxge_hw_status __retres;
  u64 data0;
  enum vxge_hw_status status;
  
#line 933 
  u64 data1 = 0ULL;
  
#line 933 
  u64 steer_ctrl = 0ULL;
  
#line 936 
  data0 = 0ULL;
  
#line 938 
  status = vxge_hw_vpath_fw_api(vpath,29U,13U,0U,& data0,& data1,& steer_ctrl);
  
#line 942 
  if (status != VXGE_HW_OK) {
    
#line 943 
    __retres = status;
    
#line 943 
    goto return_label;
  }
  else ;
  
#line 945 
  hw_info->function_mode = data0 & 255ULL;
  
#line 946 
  __retres = status;
  return_label: 
#line 946 
                return __retres;
}


#line 954  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_addr_get(struct __vxge_hw_virtualpath *vpath, u8 *macaddr, u8 *macaddr_mask)
{
  enum vxge_hw_status status;
  int i;
  int tmp_0;
  bool tmp;
  
#line 957 
  u64 action = 2ULL;
  
#line 958 
  u64 data0 = 0ULL;
  
#line 958 
  u64 data1 = 0ULL;
  
#line 958 
  u64 steer_ctrl = 0ULL;
  ldv_52369: 
#line 961 
  ;
  
#line 963 
  status = vxge_hw_vpath_fw_api(vpath,(unsigned int)action,0U,0U,& data0,& data1,& steer_ctrl);
  
#line 966 
  if (status != VXGE_HW_OK) 
#line 967 
                            goto exit; else ;
  
#line 969 
  data0 >>= 16;
  
#line 970 
  data1 >>= 16;
  
#line 973 
  i = 6;
  
#line 973 
  goto ldv_52367;
  ldv_52366: 
#line 974 
  ;
  
#line 974 
  *(macaddr + ((unsigned long)i + 18446744073709551615U)) = (unsigned char)data0;
  
#line 975 
  data0 >>= 8;
  
#line 977 
  *(macaddr_mask + ((unsigned long)i + 18446744073709551615U)) = (unsigned char)data1;
  
#line 978 
  data1 >>= 8;
  
#line 973 
  i -= 1;
  ldv_52367: 
#line 974 
  ;
  
#line 973 
  if (i > 0) 
#line 975 
             goto ldv_52366; else 
#line 978 
                                  goto ldv_52368;
  ldv_52368: 
#line 979 
  ;
  
#line 981 
  action = 3ULL;
  
#line 982 
  data0 = 0ULL;
  
#line 982 
  data1 = 0ULL;
  
#line 982 
  steer_ctrl = 0ULL;
  
#line 984 
  tmp = is_valid_ether_addr((u8 const *)macaddr);
  
#line 984 
  if (tmp) 
#line 984 
           tmp_0 = 0; else 
#line 984 
                           tmp_0 = 1;
  
#line 984 
  if (tmp_0) 
#line 986 
             goto ldv_52369; else 
#line 989 
                                  goto ldv_52370;
  ldv_52370: 
#line 990 
  ;
  exit: 
#line 985 
  ;
  
#line 986 
  return status;
}


#line 996  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_device_hw_info_get(void *bar0, struct vxge_hw_device_hw_info *hw_info)
{
  u32 i;
  u64 val64;
  struct vxge_hw_toc_reg *toc;
  struct vxge_hw_mrpcim_reg *mrpcim_reg;
  struct vxge_hw_common_reg *common_reg;
  struct vxge_hw_vpmgmt_reg *vpmgmt_reg;
  enum vxge_hw_status status;
  struct __vxge_hw_virtualpath vpath;
  u32 tmp_4;
  
#line 1008 
  memset((void *)hw_info,0,608UL);
  
#line 1010 
  toc = __vxge_hw_device_toc_get(bar0);
  
#line 1011 
  if (toc == (struct vxge_hw_toc_reg *)0) {
    
#line 1012 
    status = VXGE_HW_ERR_CRITICAL;
    
#line 1013 
    goto exit;
  }
  else ;
  
#line 1016 
  val64 = (u64)readq((void const volatile *)(& toc->toc_common_pointer));
  
#line 1017 
  common_reg = (struct vxge_hw_common_reg *)(bar0 + val64);
  
#line 1019 
  status = __vxge_hw_device_vpath_reset_in_prog_check(& common_reg->vpath_rst_in_prog);
  
#line 1021 
  if (status != VXGE_HW_OK) 
#line 1022 
                            goto exit; else ;
  
#line 1024 
  hw_info->vpath_mask = (u64)readq((void const volatile *)(& common_reg->vpath_assignments));
  
#line 1026 
  val64 = (u64)readq((void const volatile *)(& common_reg->host_type_assignments));
  
#line 1028 
  hw_info->host_type = (unsigned int)(val64 >> 56) & 7U;
  
#line 1031 
  i = 0U;
  
#line 1031 
  goto ldv_52388;
  ldv_52387: 
#line 1032 
  ;
  
#line 1032 
  if ((hw_info->vpath_mask & (9223372036854775808ULL >> i)) == 0ULL) 
    
#line 1033 
    goto ldv_52384; else ;
  
#line 1035 
  val64 = (u64)readq((void const volatile *)(& toc->toc_vpmgmt_pointer[i]));
  
#line 1037 
  vpmgmt_reg = (struct vxge_hw_vpmgmt_reg *)(bar0 + val64);
  
#line 1039 
  hw_info->func_id = __vxge_hw_vpath_func_id_get(vpmgmt_reg);
  
#line 1040 
  tmp_4 = __vxge_hw_device_access_rights_get(hw_info->host_type,hw_info->func_id);
  
#line 1040 
  if ((tmp_4 & 4U) != 0U) {
    
#line 1044 
    val64 = (u64)readq((void const volatile *)(& toc->toc_mrpcim_pointer));
    
#line 1046 
    mrpcim_reg = (struct vxge_hw_mrpcim_reg *)(bar0 + val64);
    
#line 1048 
    writeq(0UL,(void volatile *)(& mrpcim_reg->xgmac_gen_fw_memo_mask));
    
#line 1049 
    ldv_inline_asm();
  }
  else ;
  
#line 1052 
  val64 = (u64)readq((void const volatile *)(& toc->toc_vpath_pointer[i]));
  
#line 1054 
  spinlock_check(& vpath.lock);
  {
    struct lock_class_key __key;
    
#line 1054 
    __raw_spin_lock_init(& vpath.lock.__anonCompField_spinlock_18.rlock,"&(&vpath.lock)->rlock",& __key);
  }
  
#line 1055 
  vpath.vp_reg = (struct vxge_hw_vpath_reg *)(bar0 + val64);
  
#line 1056 
  vpath.vp_open = 0U;
  
#line 1058 
  status = __vxge_hw_vpath_pci_func_mode_get(& vpath,hw_info);
  
#line 1059 
  if (status != VXGE_HW_OK) 
#line 1060 
                            goto exit; else ;
  
#line 1062 
  status = __vxge_hw_vpath_fw_ver_get(& vpath,hw_info);
  
#line 1063 
  if (status != VXGE_HW_OK) 
#line 1064 
                            goto exit; else ;
  
#line 1066 
  status = __vxge_hw_vpath_card_info_get(& vpath,hw_info);
  
#line 1067 
  if (status != VXGE_HW_OK) 
#line 1068 
                            goto exit; else ;
  
#line 1070 
  goto ldv_52386;
  ldv_52384: 
#line 1071 
  ;
  
#line 1031 
  i += 1U;
  ldv_52388: 
#line 1032 
  ;
  
#line 1031 
  if (i <= 16U) 
#line 1033 
                goto ldv_52387; else 
#line 1036 
                                     goto ldv_52386;
  ldv_52386: 
#line 1037 
  ;
  
#line 1073 
  i = 0U;
  
#line 1073 
  goto ldv_52391;
  ldv_52390: 
#line 1074 
  ;
  
#line 1074 
  if ((hw_info->vpath_mask & (9223372036854775808ULL >> i)) == 0ULL) 
    
#line 1075 
    goto ldv_52389; else ;
  
#line 1077 
  val64 = (u64)readq((void const volatile *)(& toc->toc_vpath_pointer[i]));
  
#line 1078 
  vpath.vp_reg = (struct vxge_hw_vpath_reg *)(bar0 + val64);
  
#line 1079 
  vpath.vp_open = 0U;
  
#line 1081 
  status = __vxge_hw_vpath_addr_get(& vpath,(u8 *)(& hw_info->mac_addrs[i]),(u8 *)(& hw_info->mac_addr_masks[i]));
  
#line 1084 
  if (status != VXGE_HW_OK) 
#line 1085 
                            goto exit; else ;
  ldv_52389: 
#line 1086 
  ;
  
#line 1073 
  i += 1U;
  ldv_52391: 
#line 1074 
  ;
  
#line 1073 
  if (i <= 16U) 
#line 1075 
                goto ldv_52390; else 
#line 1078 
                                     goto ldv_52392;
  ldv_52392: 
#line 1079 
  ;
  exit: 
#line 1087 
  ;
  
#line 1088 
  return status;
}


#line 1094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_blockpool_destroy(struct __vxge_hw_blockpool *blockpool)
{
  struct __vxge_hw_device *hldev;
  struct list_head *p;
  struct list_head *n;
  u16 ret;
  
#line 1100 
  if (blockpool == (struct __vxge_hw_blockpool *)0) {
    
#line 1101 
    ret = (unsigned short)1U;
    
#line 1102 
    goto exit;
  }
  else ;
  
#line 1105 
  hldev = blockpool->hldev;
  
#line 1107 
  p = blockpool->free_block_list.next;
  
#line 1107 
  n = p->next;
  
#line 1107 
  goto ldv_52402;
  ldv_52401: 
#line 1108 
  ;
  
#line 1108 
  pci_unmap_single(hldev->pdev,((struct __vxge_hw_blockpool_entry *)p)->dma_addr,(unsigned long)((struct __vxge_hw_blockpool_entry *)p)->length,0);
  
#line 1113 
  vxge_os_dma_free(hldev->pdev,(void const *)((struct __vxge_hw_blockpool_entry *)p)->memblock,& ((struct __vxge_hw_blockpool_entry *)p)->acc_handle);
  
#line 1117 
  list_del(& ((struct __vxge_hw_blockpool_entry *)p)->item);
  
#line 1118 
  kfree((void const *)p);
  
#line 1119 
  blockpool->pool_size -= 1U;
  
#line 1107 
  p = n;
  
#line 1107 
  n = p->next;
  ldv_52402: 
#line 1108 
  ;
  
#line 1107 
  if (& blockpool->free_block_list != p) 
#line 1109 
                                         goto ldv_52401; else 
#line 1112 
                                                              goto ldv_52403;
  ldv_52403: 
#line 1113 
  ;
  
#line 1122 
  p = blockpool->free_entry_list.next;
  
#line 1122 
  n = p->next;
  
#line 1122 
  goto ldv_52405;
  ldv_52404: 
#line 1123 
  ;
  
#line 1123 
  list_del(& ((struct __vxge_hw_blockpool_entry *)p)->item);
  
#line 1124 
  kfree((void const *)p);
  
#line 1122 
  p = n;
  
#line 1122 
  n = p->next;
  ldv_52405: 
#line 1123 
  ;
  
#line 1122 
  if (& blockpool->free_entry_list != p) 
#line 1124 
                                         goto ldv_52404; else 
#line 1127 
                                                              goto ldv_52406;
  ldv_52406: 
#line 1128 
  ;
  
#line 1126 
  ret = (unsigned short)0U;
  exit: 
#line 1127 
  ;
  
#line 1128 
  return;
}


#line 1135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_blockpool_create(struct __vxge_hw_device *hldev, struct __vxge_hw_blockpool *blockpool, u32 pool_size, u32 pool_max)
{
  u32 i;
  void *memblock;
  dma_addr_t dma_addr;
  struct pci_dev *dma_handle;
  struct pci_dev *acc_handle;
  int tmp_0;
  int tmp_2;
  
#line 1141 
  struct __vxge_hw_blockpool_entry *entry = (struct __vxge_hw_blockpool_entry *)0;
  
#line 1146 
  enum vxge_hw_status status = 0;
  
#line 1148 
  if (blockpool == (struct __vxge_hw_blockpool *)0) {
    
#line 1149 
    status = VXGE_HW_FAIL;
    
#line 1150 
    goto blockpool_create_exit;
  }
  else ;
  
#line 1153 
  blockpool->hldev = hldev;
  
#line 1154 
  blockpool->block_size = 4096U;
  
#line 1155 
  blockpool->pool_size = 0U;
  
#line 1156 
  blockpool->pool_max = pool_max;
  
#line 1157 
  blockpool->req_out = 0U;
  
#line 1159 
  INIT_LIST_HEAD(& blockpool->free_block_list);
  
#line 1160 
  INIT_LIST_HEAD(& blockpool->free_entry_list);
  
#line 1162 
  i = 0U;
  
#line 1162 
  goto ldv_52422;
  ldv_52421: 
#line 1163 
  ;
  
#line 1163 
  entry = (struct __vxge_hw_blockpool_entry *)kzalloc_1(56UL,208U);
  
#line 1165 
  if (entry == (struct __vxge_hw_blockpool_entry *)0) {
    
#line 1166 
    __vxge_hw_blockpool_destroy(blockpool);
    
#line 1167 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 1168 
    goto blockpool_create_exit;
  }
  else ;
  
#line 1170 
  list_add(& entry->item,& blockpool->free_entry_list);
  
#line 1162 
  i += 1U;
  ldv_52422: 
#line 1163 
  ;
  
#line 1162 
  if (pool_size + pool_max > i) 
#line 1164 
                                goto ldv_52421; else 
#line 1167 
                                                     goto ldv_52423;
  ldv_52423: 
#line 1168 
  ;
  
#line 1173 
  i = 0U;
  
#line 1173 
  goto ldv_52427;
  ldv_52426: 
#line 1174 
  ;
  
#line 1174 
  memblock = vxge_os_dma_malloc(hldev->pdev,4096UL,& dma_handle,& acc_handle);
  
#line 1179 
  if (memblock == (void *)0) {
    
#line 1180 
    __vxge_hw_blockpool_destroy(blockpool);
    
#line 1181 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 1182 
    goto blockpool_create_exit;
  }
  else ;
  
#line 1185 
  dma_addr = pci_map_single(hldev->pdev,memblock,4096UL,0);
  
#line 1187 
  tmp_0 = pci_dma_mapping_error(hldev->pdev,dma_addr);
  
#line 1187 
  if ((long)(tmp_0 != 0) != 0L) {
    
#line 1189 
    vxge_os_dma_free(hldev->pdev,(void const *)memblock,& acc_handle);
    
#line 1190 
    __vxge_hw_blockpool_destroy(blockpool);
    
#line 1191 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 1192 
    goto blockpool_create_exit;
  }
  else ;
  
#line 1195 
  tmp_2 = list_empty((struct list_head const *)(& blockpool->free_entry_list));
  
#line 1195 
  if (tmp_2 == 0) {
    struct __vxge_hw_blockpool_entry *tmp_1;
    {
      
#line 1197 
      struct list_head const *__mptr = (struct list_head const *)blockpool->free_entry_list.next;
      
#line 1197 
      tmp_1 = (struct __vxge_hw_blockpool_entry *)__mptr;
    }
    
#line 1196 
    entry = tmp_1;
  }
  else ;
  
#line 1201 
  if (entry == (struct __vxge_hw_blockpool_entry *)0) 
#line 1203 
                                                      entry = (struct __vxge_hw_blockpool_entry *)kzalloc_1(56UL,208U); else ;
  
#line 1205 
  if (entry != (struct __vxge_hw_blockpool_entry *)0) {
    
#line 1206 
    list_del(& entry->item);
    
#line 1207 
    entry->length = 4096U;
    
#line 1208 
    entry->memblock = memblock;
    
#line 1209 
    entry->dma_addr = dma_addr;
    
#line 1210 
    entry->acc_handle = acc_handle;
    
#line 1211 
    entry->dma_handle = dma_handle;
    
#line 1212 
    list_add(& entry->item,& blockpool->free_block_list);
    
#line 1214 
    blockpool->pool_size += 1U;
  }
  else {
    
#line 1216 
    __vxge_hw_blockpool_destroy(blockpool);
    
#line 1217 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 1218 
    goto blockpool_create_exit;
  }
  
#line 1173 
  i += 1U;
  ldv_52427: 
#line 1174 
  ;
  
#line 1173 
  if (i < pool_size) 
#line 1175 
                     goto ldv_52426; else 
#line 1178 
                                          goto ldv_52428;
  ldv_52428: 
#line 1179 
  ;
  blockpool_create_exit: 
#line 1222 
  ;
  
#line 1223 
  return status;
}


#line 1231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_device_fifo_config_check(struct vxge_hw_fifo_config *fifo_config)
{
  enum vxge_hw_status __retres;
  
#line 1233 
  if (fifo_config->fifo_blocks + 4294967294U > 126U) {
    
#line 1235 
    __retres = VXGE_HW_BADCFG_FIFO_BLOCKS;
    
#line 1235 
    goto return_label;
  }
  else ;
  
#line 1237 
  __retres = VXGE_HW_OK;
  return_label: 
#line 1237 
                return __retres;
}


#line 1245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_device_vpath_config_check(struct vxge_hw_vp_config *vp_config)
{
  enum vxge_hw_status __retres;
  enum vxge_hw_status status;
  
#line 1249 
  if (vp_config->min_bandwidth > 100U) {
    
#line 1251 
    __retres = VXGE_HW_BADCFG_VPATH_MIN_BANDWIDTH;
    
#line 1251 
    goto return_label;
  }
  else ;
  
#line 1253 
  status = __vxge_hw_device_fifo_config_check(& vp_config->fifo);
  
#line 1254 
  if (status != VXGE_HW_OK) {
    
#line 1255 
    __retres = status;
    
#line 1255 
    goto return_label;
  }
  else ;
  
#line 1257 
  if (vp_config->mtu != 4294967295U && vp_config->mtu + 4294967228U > 9532U) {
    
#line 1260 
    __retres = VXGE_HW_BADCFG_VPATH_MTU;
    
#line 1260 
    goto return_label;
  }
  else ;
  
#line 1262 
  if ((vp_config->rpa_strip_vlan_tag != 4294967295U && vp_config->rpa_strip_vlan_tag != 1U) && vp_config->rpa_strip_vlan_tag != 0U) {
    
#line 1268 
    __retres = VXGE_HW_BADCFG_VPATH_RPA_STRIP_VLAN_TAG;
    
#line 1268 
    goto return_label;
  }
  else ;
  
#line 1270 
  __retres = VXGE_HW_OK;
  return_label: 
#line 1270 
                return __retres;
}


#line 1278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_device_config_check(struct vxge_hw_device_config *new_config)
{
  enum vxge_hw_status __retres;
  u32 i;
  enum vxge_hw_status status;
  
#line 1283 
  if ((unsigned int)*((unsigned char *)new_config + 12UL) > 2U) {
    
#line 1287 
    __retres = VXGE_HW_BADCFG_INTR_MODE;
    
#line 1287 
    goto return_label;
  }
  else ;
  
#line 1293 
  i = 0U;
  
#line 1293 
  goto ldv_52442;
  ldv_52441: 
#line 1294 
  ;
  
#line 1294 
  status = __vxge_hw_device_vpath_config_check(& new_config->vp_config[i]);
  
#line 1296 
  if (status != VXGE_HW_OK) {
    
#line 1297 
    __retres = status;
    
#line 1297 
    goto return_label;
  }
  else ;
  
#line 1293 
  i += 1U;
  ldv_52442: 
#line 1294 
  ;
  
#line 1293 
  if (i <= 16U) 
#line 1295 
                goto ldv_52441; else 
#line 1298 
                                     goto ldv_52443;
  ldv_52443: 
#line 1299 
  ;
  
#line 1300 
  __retres = VXGE_HW_OK;
  return_label: 
#line 1300 
                return __retres;
}


#line 1313  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_device_initialize(struct __vxge_hw_device **devh, struct vxge_hw_device_attr *attr, struct vxge_hw_device_config *device_config)
{
  u32 i;
  enum vxge_hw_status tmp_0;
  
#line 1319 
  u32 nblocks = 0U;
  
#line 1320 
  struct __vxge_hw_device *hldev = (struct __vxge_hw_device *)0;
  
#line 1321 
  enum vxge_hw_status status = 0;
  
#line 1323 
  status = __vxge_hw_device_config_check(device_config);
  
#line 1324 
  if (status != VXGE_HW_OK) 
#line 1325 
                            goto exit; else ;
  
#line 1327 
  hldev = (struct __vxge_hw_device *)vzalloc(24320UL);
  
#line 1328 
  if (hldev == (struct __vxge_hw_device *)0) {
    
#line 1329 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 1330 
    goto exit;
  }
  else ;
  
#line 1333 
  hldev->magic = 305419896U;
  
#line 1335 
  vxge_hw_device_debug_set(hldev,(enum vxge_debug_level)VXGE_ERR,4294967295U);
  
#line 1338 
  memcpy((void *)(& hldev->config),(void const *)device_config,3280UL);
  
#line 1341 
  hldev->bar0 = attr->bar0;
  
#line 1342 
  hldev->pdev = attr->pdev;
  
#line 1344 
  hldev->uld_callbacks = attr->uld_callbacks;
  
#line 1346 
  __vxge_hw_device_pci_e_init(hldev);
  
#line 1348 
  status = __vxge_hw_device_reg_addr_get(hldev);
  
#line 1349 
  if (status != VXGE_HW_OK) {
    
#line 1350 
    vfree((void const *)hldev);
    
#line 1351 
    goto exit;
  }
  else ;
  
#line 1354 
  __vxge_hw_device_host_info_get(hldev);
  
#line 1357 
  nblocks += 1U;
  
#line 1359 
  i = 0U;
  
#line 1359 
  goto ldv_52456;
  ldv_52455: 
#line 1360 
  ;
  
#line 1360 
  if ((hldev->vpath_assignments & (9223372036854775808ULL >> i)) == 0ULL) 
    
#line 1361 
    goto ldv_52454; else ;
  
#line 1363 
  if (device_config->vp_config[i].ring.enable == 1U) 
#line 1365 
                                                     nblocks = device_config->vp_config[i].ring.ring_blocks + nblocks; else ;
  
#line 1367 
  if (device_config->vp_config[i].fifo.enable == 1U) 
#line 1369 
                                                     nblocks = device_config->vp_config[i].fifo.fifo_blocks + nblocks; else ;
  
#line 1370 
  nblocks += 1U;
  ldv_52454: 
#line 1371 
  ;
  
#line 1359 
  i += 1U;
  ldv_52456: 
#line 1360 
  ;
  
#line 1359 
  if (i <= 16U) 
#line 1361 
                goto ldv_52455; else 
#line 1364 
                                     goto ldv_52457;
  ldv_52457: 
#line 1365 
  ;
  
#line 1373 
  tmp_0 = __vxge_hw_blockpool_create(hldev,& hldev->block_pool,device_config->dma_blockpool_initial + nblocks,device_config->dma_blockpool_max + nblocks);
  
#line 1373 
  if (tmp_0 != VXGE_HW_OK) {
    
#line 1378 
    vxge_hw_device_terminate(hldev);
    
#line 1379 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 1380 
    goto exit;
  }
  else ;
  
#line 1383 
  status = __vxge_hw_device_initialize(hldev);
  
#line 1384 
  if (status != VXGE_HW_OK) {
    
#line 1385 
    vxge_hw_device_terminate(hldev);
    
#line 1386 
    goto exit;
  }
  else ;
  
#line 1389 
  *devh = hldev;
  exit: 
#line 1390 
  ;
  
#line 1391 
  return status;
}


#line 1399  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
void vxge_hw_device_terminate(struct __vxge_hw_device *hldev)
{
  
#line 1403 
  hldev->magic = 3735936685U;
  
#line 1404 
  __vxge_hw_blockpool_destroy(& hldev->block_pool);
  
#line 1405 
  vfree((void const *)hldev);
  
#line 1406 
  return;
}


#line 1413  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_stats_access(struct __vxge_hw_virtualpath *vpath, u32 operation, u32 offset, u64 *stat)
{
  u64 val64;
  struct vxge_hw_vpath_reg *vp_reg;
  
#line 1417 
  enum vxge_hw_status status = 0;
  
#line 1420 
  if (vpath->vp_open == 0U) {
    
#line 1421 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 1422 
    goto vpath_stats_access_exit;
  }
  else ;
  
#line 1425 
  vp_reg = vpath->vp_reg;
  
#line 1427 
  val64 = (((unsigned long long)operation << 56) | ((unsigned long long)offset << 24)) | 281474976710656ULL;
  
#line 1431 
  status = __vxge_hw_pio_mem_write64(val64,(void *)(& vp_reg->xmac_stats_access_cmd),281474976710656ULL,(vpath->hldev)->config.device_poll_millis);
  
#line 1435 
  if (status == VXGE_HW_OK && operation == 0U) 
#line 1436 
                                               *stat = (u64)readq((void const volatile *)(& vp_reg->xmac_stats_access_data)); else 
                                                                    
#line 1438 
                                                                    *stat = 0ULL;
  vpath_stats_access_exit: 
#line 1440 
  ;
  
#line 1441 
  return status;
}


#line 1448  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_xmac_tx_stats_get(struct __vxge_hw_virtualpath *vpath, struct vxge_hw_xmac_vpath_tx_stats *vpath_tx_stats)
{
  u64 *val64;
  int i;
  
#line 1453 
  u32 offset = 0U;
  
#line 1454 
  enum vxge_hw_status status = 0;
  
#line 1456 
  val64 = (u64 *)vpath_tx_stats;
  
#line 1458 
  if (vpath->vp_open == 0U) {
    
#line 1459 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 1460 
    goto exit;
  }
  else ;
  
#line 1463 
  i = 0;
  
#line 1463 
  goto ldv_52481;
  ldv_52480: 
#line 1464 
  ;
  
#line 1464 
  status = __vxge_hw_vpath_stats_access(vpath,0U,offset,val64);
  
#line 1467 
  if (status != VXGE_HW_OK) 
#line 1468 
                            goto exit; else ;
  
#line 1469 
  offset += 1U;
  
#line 1470 
  val64 += 1;
  
#line 1463 
  i += 1;
  ldv_52481: 
#line 1464 
  ;
  
#line 1463 
  if ((unsigned int)i <= 17U) 
#line 1465 
                              goto ldv_52480; else 
#line 1468 
                                                   goto ldv_52482;
  ldv_52482: 
#line 1469 
  ;
  exit: 
#line 1472 
  ;
  
#line 1473 
  return status;
}


#line 1480  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_xmac_rx_stats_get(struct __vxge_hw_virtualpath *vpath, struct vxge_hw_xmac_vpath_rx_stats *vpath_rx_stats)
{
  u64 *val64;
  int i;
  
#line 1484 
  enum vxge_hw_status status = 0;
  
#line 1486 
  u32 offset = 144U;
  
#line 1487 
  val64 = (u64 *)vpath_rx_stats;
  
#line 1489 
  if (vpath->vp_open == 0U) {
    
#line 1490 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 1491 
    goto exit;
  }
  else ;
  
#line 1493 
  i = 0;
  
#line 1493 
  goto ldv_52493;
  ldv_52492: 
#line 1494 
  ;
  
#line 1494 
  status = __vxge_hw_vpath_stats_access(vpath,0U,offset >> 3,val64);
  
#line 1497 
  if (status != VXGE_HW_OK) 
#line 1498 
                            goto exit; else ;
  
#line 1500 
  offset += 8U;
  
#line 1501 
  val64 += 1;
  
#line 1493 
  i += 1;
  ldv_52493: 
#line 1494 
  ;
  
#line 1493 
  if ((unsigned int)i <= 38U) 
#line 1495 
                              goto ldv_52492; else 
#line 1498 
                                                   goto ldv_52494;
  ldv_52494: 
#line 1499 
  ;
  exit: 
#line 1503 
  ;
  
#line 1504 
  return status;
}


#line 1511  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_stats_get(struct __vxge_hw_virtualpath *vpath, struct vxge_hw_vpath_stats_hw_info *hw_stats)
{
  enum vxge_hw_status __retres;
  u64 val64;
  struct vxge_hw_vpath_reg *vp_reg;
  
#line 1515 
  enum vxge_hw_status status = 0;
  
#line 1518 
  if (vpath->vp_open == 0U) {
    
#line 1519 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 1520 
    goto exit;
  }
  else ;
  
#line 1522 
  vp_reg = vpath->vp_reg;
  
#line 1524 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_debug_stats0));
  
#line 1525 
  hw_stats->ini_num_mwr_sent = (unsigned int)(val64 >> 32);
  
#line 1528 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_debug_stats1));
  
#line 1529 
  hw_stats->ini_num_mrd_sent = (unsigned int)(val64 >> 32);
  
#line 1532 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_debug_stats2));
  
#line 1533 
  hw_stats->ini_num_cpl_rcvd = (unsigned int)(val64 >> 32);
  
#line 1536 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_debug_stats3));
  
#line 1537 
  hw_stats->ini_num_mwr_byte_sent = val64;
  
#line 1540 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_debug_stats4));
  
#line 1541 
  hw_stats->ini_num_cpl_byte_rcvd = val64;
  
#line 1544 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_debug_stats5));
  
#line 1545 
  hw_stats->wrcrdtarb_xoff = (unsigned int)val64;
  
#line 1548 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_debug_stats6));
  
#line 1549 
  hw_stats->rdcrdtarb_xoff = (unsigned int)val64;
  
#line 1552 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_genstats_count01));
  
#line 1553 
  hw_stats->vpath_genstats_count0 = (unsigned int)val64;
  
#line 1557 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_genstats_count01));
  
#line 1558 
  hw_stats->vpath_genstats_count1 = (unsigned int)(val64 >> 32);
  
#line 1562 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_genstats_count23));
  
#line 1563 
  hw_stats->vpath_genstats_count2 = (unsigned int)val64;
  
#line 1567 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_genstats_count01));
  
#line 1568 
  hw_stats->vpath_genstats_count3 = (unsigned int)(val64 >> 32);
  
#line 1572 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_genstats_count4));
  
#line 1573 
  hw_stats->vpath_genstats_count4 = (unsigned int)(val64 >> 32);
  
#line 1577 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_genstats_count5));
  
#line 1578 
  hw_stats->vpath_genstats_count5 = (unsigned int)val64;
  
#line 1582 
  status = __vxge_hw_vpath_xmac_tx_stats_get(vpath,& hw_stats->tx_stats);
  
#line 1583 
  if (status != VXGE_HW_OK) 
#line 1584 
                            goto exit; else ;
  
#line 1586 
  status = __vxge_hw_vpath_xmac_rx_stats_get(vpath,& hw_stats->rx_stats);
  
#line 1587 
  if (status != VXGE_HW_OK) 
#line 1588 
                            goto exit; else ;
  
#line 1590 
  status = __vxge_hw_vpath_stats_access(vpath,0U,58U,& val64);
  
#line 1590 
  if (status != VXGE_HW_OK) {
    
#line 1590 
    __retres = status;
    
#line 1590 
    goto return_label;
  }
  else ;
  
#line 1593 
  hw_stats->prog_event_vnum0 = (unsigned int)(val64 >> 32);
  
#line 1596 
  hw_stats->prog_event_vnum1 = (unsigned int)val64;
  
#line 1599 
  status = __vxge_hw_vpath_stats_access(vpath,0U,59U,& val64);
  
#line 1599 
  if (status != VXGE_HW_OK) {
    
#line 1599 
    __retres = status;
    
#line 1599 
    goto return_label;
  }
  else ;
  
#line 1602 
  hw_stats->prog_event_vnum2 = (unsigned int)(val64 >> 32);
  
#line 1605 
  hw_stats->prog_event_vnum3 = (unsigned int)val64;
  
#line 1608 
  val64 = (u64)readq((void const volatile *)(& vp_reg->rx_multi_cast_stats));
  
#line 1609 
  hw_stats->rx_multi_cast_frame_discard = (unsigned short)val64;
  
#line 1612 
  val64 = (u64)readq((void const volatile *)(& vp_reg->rx_frm_transferred));
  
#line 1613 
  hw_stats->rx_frm_transferred = (unsigned int)val64;
  
#line 1616 
  val64 = (u64)readq((void const volatile *)(& vp_reg->rxd_returned));
  
#line 1617 
  hw_stats->rxd_returned = (unsigned short)val64;
  
#line 1620 
  val64 = (u64)readq((void const volatile *)(& vp_reg->dbg_stats_rx_mpa));
  
#line 1621 
  hw_stats->rx_mpa_len_fail_frms = (unsigned short)(val64 >> 16);
  
#line 1623 
  hw_stats->rx_mpa_mrk_fail_frms = (unsigned short)(val64 >> 32);
  
#line 1625 
  hw_stats->rx_mpa_crc_fail_frms = (unsigned short)(val64 >> 48);
  
#line 1628 
  val64 = (u64)readq((void const volatile *)(& vp_reg->dbg_stats_rx_fau));
  
#line 1629 
  hw_stats->rx_permitted_frms = (unsigned short)(val64 >> 16);
  
#line 1631 
  hw_stats->rx_vp_reset_discarded_frms = (unsigned long long)((unsigned short)(val64 >> 32));
  
#line 1633 
  hw_stats->rx_wol_frms = (unsigned long long)((unsigned short)(val64 >> 48));
  
#line 1636 
  val64 = (u64)readq((void const volatile *)(& vp_reg->tx_vp_reset_discarded_frms));
  
#line 1637 
  hw_stats->tx_vp_reset_discarded_frms = (unsigned long long)((unsigned short)val64);
  exit: 
#line 1640 
  ;
  
#line 1641 
  __retres = status;
  return_label: 
#line 1641 
                return __retres;
}


#line 1649  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_device_stats_get(struct __vxge_hw_device *hldev, struct vxge_hw_device_stats_hw_info *hw_stats)
{
  u32 i;
  
#line 1653 
  enum vxge_hw_status status = 0;
  
#line 1655 
  i = 0U;
  
#line 1655 
  goto ldv_52511;
  ldv_52510: 
#line 1656 
  ;
  
#line 1656 
  if ((hldev->vpaths_deployed & (9223372036854775808ULL >> i)) == 0ULL || hldev->virtual_paths[i].vp_open == 0U) 
    
#line 1659 
    goto ldv_52509; else ;
  
#line 1661 
  memcpy((void *)hldev->virtual_paths[i].hw_stats_sav,(void const *)hldev->virtual_paths[i].hw_stats,624UL);
  
#line 1665 
  status = __vxge_hw_vpath_stats_get(& hldev->virtual_paths[i],hldev->virtual_paths[i].hw_stats);
  ldv_52509: 
#line 1668 
  ;
  
#line 1655 
  i += 1U;
  ldv_52511: 
#line 1656 
  ;
  
#line 1655 
  if (i <= 16U) 
#line 1657 
                goto ldv_52510; else 
#line 1660 
                                     goto ldv_52512;
  ldv_52512: 
#line 1661 
  ;
  
#line 1670 
  memcpy((void *)hw_stats,(void const *)(& hldev->stats.hw_dev_info_stats),10744UL);
  
#line 1673 
  return status;
}


#line 1680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_driver_stats_get(struct __vxge_hw_device *hldev, struct vxge_hw_device_stats_sw_info *sw_stats)
{
  enum vxge_hw_status __retres;
  
#line 1684 
  memcpy((void *)sw_stats,(void const *)(& hldev->stats.sw_dev_info_stats),4096UL);
  
#line 1687 
  __retres = VXGE_HW_OK;
  
#line 1687 
  return __retres;
}


#line 1696  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_mrpcim_stats_access(struct __vxge_hw_device *hldev, u32 operation, u32 location, u32 offset, u64 *stat)
{
  u64 val64;
  
#line 1700 
  enum vxge_hw_status status = 0;
  
#line 1702 
  status = __vxge_hw_device_is_privilaged(hldev->host_type,hldev->func_id);
  
#line 1704 
  if (status != VXGE_HW_OK) 
#line 1705 
                            goto exit; else ;
  
#line 1707 
  val64 = ((((unsigned long long)operation << 56) | ((unsigned long long)location << 32)) | ((unsigned long long)offset << 24)) | 281474976710656ULL;
  
#line 1712 
  status = __vxge_hw_pio_mem_write64(val64,(void *)(& (hldev->mrpcim_reg)->xmac_stats_sys_cmd),281474976710656ULL,hldev->config.device_poll_millis);
  
#line 1717 
  if (status == VXGE_HW_OK && operation == 0U) 
#line 1718 
                                               *stat = (u64)readq((void const volatile *)(& (hldev->mrpcim_reg)->xmac_stats_sys_data)); else 
                                                                    
#line 1720 
                                                                    *stat = 0ULL;
  exit: 
#line 1721 
  ;
  
#line 1722 
  return status;
}


#line 1730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status vxge_hw_device_xmac_aggr_stats_get(struct __vxge_hw_device *hldev, u32 port, struct vxge_hw_xmac_aggr_stats *aggr_stats)
{
  u64 *val64;
  int i;
  
#line 1735 
  u32 offset = 1824U;
  
#line 1736 
  enum vxge_hw_status status = 0;
  
#line 1738 
  val64 = (u64 *)aggr_stats;
  
#line 1740 
  status = __vxge_hw_device_is_privilaged(hldev->host_type,hldev->func_id);
  
#line 1742 
  if (status != VXGE_HW_OK) 
#line 1743 
                            goto exit; else ;
  
#line 1745 
  i = 0;
  
#line 1745 
  goto ldv_52538;
  ldv_52537: 
#line 1746 
  ;
  
#line 1746 
  status = vxge_hw_mrpcim_stats_access(hldev,0U,17U,(port * 104U + offset) >> 3,val64);
  
#line 1750 
  if (status != VXGE_HW_OK) 
#line 1751 
                            goto exit; else ;
  
#line 1753 
  offset += 8U;
  
#line 1754 
  val64 += 1;
  
#line 1745 
  i += 1;
  ldv_52538: 
#line 1746 
  ;
  
#line 1745 
  if ((unsigned int)i <= 12U) 
#line 1747 
                              goto ldv_52537; else 
#line 1750 
                                                   goto ldv_52539;
  ldv_52539: 
#line 1751 
  ;
  exit: 
#line 1756 
  ;
  
#line 1757 
  return status;
}


#line 1765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status vxge_hw_device_xmac_port_stats_get(struct __vxge_hw_device *hldev, u32 port, struct vxge_hw_xmac_port_stats *port_stats)
{
  u64 *val64;
  int i;
  
#line 1769 
  enum vxge_hw_status status = 0;
  
#line 1771 
  u32 offset = 0U;
  
#line 1772 
  val64 = (u64 *)port_stats;
  
#line 1774 
  status = __vxge_hw_device_is_privilaged(hldev->host_type,hldev->func_id);
  
#line 1776 
  if (status != VXGE_HW_OK) 
#line 1777 
                            goto exit; else ;
  
#line 1779 
  i = 0;
  
#line 1779 
  goto ldv_52551;
  ldv_52550: 
#line 1780 
  ;
  
#line 1780 
  status = vxge_hw_mrpcim_stats_access(hldev,0U,17U,(port * 608U + offset) >> 3,val64);
  
#line 1784 
  if (status != VXGE_HW_OK) 
#line 1785 
                            goto exit; else ;
  
#line 1787 
  offset += 8U;
  
#line 1788 
  val64 += 1;
  
#line 1779 
  i += 1;
  ldv_52551: 
#line 1780 
  ;
  
#line 1779 
  if ((unsigned int)i <= 75U) 
#line 1781 
                              goto ldv_52550; else 
#line 1784 
                                                   goto ldv_52552;
  ldv_52552: 
#line 1785 
  ;
  exit: 
#line 1791 
  ;
  
#line 1792 
  return status;
}


#line 1800  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_device_xmac_stats_get(struct __vxge_hw_device *hldev, struct vxge_hw_xmac_stats *xmac_stats)
{
  u32 i;
  
#line 1803 
  enum vxge_hw_status status = 0;
  
#line 1806 
  status = vxge_hw_device_xmac_aggr_stats_get(hldev,0U,& xmac_stats->aggr_stats[0]);
  
#line 1808 
  if (status != VXGE_HW_OK) 
#line 1809 
                            goto exit; else ;
  
#line 1811 
  status = vxge_hw_device_xmac_aggr_stats_get(hldev,1U,& xmac_stats->aggr_stats[1]);
  
#line 1813 
  if (status != VXGE_HW_OK) 
#line 1814 
                            goto exit; else ;
  
#line 1816 
  i = 0U;
  
#line 1816 
  goto ldv_52561;
  ldv_52560: 
#line 1817 
  ;
  
#line 1818 
  status = vxge_hw_device_xmac_port_stats_get(hldev,i,& xmac_stats->port_stats[i]);
  
#line 1820 
  if (status != VXGE_HW_OK) 
#line 1821 
                            goto exit; else ;
  
#line 1816 
  i += 1U;
  ldv_52561: 
#line 1817 
  ;
  
#line 1816 
  if (i <= 2U) 
#line 1818 
               goto ldv_52560; else 
#line 1821 
                                    goto ldv_52562;
  ldv_52562: 
#line 1822 
  ;
  
#line 1824 
  i = 0U;
  
#line 1824 
  goto ldv_52565;
  ldv_52564: 
#line 1825 
  ;
  
#line 1826 
  if ((hldev->vpaths_deployed & (9223372036854775808ULL >> i)) == 0ULL) 
    
#line 1827 
    goto ldv_52563; else ;
  
#line 1829 
  status = __vxge_hw_vpath_xmac_tx_stats_get(& hldev->virtual_paths[i],& xmac_stats->vpath_tx_stats[i]);
  
#line 1832 
  if (status != VXGE_HW_OK) 
#line 1833 
                            goto exit; else ;
  
#line 1835 
  status = __vxge_hw_vpath_xmac_rx_stats_get(& hldev->virtual_paths[i],& xmac_stats->vpath_rx_stats[i]);
  
#line 1838 
  if (status != VXGE_HW_OK) 
#line 1839 
                            goto exit; else ;
  ldv_52563: 
#line 1840 
  ;
  
#line 1824 
  i += 1U;
  ldv_52565: 
#line 1825 
  ;
  
#line 1824 
  if (i <= 16U) 
#line 1826 
                goto ldv_52564; else 
#line 1829 
                                     goto ldv_52566;
  ldv_52566: 
#line 1830 
  ;
  exit: 
#line 1841 
  ;
  
#line 1842 
  return status;
}


#line 1849  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
void vxge_hw_device_debug_set(struct __vxge_hw_device *hldev, enum vxge_debug_level level, u32 mask)
{
  
#line 1852 
  if (hldev == (struct __vxge_hw_device *)0) 
#line 1853 
                                             goto return_label; else ;
  
#line 1857 
  hldev->debug_module_mask = mask;
  
#line 1858 
  hldev->debug_level = (unsigned int)level;
  
#line 1862 
  hldev->level_err = (unsigned int)level & 2U;
  
#line 1866 
  hldev->level_trace = (unsigned int)level & 1U;
  return_label: 
#line 1867 
                return;
}


#line 1874  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
u32 vxge_hw_device_error_level_get(struct __vxge_hw_device *hldev)
{
  u32 __retres;
  
#line 1877 
  if (hldev == (struct __vxge_hw_device *)0) {
    
#line 1878 
    __retres = 2U;
    
#line 1878 
    goto return_label;
  }
  else {
    
#line 1880 
    __retres = hldev->level_err;
    
#line 1880 
    goto return_label;
  }
  return_label: 
#line 1877 
                return __retres;
}


#line 1890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
u32 vxge_hw_device_trace_level_get(struct __vxge_hw_device *hldev)
{
  u32 __retres;
  
#line 1893 
  if (hldev == (struct __vxge_hw_device *)0) {
    
#line 1894 
    __retres = 1U;
    
#line 1894 
    goto return_label;
  }
  else {
    
#line 1896 
    __retres = hldev->level_trace;
    
#line 1896 
    goto return_label;
  }
  return_label: 
#line 1893 
                return __retres;
}


#line 1906  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_device_getpause_data(struct __vxge_hw_device *hldev, u32 port, u32 *tx, u32 *rx)
{
  u64 val64;
  
#line 1910 
  enum vxge_hw_status status = 0;
  
#line 1912 
  if (hldev == (struct __vxge_hw_device *)0 || hldev->magic != 305419896U) {
    
#line 1913 
    status = VXGE_HW_ERR_INVALID_DEVICE;
    
#line 1914 
    goto exit;
  }
  else ;
  
#line 1917 
  if (port > 2U) {
    
#line 1918 
    status = VXGE_HW_ERR_INVALID_PORT;
    
#line 1919 
    goto exit;
  }
  else ;
  
#line 1922 
  if ((hldev->access_rights & 4U) == 0U) {
    
#line 1923 
    status = VXGE_HW_ERR_PRIVILAGED_OPEARATION;
    
#line 1924 
    goto exit;
  }
  else ;
  
#line 1927 
  val64 = (u64)readq((void const volatile *)(& (hldev->mrpcim_reg)->rxmac_pause_cfg_port[port]));
  
#line 1928 
  if ((val64 & 1152921504606846976ULL) != 0ULL) 
#line 1929 
                                                *tx = 1U; else ;
  
#line 1930 
  if ((val64 & 72057594037927936ULL) != 0ULL) 
#line 1931 
                                              *rx = 1U; else ;
  exit: 
#line 1932 
  ;
  
#line 1933 
  return status;
}


#line 1941  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_device_setpause_data(struct __vxge_hw_device *hldev, u32 port, u32 tx, u32 rx)
{
  u64 val64;
  
#line 1945 
  enum vxge_hw_status status = 0;
  
#line 1947 
  if (hldev == (struct __vxge_hw_device *)0 || hldev->magic != 305419896U) {
    
#line 1948 
    status = VXGE_HW_ERR_INVALID_DEVICE;
    
#line 1949 
    goto exit;
  }
  else ;
  
#line 1952 
  if (port > 2U) {
    
#line 1953 
    status = VXGE_HW_ERR_INVALID_PORT;
    
#line 1954 
    goto exit;
  }
  else ;
  
#line 1957 
  status = __vxge_hw_device_is_privilaged(hldev->host_type,hldev->func_id);
  
#line 1959 
  if (status != VXGE_HW_OK) 
#line 1960 
                            goto exit; else ;
  
#line 1962 
  val64 = (u64)readq((void const volatile *)(& (hldev->mrpcim_reg)->rxmac_pause_cfg_port[port]));
  
#line 1963 
  if (tx != 0U) 
#line 1964 
                val64 |= 1152921504606846976ULL; else 
#line 1966 
                                                      val64 &= 17293822569102704639ULL;
  
#line 1967 
  if (rx != 0U) 
#line 1968 
                val64 |= 72057594037927936ULL; else 
#line 1970 
                                                    val64 &= 18374686479671623679ULL;
  
#line 1972 
  writeq((unsigned long)val64,(void volatile *)(& (hldev->mrpcim_reg)->rxmac_pause_cfg_port[port]));
  exit: 
#line 1973 
  ;
  
#line 1974 
  return status;
}


#line 1977  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
u16 vxge_hw_device_link_width_get(struct __vxge_hw_device *hldev)
{
  u16 __retres;
  u16 lnk;
  
#line 1979 
  struct pci_dev *dev = hldev->pdev;
  
#line 1982 
  pcie_capability_read_word(dev,18,& lnk);
  
#line 1983 
  __retres = (unsigned short)((unsigned int)((unsigned short)((int)lnk >> 4)) & 63U);
  
#line 1983 
  return __retres;
}


#line 1991  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
__inline static u32 __vxge_hw_ring_block_memblock_idx(u8 *block)
{
  u32 __retres;
  
#line 1993 
  __retres = (unsigned int)*((u64 *)(block + 4080U));
  
#line 1993 
  return __retres;
}


#line 2001  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
__inline static void __vxge_hw_ring_block_memblock_idx_set(u8 *block, u32 memblock_idx)
{
  
#line 2003 
  *((u64 *)(block + 4080U)) = (unsigned long long)memblock_idx;
  
#line 2004 
  return;
}


#line 2012  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
__inline static void __vxge_hw_ring_block_next_pointer_set(u8 *block, dma_addr_t dma_next)
{
  
#line 2014 
  *((u64 *)(block + 4088U)) = dma_next;
  
#line 2015 
  return;
}


#line 2022  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static u64 __vxge_hw_ring_first_block_address_get(struct __vxge_hw_ring *ring)
{
  u64 __retres;
  struct vxge_hw_mempool_dma *dma_object;
  
#line 2026 
  dma_object = (ring->mempool)->memblocks_dma_arr;
  
#line 2029 
  __retres = dma_object->addr;
  
#line 2029 
  return __retres;
}


#line 2036  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static dma_addr_t __vxge_hw_ring_item_dma_addr(struct vxge_hw_mempool *mempoolh, void *item)
{
  dma_addr_t __retres;
  u32 memblock_idx;
  void *memblock;
  struct vxge_hw_mempool_dma *memblock_dma_object;
  ptrdiff_t dma_item_offset;
  
#line 2045 
  memblock_idx = __vxge_hw_ring_block_memblock_idx((u8 *)item);
  
#line 2048 
  memblock = *(mempoolh->memblocks_arr + memblock_idx);
  
#line 2051 
  memblock_dma_object = mempoolh->memblocks_dma_arr + memblock_idx;
  
#line 2054 
  dma_item_offset = (long)item - (long)memblock;
  
#line 2056 
  __retres = memblock_dma_object->addr + (unsigned long long)dma_item_offset;
  
#line 2056 
  return __retres;
}


#line 2063  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_ring_rxdblock_link(struct vxge_hw_mempool *mempoolh, struct __vxge_hw_ring *ring, u32 from, u32 to)
{
  u8 *to_item;
  u8 *from_item;
  dma_addr_t to_dma;
  
#line 2071 
  from_item = (u8 *)*(mempoolh->items_arr + from);
  
#line 2075 
  to_item = (u8 *)*(mempoolh->items_arr + to);
  
#line 2079 
  to_dma = __vxge_hw_ring_item_dma_addr(mempoolh,(void *)to_item);
  
#line 2083 
  __vxge_hw_ring_block_next_pointer_set(from_item,to_dma);
  
#line 2084 
  return;
}


#line 2093  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_ring_mempool_item_alloc(struct vxge_hw_mempool *mempoolh, u32 memblock_index, struct vxge_hw_mempool_dma *dma_object, u32 index, u32 is_last)
{
  u32 i;
  
#line 2099 
  void *item = *(mempoolh->items_arr + index);
  
#line 2100 
  struct __vxge_hw_ring *ring = (struct __vxge_hw_ring *)mempoolh->userdata;
  
#line 2104 
  i = 0U;
  
#line 2104 
  goto ldv_52649;
  ldv_52648: 
#line 2105 
  ;
  {
    void *rxdblock_priv;
    void *uld_priv;
    struct vxge_hw_ring_rxd_1 *rxdp;
    u32 memblock_item_idx;
    
#line 2109 
    u32 reserve_index = (ring->channel.reserve_ptr - (ring->rxds_per_block * index + i)) - 1U;
    
#line 2113 
    *(ring->channel.reserve_arr + reserve_index) = item + ring->rxd_size * i;
    
#line 2119 
    rxdblock_priv = __vxge_hw_mempool_item_priv(mempoolh,memblock_index,item,& memblock_item_idx);
    
#line 2123 
    rxdp = (struct vxge_hw_ring_rxd_1 *)*(ring->channel.reserve_arr + reserve_index);
    
#line 2125 
    uld_priv = rxdblock_priv + ring->rxd_priv_size * i;
    
#line 2128 
    rxdp->host_control = (unsigned long long)uld_priv;
  }
  
#line 2104 
  i += 1U;
  ldv_52649: 
#line 2105 
  ;
  
#line 2104 
  if (ring->rxds_per_block > i) 
#line 2106 
                                goto ldv_52648; else 
#line 2109 
                                                     goto ldv_52650;
  ldv_52650: 
#line 2110 
  ;
  
#line 2131 
  __vxge_hw_ring_block_memblock_idx_set((u8 *)item,memblock_index);
  
#line 2133 
  if (is_last != 0U) 
#line 2135 
                     __vxge_hw_ring_rxdblock_link(mempoolh,ring,index,0U); else ;
  
#line 2138 
  if (index != 0U) 
#line 2140 
                   __vxge_hw_ring_rxdblock_link(mempoolh,ring,index + 4294967295U,index); else ;
  
#line 2141 
  return;
}


#line 2149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status vxge_hw_ring_replenish(struct __vxge_hw_ring *ring)
{
  void *rxd;
  struct __vxge_hw_channel *channel;
  int tmp;
  
#line 2153 
  enum vxge_hw_status status = 0;
  
#line 2155 
  channel = & ring->channel;
  
#line 2157 
  goto ldv_52659;
  ldv_52658: 
#line 2158 
  ;
  
#line 2159 
  status = vxge_hw_ring_rxd_reserve(ring,& rxd);
  
#line 2163 
  if (ring->rxd_init != (enum vxge_hw_status (*)(void *, void *))0) {
    
#line 2164 
    status = (*(ring->rxd_init))(rxd,channel->userdata);
    
#line 2165 
    if (status != VXGE_HW_OK) {
      
#line 2166 
      vxge_hw_ring_rxd_free(ring,rxd);
      
#line 2167 
      goto exit;
    }
    else ;
  }
  else ;
  
#line 2171 
  vxge_hw_ring_rxd_post(ring,rxd);
  ldv_52659: 
#line 2172 
  ;
  
#line 2157 
  tmp = vxge_hw_channel_dtr_count(channel);
  
#line 2157 
  if (tmp > 0) 
#line 2159 
               goto ldv_52658; else 
#line 2162 
                                    goto ldv_52660;
  ldv_52660: 
#line 2163 
  ;
  
#line 2173 
  status = VXGE_HW_OK;
  exit: 
#line 2174 
  ;
  
#line 2175 
  return status;
}


#line 2184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static struct __vxge_hw_channel *__vxge_hw_channel_allocate(struct __vxge_hw_vpath_handle *vph, enum __vxge_hw_channel_type type, u32 length, u32 per_dtr_space, void *userdata)
{
  struct __vxge_hw_channel *__retres;
  struct __vxge_hw_channel *channel;
  struct __vxge_hw_device *hldev;
  u32 vp_id;
  
#line 2191 
  int size = 0;
  
#line 2194 
  hldev = (vph->vpath)->hldev;
  
#line 2195 
  vp_id = (vph->vpath)->vp_id;
  
#line 2197 
  switch ((unsigned int)type) {
    case (unsigned int)1: 
#line 2198 
    ;
    
#line 2199 
    size = 512;
    
#line 2200 
    goto ldv_52673;
    case (unsigned int)2: 
#line 2201 
    ;
    
#line 2202 
    size = 512;
    
#line 2203 
    goto ldv_52673;
    default: 
#line 2204 
    ;
    
#line 2205 
    goto ldv_52673;
  }
  ldv_52673: 
#line 2208 
  ;
  
#line 2208 
  channel = (struct __vxge_hw_channel *)kzalloc_1((unsigned long)size,208U);
  
#line 2209 
  if (channel == (struct __vxge_hw_channel *)0) 
#line 2210 
                                                goto exit0; else ;
  
#line 2211 
  INIT_LIST_HEAD(& channel->item);
  
#line 2213 
  channel->common_reg = hldev->common_reg;
  
#line 2214 
  channel->first_vp_id = hldev->first_vp_id;
  
#line 2215 
  channel->type = type;
  
#line 2216 
  channel->devh = hldev;
  
#line 2217 
  channel->vph = vph;
  
#line 2218 
  channel->userdata = userdata;
  
#line 2219 
  channel->per_dtr_space = per_dtr_space;
  
#line 2220 
  channel->length = length;
  
#line 2221 
  channel->vp_id = vp_id;
  
#line 2223 
  channel->work_arr = (void **)kzalloc_1((unsigned long)length * 8UL,208U);
  
#line 2224 
  if (channel->work_arr == (void **)0) 
#line 2225 
                                       goto exit1; else ;
  
#line 2227 
  channel->free_arr = (void **)kzalloc_1((unsigned long)length * 8UL,208U);
  
#line 2228 
  if (channel->free_arr == (void **)0) 
#line 2229 
                                       goto exit1; else ;
  
#line 2230 
  channel->free_ptr = length;
  
#line 2232 
  channel->reserve_arr = (void **)kzalloc_1((unsigned long)length * 8UL,208U);
  
#line 2233 
  if (channel->reserve_arr == (void **)0) 
#line 2234 
                                          goto exit1; else ;
  
#line 2235 
  channel->reserve_ptr = length;
  
#line 2236 
  channel->reserve_top = 0U;
  
#line 2238 
  channel->orig_arr = (void **)kzalloc_1((unsigned long)length * 8UL,208U);
  
#line 2239 
  if (channel->orig_arr == (void **)0) 
#line 2240 
                                       goto exit1; else ;
  
#line 2242 
  __retres = channel;
  
#line 2242 
  goto return_label;
  exit1: 
#line 2243 
  ;
  
#line 2244 
  __vxge_hw_channel_free(channel);
  exit0: 
#line 2246 
  ;
  
#line 2247 
  __retres = (struct __vxge_hw_channel *)0;
  return_label: 
#line 2247 
                return __retres;
}


#line 2254  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void vxge_hw_blockpool_block_add(struct __vxge_hw_device *devh, void *block_addr, u32 length, struct pci_dev *dma_h, struct pci_dev *acc_handle)
{
  struct __vxge_hw_blockpool *blockpool;
  dma_addr_t dma_addr;
  u32 req_out;
  int tmp;
  int tmp_1;
  
#line 2261 
  struct __vxge_hw_blockpool_entry *entry = (struct __vxge_hw_blockpool_entry *)0;
  
#line 2263 
  enum vxge_hw_status status = 0;
  
#line 2266 
  blockpool = & devh->block_pool;
  
#line 2268 
  if (block_addr == (void *)0) {
    
#line 2269 
    blockpool->req_out -= 1U;
    
#line 2270 
    status = VXGE_HW_FAIL;
    
#line 2271 
    goto exit;
  }
  else ;
  
#line 2274 
  dma_addr = pci_map_single(devh->pdev,block_addr,(unsigned long)length,0);
  
#line 2277 
  tmp = pci_dma_mapping_error(devh->pdev,dma_addr);
  
#line 2277 
  if ((long)(tmp != 0) != 0L) {
    
#line 2278 
    vxge_os_dma_free(devh->pdev,(void const *)block_addr,& acc_handle);
    
#line 2279 
    blockpool->req_out -= 1U;
    
#line 2280 
    status = VXGE_HW_FAIL;
    
#line 2281 
    goto exit;
  }
  else ;
  
#line 2284 
  tmp_1 = list_empty((struct list_head const *)(& blockpool->free_entry_list));
  
#line 2284 
  if (tmp_1 == 0) {
    struct __vxge_hw_blockpool_entry *tmp_0;
    {
      
#line 2286 
      struct list_head const *__mptr = (struct list_head const *)blockpool->free_entry_list.next;
      
#line 2286 
      tmp_0 = (struct __vxge_hw_blockpool_entry *)__mptr;
    }
    
#line 2285 
    entry = tmp_0;
  }
  else ;
  
#line 2290 
  if (entry == (struct __vxge_hw_blockpool_entry *)0) 
#line 2291 
                                                      entry = (struct __vxge_hw_blockpool_entry *)vmalloc(56UL); else 
                                                                    
#line 2293 
                                                                    list_del(& entry->item);
  
#line 2295 
  if (entry != (struct __vxge_hw_blockpool_entry *)0) {
    
#line 2296 
    entry->length = length;
    
#line 2297 
    entry->memblock = block_addr;
    
#line 2298 
    entry->dma_addr = dma_addr;
    
#line 2299 
    entry->acc_handle = acc_handle;
    
#line 2300 
    entry->dma_handle = dma_h;
    
#line 2301 
    list_add(& entry->item,& blockpool->free_block_list);
    
#line 2302 
    blockpool->pool_size += 1U;
    
#line 2303 
    status = VXGE_HW_OK;
  }
  else 
#line 2305 
       status = VXGE_HW_ERR_OUT_OF_MEMORY;
  
#line 2307 
  blockpool->req_out -= 1U;
  
#line 2309 
  req_out = blockpool->req_out;
  exit: 
#line 2310 
  ;
  
#line 2311 
  return;
}


#line 2315  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
__inline static void vxge_os_dma_malloc_async(struct pci_dev *pdev, void *devh, unsigned long size)
{
  gfp_t flags;
  void *vaddr;
  int tmp;
  
#line 2320 
  tmp = preempt_count();
  
#line 2320 
  if (((unsigned long)tmp & 2096896UL) != 0UL) 
#line 2321 
                                               flags = 33U; else 
#line 2323 
                                                                 flags = 209U;
  
#line 2325 
  vaddr = kmalloc(size,flags);
  
#line 2327 
  vxge_hw_blockpool_block_add((struct __vxge_hw_device *)devh,vaddr,(unsigned int)size,pdev,pdev);
  
#line 2328 
  return;
}


#line 2334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_blockpool_blocks_add(struct __vxge_hw_blockpool *blockpool)
{
  u32 i;
  
#line 2336 
  u32 nreq = 0U;
  
#line 2344 
  i = 0U;
  
#line 2344 
  goto ldv_52706;
  ldv_52705: 
#line 2345 
  ;
  
#line 2345 
  vxge_os_dma_malloc_async((blockpool->hldev)->pdev,(void *)blockpool->hldev,4096UL);
  
#line 2344 
  i += 1U;
  ldv_52706: 
#line 2345 
  ;
  
#line 2344 
  if (i < nreq) 
#line 2346 
                goto ldv_52705; else 
#line 2349 
                                     goto ldv_52707;
  ldv_52707: 
#line 2350 
  ;
  
#line 2351 
  return;
}


#line 2355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void *__vxge_hw_blockpool_malloc(struct __vxge_hw_device *devh, u32 size, struct vxge_hw_mempool_dma *dma_object)
{
  struct __vxge_hw_blockpool *blockpool;
  
#line 2358 
  struct __vxge_hw_blockpool_entry *entry = (struct __vxge_hw_blockpool_entry *)0;
  
#line 2360 
  void *memblock = (void *)0;
  
#line 2361 
  enum vxge_hw_status status = 0;
  
#line 2363 
  blockpool = & devh->block_pool;
  
#line 2365 
  if (blockpool->block_size != size) {
    int tmp;
    
#line 2367 
    memblock = vxge_os_dma_malloc(devh->pdev,(unsigned long)size,& dma_object->handle,& dma_object->acc_handle);
    
#line 2371 
    if (memblock == (void *)0) {
      
#line 2372 
      status = VXGE_HW_ERR_OUT_OF_MEMORY;
      
#line 2373 
      goto exit;
    }
    else ;
    
#line 2376 
    dma_object->addr = pci_map_single(devh->pdev,memblock,(unsigned long)size,0);
    
#line 2379 
    tmp = pci_dma_mapping_error(devh->pdev,dma_object->addr);
    
#line 2379 
    if ((long)(tmp != 0) != 0L) {
      
#line 2381 
      vxge_os_dma_free(devh->pdev,(void const *)memblock,& dma_object->acc_handle);
      
#line 2383 
      status = VXGE_HW_ERR_OUT_OF_MEMORY;
      
#line 2384 
      goto exit;
    }
    else ;
  }
  else {
    int tmp_1;
    
#line 2389 
    tmp_1 = list_empty((struct list_head const *)(& blockpool->free_block_list));
    
#line 2389 
    if (tmp_1 == 0) {
      struct __vxge_hw_blockpool_entry *tmp_0;
      {
        
#line 2391 
        struct list_head const *__mptr = (struct list_head const *)blockpool->free_block_list.next;
        
#line 2391 
        tmp_0 = (struct __vxge_hw_blockpool_entry *)__mptr;
      }
      
#line 2390 
      entry = tmp_0;
    }
    else ;
    
#line 2395 
    if (entry != (struct __vxge_hw_blockpool_entry *)0) {
      
#line 2396 
      list_del(& entry->item);
      
#line 2397 
      dma_object->addr = entry->dma_addr;
      
#line 2398 
      dma_object->handle = entry->dma_handle;
      
#line 2399 
      dma_object->acc_handle = entry->acc_handle;
      
#line 2400 
      memblock = entry->memblock;
      
#line 2402 
      list_add(& entry->item,& blockpool->free_entry_list);
      
#line 2404 
      blockpool->pool_size -= 1U;
    }
    else ;
    
#line 2407 
    if (memblock != (void *)0) 
#line 2408 
                               __vxge_hw_blockpool_blocks_add(blockpool); else ;
  }
  exit: 
#line 2410 
  ;
  
#line 2411 
  return memblock;
}


#line 2418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_blockpool_blocks_remove(struct __vxge_hw_blockpool *blockpool)
{
  struct list_head *p;
  struct list_head *n;
  
#line 2422 
  p = blockpool->free_block_list.next;
  
#line 2422 
  n = p->next;
  
#line 2422 
  goto ldv_52727;
  ldv_52726: 
#line 2423 
  ;
  
#line 2424 
  if (blockpool->pool_size < blockpool->pool_max) 
#line 2425 
                                                  goto ldv_52725; else ;
  
#line 2427 
  pci_unmap_single((blockpool->hldev)->pdev,((struct __vxge_hw_blockpool_entry *)p)->dma_addr,(unsigned long)((struct __vxge_hw_blockpool_entry *)p)->length,0);
  
#line 2433 
  vxge_os_dma_free((blockpool->hldev)->pdev,(void const *)((struct __vxge_hw_blockpool_entry *)p)->memblock,& ((struct __vxge_hw_blockpool_entry *)p)->acc_handle);
  
#line 2438 
  list_del(& ((struct __vxge_hw_blockpool_entry *)p)->item);
  
#line 2440 
  list_add(p,& blockpool->free_entry_list);
  
#line 2442 
  blockpool->pool_size -= 1U;
  
#line 2422 
  p = n;
  
#line 2422 
  n = p->next;
  ldv_52727: 
#line 2423 
  ;
  
#line 2422 
  if (& blockpool->free_block_list != p) 
#line 2424 
                                         goto ldv_52726; else 
#line 2427 
                                                              goto ldv_52725;
  ldv_52725: 
#line 2428 
  ;
  
#line 2429 
  return;
}


#line 2451  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_blockpool_free(struct __vxge_hw_device *devh, void *memblock, u32 size, struct vxge_hw_mempool_dma *dma_object)
{
  struct __vxge_hw_blockpool *blockpool;
  
#line 2455 
  struct __vxge_hw_blockpool_entry *entry = (struct __vxge_hw_blockpool_entry *)0;
  
#line 2457 
  enum vxge_hw_status status = 0;
  
#line 2459 
  blockpool = & devh->block_pool;
  
#line 2461 
  if (blockpool->block_size != size) {
    
#line 2462 
    pci_unmap_single(devh->pdev,dma_object->addr,(unsigned long)size,0);
    
#line 2464 
    vxge_os_dma_free(devh->pdev,(void const *)memblock,& dma_object->acc_handle);
  }
  else {
    int tmp_0;
    
#line 2467 
    tmp_0 = list_empty((struct list_head const *)(& blockpool->free_entry_list));
    
#line 2467 
    if (tmp_0 == 0) {
      struct __vxge_hw_blockpool_entry *tmp;
      {
        
#line 2469 
        struct list_head const *__mptr = (struct list_head const *)blockpool->free_entry_list.next;
        
#line 2469 
        tmp = (struct __vxge_hw_blockpool_entry *)__mptr;
      }
      
#line 2468 
      entry = tmp;
    }
    else ;
    
#line 2473 
    if (entry == (struct __vxge_hw_blockpool_entry *)0) 
#line 2474 
                                                        entry = (struct __vxge_hw_blockpool_entry *)vmalloc(56UL); else 
                                                                    
#line 2477 
                                                                    list_del(& entry->item);
    
#line 2479 
    if (entry != (struct __vxge_hw_blockpool_entry *)0) {
      
#line 2480 
      entry->length = size;
      
#line 2481 
      entry->memblock = memblock;
      
#line 2482 
      entry->dma_addr = dma_object->addr;
      
#line 2483 
      entry->acc_handle = dma_object->acc_handle;
      
#line 2484 
      entry->dma_handle = dma_object->handle;
      
#line 2485 
      list_add(& entry->item,& blockpool->free_block_list);
      
#line 2487 
      blockpool->pool_size += 1U;
      
#line 2488 
      status = VXGE_HW_OK;
    }
    else 
#line 2490 
         status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2492 
    if (status == VXGE_HW_OK) 
#line 2493 
                              __vxge_hw_blockpool_blocks_remove(blockpool); else ;
  }
  
#line 2495 
  return;
}


#line 2500  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_mempool_destroy(struct vxge_hw_mempool *mempool)
{
  u32 i;
  u32 j;
  
#line 2503 
  struct __vxge_hw_device *devh = mempool->devh;
  
#line 2505 
  i = 0U;
  
#line 2505 
  goto ldv_52751;
  ldv_52750: 
#line 2506 
  ;
  {
    struct vxge_hw_mempool_dma *dma_object;
    
#line 2511 
    dma_object = mempool->memblocks_dma_arr + i;
    
#line 2513 
    j = 0U;
    
#line 2513 
    goto ldv_52749;
    ldv_52748: 
#line 2514 
    ;
    {
      
#line 2514 
      u32 index = mempool->items_per_memblock * i + j;
      
#line 2517 
      if (mempool->items_current <= index) 
#line 2518 
                                           goto ldv_52747; else ;
    }
    
#line 2513 
    j += 1U;
    ldv_52749: 
#line 2514 
    ;
    
#line 2513 
    if (mempool->items_per_memblock > j) 
#line 2515 
                                         goto ldv_52748; else 
#line 2518 
                                                              goto ldv_52747;
    ldv_52747: 
#line 2519 
    ;
    
#line 2521 
    vfree((void const *)*(mempool->memblocks_priv_arr + i));
    
#line 2523 
    __vxge_hw_blockpool_free(devh,*(mempool->memblocks_arr + i),mempool->memblock_size,dma_object);
  }
  
#line 2505 
  i += 1U;
  ldv_52751: 
#line 2506 
  ;
  
#line 2505 
  if (mempool->memblocks_allocated > i) 
#line 2507 
                                        goto ldv_52750; else 
#line 2510 
                                                             goto ldv_52752;
  ldv_52752: 
#line 2511 
  ;
  
#line 2527 
  vfree((void const *)mempool->items_arr);
  
#line 2528 
  vfree((void const *)mempool->memblocks_dma_arr);
  
#line 2529 
  vfree((void const *)mempool->memblocks_priv_arr);
  
#line 2530 
  vfree((void const *)mempool->memblocks_arr);
  
#line 2531 
  vfree((void const *)mempool);
  
#line 2532 
  return;
}


#line 2539  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_mempool_grow(struct vxge_hw_mempool *mempool, u32 num_allocate, u32 *num_allocated)
{
  u32 i;
  
#line 2542 
  u32 first_time = (unsigned int)(mempool->memblocks_allocated == 0U);
  
#line 2543 
  u32 n_items = mempool->items_per_memblock;
  
#line 2544 
  u32 start_block_idx = mempool->memblocks_allocated;
  
#line 2545 
  u32 end_block_idx = mempool->memblocks_allocated + num_allocate;
  
#line 2546 
  enum vxge_hw_status status = 0;
  
#line 2548 
  *num_allocated = 0U;
  
#line 2550 
  if (mempool->memblocks_max < end_block_idx) {
    
#line 2551 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2552 
    goto exit;
  }
  else ;
  
#line 2555 
  i = start_block_idx;
  
#line 2555 
  goto ldv_52775;
  ldv_52774: 
#line 2556 
  ;
  {
    u32 j;
    void *the_memblock;
    
#line 2557 
    u32 is_last = (unsigned int)(end_block_idx + 4294967295U == i);
    
#line 2558 
    struct vxge_hw_mempool_dma *dma_object = mempool->memblocks_dma_arr + i;
    
#line 2567 
    *(mempool->memblocks_priv_arr + i) = vzalloc((unsigned long)(mempool->items_priv_size * n_items));
    
#line 2569 
    if (*(mempool->memblocks_priv_arr + i) == (void *)0) {
      
#line 2570 
      status = VXGE_HW_ERR_OUT_OF_MEMORY;
      
#line 2571 
      goto exit;
    }
    else ;
    
#line 2575 
    *(mempool->memblocks_arr + i) = __vxge_hw_blockpool_malloc(mempool->devh,mempool->memblock_size,dma_object);
    
#line 2578 
    if (*(mempool->memblocks_arr + i) == (void *)0) {
      
#line 2579 
      vfree((void const *)*(mempool->memblocks_priv_arr + i));
      
#line 2580 
      status = VXGE_HW_ERR_OUT_OF_MEMORY;
      
#line 2581 
      goto exit;
    }
    else ;
    
#line 2584 
    *num_allocated += 1U;
    
#line 2585 
    mempool->memblocks_allocated += 1U;
    
#line 2587 
    memset(*(mempool->memblocks_arr + i),0,(unsigned long)mempool->memblock_size);
    
#line 2589 
    the_memblock = *(mempool->memblocks_arr + i);
    
#line 2592 
    j = 0U;
    
#line 2592 
    goto ldv_52772;
    ldv_52771: 
#line 2593 
    ;
    {
      
#line 2593 
      u32 index = i * n_items + j;
      
#line 2595 
      if (first_time != 0U && mempool->items_initial <= index) 
#line 2596 
                                                               goto ldv_52770; else ;
      
#line 2598 
      *(mempool->items_arr + index) = the_memblock + mempool->item_size * j;
      
#line 2602 
      if (mempool->item_func_alloc != (void (*)(struct vxge_hw_mempool *, u32 , struct vxge_hw_mempool_dma *, u32 , u32 ))0) 
        
#line 2603 
        (*(mempool->item_func_alloc))(mempool,i,dma_object,index,is_last); else ;
      
#line 2606 
      mempool->items_current = index + 1U;
    }
    
#line 2592 
    j += 1U;
    ldv_52772: 
#line 2593 
    ;
    
#line 2592 
    if (j < n_items) 
#line 2594 
                     goto ldv_52771; else 
#line 2597 
                                          goto ldv_52770;
    ldv_52770: 
#line 2598 
    ;
    
#line 2609 
    if (first_time != 0U && mempool->items_current == mempool->items_initial) 
      
#line 2611 
      goto ldv_52773; else ;
  }
  
#line 2555 
  i += 1U;
  ldv_52775: 
#line 2556 
  ;
  
#line 2555 
  if (i < end_block_idx) 
#line 2557 
                         goto ldv_52774; else 
#line 2560 
                                              goto ldv_52773;
  ldv_52773: 
#line 2561 
  ;
  exit: 
#line 2613 
  ;
  
#line 2614 
  return status;
}


#line 2625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static struct vxge_hw_mempool *__vxge_hw_mempool_create(struct __vxge_hw_device *devh, u32 memblock_size, u32 item_size, u32 items_priv_size, u32 items_initial, u32 items_max, struct vxge_hw_mempool_cbs const *mp_callback, void *userdata)
{
  u32 memblocks_to_allocate;
  u32 allocated;
  
#line 2634 
  enum vxge_hw_status status = 0;
  
#line 2636 
  struct vxge_hw_mempool *mempool = (struct vxge_hw_mempool *)0;
  
#line 2639 
  if (memblock_size < item_size) {
    
#line 2640 
    status = VXGE_HW_FAIL;
    
#line 2641 
    goto exit;
  }
  else ;
  
#line 2644 
  mempool = (struct vxge_hw_mempool *)vzalloc(96UL);
  
#line 2645 
  if (mempool == (struct vxge_hw_mempool *)0) {
    
#line 2646 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2647 
    goto exit;
  }
  else ;
  
#line 2650 
  mempool->devh = devh;
  
#line 2651 
  mempool->memblock_size = memblock_size;
  
#line 2652 
  mempool->items_max = items_max;
  
#line 2653 
  mempool->items_initial = items_initial;
  
#line 2654 
  mempool->item_size = item_size;
  
#line 2655 
  mempool->items_priv_size = items_priv_size;
  
#line 2656 
  mempool->item_func_alloc = mp_callback->item_func_alloc;
  
#line 2657 
  mempool->userdata = userdata;
  
#line 2659 
  mempool->memblocks_allocated = 0U;
  
#line 2661 
  mempool->items_per_memblock = memblock_size / item_size;
  
#line 2663 
  mempool->memblocks_max = ((mempool->items_per_memblock + items_max) + 4294967295U) / mempool->items_per_memblock;
  
#line 2668 
  mempool->memblocks_arr = (void **)vzalloc((unsigned long)mempool->memblocks_max * 8UL);
  
#line 2669 
  if (mempool->memblocks_arr == (void **)0) {
    
#line 2670 
    __vxge_hw_mempool_destroy(mempool);
    
#line 2671 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2672 
    mempool = (struct vxge_hw_mempool *)0;
    
#line 2673 
    goto exit;
  }
  else ;
  
#line 2678 
  mempool->memblocks_priv_arr = (void **)vzalloc((unsigned long)mempool->memblocks_max * 8UL);
  
#line 2679 
  if (mempool->memblocks_priv_arr == (void **)0) {
    
#line 2680 
    __vxge_hw_mempool_destroy(mempool);
    
#line 2681 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2682 
    mempool = (struct vxge_hw_mempool *)0;
    
#line 2683 
    goto exit;
  }
  else ;
  
#line 2688 
  mempool->memblocks_dma_arr = (struct vxge_hw_mempool_dma *)vzalloc((unsigned long)mempool->memblocks_max * 24UL);
  
#line 2690 
  if (mempool->memblocks_dma_arr == (struct vxge_hw_mempool_dma *)0) {
    
#line 2691 
    __vxge_hw_mempool_destroy(mempool);
    
#line 2692 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2693 
    mempool = (struct vxge_hw_mempool *)0;
    
#line 2694 
    goto exit;
  }
  else ;
  
#line 2698 
  mempool->items_arr = (void **)vzalloc((unsigned long)mempool->items_max * 8UL);
  
#line 2699 
  if (mempool->items_arr == (void **)0) {
    
#line 2700 
    __vxge_hw_mempool_destroy(mempool);
    
#line 2701 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2702 
    mempool = (struct vxge_hw_mempool *)0;
    
#line 2703 
    goto exit;
  }
  else ;
  
#line 2707 
  memblocks_to_allocate = ((mempool->items_initial + mempool->items_per_memblock) + 4294967295U) / mempool->items_per_memblock;
  
#line 2712 
  status = __vxge_hw_mempool_grow(mempool,memblocks_to_allocate,& allocated);
  
#line 2714 
  if (status != VXGE_HW_OK) {
    
#line 2715 
    __vxge_hw_mempool_destroy(mempool);
    
#line 2716 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2717 
    mempool = (struct vxge_hw_mempool *)0;
    
#line 2718 
    goto exit;
  }
  else ;
  exit: 
#line 2721 
  ;
  
#line 2722 
  return mempool;
}


#line 2729  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_ring_abort(struct __vxge_hw_ring *ring)
{
  enum vxge_hw_status __retres;
  void *rxdh;
  struct __vxge_hw_channel *channel;
  
#line 2734 
  channel = & ring->channel;
  ldv_52797: 
#line 2735 
  ;
  
#line 2737 
  vxge_hw_channel_dtr_try_complete(channel,& rxdh);
  
#line 2739 
  if (rxdh == (void *)0) 
#line 2740 
                         goto ldv_52796; else ;
  
#line 2742 
  vxge_hw_channel_dtr_complete(channel);
  
#line 2744 
  if (ring->rxd_term != (void (*)(void *, enum vxge_hw_rxd_state , void *))0) 
    
#line 2745 
    (*(ring->rxd_term))(rxdh,(enum vxge_hw_rxd_state)VXGE_HW_RXD_STATE_POSTED,channel->userdata); else ;
  
#line 2748 
  vxge_hw_channel_dtr_free(channel,rxdh);
  
#line 2737 
  goto ldv_52797;
  ldv_52796: 
#line 2738 
  ;
  
#line 2751 
  __retres = VXGE_HW_OK;
  
#line 2751 
  return __retres;
}


#line 2758  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_ring_reset(struct __vxge_hw_ring *ring)
{
  struct __vxge_hw_channel *channel;
  
#line 2760 
  enum vxge_hw_status status = 0;
  
#line 2763 
  channel = & ring->channel;
  
#line 2765 
  __vxge_hw_ring_abort(ring);
  
#line 2767 
  status = __vxge_hw_channel_reset(channel);
  
#line 2769 
  if (status != VXGE_HW_OK) 
#line 2770 
                            goto exit; else ;
  
#line 2772 
  if (ring->rxd_init != (enum vxge_hw_status (*)(void *, void *))0) {
    
#line 2773 
    status = vxge_hw_ring_replenish(ring);
    
#line 2774 
    if (status != VXGE_HW_OK) 
#line 2775 
                              goto exit; else ;
  }
  else ;
  exit: 
#line 2777 
  ;
  
#line 2778 
  return status;
}


#line 2786  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_ring_delete(struct __vxge_hw_vpath_handle *vp)
{
  enum vxge_hw_status __retres;
  
#line 2788 
  struct __vxge_hw_ring *ring = (vp->vpath)->ringh;
  
#line 2790 
  __vxge_hw_ring_abort(ring);
  
#line 2792 
  if (ring->mempool != (struct vxge_hw_mempool *)0) 
#line 2793 
                                                    __vxge_hw_mempool_destroy(ring->mempool); else ;
  
#line 2795 
  (vp->vpath)->ringh = (struct __vxge_hw_ring *)0;
  
#line 2796 
  __vxge_hw_channel_free(& ring->channel);
  
#line 2798 
  __retres = VXGE_HW_OK;
  
#line 2798 
  return __retres;
}


#line 2806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_ring_create(struct __vxge_hw_vpath_handle *vp, struct vxge_hw_ring_attr *attr)
{
  enum vxge_hw_status __retres;
  struct __vxge_hw_ring *ring;
  u32 ring_length;
  struct vxge_hw_ring_config *config;
  struct __vxge_hw_device *hldev;
  u32 vp_id;
  u32 tmp;
  
#line 2809 
  enum vxge_hw_status status = 0;
  
#line 2815 
  struct vxge_hw_mempool_cbs const ring_mp_callback = {.item_func_alloc = & __vxge_hw_ring_mempool_item_alloc};
  
#line 2819 
  if (vp == (struct __vxge_hw_vpath_handle *)0 || attr == (struct vxge_hw_ring_attr *)0) {
    
#line 2820 
    status = VXGE_HW_FAIL;
    
#line 2821 
    goto exit;
  }
  else ;
  
#line 2824 
  hldev = (vp->vpath)->hldev;
  
#line 2825 
  vp_id = (vp->vpath)->vp_id;
  
#line 2827 
  config = & hldev->config.vp_config[vp_id].ring;
  
#line 2829 
  tmp = vxge_hw_ring_rxds_per_block_get(config->buffer_mode);
  
#line 2829 
  ring_length = config->ring_blocks * tmp;
  
#line 2832 
  ring = (struct __vxge_hw_ring *)__vxge_hw_channel_allocate(vp,(enum __vxge_hw_channel_type)VXGE_HW_CHANNEL_TYPE_RING,ring_length,attr->per_rxd_space,attr->userdata);
  
#line 2837 
  if (ring == (struct __vxge_hw_ring *)0) {
    
#line 2838 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2839 
    goto exit;
  }
  else ;
  
#line 2842 
  (vp->vpath)->ringh = ring;
  
#line 2843 
  ring->vp_id = vp_id;
  
#line 2844 
  ring->vp_reg = (vp->vpath)->vp_reg;
  
#line 2845 
  ring->common_reg = hldev->common_reg;
  
#line 2846 
  ring->stats = & ((vp->vpath)->sw_stats)->ring_stats;
  
#line 2847 
  ring->config = config;
  
#line 2848 
  ring->callback = attr->callback;
  
#line 2849 
  ring->rxd_init = attr->rxd_init;
  
#line 2850 
  ring->rxd_term = attr->rxd_term;
  
#line 2851 
  ring->buffer_mode = config->buffer_mode;
  
#line 2852 
  ring->tim_rti_cfg1_saved = (vp->vpath)->tim_rti_cfg1_saved;
  
#line 2853 
  ring->tim_rti_cfg3_saved = (vp->vpath)->tim_rti_cfg3_saved;
  
#line 2854 
  ring->rxds_limit = config->rxds_limit;
  
#line 2856 
  ring->rxd_size = vxge_hw_ring_rxd_size_get(config->buffer_mode);
  
#line 2857 
  ring->rxd_priv_size = attr->per_rxd_space + 24U;
  
#line 2859 
  ring->per_rxd_space = attr->per_rxd_space;
  
#line 2861 
  ring->rxd_priv_size = (ring->rxd_priv_size + 127U) & 4294967168U;
  
#line 2867 
  ring->rxds_per_block = vxge_hw_ring_rxds_per_block_get(config->buffer_mode);
  
#line 2871 
  ring->rxdblock_priv_size = ring->rxd_priv_size * ring->rxds_per_block;
  
#line 2872 
  ring->mempool = __vxge_hw_mempool_create(hldev,4096U,4096U,ring->rxdblock_priv_size,(ring->config)->ring_blocks,(ring->config)->ring_blocks,& ring_mp_callback,(void *)ring);
  
#line 2880 
  if (ring->mempool == (struct vxge_hw_mempool *)0) {
    
#line 2881 
    __vxge_hw_ring_delete(vp);
    
#line 2882 
    __retres = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 2882 
    goto return_label;
  }
  else ;
  
#line 2885 
  status = __vxge_hw_channel_initialize(& ring->channel);
  
#line 2886 
  if (status != VXGE_HW_OK) {
    
#line 2887 
    __vxge_hw_ring_delete(vp);
    
#line 2888 
    goto exit;
  }
  else ;
  
#line 2898 
  if (ring->rxd_init != (enum vxge_hw_status (*)(void *, void *))0) {
    
#line 2899 
    status = vxge_hw_ring_replenish(ring);
    
#line 2900 
    if (status != VXGE_HW_OK) {
      
#line 2901 
      __vxge_hw_ring_delete(vp);
      
#line 2902 
      goto exit;
    }
    else ;
  }
  else ;
  
#line 2908 
  (ring->stats)->common_stats.usage_cnt = 0U;
  exit: 
#line 2909 
  ;
  
#line 2910 
  __retres = status;
  return_label: 
#line 2910 
                return __retres;
}


#line 2918  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_device_config_default_get(struct vxge_hw_device_config *device_config)
{
  enum vxge_hw_status __retres;
  u32 i;
  
#line 2922 
  device_config->dma_blockpool_initial = 0U;
  
#line 2924 
  device_config->dma_blockpool_max = 4096U;
  
#line 2925 
  device_config->intr_mode = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
  
#line 2926 
  device_config->rth_en = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 2927 
  device_config->rth_it_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 2928 
  device_config->device_poll_millis = 1000U;
  
#line 2929 
  device_config->rts_mac_en = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 2931 
  i = 0U;
  
#line 2931 
  goto ldv_52825;
  ldv_52824: 
#line 2932 
  ;
  
#line 2932 
  device_config->vp_config[i].vp_id = i;
  
#line 2934 
  device_config->vp_config[i].min_bandwidth = 0U;
  
#line 2937 
  device_config->vp_config[i].ring.enable = 1U;
  
#line 2939 
  device_config->vp_config[i].ring.ring_blocks = 2U;
  
#line 2942 
  device_config->vp_config[i].ring.buffer_mode = 1U;
  
#line 2945 
  device_config->vp_config[i].ring.scatter_mode = 4294967295U;
  
#line 2948 
  device_config->vp_config[i].ring.rxds_limit = 44ULL;
  
#line 2951 
  device_config->vp_config[i].fifo.enable = 1U;
  
#line 2953 
  device_config->vp_config[i].fifo.fifo_blocks = 2U;
  
#line 2956 
  device_config->vp_config[i].fifo.max_frags = 256U;
  
#line 2959 
  device_config->vp_config[i].fifo.memblock_size = 8096U;
  
#line 2962 
  device_config->vp_config[i].fifo.alignment_size = 128U;
  
#line 2965 
  device_config->vp_config[i].fifo.intr = 0U;
  
#line 2968 
  device_config->vp_config[i].fifo.no_snoop_bits = 0U;
  
#line 2970 
  device_config->vp_config[i].tti.intr_enable = 0U;
  
#line 2973 
  device_config->vp_config[i].tti.btimer_val = 4294967295U;
  
#line 2976 
  device_config->vp_config[i].tti.timer_ac_en = 4294967295U;
  
#line 2979 
  device_config->vp_config[i].tti.timer_ci_en = 4294967295U;
  
#line 2982 
  device_config->vp_config[i].tti.timer_ri_en = 4294967295U;
  
#line 2985 
  device_config->vp_config[i].tti.rtimer_val = 4294967295U;
  
#line 2988 
  device_config->vp_config[i].tti.util_sel = 4294967295U;
  
#line 2991 
  device_config->vp_config[i].tti.ltimer_val = 4294967295U;
  
#line 2994 
  device_config->vp_config[i].tti.urange_a = 4294967295U;
  
#line 2997 
  device_config->vp_config[i].tti.uec_a = 4294967295U;
  
#line 3000 
  device_config->vp_config[i].tti.urange_b = 4294967295U;
  
#line 3003 
  device_config->vp_config[i].tti.uec_b = 4294967295U;
  
#line 3006 
  device_config->vp_config[i].tti.urange_c = 4294967295U;
  
#line 3009 
  device_config->vp_config[i].tti.uec_c = 4294967295U;
  
#line 3012 
  device_config->vp_config[i].tti.uec_d = 4294967295U;
  
#line 3015 
  device_config->vp_config[i].rti.intr_enable = 0U;
  
#line 3018 
  device_config->vp_config[i].rti.btimer_val = 4294967295U;
  
#line 3021 
  device_config->vp_config[i].rti.timer_ac_en = 4294967295U;
  
#line 3024 
  device_config->vp_config[i].rti.timer_ci_en = 4294967295U;
  
#line 3027 
  device_config->vp_config[i].rti.timer_ri_en = 4294967295U;
  
#line 3030 
  device_config->vp_config[i].rti.rtimer_val = 4294967295U;
  
#line 3033 
  device_config->vp_config[i].rti.util_sel = 4294967295U;
  
#line 3036 
  device_config->vp_config[i].rti.ltimer_val = 4294967295U;
  
#line 3039 
  device_config->vp_config[i].rti.urange_a = 4294967295U;
  
#line 3042 
  device_config->vp_config[i].rti.uec_a = 4294967295U;
  
#line 3045 
  device_config->vp_config[i].rti.urange_b = 4294967295U;
  
#line 3048 
  device_config->vp_config[i].rti.uec_b = 4294967295U;
  
#line 3051 
  device_config->vp_config[i].rti.urange_c = 4294967295U;
  
#line 3054 
  device_config->vp_config[i].rti.uec_c = 4294967295U;
  
#line 3057 
  device_config->vp_config[i].rti.uec_d = 4294967295U;
  
#line 3060 
  device_config->vp_config[i].mtu = 4294967295U;
  
#line 3063 
  device_config->vp_config[i].rpa_strip_vlan_tag = 4294967295U;
  
#line 2931 
  i += 1U;
  ldv_52825: 
#line 2932 
  ;
  
#line 2931 
  if (i <= 16U) 
#line 2933 
                goto ldv_52824; else 
#line 2936 
                                     goto ldv_52826;
  ldv_52826: 
#line 2937 
  ;
  
#line 3067 
  __retres = VXGE_HW_OK;
  
#line 3067 
  return __retres;
}


#line 3075  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_swapper_set(struct vxge_hw_vpath_reg *vpath_reg)
{
  enum vxge_hw_status __retres;
  u64 val64;
  
#line 3080 
  val64 = (u64)readq((void const volatile *)(& vpath_reg->vpath_general_cfg1));
  
#line 3081 
  ldv_inline_asm();
  
#line 3082 
  val64 |= 281474976710656ULL;
  
#line 3083 
  writeq((unsigned long)val64,(void volatile *)(& vpath_reg->vpath_general_cfg1));
  
#line 3084 
  ldv_inline_asm();
  
#line 3086 
  __retres = VXGE_HW_OK;
  
#line 3086 
  return __retres;
}


#line 3094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_kdfc_swapper_set(struct vxge_hw_legacy_reg *legacy_reg, struct vxge_hw_vpath_reg *vpath_reg)
{
  enum vxge_hw_status __retres;
  u64 val64;
  
#line 3099 
  val64 = (u64)readq((void const volatile *)(& legacy_reg->pifm_wr_swap_en));
  
#line 3101 
  if (val64 == 18446744073709551615ULL) {
    
#line 3102 
    val64 = (u64)readq((void const volatile *)(& vpath_reg->kdfcctl_cfg0));
    
#line 3103 
    ldv_inline_asm();
    
#line 3105 
    val64 |= 8070450532247928832ULL;
    
#line 3109 
    writeq((unsigned long)val64,(void volatile *)(& vpath_reg->kdfcctl_cfg0));
    
#line 3110 
    ldv_inline_asm();
  }
  else ;
  
#line 3113 
  __retres = VXGE_HW_OK;
  
#line 3113 
  return __retres;
}


#line 3120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_mgmt_reg_read(struct __vxge_hw_device *hldev, enum vxge_hw_mgmt_reg_type type, u32 index, u32 offset, u64 *value)
{
  
#line 3124 
  enum vxge_hw_status status = 0;
  
#line 3126 
  if (hldev == (struct __vxge_hw_device *)0 || hldev->magic != 305419896U) {
    
#line 3127 
    status = VXGE_HW_ERR_INVALID_DEVICE;
    
#line 3128 
    goto exit;
  }
  else ;
  
#line 3131 
  switch ((unsigned int)type) {
    case (unsigned int)0: 
#line 3132 
    ;
    
#line 3133 
    if (offset > 64U) {
      
#line 3134 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3135 
      goto ldv_52846;
    }
    else ;
    
#line 3137 
    *value = (u64)readq((void const volatile *)hldev->legacy_reg + offset);
    
#line 3138 
    goto ldv_52846;
    case (unsigned int)1: 
#line 3139 
    ;
    
#line 3140 
    if (offset > 1208U) {
      
#line 3141 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3142 
      goto ldv_52846;
    }
    else ;
    
#line 3144 
    *value = (u64)readq((void const volatile *)hldev->toc_reg + offset);
    
#line 3145 
    goto ldv_52846;
    case (unsigned int)2: 
#line 3146 
    ;
    
#line 3147 
    if (offset > 4656U) {
      
#line 3148 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3149 
      goto ldv_52846;
    }
    else ;
    
#line 3151 
    *value = (u64)readq((void const volatile *)hldev->common_reg + offset);
    
#line 3152 
    goto ldv_52846;
    case (unsigned int)3: 
#line 3153 
    ;
    
#line 3154 
    if ((hldev->access_rights & 4U) == 0U) {
      
#line 3156 
      status = VXGE_HW_ERR_PRIVILAGED_OPEARATION;
      
#line 3157 
      goto ldv_52846;
    }
    else ;
    
#line 3159 
    if (offset > 44168U) {
      
#line 3160 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3161 
      goto ldv_52846;
    }
    else ;
    
#line 3163 
    *value = (u64)readq((void const volatile *)hldev->mrpcim_reg + offset);
    
#line 3164 
    goto ldv_52846;
    case (unsigned int)4: 
#line 3165 
    ;
    
#line 3166 
    if ((hldev->access_rights & 2U) == 0U) {
      
#line 3168 
      status = VXGE_HW_ERR_PRIVILAGED_OPEARATION;
      
#line 3169 
      goto ldv_52846;
    }
    else ;
    
#line 3171 
    if (index > 16U) {
      
#line 3172 
      status = VXGE_HW_ERR_INVALID_INDEX;
      
#line 3173 
      goto ldv_52846;
    }
    else ;
    
#line 3175 
    if (offset > 2320U) {
      
#line 3176 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3177 
      goto ldv_52846;
    }
    else ;
    
#line 3179 
    *value = (u64)readq((void const volatile *)hldev->srpcim_reg[index] + offset);
    
#line 3181 
    goto ldv_52846;
    case (unsigned int)5: 
#line 3182 
    ;
    
#line 3183 
    if (index > 16U || (hldev->vpath_assignments & (9223372036854775808ULL >> index)) == 0ULL) {
      
#line 3185 
      status = VXGE_HW_ERR_INVALID_INDEX;
      
#line 3186 
      goto ldv_52846;
    }
    else ;
    
#line 3188 
    if (offset > 896U) {
      
#line 3189 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3190 
      goto ldv_52846;
    }
    else ;
    
#line 3192 
    *value = (u64)readq((void const volatile *)hldev->vpmgmt_reg[index] + offset);
    
#line 3194 
    goto ldv_52846;
    case (unsigned int)6: 
#line 3195 
    ;
    
#line 3196 
    if (index > 16U || (hldev->vpath_assignments & (9223372036854775808ULL >> index)) == 0ULL) {
      
#line 3198 
      status = VXGE_HW_ERR_INVALID_INDEX;
      
#line 3199 
      goto ldv_52846;
    }
    else ;
    
#line 3201 
    if (index > 16U) {
      
#line 3202 
      status = VXGE_HW_ERR_INVALID_INDEX;
      
#line 3203 
      goto ldv_52846;
    }
    else ;
    
#line 3205 
    if (offset > 9792U) {
      
#line 3206 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3207 
      goto ldv_52846;
    }
    else ;
    
#line 3209 
    *value = (u64)readq((void const volatile *)hldev->vpath_reg[index] + offset);
    
#line 3211 
    goto ldv_52846;
    default: 
#line 3212 
    ;
    
#line 3213 
    status = VXGE_HW_ERR_INVALID_TYPE;
    
#line 3214 
    goto ldv_52846;
  }
  ldv_52846: 
#line 3217 
  ;
  exit: 
#line 3217 
  ;
  
#line 3218 
  return status;
}


#line 3225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_strip_fcs_check(struct __vxge_hw_device *hldev, u64 vpath_mask)
{
  enum vxge_hw_status __retres;
  struct vxge_hw_vpmgmt_reg *vpmgmt_reg;
  unsigned long tmp;
  
#line 3228 
  int i = 0;
  
#line 3228 
  int j = 0;
  
#line 3230 
  i = 0;
  
#line 3230 
  goto ldv_52866;
  ldv_52865: 
#line 3231 
  ;
  
#line 3231 
  if (((9223372036854775808ULL >> i) & vpath_mask) == 0ULL) 
#line 3232 
                                                            goto ldv_52861; else ;
  
#line 3233 
  vpmgmt_reg = hldev->vpmgmt_reg[i];
  
#line 3234 
  j = 0;
  
#line 3234 
  goto ldv_52863;
  ldv_52862: 
#line 3235 
  ;
  
#line 3235 
  tmp = readq((void const volatile *)(& vpmgmt_reg->rxmac_cfg0_port_vpmgmt_clone[j]));
  
#line 3235 
  if (((unsigned long long)tmp & 72057594037927936ULL) != 0ULL) {
    
#line 3237 
    __retres = VXGE_HW_FAIL;
    
#line 3237 
    goto return_label;
  }
  else ;
  
#line 3234 
  j += 1;
  ldv_52863: 
#line 3235 
  ;
  
#line 3234 
  if (j <= 1) 
#line 3236 
              goto ldv_52862; else 
#line 3239 
                                   goto ldv_52864;
  ldv_52864: 
#line 3240 
  ;
  ldv_52861: 
#line 3241 
  ;
  
#line 3230 
  i += 1;
  ldv_52866: 
#line 3231 
  ;
  
#line 3230 
  if (i <= 16) 
#line 3232 
               goto ldv_52865; else 
#line 3235 
                                    goto ldv_52867;
  ldv_52867: 
#line 3236 
  ;
  
#line 3240 
  __retres = VXGE_HW_OK;
  return_label: 
#line 3240 
                return __retres;
}


#line 3246  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_mgmt_reg_write(struct __vxge_hw_device *hldev, enum vxge_hw_mgmt_reg_type type, u32 index, u32 offset, u64 value)
{
  
#line 3250 
  enum vxge_hw_status status = 0;
  
#line 3252 
  if (hldev == (struct __vxge_hw_device *)0 || hldev->magic != 305419896U) {
    
#line 3253 
    status = VXGE_HW_ERR_INVALID_DEVICE;
    
#line 3254 
    goto exit;
  }
  else ;
  
#line 3257 
  switch ((unsigned int)type) {
    case (unsigned int)0: 
#line 3258 
    ;
    
#line 3259 
    if (offset > 64U) {
      
#line 3260 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3261 
      goto ldv_52878;
    }
    else ;
    
#line 3263 
    writeq((unsigned long)value,(void volatile *)hldev->legacy_reg + offset);
    
#line 3264 
    goto ldv_52878;
    case (unsigned int)1: 
#line 3265 
    ;
    
#line 3266 
    if (offset > 1208U) {
      
#line 3267 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3268 
      goto ldv_52878;
    }
    else ;
    
#line 3270 
    writeq((unsigned long)value,(void volatile *)hldev->toc_reg + offset);
    
#line 3271 
    goto ldv_52878;
    case (unsigned int)2: 
#line 3272 
    ;
    
#line 3273 
    if (offset > 4656U) {
      
#line 3274 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3275 
      goto ldv_52878;
    }
    else ;
    
#line 3277 
    writeq((unsigned long)value,(void volatile *)hldev->common_reg + offset);
    
#line 3278 
    goto ldv_52878;
    case (unsigned int)3: 
#line 3279 
    ;
    
#line 3280 
    if ((hldev->access_rights & 4U) == 0U) {
      
#line 3282 
      status = VXGE_HW_ERR_PRIVILAGED_OPEARATION;
      
#line 3283 
      goto ldv_52878;
    }
    else ;
    
#line 3285 
    if (offset > 44168U) {
      
#line 3286 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3287 
      goto ldv_52878;
    }
    else ;
    
#line 3289 
    writeq((unsigned long)value,(void volatile *)hldev->mrpcim_reg + offset);
    
#line 3290 
    goto ldv_52878;
    case (unsigned int)4: 
#line 3291 
    ;
    
#line 3292 
    if ((hldev->access_rights & 2U) == 0U) {
      
#line 3294 
      status = VXGE_HW_ERR_PRIVILAGED_OPEARATION;
      
#line 3295 
      goto ldv_52878;
    }
    else ;
    
#line 3297 
    if (index > 16U) {
      
#line 3298 
      status = VXGE_HW_ERR_INVALID_INDEX;
      
#line 3299 
      goto ldv_52878;
    }
    else ;
    
#line 3301 
    if (offset > 2320U) {
      
#line 3302 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3303 
      goto ldv_52878;
    }
    else ;
    
#line 3305 
    writeq((unsigned long)value,(void volatile *)hldev->srpcim_reg[index] + offset);
    
#line 3308 
    goto ldv_52878;
    case (unsigned int)5: 
#line 3309 
    ;
    
#line 3310 
    if (index > 16U || (hldev->vpath_assignments & (9223372036854775808ULL >> index)) == 0ULL) {
      
#line 3312 
      status = VXGE_HW_ERR_INVALID_INDEX;
      
#line 3313 
      goto ldv_52878;
    }
    else ;
    
#line 3315 
    if (offset > 896U) {
      
#line 3316 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3317 
      goto ldv_52878;
    }
    else ;
    
#line 3319 
    writeq((unsigned long)value,(void volatile *)hldev->vpmgmt_reg[index] + offset);
    
#line 3321 
    goto ldv_52878;
    case (unsigned int)6: 
#line 3322 
    ;
    
#line 3323 
    if (index > 16U || (hldev->vpath_assignments & (9223372036854775808ULL >> index)) == 0ULL) {
      
#line 3325 
      status = VXGE_HW_ERR_INVALID_INDEX;
      
#line 3326 
      goto ldv_52878;
    }
    else ;
    
#line 3328 
    if (offset > 9792U) {
      
#line 3329 
      status = VXGE_HW_ERR_INVALID_OFFSET;
      
#line 3330 
      goto ldv_52878;
    }
    else ;
    
#line 3332 
    writeq((unsigned long)value,(void volatile *)hldev->vpath_reg[index] + offset);
    
#line 3334 
    goto ldv_52878;
    default: 
#line 3335 
    ;
    
#line 3336 
    status = VXGE_HW_ERR_INVALID_TYPE;
    
#line 3337 
    goto ldv_52878;
  }
  ldv_52878: 
#line 3339 
  ;
  exit: 
#line 3339 
  ;
  
#line 3340 
  return status;
}


#line 3347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_fifo_abort(struct __vxge_hw_fifo *fifo)
{
  enum vxge_hw_status __retres;
  void *txdlh;
  ldv_52891: 
#line 3350 
  ;
  
#line 3352 
  vxge_hw_channel_dtr_try_complete(& fifo->channel,& txdlh);
  
#line 3354 
  if (txdlh == (void *)0) 
#line 3355 
                          goto ldv_52890; else ;
  
#line 3357 
  vxge_hw_channel_dtr_complete(& fifo->channel);
  
#line 3359 
  if (fifo->txdl_term != (void (*)(void *, enum vxge_hw_txdl_state , void *))0) 
    
#line 3360 
    (*(fifo->txdl_term))(txdlh,(enum vxge_hw_txdl_state)VXGE_HW_TXDL_STATE_POSTED,fifo->channel.userdata); else ;
  
#line 3365 
  vxge_hw_channel_dtr_free(& fifo->channel,txdlh);
  
#line 3352 
  goto ldv_52891;
  ldv_52890: 
#line 3353 
  ;
  
#line 3368 
  __retres = VXGE_HW_OK;
  
#line 3368 
  return __retres;
}


#line 3375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_fifo_reset(struct __vxge_hw_fifo *fifo)
{
  
#line 3377 
  enum vxge_hw_status status = 0;
  
#line 3379 
  __vxge_hw_fifo_abort(fifo);
  
#line 3380 
  status = __vxge_hw_channel_reset(& fifo->channel);
  
#line 3382 
  return status;
}


#line 3390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_fifo_delete(struct __vxge_hw_vpath_handle *vp)
{
  enum vxge_hw_status __retres;
  
#line 3392 
  struct __vxge_hw_fifo *fifo = (vp->vpath)->fifoh;
  
#line 3394 
  __vxge_hw_fifo_abort(fifo);
  
#line 3396 
  if (fifo->mempool != (struct vxge_hw_mempool *)0) 
#line 3397 
                                                    __vxge_hw_mempool_destroy(fifo->mempool); else ;
  
#line 3399 
  (vp->vpath)->fifoh = (struct __vxge_hw_fifo *)0;
  
#line 3401 
  __vxge_hw_channel_free(& fifo->channel);
  
#line 3403 
  __retres = VXGE_HW_OK;
  
#line 3403 
  return __retres;
}


#line 3413  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_fifo_mempool_item_alloc(struct vxge_hw_mempool *mempoolh, u32 memblock_index, struct vxge_hw_mempool_dma *dma_object, u32 index, u32 is_last)
{
  u32 memblock_item_idx;
  struct __vxge_hw_fifo_txdl_priv *txdl_priv;
  void *tmp;
  
#line 3420 
  struct vxge_hw_fifo_txd *txdp = (struct vxge_hw_fifo_txd *)*(mempoolh->items_arr + index);
  
#line 3422 
  struct __vxge_hw_fifo *fifo = (struct __vxge_hw_fifo *)mempoolh->userdata;
  
#line 3424 
  void *memblock = *(mempoolh->memblocks_arr + memblock_index);
  
#line 3428 
  tmp = __vxge_hw_mempool_item_priv(mempoolh,memblock_index,(void *)txdp,& memblock_item_idx);
  
#line 3428 
  txdp->host_control = (unsigned long long)tmp;
  
#line 3432 
  txdl_priv = __vxge_hw_fifo_txdl_priv(fifo,txdp);
  
#line 3436 
  *(fifo->channel.reserve_arr + ((fifo->channel.reserve_ptr - index) + 4294967295U)) = (void *)txdp;
  
#line 3439 
  txdl_priv->dma_offset = (long)txdp - (long)memblock;
  
#line 3440 
  txdl_priv->dma_addr = dma_object->addr + (unsigned long long)txdl_priv->dma_offset;
  
#line 3441 
  txdl_priv->dma_handle = dma_object->handle;
  
#line 3442 
  txdl_priv->memblock = memblock;
  
#line 3443 
  txdl_priv->first_txdp = txdp;
  
#line 3444 
  txdl_priv->next_txdl_priv = (struct __vxge_hw_fifo_txdl_priv *)0;
  
#line 3445 
  txdl_priv->alloc_frags = 0U;
  
#line 3446 
  return;
}


#line 3453  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_fifo_create(struct __vxge_hw_vpath_handle *vp, struct vxge_hw_fifo_attr *attr)
{
  struct __vxge_hw_fifo *fifo;
  struct vxge_hw_fifo_config *config;
  u32 txdl_size;
  u32 txdl_per_memblock;
  struct vxge_hw_mempool_cbs fifo_mp_callback;
  struct __vxge_hw_virtualpath *vpath;
  
#line 3456 
  enum vxge_hw_status status = 0;
  
#line 3463 
  if (vp == (struct __vxge_hw_vpath_handle *)0 || attr == (struct vxge_hw_fifo_attr *)0) {
    
#line 3464 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 3465 
    goto exit;
  }
  else ;
  
#line 3467 
  vpath = vp->vpath;
  
#line 3468 
  config = & (vpath->hldev)->config.vp_config[vpath->vp_id].fifo;
  
#line 3470 
  txdl_size = config->max_frags * 32U;
  
#line 3472 
  txdl_per_memblock = config->memblock_size / txdl_size;
  
#line 3474 
  fifo = (struct __vxge_hw_fifo *)__vxge_hw_channel_allocate(vp,(enum __vxge_hw_channel_type)VXGE_HW_CHANNEL_TYPE_FIFO,config->fifo_blocks * txdl_per_memblock,attr->per_txdl_space,attr->userdata);
  
#line 3479 
  if (fifo == (struct __vxge_hw_fifo *)0) {
    
#line 3480 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 3481 
    goto exit;
  }
  else ;
  
#line 3484 
  vpath->fifoh = fifo;
  
#line 3485 
  fifo->nofl_db = vpath->nofl_db;
  
#line 3487 
  fifo->vp_id = vpath->vp_id;
  
#line 3488 
  fifo->vp_reg = vpath->vp_reg;
  
#line 3489 
  fifo->stats = & (vpath->sw_stats)->fifo_stats;
  
#line 3491 
  fifo->config = config;
  
#line 3494 
  fifo->interrupt_type = 65536ULL;
  
#line 3495 
  fifo->tim_tti_cfg1_saved = vpath->tim_tti_cfg1_saved;
  
#line 3496 
  fifo->tim_tti_cfg3_saved = vpath->tim_tti_cfg3_saved;
  
#line 3498 
  if ((fifo->config)->intr != 0U) 
#line 3499 
                                  fifo->interrupt_type = 131072ULL; else ;
  
#line 3501 
  fifo->no_snoop_bits = config->no_snoop_bits;
  
#line 3523 
  fifo->priv_size = attr->per_txdl_space + 120U;
  
#line 3525 
  fifo->priv_size = (fifo->priv_size + 127U) & 4294967168U;
  
#line 3528 
  fifo->per_txdl_space = attr->per_txdl_space;
  
#line 3531 
  fifo->txdl_size = txdl_size;
  
#line 3532 
  fifo->txdl_per_memblock = txdl_per_memblock;
  
#line 3534 
  fifo->txdl_term = attr->txdl_term;
  
#line 3535 
  fifo->callback = attr->callback;
  
#line 3537 
  if (fifo->txdl_per_memblock == 0U) {
    
#line 3538 
    __vxge_hw_fifo_delete(vp);
    
#line 3539 
    status = VXGE_HW_ERR_INVALID_BLOCK_SIZE;
    
#line 3540 
    goto exit;
  }
  else ;
  
#line 3543 
  fifo_mp_callback.item_func_alloc = & __vxge_hw_fifo_mempool_item_alloc;
  
#line 3545 
  fifo->mempool = __vxge_hw_mempool_create(vpath->hldev,(fifo->config)->memblock_size,fifo->txdl_size,fifo->priv_size,(fifo->config)->fifo_blocks * fifo->txdl_per_memblock,(fifo->config)->fifo_blocks * fifo->txdl_per_memblock,(struct vxge_hw_mempool_cbs const *)(& fifo_mp_callback),(void *)fifo);
  
#line 3555 
  if (fifo->mempool == (struct vxge_hw_mempool *)0) {
    
#line 3556 
    __vxge_hw_fifo_delete(vp);
    
#line 3557 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 3558 
    goto exit;
  }
  else ;
  
#line 3561 
  status = __vxge_hw_channel_initialize(& fifo->channel);
  
#line 3562 
  if (status != VXGE_HW_OK) {
    
#line 3563 
    __vxge_hw_fifo_delete(vp);
    
#line 3564 
    goto exit;
  }
  else ;
  exit: 
#line 3568 
  ;
  
#line 3569 
  return status;
}


#line 3578  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_pci_read(struct __vxge_hw_virtualpath *vpath, u32 phy_func_0, u32 offset, u32 *val)
{
  u64 val64;
  
#line 3582 
  enum vxge_hw_status status = 0;
  
#line 3583 
  struct vxge_hw_vpath_reg *vp_reg = vpath->vp_reg;
  
#line 3585 
  val64 = (unsigned long long)offset << 52;
  
#line 3587 
  if (phy_func_0 != 0U) 
#line 3588 
                        val64 |= 281474976710656ULL; else ;
  
#line 3590 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->pci_config_access_cfg1));
  
#line 3591 
  ldv_inline_asm();
  
#line 3592 
  writeq(9223372036854775808UL,(void volatile *)(& vp_reg->pci_config_access_cfg2));
  
#line 3594 
  ldv_inline_asm();
  
#line 3596 
  status = __vxge_hw_device_register_poll((void *)(& vp_reg->pci_config_access_cfg2),18446744073709551615ULL,1000U);
  
#line 3600 
  if (status != VXGE_HW_OK) 
#line 3601 
                            goto exit; else ;
  
#line 3603 
  val64 = (u64)readq((void const volatile *)(& vp_reg->pci_config_access_status));
  
#line 3605 
  if (val64 < (u64)0) {
    
#line 3606 
    status = VXGE_HW_FAIL;
    
#line 3607 
    *val = 0U;
  }
  else 
#line 3609 
       *val = (unsigned int)val64;
  exit: 
#line 3610 
  ;
  
#line 3611 
  return status;
}


#line 3622  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_device_flick_link_led(struct __vxge_hw_device *hldev, u64 on_off)
{
  struct __vxge_hw_virtualpath *vpath;
  u64 data0;
  enum vxge_hw_status status;
  
#line 3625 
  u64 data1 = 0ULL;
  
#line 3625 
  u64 steer_ctrl = 0ULL;
  
#line 3628 
  if (hldev == (struct __vxge_hw_device *)0) {
    
#line 3629 
    status = VXGE_HW_ERR_INVALID_DEVICE;
    
#line 3630 
    goto exit;
  }
  else ;
  
#line 3633 
  vpath = & hldev->virtual_paths[hldev->first_vp_id];
  
#line 3635 
  data0 = on_off;
  
#line 3636 
  status = vxge_hw_vpath_fw_api(vpath,4U,13U,0U,& data0,& data1,& steer_ctrl);
  exit: 
#line 3640 
  ;
  
#line 3641 
  return status;
}


#line 3648  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status __vxge_hw_vpath_rts_table_get(struct __vxge_hw_vpath_handle *vp, u32 action, u32 rts_table, u32 offset, u64 *data0, u64 *data1)
{
  enum vxge_hw_status status;
  
#line 3653 
  u64 steer_ctrl = 0ULL;
  
#line 3655 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 3656 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 3657 
    goto exit;
  }
  else ;
  
#line 3660 
  if ((rts_table == 6U || rts_table == 12U) || rts_table + 4294967288U <= 1U) 
    
#line 3668 
    steer_ctrl = 68719476736ULL; else ;
  
#line 3671 
  status = vxge_hw_vpath_fw_api(vp->vpath,action,rts_table,offset,data0,data1,& steer_ctrl);
  
#line 3673 
  if (status != VXGE_HW_OK) 
#line 3674 
                            goto exit; else ;
  
#line 3676 
  if (rts_table != 0U && rts_table != 12U) 
#line 3679 
                                           *data1 = 0ULL; else ;
  exit: 
#line 3680 
  ;
  
#line 3681 
  return status;
}


#line 3688  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status __vxge_hw_vpath_rts_table_set(struct __vxge_hw_vpath_handle *vp, u32 action, u32 rts_table, u32 offset, u64 steer_data0, u64 steer_data1)
{
  u64 data0;
  enum vxge_hw_status status;
  
#line 3692 
  u64 data1 = 0ULL;
  
#line 3692 
  u64 steer_ctrl = 0ULL;
  
#line 3695 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 3696 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 3697 
    goto exit;
  }
  else ;
  
#line 3700 
  data0 = steer_data0;
  
#line 3702 
  if (rts_table == 0U || rts_table == 12U) 
#line 3705 
                                           data1 = steer_data1; else ;
  
#line 3707 
  status = vxge_hw_vpath_fw_api(vp->vpath,action,rts_table,offset,& data0,& data1,& steer_ctrl);
  exit: 
#line 3709 
  ;
  
#line 3710 
  return status;
}


#line 3716  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_rts_rth_set(struct __vxge_hw_vpath_handle *vp, enum vxge_hw_rth_algoritms algorithm, struct vxge_hw_rth_hash_types *hash_type, u16 bucket_size)
{
  u64 data0;
  u64 data1;
  
#line 3723 
  enum vxge_hw_status status = 0;
  
#line 3725 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 3726 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 3727 
    goto exit;
  }
  else ;
  
#line 3730 
  status = __vxge_hw_vpath_rts_table_get(vp,0U,5U,0U,& data0,& data1);
  
#line 3734 
  if (status != VXGE_HW_OK) 
#line 3735 
                            goto exit; else ;
  
#line 3737 
  data0 &= 17352369364258521087ULL;
  
#line 3740 
  data0 = ((((unsigned long long)bucket_size << 56) | ((unsigned long long)algorithm << 52)) | data0) | 1152921504606846976ULL;
  
#line 3744 
  if ((unsigned int)*((unsigned char *)hash_type + 0UL) != 0U) 
#line 3745 
                                                               data0 |= 281474976710656ULL; else ;
  
#line 3747 
  if ((unsigned int)*((unsigned char *)hash_type + 0UL) != 0U) 
#line 3748 
                                                               data0 |= 17592186044416ULL; else ;
  
#line 3750 
  if ((unsigned int)*((unsigned char *)hash_type + 0UL) != 0U) 
#line 3751 
                                                               data0 |= 1099511627776ULL; else ;
  
#line 3753 
  if ((unsigned int)*((unsigned char *)hash_type + 0UL) != 0U) 
#line 3754 
                                                               data0 |= 68719476736ULL; else ;
  
#line 3756 
  if ((unsigned int)*((unsigned char *)hash_type + 0UL) != 0U) 
#line 3757 
                                                               data0 |= 4294967296ULL; else ;
  
#line 3760 
  if ((unsigned int)*((unsigned char *)hash_type + 0UL) != 0U) 
#line 3761 
                                                               data0 |= 268435456ULL; else ;
  
#line 3763 
  if ((data0 & 16777216ULL) != 0ULL) 
#line 3764 
                                     data0 &= 18446744073692774399ULL; else 
                                                                    
#line 3766 
                                                                    data0 |= 16777216ULL;
  
#line 3768 
  status = __vxge_hw_vpath_rts_table_set(vp,1U,5U,0U,data0,0ULL);
  exit: 
#line 3772 
  ;
  
#line 3773 
  return status;
}


#line 3777  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void vxge_hw_rts_rth_data0_data1_get(u32 j, u64 *data0, u64 *data1, u16 flag, u8 *itable)
{
  
#line 3780 
  switch ((int)flag) {
    case 1: 
#line 3781 
    ;
    
#line 3782 
    *data0 = (((unsigned long long)j << 56) | ((unsigned long long)*(itable + j) << 48)) | 36028797018963968ULL;
    case 2: 
#line 3786 
    ;
    
#line 3787 
    *data0 = (*data0 | (((unsigned long long)j << 40) | ((unsigned long long)*(itable + j) << 32))) | 549755813888ULL;
    case 3: 
#line 3792 
    ;
    
#line 3793 
    *data1 = (((unsigned long long)j << 56) | ((unsigned long long)*(itable + j) << 48)) | 36028797018963968ULL;
    case 4: 
#line 3797 
    ;
    
#line 3798 
    *data1 = (*data1 | (((unsigned long long)j << 40) | ((unsigned long long)*(itable + j) << 32))) | 549755813888ULL;
    default: 
#line 3803 
    ;
    
#line 3804 
    goto return_label;
  }
  return_label: 
#line 3780 
                return;
}


#line 3810  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_rts_rth_itable_set(struct __vxge_hw_vpath_handle **vpath_handles, u32 vpath_count, u8 *mtable, u8 *itable, u32 itable_size)
{
  u32 i;
  u32 j;
  u32 action;
  u32 rts_table;
  u64 data0;
  u64 data1;
  u32 max_entries;
  
#line 3821 
  enum vxge_hw_status status = 0;
  
#line 3822 
  struct __vxge_hw_vpath_handle *vp = *vpath_handles;
  
#line 3824 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 3825 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 3826 
    goto exit;
  }
  else ;
  
#line 3829 
  max_entries = 1U << itable_size;
  
#line 3831 
  if ((unsigned int)*((unsigned char *)(& ((vp->vpath)->hldev)->config) + 12UL) == 0U) {
    
#line 3833 
    action = 1U;
    
#line 3834 
    rts_table = 6U;
    
#line 3837 
    j = 0U;
    
#line 3837 
    goto ldv_53008;
    ldv_53007: 
#line 3838 
    ;
    
#line 3839 
    data1 = 0ULL;
    
#line 3841 
    data0 = (unsigned long long)*(itable + j) << 48;
    
#line 3845 
    status = __vxge_hw_vpath_rts_table_set(*vpath_handles,action,rts_table,j,data0,data1);
    
#line 3848 
    if (status != VXGE_HW_OK) 
#line 3849 
                              goto exit; else ;
    
#line 3837 
    j += 1U;
    ldv_53008: 
#line 3838 
    ;
    
#line 3837 
    if (j < max_entries) 
#line 3839 
                         goto ldv_53007; else 
#line 3842 
                                              goto ldv_53009;
    ldv_53009: 
#line 3843 
    ;
    
#line 3852 
    j = 0U;
    
#line 3852 
    goto ldv_53011;
    ldv_53010: 
#line 3853 
    ;
    
#line 3854 
    data1 = 0ULL;
    
#line 3856 
    data0 = ((unsigned long long)*(itable + j) << 48) | 1152921504606846976ULL;
    
#line 3861 
    status = __vxge_hw_vpath_rts_table_set(*(vpath_handles + (int)*(mtable + (int)*(itable + j))),action,rts_table,j,data0,data1);
    
#line 3865 
    if (status != VXGE_HW_OK) 
#line 3866 
                              goto exit; else ;
    
#line 3852 
    j += 1U;
    ldv_53011: 
#line 3853 
    ;
    
#line 3852 
    if (j < max_entries) 
#line 3854 
                         goto ldv_53010; else 
#line 3857 
                                              goto ldv_53012;
    ldv_53012: 
#line 3858 
    ;
  }
  else {
    
#line 3869 
    action = 1U;
    
#line 3870 
    rts_table = 12U;
    
#line 3872 
    i = 0U;
    
#line 3872 
    goto ldv_53029;
    ldv_53028: 
#line 3873 
    ;
    
#line 3874 
    j = 0U;
    
#line 3874 
    goto ldv_53026;
    ldv_53025: 
#line 3875 
    ;
    
#line 3876 
    data0 = 0ULL;
    
#line 3877 
    data1 = 0ULL;
    
#line 3879 
    goto ldv_53013;
    ldv_53015: 
#line 3880 
    ;
    
#line 3880 
    if ((unsigned int)*(mtable + (int)*(itable + j)) != i) {
      
#line 3881 
      j += 1U;
      
#line 3882 
      goto ldv_53013;
    }
    else ;
    
#line 3884 
    vxge_hw_rts_rth_data0_data1_get(j,& data0,& data1,(unsigned short)1,itable);
    
#line 3886 
    j += 1U;
    
#line 3887 
    goto ldv_53014;
    ldv_53013: 
#line 3888 
    ;
    
#line 3879 
    if (j < max_entries) 
#line 3881 
                         goto ldv_53015; else 
#line 3884 
                                              goto ldv_53014;
    ldv_53014: 
#line 3885 
    ;
    
#line 3890 
    goto ldv_53016;
    ldv_53018: 
#line 3891 
    ;
    
#line 3891 
    if ((unsigned int)*(mtable + (int)*(itable + j)) != i) {
      
#line 3892 
      j += 1U;
      
#line 3893 
      goto ldv_53016;
    }
    else ;
    
#line 3895 
    vxge_hw_rts_rth_data0_data1_get(j,& data0,& data1,(unsigned short)2,itable);
    
#line 3897 
    j += 1U;
    
#line 3898 
    goto ldv_53017;
    ldv_53016: 
#line 3899 
    ;
    
#line 3890 
    if (j < max_entries) 
#line 3892 
                         goto ldv_53018; else 
#line 3895 
                                              goto ldv_53017;
    ldv_53017: 
#line 3896 
    ;
    
#line 3901 
    goto ldv_53019;
    ldv_53021: 
#line 3902 
    ;
    
#line 3902 
    if ((unsigned int)*(mtable + (int)*(itable + j)) != i) {
      
#line 3903 
      j += 1U;
      
#line 3904 
      goto ldv_53019;
    }
    else ;
    
#line 3906 
    vxge_hw_rts_rth_data0_data1_get(j,& data0,& data1,(unsigned short)3,itable);
    
#line 3908 
    j += 1U;
    
#line 3909 
    goto ldv_53020;
    ldv_53019: 
#line 3910 
    ;
    
#line 3901 
    if (j < max_entries) 
#line 3903 
                         goto ldv_53021; else 
#line 3906 
                                              goto ldv_53020;
    ldv_53020: 
#line 3907 
    ;
    
#line 3912 
    goto ldv_53022;
    ldv_53024: 
#line 3913 
    ;
    
#line 3913 
    if ((unsigned int)*(mtable + (int)*(itable + j)) != i) {
      
#line 3914 
      j += 1U;
      
#line 3915 
      goto ldv_53022;
    }
    else ;
    
#line 3917 
    vxge_hw_rts_rth_data0_data1_get(j,& data0,& data1,(unsigned short)4,itable);
    
#line 3919 
    j += 1U;
    
#line 3920 
    goto ldv_53023;
    ldv_53022: 
#line 3921 
    ;
    
#line 3912 
    if (j < max_entries) 
#line 3914 
                         goto ldv_53024; else 
#line 3917 
                                              goto ldv_53023;
    ldv_53023: 
#line 3918 
    ;
    
#line 3923 
    if (data0 != 0ULL) {
      
#line 3924 
      status = __vxge_hw_vpath_rts_table_set(*(vpath_handles + i),action,rts_table,0U,data0,data1);
      
#line 3929 
      if (status != VXGE_HW_OK) 
#line 3930 
                                goto exit; else ;
    }
    else ;
    ldv_53026: 
#line 3932 
    ;
    
#line 3874 
    if (j < max_entries) 
#line 3876 
                         goto ldv_53025; else 
#line 3879 
                                              goto ldv_53027;
    ldv_53027: 
#line 3880 
    ;
    
#line 3872 
    i += 1U;
    ldv_53029: 
#line 3873 
    ;
    
#line 3872 
    if (i < vpath_count) 
#line 3874 
                         goto ldv_53028; else 
#line 3877 
                                              goto ldv_53030;
    ldv_53030: 
#line 3878 
    ;
  }
  exit: 
#line 3935 
  ;
  
#line 3936 
  return status;
}


#line 3949  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_check_leak(struct __vxge_hw_ring *ring)
{
  enum vxge_hw_status __retres;
  u64 rxd_new_count;
  u64 rxd_spat;
  unsigned int tmp;
  
#line 3951 
  enum vxge_hw_status status = 0;
  
#line 3954 
  if (ring == (struct __vxge_hw_ring *)0) {
    
#line 3955 
    __retres = status;
    
#line 3955 
    goto return_label;
  }
  else ;
  
#line 3957 
  tmp = readl((void const volatile *)(& (ring->vp_reg)->prc_rxd_doorbell));
  
#line 3957 
  rxd_new_count = (unsigned long long)tmp;
  
#line 3958 
  rxd_spat = (u64)readq((void const volatile *)(& (ring->vp_reg)->prc_cfg6));
  
#line 3959 
  rxd_spat <<= 19;
  
#line 3961 
  if (rxd_new_count >= rxd_spat) 
#line 3962 
                                 status = VXGE_HW_FAIL; else ;
  
#line 3964 
  __retres = status;
  return_label: 
#line 3964 
                return __retres;
}


#line 3972  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_mgmt_read(struct __vxge_hw_device *hldev, struct __vxge_hw_virtualpath *vpath)
{
  enum vxge_hw_status __retres;
  u32 i;
  u64 val64;
  
#line 3976 
  u32 mtu = 0U;
  
#line 3976 
  u32 max_pyld = 0U;
  
#line 3979 
  i = 0U;
  
#line 3979 
  goto ldv_53046;
  ldv_53045: 
#line 3980 
  ;
  
#line 3981 
  val64 = (u64)readq((void const volatile *)(& (vpath->vpmgmt_reg)->rxmac_cfg0_port_vpmgmt_clone[i]));
  
#line 3983 
  max_pyld = (unsigned int)val64 & 16383U;
  
#line 3987 
  if (mtu < max_pyld) 
#line 3988 
                      mtu = max_pyld; else ;
  
#line 3979 
  i += 1U;
  ldv_53046: 
#line 3980 
  ;
  
#line 3979 
  if (i <= 1U) 
#line 3981 
               goto ldv_53045; else 
#line 3984 
                                    goto ldv_53047;
  ldv_53047: 
#line 3985 
  ;
  
#line 3991 
  vpath->max_mtu = mtu + 26U;
  
#line 3993 
  val64 = (u64)readq((void const volatile *)(& (vpath->vpmgmt_reg)->xmac_vsport_choices_vp));
  
#line 3995 
  i = 0U;
  
#line 3995 
  goto ldv_53049;
  ldv_53048: 
#line 3996 
  ;
  
#line 3996 
  if (((9223372036854775808ULL >> i) & val64) != 0ULL) 
#line 3997 
                                                       vpath->vsport_number = i; else ;
  
#line 3995 
  i += 1U;
  ldv_53049: 
#line 3996 
  ;
  
#line 3995 
  if (i <= 16U) 
#line 3997 
                goto ldv_53048; else 
#line 4000 
                                     goto ldv_53050;
  ldv_53050: 
#line 4001 
  ;
  
#line 4000 
  val64 = (u64)readq((void const volatile *)(& (vpath->vpmgmt_reg)->xgmac_gen_status_vpmgmt_clone));
  
#line 4002 
  if ((val64 & 1152921504606846976ULL) != 0ULL) 
#line 4003 
                                                (vpath->hldev)->link_state = VXGE_HW_LINK_UP; else 
                                                                    
#line 4005 
                                                                    (vpath->hldev)->link_state = VXGE_HW_LINK_DOWN;
  
#line 4007 
  __retres = VXGE_HW_OK;
  
#line 4007 
  return __retres;
}


#line 4016  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_reset_check(struct __vxge_hw_virtualpath *vpath)
{
  enum vxge_hw_status status;
  
#line 4020 
  status = __vxge_hw_device_register_poll((void *)(& ((vpath->hldev)->common_reg)->vpath_rst_in_prog),(unsigned long long)(1 << (16U - vpath->vp_id)) << 47,(vpath->hldev)->config.device_poll_millis);
  
#line 4026 
  return status;
}


#line 4034  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_reset(struct __vxge_hw_device *hldev, u32 vp_id)
{
  enum vxge_hw_status __retres;
  u64 val64;
  
#line 4038 
  val64 = (unsigned long long)(1 << (16U - vp_id)) << 47;
  
#line 4040 
  __vxge_hw_pio_mem_write32_upper((unsigned int)(val64 >> 32),(void *)(& (hldev->common_reg)->cmn_rsthdlr_cfg0));
  
#line 4043 
  __retres = VXGE_HW_OK;
  
#line 4043 
  return __retres;
}


#line 4051  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_sw_reset(struct __vxge_hw_device *hldev, u32 vp_id)
{
  struct __vxge_hw_virtualpath *vpath;
  
#line 4053 
  enum vxge_hw_status status = 0;
  
#line 4056 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 4058 
  if (vpath->ringh != (struct __vxge_hw_ring *)0) {
    
#line 4059 
    status = __vxge_hw_ring_reset(vpath->ringh);
    
#line 4060 
    if (status != VXGE_HW_OK) 
#line 4061 
                              goto exit; else ;
  }
  else ;
  
#line 4064 
  if (vpath->fifoh != (struct __vxge_hw_fifo *)0) 
#line 4065 
                                                  status = __vxge_hw_fifo_reset(vpath->fifoh); else ;
  exit: 
#line 4066 
  ;
  
#line 4067 
  return status;
}


#line 4076  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_vpath_prc_configure(struct __vxge_hw_device *hldev, u32 vp_id)
{
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  struct vxge_hw_vp_config *vp_config;
  struct vxge_hw_vpath_reg *vp_reg;
  u64 tmp_2;
  
#line 4083 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 4084 
  vp_reg = vpath->vp_reg;
  
#line 4085 
  vp_config = vpath->vp_config;
  
#line 4087 
  if (vp_config->ring.enable == 0U) 
#line 4088 
                                    goto return_label; else ;
  
#line 4090 
  val64 = (u64)readq((void const volatile *)(& vp_reg->prc_cfg1));
  
#line 4091 
  val64 |= 268435456ULL;
  
#line 4092 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->prc_cfg1));
  
#line 4094 
  val64 = (u64)readq((void const volatile *)(& (vpath->vp_reg)->prc_cfg6));
  
#line 4095 
  val64 |= 288230376151711744ULL;
  
#line 4096 
  writeq((unsigned long)val64,(void volatile *)(& (vpath->vp_reg)->prc_cfg6));
  
#line 4098 
  val64 = (u64)readq((void const volatile *)(& vp_reg->prc_cfg7));
  
#line 4100 
  if ((vpath->vp_config)->ring.scatter_mode != 4294967295U) {
    
#line 4103 
    val64 &= 18230571291595767807ULL;
    
#line 4105 
    switch ((vpath->vp_config)->ring.scatter_mode) {
      case (u32)0: 
#line 4106 
      ;
      
#line 4107 
      val64 = val64;
      
#line 4109 
      goto ldv_53076;
      case (u32)1: 
#line 4110 
      ;
      
#line 4111 
      val64 |= 144115188075855872ULL;
      
#line 4113 
      goto ldv_53076;
      case (u32)2: 
#line 4114 
      ;
      
#line 4115 
      val64 |= 72057594037927936ULL;
      
#line 4117 
      goto ldv_53076;
    }
    ldv_53076: 
#line 4119 
    ;
  }
  else ;
  
#line 4121 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->prc_cfg7));
  
#line 4123 
  ;
  
#line 4123 
  tmp_2 = __vxge_hw_ring_first_block_address_get(vpath->ringh);
  
#line 4123 
  writeq((unsigned long)((tmp_2 >> 3) << 3),(void volatile *)(& vp_reg->prc_cfg5));
  
#line 4127 
  val64 = (u64)readq((void const volatile *)(& vp_reg->prc_cfg4));
  
#line 4128 
  val64 |= 72057594037927936ULL;
  
#line 4129 
  val64 &= 18445899648779419647ULL;
  
#line 4131 
  val64 = val64;
  
#line 4134 
  if ((unsigned int)*((unsigned char *)(& hldev->config) + 12UL) == 0U) 
    
#line 4135 
    val64 |= 4294967296ULL; else 
#line 4137 
                                 val64 &= 18446744069414584319ULL;
  
#line 4139 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->prc_cfg4));
  return_label: 
#line 4140 
                return;
}


#line 4148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_kdfc_configure(struct __vxge_hw_device *hldev, u32 vp_id)
{
  enum vxge_hw_status __retres;
  u64 val64;
  u64 vpath_stride;
  struct __vxge_hw_virtualpath *vpath;
  struct vxge_hw_vpath_reg *vp_reg;
  
#line 4152 
  enum vxge_hw_status status = 0;
  
#line 4156 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 4157 
  vp_reg = vpath->vp_reg;
  
#line 4158 
  status = __vxge_hw_kdfc_swapper_set(hldev->legacy_reg,vp_reg);
  
#line 4160 
  if (status != VXGE_HW_OK) 
#line 4161 
                            goto exit; else ;
  
#line 4163 
  val64 = (u64)readq((void const volatile *)(& vp_reg->kdfc_drbl_triplet_total));
  
#line 4165 
  vpath->max_kdfc_db = ((unsigned int)((val64 + 1ULL) >> 32) & 32767U) / 2U;
  
#line 4169 
  if ((vpath->vp_config)->fifo.enable == 1U) {
    
#line 4171 
    vpath->max_nofl_db = vpath->max_kdfc_db;
    
#line 4173 
    if ((unsigned long)vpath->max_nofl_db < ((unsigned long)(vpath->vp_config)->fifo.memblock_size / ((unsigned long)(vpath->vp_config)->fifo.max_frags * 32UL)) * (unsigned long)(vpath->vp_config)->fifo.fifo_blocks) {
      
#line 4179 
      __retres = VXGE_HW_BADCFG_FIFO_BLOCKS;
      
#line 4179 
      goto return_label;
    }
    else ;
    
#line 4181 
    val64 = (unsigned long long)(vpath->max_nofl_db * 2U + 4294967295U) << 32;
  }
  else ;
  
#line 4185 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->kdfc_fifo_trpl_partition));
  
#line 4187 
  writeq(72057594037927936UL,(void volatile *)(& vp_reg->kdfc_fifo_trpl_ctrl));
  
#line 4190 
  val64 = (u64)readq((void const volatile *)(& vp_reg->kdfc_trpl_fifo_0_ctrl));
  
#line 4192 
  val64 &= 18445899644501229567ULL;
  
#line 4195 
  val64 |= 282574488338432ULL;
  
#line 4202 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->kdfc_trpl_fifo_0_ctrl));
  
#line 4203 
  writeq(0UL,(void volatile *)(& vp_reg->kdfc_trpl_fifo_0_wb_address));
  
#line 4204 
  ldv_inline_asm();
  
#line 4205 
  vpath_stride = (u64)readq((void const volatile *)(& (hldev->toc_reg)->toc_kdfc_vpath_stride));
  
#line 4207 
  vpath->nofl_db = (struct __vxge_hw_non_offload_db_wrapper *)(hldev->kdfc + (unsigned long long)vp_id * vpath_stride);
  exit: 
#line 4212 
  ;
  
#line 4213 
  __retres = status;
  return_label: 
#line 4213 
                return __retres;
}


#line 4221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_mac_configure(struct __vxge_hw_device *hldev, u32 vp_id)
{
  enum vxge_hw_status __retres;
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  struct vxge_hw_vp_config *vp_config;
  struct vxge_hw_vpath_reg *vp_reg;
  
#line 4228 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 4229 
  vp_reg = vpath->vp_reg;
  
#line 4230 
  vp_config = vpath->vp_config;
  
#line 4232 
  writeq((unsigned long)((unsigned long long)vpath->vsport_number << 56),(void volatile *)(& vp_reg->xmac_vsport_choice));
  
#line 4235 
  if (vp_config->ring.enable == 1U) {
    
#line 4237 
    val64 = (u64)readq((void const volatile *)(& vp_reg->xmac_rpa_vcfg));
    
#line 4239 
    if (vp_config->rpa_strip_vlan_tag != 4294967295U) 
      
#line 4241 
      if (vp_config->rpa_strip_vlan_tag != 0U) 
#line 4242 
                                               val64 |= 1099511627776ULL; else 
                                                                    
#line 4244 
                                                                    val64 &= 18446742974197923839ULL;
    else ;
    
#line 4247 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->xmac_rpa_vcfg));
    
#line 4248 
    val64 = (u64)readq((void const volatile *)(& vp_reg->rxmac_vcfg0));
    
#line 4250 
    if (vp_config->mtu != 4294967295U) {
      
#line 4252 
      val64 &= 13835339530258874367ULL;
      
#line 4253 
      if (vp_config->mtu + 26U < vpath->max_mtu) 
#line 4255 
                                                 val64 = ((unsigned long long)(vp_config->mtu + 26U) << 48) | val64; else 
                                                                    
#line 4259 
                                                                    val64 = ((unsigned long long)vpath->max_mtu << 48) | val64;
    }
    else ;
    
#line 4263 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->rxmac_vcfg0));
    
#line 4265 
    val64 = (u64)readq((void const volatile *)(& vp_reg->rxmac_vcfg1));
    
#line 4267 
    val64 &= 18446744073706340351ULL;
    
#line 4270 
    if ((unsigned int)*((unsigned char *)(& hldev->config) + 12UL) != 0U) 
      
#line 4272 
      val64 |= 2162688ULL; else ;
    
#line 4277 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->rxmac_vcfg1));
  }
  else ;
  
#line 4279 
  __retres = VXGE_HW_OK;
  
#line 4279 
  return __retres;
}


#line 4288  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_tim_configure(struct __vxge_hw_device *hldev, u32 vp_id)
{
  enum vxge_hw_status __retres;
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  struct vxge_hw_vpath_reg *vp_reg;
  struct vxge_hw_vp_config *config;
  
#line 4295 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 4296 
  vp_reg = vpath->vp_reg;
  
#line 4297 
  config = vpath->vp_config;
  
#line 4299 
  writeq(0UL,(void volatile *)(& vp_reg->tim_dest_addr));
  
#line 4300 
  writeq(0UL,(void volatile *)(& vp_reg->tim_vpath_map));
  
#line 4301 
  writeq(0UL,(void volatile *)(& vp_reg->tim_bitmap));
  
#line 4302 
  writeq(0UL,(void volatile *)(& vp_reg->tim_remap));
  
#line 4304 
  if (config->ring.enable == 1U) 
#line 4305 
                                 writeq((unsigned long)((unsigned long long)(vp_id * 4U + 1U) << 56),(void volatile *)(& vp_reg->tim_ring_assn)); else ;
  
#line 4309 
  val64 = (u64)readq((void const volatile *)(& vp_reg->tim_pci_cfg));
  
#line 4310 
  val64 |= 72057594037927936ULL;
  
#line 4311 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_pci_cfg));
  
#line 4313 
  if (config->fifo.enable == 1U) {
    
#line 4315 
    val64 = (u64)readq((void const volatile *)(& vp_reg->tim_cfg1_int_num[0]));
    
#line 4317 
    if (config->tti.btimer_val != 4294967295U) {
      
#line 4318 
      val64 &= 18158513701852807167ULL;
      
#line 4320 
      val64 = ((unsigned long long)config->tti.btimer_val << 32) | val64;
    }
    else ;
    
#line 4324 
    val64 &= 18446744073441116159ULL;
    
#line 4326 
    if (config->tti.timer_ac_en != 4294967295U) 
      
#line 4327 
      if (config->tti.timer_ac_en != 0U) 
#line 4328 
                                         val64 |= 33554432ULL; else 
#line 4330 
                                                                    val64 &= 18446744073675997183ULL;
    else ;
    
#line 4333 
    if (config->tti.timer_ci_en != 4294967295U) 
      
#line 4334 
      if (config->tti.timer_ci_en != 0U) 
#line 4335 
                                         val64 |= 16777216ULL; else 
#line 4337 
                                                                    val64 &= 18446744073692774399ULL;
    else ;
    
#line 4340 
    if (config->tti.urange_a != 4294967295U) {
      
#line 4341 
      val64 &= 18446744073705422847ULL;
      
#line 4342 
      val64 = ((unsigned long long)config->tti.urange_a << 16) | val64;
    }
    else ;
    
#line 4346 
    if (config->tti.urange_b != 4294967295U) {
      
#line 4347 
      val64 &= 18446744073709535487ULL;
      
#line 4348 
      val64 = ((unsigned long long)config->tti.urange_b << 8) | val64;
    }
    else ;
    
#line 4352 
    if (config->tti.urange_c != 4294967295U) {
      
#line 4353 
      val64 &= 18446744073709551552ULL;
      
#line 4354 
      val64 = (unsigned long long)config->tti.urange_c | val64;
    }
    else ;
    
#line 4358 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg1_int_num[0]));
    
#line 4359 
    vpath->tim_tti_cfg1_saved = val64;
    
#line 4361 
    val64 = (u64)readq((void const volatile *)(& vp_reg->tim_cfg2_int_num[0]));
    
#line 4363 
    if (config->tti.uec_a != 4294967295U) {
      
#line 4364 
      val64 &= 281474976710655ULL;
      
#line 4365 
      val64 = ((unsigned long long)config->tti.uec_a << 48) | val64;
    }
    else ;
    
#line 4369 
    if (config->tti.uec_b != 4294967295U) {
      
#line 4370 
      val64 &= 18446462603027808255ULL;
      
#line 4371 
      val64 = ((unsigned long long)config->tti.uec_b << 32) | val64;
    }
    else ;
    
#line 4375 
    if (config->tti.uec_c != 4294967295U) {
      
#line 4376 
      val64 &= 18446744069414649855ULL;
      
#line 4377 
      val64 = ((unsigned long long)config->tti.uec_c << 16) | val64;
    }
    else ;
    
#line 4381 
    if (config->tti.uec_d != 4294967295U) {
      
#line 4382 
      val64 &= 18446744073709486080ULL;
      
#line 4383 
      val64 = (unsigned long long)config->tti.uec_d | val64;
    }
    else ;
    
#line 4387 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg2_int_num[0]));
    
#line 4388 
    val64 = (u64)readq((void const volatile *)(& vp_reg->tim_cfg3_int_num[0]));
    
#line 4390 
    if (config->tti.timer_ri_en != 4294967295U) 
      
#line 4391 
      if (config->tti.timer_ri_en != 0U) 
#line 4392 
                                         val64 |= 9223372036854775808ULL; else 
                                                                    
#line 4394 
                                                                    val64 &= 9223372036854775807ULL;
    else ;
    
#line 4397 
    if (config->tti.rtimer_val != 4294967295U) {
      
#line 4398 
      val64 &= 18158513701852807167ULL;
      
#line 4400 
      val64 = ((unsigned long long)config->tti.rtimer_val << 32) | val64;
    }
    else ;
    
#line 4404 
    if (config->tti.util_sel != 4294967295U) {
      
#line 4405 
      val64 &= 18446744069481693183ULL;
      
#line 4406 
      val64 = ((unsigned long long)vp_id << 26) | val64;
    }
    else ;
    
#line 4409 
    if (config->tti.ltimer_val != 4294967295U) {
      
#line 4410 
      val64 &= 18446744073642442752ULL;
      
#line 4412 
      val64 = (unsigned long long)config->tti.ltimer_val | val64;
    }
    else ;
    
#line 4416 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg3_int_num[0]));
    
#line 4417 
    vpath->tim_tti_cfg3_saved = val64;
  }
  else ;
  
#line 4420 
  if (config->ring.enable == 1U) {
    
#line 4422 
    val64 = (u64)readq((void const volatile *)(& vp_reg->tim_cfg1_int_num[1]));
    
#line 4424 
    if (config->rti.btimer_val != 4294967295U) {
      
#line 4425 
      val64 &= 18158513701852807167ULL;
      
#line 4427 
      val64 = ((unsigned long long)config->rti.btimer_val << 32) | val64;
    }
    else ;
    
#line 4431 
    val64 &= 18446744073441116159ULL;
    
#line 4433 
    if (config->rti.timer_ac_en != 4294967295U) 
      
#line 4434 
      if (config->rti.timer_ac_en != 0U) 
#line 4435 
                                         val64 |= 33554432ULL; else 
#line 4437 
                                                                    val64 &= 18446744073675997183ULL;
    else ;
    
#line 4440 
    if (config->rti.timer_ci_en != 4294967295U) 
      
#line 4441 
      if (config->rti.timer_ci_en != 0U) 
#line 4442 
                                         val64 |= 16777216ULL; else 
#line 4444 
                                                                    val64 &= 18446744073692774399ULL;
    else ;
    
#line 4447 
    if (config->rti.urange_a != 4294967295U) {
      
#line 4448 
      val64 &= 18446744073705422847ULL;
      
#line 4449 
      val64 = ((unsigned long long)config->rti.urange_a << 16) | val64;
    }
    else ;
    
#line 4453 
    if (config->rti.urange_b != 4294967295U) {
      
#line 4454 
      val64 &= 18446744073709535487ULL;
      
#line 4455 
      val64 = ((unsigned long long)config->rti.urange_b << 8) | val64;
    }
    else ;
    
#line 4459 
    if (config->rti.urange_c != 4294967295U) {
      
#line 4460 
      val64 &= 18446744073709551552ULL;
      
#line 4461 
      val64 = (unsigned long long)config->rti.urange_c | val64;
    }
    else ;
    
#line 4465 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg1_int_num[1]));
    
#line 4466 
    vpath->tim_rti_cfg1_saved = val64;
    
#line 4468 
    val64 = (u64)readq((void const volatile *)(& vp_reg->tim_cfg2_int_num[1]));
    
#line 4470 
    if (config->rti.uec_a != 4294967295U) {
      
#line 4471 
      val64 &= 281474976710655ULL;
      
#line 4472 
      val64 = ((unsigned long long)config->rti.uec_a << 48) | val64;
    }
    else ;
    
#line 4476 
    if (config->rti.uec_b != 4294967295U) {
      
#line 4477 
      val64 &= 18446462603027808255ULL;
      
#line 4478 
      val64 = ((unsigned long long)config->rti.uec_b << 32) | val64;
    }
    else ;
    
#line 4482 
    if (config->rti.uec_c != 4294967295U) {
      
#line 4483 
      val64 &= 18446744069414649855ULL;
      
#line 4484 
      val64 = ((unsigned long long)config->rti.uec_c << 16) | val64;
    }
    else ;
    
#line 4488 
    if (config->rti.uec_d != 4294967295U) {
      
#line 4489 
      val64 &= 18446744073709486080ULL;
      
#line 4490 
      val64 = (unsigned long long)config->rti.uec_d | val64;
    }
    else ;
    
#line 4494 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg2_int_num[1]));
    
#line 4495 
    val64 = (u64)readq((void const volatile *)(& vp_reg->tim_cfg3_int_num[1]));
    
#line 4497 
    if (config->rti.timer_ri_en != 4294967295U) 
      
#line 4498 
      if (config->rti.timer_ri_en != 0U) 
#line 4499 
                                         val64 |= 9223372036854775808ULL; else 
                                                                    
#line 4501 
                                                                    val64 &= 9223372036854775807ULL;
    else ;
    
#line 4504 
    if (config->rti.rtimer_val != 4294967295U) {
      
#line 4505 
      val64 &= 18158513701852807167ULL;
      
#line 4507 
      val64 = ((unsigned long long)config->rti.rtimer_val << 32) | val64;
    }
    else ;
    
#line 4511 
    if (config->rti.util_sel != 4294967295U) {
      
#line 4512 
      val64 &= 18446744069481693183ULL;
      
#line 4513 
      val64 = ((unsigned long long)vp_id << 26) | val64;
    }
    else ;
    
#line 4516 
    if (config->rti.ltimer_val != 4294967295U) {
      
#line 4517 
      val64 &= 18446744073642442752ULL;
      
#line 4519 
      val64 = (unsigned long long)config->rti.ltimer_val | val64;
    }
    else ;
    
#line 4523 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg3_int_num[1]));
    
#line 4524 
    vpath->tim_rti_cfg3_saved = val64;
  }
  else ;
  
#line 4527 
  val64 = 0ULL;
  
#line 4528 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg1_int_num[2]));
  
#line 4529 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg2_int_num[2]));
  
#line 4530 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg3_int_num[2]));
  
#line 4531 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg1_int_num[3]));
  
#line 4532 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg2_int_num[3]));
  
#line 4533 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg3_int_num[3]));
  
#line 4535 
  val64 = 644245094400ULL;
  
#line 4536 
  val64 = val64;
  
#line 4537 
  val64 |= 6291456ULL;
  
#line 4538 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_wrkld_clc));
  
#line 4540 
  __retres = VXGE_HW_OK;
  
#line 4540 
  return __retres;
}


#line 4549  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vpath_initialize(struct __vxge_hw_device *hldev, u32 vp_id)
{
  u64 val64;
  u32 val32;
  struct __vxge_hw_virtualpath *vpath;
  struct vxge_hw_vpath_reg *vp_reg;
  
#line 4553 
  enum vxge_hw_status status = 0;
  
#line 4557 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 4559 
  if ((hldev->vpath_assignments & (9223372036854775808ULL >> vp_id)) == 0ULL) {
    
#line 4560 
    status = VXGE_HW_ERR_VPATH_NOT_AVAILABLE;
    
#line 4561 
    goto exit;
  }
  else ;
  
#line 4563 
  vp_reg = vpath->vp_reg;
  
#line 4565 
  status = __vxge_hw_vpath_swapper_set(vpath->vp_reg);
  
#line 4566 
  if (status != VXGE_HW_OK) 
#line 4567 
                            goto exit; else ;
  
#line 4569 
  status = __vxge_hw_vpath_mac_configure(hldev,vp_id);
  
#line 4570 
  if (status != VXGE_HW_OK) 
#line 4571 
                            goto exit; else ;
  
#line 4573 
  status = __vxge_hw_vpath_kdfc_configure(hldev,vp_id);
  
#line 4574 
  if (status != VXGE_HW_OK) 
#line 4575 
                            goto exit; else ;
  
#line 4577 
  status = __vxge_hw_vpath_tim_configure(hldev,vp_id);
  
#line 4578 
  if (status != VXGE_HW_OK) 
#line 4579 
                            goto exit; else ;
  
#line 4581 
  val64 = (u64)readq((void const volatile *)(& vp_reg->rtdma_rd_optimization_ctrl));
  
#line 4584 
  status = __vxge_hw_vpath_pci_read(vpath,1U,120U,& val32);
  
#line 4585 
  if (status == VXGE_HW_OK) {
    
#line 4586 
    val32 = (val32 >> 12) & 7U;
    
#line 4587 
    val64 &= 18446736377128157183ULL;
    
#line 4589 
    val64 = ((unsigned long long)val32 << 40) | val64;
    
#line 4592 
    val64 |= 17592186044416ULL;
  }
  else ;
  
#line 4595 
  val64 &= 18446744073592111103ULL;
  
#line 4596 
  val64 |= 33554432ULL;
  
#line 4600 
  val64 |= 268435456ULL;
  
#line 4601 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->rtdma_rd_optimization_ctrl));
  exit: 
#line 4603 
  ;
  
#line 4604 
  return status;
}


#line 4611  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_vp_terminate(struct __vxge_hw_device *hldev, u32 vp_id)
{
  struct __vxge_hw_virtualpath *vpath;
  
#line 4615 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 4617 
  if (vpath->vp_open == 0U) 
#line 4618 
                            goto exit; else ;
  
#line 4620 
  if (vpath->vp_id <= 15U) {
    
#line 4620 
    (vpath->hldev)->tim_int_mask0[0] &= ~ (8ULL << (vpath->vp_id * 4294967292U + 60U));
    
#line 4620 
    (vpath->hldev)->tim_int_mask0[1] &= ~ (4ULL << (vpath->vp_id * 4294967292U + 60U));
  }
  else {
    
#line 4620 
    (vpath->hldev)->tim_int_mask1[0] = 0U;
    
#line 4620 
    (vpath->hldev)->tim_int_mask1[1] = 0U;
  }
  
#line 4622 
  hldev->stats.hw_dev_info_stats.vpath_info[vpath->vp_id] = (struct vxge_hw_vpath_stats_hw_info *)0;
  
#line 4627 
  ldv_spin_lock_76(& vpath->lock);
  
#line 4628 
  vpath->vp_open = 0U;
  
#line 4629 
  ldv_spin_unlock_77(& vpath->lock);
  
#line 4631 
  vpath->vpmgmt_reg = (struct vxge_hw_vpmgmt_reg *)0;
  
#line 4632 
  vpath->nofl_db = (struct __vxge_hw_non_offload_db_wrapper *)0;
  
#line 4633 
  vpath->max_mtu = 0U;
  
#line 4634 
  vpath->vsport_number = 0U;
  
#line 4635 
  vpath->max_kdfc_db = 0U;
  
#line 4636 
  vpath->max_nofl_db = 0U;
  
#line 4637 
  vpath->ringh = (struct __vxge_hw_ring *)0;
  
#line 4638 
  vpath->fifoh = (struct __vxge_hw_fifo *)0;
  
#line 4639 
  memset((void *)(& vpath->vpath_handles),0,16UL);
  
#line 4640 
  vpath->stats_block = (struct __vxge_hw_blockpool_entry *)0;
  
#line 4641 
  vpath->hw_stats = (struct vxge_hw_vpath_stats_hw_info *)0;
  
#line 4642 
  vpath->hw_stats_sav = (struct vxge_hw_vpath_stats_hw_info *)0;
  
#line 4643 
  vpath->sw_stats = (struct vxge_hw_vpath_stats_sw_info *)0;
  exit: 
#line 4645 
  ;
  
#line 4646 
  return;
}


#line 4655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status __vxge_hw_vp_initialize(struct __vxge_hw_device *hldev, u32 vp_id, struct vxge_hw_vp_config *config)
{
  struct __vxge_hw_virtualpath *vpath;
  
#line 4659 
  enum vxge_hw_status status = 0;
  
#line 4661 
  if ((hldev->vpath_assignments & (9223372036854775808ULL >> vp_id)) == 0ULL) {
    
#line 4662 
    status = VXGE_HW_ERR_VPATH_NOT_AVAILABLE;
    
#line 4663 
    goto exit;
  }
  else ;
  
#line 4666 
  vpath = & hldev->virtual_paths[vp_id];
  
#line 4668 
  spinlock_check(& vpath->lock);
  {
    struct lock_class_key __key;
    
#line 4668 
    __raw_spin_lock_init(& vpath->lock.__anonCompField_spinlock_18.rlock,"&(&vpath->lock)->rlock",& __key);
  }
  
#line 4669 
  vpath->vp_id = vp_id;
  
#line 4670 
  vpath->vp_open = 1U;
  
#line 4671 
  vpath->hldev = hldev;
  
#line 4672 
  vpath->vp_config = config;
  
#line 4673 
  vpath->vp_reg = hldev->vpath_reg[vp_id];
  
#line 4674 
  vpath->vpmgmt_reg = hldev->vpmgmt_reg[vp_id];
  
#line 4676 
  __vxge_hw_vpath_reset(hldev,vp_id);
  
#line 4678 
  status = __vxge_hw_vpath_reset_check(vpath);
  
#line 4679 
  if (status != VXGE_HW_OK) {
    
#line 4680 
    memset((void *)vpath,0,320UL);
    
#line 4681 
    goto exit;
  }
  else ;
  
#line 4684 
  status = __vxge_hw_vpath_mgmt_read(hldev,vpath);
  
#line 4685 
  if (status != VXGE_HW_OK) {
    
#line 4686 
    memset((void *)vpath,0,320UL);
    
#line 4687 
    goto exit;
  }
  else ;
  
#line 4690 
  INIT_LIST_HEAD(& vpath->vpath_handles);
  
#line 4692 
  vpath->sw_stats = & hldev->stats.sw_dev_info_stats.vpath_info[vp_id];
  
#line 4694 
  if (vp_id <= 15U) {
    
#line 4694 
    hldev->tim_int_mask0[0] |= 8ULL << (vp_id * 4294967292U + 60U);
    
#line 4694 
    hldev->tim_int_mask0[1] |= 4ULL << (vp_id * 4294967292U + 60U);
  }
  else {
    
#line 4694 
    hldev->tim_int_mask1[0] = 2147483648U;
    
#line 4694 
    hldev->tim_int_mask1[1] = 1073741824U;
  }
  
#line 4697 
  status = __vxge_hw_vpath_initialize(hldev,vp_id);
  
#line 4698 
  if (status != VXGE_HW_OK) 
#line 4699 
                            __vxge_hw_vp_terminate(hldev,vp_id); else ;
  exit: 
#line 4700 
  ;
  
#line 4701 
  return status;
}


#line 4710  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_mtu_set(struct __vxge_hw_vpath_handle *vp, u32 new_mtu)
{
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  
#line 4713 
  enum vxge_hw_status status = 0;
  
#line 4716 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 4717 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 4718 
    goto exit;
  }
  else ;
  
#line 4720 
  vpath = vp->vpath;
  
#line 4722 
  new_mtu += 26U;
  
#line 4724 
  if (new_mtu <= 67U || vpath->max_mtu < new_mtu) 
#line 4725 
                                                  status = VXGE_HW_ERR_INVALID_MTU_SIZE; else ;
  
#line 4727 
  val64 = (u64)readq((void const volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  
#line 4729 
  val64 &= 13835339530258874367ULL;
  
#line 4730 
  val64 = ((unsigned long long)new_mtu << 48) | val64;
  
#line 4732 
  writeq((unsigned long)val64,(void volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  
#line 4734 
  (vpath->vp_config)->mtu = new_mtu + 4294967270U;
  exit: 
#line 4736 
  ;
  
#line 4737 
  return status;
}


#line 4746  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static enum vxge_hw_status vxge_hw_vpath_stats_enable(struct __vxge_hw_vpath_handle *vp)
{
  struct __vxge_hw_virtualpath *vpath;
  
#line 4748 
  enum vxge_hw_status status = 0;
  
#line 4751 
  vpath = vp->vpath;
  
#line 4753 
  if (vpath->vp_open == 0U) {
    
#line 4754 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 4755 
    goto exit;
  }
  else ;
  
#line 4758 
  memcpy((void *)vpath->hw_stats_sav,(void const *)vpath->hw_stats,624UL);
  
#line 4761 
  status = __vxge_hw_vpath_stats_get(vpath,vpath->hw_stats);
  exit: 
#line 4762 
  ;
  
#line 4763 
  return status;
}


#line 4771  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static struct __vxge_hw_blockpool_entry *__vxge_hw_blockpool_block_allocate(struct __vxge_hw_device *devh, u32 size)
{
  struct __vxge_hw_blockpool *blockpool;
  
#line 4773 
  struct __vxge_hw_blockpool_entry *entry = (struct __vxge_hw_blockpool_entry *)0;
  
#line 4776 
  blockpool = & devh->block_pool;
  
#line 4778 
  if (blockpool->block_size == size) {
    int tmp_0;
    
#line 4780 
    tmp_0 = list_empty((struct list_head const *)(& blockpool->free_block_list));
    
#line 4780 
    if (tmp_0 == 0) {
      struct __vxge_hw_blockpool_entry *tmp;
      {
        
#line 4782 
        struct list_head const *__mptr = (struct list_head const *)blockpool->free_block_list.next;
        
#line 4782 
        tmp = (struct __vxge_hw_blockpool_entry *)__mptr;
      }
      
#line 4781 
      entry = tmp;
    }
    else ;
    
#line 4786 
    if (entry != (struct __vxge_hw_blockpool_entry *)0) {
      
#line 4787 
      list_del(& entry->item);
      
#line 4788 
      blockpool->pool_size -= 1U;
    }
    else ;
  }
  else ;
  
#line 4792 
  if (entry != (struct __vxge_hw_blockpool_entry *)0) 
#line 4793 
                                                      __vxge_hw_blockpool_blocks_add(blockpool); else ;
  
#line 4795 
  return entry;
}


#line 4805  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_open(struct __vxge_hw_device *hldev, struct vxge_hw_vpath_attr *attr, struct __vxge_hw_vpath_handle **vpath_handle)
{
  enum vxge_hw_status __retres;
  struct __vxge_hw_virtualpath *vpath;
  struct __vxge_hw_vpath_handle *vp;
  enum vxge_hw_status status;
  
#line 4813 
  vpath = & hldev->virtual_paths[attr->vp_id];
  
#line 4815 
  if (vpath->vp_open == 1U) {
    
#line 4816 
    status = VXGE_HW_ERR_INVALID_STATE;
    
#line 4817 
    goto vpath_open_exit1;
  }
  else ;
  
#line 4820 
  status = __vxge_hw_vp_initialize(hldev,attr->vp_id,& hldev->config.vp_config[attr->vp_id]);
  
#line 4822 
  if (status != VXGE_HW_OK) 
#line 4823 
                            goto vpath_open_exit1; else ;
  
#line 4825 
  vp = (struct __vxge_hw_vpath_handle *)vzalloc(24UL);
  
#line 4826 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 4827 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 4828 
    goto vpath_open_exit2;
  }
  else ;
  
#line 4831 
  vp->vpath = vpath;
  
#line 4833 
  if ((vpath->vp_config)->fifo.enable == 1U) {
    
#line 4834 
    status = __vxge_hw_fifo_create(vp,& attr->fifo_attr);
    
#line 4835 
    if (status != VXGE_HW_OK) 
#line 4836 
                              goto vpath_open_exit6; else ;
  }
  else ;
  
#line 4839 
  if ((vpath->vp_config)->ring.enable == 1U) {
    
#line 4840 
    status = __vxge_hw_ring_create(vp,& attr->ring_attr);
    
#line 4841 
    if (status != VXGE_HW_OK) 
#line 4842 
                              goto vpath_open_exit7; else ;
    
#line 4844 
    __vxge_hw_vpath_prc_configure(hldev,attr->vp_id);
  }
  else ;
  
#line 4847 
  (vpath->fifoh)->tx_intr_num = attr->vp_id * 4U;
  
#line 4851 
  vpath->stats_block = __vxge_hw_blockpool_block_allocate(hldev,4096U);
  
#line 4853 
  if (vpath->stats_block == (struct __vxge_hw_blockpool_entry *)0) {
    
#line 4854 
    status = VXGE_HW_ERR_OUT_OF_MEMORY;
    
#line 4855 
    goto vpath_open_exit8;
  }
  else ;
  
#line 4858 
  vpath->hw_stats = (struct vxge_hw_vpath_stats_hw_info *)(vpath->stats_block)->memblock;
  
#line 4859 
  memset((void *)vpath->hw_stats,0,624UL);
  
#line 4862 
  hldev->stats.hw_dev_info_stats.vpath_info[attr->vp_id] = vpath->hw_stats;
  
#line 4865 
  vpath->hw_stats_sav = & hldev->stats.hw_dev_info_stats.vpath_info_sav[attr->vp_id];
  
#line 4867 
  memset((void *)vpath->hw_stats_sav,0,624UL);
  
#line 4870 
  writeq((unsigned long)(vpath->stats_block)->dma_addr,(void volatile *)(& (vpath->vp_reg)->stats_cfg));
  
#line 4872 
  status = vxge_hw_vpath_stats_enable(vp);
  
#line 4873 
  if (status != VXGE_HW_OK) 
#line 4874 
                            goto vpath_open_exit8; else ;
  
#line 4876 
  list_add(& vp->item,& vpath->vpath_handles);
  
#line 4878 
  hldev->vpaths_deployed |= 9223372036854775808ULL >> vpath->vp_id;
  
#line 4880 
  *vpath_handle = vp;
  
#line 4882 
  attr->fifo_attr.userdata = (void *)vpath->fifoh;
  
#line 4883 
  attr->ring_attr.userdata = (void *)vpath->ringh;
  
#line 4885 
  __retres = VXGE_HW_OK;
  
#line 4885 
  goto return_label;
  vpath_open_exit8: 
#line 4887 
  ;
  
#line 4888 
  if (vpath->ringh != (struct __vxge_hw_ring *)0) 
#line 4889 
                                                  __vxge_hw_ring_delete(vp); else ;
  vpath_open_exit7: 
#line 4890 
  ;
  
#line 4891 
  if (vpath->fifoh != (struct __vxge_hw_fifo *)0) 
#line 4892 
                                                  __vxge_hw_fifo_delete(vp); else ;
  vpath_open_exit6: 
#line 4893 
  ;
  
#line 4894 
  vfree((void const *)vp);
  vpath_open_exit2: 
#line 4895 
  ;
  
#line 4896 
  __vxge_hw_vp_terminate(hldev,attr->vp_id);
  vpath_open_exit1: 
#line 4897 
  ;
  
#line 4899 
  __retres = status;
  return_label: 
#line 4899 
                return __retres;
}


#line 4910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
void vxge_hw_vpath_rx_doorbell_init(struct __vxge_hw_vpath_handle *vp)
{
  u64 new_count;
  u64 val64;
  u64 val164;
  u64 tmp_3;
  u64 tmp_5;
  
#line 4912 
  struct __vxge_hw_virtualpath *vpath = vp->vpath;
  
#line 4913 
  struct __vxge_hw_ring *ring = vpath->ringh;
  
#line 4914 
  struct vxgedev *vdev = netdev_priv((struct net_device const *)(vpath->hldev)->ndev);
  
#line 4917 
  if ((unsigned int)*((unsigned char *)vdev + 1466UL) != 0U) {
    
#line 4918 
    new_count = (u64)readq((void const volatile *)(& (vpath->vp_reg)->rxdmem_size));
    
#line 4919 
    new_count &= 8191ULL;
  }
  else 
#line 4921 
       new_count = (unsigned long long)(((ring->config)->ring_blocks * 4096U) / 8U);
  
#line 4923 
  val164 = new_count;
  
#line 4925 
  writeq((unsigned long)val164,(void volatile *)(& (vpath->vp_reg)->prc_rxd_doorbell));
  
#line 4927 
  readl((void const volatile *)(& (vpath->vp_reg)->prc_rxd_doorbell));
  
#line 4929 
  val164 /= 2ULL;
  
#line 4930 
  val64 = (u64)readq((void const volatile *)(& (vpath->vp_reg)->prc_cfg6));
  
#line 4931 
  val64 <<= 19;
  
#line 4932 
  val64 &= 511ULL;
  
#line 4937 
  new_count = (new_count - val64) - 1ULL;
  {
    u64 tmp_2;
    
#line 4938 
    u64 _min1 = val164;
    
#line 4938 
    u64 _min2 = new_count;
    
#line 4938 
    if (_min1 < _min2) 
#line 4938 
                       tmp_2 = _min1; else 
#line 4938 
                                           tmp_2 = _min2;
    
#line 4938 
    tmp_3 = tmp_2;
  }
  
#line 4938 
  val64 = tmp_3 / 4ULL;
  {
    u64 tmp_4;
    
#line 4940 
    u64 _min1_0 = ring->rxds_limit;
    
#line 4940 
    u64 _min2_0 = val64;
    
#line 4940 
    if (_min1_0 < _min2_0) 
#line 4940 
                           tmp_4 = _min1_0; else 
#line 4940 
                                                 tmp_4 = _min2_0;
    
#line 4940 
    tmp_5 = tmp_4;
  }
  
#line 4940 
  ring->rxds_limit = tmp_5;
  
#line 4941 
  if (ring->rxds_limit <= 3ULL) 
#line 4942 
                                ring->rxds_limit = 4ULL; else ;
  
#line 4943 
  return;
}


#line 4953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
static void __vxge_hw_blockpool_block_free(struct __vxge_hw_device *devh, struct __vxge_hw_blockpool_entry *entry)
{
  struct __vxge_hw_blockpool *blockpool;
  
#line 4958 
  blockpool = & devh->block_pool;
  
#line 4960 
  if (entry->length == blockpool->block_size) {
    
#line 4961 
    list_add(& entry->item,& blockpool->free_block_list);
    
#line 4962 
    blockpool->pool_size += 1U;
  }
  else ;
  
#line 4965 
  __vxge_hw_blockpool_blocks_remove(blockpool);
  
#line 4966 
  return;
}


#line 4973  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_close(struct __vxge_hw_vpath_handle *vp)
{
  int tmp;
  
#line 4975 
  struct __vxge_hw_virtualpath *vpath = (struct __vxge_hw_virtualpath *)0;
  
#line 4976 
  struct __vxge_hw_device *devh = (struct __vxge_hw_device *)0;
  
#line 4977 
  u32 vp_id = (vp->vpath)->vp_id;
  
#line 4978 
  u32 is_empty = 1U;
  
#line 4979 
  enum vxge_hw_status status = 0;
  
#line 4981 
  vpath = vp->vpath;
  
#line 4982 
  devh = vpath->hldev;
  
#line 4984 
  if (vpath->vp_open == 0U) {
    
#line 4985 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 4986 
    goto vpath_close_exit;
  }
  else ;
  
#line 4989 
  list_del(& vp->item);
  
#line 4991 
  tmp = list_empty((struct list_head const *)(& vpath->vpath_handles));
  
#line 4991 
  if (tmp == 0) {
    
#line 4992 
    list_add(& vp->item,& vpath->vpath_handles);
    
#line 4993 
    is_empty = 0U;
  }
  else ;
  
#line 4996 
  if (is_empty == 0U) {
    
#line 4997 
    status = VXGE_HW_FAIL;
    
#line 4998 
    goto vpath_close_exit;
  }
  else ;
  
#line 5001 
  devh->vpaths_deployed &= ~ (9223372036854775808ULL >> vp_id);
  
#line 5003 
  if (vpath->ringh != (struct __vxge_hw_ring *)0) 
#line 5004 
                                                  __vxge_hw_ring_delete(vp); else ;
  
#line 5006 
  if (vpath->fifoh != (struct __vxge_hw_fifo *)0) 
#line 5007 
                                                  __vxge_hw_fifo_delete(vp); else ;
  
#line 5009 
  if (vpath->stats_block != (struct __vxge_hw_blockpool_entry *)0) 
#line 5010 
                                                                   __vxge_hw_blockpool_block_free(devh,vpath->stats_block); else ;
  
#line 5012 
  vfree((void const *)vp);
  
#line 5014 
  __vxge_hw_vp_terminate(devh,vp_id);
  vpath_close_exit: 
#line 5016 
  ;
  
#line 5017 
  return status;
}


#line 5024  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_reset(struct __vxge_hw_vpath_handle *vp)
{
  enum vxge_hw_status status;
  u32 vp_id;
  
#line 5028 
  struct __vxge_hw_virtualpath *vpath = vp->vpath;
  
#line 5030 
  vp_id = vpath->vp_id;
  
#line 5032 
  if (vpath->vp_open == 0U) {
    
#line 5033 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 5034 
    goto exit;
  }
  else ;
  
#line 5037 
  status = __vxge_hw_vpath_reset(vpath->hldev,vp_id);
  
#line 5038 
  if (status == VXGE_HW_OK) 
#line 5039 
                            (vpath->sw_stats)->soft_reset_cnt += 1U; else ;
  exit: 
#line 5040 
  ;
  
#line 5041 
  return status;
}


#line 5050  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
enum vxge_hw_status vxge_hw_vpath_recover_from_reset(struct __vxge_hw_vpath_handle *vp)
{
  enum vxge_hw_status status;
  struct __vxge_hw_device *hldev;
  u32 vp_id;
  
#line 5052 
  struct __vxge_hw_virtualpath *vpath = (struct __vxge_hw_virtualpath *)0;
  
#line 5057 
  vp_id = (vp->vpath)->vp_id;
  
#line 5058 
  vpath = vp->vpath;
  
#line 5059 
  hldev = vpath->hldev;
  
#line 5061 
  if (vpath->vp_open == 0U) {
    
#line 5062 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 5063 
    goto exit;
  }
  else ;
  
#line 5066 
  status = __vxge_hw_vpath_reset_check(vpath);
  
#line 5067 
  if (status != VXGE_HW_OK) 
#line 5068 
                            goto exit; else ;
  
#line 5070 
  status = __vxge_hw_vpath_sw_reset(hldev,vp_id);
  
#line 5071 
  if (status != VXGE_HW_OK) 
#line 5072 
                            goto exit; else ;
  
#line 5074 
  status = __vxge_hw_vpath_initialize(hldev,vp_id);
  
#line 5075 
  if (status != VXGE_HW_OK) 
#line 5076 
                            goto exit; else ;
  
#line 5078 
  if (vpath->ringh != (struct __vxge_hw_ring *)0) 
#line 5079 
                                                  __vxge_hw_vpath_prc_configure(hldev,vp_id); else ;
  
#line 5081 
  memset((void *)vpath->hw_stats,0,624UL);
  
#line 5084 
  memset((void *)vpath->hw_stats_sav,0,624UL);
  
#line 5087 
  writeq((unsigned long)(vpath->stats_block)->dma_addr,(void volatile *)(& (vpath->vp_reg)->stats_cfg));
  
#line 5090 
  status = vxge_hw_vpath_stats_enable(vp);
  exit: 
#line 5092 
  ;
  
#line 5093 
  return status;
}


#line 5102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-config.c"
void vxge_hw_vpath_enable(struct __vxge_hw_vpath_handle *vp)
{
  struct __vxge_hw_device *hldev;
  u64 val64;
  
#line 5107 
  hldev = (vp->vpath)->hldev;
  
#line 5109 
  val64 = (unsigned long long)(1 << (16U - (vp->vpath)->vp_id)) << 47;
  
#line 5112 
  __vxge_hw_pio_mem_write32_upper((unsigned int)(val64 >> 32),(void *)(& (hldev->common_reg)->cmn_rsthdlr_cfg1));
  
#line 5114 
  return;
}


#line 402  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-config.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 405 
  tmp = ldv_kmalloc(size,flags);
  
#line 405 
  return tmp;
}


#line 423  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-config.c.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 426 
  tmp = ldv_kzalloc(size,flags);
  
#line 426 
  return tmp;
}


#line 748  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-config.c.aux"
static void ldv_spin_lock_73(spinlock_t *lock)
{
  
#line 752 
  ldv_spin_model_lock((char *)"lock_of___vxge_hw_virtualpath");
  
#line 754 
  spin_lock(lock);
  
#line 755 
  return;
}


#line 758  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-config.c.aux"
static void ldv_spin_unlock_74(spinlock_t *lock)
{
  
#line 762 
  ldv_spin_model_unlock((char *)"lock_of___vxge_hw_virtualpath");
  
#line 764 
  spin_unlock_0(lock);
  
#line 765 
  return;
}


#line 768  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-config.c.aux"
static void ldv_spin_unlock_75(spinlock_t *lock)
{
  
#line 772 
  ldv_spin_model_unlock((char *)"lock_of___vxge_hw_virtualpath");
  
#line 774 
  spin_unlock_0(lock);
  
#line 775 
  return;
}


#line 778  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-config.c.aux"
static void ldv_spin_lock_76(spinlock_t *lock)
{
  
#line 782 
  ldv_spin_model_lock((char *)"lock_of___vxge_hw_virtualpath");
  
#line 784 
  spin_lock(lock);
  
#line 785 
  return;
}


#line 788  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/weaver/.tmp_vxge-config.c.aux"
static void ldv_spin_unlock_77(spinlock_t *lock)
{
  
#line 792 
  ldv_spin_model_unlock((char *)"lock_of___vxge_hw_virtualpath");
  
#line 794 
  spin_unlock_0(lock);
  
#line 795 
  return;
}


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_intr_enable(struct __vxge_hw_vpath_handle *vp)
{
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  struct vxge_hw_vpath_reg *vp_reg;
  
#line 36 
  enum vxge_hw_status status = 0;
  
#line 37 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 38 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 39 
    goto exit;
  }
  else ;
  
#line 42 
  vpath = vp->vpath;
  
#line 44 
  if (vpath->vp_open == 0U) {
    
#line 45 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 46 
    goto exit;
  }
  else ;
  
#line 49 
  vp_reg = vpath->vp_reg;
  
#line 51 
  writeq(18446744073709551615UL,(void volatile *)(& vp_reg->kdfcctl_errors_reg));
  
#line 53 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->general_errors_reg));
  
#line 56 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->pci_config_errors_reg));
  
#line 59 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->mrpcim_to_vpath_alarm_reg));
  
#line 62 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->srpcim_to_vpath_alarm_reg));
  
#line 65 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->vpath_ppif_int_status));
  
#line 68 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->srpcim_msg_to_vpath_reg));
  
#line 71 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->vpath_pcipif_int_status));
  
#line 74 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->prc_alarm_reg));
  
#line 77 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->wrdma_alarm_status));
  
#line 80 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->asic_ntwk_vp_err_reg));
  
#line 83 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->xgmac_vp_int_status));
  
#line 86 
  val64 = (u64)readq((void const volatile *)(& vp_reg->vpath_general_int_status));
  
#line 90 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->vpath_pcipif_int_mask));
  
#line 93 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->srpcim_msg_to_vpath_mask));
  
#line 96 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->srpcim_to_vpath_alarm_mask));
  
#line 99 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->mrpcim_to_vpath_alarm_mask));
  
#line 102 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->pci_config_errors_mask));
  
#line 107 
  writeq(17895424UL,(void volatile *)(& vp_reg->general_errors_mask));
  
#line 113 
  __vxge_hw_pio_mem_write32_upper(17830144U,(void *)(& vp_reg->kdfcctl_errors_mask));
  
#line 122 
  __vxge_hw_pio_mem_write32_upper(0U,(void *)(& vp_reg->vpath_ppif_int_mask));
  
#line 124 
  __vxge_hw_pio_mem_write32_upper(2147483648U,(void *)(& vp_reg->prc_alarm_mask));
  
#line 128 
  __vxge_hw_pio_mem_write32_upper(0U,(void *)(& vp_reg->wrdma_alarm_mask));
  
#line 129 
  __vxge_hw_pio_mem_write32_upper(0U,(void *)(& vp_reg->xgmac_vp_int_mask));
  
#line 131 
  if ((vpath->hldev)->first_vp_id != vpath->vp_id) 
#line 132 
                                                   __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->asic_ntwk_vp_err_mask)); else 
                                                                    
#line 135 
                                                                    __vxge_hw_pio_mem_write32_upper(4352U,(void *)(& vp_reg->asic_ntwk_vp_err_mask));
  
#line 140 
  __vxge_hw_pio_mem_write32_upper(0U,(void *)(& vp_reg->vpath_general_int_mask));
  exit: 
#line 142 
  ;
  
#line 143 
  return status;
}


#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_intr_disable(struct __vxge_hw_vpath_handle *vp)
{
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  struct vxge_hw_vpath_reg *vp_reg;
  
#line 162 
  enum vxge_hw_status status = 0;
  
#line 164 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 165 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 166 
    goto exit;
  }
  else ;
  
#line 169 
  vpath = vp->vpath;
  
#line 171 
  if (vpath->vp_open == 0U) {
    
#line 172 
    status = VXGE_HW_ERR_VPATH_NOT_OPEN;
    
#line 173 
    goto exit;
  }
  else ;
  
#line 175 
  vp_reg = vpath->vp_reg;
  
#line 177 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->vpath_general_int_mask));
  
#line 181 
  val64 = 9223372036854775808ULL >> (1 << (16U - vpath->vp_id));
  
#line 183 
  writeq(18446744073709551615UL,(void volatile *)(& vp_reg->kdfcctl_errors_mask));
  
#line 185 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->general_errors_mask));
  
#line 188 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->pci_config_errors_mask));
  
#line 191 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->mrpcim_to_vpath_alarm_mask));
  
#line 194 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->srpcim_to_vpath_alarm_mask));
  
#line 197 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->vpath_ppif_int_mask));
  
#line 200 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->srpcim_msg_to_vpath_mask));
  
#line 203 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->vpath_pcipif_int_mask));
  
#line 206 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->wrdma_alarm_mask));
  
#line 209 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->prc_alarm_mask));
  
#line 212 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->xgmac_vp_int_mask));
  
#line 215 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& vp_reg->asic_ntwk_vp_err_mask));
  exit: 
#line 218 
  ;
  
#line 219 
  return status;
}


#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_tti_ci_set(struct __vxge_hw_fifo *fifo)
{
  struct vxge_hw_vpath_reg *vp_reg;
  struct vxge_hw_vp_config *config;
  u64 val64;
  struct vxge_hw_vp_config *tmp;
  
#line 228 
  if ((fifo->config)->enable != 1U) 
#line 229 
                                    goto return_label; else ;
  
#line 231 
  vp_reg = fifo->vp_reg;
  {
    
#line 232 
    struct vxge_hw_fifo_config const *__mptr = (struct vxge_hw_fifo_config const *)fifo->config;
    
#line 232 
    tmp = (struct vxge_hw_vp_config *)__mptr + 18446744073709551584U;
  }
  
#line 232 
  config = tmp;
  
#line 234 
  if (config->tti.timer_ci_en != 1U) {
    
#line 235 
    config->tti.timer_ci_en = 1U;
    
#line 236 
    val64 = (u64)readq((void const volatile *)(& vp_reg->tim_cfg1_int_num[0]));
    
#line 237 
    val64 |= 16777216ULL;
    
#line 238 
    fifo->tim_tti_cfg1_saved = val64;
    
#line 239 
    writeq((unsigned long)val64,(void volatile *)(& vp_reg->tim_cfg1_int_num[0]));
  }
  else ;
  return_label: 
#line 241 
                return;
}


#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_dynamic_rti_ci_set(struct __vxge_hw_ring *ring)
{
  
#line 245 
  u64 val64 = ring->tim_rti_cfg1_saved;
  
#line 247 
  val64 |= 16777216ULL;
  
#line 248 
  ring->tim_rti_cfg1_saved = val64;
  
#line 249 
  writeq((unsigned long)val64,(void volatile *)(& (ring->vp_reg)->tim_cfg1_int_num[1]));
  
#line 250 
  return;
}


#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_dynamic_tti_rtimer_set(struct __vxge_hw_fifo *fifo)
{
  
#line 254 
  u64 val64 = fifo->tim_tti_cfg3_saved;
  
#line 255 
  u64 timer = (unsigned long long)((fifo->rtimer * 1000U) / 272U);
  
#line 257 
  val64 &= 18158513701852807167ULL;
  
#line 258 
  if (timer != 0ULL) 
#line 259 
                     val64 = ((timer << 32) | val64) | 2882303761517117440ULL; else ;
  
#line 262 
  writeq((unsigned long)val64,(void volatile *)(& (fifo->vp_reg)->tim_cfg3_int_num[0]));
  
#line 263 
  return;
}


#line 268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_dynamic_rti_rtimer_set(struct __vxge_hw_ring *ring)
{
  
#line 270 
  u64 val64 = ring->tim_rti_cfg3_saved;
  
#line 271 
  u64 timer = (unsigned long long)((ring->rtimer * 1000U) / 272U);
  
#line 273 
  val64 &= 18158513701852807167ULL;
  
#line 274 
  if (timer != 0ULL) 
#line 275 
                     val64 = ((timer << 32) | val64) | 2305843009213693952ULL; else ;
  
#line 278 
  writeq((unsigned long)val64,(void volatile *)(& (ring->vp_reg)->tim_cfg3_int_num[1]));
  
#line 279 
  return;
}


#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_channel_msix_mask(struct __vxge_hw_channel *channel, int msix_id)
{
  
#line 296 
  __vxge_hw_pio_mem_write32_upper((unsigned int)((9223372036854775808ULL >> (msix_id >> 2)) >> 32),(void *)(& (channel->common_reg)->set_msix_mask_vect[msix_id % 4]));
  
#line 299 
  return;
}


#line 311  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_channel_msix_unmask(struct __vxge_hw_channel *channel, int msix_id)
{
  
#line 314 
  __vxge_hw_pio_mem_write32_upper((unsigned int)((9223372036854775808ULL >> (msix_id >> 2)) >> 32),(void *)(& (channel->common_reg)->clear_msix_mask_vect[msix_id % 4]));
  
#line 317 
  return;
}


#line 329  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_channel_msix_clear(struct __vxge_hw_channel *channel, int msix_id)
{
  
#line 331 
  __vxge_hw_pio_mem_write32_upper((unsigned int)((9223372036854775808ULL >> (msix_id >> 2)) >> 32),(void *)(& (channel->common_reg)->clr_msix_one_shot_vec[msix_id % 4]));
  
#line 334 
  return;
}


#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
u32 vxge_hw_device_set_intr_type(struct __vxge_hw_device *hldev, u32 intr_mode)
{
  
#line 345 
  if (intr_mode > 2U) 
#line 349 
                      intr_mode = 0U; else ;
  
#line 351 
  hldev->config.intr_mode = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))intr_mode;
  
#line 352 
  return intr_mode;
}


#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_device_intr_enable(struct __vxge_hw_device *hldev)
{
  u32 i;
  u64 val64;
  u32 val32;
  
#line 372 
  vxge_hw_device_mask_all(hldev);
  
#line 374 
  i = 0U;
  
#line 374 
  goto ldv_46501;
  ldv_46500: 
#line 375 
  ;
  
#line 376 
  if ((hldev->vpaths_deployed & (9223372036854775808ULL >> i)) == 0ULL) 
    
#line 377 
    goto ldv_46499; else ;
  
#line 379 
  vxge_hw_vpath_intr_enable((struct __vxge_hw_vpath_handle *)hldev->virtual_paths[i].vpath_handles.next);
  ldv_46499: 
#line 381 
  ;
  
#line 374 
  i += 1U;
  ldv_46501: 
#line 375 
  ;
  
#line 374 
  if (i <= 16U) 
#line 376 
                goto ldv_46500; else 
#line 379 
                                     goto ldv_46502;
  ldv_46502: 
#line 380 
  ;
  
#line 383 
  if ((unsigned int)*((unsigned char *)(& hldev->config) + 12UL) == 0U) {
    
#line 384 
    val64 = hldev->tim_int_mask0[0] | hldev->tim_int_mask0[1];
    
#line 387 
    if (val64 != 0ULL) {
      
#line 388 
      writeq((unsigned long)val64,(void volatile *)(& (hldev->common_reg)->tim_int_status0));
      
#line 390 
      writeq((unsigned long)(~ val64),(void volatile *)(& (hldev->common_reg)->tim_int_mask0));
    }
    else ;
    
#line 393 
    val32 = hldev->tim_int_mask1[0] | hldev->tim_int_mask1[1];
    
#line 396 
    if (val32 != 0U) {
      
#line 397 
      __vxge_hw_pio_mem_write32_upper(val32,(void *)(& (hldev->common_reg)->tim_int_status1));
      
#line 400 
      __vxge_hw_pio_mem_write32_upper(~ val32,(void *)(& (hldev->common_reg)->tim_int_mask1));
    }
    else ;
  }
  else ;
  
#line 405 
  val64 = (u64)readq((void const volatile *)(& (hldev->common_reg)->titan_general_int_status));
  
#line 407 
  vxge_hw_device_unmask_all(hldev);
  
#line 408 
  return;
}


#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_device_intr_disable(struct __vxge_hw_device *hldev)
{
  u32 i;
  
#line 424 
  vxge_hw_device_mask_all(hldev);
  
#line 427 
  writeq(18446744073709551615UL,(void volatile *)(& (hldev->common_reg)->tim_int_mask0));
  
#line 428 
  __vxge_hw_pio_mem_write32_upper(4294967295U,(void *)(& (hldev->common_reg)->tim_int_mask1));
  
#line 431 
  i = 0U;
  
#line 431 
  goto ldv_46509;
  ldv_46508: 
#line 432 
  ;
  
#line 433 
  if ((hldev->vpaths_deployed & (9223372036854775808ULL >> i)) == 0ULL) 
    
#line 434 
    goto ldv_46507; else ;
  
#line 436 
  vxge_hw_vpath_intr_disable((struct __vxge_hw_vpath_handle *)hldev->virtual_paths[i].vpath_handles.next);
  ldv_46507: 
#line 438 
  ;
  
#line 431 
  i += 1U;
  ldv_46509: 
#line 432 
  ;
  
#line 431 
  if (i <= 16U) 
#line 433 
                goto ldv_46508; else 
#line 436 
                                     goto ldv_46510;
  ldv_46510: 
#line 437 
  ;
  
#line 438 
  return;
}


#line 449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_device_mask_all(struct __vxge_hw_device *hldev)
{
  u64 val64;
  
#line 453 
  val64 = 72339069014638592ULL;
  
#line 456 
  __vxge_hw_pio_mem_write32_upper((unsigned int)(val64 >> 32),(void *)(& (hldev->common_reg)->titan_mask_all_int));
  
#line 458 
  return;
}


#line 468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_device_unmask_all(struct __vxge_hw_device *hldev)
{
  
#line 470 
  u64 val64 = 0ULL;
  
#line 472 
  if ((unsigned int)*((unsigned char *)(& hldev->config) + 12UL) == 0U) 
    
#line 473 
    val64 = 281474976710656ULL; else ;
  
#line 475 
  __vxge_hw_pio_mem_write32_upper((unsigned int)(val64 >> 32),(void *)(& (hldev->common_reg)->titan_mask_all_int));
  
#line 477 
  return;
}


#line 487  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_device_flush_io(struct __vxge_hw_device *hldev)
{
  u32 val32;
  
#line 491 
  val32 = readl((void const volatile *)(& (hldev->common_reg)->titan_general_int_status));
  
#line 492 
  return;
}


#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
static enum vxge_hw_status __vxge_hw_device_handle_error(struct __vxge_hw_device *hldev, u32 vp_id, enum vxge_hw_event type)
{
  enum vxge_hw_status __retres;
  
#line 506 
  switch ((unsigned int)type) {
    case (unsigned int)0: 
#line 507 
    ;
    
#line 508 
    goto ldv_46529;
    case (unsigned int)1: 
#line 509 
    ;
    case (unsigned int)2: 
#line 510 
    ;
    case (unsigned int)3: 
#line 511 
    ;
    case (unsigned int)4: 
#line 512 
    ;
    
#line 513 
    goto out;
    case (unsigned int)5: 
#line 514 
    ;
    
#line 515 
    goto out;
    case (unsigned int)6: 
#line 516 
    ;
    case (unsigned int)7: 
#line 517 
    ;
    
#line 518 
    goto out;
    case (unsigned int)8: 
#line 519 
    ;
    case (unsigned int)9: 
#line 520 
    ;
    case (unsigned int)10: 
#line 521 
    ;
    case (unsigned int)11: 
#line 522 
    ;
    
#line 523 
    goto ldv_46529;
    case (unsigned int)12: 
#line 524 
    ;
    case (unsigned int)13: 
#line 525 
    ;
    
#line 526 
    goto out;
    case (unsigned int)14: 
#line 527 
    ;
    
#line 528 
    goto ldv_46529;
    default: 
#line 529 
    ;
    
#line 531 
    goto out;
  }
  ldv_46529: 
#line 535 
  ;
  
#line 535 
  if ((hldev->uld_callbacks)->crit_err != (void (*)(struct __vxge_hw_device *, enum vxge_hw_event , u64 ))0) 
    
#line 536 
    (*((hldev->uld_callbacks)->crit_err))(hldev,type,(unsigned long long)vp_id); else ;
  out: 
#line 538 
  ;
  
#line 540 
  __retres = VXGE_HW_OK;
  
#line 540 
  return __retres;
}


#line 551  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
static enum vxge_hw_status __vxge_hw_device_handle_link_down_ind(struct __vxge_hw_device *hldev)
{
  enum vxge_hw_status __retres;
  
#line 556 
  if (hldev->link_state == (unsigned int)VXGE_HW_LINK_DOWN) 
#line 557 
                                                            goto exit; else ;
  
#line 559 
  hldev->link_state = VXGE_HW_LINK_DOWN;
  
#line 562 
  if ((hldev->uld_callbacks)->link_down != (void (*)(struct __vxge_hw_device *))0) 
    
#line 563 
    (*((hldev->uld_callbacks)->link_down))(hldev); else ;
  exit: 
#line 564 
  ;
  
#line 565 
  __retres = VXGE_HW_OK;
  
#line 565 
  return __retres;
}


#line 576  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
static enum vxge_hw_status __vxge_hw_device_handle_link_up_ind(struct __vxge_hw_device *hldev)
{
  enum vxge_hw_status __retres;
  
#line 581 
  if (hldev->link_state == (unsigned int)VXGE_HW_LINK_UP) 
#line 582 
                                                          goto exit; else ;
  
#line 584 
  hldev->link_state = VXGE_HW_LINK_UP;
  
#line 587 
  if ((hldev->uld_callbacks)->link_up != (void (*)(struct __vxge_hw_device *))0) 
    
#line 588 
    (*((hldev->uld_callbacks)->link_up))(hldev); else ;
  exit: 
#line 589 
  ;
  
#line 590 
  __retres = VXGE_HW_OK;
  
#line 590 
  return __retres;
}


#line 602  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
static enum vxge_hw_status __vxge_hw_vpath_alarm_process(struct __vxge_hw_virtualpath *vpath, u32 skip_alarms)
{
  enum vxge_hw_status __retres;
  u64 val64;
  u64 alarm_status;
  u64 pic_status;
  u64 mask64;
  struct vxge_hw_vpath_stats_sw_info *sw_stats;
  struct vxge_hw_vpath_reg *vp_reg;
  int tmp_26;
  
#line 608 
  struct __vxge_hw_device *hldev = (struct __vxge_hw_device *)0;
  
#line 609 
  enum vxge_hw_event alarm_event = VXGE_HW_EVENT_UNKNOWN;
  
#line 614 
  if (vpath == (struct __vxge_hw_virtualpath *)0) {
    
#line 615 
    alarm_event = alarm_event;
    
#line 617 
    goto out2;
  }
  else ;
  
#line 620 
  hldev = vpath->hldev;
  
#line 621 
  vp_reg = vpath->vp_reg;
  
#line 622 
  alarm_status = (u64)readq((void const volatile *)(& vp_reg->vpath_general_int_status));
  
#line 624 
  if (alarm_status == 18446744073709551615ULL) {
    unsigned int tmp_0;
    
#line 625 
    if (alarm_event > (unsigned int)VXGE_HW_EVENT_MRPCIM_SERR) 
#line 625 
                                                               tmp_0 = (unsigned int)alarm_event; else 
                                                                    
#line 625 
                                                                    tmp_0 = 14U;
    
#line 625 
    alarm_event = (enum vxge_hw_event)tmp_0;
    
#line 627 
    goto out;
  }
  else ;
  
#line 630 
  sw_stats = vpath->sw_stats;
  
#line 632 
  if ((alarm_status & 17221465907902021631ULL) != 0ULL) {
    
#line 637 
    sw_stats->error_stats.unknown_alarms += 1U;
    
#line 639 
    alarm_event = alarm_event;
    
#line 641 
    goto out;
  }
  else ;
  
#line 644 
  if ((alarm_status & 17592186044416ULL) != 0ULL) {
    
#line 646 
    val64 = (u64)readq((void const volatile *)(& vp_reg->xgmac_vp_int_status));
    
#line 648 
    if ((val64 & 1152921504606846976ULL) != 0ULL) {
      unsigned int tmp_5;
      
#line 651 
      val64 = (u64)readq((void const volatile *)(& vp_reg->asic_ntwk_vp_err_reg));
      
#line 653 
      if (((val64 & 1152921504606846976ULL) != 0ULL && (val64 & 72057594037927936ULL) == 0ULL) || ((val64 & 4503599627370496ULL) != 0ULL && (val64 & 281474976710656ULL) == 0ULL)) {
        unsigned int tmp_3;
        
#line 662 
        sw_stats->error_stats.network_sustained_fault += 1U;
        
#line 664 
        writeq(1152921504606846976UL,(void volatile *)(& vp_reg->asic_ntwk_vp_err_mask));
        
#line 668 
        __vxge_hw_device_handle_link_down_ind(hldev);
        
#line 669 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_RESET_COMPLETE) 
          
#line 669 
          tmp_3 = (unsigned int)alarm_event; else 
#line 669 
                                                  tmp_3 = 3U;
        
#line 669 
        alarm_event = (enum vxge_hw_event)tmp_3;
      }
      else ;
      
#line 673 
      if (((val64 & 72057594037927936ULL) != 0ULL && (val64 & 1152921504606846976ULL) == 0ULL) || ((val64 & 281474976710656ULL) != 0ULL && (val64 & 4503599627370496ULL) == 0ULL)) {
        unsigned int tmp_4;
        
#line 683 
        sw_stats->error_stats.network_sustained_ok += 1U;
        
#line 685 
        writeq(72057594037927936UL,(void volatile *)(& vp_reg->asic_ntwk_vp_err_mask));
        
#line 689 
        __vxge_hw_device_handle_link_up_ind(hldev);
        
#line 690 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_LINK_DOWN) 
#line 690 
                                                                 tmp_4 = (unsigned int)alarm_event; else 
                                                                    
#line 690 
                                                                    tmp_4 = 4U;
        
#line 690 
        alarm_event = (enum vxge_hw_event)tmp_4;
      }
      else ;
      
#line 694 
      writeq(18446744073709551615UL,(void volatile *)(& vp_reg->asic_ntwk_vp_err_reg));
      
#line 697 
      if (alarm_event > (unsigned int)VXGE_HW_EVENT_LINK_UP) 
#line 697 
                                                             tmp_5 = (unsigned int)alarm_event; else 
                                                                    
#line 697 
                                                                    tmp_5 = 5U;
      
#line 697 
      alarm_event = (enum vxge_hw_event)tmp_5;
      
#line 700 
      if (skip_alarms != 0U) {
        
#line 701 
        __retres = VXGE_HW_OK;
        
#line 701 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 705 
  if ((alarm_status & 1152921504606846976ULL) != 0ULL) {
    
#line 707 
    pic_status = (u64)readq((void const volatile *)(& vp_reg->vpath_ppif_int_status));
    
#line 709 
    if ((pic_status & 72057594037927936ULL) != 0ULL) {
      
#line 712 
      val64 = (u64)readq((void const volatile *)(& vp_reg->general_errors_reg));
      
#line 713 
      mask64 = (u64)readq((void const volatile *)(& vp_reg->general_errors_mask));
      
#line 715 
      if (((~ mask64 & val64) & 4294967296ULL) != 0ULL) {
        unsigned int tmp_9;
        
#line 718 
        sw_stats->error_stats.ini_serr_det += 1U;
        
#line 720 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_CRITICAL_ERR) 
#line 720 
                                                                    tmp_9 = (unsigned int)alarm_event; else 
                                                                    
#line 720 
                                                                    tmp_9 = 11U;
        
#line 720 
        alarm_event = (enum vxge_hw_event)tmp_9;
      }
      else ;
      
#line 724 
      if (((~ mask64 & val64) & 1152921504606846976ULL) != 0ULL) {
        unsigned int tmp_10;
        
#line 727 
        sw_stats->error_stats.dblgen_fifo0_overflow += 1U;
        
#line 729 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_MRPCIM_ECCERR) 
          
#line 729 
          tmp_10 = (unsigned int)alarm_event; else 
#line 729 
                                                   tmp_10 = 8U;
        
#line 729 
        alarm_event = (enum vxge_hw_event)tmp_10;
      }
      else ;
      
#line 733 
      if (((~ mask64 & val64) & 281474976710656ULL) != 0ULL) 
#line 736 
                                                             sw_stats->error_stats.statsb_pif_chain_error += 1U; else ;
      
#line 738 
      if (((~ mask64 & val64) & 17592186044416ULL) != 0ULL) 
#line 741 
                                                            sw_stats->error_stats.statsb_drop_timeout += 1U; else ;
      
#line 743 
      if (((~ mask64 & val64) & 68719476736ULL) != 0ULL) 
#line 746 
                                                         sw_stats->error_stats.target_illegal_access += 1U; else ;
      
#line 748 
      if (skip_alarms == 0U) {
        unsigned int tmp_11;
        
#line 749 
        writeq(18446744073709551615UL,(void volatile *)(& vp_reg->general_errors_reg));
        
#line 751 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_LINK_UP) 
#line 751 
                                                               tmp_11 = (unsigned int)alarm_event; else 
                                                                    
#line 751 
                                                                    tmp_11 = 5U;
        
#line 751 
        alarm_event = (enum vxge_hw_event)tmp_11;
      }
      else ;
    }
    else ;
    
#line 757 
    if ((pic_status & 1152921504606846976ULL) != 0ULL) {
      
#line 760 
      val64 = (u64)readq((void const volatile *)(& vp_reg->kdfcctl_errors_reg));
      
#line 761 
      mask64 = (u64)readq((void const volatile *)(& vp_reg->kdfcctl_errors_mask));
      
#line 763 
      if (((~ mask64 & val64) & 1152921504606846976ULL) != 0ULL) {
        unsigned int tmp_14;
        
#line 766 
        sw_stats->error_stats.kdfcctl_fifo0_overwrite += 1U;
        
#line 768 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_MRPCIM_ECCERR) 
          
#line 768 
          tmp_14 = (unsigned int)alarm_event; else 
#line 768 
                                                   tmp_14 = 8U;
        
#line 768 
        alarm_event = (enum vxge_hw_event)tmp_14;
      }
      else ;
      
#line 773 
      if (((~ mask64 & val64) & 281474976710656ULL) != 0ULL) {
        unsigned int tmp_15;
        
#line 776 
        sw_stats->error_stats.kdfcctl_fifo0_poison += 1U;
        
#line 778 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_MRPCIM_ECCERR) 
          
#line 778 
          tmp_15 = (unsigned int)alarm_event; else 
#line 778 
                                                   tmp_15 = 8U;
        
#line 778 
        alarm_event = (enum vxge_hw_event)tmp_15;
      }
      else ;
      
#line 783 
      if (((~ mask64 & val64) & 4294967296ULL) != 0ULL) {
        unsigned int tmp_16;
        
#line 786 
        sw_stats->error_stats.kdfcctl_fifo0_dma_error += 1U;
        
#line 788 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_MRPCIM_ECCERR) 
          
#line 788 
          tmp_16 = (unsigned int)alarm_event; else 
#line 788 
                                                   tmp_16 = 8U;
        
#line 788 
        alarm_event = (enum vxge_hw_event)tmp_16;
      }
      else ;
      
#line 793 
      if (skip_alarms == 0U) {
        unsigned int tmp_17;
        
#line 794 
        writeq(18446744073709551615UL,(void volatile *)(& vp_reg->kdfcctl_errors_reg));
        
#line 796 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_LINK_UP) 
#line 796 
                                                               tmp_17 = (unsigned int)alarm_event; else 
                                                                    
#line 796 
                                                                    tmp_17 = 5U;
        
#line 796 
        alarm_event = (enum vxge_hw_event)tmp_17;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 804 
  if ((alarm_status & 281474976710656ULL) != 0ULL) {
    
#line 806 
    val64 = (u64)readq((void const volatile *)(& vp_reg->wrdma_alarm_status));
    
#line 808 
    if ((val64 & 4611686018427387904ULL) != 0ULL) {
      
#line 810 
      val64 = (u64)readq((void const volatile *)(& vp_reg->prc_alarm_reg));
      
#line 811 
      mask64 = (u64)readq((void const volatile *)(& vp_reg->prc_alarm_mask));
      
#line 813 
      if ((~ mask64 & val64) < (unsigned long long)0) 
#line 815 
                                                      sw_stats->error_stats.prc_ring_bumps += 1U; else ;
      
#line 817 
      if (((~ mask64 & val64) & 4611686018427387904ULL) != 0ULL) {
        unsigned int tmp_21;
        
#line 819 
        sw_stats->error_stats.prc_rxdcm_sc_err += 1U;
        
#line 821 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_FIFO_ERR) 
#line 821 
                                                                tmp_21 = (unsigned int)alarm_event; else 
                                                                    
#line 821 
                                                                    tmp_21 = 9U;
        
#line 821 
        alarm_event = (enum vxge_hw_event)tmp_21;
      }
      else ;
      
#line 826 
      if (((~ mask64 & val64) & 2305843009213693952ULL) != 0ULL) {
        unsigned int tmp_22;
        
#line 828 
        sw_stats->error_stats.prc_rxdcm_sc_abort += 1U;
        
#line 830 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_FIFO_ERR) 
#line 830 
                                                                tmp_22 = (unsigned int)alarm_event; else 
                                                                    
#line 830 
                                                                    tmp_22 = 9U;
        
#line 830 
        alarm_event = (enum vxge_hw_event)tmp_22;
      }
      else ;
      
#line 835 
      if (((~ mask64 & val64) & 1152921504606846976ULL) != 0ULL) {
        unsigned int tmp_23;
        
#line 837 
        sw_stats->error_stats.prc_quanta_size_err += 1U;
        
#line 839 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_FIFO_ERR) 
#line 839 
                                                                tmp_23 = (unsigned int)alarm_event; else 
                                                                    
#line 839 
                                                                    tmp_23 = 9U;
        
#line 839 
        alarm_event = (enum vxge_hw_event)tmp_23;
      }
      else ;
      
#line 844 
      if (skip_alarms == 0U) {
        unsigned int tmp_24;
        
#line 845 
        writeq(18446744073709551615UL,(void volatile *)(& vp_reg->prc_alarm_reg));
        
#line 847 
        if (alarm_event > (unsigned int)VXGE_HW_EVENT_LINK_UP) 
#line 847 
                                                               tmp_24 = (unsigned int)alarm_event; else 
                                                                    
#line 847 
                                                                    tmp_24 = 5U;
        
#line 847 
        alarm_event = (enum vxge_hw_event)tmp_24;
      }
      else ;
    }
    else ;
  }
  else ;
  out: 
#line 853 
  ;
  
#line 854 
  hldev->stats.sw_dev_err_stats.vpath_alarms += 1U;
  out2: 
#line 855 
  ;
  
#line 856 
  if (alarm_event == (unsigned int)VXGE_HW_EVENT_ALARM_CLEARED || alarm_event == (unsigned int)VXGE_HW_EVENT_UNKNOWN) {
    
#line 858 
    __retres = VXGE_HW_OK;
    
#line 858 
    goto return_label;
  }
  else ;
  
#line 860 
  __vxge_hw_device_handle_error(hldev,vpath->vp_id,alarm_event);
  
#line 862 
  if (alarm_event == (unsigned int)VXGE_HW_EVENT_SERR) {
    
#line 863 
    __retres = VXGE_HW_ERR_CRITICAL;
    
#line 863 
    goto return_label;
  }
  else ;
  
#line 866 
  if (alarm_event != (unsigned int)VXGE_HW_EVENT_SLOT_FREEZE) {
    int tmp_25;
    
#line 865 
    if (alarm_event == (unsigned int)VXGE_HW_EVENT_FIFO_ERR) 
#line 865 
                                                             tmp_25 = 219; else 
                                                                    
#line 865 
                                                                    tmp_25 = 220;
    
#line 866 
    tmp_26 = tmp_25;
  }
  else 
#line 866 
       tmp_26 = 222;
  
#line 866 
  __retres = (enum vxge_hw_status)tmp_26;
  return_label: 
#line 866 
                return __retres;
}


#line 890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_device_begin_irq(struct __vxge_hw_device *hldev, u32 skip_alarms, u64 *reason)
{
  enum vxge_hw_status __retres;
  u32 i;
  u64 val64;
  u64 adapter_status;
  u64 vpath_mask;
  
#line 897 
  enum vxge_hw_status ret = 0;
  
#line 899 
  val64 = (u64)readq((void const volatile *)(& (hldev->common_reg)->titan_general_int_status));
  
#line 901 
  if ((long)(val64 == 0ULL) != 0L) {
    
#line 903 
    *reason = 0ULL;
    
#line 904 
    ret = VXGE_HW_ERR_WRONG_IRQ;
    
#line 905 
    goto exit;
  }
  else ;
  
#line 908 
  if ((long)(val64 == 18446744073709551615ULL) != 0L) {
    
#line 910 
    adapter_status = (u64)readq((void const volatile *)(& (hldev->common_reg)->adapter_status));
    
#line 912 
    if (adapter_status == 18446744073709551615ULL) {
      
#line 914 
      __vxge_hw_device_handle_error(hldev,4294967295U,(enum vxge_hw_event)VXGE_HW_EVENT_SLOT_FREEZE);
      
#line 916 
      *reason = 0ULL;
      
#line 917 
      ret = VXGE_HW_ERR_SLOT_FREEZE;
      
#line 918 
      goto exit;
    }
    else ;
  }
  else ;
  
#line 922 
  hldev->stats.sw_dev_info_stats.total_intr_cnt += 1U;
  
#line 924 
  *reason = val64;
  
#line 926 
  vpath_mask = hldev->vpaths_deployed >> 47;
  
#line 929 
  if (((vpath_mask << 44) & val64) != 0ULL) {
    
#line 931 
    hldev->stats.sw_dev_info_stats.traffic_intr_cnt += 1U;
    
#line 933 
    __retres = VXGE_HW_OK;
    
#line 933 
    goto return_label;
  }
  else ;
  
#line 936 
  hldev->stats.sw_dev_info_stats.not_traffic_intr_cnt += 1U;
  
#line 938 
  if ((long)((val64 & 2305843009213693952ULL) != 0ULL) != 0L) {
    
#line 941 
    enum vxge_hw_status error_level = 0;
    
#line 943 
    hldev->stats.sw_dev_err_stats.vpath_alarms += 1U;
    
#line 945 
    i = 0U;
    
#line 945 
    goto ldv_46583;
    ldv_46582: 
#line 946 
    ;
    
#line 947 
    if ((hldev->vpaths_deployed & (9223372036854775808ULL >> i)) == 0ULL) 
      
#line 948 
      goto ldv_46580; else ;
    
#line 950 
    ret = __vxge_hw_vpath_alarm_process(& hldev->virtual_paths[i],skip_alarms);
    
#line 953 
    if (ret > error_level) 
#line 953 
                           error_level = ret; else 
#line 953 
                                                   error_level = error_level;
    
#line 955 
    if ((long)((unsigned int)ret + 4294967075U <= 1U) != 0L) 
#line 957 
                                                             goto ldv_46581; else ;
    ldv_46580: 
#line 958 
    ;
    
#line 945 
    i += 1U;
    ldv_46583: 
#line 946 
    ;
    
#line 945 
    if (i <= 16U) 
#line 947 
                  goto ldv_46582; else 
#line 950 
                                       goto ldv_46581;
    ldv_46581: 
#line 951 
    ;
    
#line 960 
    ret = error_level;
  }
  else ;
  exit: 
#line 962 
  ;
  
#line 963 
  __retres = ret;
  return_label: 
#line 963 
                return __retres;
}


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_device_clear_tx_rx(struct __vxge_hw_device *hldev)
{
  
#line 979 
  if (hldev->tim_int_mask0[0] != 0ULL || hldev->tim_int_mask0[1] != 0ULL) 
    
#line 981 
    writeq((unsigned long)(hldev->tim_int_mask0[0] | hldev->tim_int_mask0[1]),(void volatile *)(& (hldev->common_reg)->tim_int_status0)); else ;
  
#line 986 
  if (hldev->tim_int_mask1[0] != 0U || hldev->tim_int_mask1[1] != 0U) 
    
#line 988 
    __vxge_hw_pio_mem_write32_upper(hldev->tim_int_mask1[0] | hldev->tim_int_mask1[1],(void *)(& (hldev->common_reg)->tim_int_status1)); else ;
  
#line 992 
  return;
}


#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
static enum vxge_hw_status vxge_hw_channel_dtr_alloc(struct __vxge_hw_channel *channel, void **dtrh)
{
  enum vxge_hw_status __retres;
  
#line 1007 
  if (channel->reserve_ptr != channel->reserve_top) {
    _alloc_after_swap: 
#line 1008 
    ;
    
#line 1009 
    channel->reserve_ptr -= 1U;
    
#line 1009 
    *dtrh = *(channel->reserve_arr + channel->reserve_ptr);
    
#line 1011 
    __retres = VXGE_HW_OK;
    
#line 1011 
    goto return_label;
  }
  else ;
  
#line 1020 
  if (channel->length != channel->free_ptr) {
    {
      
#line 1021 
      void **__tmp = channel->reserve_arr;
      
#line 1021 
      channel->reserve_arr = channel->free_arr;
      
#line 1021 
      channel->free_arr = __tmp;
    }
    
#line 1022 
    channel->reserve_ptr = channel->length;
    
#line 1023 
    channel->reserve_top = channel->free_ptr;
    
#line 1024 
    channel->free_ptr = channel->length;
    
#line 1026 
    (channel->stats)->reserve_free_swaps_cnt += 1U;
    
#line 1028 
    goto _alloc_after_swap;
  }
  else ;
  
#line 1031 
  (channel->stats)->full_cnt += 1U;
  
#line 1033 
  *dtrh = (void *)0;
  
#line 1034 
  __retres = VXGE_HW_INF_OUT_OF_DESCRIPTORS;
  return_label: 
#line 1034 
                return __retres;
}


#line 1046  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
static void vxge_hw_channel_dtr_post(struct __vxge_hw_channel *channel, void *dtrh)
{
  u32 tmp;
  
#line 1050 
  tmp = channel->post_index;
  
#line 1050 
  channel->post_index += 1U;
  
#line 1050 
  *(channel->work_arr + tmp) = dtrh;
  
#line 1053 
  if (channel->post_index == channel->length) 
#line 1054 
                                              channel->post_index = 0U; else ;
  
#line 1055 
  return;
}


#line 1066  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_channel_dtr_try_complete(struct __vxge_hw_channel *channel, void **dtrh)
{
  
#line 1070 
  *dtrh = *(channel->work_arr + channel->compl_index);
  
#line 1071 
  __builtin_prefetch((void const *)*dtrh);
  
#line 1072 
  return;
}


#line 1081  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_channel_dtr_complete(struct __vxge_hw_channel *channel)
{
  
#line 1083 
  *(channel->work_arr + channel->compl_index) = (void *)0;
  
#line 1086 
  channel->compl_index += 1U;
  
#line 1086 
  ;
  
#line 1086 
  if (channel->compl_index == channel->length) 
#line 1087 
                                               channel->compl_index = 0U; else ;
  
#line 1089 
  (channel->stats)->total_compl_cnt += 1U;
  
#line 1090 
  return;
}


#line 1100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_channel_dtr_free(struct __vxge_hw_channel *channel, void *dtrh)
{
  
#line 1102 
  channel->free_ptr -= 1U;
  
#line 1102 
  *(channel->free_arr + channel->free_ptr) = dtrh;
  
#line 1103 
  return;
}


#line 1112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
int vxge_hw_channel_dtr_count(struct __vxge_hw_channel *channel)
{
  int __retres;
  
#line 1114 
  __retres = (int)((channel->reserve_ptr - channel->reserve_top) + (channel->length - channel->free_ptr));
  
#line 1114 
  return __retres;
}


#line 1132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_ring_rxd_reserve(struct __vxge_hw_ring *ring, void **rxdh)
{
  enum vxge_hw_status status;
  struct __vxge_hw_channel *channel;
  
#line 1138 
  channel = & ring->channel;
  
#line 1140 
  status = vxge_hw_channel_dtr_alloc(channel,rxdh);
  
#line 1142 
  if (status == VXGE_HW_OK) {
    u64 tmp;
    
#line 1143 
    struct vxge_hw_ring_rxd_1 *rxdp = (struct vxge_hw_ring_rxd_1 *)*rxdh;
    
#line 1146 
    tmp = 0ULL;
    
#line 1146 
    rxdp->control_1 = tmp;
    
#line 1146 
    rxdp->control_0 = tmp;
  }
  else ;
  
#line 1149 
  return status;
}


#line 1176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_ring_rxd_free(struct __vxge_hw_ring *ring, void *rxdh)
{
  struct __vxge_hw_channel *channel;
  
#line 1180 
  channel = & ring->channel;
  
#line 1182 
  vxge_hw_channel_dtr_free(channel,rxdh);
  
#line 1183 
  return;
}


#line 1193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_ring_rxd_pre_post(struct __vxge_hw_ring *ring, void *rxdh)
{
  struct __vxge_hw_channel *channel;
  
#line 1197 
  channel = & ring->channel;
  
#line 1199 
  vxge_hw_channel_dtr_post(channel,rxdh);
  
#line 1200 
  return;
}


#line 1209  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_ring_rxd_post_post(struct __vxge_hw_ring *ring, void *rxdh)
{
  struct __vxge_hw_channel *channel;
  
#line 1211 
  struct vxge_hw_ring_rxd_1 *rxdp = (struct vxge_hw_ring_rxd_1 *)rxdh;
  
#line 1214 
  channel = & ring->channel;
  
#line 1216 
  rxdp->control_0 = 72057594037927936ULL;
  
#line 1218 
  if ((ring->stats)->common_stats.usage_cnt != 0U) 
#line 1219 
                                                   (ring->stats)->common_stats.usage_cnt -= 1U; else ;
  
#line 1220 
  return;
}


#line 1232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_ring_rxd_post(struct __vxge_hw_ring *ring, void *rxdh)
{
  struct __vxge_hw_channel *channel;
  
#line 1234 
  struct vxge_hw_ring_rxd_1 *rxdp = (struct vxge_hw_ring_rxd_1 *)rxdh;
  
#line 1237 
  channel = & ring->channel;
  
#line 1238 
  ldv_inline_asm();
  
#line 1240 
  rxdp->control_0 = 72057594037927936ULL;
  
#line 1242 
  vxge_hw_channel_dtr_post(channel,rxdh);
  
#line 1244 
  if ((ring->stats)->common_stats.usage_cnt != 0U) 
#line 1245 
                                                   (ring->stats)->common_stats.usage_cnt -= 1U; else ;
  
#line 1246 
  return;
}


#line 1255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_ring_rxd_post_post_wmb(struct __vxge_hw_ring *ring, void *rxdh)
{
  
#line 1257 
  ldv_inline_asm();
  
#line 1258 
  vxge_hw_ring_rxd_post_post(ring,rxdh);
  
#line 1259 
  return;
}


#line 1294  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_ring_rxd_next_completed(struct __vxge_hw_ring *ring, void **rxdh, u8 *t_code)
{
  struct __vxge_hw_channel *channel;
  struct vxge_hw_ring_rxd_1 *rxdp;
  u64 control_0;
  u64 own;
  
#line 1299 
  enum vxge_hw_status status = 0;
  
#line 1302 
  channel = & ring->channel;
  
#line 1304 
  vxge_hw_channel_dtr_try_complete(channel,rxdh);
  
#line 1306 
  rxdp = (struct vxge_hw_ring_rxd_1 *)*rxdh;
  
#line 1307 
  if (rxdp == (struct vxge_hw_ring_rxd_1 *)0) {
    
#line 1308 
    status = VXGE_HW_INF_NO_MORE_COMPLETED_DESCRIPTORS;
    
#line 1309 
    goto exit;
  }
  else ;
  
#line 1312 
  control_0 = rxdp->control_0;
  
#line 1313 
  own = control_0 & 72057594037927936ULL;
  
#line 1314 
  *t_code = (unsigned char)((unsigned int)((unsigned char)(control_0 >> 48)) & 15U);
  
#line 1317 
  if (own == 0ULL || (unsigned int)*t_code == 12U) {
    
#line 1322 
    ring->cmpl_cnt += 1U;
    
#line 1323 
    vxge_hw_channel_dtr_complete(channel);
    
#line 1327 
    (ring->stats)->common_stats.usage_cnt += 1U;
    
#line 1328 
    if ((ring->stats)->common_stats.usage_max < (ring->stats)->common_stats.usage_cnt) 
      
#line 1330 
      (ring->stats)->common_stats.usage_max = (ring->stats)->common_stats.usage_cnt; else ;
    
#line 1333 
    status = VXGE_HW_OK;
    
#line 1334 
    goto exit;
  }
  else ;
  
#line 1339 
  *rxdh = (void *)0;
  
#line 1340 
  status = VXGE_HW_INF_NO_MORE_COMPLETED_DESCRIPTORS;
  exit: 
#line 1341 
  ;
  
#line 1342 
  return status;
}


#line 1359  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_ring_handle_tcode(struct __vxge_hw_ring *ring, void *rxdh, u8 t_code)
{
  struct __vxge_hw_channel *channel;
  
#line 1363 
  enum vxge_hw_status status = 0;
  
#line 1365 
  channel = & ring->channel;
  
#line 1372 
  if ((unsigned int)t_code == 0U || (unsigned int)t_code == 5U) {
    
#line 1374 
    status = VXGE_HW_OK;
    
#line 1375 
    goto exit;
  }
  else ;
  
#line 1378 
  if ((unsigned int)t_code > 15U) {
    
#line 1379 
    status = VXGE_HW_ERR_INVALID_TCODE;
    
#line 1380 
    goto exit;
  }
  else ;
  
#line 1383 
  (ring->stats)->rxd_t_code_err_cnt[(int)t_code] += 1U;
  exit: 
#line 1384 
  ;
  
#line 1385 
  return status;
}


#line 1399  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
static void __vxge_hw_non_offload_db_post(struct __vxge_hw_fifo *fifo, u64 txdl_ptr, u32 num_txds, u32 no_snoop)
{
  struct __vxge_hw_channel *channel;
  
#line 1404 
  channel = & fifo->channel;
  
#line 1406 
  writeq((unsigned long)(((unsigned long long)num_txds << 24) | ((unsigned long long)no_snoop & 255ULL)),(void volatile *)(& (fifo->nofl_db)->control_0));
  
#line 1410 
  ldv_inline_asm();
  
#line 1413 
  writeq((unsigned long)txdl_ptr,(void volatile *)(& (fifo->nofl_db)->txdl_ptr));
  
#line 1414 
  ldv_inline_asm();
  
#line 1415 
  return;
}


#line 1423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
u32 vxge_hw_fifo_free_txdl_count_get(struct __vxge_hw_fifo *fifoh)
{
  u32 __retres;
  int tmp;
  
#line 1425 
  tmp = vxge_hw_channel_dtr_count(& fifoh->channel);
  
#line 1425 
  __retres = (unsigned int)tmp;
  
#line 1425 
  return __retres;
}


#line 1448  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_fifo_txdl_reserve(struct __vxge_hw_fifo *fifo, void **txdlh, void **txdl_priv)
{
  struct __vxge_hw_channel *channel;
  enum vxge_hw_status status;
  int i;
  
#line 1456 
  channel = & fifo->channel;
  
#line 1458 
  status = vxge_hw_channel_dtr_alloc(channel,txdlh);
  
#line 1460 
  if (status == VXGE_HW_OK) {
    struct __vxge_hw_fifo_txdl_priv *priv;
    u64 tmp;
    
#line 1461 
    struct vxge_hw_fifo_txd *txdp = (struct vxge_hw_fifo_txd *)*txdlh;
    
#line 1465 
    priv = __vxge_hw_fifo_txdl_priv(fifo,txdp);
    
#line 1468 
    priv->align_dma_offset = 0L;
    
#line 1469 
    priv->align_vaddr_start = priv->align_vaddr;
    
#line 1470 
    priv->align_used_frags = 0U;
    
#line 1471 
    priv->frags = 0U;
    
#line 1472 
    priv->alloc_frags = (fifo->config)->max_frags;
    
#line 1473 
    priv->next_txdl_priv = (struct __vxge_hw_fifo_txdl_priv *)0;
    
#line 1475 
    *txdl_priv = (void *)txdp->host_control;
    
#line 1477 
    i = 0;
    
#line 1477 
    goto ldv_46684;
    ldv_46683: 
#line 1478 
    ;
    
#line 1478 
    txdp = (struct vxge_hw_fifo_txd *)*txdlh + i;
    
#line 1479 
    tmp = 0ULL;
    
#line 1479 
    txdp->control_1 = tmp;
    
#line 1479 
    txdp->control_0 = tmp;
    
#line 1477 
    i += 1;
    ldv_46684: 
#line 1478 
    ;
    
#line 1477 
    if ((fifo->config)->max_frags > (unsigned int)i) 
#line 1479 
                                                     goto ldv_46683; else 
                                                                    
#line 1482 
                                                                    goto ldv_46685;
    ldv_46685: 
#line 1483 
    ;
  }
  else ;
  
#line 1483 
  return status;
}


#line 1503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_fifo_txdl_buffer_set(struct __vxge_hw_fifo *fifo, void *txdlh, u32 frag_idx, dma_addr_t dma_pointer, u32 size)
{
  struct __vxge_hw_fifo_txdl_priv *txdl_priv;
  struct vxge_hw_fifo_txd *txdp;
  struct vxge_hw_fifo_txd *txdp_last;
  struct __vxge_hw_channel *channel;
  
#line 1511 
  channel = & fifo->channel;
  
#line 1513 
  txdl_priv = __vxge_hw_fifo_txdl_priv(fifo,(struct vxge_hw_fifo_txd *)txdlh);
  
#line 1514 
  txdp = (struct vxge_hw_fifo_txd *)txdlh + txdl_priv->frags;
  
#line 1516 
  if (frag_idx != 0U) {
    u64 tmp;
    
#line 1517 
    tmp = 0ULL;
    
#line 1517 
    txdp->control_1 = tmp;
    
#line 1517 
    txdp->control_0 = tmp;
  }
  else {
    
#line 1519 
    txdp->control_0 |= 2199023255552ULL;
    
#line 1521 
    txdp->control_1 |= fifo->interrupt_type;
    
#line 1522 
    txdp->control_1 |= (unsigned long long)fifo->tx_intr_num << 24;
    
#line 1524 
    if (txdl_priv->frags != 0U) {
      
#line 1525 
      txdp_last = (struct vxge_hw_fifo_txd *)txdlh + (txdl_priv->frags + 4294967295U);
      
#line 1527 
      txdp_last->control_0 |= 1099511627776ULL;
    }
    else ;
  }
  
#line 1534 
  txdp->buffer_pointer = dma_pointer;
  
#line 1535 
  txdp->control_0 |= (unsigned long long)size;
  
#line 1536 
  (fifo->stats)->total_buffers += 1U;
  
#line 1537 
  txdl_priv->frags += 1U;
  
#line 1538 
  return;
}


#line 1552  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_fifo_txdl_post(struct __vxge_hw_fifo *fifo, void *txdlh)
{
  struct __vxge_hw_fifo_txdl_priv *txdl_priv;
  struct vxge_hw_fifo_txd *txdp_last;
  struct vxge_hw_fifo_txd *txdp_first;
  struct __vxge_hw_channel *channel;
  
#line 1559 
  channel = & fifo->channel;
  
#line 1561 
  txdl_priv = __vxge_hw_fifo_txdl_priv(fifo,(struct vxge_hw_fifo_txd *)txdlh);
  
#line 1562 
  txdp_first = (struct vxge_hw_fifo_txd *)txdlh;
  
#line 1564 
  txdp_last = (struct vxge_hw_fifo_txd *)txdlh + (txdl_priv->frags + 4294967295U);
  
#line 1565 
  txdp_last->control_0 |= 1099511627776ULL;
  
#line 1567 
  txdp_first->control_0 |= 72057594037927936ULL;
  
#line 1569 
  vxge_hw_channel_dtr_post(& fifo->channel,txdlh);
  
#line 1571 
  __vxge_hw_non_offload_db_post(fifo,txdl_priv->dma_addr,txdl_priv->frags + 4294967295U,fifo->no_snoop_bits);
  
#line 1576 
  (fifo->stats)->total_posts += 1U;
  
#line 1577 
  (fifo->stats)->common_stats.usage_cnt += 1U;
  
#line 1578 
  if ((fifo->stats)->common_stats.usage_max < (fifo->stats)->common_stats.usage_cnt) 
    
#line 1580 
    (fifo->stats)->common_stats.usage_max = (fifo->stats)->common_stats.usage_cnt; else ;
  
#line 1582 
  return;
}


#line 1616  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_fifo_txdl_next_completed(struct __vxge_hw_fifo *fifo, void **txdlh, enum vxge_hw_fifo_tcode *t_code)
{
  struct __vxge_hw_channel *channel;
  struct vxge_hw_fifo_txd *txdp;
  
#line 1622 
  enum vxge_hw_status status = 0;
  
#line 1624 
  channel = & fifo->channel;
  
#line 1626 
  vxge_hw_channel_dtr_try_complete(channel,txdlh);
  
#line 1628 
  txdp = (struct vxge_hw_fifo_txd *)*txdlh;
  
#line 1629 
  if (txdp == (struct vxge_hw_fifo_txd *)0) {
    
#line 1630 
    status = VXGE_HW_INF_NO_MORE_COMPLETED_DESCRIPTORS;
    
#line 1631 
    goto exit;
  }
  else ;
  
#line 1635 
  if ((txdp->control_0 & 72057594037927936ULL) == 0ULL) {
    
#line 1639 
    vxge_hw_channel_dtr_complete(channel);
    
#line 1641 
    *t_code = (enum vxge_hw_fifo_tcode)((unsigned int)((unsigned char)(txdp->control_0 >> 48)) & 15U);
    
#line 1643 
    if ((fifo->stats)->common_stats.usage_cnt != 0U) 
#line 1644 
                                                     (fifo->stats)->common_stats.usage_cnt -= 1U; else ;
    
#line 1646 
    status = VXGE_HW_OK;
    
#line 1647 
    goto exit;
  }
  else ;
  
#line 1651 
  *txdlh = (void *)0;
  
#line 1652 
  status = VXGE_HW_INF_NO_MORE_COMPLETED_DESCRIPTORS;
  exit: 
#line 1653 
  ;
  
#line 1654 
  return status;
}


#line 1671  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_fifo_handle_tcode(struct __vxge_hw_fifo *fifo, void *txdlh, enum vxge_hw_fifo_tcode t_code)
{
  struct __vxge_hw_channel *channel;
  
#line 1677 
  enum vxge_hw_status status = 0;
  
#line 1678 
  channel = & fifo->channel;
  
#line 1680 
  if (((unsigned int)t_code & 7U) > 4U) {
    
#line 1681 
    status = VXGE_HW_ERR_INVALID_TCODE;
    
#line 1682 
    goto exit;
  }
  else ;
  
#line 1685 
  (fifo->stats)->txd_t_code_err_cnt[(unsigned int)t_code] += 1U;
  exit: 
#line 1686 
  ;
  
#line 1687 
  return status;
}


#line 1714  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_fifo_txdl_free(struct __vxge_hw_fifo *fifo, void *txdlh)
{
  struct __vxge_hw_fifo_txdl_priv *txdl_priv;
  u32 max_frags;
  struct __vxge_hw_channel *channel;
  
#line 1720 
  channel = & fifo->channel;
  
#line 1722 
  txdl_priv = __vxge_hw_fifo_txdl_priv(fifo,(struct vxge_hw_fifo_txd *)txdlh);
  
#line 1725 
  max_frags = (fifo->config)->max_frags;
  
#line 1727 
  vxge_hw_channel_dtr_free(channel,txdlh);
  
#line 1728 
  return;
}


#line 1746  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_mac_addr_add(struct __vxge_hw_vpath_handle *vp, u8 *macaddr, u8 *macaddr_mask, enum vxge_hw_vpath_mac_addr_add_mode duplicate_mode)
{
  u32 i;
  
#line 1753 
  u64 data1 = 0ULL;
  
#line 1754 
  u64 data2 = 0ULL;
  
#line 1755 
  enum vxge_hw_status status = 0;
  
#line 1757 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 1758 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 1759 
    goto exit;
  }
  else ;
  
#line 1762 
  i = 0U;
  
#line 1762 
  goto ldv_46741;
  ldv_46740: 
#line 1763 
  ;
  
#line 1763 
  data1 <<= 8;
  
#line 1764 
  data1 = (unsigned long long)*(macaddr + i) | data1;
  
#line 1766 
  data2 <<= 8;
  
#line 1767 
  data2 = (unsigned long long)*(macaddr_mask + i) | data2;
  
#line 1762 
  i += 1U;
  ldv_46741: 
#line 1763 
  ;
  
#line 1762 
  if (i <= 5U) 
#line 1764 
               goto ldv_46740; else 
#line 1767 
                                    goto ldv_46742;
  ldv_46742: 
#line 1768 
  ;
  
#line 1770 
  switch ((unsigned int)duplicate_mode) {
    case (unsigned int)0: 
#line 1771 
    ;
    
#line 1772 
    i = 0U;
    
#line 1773 
    goto ldv_46744;
    case (unsigned int)1: 
#line 1774 
    ;
    
#line 1775 
    i = 1U;
    
#line 1776 
    goto ldv_46744;
    case (unsigned int)2: 
#line 1777 
    ;
    
#line 1778 
    i = 2U;
    
#line 1779 
    goto ldv_46744;
    default: 
#line 1780 
    ;
    
#line 1781 
    i = 0U;
    
#line 1782 
    goto ldv_46744;
  }
  ldv_46744: 
#line 1785 
  ;
  
#line 1785 
  status = __vxge_hw_vpath_rts_table_set(vp,0U,0U,0U,data1 << 16,(data2 << 16) | (unsigned long long)i);
  exit: 
#line 1792 
  ;
  
#line 1793 
  return status;
}


#line 1809  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_mac_addr_get(struct __vxge_hw_vpath_handle *vp, u8 *macaddr, u8 *macaddr_mask)
{
  u32 i;
  
#line 1815 
  u64 data1 = 0ULL;
  
#line 1816 
  u64 data2 = 0ULL;
  
#line 1817 
  enum vxge_hw_status status = 0;
  
#line 1819 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 1820 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 1821 
    goto exit;
  }
  else ;
  
#line 1824 
  status = __vxge_hw_vpath_rts_table_get(vp,2U,0U,0U,& data1,& data2);
  
#line 1829 
  if (status != VXGE_HW_OK) 
#line 1830 
                            goto exit; else ;
  
#line 1832 
  data1 >>= 16;
  
#line 1834 
  data2 >>= 16;
  
#line 1836 
  i = 6U;
  
#line 1836 
  goto ldv_46759;
  ldv_46758: 
#line 1837 
  ;
  
#line 1837 
  *(macaddr + (i + 4294967295U)) = (unsigned char)data1;
  
#line 1838 
  data1 >>= 8;
  
#line 1840 
  *(macaddr_mask + (i + 4294967295U)) = (unsigned char)data2;
  
#line 1841 
  data2 >>= 8;
  
#line 1836 
  i -= 1U;
  ldv_46759: 
#line 1837 
  ;
  
#line 1836 
  if (i != 0U) 
#line 1838 
               goto ldv_46758; else 
#line 1841 
                                    goto ldv_46760;
  ldv_46760: 
#line 1842 
  ;
  exit: 
#line 1843 
  ;
  
#line 1844 
  return status;
}


#line 1861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_mac_addr_get_next(struct __vxge_hw_vpath_handle *vp, u8 *macaddr, u8 *macaddr_mask)
{
  u32 i;
  
#line 1867 
  u64 data1 = 0ULL;
  
#line 1868 
  u64 data2 = 0ULL;
  
#line 1869 
  enum vxge_hw_status status = 0;
  
#line 1871 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 1872 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 1873 
    goto exit;
  }
  else ;
  
#line 1876 
  status = __vxge_hw_vpath_rts_table_get(vp,3U,0U,0U,& data1,& data2);
  
#line 1881 
  if (status != VXGE_HW_OK) 
#line 1882 
                            goto exit; else ;
  
#line 1884 
  data1 >>= 16;
  
#line 1886 
  data2 >>= 16;
  
#line 1888 
  i = 6U;
  
#line 1888 
  goto ldv_46772;
  ldv_46771: 
#line 1889 
  ;
  
#line 1889 
  *(macaddr + (i + 4294967295U)) = (unsigned char)data1;
  
#line 1890 
  data1 >>= 8;
  
#line 1892 
  *(macaddr_mask + (i + 4294967295U)) = (unsigned char)data2;
  
#line 1893 
  data2 >>= 8;
  
#line 1888 
  i -= 1U;
  ldv_46772: 
#line 1889 
  ;
  
#line 1888 
  if (i != 0U) 
#line 1890 
               goto ldv_46771; else 
#line 1893 
                                    goto ldv_46773;
  ldv_46773: 
#line 1894 
  ;
  exit: 
#line 1896 
  ;
  
#line 1897 
  return status;
}


#line 1914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_mac_addr_delete(struct __vxge_hw_vpath_handle *vp, u8 *macaddr, u8 *macaddr_mask)
{
  u32 i;
  
#line 1920 
  u64 data1 = 0ULL;
  
#line 1921 
  u64 data2 = 0ULL;
  
#line 1922 
  enum vxge_hw_status status = 0;
  
#line 1924 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 1925 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 1926 
    goto exit;
  }
  else ;
  
#line 1929 
  i = 0U;
  
#line 1929 
  goto ldv_46785;
  ldv_46784: 
#line 1930 
  ;
  
#line 1930 
  data1 <<= 8;
  
#line 1931 
  data1 = (unsigned long long)*(macaddr + i) | data1;
  
#line 1933 
  data2 <<= 8;
  
#line 1934 
  data2 = (unsigned long long)*(macaddr_mask + i) | data2;
  
#line 1929 
  i += 1U;
  ldv_46785: 
#line 1930 
  ;
  
#line 1929 
  if (i <= 5U) 
#line 1931 
               goto ldv_46784; else 
#line 1934 
                                    goto ldv_46786;
  ldv_46786: 
#line 1935 
  ;
  
#line 1937 
  status = __vxge_hw_vpath_rts_table_set(vp,1U,0U,0U,data1 << 16,data2 << 16);
  exit: 
#line 1943 
  ;
  
#line 1944 
  return status;
}


#line 1958  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_vid_add(struct __vxge_hw_vpath_handle *vp, u64 vid)
{
  
#line 1960 
  enum vxge_hw_status status = 0;
  
#line 1962 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 1963 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 1964 
    goto exit;
  }
  else ;
  
#line 1967 
  status = __vxge_hw_vpath_rts_table_set(vp,0U,1U,0U,vid << 52,0ULL);
  exit: 
#line 1971 
  ;
  
#line 1972 
  return status;
}


#line 1986  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_vid_delete(struct __vxge_hw_vpath_handle *vp, u64 vid)
{
  
#line 1988 
  enum vxge_hw_status status = 0;
  
#line 1990 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 1991 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 1992 
    goto exit;
  }
  else ;
  
#line 1995 
  status = __vxge_hw_vpath_rts_table_set(vp,1U,1U,0U,vid << 52,0ULL);
  exit: 
#line 1999 
  ;
  
#line 2000 
  return status;
}


#line 2011  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_promisc_enable(struct __vxge_hw_vpath_handle *vp)
{
  enum vxge_hw_status __retres;
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  
#line 2016 
  enum vxge_hw_status status = 0;
  
#line 2018 
  if (vp == (struct __vxge_hw_vpath_handle *)0 || (vp->vpath)->ringh == (struct __vxge_hw_ring *)0) {
    
#line 2019 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 2020 
    goto exit;
  }
  else ;
  
#line 2023 
  vpath = vp->vpath;
  
#line 2026 
  if (((vpath->hldev)->access_rights & 4U) == 0U) {
    
#line 2028 
    __retres = VXGE_HW_OK;
    
#line 2028 
    goto return_label;
  }
  else ;
  
#line 2030 
  val64 = (u64)readq((void const volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  
#line 2032 
  if ((val64 & 1048576ULL) == 0ULL) {
    
#line 2034 
    val64 |= 1118464ULL;
    
#line 2039 
    writeq((unsigned long)val64,(void volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  }
  else ;
  exit: 
#line 2041 
  ;
  
#line 2042 
  __retres = status;
  return_label: 
#line 2042 
                return __retres;
}


#line 2053  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_promisc_disable(struct __vxge_hw_vpath_handle *vp)
{
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  
#line 2058 
  enum vxge_hw_status status = 0;
  
#line 2060 
  if (vp == (struct __vxge_hw_vpath_handle *)0 || (vp->vpath)->ringh == (struct __vxge_hw_ring *)0) {
    
#line 2061 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 2062 
    goto exit;
  }
  else ;
  
#line 2065 
  vpath = vp->vpath;
  
#line 2067 
  val64 = (u64)readq((void const volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  
#line 2069 
  if ((val64 & 1048576ULL) != 0ULL) {
    
#line 2071 
    val64 &= 18446744073708437247ULL;
    
#line 2075 
    writeq((unsigned long)val64,(void volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  }
  else ;
  exit: 
#line 2077 
  ;
  
#line 2078 
  return status;
}


#line 2087  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_bcast_enable(struct __vxge_hw_vpath_handle *vp)
{
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  
#line 2092 
  enum vxge_hw_status status = 0;
  
#line 2094 
  if (vp == (struct __vxge_hw_vpath_handle *)0 || (vp->vpath)->ringh == (struct __vxge_hw_ring *)0) {
    
#line 2095 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 2096 
    goto exit;
  }
  else ;
  
#line 2099 
  vpath = vp->vpath;
  
#line 2101 
  val64 = (u64)readq((void const volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  
#line 2103 
  if ((val64 & 4096ULL) == 0ULL) {
    
#line 2104 
    val64 |= 4096ULL;
    
#line 2105 
    writeq((unsigned long)val64,(void volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  }
  else ;
  exit: 
#line 2107 
  ;
  
#line 2108 
  return status;
}


#line 2119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_mcast_enable(struct __vxge_hw_vpath_handle *vp)
{
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  
#line 2124 
  enum vxge_hw_status status = 0;
  
#line 2126 
  if (vp == (struct __vxge_hw_vpath_handle *)0 || (vp->vpath)->ringh == (struct __vxge_hw_ring *)0) {
    
#line 2127 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 2128 
    goto exit;
  }
  else ;
  
#line 2131 
  vpath = vp->vpath;
  
#line 2133 
  val64 = (u64)readq((void const volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  
#line 2135 
  if ((val64 & 65536ULL) == 0ULL) {
    
#line 2136 
    val64 |= 65536ULL;
    
#line 2137 
    writeq((unsigned long)val64,(void volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  }
  else ;
  exit: 
#line 2139 
  ;
  
#line 2140 
  return status;
}


#line 2153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_mcast_disable(struct __vxge_hw_vpath_handle *vp)
{
  u64 val64;
  struct __vxge_hw_virtualpath *vpath;
  
#line 2157 
  enum vxge_hw_status status = 0;
  
#line 2159 
  if (vp == (struct __vxge_hw_vpath_handle *)0 || (vp->vpath)->ringh == (struct __vxge_hw_ring *)0) {
    
#line 2160 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 2161 
    goto exit;
  }
  else ;
  
#line 2164 
  vpath = vp->vpath;
  
#line 2166 
  val64 = (u64)readq((void const volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  
#line 2168 
  if ((val64 & 65536ULL) != 0ULL) {
    
#line 2169 
    val64 &= 18446744073709486079ULL;
    
#line 2170 
    writeq((unsigned long)val64,(void volatile *)(& (vpath->vp_reg)->rxmac_vcfg0));
  }
  else ;
  exit: 
#line 2172 
  ;
  
#line 2173 
  return status;
}


#line 2184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_alarm_process(struct __vxge_hw_vpath_handle *vp, u32 skip_alarms)
{
  
#line 2188 
  enum vxge_hw_status status = 0;
  
#line 2190 
  if (vp == (struct __vxge_hw_vpath_handle *)0) {
    
#line 2191 
    status = VXGE_HW_ERR_INVALID_HANDLE;
    
#line 2192 
    goto exit;
  }
  else ;
  
#line 2195 
  status = __vxge_hw_vpath_alarm_process(vp->vpath,skip_alarms);
  exit: 
#line 2196 
  ;
  
#line 2197 
  return status;
}


#line 2213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_msix_set(struct __vxge_hw_vpath_handle *vp, int *tim_msix_id, int alarm_msix_id)
{
  u64 val64;
  
#line 2217 
  struct __vxge_hw_virtualpath *vpath = vp->vpath;
  
#line 2218 
  struct vxge_hw_vpath_reg *vp_reg = vpath->vp_reg;
  
#line 2219 
  u32 vp_id = (vp->vpath)->vp_id;
  
#line 2221 
  val64 = ((unsigned long long)(vp_id * 4U + (unsigned int)*tim_msix_id) << 48) | ((unsigned long long)(vp_id * 4U + (unsigned int)*(tim_msix_id + 1U)) << 40);
  
#line 2226 
  writeq((unsigned long)val64,(void volatile *)(& vp_reg->interrupt_cfg0));
  
#line 2228 
  writeq((unsigned long)((unsigned long long)((vpath->hldev)->first_vp_id * 4U + (unsigned int)alarm_msix_id) << 56),(void volatile *)(& vp_reg->interrupt_cfg2));
  
#line 2232 
  if ((unsigned int)*((unsigned char *)(& (vpath->hldev)->config) + 12UL) == 2U) {
    
#line 2234 
    __vxge_hw_pio_mem_write32_upper(268435456U,(void *)(& vp_reg->one_shot_vect0_en));
    
#line 2237 
    __vxge_hw_pio_mem_write32_upper(268435456U,(void *)(& vp_reg->one_shot_vect1_en));
    
#line 2240 
    __vxge_hw_pio_mem_write32_upper(268435456U,(void *)(& vp_reg->one_shot_vect2_en));
  }
  else ;
  
#line 2244 
  return;
}


#line 2259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_msix_mask(struct __vxge_hw_vpath_handle *vp, int msix_id)
{
  
#line 2261 
  struct __vxge_hw_device *hldev = (vp->vpath)->hldev;
  
#line 2262 
  __vxge_hw_pio_mem_write32_upper((unsigned int)((9223372036854775808ULL >> (msix_id >> 2)) >> 32),(void *)(& (hldev->common_reg)->set_msix_mask_vect[msix_id % 4]));
  
#line 2265 
  return;
}


#line 2279  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_msix_clear(struct __vxge_hw_vpath_handle *vp, int msix_id)
{
  
#line 2281 
  struct __vxge_hw_device *hldev = (vp->vpath)->hldev;
  
#line 2283 
  if ((unsigned int)*((unsigned char *)(& hldev->config) + 12UL) == 2U) 
    
#line 2284 
    __vxge_hw_pio_mem_write32_upper((unsigned int)((9223372036854775808ULL >> (msix_id >> 2)) >> 32),(void *)(& (hldev->common_reg)->clr_msix_one_shot_vec[msix_id % 4])); else 
                                                                    
#line 2288 
                                                                    __vxge_hw_pio_mem_write32_upper((unsigned int)((9223372036854775808ULL >> (msix_id >> 2)) >> 32),(void *)(& (hldev->common_reg)->clear_msix_mask_vect[msix_id % 4]));
  
#line 2291 
  return;
}


#line 2306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_msix_unmask(struct __vxge_hw_vpath_handle *vp, int msix_id)
{
  
#line 2308 
  struct __vxge_hw_device *hldev = (vp->vpath)->hldev;
  
#line 2309 
  __vxge_hw_pio_mem_write32_upper((unsigned int)((9223372036854775808ULL >> (msix_id >> 2)) >> 32),(void *)(& (hldev->common_reg)->clear_msix_mask_vect[msix_id % 4]));
  
#line 2312 
  return;
}


#line 2322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_inta_mask_tx_rx(struct __vxge_hw_vpath_handle *vp)
{
  u64 val64;
  unsigned int tmp_0;
  
#line 2324 
  u64 tim_int_mask0[4U] = {0ULL, 0ULL, 0ULL, 0ULL};
  
#line 2325 
  u32 tim_int_mask1[4U] = {0U, 0U, 0U, 0U};
  
#line 2327 
  struct __vxge_hw_device *hldev = (vp->vpath)->hldev;
  
#line 2329 
  if ((vp->vpath)->vp_id <= 15U) {
    
#line 2329 
    tim_int_mask0[0] |= 8ULL << ((vp->vpath)->vp_id * 4294967292U + 60U);
    
#line 2329 
    tim_int_mask0[1] |= 4ULL << ((vp->vpath)->vp_id * 4294967292U + 60U);
  }
  else {
    
#line 2329 
    tim_int_mask1[0] = 2147483648U;
    
#line 2329 
    tim_int_mask1[1] = 1073741824U;
  }
  
#line 2332 
  val64 = (u64)readq((void const volatile *)(& (hldev->common_reg)->tim_int_mask0));
  
#line 2334 
  if (tim_int_mask0[0] != 0ULL || tim_int_mask0[1] != 0ULL) 
#line 2336 
                                                            writeq((unsigned long)((tim_int_mask0[0] | tim_int_mask0[1]) | val64),(void volatile *)(& (hldev->common_reg)->tim_int_mask0)); else ;
  
#line 2341 
  tmp_0 = readl((void const volatile *)(& (hldev->common_reg)->tim_int_mask1));
  
#line 2341 
  val64 = (unsigned long long)tmp_0;
  
#line 2343 
  if (tim_int_mask1[0] != 0U || tim_int_mask1[1] != 0U) 
#line 2345 
                                                        __vxge_hw_pio_mem_write32_upper((tim_int_mask1[0] | tim_int_mask1[1]) | (unsigned int)val64,(void *)(& (hldev->common_reg)->tim_int_mask1)); else ;
  
#line 2349 
  return;
}


#line 2360  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
void vxge_hw_vpath_inta_unmask_tx_rx(struct __vxge_hw_vpath_handle *vp)
{
  u64 val64;
  
#line 2362 
  u64 tim_int_mask0[4U] = {0ULL, 0ULL, 0ULL, 0ULL};
  
#line 2363 
  u32 tim_int_mask1[4U] = {0U, 0U, 0U, 0U};
  
#line 2365 
  struct __vxge_hw_device *hldev = (vp->vpath)->hldev;
  
#line 2367 
  if ((vp->vpath)->vp_id <= 15U) {
    
#line 2367 
    tim_int_mask0[0] |= 8ULL << ((vp->vpath)->vp_id * 4294967292U + 60U);
    
#line 2367 
    tim_int_mask0[1] |= 4ULL << ((vp->vpath)->vp_id * 4294967292U + 60U);
  }
  else {
    
#line 2367 
    tim_int_mask1[0] = 2147483648U;
    
#line 2367 
    tim_int_mask1[1] = 1073741824U;
  }
  
#line 2370 
  val64 = (u64)readq((void const volatile *)(& (hldev->common_reg)->tim_int_mask0));
  
#line 2372 
  if (tim_int_mask0[0] != 0ULL || tim_int_mask0[1] != 0ULL) 
#line 2374 
                                                            writeq((unsigned long)(~ (tim_int_mask0[0] | tim_int_mask0[1]) & val64),(void volatile *)(& (hldev->common_reg)->tim_int_mask0)); else ;
  
#line 2379 
  if (tim_int_mask1[0] != 0U || tim_int_mask1[1] != 0U) 
#line 2381 
                                                        __vxge_hw_pio_mem_write32_upper(~ (tim_int_mask1[0] | tim_int_mask1[1]) & (unsigned int)val64,(void *)(& (hldev->common_reg)->tim_int_mask1)); else ;
  
#line 2385 
  return;
}


#line 2402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_poll_rx(struct __vxge_hw_ring *ring)
{
  u8 t_code;
  void *first_rxdh;
  
#line 2405 
  enum vxge_hw_status status = 0;
  
#line 2407 
  u64 val64 = 0ULL;
  
#line 2408 
  int new_count = 0;
  
#line 2410 
  ring->cmpl_cnt = 0U;
  
#line 2412 
  status = vxge_hw_ring_rxd_next_completed(ring,& first_rxdh,& t_code);
  
#line 2413 
  if (status == VXGE_HW_OK) 
#line 2414 
                            (*(ring->callback))(ring,first_rxdh,(unsigned char)((int)t_code),ring->channel.userdata); else ;
  
#line 2417 
  if (ring->cmpl_cnt != 0U) {
    
#line 2418 
    ring->doorbell_cnt += ring->cmpl_cnt;
    
#line 2419 
    if ((unsigned long long)ring->doorbell_cnt >= ring->rxds_limit) {
      unsigned int tmp;
      
#line 2424 
      new_count = (int)(ring->doorbell_cnt * 4U);
      
#line 2427 
      ring->total_db_cnt += ring->doorbell_cnt;
      
#line 2428 
      if (ring->total_db_cnt >= ring->rxds_per_block) {
        
#line 2429 
        new_count += 4;
        
#line 2431 
        ring->total_db_cnt %= ring->rxds_per_block;
      }
      else ;
      
#line 2433 
      writeq((unsigned long)new_count,(void volatile *)(& (ring->vp_reg)->prc_rxd_doorbell));
      
#line 2436 
      tmp = readl((void const volatile *)(& (ring->common_reg)->titan_general_int_status));
      
#line 2435 
      val64 = (unsigned long long)tmp;
      
#line 2437 
      ring->doorbell_cnt = 0U;
    }
    else ;
  }
  else ;
  
#line 2441 
  return status;
}


#line 2456  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/neterion/vxge/vxge-traffic.c"
enum vxge_hw_status vxge_hw_vpath_poll_tx(struct __vxge_hw_fifo *fifo, struct sk_buff ***skb_ptr, int nr_skb, int *more)
{
  enum vxge_hw_fifo_tcode t_code;
  void *first_txdlh;
  struct __vxge_hw_channel *channel;
  
#line 2462 
  enum vxge_hw_status status = 0;
  
#line 2465 
  channel = & fifo->channel;
  
#line 2467 
  status = vxge_hw_fifo_txdl_next_completed(fifo,& first_txdlh,& t_code);
  
#line 2469 
  if (status == VXGE_HW_OK) {
    enum vxge_hw_status tmp;
    
#line 2470 
    tmp = (*(fifo->callback))(fifo,first_txdlh,t_code,channel->userdata,skb_ptr,nr_skb,more);
    
#line 2470 
    if (tmp != VXGE_HW_OK) 
#line 2472 
                           status = VXGE_HW_COMPLETIONS_REMAIN; else ;
  }
  else ;
  
#line 2474 
  return status;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 28 
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 97 
void ldv_failed_register_netdev(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 86  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0);


#line 88 
void *ldv_interrupt_scenario_18(void *arg0);


#line 89 
void *ldv_interrupt_scenario_19(void *arg0);


#line 91 
int main(void);


#line 92 
void *ldv_timer_scenario_15(void *arg0);


#line 94 
void ldv_dispatch_register_10_3(struct pci_driver *arg0);


#line 95 
void *ldv_interrupt_scenario_17(void *arg0);


#line 96 
void *ldv_interrupt_scenario_20(void *arg0);


#line 100 
void ldv_dispatch_irq_register_13_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 101 
void *ldv_random_allocationless_scenario_14(void *arg0);


#line 102 
void ldv_dispatch_deregister_8_1(struct pci_driver *arg0);


#line 103 
void *ldv_pci_scenario_16(void *arg0);


#line 104 
void ldv_dispatch_instance_register_3_3(struct timer_list *arg0);


#line 105 
void ldv_dispatch_irq_deregister_6_1(int arg0);


#line 106 
void *ldv_initialization_1(void *arg0);


#line 109 
void ldv_dispatch_instance_deregister_12_1(struct timer_list *arg0);


#line 111 
void ldv_dispatch_register_9_4(struct net_device *arg0);


#line 117  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_14;

#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 119  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_19;

#line 120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 121  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_18;

#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_20;

#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_17;

#line 127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_14 *cf_arg_14;
  int tmp;
  
#line 130 
  tmp = ldv_undef_int();
  
#line 130 
  switch (tmp) {
    case 0: 
#line 131 
    ;
    
#line 132 
    ret = pthread_join(ldv_thread_14,(void **)0);
    
#line 133 
    __VERIFIER_assume(ret == 0);
    
#line 134 
    goto ldv_44753;
    default: 
#line 136 
    ;
    
#line 136 
    __VERIFIER_assume(0);
  }
  ldv_44753: 
#line 137 
  ;
  
#line 138 
  return;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_del_timer_sync(struct timer_list *arg0)
{
  int __retres;
  struct timer_list *ldv_12_timer_list;
  
#line 148 
  ldv_12_timer_list = arg0;
  
#line 152 
  ldv_dispatch_instance_deregister_12_1(ldv_12_timer_list);
  
#line 153 
  ;
  
#line 153 
  __retres = 0;
  
#line 153 
  return __retres;
}


#line 161  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_18(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_18_ret_val;
  int ldv_18_line;
  void *ldv_18_data;
  enum irqreturn (*ldv_18_thread)(int , void *);
  int tmp;
  
#line 167 
  enum irqreturn (*ldv_18_callback)(int , void *) = & ldv_emg_wrapper_vxge_rx_msix_napi_handle_2;
  
#line 170 
  struct ldv_struct_interrupt_scenario_17 *data = (struct ldv_struct_interrupt_scenario_17 *)arg0;
  
#line 175 
  if (data != (struct ldv_struct_interrupt_scenario_17 *)0) {
    
#line 176 
    ldv_18_line = data->arg0;
    
#line 177 
    ldv_18_callback = data->arg1;
    
#line 178 
    ldv_18_thread = data->arg2;
    
#line 179 
    ldv_18_data = data->arg3;
    
#line 180 
    ldv_free((void *)data);
  }
  else ;
  
#line 186 
  ldv_switch_to_interrupt_context();
  
#line 188 
  ldv_18_ret_val = ldv_emg_wrapper_vxge_rx_msix_napi_handle_2(ldv_18_line,ldv_18_data);
  
#line 190 
  ldv_switch_to_process_context();
  
#line 193 
  tmp = ldv_undef_int();
  
#line 193 
  if (tmp != 0) {
    
#line 195 
    __VERIFIER_assume(ldv_18_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 199 
    if (ldv_18_thread != (enum irqreturn (*)(int , void *))0) 
#line 201 
                                                              (*ldv_18_thread)(ldv_18_line,ldv_18_data); else ;
  }
  else 
#line 208 
       __VERIFIER_assume(ldv_18_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 217 
  __retres = (void *)0;
  
#line 217 
  goto return_label;
  
#line 219 
  __retres = (void *)0;
  return_label: 
#line 219 
                return __retres;
}


#line 224  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_9_4(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_14 *cf_arg_14;
  int tmp;
  
#line 227 
  tmp = ldv_undef_int();
  
#line 227 
  switch (tmp) {
    case 0: 
#line 228 
    ;
    
#line 229 
    cf_arg_14 = (struct ldv_struct_random_allocationless_scenario_14 *)ldv_xmalloc(16UL);
    
#line 230 
    cf_arg_14->arg0 = arg0;
    
#line 231 
    ret = pthread_create(& ldv_thread_14,(pthread_attr_t const *)0,& ldv_random_allocationless_scenario_14,(void *)cf_arg_14);
    
#line 232 
    __VERIFIER_assume(ret == 0);
    
#line 233 
    goto ldv_44778;
    default: 
#line 235 
    ;
    
#line 235 
    __VERIFIER_assume(0);
  }
  ldv_44778: 
#line 236 
  ;
  
#line 237 
  return;
}


#line 241  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 244 
  struct pci_driver *ldv_10_pci_driver = ldv_emg_alias_vxge_driver_2;
  
#line 248 
  tmp_0 = ldv_undef_int();
  
#line 248 
  if (tmp_0 != 0) {
    
#line 250 
    ldv_10_pci_driver = arg0;
    
#line 254 
    ldv_dispatch_register_10_3(ldv_10_pci_driver);
    
#line 258 
    __retres = 0;
    
#line 258 
    goto return_label;
  }
  else {
    int tmp;
    
#line 265 
    tmp = ldv_undef_int_negative();
    
#line 265 
    __retres = tmp;
    
#line 265 
    goto return_label;
  }
  return_label: 
#line 248 
                return __retres;
}


#line 275  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 278 
  ldv_initialize();
  
#line 281 
  ldv_initialization_1((void *)0);
  
#line 283 
  __retres = 0;
  
#line 283 
  return __retres;
}


#line 288  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_timer_scenario_15(void *arg0)
{
  void *__retres;
  struct timer_list *ldv_15_container;
  
#line 293 
  struct ldv_struct_timer_scenario_15 *data = (struct ldv_struct_timer_scenario_15 *)arg0;
  
#line 298 
  if (data != (struct ldv_struct_timer_scenario_15 *)0) {
    
#line 299 
    ldv_15_container = data->arg0;
    
#line 300 
    ldv_free((void *)data);
  }
  else ;
  
#line 305 
  if (ldv_15_container->function != (void (*)(unsigned long ))0) {
    
#line 307 
    ldv_switch_to_interrupt_context();
    
#line 309 
    (*(ldv_15_container->function))(ldv_15_container->data);
    
#line 311 
    ldv_switch_to_process_context();
  }
  else ;
  
#line 320 
  __retres = (void *)0;
  
#line 320 
  goto return_label;
  
#line 322 
  __retres = (void *)0;
  return_label: 
#line 322 
                return __retres;
}


#line 327  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  struct net_device *__retres;
  struct net_device *ldv_4_netdev;
  int tmp_0;
  
#line 334 
  tmp_0 = ldv_undef_int();
  
#line 334 
  if (tmp_0 != 0) {
    
#line 336 
    ldv_4_netdev = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    
#line 340 
    __retres = ldv_4_netdev;
    
#line 340 
    goto return_label;
  }
  else {
    
#line 347 
    __retres = (struct net_device *)0;
    
#line 347 
    goto return_label;
  }
  return_label: 
#line 334 
                return __retres;
}


#line 357  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_10_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_16 *cf_arg_16;
  int tmp;
  
#line 360 
  tmp = ldv_undef_int();
  
#line 360 
  switch (tmp) {
    case 0: 
#line 361 
    ;
    
#line 362 
    cf_arg_16 = (struct ldv_struct_pci_scenario_16 *)ldv_xmalloc(16UL);
    
#line 363 
    cf_arg_16->arg0 = arg0;
    
#line 364 
    ret = pthread_create(& ldv_thread_16,(pthread_attr_t const *)0,& ldv_pci_scenario_16,(void *)cf_arg_16);
    
#line 365 
    __VERIFIER_assume(ret == 0);
    
#line 366 
    goto ldv_44806;
    default: 
#line 368 
    ;
    
#line 368 
    __VERIFIER_assume(0);
  }
  ldv_44806: 
#line 369 
  ;
  
#line 370 
  return;
}


#line 374  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_17(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_17_ret_val;
  int ldv_17_line;
  void *ldv_17_data;
  enum irqreturn (*ldv_17_thread)(int , void *);
  int tmp;
  
#line 380 
  enum irqreturn (*ldv_17_callback)(int , void *) = & ldv_emg_wrapper_vxge_isr_napi_2;
  
#line 383 
  struct ldv_struct_interrupt_scenario_17 *data = (struct ldv_struct_interrupt_scenario_17 *)arg0;
  
#line 388 
  if (data != (struct ldv_struct_interrupt_scenario_17 *)0) {
    
#line 389 
    ldv_17_line = data->arg0;
    
#line 390 
    ldv_17_callback = data->arg1;
    
#line 391 
    ldv_17_thread = data->arg2;
    
#line 392 
    ldv_17_data = data->arg3;
    
#line 393 
    ldv_free((void *)data);
  }
  else ;
  
#line 399 
  ldv_switch_to_interrupt_context();
  
#line 401 
  ldv_17_ret_val = ldv_emg_wrapper_vxge_isr_napi_2(ldv_17_line,ldv_17_data);
  
#line 403 
  ldv_switch_to_process_context();
  
#line 406 
  tmp = ldv_undef_int();
  
#line 406 
  if (tmp != 0) {
    
#line 408 
    __VERIFIER_assume(ldv_17_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 412 
    if (ldv_17_thread != (enum irqreturn (*)(int , void *))0) 
#line 414 
                                                              (*ldv_17_thread)(ldv_17_line,ldv_17_data); else ;
  }
  else 
#line 421 
       __VERIFIER_assume(ldv_17_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 430 
  __retres = (void *)0;
  
#line 430 
  goto return_label;
  
#line 432 
  __retres = (void *)0;
  return_label: 
#line 432 
                return __retres;
}


#line 437  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_19(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_19_ret_val;
  int ldv_19_line;
  void *ldv_19_data;
  enum irqreturn (*ldv_19_thread)(int , void *);
  int tmp;
  
#line 443 
  enum irqreturn (*ldv_19_callback)(int , void *) = & ldv_emg_wrapper_vxge_alarm_msix_handle_2;
  
#line 446 
  struct ldv_struct_interrupt_scenario_17 *data = (struct ldv_struct_interrupt_scenario_17 *)arg0;
  
#line 451 
  if (data != (struct ldv_struct_interrupt_scenario_17 *)0) {
    
#line 452 
    ldv_19_line = data->arg0;
    
#line 453 
    ldv_19_callback = data->arg1;
    
#line 454 
    ldv_19_thread = data->arg2;
    
#line 455 
    ldv_19_data = data->arg3;
    
#line 456 
    ldv_free((void *)data);
  }
  else ;
  
#line 462 
  ldv_switch_to_interrupt_context();
  
#line 464 
  ldv_19_ret_val = ldv_emg_wrapper_vxge_alarm_msix_handle_2(ldv_19_line,ldv_19_data);
  
#line 466 
  ldv_switch_to_process_context();
  
#line 469 
  tmp = ldv_undef_int();
  
#line 469 
  if (tmp != 0) {
    
#line 471 
    __VERIFIER_assume(ldv_19_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 475 
    if (ldv_19_thread != (enum irqreturn (*)(int , void *))0) 
#line 477 
                                                              (*ldv_19_thread)(ldv_19_line,ldv_19_data); else ;
  }
  else 
#line 484 
       __VERIFIER_assume(ldv_19_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 493 
  __retres = (void *)0;
  
#line 493 
  goto return_label;
  
#line 495 
  __retres = (void *)0;
  return_label: 
#line 495 
                return __retres;
}


#line 500  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_13_line;
  void *ldv_13_data;
  enum irqreturn (*ldv_13_thread)(int , void *);
  int tmp_0;
  
#line 505 
  enum irqreturn (*ldv_13_callback)(int , void *) = & ldv_emg_wrapper_vxge_tx_msix_handle_2;
  
#line 510 
  tmp_0 = ldv_undef_int();
  
#line 510 
  if (tmp_0 != 0) {
    
#line 512 
    ldv_13_line = (int)arg0;
    
#line 513 
    ldv_13_callback = arg1;
    
#line 514 
    ldv_13_thread = (enum irqreturn (*)(int , void *))0;
    
#line 515 
    ldv_13_data = arg4;
    
#line 519 
    ldv_dispatch_irq_register_13_3(ldv_13_line,ldv_13_callback,ldv_13_thread,ldv_13_data);
    
#line 523 
    __retres = 0;
    
#line 523 
    goto return_label;
  }
  else {
    int tmp;
    
#line 530 
    tmp = ldv_undef_int_negative();
    
#line 530 
    __retres = tmp;
    
#line 530 
    goto return_label;
  }
  return_label: 
#line 510 
                return __retres;
}


#line 540  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 543 
  struct pci_driver *ldv_8_pci_driver = ldv_emg_alias_vxge_driver_2;
  
#line 546 
  ldv_8_pci_driver = arg0;
  
#line 550 
  ldv_dispatch_deregister_8_1(ldv_8_pci_driver);
  
#line 554 
  goto return_label;
  return_label: 
#line 556 
                return;
}


#line 561  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_schedule_work(struct work_struct *arg0)
{
  _Bool __retres;
  struct work_struct *ldv_11_work_struct;
  int tmp;
  
#line 568 
  tmp = ldv_undef_int();
  
#line 568 
  if (tmp != 0) {
    
#line 570 
    ldv_11_work_struct = arg0;
    
#line 574 
    if (ldv_11_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 576 
      (*(ldv_11_work_struct->func))(ldv_11_work_struct); else ;
    
#line 581 
    __retres = (_Bool)1;
    
#line 581 
    goto return_label;
  }
  else {
    
#line 588 
    __retres = (_Bool)0;
    
#line 588 
    goto return_label;
  }
  return_label: 
#line 568 
                return __retres;
}


#line 598  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_13_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_17 *cf_arg_17;
  struct ldv_struct_interrupt_scenario_17 *cf_arg_18;
  struct ldv_struct_interrupt_scenario_17 *cf_arg_19;
  struct ldv_struct_interrupt_scenario_17 *cf_arg_20;
  int tmp;
  
#line 604 
  tmp = ldv_undef_int();
  
#line 604 
  switch (tmp) {
    case 0: 
#line 605 
    ;
    
#line 606 
    cf_arg_17 = (struct ldv_struct_interrupt_scenario_17 *)ldv_xmalloc(32UL);
    
#line 607 
    cf_arg_17->arg0 = arg0;
    
#line 608 
    cf_arg_17->arg1 = arg1;
    
#line 609 
    cf_arg_17->arg2 = arg2;
    
#line 610 
    cf_arg_17->arg3 = arg3;
    
#line 611 
    ret = pthread_create(& ldv_thread_17,(pthread_attr_t const *)0,& ldv_interrupt_scenario_17,(void *)cf_arg_17);
    
#line 612 
    __VERIFIER_assume(ret == 0);
    
#line 613 
    goto ldv_44875;
    case 1: 
#line 615 
    ;
    
#line 616 
    cf_arg_18 = (struct ldv_struct_interrupt_scenario_17 *)ldv_xmalloc(32UL);
    
#line 617 
    cf_arg_18->arg0 = arg0;
    
#line 618 
    cf_arg_18->arg1 = arg1;
    
#line 619 
    cf_arg_18->arg2 = arg2;
    
#line 620 
    cf_arg_18->arg3 = arg3;
    
#line 621 
    ret = pthread_create(& ldv_thread_18,(pthread_attr_t const *)0,& ldv_interrupt_scenario_18,(void *)cf_arg_18);
    
#line 622 
    __VERIFIER_assume(ret == 0);
    
#line 623 
    goto ldv_44875;
    case 2: 
#line 625 
    ;
    
#line 626 
    cf_arg_19 = (struct ldv_struct_interrupt_scenario_17 *)ldv_xmalloc(32UL);
    
#line 627 
    cf_arg_19->arg0 = arg0;
    
#line 628 
    cf_arg_19->arg1 = arg1;
    
#line 629 
    cf_arg_19->arg2 = arg2;
    
#line 630 
    cf_arg_19->arg3 = arg3;
    
#line 631 
    ret = pthread_create(& ldv_thread_19,(pthread_attr_t const *)0,& ldv_interrupt_scenario_19,(void *)cf_arg_19);
    
#line 632 
    __VERIFIER_assume(ret == 0);
    
#line 633 
    goto ldv_44875;
    case 3: 
#line 635 
    ;
    
#line 636 
    cf_arg_20 = (struct ldv_struct_interrupt_scenario_17 *)ldv_xmalloc(32UL);
    
#line 637 
    cf_arg_20->arg0 = arg0;
    
#line 638 
    cf_arg_20->arg1 = arg1;
    
#line 639 
    cf_arg_20->arg2 = arg2;
    
#line 640 
    cf_arg_20->arg3 = arg3;
    
#line 641 
    ret = pthread_create(& ldv_thread_20,(pthread_attr_t const *)0,& ldv_interrupt_scenario_20,(void *)cf_arg_20);
    
#line 642 
    __VERIFIER_assume(ret == 0);
    
#line 643 
    goto ldv_44875;
    default: 
#line 645 
    ;
    
#line 645 
    __VERIFIER_assume(0);
  }
  ldv_44875: 
#line 646 
  ;
  
#line 647 
  return;
}


#line 651  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_random_allocationless_scenario_14(void *arg0)
{
  void *__retres;
  void *ldv_14_ldv_param_1_13;
  struct ethtool_cmd *ldv_14_ldv_param_1_3;
  struct ethtool_drvinfo *ldv_14_ldv_param_1_10;
  int ldv_14_ldv_param_1_15;
  unsigned short ldv_14_ldv_param_1_25;
  unsigned char *ldv_14_ldv_param_2_24;
  struct ethtool_cmd *ldv_14_ldv_param_1_14;
  struct ethtool_pauseparam *ldv_14_ldv_param_1_2;
  enum ethtool_phys_id_state *ldv_14_ldv_param_1_4;
  struct rtnl_link_stats64 *ldv_14_ldv_param_1_5;
  unsigned long long ldv_14_ldv_param_1_11;
  unsigned long long *ldv_14_ldv_param_2_8;
  void *ldv_14_ldv_param_2_22;
  unsigned short ldv_14_ldv_param_2_26;
  unsigned short ldv_14_ldv_param_1_16;
  struct ifreq *ldv_14_ldv_param_1_18;
  struct ethtool_flash *ldv_14_ldv_param_1_20;
  int ldv_14_ldv_param_2_19;
  struct ethtool_regs *ldv_14_ldv_param_1_21;
  unsigned short ldv_14_ldv_param_2_17;
  int ldv_14_ldv_param_1_6;
  unsigned long long ldv_14_ldv_param_1_9;
  unsigned int ldv_14_ldv_param_1_23;
  struct sk_buff *ldv_14_ldv_param_0_12;
  struct net_device *ldv_14_container;
  struct ethtool_pauseparam *ldv_14_ldv_param_1_27;
  struct ethtool_stats *ldv_14_ldv_param_1_7;
  int tmp_14;
  
#line 682 
  struct ldv_struct_random_allocationless_scenario_14 *data = (struct ldv_struct_random_allocationless_scenario_14 *)arg0;
  
#line 687 
  if (data != (struct ldv_struct_random_allocationless_scenario_14 *)0) {
    
#line 688 
    ldv_14_container = data->arg0;
    
#line 689 
    ldv_free((void *)data);
  }
  else ;
  
#line 697 
  goto ldv_call_14;
  
#line 699 
  __retres = (void *)0;
  
#line 699 
  goto return_label;
  ldv_call_14: 
#line 702 
  ;
  
#line 705 
  tmp_14 = ldv_undef_int();
  
#line 705 
  if (tmp_14 != 0) {
    int tmp_0;
    
#line 707 
    ldv_14_ldv_param_1_2 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
    
#line 710 
    tmp_0 = ldv_undef_int();
    
#line 710 
    switch (tmp_0) {
      case 1: 
#line 711 
      ;
      
#line 714 
      ldv_emg_wrapper_vxge_ethtool_getpause_data_2(ldv_14_container,ldv_14_ldv_param_1_2);
      
#line 717 
      goto ldv_44913;
      case 2: 
#line 719 
      ;
      
#line 721 
      ldv_14_ldv_param_1_27 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 726 
      ldv_emg_wrapper_vxge_ethtool_setpause_data_24(ldv_14_container,ldv_14_ldv_param_1_27);
      
#line 730 
      ldv_free((void *)ldv_14_ldv_param_1_27);
      
#line 733 
      goto ldv_44913;
      case 3: 
#line 735 
      ;
      
#line 738 
      ldv_emg_wrapper_vxge_netpoll_26(ldv_14_container);
      
#line 741 
      goto ldv_44913;
      case 4: 
#line 743 
      ;
      
#line 749 
      ldv_emg_wrapper_vxge_vlan_rx_kill_vid_25(ldv_14_container,(unsigned short)((int)ldv_14_ldv_param_1_25),(unsigned short)((int)ldv_14_ldv_param_2_26));
      
#line 755 
      goto ldv_44913;
      case 5: 
#line 757 
      ;
      
#line 760 
      ldv_emg_wrapper_vxge_set_multicast_27(ldv_14_container);
      
#line 763 
      goto ldv_44913;
      case 6: 
#line 765 
      ;
      
#line 768 
      ldv_emg_wrapper_vxge_ethtool_get_regs_len_23(ldv_14_container);
      
#line 771 
      goto ldv_44913;
      case 7: 
#line 773 
      ;
      
#line 775 
      ldv_14_ldv_param_2_24 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 780 
      ldv_emg_wrapper_vxge_ethtool_get_strings_22(ldv_14_container,ldv_14_ldv_param_1_23,ldv_14_ldv_param_2_24);
      
#line 784 
      ldv_free((void *)ldv_14_ldv_param_2_24);
      
#line 787 
      goto ldv_44913;
      case 8: 
#line 789 
      ;
      
#line 792 
      ldv_emg_wrapper_vxge_tx_watchdog_21(ldv_14_container);
      
#line 795 
      goto ldv_44913;
      case 9: 
#line 797 
      ;
      
#line 799 
      ldv_14_ldv_param_2_22 = ldv_xmalloc_unknown_size(0UL);
      
#line 800 
      ldv_14_ldv_param_1_21 = (struct ethtool_regs *)ldv_xmalloc_unknown_size(0UL);
      
#line 805 
      ldv_emg_wrapper_vxge_ethtool_gregs_20(ldv_14_container,ldv_14_ldv_param_1_21,ldv_14_ldv_param_2_22);
      
#line 809 
      ldv_free(ldv_14_ldv_param_2_22);
      
#line 810 
      ldv_free((void *)ldv_14_ldv_param_1_21);
      
#line 813 
      goto ldv_44913;
      case 10: 
#line 815 
      ;
      
#line 817 
      ldv_14_ldv_param_1_20 = (struct ethtool_flash *)ldv_xmalloc_unknown_size(0UL);
      
#line 822 
      ldv_emg_wrapper_vxge_fw_flash_19(ldv_14_container,ldv_14_ldv_param_1_20);
      
#line 826 
      ldv_free((void *)ldv_14_ldv_param_1_20);
      
#line 829 
      goto ldv_44913;
      case 11: 
#line 831 
      ;
      
#line 833 
      ldv_14_ldv_param_1_18 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
      
#line 838 
      ldv_emg_wrapper_vxge_ioctl_18(ldv_14_container,ldv_14_ldv_param_1_18,ldv_14_ldv_param_2_19);
      
#line 842 
      ldv_free((void *)ldv_14_ldv_param_1_18);
      
#line 845 
      goto ldv_44913;
      case 12: 
#line 847 
      ;
      
#line 853 
      ldv_emg_wrapper_vxge_vlan_rx_add_vid_17(ldv_14_container,(unsigned short)((int)ldv_14_ldv_param_1_16),(unsigned short)((int)ldv_14_ldv_param_2_17));
      
#line 859 
      goto ldv_44913;
      case 13: 
#line 861 
      ;
      
#line 867 
      ldv_emg_wrapper_vxge_ethtool_get_sset_count_16(ldv_14_container,ldv_14_ldv_param_1_15);
      
#line 873 
      goto ldv_44913;
      case 14: 
#line 875 
      ;
      
#line 877 
      ldv_14_ldv_param_1_14 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 882 
      ldv_emg_wrapper_vxge_ethtool_gset_15(ldv_14_container,ldv_14_ldv_param_1_14);
      
#line 886 
      ldv_free((void *)ldv_14_ldv_param_1_14);
      
#line 889 
      goto ldv_44913;
      case 15: 
#line 891 
      ;
      
#line 893 
      ldv_14_ldv_param_1_13 = ldv_xmalloc_unknown_size(0UL);
      
#line 898 
      ldv_emg_wrapper_vxge_set_mac_addr_14(ldv_14_container,ldv_14_ldv_param_1_13);
      
#line 902 
      ldv_free(ldv_14_ldv_param_1_13);
      
#line 905 
      goto ldv_44913;
      case 16: 
#line 907 
      ;
      
#line 909 
      ldv_14_ldv_param_0_12 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
      
#line 914 
      ldv_emg_wrapper_vxge_xmit_13(ldv_14_ldv_param_0_12,ldv_14_container);
      
#line 918 
      ldv_free((void *)ldv_14_ldv_param_0_12);
      
#line 921 
      goto ldv_44913;
      case 17: 
#line 923 
      ;
      
#line 929 
      ldv_emg_wrapper_vxge_fix_features_12(ldv_14_container,ldv_14_ldv_param_1_11);
      
#line 935 
      goto ldv_44913;
      case 18: 
#line 937 
      ;
      
#line 939 
      ldv_14_ldv_param_1_10 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 944 
      ldv_emg_wrapper_vxge_ethtool_gdrvinfo_11(ldv_14_container,ldv_14_ldv_param_1_10);
      
#line 948 
      ldv_free((void *)ldv_14_ldv_param_1_10);
      
#line 951 
      goto ldv_44913;
      case 19: 
#line 953 
      ;
      
#line 959 
      ldv_emg_wrapper_vxge_set_features_10(ldv_14_container,ldv_14_ldv_param_1_9);
      
#line 965 
      goto ldv_44913;
      case 20: 
#line 967 
      ;
      
#line 970 
      (*ldv_emg_alias_ethtool_op_get_link_9)(ldv_14_container);
      
#line 973 
      goto ldv_44913;
      case 21: 
#line 975 
      ;
      
#line 978 
      (*ldv_emg_alias_eth_validate_addr_6)(ldv_14_container);
      
#line 981 
      goto ldv_44913;
      case 22: 
#line 983 
      ;
      
#line 985 
      ldv_14_ldv_param_1_7 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
      
#line 986 
      ldv_14_ldv_param_2_8 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 991 
      ldv_emg_wrapper_vxge_get_ethtool_stats_7(ldv_14_container,ldv_14_ldv_param_1_7,ldv_14_ldv_param_2_8);
      
#line 995 
      ldv_free((void *)ldv_14_ldv_param_1_7);
      
#line 996 
      ldv_free((void *)ldv_14_ldv_param_2_8);
      
#line 999 
      goto ldv_44913;
      case 23: 
#line 1001 
      ;
      
#line 1007 
      ldv_emg_wrapper_vxge_change_mtu_8(ldv_14_container,ldv_14_ldv_param_1_6);
      
#line 1013 
      goto ldv_44913;
      case 24: 
#line 1015 
      ;
      
#line 1017 
      ldv_14_ldv_param_1_5 = (struct rtnl_link_stats64 *)ldv_xmalloc_unknown_size(0UL);
      
#line 1022 
      ldv_emg_wrapper_vxge_get_stats64_5(ldv_14_container,ldv_14_ldv_param_1_5);
      
#line 1026 
      ldv_free((void *)ldv_14_ldv_param_1_5);
      
#line 1029 
      goto ldv_44913;
      case 25: 
#line 1031 
      ;
      
#line 1033 
      ldv_14_ldv_param_1_4 = (enum ethtool_phys_id_state *)ldv_xmalloc_unknown_size(0UL);
      
#line 1038 
      ldv_emg_wrapper_vxge_ethtool_idnic_4(ldv_14_container,*ldv_14_ldv_param_1_4);
      
#line 1042 
      ldv_free((void *)ldv_14_ldv_param_1_4);
      
#line 1045 
      goto ldv_44913;
      case 26: 
#line 1047 
      ;
      
#line 1049 
      ldv_14_ldv_param_1_3 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 1054 
      ldv_emg_wrapper_vxge_ethtool_sset_3(ldv_14_container,ldv_14_ldv_param_1_3);
      
#line 1058 
      ldv_free((void *)ldv_14_ldv_param_1_3);
      
#line 1061 
      goto ldv_44913;
      default: 
#line 1063 
      ;
      
#line 1063 
      __VERIFIER_assume(0);
    }
    ldv_44913: 
#line 1066 
    ;
    
#line 1066 
    ldv_free((void *)ldv_14_ldv_param_1_2);
    
#line 1073 
    goto ldv_call_14;
  }
  else {
    
#line 1081 
    __retres = (void *)0;
    
#line 1081 
    goto return_label;
  }
  
#line 1084 
  __retres = (void *)0;
  return_label: 
#line 1084 
                return __retres;
}


#line 1089  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_8_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_16 *cf_arg_16;
  int tmp;
  
#line 1092 
  tmp = ldv_undef_int();
  
#line 1092 
  switch (tmp) {
    case 0: 
#line 1093 
    ;
    
#line 1094 
    ret = pthread_join(ldv_thread_16,(void **)0);
    
#line 1095 
    __VERIFIER_assume(ret == 0);
    
#line 1096 
    goto ldv_44946;
    default: 
#line 1098 
    ;
    
#line 1098 
    __VERIFIER_assume(0);
  }
  ldv_44946: 
#line 1099 
  ;
  
#line 1100 
  return;
}


#line 1104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_16(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_16_resource_1;
  struct pci_device_id *ldv_16_ldv_param_1_2;
  struct pm_message ldv_16_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 1109 
  struct pci_driver *ldv_16_container = ldv_emg_alias_vxge_driver_2;
  
#line 1110 
  int ldv_16_ret = ldv_undef_int();
  
#line 1113 
  struct ldv_struct_pci_scenario_16 *data = (struct ldv_struct_pci_scenario_16 *)arg0;
  
#line 1117 
  ldv_16_ret = ldv_undef_int();
  
#line 1120 
  if (data != (struct ldv_struct_pci_scenario_16 *)0) {
    
#line 1121 
    ldv_16_container = data->arg0;
    
#line 1122 
    ldv_free((void *)data);
  }
  else ;
  
#line 1133 
  goto ldv_main_16;
  
#line 1135 
  __retres = (void *)0;
  
#line 1135 
  goto return_label;
  ldv_main_16: 
#line 1138 
  ;
  
#line 1141 
  tmp_2 = ldv_undef_int();
  
#line 1141 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 1143 
    ldv_16_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 1148 
    ldv_pre_probe();
    
#line 1150 
    ldv_16_ret = ldv_emg_wrapper_vxge_probe_2(ldv_16_resource_1,ldv_16_ldv_param_1_2);
    
#line 1152 
    ldv_16_ret = ldv_post_probe(ldv_16_ret);
    
#line 1156 
    ldv_free((void *)ldv_16_ldv_param_1_2);
    
#line 1159 
    tmp_1 = ldv_undef_int();
    
#line 1159 
    if (tmp_1 != 0) {
      
#line 1161 
      __VERIFIER_assume(ldv_16_ret == 0);
      
#line 1168 
      goto ldv_call_16;
    }
    else {
      
#line 1172 
      __VERIFIER_assume(ldv_16_ret != 0);
      
#line 1179 
      goto ldv_main_16;
    }
  }
  else {
    
#line 1191 
    __retres = (void *)0;
    
#line 1191 
    goto return_label;
  }
  
#line 1194 
  __retres = (void *)0;
  
#line 1194 
  goto return_label;
  ldv_call_16: 
#line 1197 
  ;
  
#line 1200 
  tmp_3 = ldv_undef_int();
  
#line 1200 
  switch (tmp_3) {
    case 1: 
#line 1201 
    ;
    
#line 1210 
    goto ldv_call_16;
    case 2: 
#line 1213 
    ;
    
#line 1216 
    ldv_16_ret = ldv_emg_wrapper_vxge_pm_suspend_3(ldv_16_resource_1,ldv_16_resource_0);
    
#line 1218 
    ldv_16_ret = ldv_filter_err_code(ldv_16_ret);
    
#line 1222 
    if (ldv_16_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 1224 
      ldv_16_ret = (*(ldv_16_container->suspend_late))(ldv_16_resource_1,ldv_16_resource_0);
      
#line 1226 
      ldv_16_ret = ldv_filter_err_code(ldv_16_ret);
    }
    else 
#line 1228 
         ldv_16_ret = ldv_undef_int();
    
#line 1233 
    if (ldv_16_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 1235 
      (*(ldv_16_container->resume_early))(ldv_16_resource_1); else ;
    
#line 1241 
    ldv_emg_wrapper_vxge_pm_resume_5(ldv_16_resource_1);
    
#line 1248 
    goto ldv_call_16;
    case 3: 
#line 1251 
    ;
    
#line 1253 
    if (ldv_16_container->shutdown != (void (*)(struct pci_dev *))0) 
      
#line 1255 
      (*(ldv_16_container->shutdown))(ldv_16_resource_1); else ;
    
#line 1261 
    ldv_emg_wrapper_vxge_remove_4(ldv_16_resource_1);
    
#line 1268 
    goto ldv_main_16;
    default: 
#line 1271 
    ;
    
#line 1271 
    __VERIFIER_assume(0);
  }
  
#line 1274 
  __retres = (void *)0;
  return_label: 
#line 1274 
                return __retres;
}


#line 1279  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_register_3_3(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_15 *cf_arg_15;
  int tmp;
  
#line 1282 
  tmp = ldv_undef_int();
  
#line 1282 
  switch (tmp) {
    case 0: 
#line 1283 
    ;
    
#line 1284 
    cf_arg_15 = (struct ldv_struct_timer_scenario_15 *)ldv_xmalloc(16UL);
    
#line 1285 
    cf_arg_15->arg0 = arg0;
    
#line 1286 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_timer_scenario_15,(void *)cf_arg_15);
    
#line 1287 
    __VERIFIER_assume(ret == 0);
    
#line 1288 
    goto ldv_44969;
    default: 
#line 1290 
    ;
    
#line 1290 
    __VERIFIER_assume(0);
  }
  ldv_44969: 
#line 1291 
  ;
  
#line 1292 
  return;
}


#line 1296  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_6_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_6 *cf_arg_17;
  struct ldv_struct_free_irq_6 *cf_arg_18;
  struct ldv_struct_free_irq_6 *cf_arg_19;
  struct ldv_struct_free_irq_6 *cf_arg_20;
  int tmp;
  
#line 1302 
  tmp = ldv_undef_int();
  
#line 1302 
  switch (tmp) {
    case 0: 
#line 1303 
    ;
    
#line 1304 
    ret = pthread_join(ldv_thread_17,(void **)0);
    
#line 1305 
    __VERIFIER_assume(ret == 0);
    
#line 1306 
    goto ldv_44980;
    case 1: 
#line 1308 
    ;
    
#line 1309 
    ret = pthread_join(ldv_thread_18,(void **)0);
    
#line 1310 
    __VERIFIER_assume(ret == 0);
    
#line 1311 
    goto ldv_44980;
    case 2: 
#line 1313 
    ;
    
#line 1314 
    ret = pthread_join(ldv_thread_19,(void **)0);
    
#line 1315 
    __VERIFIER_assume(ret == 0);
    
#line 1316 
    goto ldv_44980;
    case 3: 
#line 1318 
    ;
    
#line 1319 
    ret = pthread_join(ldv_thread_20,(void **)0);
    
#line 1320 
    __VERIFIER_assume(ret == 0);
    
#line 1321 
    goto ldv_44980;
    default: 
#line 1323 
    ;
    
#line 1323 
    __VERIFIER_assume(0);
  }
  ldv_44980: 
#line 1324 
  ;
  
#line 1325 
  return;
}


#line 1329  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 1336 
  ldv_1_ret = ldv_emg_vxge_starter();
  
#line 1337 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 1340 
  tmp = ldv_undef_int();
  
#line 1340 
  if (tmp != 0) {
    
#line 1342 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 1346 
    __retres = (void *)0;
    
#line 1346 
    goto return_label;
  }
  else {
    
#line 1350 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 1355 
    ldv_emg_vxge_closer();
    
#line 1359 
    __retres = (void *)0;
    
#line 1359 
    goto return_label;
  }
  
#line 1362 
  __retres = (void *)0;
  return_label: 
#line 1362 
                return __retres;
}


#line 1367  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_unregister_netdev(struct net_device *arg0)
{
  struct net_device *ldv_5_netdev;
  
#line 1373 
  ldv_5_netdev = arg0;
  
#line 1378 
  ldv_emg_wrapper_vxge_close_2(ldv_5_netdev);
  
#line 1382 
  ldv_dispatch_deregister_5_1(ldv_5_netdev);
  
#line 1386 
  goto return_label;
  return_label: 
#line 1388 
                return;
}


#line 1393  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_6_line;
  
#line 1399 
  ldv_6_line = (int)arg0;
  
#line 1403 
  ldv_dispatch_irq_deregister_6_1(ldv_6_line);
  
#line 1407 
  goto return_label;
  return_label: 
#line 1409 
                return;
}


#line 1414  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_deregister_12_1(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_15 *cf_arg_15;
  int tmp;
  
#line 1417 
  tmp = ldv_undef_int();
  
#line 1417 
  switch (tmp) {
    case 0: 
#line 1418 
    ;
    
#line 1419 
    ret = pthread_join(ldv_thread_15,(void **)0);
    
#line 1420 
    __VERIFIER_assume(ret == 0);
    
#line 1421 
    goto ldv_45004;
    default: 
#line 1423 
    ;
    
#line 1423 
    __VERIFIER_assume(0);
  }
  ldv_45004: 
#line 1424 
  ;
  
#line 1425 
  return;
}


#line 1429  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_register_netdev(struct net_device *arg0)
{
  int __retres;
  struct net_device *ldv_9_netdev;
  int tmp_3;
  
#line 1433 
  int ldv_9_ret = ldv_undef_int();
  
#line 1436 
  ldv_9_ret = ldv_undef_int();
  
#line 1439 
  tmp_3 = ldv_undef_int();
  
#line 1439 
  if (tmp_3 != 0) {
    int tmp_1;
    
#line 1441 
    ldv_9_netdev = arg0;
    
#line 1446 
    ldv_9_ret = ldv_emg_wrapper_vxge_open_2(ldv_9_netdev);
    
#line 1449 
    tmp_1 = ldv_undef_int();
    
#line 1449 
    if (tmp_1 != 0) {
      
#line 1451 
      __VERIFIER_assume(ldv_9_ret == 0);
      
#line 1455 
      ldv_dispatch_register_9_4(ldv_9_netdev);
      
#line 1459 
      __retres = 0;
      
#line 1459 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 1466 
      __VERIFIER_assume(ldv_9_ret != 0);
      
#line 1467 
      ldv_failed_register_netdev();
      
#line 1468 
      tmp_0 = ldv_undef_int_negative();
      
#line 1468 
      __retres = tmp_0;
      
#line 1468 
      goto return_label;
    }
  }
  else {
    int tmp_2;
    
#line 1476 
    ldv_failed_register_netdev();
    
#line 1477 
    tmp_2 = ldv_undef_int_negative();
    
#line 1477 
    __retres = tmp_2;
    
#line 1477 
    goto return_label;
  }
  return_label: 
#line 1439 
                return __retres;
}


#line 1487  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_flush_work(struct work_struct *arg0)
{
  _Bool __retres;
  struct work_struct *ldv_7_work_struct;
  int tmp;
  
#line 1494 
  tmp = ldv_undef_int();
  
#line 1494 
  if (tmp != 0) {
    
#line 1496 
    ldv_7_work_struct = arg0;
    
#line 1500 
    if (ldv_7_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 1502 
      (*(ldv_7_work_struct->func))(ldv_7_work_struct); else ;
    
#line 1507 
    __retres = (_Bool)1;
    
#line 1507 
    goto return_label;
  }
  else {
    
#line 1514 
    __retres = (_Bool)0;
    
#line 1514 
    goto return_label;
  }
  return_label: 
#line 1494 
                return __retres;
}


#line 1524  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_20(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_20_ret_val;
  int ldv_20_line;
  void *ldv_20_data;
  enum irqreturn (*ldv_20_thread)(int , void *);
  int tmp;
  
#line 1530 
  enum irqreturn (*ldv_20_callback)(int , void *) = & ldv_emg_wrapper_vxge_tx_msix_handle_2;
  
#line 1533 
  struct ldv_struct_interrupt_scenario_17 *data = (struct ldv_struct_interrupt_scenario_17 *)arg0;
  
#line 1538 
  if (data != (struct ldv_struct_interrupt_scenario_17 *)0) {
    
#line 1539 
    ldv_20_line = data->arg0;
    
#line 1540 
    ldv_20_callback = data->arg1;
    
#line 1541 
    ldv_20_thread = data->arg2;
    
#line 1542 
    ldv_20_data = data->arg3;
    
#line 1543 
    ldv_free((void *)data);
  }
  else ;
  
#line 1549 
  ldv_switch_to_interrupt_context();
  
#line 1551 
  ldv_20_ret_val = ldv_emg_wrapper_vxge_tx_msix_handle_2(ldv_20_line,ldv_20_data);
  
#line 1553 
  ldv_switch_to_process_context();
  
#line 1556 
  tmp = ldv_undef_int();
  
#line 1556 
  if (tmp != 0) {
    
#line 1558 
    __VERIFIER_assume(ldv_20_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 1562 
    if (ldv_20_thread != (enum irqreturn (*)(int , void *))0) 
#line 1564 
                                                              (*ldv_20_thread)(ldv_20_line,ldv_20_data); else ;
  }
  else 
#line 1571 
       __VERIFIER_assume(ldv_20_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 1580 
  __retres = (void *)0;
  
#line 1580 
  goto return_label;
  
#line 1582 
  __retres = (void *)0;
  return_label: 
#line 1582 
                return __retres;
}


#line 1587  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_netdev(struct net_device *arg0)
{
  struct net_device *ldv_2_netdev;
  
#line 1593 
  ldv_2_netdev = arg0;
  
#line 1594 
  ldv_free((void *)ldv_2_netdev);
  
#line 1598 
  goto return_label;
  return_label: 
#line 1600 
                return;
}


#line 1605  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/neterion/vxge/vxge.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1)
{
  int __retres;
  struct timer_list *ldv_3_timer_list;
  int tmp_0;
  
#line 1612 
  tmp_0 = ldv_undef_int();
  
#line 1612 
  if (tmp_0 != 0) {
    
#line 1614 
    ldv_3_timer_list = arg0;
    
#line 1618 
    ldv_dispatch_instance_register_3_3(ldv_3_timer_list);
    
#line 1622 
    __retres = 0;
    
#line 1622 
    goto return_label;
  }
  else {
    int tmp;
    
#line 1629 
    tmp = ldv_undef_int_negative();
    
#line 1629 
    __retres = tmp;
    
#line 1629 
    goto return_label;
  }
  return_label: 
#line 1612 
                return __retres;
}


