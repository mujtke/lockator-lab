/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __sum16;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
struct module;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4
};

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104 
struct pollfd;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_33 {
   unsigned long seg ;
};

#line 493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_33 mm_segment_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sig_on_uaccess_error : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uaccess_err : 1 ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/stat.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct vm_area_struct;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 193 
struct rw_semaphore;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
enum tk_offsets {
    TK_OFFS_REAL = 0,
    TK_OFFS_BOOT = 1,
    TK_OFFS_TAI = 2,
    TK_OFFS_MAX = 3
};

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 243 
enum hrtimer_restart;

#line 244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_49 {
   struct __anonstruct_50 __anonCompField___anonunion_49_19 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_49 __anonCompField_ctl_table_header_20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11900 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmod.h"
struct cred;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/elf.h"
struct inode;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_147 {
   struct __anonstruct_148 __anonCompField___anonunion_147_33 ;
   struct __anonstruct_149 __anonCompField___anonunion_147_34 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_147 __anonCompField_uprobe_task_35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 133 
struct address_space;

#line 134 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_150 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_152 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_156 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_155 {
   atomic_t _mapcount ;
   struct __anonstruct_156 __anonCompField___anonunion_155_38 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_154 {
   union __anonunion_155 __anonCompField___anonstruct_154_39 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_153 {
   unsigned long counters ;
   struct __anonstruct_154 __anonCompField___anonunion_153_40 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_151 {
   union __anonunion_152 __anonCompField___anonstruct_151_37 ;
   union __anonunion_153 __anonCompField___anonstruct_151_41 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_157 {
   struct list_head lru ;
   struct __anonstruct_158 __anonCompField___anonunion_157_43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_159 __anonCompField___anonunion_157_44 ;
   pgtable_t pmd_huge_pte ;
};

#line 32 
struct kmem_cache;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_150 __anonCompField_page_36 ;
   struct __anonstruct_151 __anonCompField_page_42 ;
   union __anonunion_157 __anonCompField_page_45 ;
   union __anonunion_160 __anonCompField_page_46 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct vm_operations_struct;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
union __anonunion_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_166 __anonCompField_idr_layer_47 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185 
struct dentry;

#line 186 
struct iattr;

#line 187 
struct super_block;

#line 188 
struct file_system_type;

#line 189 
struct kernfs_open_node;

#line 190 
struct kernfs_iattrs;

#line 213 
struct kernfs_root;

#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89 
struct kernfs_ops;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_171 __anonCompField_kernfs_node_48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 477 
struct sock;

#line 478 
struct kobject;

#line 479 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject_ns.h"
struct bin_attribute;

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject_ns.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct kernel_param;

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_172 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_172 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_197 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_199 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct_199 __anonCompField___anonunion_198_52 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_196 __anonCompField_key_50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_197 __anonCompField_key_51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_198 __anonCompField_key_53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion_201 __anonCompField_key_54 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct pipe_inode_info;

#line 1173 
struct uts_namespace;

#line 1174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_217 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_217 __anonCompField_iov_iter_58 ;
   unsigned long nr_segs ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 398  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irq.h"
struct proc_dir_entry;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 67 
struct path;

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dma_map_ops;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_229 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_229 __anonCompField_pci_dev_66 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct writeback_control;

#line 66 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_231 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_231 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_232 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_232 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_233 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_233 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_234 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_234 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_235 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_235 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_236 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_236 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_237 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_237 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_238 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_238 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_239 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_240 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_239 ifr_ifrn ;
   union __anonunion_ifr_ifru_240 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_245 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_244 {
   struct __anonstruct_245 __anonCompField___anonunion_244_67 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_244 __anonCompField_lockref_68 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_247 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_246 {
   struct __anonstruct_247 __anonCompField___anonunion_246_69 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_246 __anonCompField_qstr_70 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_248 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_248 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_252 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_251 {
   struct __anonstruct_252 __anonCompField___anonunion_251_71 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_251 __anonCompField_radix_tree_node_72 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 62 
struct poll_table_struct;

#line 63 
struct kstatfs;

#line 64 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_256 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_256 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_257 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_257 __anonCompField_kqid_74 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_260 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_261 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_262 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_260 __anonCompField_inode_75 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_261 __anonCompField_inode_76 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_262 __anonCompField_inode_77 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_263 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_263 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 947 
struct net;

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19 
struct fasync_struct;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_265 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_264 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_265 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_264 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
enum ldv_27095 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_27095 socket_state;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_280 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_280 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_27496 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_285 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_286 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_27496 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_285 __anonCompField_nf_bridge_info_81 ;
   union __anonunion_286 __anonCompField_nf_bridge_info_82 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 215 
struct skb_frag_struct;

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_page_287 {
   struct page *p ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_287 page ;
   __u32 page_offset ;
   __u32 size ;
};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};

#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_289 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_288 {
   u64 v64 ;
   struct __anonstruct_289 __anonCompField___anonunion_288_83 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_288 __anonCompField_skb_mstamp_84 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_292 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_291 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_292 __anonCompField___anonstruct_291_85 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_290 {
   struct __anonstruct_291 __anonCompField___anonunion_290_86 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_294 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_293 {
   __wsum csum ;
   struct __anonstruct_294 __anonCompField___anonunion_293_88 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_295 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_296 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_297 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_290 __anonCompField_sk_buff_87 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_293 __anonCompField_sk_buff_89 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_295 __anonCompField_sk_buff_90 ;
   __u32 secmark ;
   union __anonunion_296 __anonCompField_sk_buff_91 ;
   union __anonunion_297 __anonCompField_sk_buff_92 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 767 
struct rtable;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct inet_peer_base;

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/xfrm.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_306 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_306 possible_net_t;

#line 376 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 1084  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct mii_ioctl_data {
   __u16 phy_id ;
   __u16 reg_num ;
   __u16 val_in ;
   __u16 val_out ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_29305 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_29305 phy_interface_t;

#line 126 
enum ldv_29358 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_29358 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct xfrm_policy;

#line 98 
struct xfrm_state;

#line 114 
struct request_sock;

#line 1628 
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 331 
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_31068 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_31069 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_317 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct inet6_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_318 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_316 adj_list ;
   struct __anonstruct_all_adj_list_317 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_31068 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_31069 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_318 __anonCompField_net_device_95 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 2893 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 646  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
struct iphdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ihl : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/cacheflush.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) dst_reg : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
};

#line 273 
struct bpf_prog_aux;

#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
union __anonunion_337 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff const *, struct bpf_insn const *) ;
   union __anonunion_337 __anonCompField_bpf_prog_100 ;
};

#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   int maxtype ;
   struct nla_policy const *policy ;
   int (*validate)(struct nlattr **, struct nlattr **) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device const *) ;
   int (*fill_info)(struct sk_buff *, struct net_device const *) ;
   size_t (*get_xstats_size)(struct net_device const *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device const *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy const *slave_policy ;
   int (*slave_validate)(struct nlattr **, struct nlattr **) ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **) ;
   size_t (*get_slave_size)(struct net_device const *, struct net_device const *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device const *, struct net_device const *) ;
   struct net *(*get_link_net)(struct net_device const *) ;
};

#line 171 
struct neigh_table;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   void (*neigh_cleanup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};

#line 129 
struct neigh_ops;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops const *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const *, struct net_device const *, __u32 *) ;
   bool (*key_eq)(struct neighbour const *, void const *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};

#line 519 
struct dn_route;

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
union __anonunion_345 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_345 __anonCompField_dst_entry_101 ;
};

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_socket_lock_t_346 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_346 socket_lock_t;

#line 124 
struct proto;

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u32 __portpair;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u64 __addrpair;

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_348 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_347 {
   __addrpair skc_addrpair ;
   struct __anonstruct_348 __anonCompField___anonunion_347_102 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_349 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_351 {
   __be16 skc_dport ;
   __u16 skc_num ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_350 {
   __portpair skc_portpair ;
   struct __anonstruct_351 __anonCompField___anonunion_350_105 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_352 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_353 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock_common {
   union __anonunion_347 __anonCompField_sock_common_103 ;
   union __anonunion_349 __anonCompField_sock_common_104 ;
   union __anonunion_350 __anonCompField_sock_common_106 ;
   unsigned short skc_family ;
   unsigned char volatile skc_state ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) skc_reuse : 4 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_reuseport : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_ipv6only : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_352 __anonCompField_sock_common_107 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_353 __anonCompField_sock_common_108 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};

#line 219 
struct cg_proto;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_sk_backlog_354 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_354 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) sk_shutdown : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_tx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_rx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) sk_userlocks : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) sk_protocol : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred const *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
};

#line 914 
struct request_sock_ops;

#line 915 
struct timewait_sock_ops;

#line 916 
struct inet_hashinfo;

#line 917 
struct raw_hashinfo;

#line 932 
struct udp_table;

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_h_357 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   void (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   void (*clear_sk)(struct sock *, int ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock const *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_357 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup *, struct cgroup_subsys *) ;
   void (*destroy_cgroup)(struct mem_cgroup *) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup *) ;
};

#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock const *) ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cookie_ts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops const *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};

#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) res1 : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) doff : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) fin : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syn : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rst : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) psh : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ack : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) urg : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ece : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};

#line 410  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
struct firmware {
   size_t size ;
   u8 const *data ;
   struct page **pages ;
   void *priv ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hwmon.h"
struct sensor_device_attribute {
   struct device_attribute dev_attr ;
   int index ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
union __anonunion_383 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_383 __anonCompField_inetpeer_addr_base_112 ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_384 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct __anonstruct_386 {
   atomic_t rid ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_385 {
   struct __anonstruct_386 __anonCompField___anonunion_385_114 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_384 __anonCompField_inet_peer_113 ;
   union __anonunion_385 __anonCompField_inet_peer_115 ;
   __u32 dtime ;
   atomic_t refcnt ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct uncached_list;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/pps.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations const *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pps_kernel.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};

#line 83 
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_pin_desc {
   char name[64U] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5U] ;
};

#line 134 
enum ldv_36697 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
union __anonunion_388 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_clock_request {
   enum ldv_36697 type ;
   union __anonunion_388 __anonCompField_ptp_clock_request_117 ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int n_pins ;
   int pps ;
   struct ptp_pin_desc *pin_config ;
   int (*adjfreq)(struct ptp_clock_info *, s32 ) ;
   int (*adjtime)(struct ptp_clock_info *, s64 ) ;
   int (*gettime64)(struct ptp_clock_info *, struct timespec *) ;
   int (*settime64)(struct ptp_clock_info *, struct timespec const *) ;
   int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int ) ;
   int (*verify)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ) ;
};

#line 113 
struct ptp_clock;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct tg3_tx_buffer_desc {
   u32 addr_hi ;
   u32 addr_lo ;
   u32 len_flags ;
   u32 vlan_tag ;
};

#line 2558  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_rx_buffer_desc {
   u32 addr_hi ;
   u32 addr_lo ;
   u32 idx_len ;
   u32 type_flags ;
   u32 ip_tcp_csum ;
   u32 err_vlan ;
   u32 reserved ;
   u32 opaque ;
};

#line 2620  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct __anonstruct_addrlist_390 {
   u32 addr_hi ;
   u32 addr_lo ;
};

#line 2620  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_ext_rx_buffer_desc {
   struct __anonstruct_addrlist_390 addrlist[3U] ;
   u32 len2_len1 ;
   u32 resv_len3 ;
   struct tg3_rx_buffer_desc std ;
};

#line 2636  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_internal_buffer_desc {
   u32 addr_hi ;
   u32 addr_lo ;
   u32 nic_mbuf ;
   u16 len ;
   u16 cqid_sqid ;
   u32 flags ;
   u32 __cookie1 ;
   u32 __cookie2 ;
   u32 __cookie3 ;
};

#line 2658  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct __anonstruct_idx_391 {
   u16 rx_producer ;
   u16 tx_consumer ;
};

#line 2658  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_hw_status {
   u32 status ;
   u32 status_tag ;
   u16 rx_jumbo_consumer ;
   u16 rx_consumer ;
   u16 rx_mini_consumer ;
   u16 reserved ;
   struct __anonstruct_idx_391 idx[16U] ;
};

#line 2696  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct __anonstruct_tg3_stat64_t_392 {
   u32 high ;
   u32 low ;
};

#line 2696  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
typedef struct __anonstruct_tg3_stat64_t_392 tg3_stat64_t;

#line 2697  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_hw_stats {
   u8 __reserved0[256U] ;
   tg3_stat64_t rx_octets ;
   u64 __reserved1 ;
   tg3_stat64_t rx_fragments ;
   tg3_stat64_t rx_ucast_packets ;
   tg3_stat64_t rx_mcast_packets ;
   tg3_stat64_t rx_bcast_packets ;
   tg3_stat64_t rx_fcs_errors ;
   tg3_stat64_t rx_align_errors ;
   tg3_stat64_t rx_xon_pause_rcvd ;
   tg3_stat64_t rx_xoff_pause_rcvd ;
   tg3_stat64_t rx_mac_ctrl_rcvd ;
   tg3_stat64_t rx_xoff_entered ;
   tg3_stat64_t rx_frame_too_long_errors ;
   tg3_stat64_t rx_jabbers ;
   tg3_stat64_t rx_undersize_packets ;
   tg3_stat64_t rx_in_length_errors ;
   tg3_stat64_t rx_out_length_errors ;
   tg3_stat64_t rx_64_or_less_octet_packets ;
   tg3_stat64_t rx_65_to_127_octet_packets ;
   tg3_stat64_t rx_128_to_255_octet_packets ;
   tg3_stat64_t rx_256_to_511_octet_packets ;
   tg3_stat64_t rx_512_to_1023_octet_packets ;
   tg3_stat64_t rx_1024_to_1522_octet_packets ;
   tg3_stat64_t rx_1523_to_2047_octet_packets ;
   tg3_stat64_t rx_2048_to_4095_octet_packets ;
   tg3_stat64_t rx_4096_to_8191_octet_packets ;
   tg3_stat64_t rx_8192_to_9022_octet_packets ;
   u64 __unused0[37U] ;
   tg3_stat64_t tx_octets ;
   u64 __reserved2 ;
   tg3_stat64_t tx_collisions ;
   tg3_stat64_t tx_xon_sent ;
   tg3_stat64_t tx_xoff_sent ;
   tg3_stat64_t tx_flow_control ;
   tg3_stat64_t tx_mac_errors ;
   tg3_stat64_t tx_single_collisions ;
   tg3_stat64_t tx_mult_collisions ;
   tg3_stat64_t tx_deferred ;
   u64 __reserved3 ;
   tg3_stat64_t tx_excessive_collisions ;
   tg3_stat64_t tx_late_collisions ;
   tg3_stat64_t tx_collide_2times ;
   tg3_stat64_t tx_collide_3times ;
   tg3_stat64_t tx_collide_4times ;
   tg3_stat64_t tx_collide_5times ;
   tg3_stat64_t tx_collide_6times ;
   tg3_stat64_t tx_collide_7times ;
   tg3_stat64_t tx_collide_8times ;
   tg3_stat64_t tx_collide_9times ;
   tg3_stat64_t tx_collide_10times ;
   tg3_stat64_t tx_collide_11times ;
   tg3_stat64_t tx_collide_12times ;
   tg3_stat64_t tx_collide_13times ;
   tg3_stat64_t tx_collide_14times ;
   tg3_stat64_t tx_collide_15times ;
   tg3_stat64_t tx_ucast_packets ;
   tg3_stat64_t tx_mcast_packets ;
   tg3_stat64_t tx_bcast_packets ;
   tg3_stat64_t tx_carrier_sense_errors ;
   tg3_stat64_t tx_discards ;
   tg3_stat64_t tx_errors ;
   u64 __unused1[31U] ;
   tg3_stat64_t COS_rx_packets[16U] ;
   tg3_stat64_t COS_rx_filter_dropped ;
   tg3_stat64_t dma_writeq_full ;
   tg3_stat64_t dma_write_prioq_full ;
   tg3_stat64_t rxbds_empty ;
   tg3_stat64_t rx_discards ;
   tg3_stat64_t rx_errors ;
   tg3_stat64_t rx_threshold_hit ;
   u64 __unused2[9U] ;
   tg3_stat64_t COS_out_packets[16U] ;
   tg3_stat64_t dma_readq_full ;
   tg3_stat64_t dma_read_prioq_full ;
   tg3_stat64_t tx_comp_queue_full ;
   tg3_stat64_t ring_set_send_prod_index ;
   tg3_stat64_t ring_status_update ;
   tg3_stat64_t nic_irqs ;
   tg3_stat64_t nic_avoided_irqs ;
   tg3_stat64_t nic_tx_threshold_hit ;
   tg3_stat64_t mbuf_lwm_thresh_hit ;
   u8 __reserved4[312U] ;
};

#line 2801  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_ocir {
   u32 signature ;
   u16 version_flags ;
   u16 refresh_int ;
   u32 refresh_tmr ;
   u32 update_tmr ;
   u32 dst_base_addr ;
   u16 src_hdr_offset ;
   u16 src_hdr_length ;
   u16 src_data_offset ;
   u16 src_data_length ;
   u16 dst_hdr_offset ;
   u16 dst_data_offset ;
   u16 dst_reg_upd_offset ;
   u16 dst_sem_offset ;
   u32 reserved1[2U] ;
   u32 port0_flags ;
   u32 port1_flags ;
   u32 port2_flags ;
   u32 port3_flags ;
   u32 reserved2[1U] ;
};

#line 2834  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct ring_info {
   u8 *data ;
   dma_addr_t mapping ;
};

#line 2848  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_tx_ring_info {
   struct sk_buff *skb ;
   dma_addr_t mapping ;
   bool fragmented ;
};

#line 2854  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_link_config {
   u32 advertising ;
   u16 speed ;
   u8 duplex ;
   u8 autoneg ;
   u8 flowctrl ;
   u8 active_flowctrl ;
   u8 active_duplex ;
   u16 active_speed ;
   u32 rmt_adv ;
};

#line 2870  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_bufmgr_config {
   u32 mbuf_read_dma_low_water ;
   u32 mbuf_mac_rx_low_water ;
   u32 mbuf_high_water ;
   u32 mbuf_read_dma_low_water_jumbo ;
   u32 mbuf_mac_rx_low_water_jumbo ;
   u32 mbuf_high_water_jumbo ;
   u32 dma_low_water ;
   u32 dma_high_water ;
};

#line 2883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_ethtool_stats {
   u64 rx_octets ;
   u64 rx_fragments ;
   u64 rx_ucast_packets ;
   u64 rx_mcast_packets ;
   u64 rx_bcast_packets ;
   u64 rx_fcs_errors ;
   u64 rx_align_errors ;
   u64 rx_xon_pause_rcvd ;
   u64 rx_xoff_pause_rcvd ;
   u64 rx_mac_ctrl_rcvd ;
   u64 rx_xoff_entered ;
   u64 rx_frame_too_long_errors ;
   u64 rx_jabbers ;
   u64 rx_undersize_packets ;
   u64 rx_in_length_errors ;
   u64 rx_out_length_errors ;
   u64 rx_64_or_less_octet_packets ;
   u64 rx_65_to_127_octet_packets ;
   u64 rx_128_to_255_octet_packets ;
   u64 rx_256_to_511_octet_packets ;
   u64 rx_512_to_1023_octet_packets ;
   u64 rx_1024_to_1522_octet_packets ;
   u64 rx_1523_to_2047_octet_packets ;
   u64 rx_2048_to_4095_octet_packets ;
   u64 rx_4096_to_8191_octet_packets ;
   u64 rx_8192_to_9022_octet_packets ;
   u64 tx_octets ;
   u64 tx_collisions ;
   u64 tx_xon_sent ;
   u64 tx_xoff_sent ;
   u64 tx_flow_control ;
   u64 tx_mac_errors ;
   u64 tx_single_collisions ;
   u64 tx_mult_collisions ;
   u64 tx_deferred ;
   u64 tx_excessive_collisions ;
   u64 tx_late_collisions ;
   u64 tx_collide_2times ;
   u64 tx_collide_3times ;
   u64 tx_collide_4times ;
   u64 tx_collide_5times ;
   u64 tx_collide_6times ;
   u64 tx_collide_7times ;
   u64 tx_collide_8times ;
   u64 tx_collide_9times ;
   u64 tx_collide_10times ;
   u64 tx_collide_11times ;
   u64 tx_collide_12times ;
   u64 tx_collide_13times ;
   u64 tx_collide_14times ;
   u64 tx_collide_15times ;
   u64 tx_ucast_packets ;
   u64 tx_mcast_packets ;
   u64 tx_bcast_packets ;
   u64 tx_carrier_sense_errors ;
   u64 tx_discards ;
   u64 tx_errors ;
   u64 dma_writeq_full ;
   u64 dma_write_prioq_full ;
   u64 rxbds_empty ;
   u64 rx_discards ;
   u64 rx_errors ;
   u64 rx_threshold_hit ;
   u64 dma_readq_full ;
   u64 dma_read_prioq_full ;
   u64 tx_comp_queue_full ;
   u64 ring_set_send_prod_index ;
   u64 ring_status_update ;
   u64 nic_irqs ;
   u64 nic_avoided_irqs ;
   u64 nic_tx_threshold_hit ;
   u64 mbuf_lwm_thresh_hit ;
};

#line 2968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_rx_prodring_set {
   u32 rx_std_prod_idx ;
   u32 rx_std_cons_idx ;
   u32 rx_jmb_prod_idx ;
   u32 rx_jmb_cons_idx ;
   struct tg3_rx_buffer_desc *rx_std ;
   struct tg3_ext_rx_buffer_desc *rx_jmb ;
   struct ring_info *rx_std_buffers ;
   struct ring_info *rx_jmb_buffers ;
   dma_addr_t rx_std_mapping ;
   dma_addr_t rx_jmb_mapping ;
};

#line 2981 
struct tg3;

#line 2981  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_napi {
   struct napi_struct napi ;
   struct tg3 *tp ;
   struct tg3_hw_status *hw_status ;
   u32 chk_msi_cnt ;
   u32 last_tag ;
   u32 last_irq_tag ;
   u32 int_mbox ;
   u32 coal_now ;
   u32 consmbox ;
   u32 rx_rcb_ptr ;
   u32 last_rx_cons ;
   u16 *rx_rcb_prod_idx ;
   struct tg3_rx_prodring_set prodring ;
   struct tg3_rx_buffer_desc *rx_rcb ;
   u32 tx_prod ;
   u32 tx_cons ;
   u32 tx_pending ;
   u32 last_tx_cons ;
   u32 prodmbox ;
   struct tg3_tx_buffer_desc *tx_ring ;
   struct tg3_tx_ring_info *tx_buffers ;
   dma_addr_t status_mapping ;
   dma_addr_t rx_rcb_mapping ;
   dma_addr_t tx_desc_mapping ;
   char irq_lbl[16U] ;
   unsigned int irq_vec ;
};

#line 3019 
enum TG3_FLAGS {
    TG3_FLAG_TAGGED_STATUS = 0,
    TG3_FLAG_TXD_MBOX_HWBUG = 1,
    TG3_FLAG_USE_LINKCHG_REG = 2,
    TG3_FLAG_ERROR_PROCESSED = 3,
    TG3_FLAG_ENABLE_ASF = 4,
    TG3_FLAG_ASPM_WORKAROUND = 5,
    TG3_FLAG_POLL_SERDES = 6,
    TG3_FLAG_POLL_CPMU_LINK = 7,
    TG3_FLAG_MBOX_WRITE_REORDER = 8,
    TG3_FLAG_PCIX_TARGET_HWBUG = 9,
    TG3_FLAG_WOL_SPEED_100MB = 10,
    TG3_FLAG_WOL_ENABLE = 11,
    TG3_FLAG_EEPROM_WRITE_PROT = 12,
    TG3_FLAG_NVRAM = 13,
    TG3_FLAG_NVRAM_BUFFERED = 14,
    TG3_FLAG_SUPPORT_MSI = 15,
    TG3_FLAG_SUPPORT_MSIX = 16,
    TG3_FLAG_USING_MSI = 17,
    TG3_FLAG_USING_MSIX = 18,
    TG3_FLAG_PCIX_MODE = 19,
    TG3_FLAG_PCI_HIGH_SPEED = 20,
    TG3_FLAG_PCI_32BIT = 21,
    TG3_FLAG_SRAM_USE_CONFIG = 22,
    TG3_FLAG_TX_RECOVERY_PENDING = 23,
    TG3_FLAG_WOL_CAP = 24,
    TG3_FLAG_JUMBO_RING_ENABLE = 25,
    TG3_FLAG_PAUSE_AUTONEG = 26,
    TG3_FLAG_CPMU_PRESENT = 27,
    TG3_FLAG_40BIT_DMA_BUG = 28,
    TG3_FLAG_BROKEN_CHECKSUMS = 29,
    TG3_FLAG_JUMBO_CAPABLE = 30,
    TG3_FLAG_CHIP_RESETTING = 31,
    TG3_FLAG_INIT_COMPLETE = 32,
    TG3_FLAG_MAX_RXPEND_64 = 33,
    TG3_FLAG_PCI_EXPRESS = 34,
    TG3_FLAG_ASF_NEW_HANDSHAKE = 35,
    TG3_FLAG_HW_AUTONEG = 36,
    TG3_FLAG_IS_NIC = 37,
    TG3_FLAG_FLASH = 38,
    TG3_FLAG_FW_TSO = 39,
    TG3_FLAG_HW_TSO_1 = 40,
    TG3_FLAG_HW_TSO_2 = 41,
    TG3_FLAG_HW_TSO_3 = 42,
    TG3_FLAG_TSO_CAPABLE = 43,
    TG3_FLAG_TSO_BUG = 44,
    TG3_FLAG_ICH_WORKAROUND = 45,
    TG3_FLAG_1SHOT_MSI = 46,
    TG3_FLAG_NO_FWARE_REPORTED = 47,
    TG3_FLAG_NO_NVRAM_ADDR_TRANS = 48,
    TG3_FLAG_ENABLE_APE = 49,
    TG3_FLAG_PROTECTED_NVRAM = 50,
    TG3_FLAG_5701_DMA_BUG = 51,
    TG3_FLAG_USE_PHYLIB = 52,
    TG3_FLAG_MDIOBUS_INITED = 53,
    TG3_FLAG_LRG_PROD_RING_CAP = 54,
    TG3_FLAG_RGMII_INBAND_DISABLE = 55,
    TG3_FLAG_RGMII_EXT_IBND_RX_EN = 56,
    TG3_FLAG_RGMII_EXT_IBND_TX_EN = 57,
    TG3_FLAG_CLKREQ_BUG = 58,
    TG3_FLAG_NO_NVRAM = 59,
    TG3_FLAG_ENABLE_RSS = 60,
    TG3_FLAG_ENABLE_TSS = 61,
    TG3_FLAG_SHORT_DMA_BUG = 62,
    TG3_FLAG_USE_JUMBO_BDFLAG = 63,
    TG3_FLAG_L1PLLPD_EN = 64,
    TG3_FLAG_APE_HAS_NCSI = 65,
    TG3_FLAG_TX_TSTAMP_EN = 66,
    TG3_FLAG_4K_FIFO_LIMIT = 67,
    TG3_FLAG_5719_5720_RDMA_BUG = 68,
    TG3_FLAG_RESET_TASK_PENDING = 69,
    TG3_FLAG_PTP_CAPABLE = 70,
    TG3_FLAG_5705_PLUS = 71,
    TG3_FLAG_IS_5788 = 72,
    TG3_FLAG_5750_PLUS = 73,
    TG3_FLAG_5780_CLASS = 74,
    TG3_FLAG_5755_PLUS = 75,
    TG3_FLAG_57765_PLUS = 76,
    TG3_FLAG_57765_CLASS = 77,
    TG3_FLAG_5717_PLUS = 78,
    TG3_FLAG_IS_SSB_CORE = 79,
    TG3_FLAG_FLUSH_POSTED_WRITES = 80,
    TG3_FLAG_ROBOSWITCH = 81,
    TG3_FLAG_ONE_DMA_AT_ONCE = 82,
    TG3_FLAG_RGMII_MODE = 83,
    TG3_FLAG_NUMBER_OF_FLAGS = 84
};

#line 3107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3_firmware_hdr {
   __be32 version ;
   __be32 base_addr ;
   __be32 len ;
};

#line 3115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
union __anonunion_393 {
   unsigned long phy_crc_errors ;
   unsigned long last_event_jiffies ;
};

#line 3115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.h"
struct tg3 {
   unsigned int irq_sync ;
   spinlock_t lock ;
   spinlock_t indirect_lock ;
   u32 (*read32)(struct tg3 *, u32 ) ;
   void (*write32)(struct tg3 *, u32 , u32 ) ;
   u32 (*read32_mbox)(struct tg3 *, u32 ) ;
   void (*write32_mbox)(struct tg3 *, u32 , u32 ) ;
   void *regs ;
   void *aperegs ;
   struct net_device *dev ;
   struct pci_dev *pdev ;
   u32 coal_now ;
   u32 msg_enable ;
   struct ptp_clock_info ptp_info ;
   struct ptp_clock *ptp_clock ;
   s64 ptp_adjust ;
   void (*write32_tx_mbox)(struct tg3 *, u32 , u32 ) ;
   u32 dma_limit ;
   u32 txq_req ;
   u32 txq_cnt ;
   u32 txq_max ;
   struct tg3_napi napi[5U] ;
   void (*write32_rx_mbox)(struct tg3 *, u32 , u32 ) ;
   u32 rx_copy_thresh ;
   u32 rx_std_ring_mask ;
   u32 rx_jmb_ring_mask ;
   u32 rx_ret_ring_mask ;
   u32 rx_pending ;
   u32 rx_jumbo_pending ;
   u32 rx_std_max_post ;
   u32 rx_offset ;
   u32 rx_pkt_map_sz ;
   u32 rxq_req ;
   u32 rxq_cnt ;
   u32 rxq_max ;
   bool rx_refill ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   struct rtnl_link_stats64 net_stats_prev ;
   struct tg3_ethtool_stats estats_prev ;
   unsigned long tg3_flags[2U] ;
   union __anonunion_393 __anonCompField_tg3_119 ;
   struct timer_list timer ;
   u16 timer_counter ;
   u16 timer_multiplier ;
   u32 timer_offset ;
   u16 asf_counter ;
   u16 asf_multiplier ;
   u32 serdes_counter ;
   struct tg3_link_config link_config ;
   struct tg3_bufmgr_config bufmgr_config ;
   u32 rx_mode ;
   u32 tx_mode ;
   u32 mac_mode ;
   u32 mi_mode ;
   u32 misc_host_ctrl ;
   u32 grc_mode ;
   u32 grc_local_ctrl ;
   u32 dma_rwctrl ;
   u32 coalesce_mode ;
   u32 pwrmgmt_thresh ;
   u32 rxptpctl ;
   u32 pci_chip_rev_id ;
   u16 pci_cmd ;
   u8 pci_cacheline_sz ;
   u8 pci_lat_timer ;
   int pci_fn ;
   int msi_cap ;
   int pcix_cap ;
   int pcie_readrq ;
   struct mii_bus *mdio_bus ;
   int mdio_irq[32U] ;
   int old_link ;
   u8 phy_addr ;
   u8 phy_ape_lock ;
   u32 phy_id ;
   u32 phy_flags ;
   u32 led_ctrl ;
   u32 phy_otp ;
   u32 setlpicnt ;
   u8 rss_ind_tbl[128U] ;
   char board_part_number[24U] ;
   char fw_ver[32U] ;
   u32 nic_sram_data_cfg ;
   u32 pci_clock_ctrl ;
   struct pci_dev *pdev_peer ;
   struct tg3_hw_stats *hw_stats ;
   dma_addr_t stats_mapping ;
   struct work_struct reset_task ;
   int nvram_lock_cnt ;
   u32 nvram_size ;
   u32 nvram_pagesize ;
   u32 nvram_jedecnum ;
   unsigned int irq_max ;
   unsigned int irq_cnt ;
   struct ethtool_coalesce coal ;
   struct ethtool_eee eee ;
   char const *fw_needed ;
   struct firmware const *fw ;
   u32 fw_len ;
   struct device *hwmon_dev ;
   bool link_up ;
   bool pcierr_recovery ;
};

#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct __anonstruct_ethtool_stats_keys_394 {
   char const string[32U] ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct __anonstruct_ethtool_test_keys_395 {
   char const string[32U] ;
};

#line 5080  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct tg3_fiber_aneginfo {
   int state ;
   u32 flags ;
   unsigned long link_time ;
   unsigned long cur_time ;
   u32 ability_match_cfg ;
   int ability_match_count ;
   char ability_match ;
   char idle_match ;
   char ack_match ;
   u32 txconfig ;
   u32 rxconfig ;
};

#line 13032  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct __anonstruct_reg_tbl_399 {
   u16 offset ;
   u16 flags ;
   u32 read_mask ;
   u32 write_mask ;
};

#line 13260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct mem_entry {
   u32 offset ;
   u32 len ;
};

#line 14983  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct subsys_tbl_ent {
   u16 subsys_vendor ;
   u16 subsys_devid ;
   u32 phy_id ;
};

#line 16172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct tg3_dev_id {
   u32 vendor ;
   u32 device ;
   u32 rev ;
};

#line 16213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct tg3_dev_id_0 {
   u32 vendor ;
   u32 device ;
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct ldv_struct_del_timer_sync_8 {
   struct timer_list *arg0 ;
   int signal_pending ;
};

#line 19  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_free_irq_3 {
   int arg0 ;
   int signal_pending ;
};

#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_15 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_14 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_random_allocationless_scenario_13 {
   struct net_device *arg0 ;
   int signal_pending ;
};
unsigned short __builtin_bswap16(unsigned short);

unsigned int __builtin_bswap32(unsigned int);

void __builtin_prefetch(void const * , ...);

void __builtin_unreachable(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/fvtp/.tmp_tg3.c"
void ldv_inline_asm(void);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight32(unsigned int w)
{
  
#line 26 
  unsigned int res = 0U;
  
#line 27 
  ldv_inline_asm();
  
#line 32 
  return res;
}


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight8(unsigned int w)
{
  unsigned int tmp;
  
#line 42 
  tmp = __arch_hweight32(w & 255U);
  
#line 42 
  return tmp;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned long __arch_hweight64(__u64 w)
{
  
#line 47 
  unsigned long res = 0UL;
  
#line 48 
  ldv_inline_asm();
  
#line 58 
  return res;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val)
{
  __u16 tmp;
  
#line 49 
  tmp = __builtin_bswap16((unsigned short)((int)val));
  
#line 49 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val)
{
  __u32 tmp;
  
#line 60 
  tmp = __builtin_bswap32(val);
  
#line 60 
  return tmp;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitops.h"
__inline static unsigned long hweight_long(unsigned long w)
{
  unsigned long tmp_0;
  
#line 80 
  if (0 != 0) 
#line 80 
              tmp_0 = (unsigned long)((((unsigned int)((((((((((unsigned long long)w & 1ULL) != 0ULL) + (((unsigned long long)w & 2ULL) != 0ULL)) + (((unsigned long long)w & 4ULL) != 0ULL)) + (((unsigned long long)w & 8ULL) != 0ULL)) + (((unsigned long long)w & 16ULL) != 0ULL)) + (((unsigned long long)w & 32ULL) != 0ULL)) + (((unsigned long long)w & 64ULL) != 0ULL)) + (((unsigned long long)w & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 8) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 8) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(w >> 16) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 16) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 24) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 24) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 128ULL) != 0ULL)))) + (((unsigned int)((((((((((unsigned long long)(w >> 32) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 32) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 40) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 40) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(w >> 48) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 48) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 56) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 56) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 128ULL) != 0ULL))))); else 
                                                                    
#line 80 
                                                                    tmp_0 = __arch_hweight64((unsigned long long)w);
  
#line 80 
  return tmp_0;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void ___might_sleep(char const *, int, int);


#line 248 
void __might_fault(char const *, int);


#line 402 
int sprintf(char *, char const * , ...);


#line 405 
int snprintf(char *, size_t, char const * , ...);


#line 474 
extern enum system_states system_state;


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-defs.h"
void __bad_size_call_parameter(void);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void)
{
  struct task_struct *tmp;
  {
    struct task_struct *pfo_ret__;
    
#line 14 
    switch (8UL) {
      case (unsigned long)1: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)2: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)4: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)8: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      default: 
#line 14 
      ;
      
#line 14 
      __bad_percpu_size();
    }
    ldv_3477: 
#line 14 
    ;
    
#line 14 
    tmp = pfo_ret__;
  }
  
#line 14 
  return tmp;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 56 
void *memset(void *, int, size_t);


#line 63 
int memcmp(void const *, void const *, size_t);


#line 64 
size_t strlen(char const *);


#line 65 
char *strcpy(char *, char const *);


#line 66 
char *strcat(char *, char const *);


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
size_t strlcpy(char *, char const *, size_t);


#line 32 
char *strncat(char *, char const *, __kernel_size_t);


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
int __bitmap_weight(unsigned long const *, unsigned int);


#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const *src, unsigned int nbits)
{
  int __retres;
  int tmp_0;
  
#line 300 
  if (0 != 0 && nbits <= 64U) {
    unsigned long tmp;
    
#line 301 
    tmp = hweight_long(*src & (18446744073709551615UL >> (- nbits & 63U)));
    
#line 301 
    __retres = (int)tmp;
    
#line 301 
    goto return_label;
  }
  else ;
  
#line 302 
  tmp_0 = __bitmap_weight(src,nbits);
  
#line 302 
  __retres = tmp_0;
  return_label: 
#line 302 
                return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
extern int nr_cpu_ids;


#line 89 
extern struct cpumask const * const cpu_online_mask;


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask const *srcp)
{
  unsigned int __retres;
  int tmp;
  
#line 476 
  tmp = bitmap_weight((unsigned long const *)(& srcp->bits),(unsigned int)nr_cpu_ids);
  
#line 476 
  __retres = (unsigned int)tmp;
  
#line 476 
  return __retres;
}


#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
  u64 __retres;
  
#line 20 
  *remainder = (unsigned int)(dividend % (unsigned long long)divisor);
  
#line 21 
  __retres = dividend / (unsigned long long)divisor;
  
#line 21 
  return __retres;
}


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/math64.h"
__inline static u64 div_u64(u64 dividend, u32 divisor)
{
  u32 remainder;
  u64 tmp;
  
#line 100 
  tmp = div_u64_rem(dividend,divisor,& remainder);
  
#line 100 
  return tmp;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR(void const *ptr);


#line 41 
static bool IS_ERR(void const *ptr);


#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
__inline static unsigned long current_top_of_stack(void)
{
  unsigned long __retres;
  u64 tmp;
  {
    u64 pfo_ret__;
    
#line 469 
    switch (8UL) {
      case (unsigned long)1: 
#line 469 
      ;
      
#line 470 
      ldv_inline_asm();
      
#line 469 
      goto ldv_5689;
      case (unsigned long)2: 
#line 469 
      ;
      
#line 470 
      ldv_inline_asm();
      
#line 469 
      goto ldv_5689;
      case (unsigned long)4: 
#line 469 
      ;
      
#line 470 
      ldv_inline_asm();
      
#line 469 
      goto ldv_5689;
      case (unsigned long)8: 
#line 469 
      ;
      
#line 470 
      ldv_inline_asm();
      
#line 469 
      goto ldv_5689;
      default: 
#line 469 
      ;
      
#line 469 
      __bad_percpu_size();
    }
    ldv_5689: 
#line 469 
    ;
    
#line 469 
    tmp = pfo_ret__;
  }
  
#line 469 
  __retres = (unsigned long)tmp;
  
#line 469 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const *v)
{
  int __retres;
  int const volatile *tmp;
  {
    
#line 27 
    int const __var = 0;
    
#line 27 
    tmp = (int const volatile *)(& v->counter);
  }
  
#line 27 
  __retres = *tmp;
  
#line 27 
  return __retres;
}


#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void)
{
  struct thread_info *__retres;
  unsigned long tmp;
  
#line 182 
  tmp = current_top_of_stack();
  
#line 182 
  __retres = (struct thread_info *)(tmp + 18446744073709518848UL);
  
#line 182 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti, int flag)
{
  int tmp_1;
  
#line 91 
  if (0 != 0) 
#line 91 
              tmp_1 = constant_test_bit((long)flag,(unsigned long const volatile *)(& ti->flags)); else 
                                                                    
#line 91 
                                                                    tmp_1 = variable_test_bit((long)flag,(unsigned long const volatile *)(& ti->flags));
  
#line 91 
  return tmp_1;
}


#line 7  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
void __local_bh_disable_ip(unsigned long, unsigned int);


#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_disable(void)
{
  __here_0: 
#line 18 
  ;
  
#line 18 
  __local_bh_disable_ip((unsigned long)((void *)0),512U);
  
#line 20 
  return;
}


#line 22 
void __local_bh_enable_ip(unsigned long, unsigned int);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_enable(void)
{
  __here_0: 
#line 31 
  ;
  
#line 31 
  __local_bh_enable_ip((unsigned long)((void *)0),512U);
  
#line 33 
  return;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 30 
void _raw_spin_lock_bh(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 42 
void _raw_spin_unlock_bh(raw_spinlock_t *);


#line 45 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_60(spinlock_t *lock);


#line 358 
static void ldv_spin_lock_92(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_107(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 391 
static void ldv_spin_lock_bh_86(spinlock_t *lock);


#line 395 
static void ldv_spin_lock_bh_88(spinlock_t *lock);


#line 399 
static void ldv_spin_lock_bh_90(spinlock_t *lock);


#line 403 
static void ldv_spin_lock_bh_96(spinlock_t *lock);


#line 407 
static void ldv_spin_lock_bh_97(spinlock_t *lock);


#line 411 
static void ldv_spin_lock_bh_99(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_101(spinlock_t *lock);


#line 419 
static void ldv_spin_lock_bh_103(spinlock_t *lock);


#line 423 
static void ldv_spin_lock_bh_105(spinlock_t *lock);


#line 427 
static void ldv_spin_lock_bh_121(spinlock_t *lock);


#line 431 
static void ldv_spin_lock_bh_123(spinlock_t *lock);


#line 435 
static void ldv_spin_lock_bh_125(spinlock_t *lock);


#line 439 
static void ldv_spin_lock_bh_127(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_63(spinlock_t *lock);


#line 407 
static void ldv_spin_unlock_93(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_108(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_109(spinlock_t *lock);


#line 419 
static void ldv_spin_unlock_110(spinlock_t *lock);


#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh(spinlock_t *lock)
{
  
#line 422 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 423 
  return;
}


#line 452 
static void ldv_spin_unlock_bh_87(spinlock_t *lock);


#line 456 
static void ldv_spin_unlock_bh_89(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_91(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_95(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_98(spinlock_t *lock);


#line 472 
static void ldv_spin_unlock_bh_100(spinlock_t *lock);


#line 476 
static void ldv_spin_unlock_bh_102(spinlock_t *lock);


#line 480 
static void ldv_spin_unlock_bh_104(spinlock_t *lock);


#line 484 
static void ldv_spin_unlock_bh_106(spinlock_t *lock);


#line 488 
static void ldv_spin_unlock_bh_122(spinlock_t *lock);


#line 492 
static void ldv_spin_unlock_bh_124(spinlock_t *lock);


#line 496 
static void ldv_spin_unlock_bh_126(spinlock_t *lock);


#line 500 
static void ldv_spin_unlock_bh_128(spinlock_t *lock);


#line 504 
static void ldv_spin_unlock_bh_129(spinlock_t *lock);


#line 518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 520 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 521 
  return;
}


#line 550 
static void ldv_spin_unlock_irqrestore_75(spinlock_t *lock, unsigned long flags);


#line 554 
static void ldv_spin_unlock_irqrestore_77(spinlock_t *lock, unsigned long flags);


#line 558 
static void ldv_spin_unlock_irqrestore_79(spinlock_t *lock, unsigned long flags);


#line 562 
static void ldv_spin_unlock_irqrestore_81(spinlock_t *lock, unsigned long flags);


#line 566 
static void ldv_spin_unlock_irqrestore_83(spinlock_t *lock, unsigned long flags);


#line 570 
static void ldv_spin_unlock_irqrestore_85(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_74(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_76(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_78(spinlock_t *ldv_func_arg1);


#line 82 
static void ldv___ldv_spin_lock_80(spinlock_t *ldv_func_arg1);


#line 86 
static void ldv___ldv_spin_lock_82(spinlock_t *ldv_func_arg1);


#line 90 
static void ldv___ldv_spin_lock_84(spinlock_t *ldv_func_arg1);


#line 98 
void ldv_spin_model_lock(char *);


#line 99 
void ldv_spin_model_unlock(char *);


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 24 
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec const *ts)
{
  s64 __retres;
  
#line 193 
  __retres = (long long)ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
  
#line 193 
  return __retres;
}


#line 215 
struct timespec ns_to_timespec(s64 const);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 285 
unsigned int jiffies_to_usecs(unsigned long const);


#line 365 
unsigned long __usecs_to_jiffies(unsigned int const);


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _usecs_to_jiffies(unsigned int const u)
{
  unsigned long __retres;
  
#line 369 
  __retres = (unsigned long)(((long)u + 3999L) / 4000L);
  
#line 369 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long usecs_to_jiffies(unsigned int const u)
{
  unsigned long __retres;
  
#line 410 
  if (0 != 0) {
    unsigned int tmp;
    unsigned long tmp_0;
    
#line 411 
    tmp = jiffies_to_usecs(4611686018427387902UL);
    
#line 411 
    ;
    
#line 411 
    if (tmp < u) {
      
#line 412 
      __retres = 4611686018427387902UL;
      
#line 412 
      goto return_label;
    }
    else ;
    
#line 413 
    tmp_0 = _usecs_to_jiffies(u);
    
#line 413 
    __retres = tmp_0;
    
#line 413 
    goto return_label;
  }
  else {
    unsigned long tmp_1;
    
#line 415 
    tmp_1 = __usecs_to_jiffies(u);
    
#line 415 
    __retres = tmp_1;
    
#line 415 
    goto return_label;
  }
  return_label: 
#line 410 
                return __retres;
}


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns)
{
  
#line 285 
  ktime_t const ktime_zero = {.tv64 = 0LL};
  
#line 287 
  ktime_t __constr_expr_17 = {.tv64 = (long long)((unsigned long long)ktime_zero.tv64 + ns)};
  
#line 287 
  return __constr_expr_17;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
ktime_t ktime_get_with_offset(enum tk_offsets);


#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
__inline static ktime_t ktime_get_real(void)
{
  ktime_t tmp;
  
#line 172 
  tmp = ktime_get_with_offset((enum tk_offsets)TK_OFFS_REAL);
  
#line 172 
  return tmp;
}


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 224 
void add_timer(struct timer_list *);


#line 232 
static int ldv_del_timer_sync_111(struct timer_list *ldv_func_arg1);


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void __init_work(struct work_struct *, int);


#line 444 
bool cancel_work_sync(struct work_struct *);


#line 560 
static bool ldv_schedule_work_94(struct work_struct *work);


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile *addr)
{
  unsigned int ret;
  
#line 59 
  ldv_inline_asm();
  
#line 58 
  return ret;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void volatile *addr)
{
  
#line 68 
  ldv_inline_asm();
  
#line 69 
  return;
}


#line 195 
void iounmap(void volatile *);


#line 374  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
void __free_page_frag(void *);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 2845  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk, int flag)
{
  int tmp;
  
#line 2847 
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack,flag);
  
#line 2847 
  return tmp;
}


#line 2871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p)
{
  int __retres;
  int tmp;
  
#line 2873 
  tmp = test_tsk_thread_flag(p,2);
  
#line 2873 
  __retres = (long)(tmp != 0);
  
#line 2873 
  return __retres;
}


#line 2903 
int _cond_resched(void);


#line 3023  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
__inline static bool need_resched(void)
{
  bool __retres;
  int tmp_0;
  struct thread_info *tmp;
  
#line 3025 
  tmp = current_thread_info();
  
#line 3025 
  tmp_0 = test_ti_thread_flag(tmp,3);
  
#line 3025 
  __retres = (_Bool)((long)(tmp_0 != 0) != 0L);
  
#line 3025 
  return __retres;
}


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 418 
static void *kmalloc(size_t size, gfp_t flags);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 5  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __bad_udelay(void);


#line 8 
void __udelay(unsigned long);


#line 10 
void __const_udelay(unsigned long);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
void msleep(unsigned int);


#line 47 
unsigned long msleep_interruptible(unsigned int);


#line 48 
void usleep_range(unsigned long, unsigned long);


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 652 
unsigned long _copy_to_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 664 
void copy_to_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 677 
void __copy_to_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void const *from, unsigned long n)
{
  
#line 730 
  int sz = -1;
  
#line 732 
  __might_fault("./arch/x86/include/asm/uaccess.h",732);
  
#line 735 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 736 
                                                                    n = _copy_to_user(to,from,(unsigned int)n);
  else 
    
#line 737 
    if (0 != 0) 
#line 738 
                copy_to_user_overflow(); else 
#line 740 
                                              __copy_to_user_overflow();
  
#line 742 
  return n;
}


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
void synchronize_irq(unsigned int);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_112(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 145 
static int ldv_request_irq_114(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 157 
static void ldv_free_irq_113(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 161 
static void ldv_free_irq_115(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 165 
static void ldv_free_irq_116(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 169 
static void ldv_free_irq_117(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 173 
static void ldv_free_irq_118(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 177 
static void ldv_free_irq_119(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 181 
static void ldv_free_irq_120(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm_wakeup.h"
__inline static bool device_can_wakeup(struct device *dev)
{
  bool __retres;
  
#line 83 
  __retres = (_Bool)((int)dev->power.can_wakeup != 0);
  
#line 83 
  return __retres;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm_wakeup.h"
__inline static bool device_may_wakeup(struct device *dev)
{
  bool __retres;
  
#line 88 
  __retres = (_Bool)(((unsigned int)*((unsigned char *)(& dev->power) + 4UL) != 0U && dev->power.wakeup != (struct wakeup_source *)0) != 0);
  
#line 88 
  return __retres;
}


#line 102 
void device_set_wakeup_capable(struct device *, bool);


#line 104 
int device_set_wakeup_enable(struct device *, bool);


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 1083 
void dev_err(struct device const *, char const * , ...);


#line 1085 
void dev_warn(struct device const *, char const * , ...);


#line 401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev)
{
  int __retres;
  
#line 403 
  __retres = pdev->error_state != 1U;
  
#line 403 
  return __retres;
}


#line 814 
void pci_dev_put(struct pci_dev *);


#line 835 
int pci_find_capability(struct pci_dev *, int);


#line 843 
struct pci_dev *pci_get_device(unsigned int, unsigned int, struct pci_dev *);


#line 848 
struct pci_dev *pci_get_slot(struct pci_bus *, unsigned int);


#line 857 
int pci_dev_present(struct pci_device_id const *);


#line 859 
int pci_bus_read_config_byte(struct pci_bus *, unsigned int, int, u8 *);


#line 861 
int pci_bus_read_config_word(struct pci_bus *, unsigned int, int, u16 *);


#line 863 
int pci_bus_read_config_dword(struct pci_bus *, unsigned int, int, u32 *);


#line 865 
int pci_bus_write_config_byte(struct pci_bus *, unsigned int, int, u8);


#line 867 
int pci_bus_write_config_word(struct pci_bus *, unsigned int, int, u16);


#line 869 
int pci_bus_write_config_dword(struct pci_bus *, unsigned int, int, u32);


#line 883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev const *dev, int where, u8 *val)
{
  int tmp;
  
#line 885 
  tmp = pci_bus_read_config_byte(dev->bus,dev->devfn,where,val);
  
#line 885 
  return tmp;
}


#line 887  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev const *dev, int where, u16 *val)
{
  int tmp;
  
#line 889 
  tmp = pci_bus_read_config_word(dev->bus,dev->devfn,where,val);
  
#line 889 
  return tmp;
}


#line 891  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev const *dev, int where, u32 *val)
{
  int tmp;
  
#line 894 
  tmp = pci_bus_read_config_dword(dev->bus,dev->devfn,where,val);
  
#line 894 
  return tmp;
}


#line 896  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev const *dev, int where, u8 val)
{
  int tmp;
  
#line 898 
  tmp = pci_bus_write_config_byte(dev->bus,dev->devfn,where,(unsigned char)((int)val));
  
#line 898 
  return tmp;
}


#line 900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev const *dev, int where, u16 val)
{
  int tmp;
  
#line 902 
  tmp = pci_bus_write_config_word(dev->bus,dev->devfn,where,(unsigned short)((int)val));
  
#line 902 
  return tmp;
}


#line 904  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev const *dev, int where, u32 val)
{
  int tmp;
  
#line 907 
  tmp = pci_bus_write_config_dword(dev->bus,dev->devfn,where,val);
  
#line 907 
  return tmp;
}


#line 910 
int pcie_capability_read_word(struct pci_dev *, int, u16 *);


#line 912 
int pcie_capability_write_word(struct pci_dev *, int, u16);


#line 914 
int pcie_capability_clear_and_set_word(struct pci_dev *, int, u16, u16);


#line 919  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pcie_capability_set_word(struct pci_dev *dev, int pos, u16 set)
{
  int tmp;
  
#line 922 
  tmp = pcie_capability_clear_and_set_word(dev,pos,(unsigned short)0,(unsigned short)((int)set));
  
#line 922 
  return tmp;
}


#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pcie_capability_clear_word(struct pci_dev *dev, int pos, u16 clear)
{
  int tmp;
  
#line 934 
  tmp = pcie_capability_clear_and_set_word(dev,pos,(unsigned short)((int)clear),(unsigned short)0);
  
#line 934 
  return tmp;
}


#line 951 
int pci_enable_device(struct pci_dev *);


#line 958  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_is_enabled(struct pci_dev *pdev)
{
  int __retres;
  int tmp;
  
#line 960 
  tmp = atomic_read((atomic_t const *)(& pdev->enable_cnt));
  
#line 960 
  __retres = tmp > 0;
  
#line 960 
  return __retres;
}


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1014 
bool pci_device_is_present(struct pci_dev *);


#line 1026 
int pci_save_state(struct pci_dev *);


#line 1027 
void pci_restore_state(struct pci_dev *);


#line 1040 
int pci_set_power_state(struct pci_dev *, pci_power_t);


#line 1046 
int pci_wake_from_d3(struct pci_dev *, bool);


#line 1076 
ssize_t pci_read_vpd(struct pci_dev *, loff_t, size_t, void *);


#line 1094 
int pci_request_regions(struct pci_dev *, char const *);


#line 1096 
void pci_release_regions(struct pci_dev *);


#line 1146 
static int ldv___pci_register_driver_135(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1162 
static void ldv_pci_unregister_driver_136(struct pci_driver *ldv_func_arg1);


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page const *page)
{
  void *__retres;
  
#line 947 
  __retres = (void *)((unsigned long)((unsigned long long)(((long)page + 24189255811072L) / 64L) << 12) + 18446612132314218496UL);
  
#line 947 
  return __retres;
}


#line 1212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
void pci_disable_msi(struct pci_dev *);


#line 1216 
void pci_disable_msix(struct pci_dev *);


#line 1219 
int pci_enable_msi_range(struct pci_dev *, int, int);


#line 1220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev, int nvec)
{
  int __retres;
  
#line 1222 
  int rc = pci_enable_msi_range(dev,nvec,nvec);
  
#line 1223 
  if (rc < 0) {
    
#line 1224 
    __retres = rc;
    
#line 1224 
    goto return_label;
  }
  else ;
  
#line 1225 
  __retres = 0;
  return_label: 
#line 1225 
                return __retres;
}


#line 1227 
int pci_enable_msix_range(struct pci_dev *, struct msix_entry *, int, int);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 44 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 59 
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);


#line 63 
void debug_dma_sync_single_for_device(struct device *, dma_addr_t, size_t, int);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t addr;
  void *tmp_0;
  int tmp_1;
  
#line 80 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 83 
  ;
  
#line 83 
  tmp_0 = lowmem_page_address((struct page const *)page);
  
#line 83 
  ;
  
#line 83 
  kmemcheck_mark_initialized(tmp_0 + offset,(unsigned int)size);
  
#line 84 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 84 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 86 
    ldv_inline_asm();
    
#line 84 
    ;
  }
  else ;
  
#line 85 
  addr = (*(ops->map_page))(dev,page,offset,size,dir,(struct dma_attrs *)0);
  
#line 86 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr,(_Bool)0);
  
#line 88 
  return addr;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 94 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 96 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 96 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 98 
    ldv_inline_asm();
    
#line 96 
    ;
  }
  else ;
  
#line 97 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 98 
    (*(ops->unmap_page))(dev,addr,size,dir,(struct dma_attrs *)0); else ;
  
#line 99 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)0);
  
#line 100 
  return;
}


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 106 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 108 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 108 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 110 
    ldv_inline_asm();
    
#line 108 
    ;
  }
  else ;
  
#line 109 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 110 
    (*(ops->sync_single_for_cpu))(dev,addr,size,dir); else ;
  
#line 111 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  
#line 112 
  return;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 118 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 120 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 120 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 122 
    ldv_inline_asm();
    
#line 120 
    ;
  }
  else ;
  
#line 121 
  if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 122 
    (*(ops->sync_single_for_device))(dev,addr,size,dir); else ;
  
#line 123 
  debug_dma_sync_single_for_device(dev,addr,size,(int)dir);
  
#line 124 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 60 
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 131 
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, struct dma_attrs *);


#line 136 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, struct dma_attrs *);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag)
{
  
#line 186 
  void *ret = dma_alloc_attrs(dev,size,dma_handle,flag | 32768U,(struct dma_attrs *)0);
  
#line 188 
  return ret;
}


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr, size_t size, int direction)
{
  dma_addr_t tmp_0;
  struct device *tmp;
  
#line 40 
  ;
  
#line 40 
  ;
  
#line 40 
  ;
  
#line 40 
  if (hwdev != (struct pci_dev *)0) 
#line 40 
                                    tmp = & hwdev->dev; else 
#line 40 
                                                             tmp = (struct device *)0;
  
#line 40 
  tmp_0 = dma_map_single_attrs(tmp,ptr,size,(enum dma_data_direction)direction,(struct dma_attrs *)0);
  
#line 40 
  return tmp_0;
}


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr, size_t size, int direction)
{
  struct device *tmp;
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  ;
  
#line 47 
  if (hwdev != (struct pci_dev *)0) 
#line 47 
                                    tmp = & hwdev->dev; else 
#line 47 
                                                             tmp = (struct device *)0;
  
#line 47 
  dma_unmap_single_attrs(tmp,dma_addr,size,(enum dma_data_direction)direction,(struct dma_attrs *)0);
  
#line 48 
  return;
}


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev, dma_addr_t dma_address, size_t size, int direction)
{
  struct device *tmp;
  
#line 61 
  ;
  
#line 61 
  ;
  
#line 61 
  ;
  
#line 61 
  if (hwdev != (struct pci_dev *)0) 
#line 61 
                                    tmp = & hwdev->dev; else 
#line 61 
                                                             tmp = (struct device *)0;
  
#line 61 
  dma_unmap_page(tmp,dma_address,size,(enum dma_data_direction)direction);
  
#line 62 
  return;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev, dma_addr_t dma_handle, size_t size, int direction)
{
  struct device *tmp;
  
#line 82 
  ;
  
#line 82 
  ;
  
#line 82 
  ;
  
#line 82 
  if (hwdev != (struct pci_dev *)0) 
#line 82 
                                    tmp = & hwdev->dev; else 
#line 82 
                                                             tmp = (struct device *)0;
  
#line 82 
  dma_sync_single_for_cpu(tmp,dma_handle,size,(enum dma_data_direction)direction);
  
#line 83 
  return;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev, dma_addr_t dma_handle, size_t size, int direction)
{
  struct device *tmp;
  
#line 89 
  ;
  
#line 89 
  ;
  
#line 89 
  ;
  
#line 89 
  if (hwdev != (struct pci_dev *)0) 
#line 89 
                                    tmp = & hwdev->dev; else 
#line 89 
                                                             tmp = (struct device *)0;
  
#line 89 
  dma_sync_single_for_device(tmp,dma_handle,size,(enum dma_data_direction)direction);
  
#line 90 
  return;
}


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_mapping_error(struct pci_dev *pdev, dma_addr_t dma_addr)
{
  int tmp;
  
#line 109 
  tmp = dma_mapping_error(& pdev->dev,dma_addr);
  
#line 109 
  return tmp;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
{
  int tmp;
  
#line 115 
  tmp = dma_set_mask(& dev->dev,mask);
  
#line 115 
  return tmp;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
{
  int tmp;
  
#line 120 
  tmp = dma_set_coherent_mask(& dev->dev,mask);
  
#line 120 
  return tmp;
}


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static char const *pci_name(struct pci_dev const *pdev)
{
  char const *tmp;
  
#line 1486 
  tmp = dev_name(& pdev->dev);
  
#line 1486 
  return tmp;
}


#line 1666 
void *pci_ioremap_bar(struct pci_dev *, int);


#line 1718  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev)
{
  int __retres;
  
#line 1720 
  __retres = (int)dev->pcie_cap;
  
#line 1720 
  return __retres;
}


#line 1729  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev)
{
  bool __retres;
  int tmp;
  
#line 1731 
  tmp = pci_pcie_cap(dev);
  
#line 1731 
  __retres = (_Bool)(tmp != 0);
  
#line 1731 
  return __retres;
}


#line 1793  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static u16 pci_vpd_lrdt_size(u8 const *lrdt)
{
  u16 __retres;
  
#line 1795 
  __retres = (unsigned short)((int)((unsigned short)*(lrdt + 1U)) + ((int)((unsigned short)*(lrdt + 2U)) << 8U));
  
#line 1795 
  return __retres;
}


#line 1815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static u8 pci_vpd_info_field_size(u8 const *info_field)
{
  u8 __retres;
  
#line 1817 
  __retres = *(info_field + 2U);
  
#line 1817 
  return __retres;
}


#line 1830 
int pci_vpd_find_tag(u8 const *, unsigned int, unsigned int, u8);


#line 1842 
int pci_vpd_find_info_keyword(u8 const *, unsigned int, unsigned int, char const *);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql, unsigned int count)
{
  
#line 74 
  if ((long)(count > 268435455U) != 0L) {
    
#line 76 
    ldv_inline_asm();
    
#line 74 
    ;
  }
  else ;
  
#line 76 
  dql->last_obj_cnt = count;
  
#line 77 
  ldv_inline_asm();
  
#line 85 
  dql->num_queued += count;
  
#line 86 
  return;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql const *dql)
{
  int __retres;
  unsigned int const volatile *tmp;
  unsigned int const volatile *tmp_0;
  {
    
#line 91 
    unsigned int const __var = 0U;
    
#line 91 
    tmp = (unsigned int const volatile *)(& dql->adj_limit);
  }
  {
    
#line 91 
    unsigned int const __var_0 = 0U;
    
#line 91 
    tmp_0 = (unsigned int const volatile *)(& dql->num_queued);
  }
  
#line 91 
  ;
  
#line 91 
  __retres = (int)(*tmp - *tmp_0);
  
#line 91 
  return __retres;
}


#line 95 
void dql_completed(struct dql *, unsigned int);


#line 98 
void dql_reset(struct dql *);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_fold(__wsum sum)
{
  __sum16 __retres;
  
#line 24 
  ldv_inline_asm();
  
#line 29 
  __retres = (unsigned short)(~ sum >> 16);
  
#line 29 
  return __retres;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len, unsigned short proto, __wsum sum)
{
  
#line 89 
  ldv_inline_asm();
  
#line 97 
  return sum;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr, unsigned short len, unsigned short proto, __wsum sum)
{
  __sum16 tmp_0;
  __wsum tmp;
  
#line 116 
  tmp = csum_tcpudp_nofold(saddr,daddr,(unsigned short)((int)len),(unsigned short)((int)proto),sum);
  
#line 116 
  tmp_0 = csum_fold(tmp);
  
#line 116 
  return tmp_0;
}


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const *frag)
{
  unsigned int __retres;
  
#line 232 
  __retres = frag->size;
  
#line 232 
  return __retres;
}


#line 775 
void consume_skb(struct sk_buff *);


#line 786 
struct sk_buff *build_skb(void *, unsigned int);


#line 843 
struct sk_buff *skb_copy(struct sk_buff const *, gfp_t);


#line 852 
int pskb_expand_head(struct sk_buff *, int, int, gfp_t);


#line 855 
struct sk_buff *skb_copy_expand(struct sk_buff const *, int, int, gfp_t);


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 978 
  __retres = skb->head + skb->end;
  
#line 978 
  return __retres;
}


#line 1000  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
  struct skb_shared_hwtstamps *__retres;
  unsigned char *tmp;
  
#line 1002 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1002 
  __retres = & ((struct skb_shared_info *)tmp)->hwtstamps;
  
#line 1002 
  return __retres;
}


#line 1127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff const *skb)
{
  int __retres;
  int dataref;
  unsigned char *tmp;
  
#line 1131 
  if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) {
    
#line 1132 
    __retres = 0;
    
#line 1132 
    goto return_label;
  }
  else ;
  
#line 1134 
  tmp = skb_end_pointer(skb);
  
#line 1134 
  dataref = atomic_read((atomic_t const *)(& ((struct skb_shared_info *)tmp)->dataref));
  
#line 1135 
  dataref = (dataref & 65535) - (dataref >> 16);
  
#line 1136 
  __retres = dataref != 1;
  return_label: 
#line 1136 
                return __retres;
}


#line 1567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff const *skb)
{
  bool __retres;
  
#line 1569 
  __retres = (_Bool)(skb->data_len != 0U);
  
#line 1569 
  return __retres;
}


#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1574 
  __retres = skb->len - skb->data_len;
  
#line 1574 
  return __retres;
}


#line 1688 
unsigned char *skb_put(struct sk_buff *, unsigned int);


#line 1750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1752 
  __retres = (unsigned int)((long)skb->data - (long)skb->head);
  
#line 1752 
  return __retres;
}


#line 1761  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_tailroom(struct sk_buff const *skb)
{
  int __retres;
  unsigned int tmp_0;
  bool tmp;
  
#line 1763 
  tmp = skb_is_nonlinear(skb);
  
#line 1763 
  if ((int)tmp == 0) 
#line 1763 
                     tmp_0 = skb->end - skb->tail; else 
#line 1763 
                                                        tmp_0 = 0U;
  
#line 1763 
  __retres = (int)tmp_0;
  
#line 1763 
  return __retres;
}


#line 1789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  
#line 1791 
  skb->data += len;
  
#line 1792 
  skb->tail += (unsigned int)len;
  
#line 1793 
  return;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1882 
  __retres = skb->head + (int)skb->transport_header;
  
#line 1882 
  return __retres;
}


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1899 
  __retres = skb->head + (int)skb->network_header;
  
#line 1899 
  return __retres;
}


#line 1967  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_transport_offset(struct sk_buff const *skb)
{
  int __retres;
  unsigned char *tmp;
  
#line 1969 
  tmp = skb_transport_header(skb);
  
#line 1969 
  ;
  
#line 1969 
  __retres = (int)((long)tmp - (long)skb->data);
  
#line 1969 
  return __retres;
}


#line 2138 
void *netdev_alloc_frag(unsigned int);


#line 2140 
struct sk_buff *__netdev_alloc_skb(struct net_device *, unsigned int, gfp_t);


#line 2156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev, unsigned int length)
{
  struct sk_buff *tmp;
  
#line 2159 
  tmp = __netdev_alloc_skb(dev,length,32U);
  
#line 2159 
  return tmp;
}


#line 2192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_free_frag(void *addr)
{
  
#line 2194 
  __free_page_frag(addr);
  
#line 2195 
  return;
}


#line 2272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const *frag)
{
  struct page *__retres;
  
#line 2274 
  __retres = frag->page.p;
  
#line 2274 
  return __retres;
}


#line 2390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev, skb_frag_t const *frag, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t tmp_0;
  struct page *tmp;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  tmp = skb_frag_page(frag);
  
#line 2395 
  ;
  
#line 2395 
  tmp_0 = dma_map_page(dev,tmp,(unsigned long)frag->page_offset + offset,size,dir);
  
#line 2395 
  return tmp_0;
}


#line 2427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb, unsigned int headroom, int cloned)
{
  int __retres;
  unsigned int tmp_0;
  
#line 2430 
  int delta = 0;
  
#line 2432 
  tmp_0 = skb_headroom((struct sk_buff const *)skb);
  
#line 2432 
  ;
  
#line 2432 
  if (tmp_0 < headroom) {
    unsigned int tmp;
    
#line 2433 
    tmp = skb_headroom((struct sk_buff const *)skb);
    
#line 2433 
    delta = (int)(headroom - tmp);
  }
  else ;
  
#line 2435 
  if (delta != 0 || cloned != 0) {
    int tmp_5;
    int tmp_2;
    int tmp_4;
    {
      int tmp_1;
      
#line 2436 
      int _max1 = 32;
      
#line 2436 
      int _max2 = 64;
      
#line 2436 
      if (_max1 > _max2) 
#line 2436 
                         tmp_1 = _max1; else 
#line 2436 
                                             tmp_1 = _max2;
      
#line 2436 
      tmp_2 = tmp_1;
    }
    {
      int tmp_3;
      
#line 2436 
      int _max1_0 = 32;
      
#line 2436 
      int _max2_0 = 64;
      
#line 2436 
      if (_max1_0 > _max2_0) 
#line 2436 
                             tmp_3 = _max1_0; else 
#line 2436 
                                                   tmp_3 = _max2_0;
      
#line 2436 
      tmp_4 = tmp_3;
    }
    
#line 2436 
    ;
    
#line 2436 
    ;
    
#line 2436 
    tmp_5 = pskb_expand_head(skb,((tmp_2 + -1) + delta) & ~ (tmp_4 + -1),0,32U);
    
#line 2436 
    __retres = tmp_5;
    
#line 2436 
    goto return_label;
  }
  else ;
  
#line 2438 
  __retres = 0;
  return_label: 
#line 2438 
                return __retres;
}


#line 2468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
{
  int tmp_0;
  int tmp;
  
#line 2470 
  tmp = skb_header_cloned((struct sk_buff const *)skb);
  
#line 2470 
  ;
  
#line 2470 
  ;
  
#line 2470 
  tmp_0 = __skb_cow(skb,headroom,tmp);
  
#line 2470 
  return tmp_0;
}


#line 2865 
void skb_clone_tx_timestamp(struct sk_buff *);


#line 2911 
void skb_tstamp_tx(struct sk_buff *, struct skb_shared_hwtstamps *);


#line 2914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void sw_tx_timestamp(struct sk_buff *skb)
{
  unsigned char *tmp;
  
#line 2916 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2916 
  ;
  
#line 2916 
  if (((int)((struct skb_shared_info *)tmp)->tx_flags & 2) != 0) {
    unsigned char *tmp_0;
    
#line 2917 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2916 
    ;
    
#line 2916 
    if (((int)((struct skb_shared_info *)tmp_0)->tx_flags & 4) == 0) 
      
#line 2918 
      skb_tstamp_tx(skb,(struct skb_shared_hwtstamps *)0); else ;
  }
  else ;
  
#line 2919 
  return;
}


#line 2933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_tx_timestamp(struct sk_buff *skb)
{
  
#line 2935 
  skb_clone_tx_timestamp(skb);
  
#line 2936 
  sw_tx_timestamp(skb);
  
#line 2937 
  return;
}


#line 3295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff const *skb)
{
  u16 __retres;
  
#line 3297 
  __retres = skb->queue_mapping;
  
#line 3297 
  return __retres;
}


#line 3390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_gso_v6(struct sk_buff const *skb)
{
  bool __retres;
  unsigned char *tmp;
  
#line 3392 
  tmp = skb_end_pointer(skb);
  
#line 3392 
  ;
  
#line 3392 
  __retres = (_Bool)(((int)((struct skb_shared_info *)tmp)->gso_type & 16) != 0);
  
#line 3392 
  return __retres;
}


#line 3426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff const *skb)
{
  
#line 3428 
  return;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep, __u32 speed)
{
  
#line 117 
  ep->speed = (unsigned short)speed;
  
#line 118 
  ep->speed_hi = (unsigned short)(speed >> 16);
  
#line 119 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd const *ep)
{
  __u32 __retres;
  
#line 123 
  __retres = (unsigned int)(((int)ep->speed_hi << 16) | (int)ep->speed);
  
#line 123 
  return __retres;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
u32 ethtool_op_get_link(struct net_device *);


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
__inline static u32 ethtool_rxfh_indir_default(u32 index, u32 n_rx_rings)
{
  u32 __retres;
  
#line 97 
  __retres = index % n_rx_rings;
  
#line 97 
  return __retres;
}


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static struct mii_ioctl_data *if_mii(struct ifreq *rq)
{
  struct mii_ioctl_data *__retres;
  
#line 47 
  __retres = (struct mii_ioctl_data *)(& rq->ifr_ifru);
  
#line 47 
  return __retres;
}


#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u32 ethtool_adv_to_mii_adv_t(u32 ethadv)
{
  
#line 111 
  u32 result = 0U;
  
#line 113 
  if ((ethadv & 1U) != 0U) 
#line 114 
                           result |= 32U; else ;
  
#line 115 
  if ((ethadv & 2U) != 0U) 
#line 116 
                           result |= 64U; else ;
  
#line 117 
  if ((ethadv & 4U) != 0U) 
#line 118 
                           result |= 128U; else ;
  
#line 119 
  if ((ethadv & 8U) != 0U) 
#line 120 
                           result |= 256U; else ;
  
#line 121 
  if ((ethadv & 8192U) != 0U) 
#line 122 
                              result |= 1024U; else ;
  
#line 123 
  if ((ethadv & 16384U) != 0U) 
#line 124 
                               result |= 2048U; else ;
  
#line 126 
  return result;
}


#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u32 mii_adv_to_ethtool_adv_t(u32 adv)
{
  
#line 138 
  u32 result = 0U;
  
#line 140 
  if ((adv & 32U) != 0U) 
#line 141 
                         result |= 1U; else ;
  
#line 142 
  if ((adv & 64U) != 0U) 
#line 143 
                         result |= 2U; else ;
  
#line 144 
  if ((adv & 128U) != 0U) 
#line 145 
                          result |= 4U; else ;
  
#line 146 
  if ((adv & 256U) != 0U) 
#line 147 
                          result |= 8U; else ;
  
#line 148 
  if ((adv & 1024U) != 0U) 
#line 149 
                           result |= 8192U; else ;
  
#line 150 
  if ((adv & 2048U) != 0U) 
#line 151 
                           result |= 16384U; else ;
  
#line 153 
  return result;
}


#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u32 ethtool_adv_to_mii_ctrl1000_t(u32 ethadv)
{
  
#line 166 
  u32 result = 0U;
  
#line 168 
  if ((ethadv & 16U) != 0U) 
#line 169 
                            result |= 256U; else ;
  
#line 170 
  if ((ethadv & 32U) != 0U) 
#line 171 
                            result |= 512U; else ;
  
#line 173 
  return result;
}


#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u32 mii_ctrl1000_to_ethtool_adv_t(u32 adv)
{
  
#line 186 
  u32 result = 0U;
  
#line 188 
  if ((adv & 256U) != 0U) 
#line 189 
                          result |= 16U; else ;
  
#line 190 
  if ((adv & 512U) != 0U) 
#line 191 
                          result |= 32U; else ;
  
#line 193 
  return result;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u32 mii_lpa_to_ethtool_lpa_t(u32 lpa)
{
  u32 __retres;
  u32 tmp;
  
#line 206 
  u32 result = 0U;
  
#line 208 
  if ((lpa & 16384U) != 0U) 
#line 209 
                            result |= 64U; else ;
  
#line 211 
  tmp = mii_adv_to_ethtool_adv_t(lpa);
  
#line 211 
  ;
  
#line 211 
  __retres = tmp | result;
  
#line 211 
  return __retres;
}


#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u32 mii_stat1000_to_ethtool_lpa_t(u32 lpa)
{
  
#line 224 
  u32 result = 0U;
  
#line 226 
  if ((lpa & 1024U) != 0U) 
#line 227 
                           result |= 16U; else ;
  
#line 228 
  if ((lpa & 2048U) != 0U) 
#line 229 
                           result |= 32U; else ;
  
#line 231 
  return result;
}


#line 242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u32 ethtool_adv_to_mii_adv_x(u32 ethadv)
{
  
#line 244 
  u32 result = 0U;
  
#line 246 
  if ((ethadv & 16U) != 0U) 
#line 247 
                            result |= 64U; else ;
  
#line 248 
  if ((ethadv & 32U) != 0U) 
#line 249 
                            result |= 32U; else ;
  
#line 250 
  if ((ethadv & 8192U) != 0U) 
#line 251 
                              result |= 128U; else ;
  
#line 252 
  if ((ethadv & 16384U) != 0U) 
#line 253 
                               result |= 256U; else ;
  
#line 255 
  return result;
}


#line 266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u32 mii_adv_to_ethtool_adv_x(u32 adv)
{
  
#line 268 
  u32 result = 0U;
  
#line 270 
  if ((adv & 64U) != 0U) 
#line 271 
                         result |= 16U; else ;
  
#line 272 
  if ((adv & 32U) != 0U) 
#line 273 
                         result |= 32U; else ;
  
#line 274 
  if ((adv & 128U) != 0U) 
#line 275 
                          result |= 8192U; else ;
  
#line 276 
  if ((adv & 256U) != 0U) 
#line 277 
                          result |= 16384U; else ;
  
#line 279 
  return result;
}


#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u16 mii_advertise_flowctrl(int cap)
{
  
#line 306 
  u16 adv = (unsigned short)0U;
  
#line 308 
  if ((cap & 2) != 0) 
#line 309 
                      adv = (unsigned short)3072U; else ;
  
#line 310 
  if ((cap & 1) != 0) 
#line 311 
                      adv = (unsigned short)((unsigned int)adv ^ 2048U); else ;
  
#line 313 
  return adv;
}


#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static u8 mii_resolve_flowctrl_fdx(u16 lcladv, u16 rmtadv)
{
  
#line 325 
  u8 cap = (unsigned char)0U;
  
#line 327 
  if ((((int)lcladv & (int)rmtadv) & 1024) != 0) 
#line 328 
                                                 cap = (unsigned char)3U;
  else 
    
#line 329 
    if ((((int)lcladv & (int)rmtadv) & 2048) != 0) {
      
#line 330 
      if (((int)lcladv & 1024) != 0) 
#line 331 
                                     cap = (unsigned char)2U;
      else 
        
#line 332 
        if (((int)rmtadv & 1024) != 0) 
#line 333 
                                       cap = (unsigned char)1U; else ;
    }
    else ;
  
#line 336 
  return cap;
}


#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus *mdiobus_alloc_size(size_t);


#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
__inline static struct mii_bus *mdiobus_alloc(void)
{
  struct mii_bus *tmp;
  
#line 198 
  tmp = mdiobus_alloc_size(0UL);
  
#line 198 
  return tmp;
}


#line 201 
int mdiobus_register(struct mii_bus *);


#line 202 
void mdiobus_unregister(struct mii_bus *);


#line 203 
void mdiobus_free(struct mii_bus *);


#line 742 
struct phy_device *phy_connect(struct net_device *, char const *, void (*)(struct net_device *), phy_interface_t);


#line 745 
void phy_disconnect(struct phy_device *);


#line 747 
void phy_start(struct phy_device *);


#line 748 
void phy_stop(struct phy_device *);


#line 749 
int phy_start_aneg(struct phy_device *);


#line 777 
int phy_ethtool_sset(struct phy_device *, struct ethtool_cmd *);


#line 778 
int phy_ethtool_gset(struct phy_device *, struct ethtool_cmd *);


#line 779 
int phy_mii_ioctl(struct phy_device *, struct ifreq *, int);


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __napi_schedule(struct napi_struct *);


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n)
{
  bool __retres;
  int tmp;
  
#line 396 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& n->state));
  
#line 396 
  __retres = (_Bool)(tmp != 0);
  
#line 396 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n)
{
  bool __retres;
  int tmp_2;
  int tmp_0;
  bool tmp;
  
#line 410 
  tmp = napi_disable_pending(n);
  
#line 410 
  if (tmp) 
#line 410 
           tmp_0 = 0; else 
#line 410 
                           tmp_0 = 1;
  
#line 410 
  if (tmp_0) {
    int tmp_1;
    
#line 410 
    tmp_1 = test_and_set_bit(0L,(unsigned long volatile *)(& n->state));
    
#line 410 
    if (tmp_1 == 0) 
#line 410 
                    tmp_2 = 1; else 
#line 410 
                                    tmp_2 = 0;
  }
  else 
#line 410 
       tmp_2 = 0;
  
#line 410 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 410 
  return __retres;
}


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n)
{
  bool tmp;
  
#line 423 
  tmp = napi_schedule_prep(n);
  
#line 423 
  if ((int)tmp != 0) 
#line 424 
                     __napi_schedule(n); else ;
  
#line 425 
  return;
}


#line 450 
void napi_complete_done(struct napi_struct *, int);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n)
{
  
#line 460 
  napi_complete_done(n,0);
  
#line 461 
  return;
}


#line 496 
void napi_disable(struct napi_struct *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  int tmp;
  
#line 507 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& n->state));
  
#line 507 
  if ((long)(tmp == 0) != 0L) {
    
#line 509 
    ldv_inline_asm();
    
#line 507 
    ;
  }
  else ;
  
#line 509 
  ldv_inline_asm();
  
#line 509 
  set_bit(0L,(unsigned long volatile *)(& n->state));
  
#line 510 
  return;
}


#line 1822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev, unsigned int index)
{
  struct netdev_queue *__retres;
  
#line 1825 
  __retres = dev->_tx + index;
  
#line 1825 
  return __retres;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device const *dev)
{
  void *__retres;
  
#line 1882 
  __retres = (void *)dev + 3008U;
  
#line 1882 
  return __retres;
}


#line 1911 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);


#line 1920 
void netif_napi_del(struct napi_struct *);


#line 2183 
int dev_close(struct net_device *);


#line 2205 
static void ldv_free_netdev_132(struct net_device *ldv_func_arg1);


#line 2209 
static void ldv_free_netdev_134(struct net_device *ldv_func_arg1);


#line 2505 
void netif_schedule_queue(struct netdev_queue *);


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  
#line 2517 
  set_bit(0L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2518 
  return;
}


#line 2531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2535 
  i = 0U;
  
#line 2535 
  goto ldv_45054;
  ldv_45053: 
#line 2536 
  ;
  {
    
#line 2536 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2537 
    netif_tx_start_queue(txq);
  }
  
#line 2535 
  i += 1U;
  ldv_45054: 
#line 2536 
  ;
  
#line 2535 
  if (dev->num_tx_queues > i) 
#line 2537 
                              goto ldv_45053; else 
#line 2540 
                                                   goto ldv_45055;
  ldv_45055: 
#line 2541 
  ;
  
#line 2542 
  return;
}


#line 2541 
void netif_tx_wake_queue(struct netdev_queue *);


#line 2555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2559 
  i = 0U;
  
#line 2559 
  goto ldv_45067;
  ldv_45066: 
#line 2560 
  ;
  {
    
#line 2560 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2561 
    netif_tx_wake_queue(txq);
  }
  
#line 2559 
  i += 1U;
  ldv_45067: 
#line 2560 
  ;
  
#line 2559 
  if (dev->num_tx_queues > i) 
#line 2561 
                              goto ldv_45066; else 
#line 2564 
                                                   goto ldv_45068;
  ldv_45068: 
#line 2565 
  ;
  
#line 2566 
  return;
}


#line 2584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  int tmp;
  
#line 2586 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev_queue->state));
  
#line 2586 
  __retres = (_Bool)(tmp != 0);
  
#line 2586 
  return __retres;
}


#line 2600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_xmit_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  
#line 2602 
  __retres = (_Bool)((dev_queue->state & 3UL) != 0UL);
  
#line 2602 
  return __retres;
}


#line 2645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2649 
  dql_queued(& dev_queue->dql,bytes);
  
#line 2651 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2651 
  if ((long)(tmp >= 0) != 0L) 
#line 2652 
                              goto return_label; else ;
  
#line 2654 
  set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2655 
  ldv_inline_asm();
  
#line 2664 
  tmp_0 = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2664 
  if ((long)(tmp_0 >= 0) != 0L) 
#line 2665 
                                set_bit(1L,(unsigned long volatile *)(& dev_queue->state)); else ;
  return_label: 
#line 2666 
                return;
}


#line 2683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue, unsigned int pkts, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2687 
  if ((long)(bytes == 0U) != 0L) 
#line 2688 
                                 goto return_label; else ;
  
#line 2690 
  dql_completed(& dev_queue->dql,bytes);
  
#line 2691 
  ldv_inline_asm();
  
#line 2699 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2699 
  if (tmp < 0) 
#line 2700 
               goto return_label; else ;
  
#line 2702 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2702 
  if (tmp_0 != 0) 
#line 2703 
                  netif_schedule_queue(dev_queue); else ;
  return_label: 
#line 2704 
                return;
}


#line 2723  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q)
{
  
#line 2726 
  set_bit(1L,(unsigned long volatile *)(& q->state));
  
#line 2727 
  dql_reset(& q->dql);
  
#line 2728 
  return;
}


#line 2769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 2771 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev->state));
  
#line 2771 
  __retres = (_Bool)(tmp != 0);
  
#line 2771 
  return __retres;
}


#line 2867 
int netif_set_real_num_tx_queues(struct net_device *, unsigned int);


#line 2870 
int netif_set_real_num_rx_queues(struct net_device *, unsigned int);


#line 2892 
int netif_get_num_default_rss_queues(void);


#line 2900 
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);


#line 2931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  
#line 2933 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2934 
  return;
}


#line 2948 
gro_result_t napi_gro_receive(struct napi_struct *, struct sk_buff *);


#line 3038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 3040 
  tmp = constant_test_bit(2L,(unsigned long const volatile *)(& dev->state));
  
#line 3040 
  __retres = (_Bool)(tmp == 0);
  
#line 3040 
  return __retres;
}


#line 3047 
void netif_carrier_on(struct net_device *);


#line 3049 
void netif_carrier_off(struct net_device *);


#line 3117 
void netif_device_detach(struct net_device *);


#line 3119 
void netif_device_attach(struct net_device *);


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_60(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_63(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3287 
  local_bh_disable();
  {
    int pscr_ret__;
    {
      
#line 3288 
      void const *__vpp_verify = (void const *)0;
      
#line 3288 
      void const *tmp = __vpp_verify;
    }
    
#line 3288 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3288 
      ;
      {
        int pfo_ret__;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45628;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45628;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45628;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45628;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45628: 
#line 3288 
        ;
        
#line 3288 
        tmp_0 = pfo_ret__;
      }
      
#line 3288 
      pscr_ret__ = tmp_0;
      
#line 3288 
      goto ldv_45634;
      case (unsigned long)2: 
#line 3288 
      ;
      {
        int pfo_ret___0;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45638;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45638;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45638;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45638;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45638: 
#line 3288 
        ;
        
#line 3288 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3288 
      pscr_ret__ = tmp_0_0;
      
#line 3288 
      goto ldv_45634;
      case (unsigned long)4: 
#line 3288 
      ;
      {
        int pfo_ret___1;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45647;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45647;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45647;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45647;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45647: 
#line 3288 
        ;
        
#line 3288 
        tmp_1 = pfo_ret___1;
      }
      
#line 3288 
      pscr_ret__ = tmp_1;
      
#line 3288 
      goto ldv_45634;
      case (unsigned long)8: 
#line 3288 
      ;
      {
        int pfo_ret___2;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45656;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45656;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45656;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45656;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45656: 
#line 3288 
        ;
        
#line 3288 
        tmp_2 = pfo_ret___2;
      }
      
#line 3288 
      pscr_ret__ = tmp_2;
      
#line 3288 
      goto ldv_45634;
      default: 
#line 3288 
      ;
      
#line 3288 
      __bad_size_call_parameter();
      
#line 3288 
      goto ldv_45634;
    }
    ldv_45634: 
#line 3288 
    ;
    
#line 3288 
    tmp_3 = pscr_ret__;
  }
  
#line 3288 
  cpu = tmp_3;
  
#line 3289 
  i = 0U;
  
#line 3289 
  goto ldv_45666;
  ldv_45665: 
#line 3290 
  ;
  {
    
#line 3290 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3292 
    __netif_tx_lock(txq,cpu);
    
#line 3293 
    netif_tx_start_queue(txq);
    
#line 3294 
    __netif_tx_unlock(txq);
  }
  
#line 3289 
  i += 1U;
  ldv_45666: 
#line 3290 
  ;
  
#line 3289 
  if (dev->num_tx_queues > i) 
#line 3291 
                              goto ldv_45665; else 
#line 3294 
                                                   goto ldv_45667;
  ldv_45667: 
#line 3295 
  ;
  
#line 3296 
  local_bh_enable();
  
#line 3297 
  return;
}


#line 3355 
static int ldv_register_netdev_131(struct net_device *ldv_func_arg1);


#line 3360 
static void ldv_unregister_netdev_133(struct net_device *ldv_func_arg1);


#line 3549 
void netdev_rss_key_fill(void *, size_t);


#line 3553 
int skb_checksum_help(struct sk_buff *);


#line 3554 
struct sk_buff *__skb_gso_segment(struct sk_buff *, netdev_features_t, bool);


#line 3573  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct sk_buff *skb_gso_segment(struct sk_buff *skb, netdev_features_t features)
{
  struct sk_buff *tmp;
  
#line 3575 
  tmp = __skb_gso_segment(skb,features,(_Bool)1);
  
#line 3575 
  return tmp;
}


#line 3683 
void netdev_update_features(struct net_device *);


#line 3828 
void netdev_err(struct net_device const *, char const * , ...);


#line 3830 
void netdev_warn(struct net_device const *, char const * , ...);


#line 3832 
void netdev_notice(struct net_device const *, char const * , ...);


#line 3834 
void netdev_info(struct net_device const *, char const * , ...);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__be16 eth_type_trans(struct sk_buff *, struct net_device *);


#line 47 
int eth_validate_addr(struct net_device *);


#line 53 
static struct net_device *ldv_alloc_etherdev_mqs_130(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 96 
  __retres = (_Bool)((*((u32 const *)addr) | (unsigned int)*((u16 const *)(addr + 4U))) == 0U);
  
#line 96 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_3;
  int tmp_0;
  bool tmp;
  
#line 190 
  tmp = is_multicast_ether_addr(addr);
  
#line 190 
  if (tmp) 
#line 190 
           tmp_0 = 0; else 
#line 190 
                           tmp_0 = 1;
  
#line 190 
  if (tmp_0) {
    int tmp_2;
    bool tmp_1;
    
#line 190 
    tmp_1 = is_zero_ether_addr(addr);
    
#line 190 
    if (tmp_1) 
#line 190 
               tmp_2 = 0; else 
#line 190 
                               tmp_2 = 1;
    
#line 190 
    if (tmp_2) 
#line 190 
               tmp_3 = 1; else 
#line 190 
                               tmp_3 = 0;
  }
  else 
#line 190 
       tmp_3 = 0;
  
#line 190 
  __retres = (_Bool)(tmp_3 != 0);
  
#line 190 
  return __retres;
}


#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mdio.h"
__inline static u32 mmd_eee_adv_to_ethtool_adv_t(u16 eee_adv)
{
  
#line 130 
  u32 adv = 0U;
  
#line 132 
  if (((int)eee_adv & 2) != 0) 
#line 133 
                               adv |= 8U; else ;
  
#line 134 
  if (((int)eee_adv & 4) != 0) 
#line 135 
                               adv |= 32U; else ;
  
#line 136 
  if (((int)eee_adv & 8) != 0) 
#line 137 
                               adv |= 4096U; else ;
  
#line 138 
  if (((int)eee_adv & 16) != 0) 
#line 139 
                                adv |= 131072U; else ;
  
#line 140 
  if (((int)eee_adv & 32) != 0) 
#line 141 
                                adv |= 262144U; else ;
  
#line 142 
  if (((int)eee_adv & 64) != 0) 
#line 143 
                                adv |= 524288U; else ;
  
#line 145 
  return adv;
}


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
void rtnl_lock(void);


#line 28 
void rtnl_unlock(void);


#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)
{
  
#line 412 
  skb->vlan_proto = vlan_proto;
  
#line 413 
  skb->vlan_tci = (unsigned short)((unsigned int)vlan_tci | 4096U);
  
#line 414 
  return;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 25 
  tmp = (struct iphdr *)skb_network_header(skb);
  
#line 25 
  return tmp;
}


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static struct tcphdr *tcp_hdr(struct sk_buff const *skb)
{
  struct tcphdr *tmp;
  
#line 29 
  tmp = (struct tcphdr *)skb_transport_header(skb);
  
#line 29 
  return tmp;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static unsigned int tcp_hdrlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  struct tcphdr *tmp;
  
#line 34 
  tmp = tcp_hdr(skb);
  
#line 34 
  ;
  
#line 34 
  __retres = (unsigned int)((int)tmp->doff * 4);
  
#line 34 
  return __retres;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static unsigned int tcp_optlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  struct tcphdr *tmp;
  
#line 49 
  tmp = tcp_hdr(skb);
  
#line 49 
  ;
  
#line 49 
  __retres = (unsigned int)(((int)tmp->doff + -5) * 4);
  
#line 49 
  return __retres;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/firmware.h"
int request_firmware(struct firmware const **, char const *, struct device *);


#line 51 
void release_firmware(struct firmware const *);


#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ssb/ssb_driver_gige.h"
__inline static bool pdev_is_ssb_gige_core(struct pci_dev *pdev)
{
  bool __retres;
  
#line 161 
  __retres = (_Bool)0;
  
#line 161 
  return __retres;
}


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ssb/ssb_driver_gige.h"
__inline static int ssb_gige_get_macaddr(struct pci_dev *pdev, u8 *macaddr)
{
  int __retres;
  
#line 185 
  __retres = -19;
  
#line 185 
  return __retres;
}


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ssb/ssb_driver_gige.h"
__inline static int ssb_gige_get_phyaddr(struct pci_dev *pdev)
{
  int __retres;
  
#line 189 
  __retres = -19;
  
#line 189 
  return __retres;
}


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hwmon.h"
struct device *hwmon_device_register_with_groups(struct device *, char const *, void *, struct attribute_group const **);


#line 30 
void hwmon_device_unregister(struct device *);


#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock *ptp_clock_register(struct ptp_clock_info *, struct device *);


#line 133 
int ptp_clock_unregister(struct ptp_clock *);


#line 177 
int ptp_clock_index(struct ptp_clock *);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static int _tg3_flag(enum TG3_FLAGS flag, unsigned long *bits)
{
  int tmp_1;
  
#line 75 
  if (0 != 0) 
#line 75 
              tmp_1 = constant_test_bit((long)flag,(unsigned long const volatile *)bits); else 
                                                                    
#line 75 
                                                                    tmp_1 = variable_test_bit((long)flag,(unsigned long const volatile *)bits);
  
#line 75 
  return tmp_1;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void _tg3_flag_set(enum TG3_FLAGS flag, unsigned long *bits)
{
  
#line 80 
  set_bit((long)flag,(unsigned long volatile *)bits);
  
#line 81 
  return;
}


#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static char version[28U] = {(char)'t', (char)'g', (char)'3', (char)'\000'};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_debug = -1;

#line 240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct pci_device_id const tg3_pci_tbl[97U] = {{.vendor = 5348U, .device = 5700U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5701U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5702U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5703U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5704U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5709U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5715U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5716U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5725U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5726U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5798U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5799U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5800U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5830U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5831U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5782U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5788U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5789U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5901U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 3UL}, {.vendor = 5348U, .device = 5902U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 3UL}, {.vendor = 5348U, .device = 5705U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5742U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 3UL}, {.vendor = 5348U, .device = 5721U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5722U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5750U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5751U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5757U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5758U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5632U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5633U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5879U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5885U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5886U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5754U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5746U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5755U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5747U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5748U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5786U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5787U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5779U, .subvendor = 6058U, .subdevice = 12374U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5779U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5759U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5736U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5737U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5752U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5753U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5738U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5739U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5853U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5906U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5907U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5784U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5764U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5723U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5761U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5760U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5768U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5769U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5785U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5792U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5778U, .subvendor = 4133U, .subdevice = 1537U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5778U, .subvendor = 4133U, .subdevice = 1554U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5778U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5776U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5780U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5777U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5717U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5733U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5718U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5809U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5813U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5808U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5812U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5810U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5814U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 1UL}, {.vendor = 5348U, .device = 5719U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5727U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5762U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5766U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5767U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5699U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5875U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5698U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5763U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5697U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5815U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5348U, .device = 5811U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 4424U, .device = 17408U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 4424U, .device = 17664U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5947U, .device = 1000U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5947U, .device = 1001U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5947U, .device = 1003U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 5947U, .device = 1002U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 4203U, .device = 5701U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 4303U, .device = 4514U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 359  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
struct pci_device_id const __mod_pci__tg3_pci_tbl_device_table[97U];

#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct __anonstruct_ethtool_stats_keys_394 const ethtool_stats_keys[72U] = {{.string = {(char)'r', (char)'x', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'r', (char)'a', (char)'g', (char)'m', (char)'e', (char)'n', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'c', (char)'a', (char)'s', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'c', (char)'a', (char)'s', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'c', (char)'a', (char)'s', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'c', (char)'s', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'a', (char)'l', (char)'i', (char)'g', (char)'n', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'p', (char)'a', (char)'u', (char)'s', (char)'e', (char)'_', (char)'r', (char)'c', (char)'v', (char)'d', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'p', (char)'a', (char)'u', (char)'s', (char)'e', (char)'_', (char)'r', (char)'c', (char)'v', (char)'d', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'a', (char)'c', (char)'_', (char)'c', (char)'t', (char)'r', (char)'l', (char)'_', (char)'r', (char)'c', (char)'v', (char)'d', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'e', (char)'n', (char)'t', (char)'e', (char)'r', (char)'e', (char)'d', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'r', (char)'a', (char)'m', (char)'e', (char)'_', (char)'t', (char)'o', (char)'o', (char)'_', (char)'l', (char)'o', (char)'n', (char)'g', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'j', (char)'a', (char)'b', (char)'b', (char)'e', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'i', (char)'n', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'o', (char)'u', (char)'t', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'6', (char)'4', (char)'_', (char)'o', (char)'r', (char)'_', (char)'l', (char)'e', (char)'s', (char)'s', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'6', (char)'5', (char)'_', (char)'t', (char)'o', (char)'_', (char)'1', (char)'2', (char)'7', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'1', (char)'2', (char)'8', (char)'_', (char)'t', (char)'o', (char)'_', (char)'2', (char)'5', (char)'5', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'2', (char)'5', (char)'6', (char)'_', (char)'t', (char)'o', (char)'_', (char)'5', (char)'1', (char)'1', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'5', (char)'1', (char)'2', (char)'_', (char)'t', (char)'o', (char)'_', (char)'1', (char)'0', (char)'2', (char)'3', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'1', (char)'0', (char)'2', (char)'4', (char)'_', (char)'t', (char)'o', (char)'_', (char)'1', (char)'5', (char)'2', (char)'2', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'1', (char)'5', (char)'2', (char)'3', (char)'_', (char)'t', (char)'o', (char)'_', (char)'2', (char)'0', (char)'4', (char)'7', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'2', (char)'0', (char)'4', (char)'8', (char)'_', (char)'t', (char)'o', (char)'_', (char)'4', (char)'0', (char)'9', (char)'5', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'4', (char)'0', (char)'9', (char)'6', (char)'_', (char)'t', (char)'o', (char)'_', (char)'8', (char)'1', (char)'9', (char)'1', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'8', (char)'1', (char)'9', (char)'2', (char)'_', (char)'t', (char)'o', (char)'_', (char)'9', (char)'0', (char)'2', (char)'2', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'o', (char)'c', (char)'t', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'s', (char)'e', (char)'n', (char)'t', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'s', (char)'e', (char)'n', (char)'t', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'a', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'n', (char)'g', (char)'l', (char)'e', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'f', (char)'e', (char)'r', (char)'r', (char)'e', (char)'d', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'x', (char)'c', (char)'e', (char)'s', (char)'s', (char)'i', (char)'v', (char)'e', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'l', (char)'a', (char)'t', (char)'e', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'2', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'3', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'4', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'5', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'6', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'7', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'8', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'9', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'1', (char)'0', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'1', (char)'1', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'1', (char)'2', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'1', (char)'3', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'1', (char)'4', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'d', (char)'e', (char)'_', (char)'1', (char)'5', (char)'t', (char)'i', (char)'m', (char)'e', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'u', (char)'c', (char)'a', (char)'s', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'c', (char)'a', (char)'s', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'c', (char)'a', (char)'s', (char)'t', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'a', (char)'r', (char)'r', (char)'i', (char)'e', (char)'r', (char)'_', (char)'s', (char)'e', (char)'n', (char)'s', (char)'e', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'i', (char)'s', (char)'c', (char)'a', (char)'r', (char)'d', (char)'s', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'d', (char)'m', (char)'a', (char)'_', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'q', (char)'_', (char)'f', (char)'u', (char)'l', (char)'l', (char)'\000'}}, {.string = {(char)'d', (char)'m', (char)'a', (char)'_', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'_', (char)'p', (char)'r', (char)'i', (char)'o', (char)'q', (char)'_', (char)'f', (char)'u', (char)'l', (char)'l', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'b', (char)'d', (char)'s', (char)'_', (char)'e', (char)'m', (char)'p', (char)'t', (char)'y', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'d', (char)'i', (char)'s', (char)'c', (char)'a', (char)'r', (char)'d', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}}, {.string = {(char)'r', (char)'x', (char)'_', (char)'t', (char)'h', (char)'r', (char)'e', (char)'s', (char)'h', (char)'o', (char)'l', (char)'d', (char)'_', (char)'h', (char)'i', (char)'t', (char)'\000'}}, {.string = {(char)'d', (char)'m', (char)'a', (char)'_', (char)'r', (char)'e', (char)'a', (char)'d', (char)'q', (char)'_', (char)'f', (char)'u', (char)'l', (char)'l', (char)'\000'}}, {.string = {(char)'d', (char)'m', (char)'a', (char)'_', (char)'r', (char)'e', (char)'a', (char)'d', (char)'_', (char)'p', (char)'r', (char)'i', (char)'o', (char)'q', (char)'_', (char)'f', (char)'u', (char)'l', (char)'l', (char)'\000'}}, {.string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'o', (char)'m', (char)'p', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'_', (char)'f', (char)'u', (char)'l', (char)'l', (char)'\000'}}, {.string = {(char)'r', (char)'i', (char)'n', (char)'g', (char)'_', (char)'s', (char)'e', (char)'t', (char)'_', (char)'s', (char)'e', (char)'n', (char)'d', (char)'_', (char)'p', (char)'r', (char)'o', (char)'d', (char)'_', (char)'i', (char)'n', (char)'d', (char)'e', (char)'x', (char)'\000'}}, {.string = {(char)'r', (char)'i', (char)'n', (char)'g', (char)'_', (char)'s', (char)'t', (char)'a', (char)'t', (char)'u', (char)'s', (char)'_', (char)'u', (char)'p', (char)'d', (char)'a', (char)'t', (char)'e', (char)'\000'}}, {.string = {(char)'n', (char)'i', (char)'c', (char)'_', (char)'i', (char)'r', (char)'q', (char)'s', (char)'\000'}}, {.string = {(char)'n', (char)'i', (char)'c', (char)'_', (char)'a', (char)'v', (char)'o', (char)'i', (char)'d', (char)'e', (char)'d', (char)'_', (char)'i', (char)'r', (char)'q', (char)'s', (char)'\000'}}, {.string = {(char)'n', (char)'i', (char)'c', (char)'_', (char)'t', (char)'x', (char)'_', (char)'t', (char)'h', (char)'r', (char)'e', (char)'s', (char)'h', (char)'o', (char)'l', (char)'d', (char)'_', (char)'h', (char)'i', (char)'t', (char)'\000'}}, {.string = {(char)'m', (char)'b', (char)'u', (char)'f', (char)'_', (char)'l', (char)'w', (char)'m', (char)'_', (char)'t', (char)'h', (char)'r', (char)'e', (char)'s', (char)'h', (char)'_', (char)'h', (char)'i', (char)'t', (char)'\000'}}};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct __anonstruct_ethtool_test_keys_395 const ethtool_test_keys[8U] = {{.string = {(char)'n', (char)'v', (char)'r', (char)'a', (char)'m', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'n', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)' ', (char)'\000'}}, {.string = {(char)'l', (char)'i', (char)'n', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'n', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)' ', (char)'\000'}}, {.string = {(char)'r', (char)'e', (char)'g', (char)'i', (char)'s', (char)'t', (char)'e', (char)'r', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}}, {.string = {(char)'m', (char)'e', (char)'m', (char)'o', (char)'r', (char)'y', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}}, {.string = {(char)'m', (char)'a', (char)'c', (char)' ', (char)'l', (char)'o', (char)'o', (char)'p', (char)'b', (char)'a', (char)'c', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}}, {.string = {(char)'p', (char)'h', (char)'y', (char)' ', (char)'l', (char)'o', (char)'o', (char)'p', (char)'b', (char)'a', (char)'c', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}}, {.string = {(char)'e', (char)'x', (char)'t', (char)' ', (char)'l', (char)'o', (char)'o', (char)'p', (char)'b', (char)'a', (char)'c', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}}, {.string = {(char)'i', (char)'n', (char)'t', (char)'e', (char)'r', (char)'r', (char)'u', (char)'p', (char)'t', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}}};

#line 471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write32(struct tg3 *tp, u32 off, u32 val)
{
  
#line 473 
  writel(val,(void volatile *)(tp->regs + off));
  
#line 474 
  return;
}


#line 476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_read32(struct tg3 *tp, u32 off)
{
  u32 tmp;
  
#line 478 
  tmp = readl((void const volatile *)(tp->regs + off));
  
#line 478 
  return tmp;
}


#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ape_write32(struct tg3 *tp, u32 off, u32 val)
{
  
#line 483 
  writel(val,(void volatile *)(tp->aperegs + off));
  
#line 484 
  return;
}


#line 486  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_ape_read32(struct tg3 *tp, u32 off)
{
  u32 tmp;
  
#line 488 
  tmp = readl((void const volatile *)(tp->aperegs + off));
  
#line 488 
  return tmp;
}


#line 491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write_indirect_reg32(struct tg3 *tp, u32 off, u32 val)
{
  unsigned long flags;
  
#line 495 
  ldv___ldv_spin_lock_74(& tp->indirect_lock);
  
#line 496 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,120,off);
  
#line 497 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,128,val);
  
#line 498 
  ldv_spin_unlock_irqrestore_75(& tp->indirect_lock,flags);
  
#line 499 
  return;
}


#line 501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write_flush_reg32(struct tg3 *tp, u32 off, u32 val)
{
  
#line 503 
  writel(val,(void volatile *)(tp->regs + off));
  
#line 504 
  readl((void const volatile *)(tp->regs + off));
  
#line 505 
  return;
}


#line 507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_read_indirect_reg32(struct tg3 *tp, u32 off)
{
  unsigned long flags;
  u32 val;
  
#line 512 
  ldv___ldv_spin_lock_76(& tp->indirect_lock);
  
#line 513 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,120,off);
  
#line 514 
  pci_read_config_dword((struct pci_dev const *)tp->pdev,128,& val);
  
#line 515 
  ldv_spin_unlock_irqrestore_77(& tp->indirect_lock,flags);
  
#line 516 
  return val;
}


#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write_indirect_mbox(struct tg3 *tp, u32 off, u32 val)
{
  unsigned long flags;
  
#line 523 
  if (off == 644U) {
    
#line 524 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,164,val);
    
#line 526 
    goto return_label;
  }
  else ;
  
#line 528 
  if (off == 620U) {
    
#line 529 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,156,val);
    
#line 531 
    goto return_label;
  }
  else ;
  
#line 534 
  ldv___ldv_spin_lock_78(& tp->indirect_lock);
  
#line 535 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,120,off + 22016U);
  
#line 536 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,128,val);
  
#line 537 
  ldv_spin_unlock_irqrestore_79(& tp->indirect_lock,flags);
  
#line 542 
  if (off == 516U && val == 1U) 
#line 544 
                                pci_write_config_dword((struct pci_dev const *)tp->pdev,144,tp->grc_local_ctrl | 2U); else ;
  return_label: 
#line 546 
                return;
}


#line 549  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_read_indirect_mbox(struct tg3 *tp, u32 off)
{
  unsigned long flags;
  u32 val;
  
#line 554 
  ldv___ldv_spin_lock_80(& tp->indirect_lock);
  
#line 555 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,120,off + 22016U);
  
#line 556 
  pci_read_config_dword((struct pci_dev const *)tp->pdev,128,& val);
  
#line 557 
  ldv_spin_unlock_irqrestore_81(& tp->indirect_lock,flags);
  
#line 558 
  return val;
}


#line 566  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void _tw32_flush(struct tg3 *tp, u32 off, u32 val, u32 usec_wait)
{
  int tmp;
  
#line 568 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_TARGET_HWBUG,(unsigned long *)(& tp->tg3_flags));
  
#line 568 
  if (tmp != 0) 
#line 568 
                goto _LOR;
  else {
    int tmp_0;
    
#line 568 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ICH_WORKAROUND,(unsigned long *)(& tp->tg3_flags));
    
#line 568 
    if (tmp_0 != 0) _LOR: 
#line 570 
                          (*(tp->write32))(tp,off,val);
    else {
      
#line 573 
      tg3_write32(tp,off,val);
      
#line 574 
      if (usec_wait != 0U) 
        
#line 575 
        if (0 != 0) 
          
#line 575 
          if (usec_wait > 19999U) 
#line 575 
                                  __bad_udelay(); else 
#line 575 
                                                       __const_udelay((unsigned long)usec_wait * 4295UL);
        else 
#line 575 
             __udelay((unsigned long)usec_wait);
      else ;
      
#line 576 
      (*(tp->read32))(tp,off);
    }
  }
  
#line 581 
  if (usec_wait != 0U) 
    
#line 582 
    if (0 != 0) 
      
#line 582 
      if (usec_wait > 19999U) 
#line 582 
                              __bad_udelay(); else 
#line 582 
                                                   __const_udelay((unsigned long)usec_wait * 4295UL);
    else 
#line 582 
         __udelay((unsigned long)usec_wait);
  else ;
  
#line 584 
  return;
}


#line 585  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tw32_mailbox_flush(struct tg3 *tp, u32 off, u32 val)
{
  int tmp;
  
#line 587 
  (*(tp->write32_mbox))(tp,off,val);
  
#line 588 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLUSH_POSTED_WRITES,(unsigned long *)(& tp->tg3_flags));
  
#line 588 
  if (tmp != 0) 
#line 591 
                (*(tp->read32_mbox))(tp,off);
  else {
    int tmp_0;
    
#line 588 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MBOX_WRITE_REORDER,(unsigned long *)(& tp->tg3_flags));
    
#line 588 
    if (tmp_0 == 0) {
      int tmp_1;
      
#line 589 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ICH_WORKAROUND,(unsigned long *)(& tp->tg3_flags));
      
#line 589 
      if (tmp_1 == 0) 
#line 591 
                      (*(tp->read32_mbox))(tp,off); else ;
    }
    else ;
  }
  
#line 592 
  return;
}


#line 594  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write32_tx_mbox(struct tg3 *tp, u32 off, u32 val)
{
  int tmp;
  int tmp_0;
  
#line 596 
  void *mbox = tp->regs + off;
  
#line 597 
  writel(val,(void volatile *)mbox);
  
#line 598 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TXD_MBOX_HWBUG,(unsigned long *)(& tp->tg3_flags));
  
#line 598 
  if (tmp != 0) 
#line 599 
                writel(val,(void volatile *)mbox); else ;
  
#line 600 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MBOX_WRITE_REORDER,(unsigned long *)(& tp->tg3_flags));
  
#line 600 
  if (tmp_0 != 0) 
#line 602 
                  readl((void const volatile *)mbox);
  else {
    int tmp_1;
    
#line 600 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLUSH_POSTED_WRITES,(unsigned long *)(& tp->tg3_flags));
    
#line 600 
    if (tmp_1 != 0) 
#line 602 
                    readl((void const volatile *)mbox); else ;
  }
  
#line 603 
  return;
}


#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_read32_mbox_5906(struct tg3 *tp, u32 off)
{
  u32 tmp;
  
#line 607 
  tmp = readl((void const volatile *)(tp->regs + (off + 22016U)));
  
#line 607 
  return tmp;
}


#line 610  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write32_mbox_5906(struct tg3 *tp, u32 off, u32 val)
{
  
#line 612 
  writel(val,(void volatile *)(tp->regs + (off + 22016U)));
  
#line 613 
  return;
}


#line 626  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write_mem(struct tg3 *tp, u32 off, u32 val)
{
  unsigned long flags;
  int tmp;
  
#line 630 
  if (tp->pci_chip_rev_id >> 12 == 12U && off + 4294966528U <= 15615U) 
    
#line 632 
    goto return_label; else ;
  
#line 634 
  ldv___ldv_spin_lock_82(& tp->indirect_lock);
  
#line 635 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SRAM_USE_CONFIG,(unsigned long *)(& tp->tg3_flags));
  
#line 635 
  if (tmp != 0) {
    
#line 636 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,124,off);
    
#line 637 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,132,val);
    
#line 640 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,124,0U);
  }
  else {
    
#line 642 
    _tw32_flush(tp,124U,off,0U);
    
#line 643 
    _tw32_flush(tp,132U,val,0U);
    
#line 646 
    _tw32_flush(tp,124U,0U,0U);
  }
  
#line 648 
  ldv_spin_unlock_irqrestore_83(& tp->indirect_lock,flags);
  return_label: 
#line 649 
                return;
}


#line 651  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_mem(struct tg3 *tp, u32 off, u32 *val)
{
  unsigned long flags;
  int tmp;
  
#line 655 
  if (tp->pci_chip_rev_id >> 12 == 12U && off + 4294966528U <= 15615U) {
    
#line 657 
    *val = 0U;
    
#line 658 
    goto return_label;
  }
  else ;
  
#line 661 
  ldv___ldv_spin_lock_84(& tp->indirect_lock);
  
#line 662 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SRAM_USE_CONFIG,(unsigned long *)(& tp->tg3_flags));
  
#line 662 
  if (tmp != 0) {
    
#line 663 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,124,off);
    
#line 664 
    pci_read_config_dword((struct pci_dev const *)tp->pdev,132,val);
    
#line 667 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,124,0U);
  }
  else {
    
#line 669 
    _tw32_flush(tp,124U,off,0U);
    
#line 670 
    *val = (*(tp->read32))(tp,132U);
    
#line 673 
    _tw32_flush(tp,124U,0U,0U);
  }
  
#line 675 
  ldv_spin_unlock_irqrestore_85(& tp->indirect_lock,flags);
  return_label: 
#line 676 
                return;
}


#line 678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ape_lock_init(struct tg3 *tp)
{
  int i;
  u32 regbase;
  u32 bit;
  
#line 683 
  if (tp->pci_chip_rev_id >> 12 == 22369U) 
#line 684 
                                           regbase = 76U; else 
#line 686 
                                                               regbase = 33824U;
  
#line 689 
  i = 0;
  
#line 689 
  goto ldv_55947;
  ldv_55946: 
#line 690 
  ;
  
#line 690 
  switch (i) {
    case 0: 
#line 691 
    ;
    case 2: 
#line 692 
    ;
    case 3: 
#line 693 
    ;
    case 5: 
#line 694 
    ;
    
#line 695 
    bit = 4096U;
    
#line 696 
    goto ldv_55944;
    default: 
#line 697 
    ;
    
#line 698 
    if (tp->pci_fn == 0) 
#line 699 
                         bit = 4096U; else 
#line 701 
                                           bit = (unsigned int)(1 << tp->pci_fn);
  }
  ldv_55944: 
#line 703 
  ;
  
#line 703 
  tg3_ape_write32(tp,(unsigned int)(i * 4) + regbase,bit);
  
#line 689 
  i += 1;
  ldv_55947: 
#line 690 
  ;
  
#line 689 
  if (i <= 7) 
#line 691 
              goto ldv_55946; else 
#line 694 
                                   goto ldv_55948;
  ldv_55948: 
#line 695 
  ;
  
#line 696 
  return;
}


#line 708  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ape_lock(struct tg3 *tp, int locknum)
{
  int __retres;
  int i;
  int off;
  u32 status;
  u32 req;
  u32 gnt;
  u32 bit;
  int tmp;
  int tmp_0;
  
#line 711 
  int ret = 0;
  
#line 714 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 714 
  if (tmp == 0) {
    
#line 715 
    __retres = 0;
    
#line 715 
    goto return_label;
  }
  else ;
  
#line 717 
  switch (locknum) {
    case 7: 
#line 718 
    ;
    
#line 719 
    if (tp->pci_chip_rev_id >> 12 == 22369U) {
      
#line 720 
      __retres = 0;
      
#line 720 
      goto return_label;
    }
    else ;
    case 1: 
#line 721 
    ;
    case 4: 
#line 722 
    ;
    
#line 723 
    if (tp->pci_fn == 0) 
#line 724 
                         bit = 4096U; else 
#line 726 
                                           bit = (unsigned int)(1 << tp->pci_fn);
    
#line 727 
    goto ldv_55963;
    case 0: 
#line 728 
    ;
    case 2: 
#line 729 
    ;
    case 3: 
#line 730 
    ;
    case 5: 
#line 731 
    ;
    
#line 732 
    bit = 4096U;
    
#line 733 
    goto ldv_55963;
    default: 
#line 734 
    ;
    
#line 735 
    __retres = -22;
    
#line 735 
    goto return_label;
  }
  ldv_55963: 
#line 738 
  ;
  
#line 738 
  if (tp->pci_chip_rev_id >> 12 == 22369U) {
    
#line 739 
    req = 44U;
    
#line 740 
    gnt = 76U;
  }
  else {
    
#line 742 
    req = 33792U;
    
#line 743 
    gnt = 33824U;
  }
  
#line 746 
  off = locknum * 4;
  
#line 748 
  tg3_ape_write32(tp,req + (unsigned int)off,bit);
  
#line 751 
  i = 0;
  
#line 751 
  goto ldv_55971;
  ldv_55970: 
#line 752 
  ;
  
#line 752 
  status = tg3_ape_read32(tp,gnt + (unsigned int)off);
  
#line 753 
  if (status == bit) 
#line 754 
                     goto ldv_55969; else ;
  
#line 755 
  tmp_0 = pci_channel_offline(tp->pdev);
  
#line 755 
  if (tmp_0 != 0) 
#line 756 
                  goto ldv_55969; else ;
  
#line 758 
  __const_udelay(42950UL);
  
#line 751 
  i += 1;
  ldv_55971: 
#line 752 
  ;
  
#line 751 
  if (i <= 99) 
#line 753 
               goto ldv_55970; else 
#line 756 
                                    goto ldv_55969;
  ldv_55969: 
#line 757 
  ;
  
#line 761 
  if (status != bit) {
    
#line 763 
    tg3_ape_write32(tp,gnt + (unsigned int)off,bit);
    
#line 764 
    ret = -16;
  }
  else ;
  
#line 767 
  __retres = ret;
  return_label: 
#line 767 
                return __retres;
}


#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ape_unlock(struct tg3 *tp, int locknum)
{
  u32 gnt;
  u32 bit;
  int tmp;
  
#line 774 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 774 
  if (tmp == 0) 
#line 775 
                goto return_label; else ;
  
#line 777 
  switch (locknum) {
    case 7: 
#line 778 
    ;
    
#line 779 
    if (tp->pci_chip_rev_id >> 12 == 22369U) 
#line 780 
                                             goto return_label; else ;
    case 1: 
#line 781 
    ;
    case 4: 
#line 782 
    ;
    
#line 783 
    if (tp->pci_fn == 0) 
#line 784 
                         bit = 4096U; else 
#line 786 
                                           bit = (unsigned int)(1 << tp->pci_fn);
    
#line 787 
    goto ldv_55981;
    case 0: 
#line 788 
    ;
    case 2: 
#line 789 
    ;
    case 3: 
#line 790 
    ;
    case 5: 
#line 791 
    ;
    
#line 792 
    bit = 4096U;
    
#line 793 
    goto ldv_55981;
    default: 
#line 794 
    ;
    
#line 795 
    goto return_label;
  }
  ldv_55981: 
#line 798 
  ;
  
#line 798 
  if (tp->pci_chip_rev_id >> 12 == 22369U) 
#line 799 
                                           gnt = 76U; else 
#line 801 
                                                           gnt = 33824U;
  
#line 803 
  tg3_ape_write32(tp,(unsigned int)(locknum * 4) + gnt,bit);
  return_label: 
#line 804 
                return;
}


#line 806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ape_event_lock(struct tg3 *tp, u32 timeout_us)
{
  int __retres;
  u32 apedata;
  int tmp;
  unsigned int tmp_0;
  int tmp_1;
  
#line 810 
  goto ldv_55994;
  ldv_55993: 
#line 811 
  ;
  
#line 811 
  tmp = tg3_ape_lock(tp,4);
  
#line 811 
  if (tmp != 0) {
    
#line 812 
    __retres = -16;
    
#line 812 
    goto return_label;
  }
  else ;
  
#line 814 
  apedata = tg3_ape_read32(tp,17152U);
  
#line 815 
  if (apedata >= (u32)0) 
#line 816 
                         goto ldv_55992; else ;
  
#line 818 
  tg3_ape_unlock(tp,4);
  
#line 820 
  __const_udelay(42950UL);
  
#line 821 
  if (10U < timeout_us) 
#line 821 
                        tmp_0 = 10U; else 
#line 821 
                                          tmp_0 = timeout_us;
  
#line 821 
  timeout_us -= tmp_0;
  ldv_55994: 
#line 822 
  ;
  
#line 810 
  if (timeout_us != 0U) 
#line 812 
                        goto ldv_55993; else 
#line 815 
                                             goto ldv_55992;
  ldv_55992: 
#line 816 
  ;
  
#line 824 
  if (timeout_us != 0U) 
#line 824 
                        tmp_1 = 0; else 
#line 824 
                                        tmp_1 = -16;
  
#line 824 
  __retres = tmp_1;
  return_label: 
#line 824 
                return __retres;
}


#line 827  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ape_wait_for_event(struct tg3 *tp, u32 timeout_us)
{
  int __retres;
  u32 i;
  u32 apedata;
  
#line 831 
  i = 0U;
  
#line 831 
  goto ldv_56003;
  ldv_56002: 
#line 832 
  ;
  
#line 832 
  apedata = tg3_ape_read32(tp,17152U);
  
#line 834 
  if (apedata >= (u32)0) 
#line 835 
                         goto ldv_56001; else ;
  
#line 837 
  __const_udelay(42950UL);
  
#line 831 
  i += 1U;
  ldv_56003: 
#line 832 
  ;
  
#line 831 
  if (timeout_us / 10U > i) 
#line 833 
                            goto ldv_56002; else 
#line 836 
                                                 goto ldv_56001;
  ldv_56001: 
#line 837 
  ;
  
#line 840 
  __retres = timeout_us / 10U == i;
  
#line 840 
  return __retres;
}


#line 843  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ape_scratchpad_read(struct tg3 *tp, u32 *data, u32 base_off, u32 len)
{
  int __retres;
  int err;
  u32 i;
  u32 bufoff;
  u32 msgoff;
  u32 maxlen;
  u32 apedata;
  int tmp;
  u32 tmp_0;
  
#line 849 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_APE_HAS_NCSI,(unsigned long *)(& tp->tg3_flags));
  
#line 849 
  if (tmp == 0) {
    
#line 850 
    __retres = 0;
    
#line 850 
    goto return_label;
  }
  else ;
  
#line 852 
  apedata = tg3_ape_read32(tp,16384U);
  
#line 853 
  if (apedata != 1095779617U) {
    
#line 854 
    __retres = -19;
    
#line 854 
    goto return_label;
  }
  else ;
  
#line 856 
  apedata = tg3_ape_read32(tp,16396U);
  
#line 857 
  if ((apedata & 256U) == 0U) {
    
#line 858 
    __retres = -11;
    
#line 858 
    goto return_label;
  }
  else ;
  
#line 860 
  tmp_0 = tg3_ape_read32(tp,16412U);
  
#line 860 
  bufoff = tmp_0 + 16384U;
  
#line 862 
  msgoff = bufoff + 8U;
  
#line 863 
  maxlen = tg3_ape_read32(tp,16416U);
  
#line 865 
  goto ldv_56022;
  ldv_56021: 
#line 866 
  ;
  {
    u32 length;
    int tmp_1;
    
#line 869 
    if (maxlen < len) 
#line 869 
                      length = maxlen; else 
#line 869 
                                            length = len;
    
#line 870 
    len -= length;
    
#line 872 
    apedata = tg3_ape_read32(tp,16396U);
    
#line 873 
    if ((apedata & 256U) == 0U) {
      
#line 874 
      __retres = -11;
      
#line 874 
      goto return_label;
    }
    else ;
    
#line 877 
    err = tg3_ape_event_lock(tp,1000U);
    
#line 878 
    if (err != 0) {
      
#line 879 
      __retres = err;
      
#line 879 
      goto return_label;
    }
    else ;
    
#line 881 
    apedata = 2147489296U;
    
#line 884 
    tg3_ape_write32(tp,17152U,apedata);
    
#line 886 
    tg3_ape_write32(tp,bufoff,base_off);
    
#line 887 
    tg3_ape_write32(tp,bufoff + 4U,length);
    
#line 889 
    tg3_ape_unlock(tp,4);
    
#line 890 
    tg3_ape_write32(tp,12U,1U);
    
#line 892 
    base_off += length;
    
#line 894 
    tmp_1 = tg3_ape_wait_for_event(tp,30000U);
    
#line 894 
    if (tmp_1 != 0) {
      
#line 895 
      __retres = -11;
      
#line 895 
      goto return_label;
    }
    else ;
    
#line 897 
    i = 0U;
    
#line 897 
    goto ldv_56019;
    ldv_56018: 
#line 898 
    ;
    {
      
#line 898 
      u32 val = tg3_ape_read32(tp,msgoff + i);
      
#line 899 
      memcpy((void *)data,(void const *)(& val),4UL);
      
#line 900 
      data += 1;
    }
    
#line 897 
    i += 4U;
    
#line 897 
    length += 4294967292U;
    ldv_56019: 
#line 898 
    ;
    
#line 897 
    if (length != 0U) 
#line 899 
                      goto ldv_56018; else 
#line 902 
                                           goto ldv_56020;
    ldv_56020: 
#line 903 
    ;
  }
  ldv_56022: 
#line 905 
  ;
  
#line 865 
  if (len != 0U) 
#line 867 
                 goto ldv_56021; else 
#line 870 
                                      goto ldv_56023;
  ldv_56023: 
#line 871 
  ;
  
#line 904 
  __retres = 0;
  return_label: 
#line 904 
                return __retres;
}


#line 907  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ape_send_event(struct tg3 *tp, u32 event)
{
  int __retres;
  int err;
  u32 apedata;
  
#line 912 
  apedata = tg3_ape_read32(tp,16384U);
  
#line 913 
  if (apedata != 1095779617U) {
    
#line 914 
    __retres = -11;
    
#line 914 
    goto return_label;
  }
  else ;
  
#line 916 
  apedata = tg3_ape_read32(tp,16396U);
  
#line 917 
  if ((apedata & 256U) == 0U) {
    
#line 918 
    __retres = -11;
    
#line 918 
    goto return_label;
  }
  else ;
  
#line 921 
  err = tg3_ape_event_lock(tp,1000U);
  
#line 922 
  if (err != 0) {
    
#line 923 
    __retres = err;
    
#line 923 
    goto return_label;
  }
  else ;
  
#line 925 
  tg3_ape_write32(tp,17152U,event | 2147483648U);
  
#line 928 
  tg3_ape_unlock(tp,4);
  
#line 929 
  tg3_ape_write32(tp,12U,1U);
  
#line 931 
  __retres = 0;
  return_label: 
#line 931 
                return __retres;
}


#line 934  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ape_driver_state_change(struct tg3 *tp, int kind)
{
  u32 event;
  u32 apedata;
  int tmp;
  
#line 939 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 939 
  if (tmp == 0) 
#line 940 
                goto return_label; else ;
  
#line 942 
  switch (kind) {
    bool tmp_0;
    case 1: 
#line 943 
    ;
    
#line 944 
    tg3_ape_write32(tp,16896U,1213158228U);
    
#line 946 
    tg3_ape_write32(tp,16900U,32U);
    
#line 948 
    apedata = tg3_ape_read32(tp,16904U);
    
#line 949 
    apedata += 1U;
    
#line 949 
    ;
    
#line 949 
    tg3_ape_write32(tp,16904U,apedata);
    
#line 950 
    tg3_ape_write32(tp,16908U,4026763520U);
    
#line 952 
    tg3_ape_write32(tp,16912U,1U);
    
#line 954 
    tg3_ape_write32(tp,16924U,1U);
    
#line 957 
    event = 65536U;
    
#line 958 
    goto ldv_56037;
    case 0: 
#line 959 
    ;
    
#line 965 
    tg3_ape_write32(tp,16896U,0U);
    
#line 967 
    tmp_0 = device_may_wakeup(& (tp->pdev)->dev);
    
#line 967 
    if ((int)tmp_0 != 0) {
      int tmp_1;
      
#line 967 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 967 
      if (tmp_1 != 0) {
        
#line 969 
        tg3_ape_write32(tp,16932U,32768U);
        
#line 971 
        apedata = 3U;
      }
      else 
#line 973 
           apedata = 2U;
    }
    else 
#line 973 
         apedata = 2U;
    
#line 975 
    tg3_ape_write32(tp,16924U,apedata);
    
#line 977 
    event = 131072U;
    
#line 978 
    goto ldv_56037;
    default: 
#line 979 
    ;
    
#line 980 
    goto return_label;
  }
  ldv_56037: 
#line 983 
  ;
  
#line 983 
  event |= 1296U;
  
#line 985 
  tg3_ape_send_event(tp,event);
  return_label: 
#line 986 
                return;
}


#line 988  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_disable_ints(struct tg3 *tp)
{
  int i;
  
#line 992 
  (*(tp->write32))(tp,104U,tp->misc_host_ctrl | 2U);
  
#line 994 
  i = 0;
  
#line 994 
  goto ldv_56045;
  ldv_56044: 
#line 995 
  ;
  
#line 995 
  tw32_mailbox_flush(tp,tp->napi[i].int_mbox,1U);
  
#line 994 
  i += 1;
  ldv_56045: 
#line 995 
  ;
  
#line 994 
  if (tp->irq_max > (unsigned int)i) 
#line 996 
                                     goto ldv_56044; else 
#line 999 
                                                          goto ldv_56046;
  ldv_56046: 
#line 1000 
  ;
  
#line 1001 
  return;
}


#line 998  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_enable_ints(struct tg3 *tp)
{
  int i;
  int tmp_0;
  
#line 1002 
  tp->irq_sync = 0U;
  
#line 1003 
  ldv_inline_asm();
  
#line 1005 
  (*(tp->write32))(tp,104U,tp->misc_host_ctrl & 4294967293U);
  
#line 1008 
  tp->coal_now = tp->coalesce_mode | 2U;
  
#line 1009 
  i = 0;
  
#line 1009 
  goto ldv_56053;
  ldv_56052: 
#line 1010 
  ;
  {
    int tmp;
    
#line 1010 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 1012 
    tw32_mailbox_flush(tp,tnapi->int_mbox,tnapi->last_tag << 24);
    
#line 1013 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_1SHOT_MSI,(unsigned long *)(& tp->tg3_flags));
    
#line 1013 
    if (tmp != 0) 
#line 1014 
                  tw32_mailbox_flush(tp,tnapi->int_mbox,tnapi->last_tag << 24); else ;
    
#line 1016 
    tp->coal_now |= tnapi->coal_now;
  }
  
#line 1009 
  i += 1;
  ldv_56053: 
#line 1010 
  ;
  
#line 1009 
  if (tp->irq_cnt > (unsigned int)i) 
#line 1011 
                                     goto ldv_56052; else 
#line 1014 
                                                          goto ldv_56054;
  ldv_56054: 
#line 1015 
  ;
  
#line 1020 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags));
  
#line 1020 
  if (tmp_0 == 0) 
    
#line 1020 
    if (((tp->napi[0].hw_status)->status & 1U) != 0U) 
#line 1022 
                                                      (*(tp->write32))(tp,26632U,tp->grc_local_ctrl | 4U); else 
                                                                    
#line 1024 
                                                                    (*(tp->write32))(tp,15360U,tp->coal_now);
  else 
#line 1024 
       (*(tp->write32))(tp,15360U,tp->coal_now);
  
#line 1026 
  tp->coal_now &= ~ (tp->napi[0].coal_now | tp->napi[1].coal_now);
  
#line 1027 
  return;
}


#line 1029  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static unsigned int tg3_has_work(struct tg3_napi *tnapi)
{
  int tmp;
  
#line 1031 
  struct tg3 *tp = tnapi->tp;
  
#line 1032 
  struct tg3_hw_status *sblk = tnapi->hw_status;
  
#line 1033 
  unsigned int work_exists = 0U;
  
#line 1036 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_LINKCHG_REG,(unsigned long *)(& tp->tg3_flags));
  
#line 1036 
  if (tmp == 0) {
    int tmp_0;
    
#line 1036 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_POLL_SERDES,(unsigned long *)(& tp->tg3_flags));
    
#line 1036 
    if (tmp_0 == 0) {
      
#line 1037 
      if ((sblk->status & 2U) != 0U) 
#line 1038 
                                     work_exists = 1U; else ;
    }
    else ;
  }
  else ;
  
#line 1042 
  if ((unsigned int)sblk->idx[0].tx_consumer != tnapi->tx_cons) 
#line 1043 
                                                                work_exists = 1U; else ;
  
#line 1046 
  if (tnapi->rx_rcb_prod_idx != (u16 *)0U && (unsigned int)*(tnapi->rx_rcb_prod_idx) != tnapi->rx_rcb_ptr) 
    
#line 1048 
    work_exists = 1U; else ;
  
#line 1050 
  return work_exists;
}


#line 1058  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_int_reenable(struct tg3_napi *tnapi)
{
  int tmp;
  
#line 1060 
  struct tg3 *tp = tnapi->tp;
  
#line 1062 
  (*(tp->write32_mbox))(tp,tnapi->int_mbox,tnapi->last_tag << 24);
  
#line 1063 
  ldv_inline_asm();
  
#line 1069 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags));
  
#line 1069 
  if (tmp == 0) {
    unsigned int tmp_0;
    
#line 1069 
    tmp_0 = tg3_has_work(tnapi);
    
#line 1069 
    if (tmp_0 != 0U) 
#line 1070 
                     (*(tp->write32))(tp,15360U,(tp->coalesce_mode | tnapi->coal_now) | 2U); else ;
  }
  else ;
  
#line 1071 
  return;
}


#line 1074  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_switch_clocks(struct tg3 *tp)
{
  u32 clock_ctrl;
  u32 orig_clock_ctrl;
  int tmp;
  int tmp_1;
  
#line 1079 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
  
#line 1079 
  if (tmp != 0) 
#line 1080 
                goto return_label;
  else {
    int tmp_0;
    
#line 1079 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 1079 
    if (tmp_0 != 0) 
#line 1080 
                    goto return_label; else ;
  }
  
#line 1082 
  clock_ctrl = (*(tp->read32))(tp,116U);
  
#line 1084 
  orig_clock_ctrl = clock_ctrl;
  
#line 1085 
  clock_ctrl &= 6291487U;
  
#line 1088 
  tp->pci_clock_ctrl = clock_ctrl;
  
#line 1090 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 1090 
  if (tmp_1 != 0) {
    
#line 1091 
    if ((orig_clock_ctrl & 1048576U) != 0U) 
#line 1092 
                                            _tw32_flush(tp,116U,clock_ctrl | 1048576U,40U); else ;
  }
  else 
    
#line 1095 
    if ((orig_clock_ctrl & 262144U) != 0U) {
      
#line 1096 
      _tw32_flush(tp,116U,clock_ctrl | 266240U,40U);
      
#line 1100 
      _tw32_flush(tp,116U,clock_ctrl | 4096U,40U);
    }
    else ;
  
#line 1104 
  _tw32_flush(tp,116U,clock_ctrl,40U);
  return_label: 
#line 1105 
                return;
}


#line 1109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int __tg3_readphy(struct tg3 *tp, unsigned int phy_addr, int reg, u32 *val)
{
  u32 frame_val;
  unsigned int loops;
  int ret;
  
#line 1116 
  if ((tp->mi_mode & 16U) != 0U) {
    
#line 1117 
    _tw32_flush(tp,1108U,tp->mi_mode & 4294967279U,0U);
    
#line 1119 
    __const_udelay(343600UL);
  }
  else ;
  
#line 1122 
  tg3_ape_lock(tp,(int)tp->phy_ape_lock);
  
#line 1124 
  *val = 0U;
  
#line 1126 
  frame_val = (phy_addr << 21) & 65011712U;
  
#line 1128 
  frame_val = ((unsigned int)(reg << 16) & 2031616U) | frame_val;
  
#line 1130 
  frame_val |= 671088640U;
  
#line 1132 
  _tw32_flush(tp,1100U,frame_val,0U);
  
#line 1134 
  loops = 5000U;
  
#line 1135 
  goto ldv_56081;
  ldv_56080: 
#line 1136 
  ;
  
#line 1136 
  __const_udelay(42950UL);
  
#line 1137 
  frame_val = (*(tp->read32))(tp,1100U);
  
#line 1139 
  if ((frame_val & 536870912U) == 0U) {
    
#line 1140 
    __const_udelay(21475UL);
    
#line 1141 
    frame_val = (*(tp->read32))(tp,1100U);
    
#line 1142 
    goto ldv_56079;
  }
  else ;
  
#line 1144 
  loops += 4294967295U;
  ldv_56081: 
#line 1145 
  ;
  
#line 1135 
  if (loops != 0U) 
#line 1137 
                   goto ldv_56080; else 
#line 1140 
                                        goto ldv_56079;
  ldv_56079: 
#line 1141 
  ;
  
#line 1147 
  ret = -16;
  
#line 1148 
  if (loops != 0U) {
    
#line 1149 
    *val = frame_val & 65535U;
    
#line 1150 
    ret = 0;
  }
  else ;
  
#line 1153 
  if ((tp->mi_mode & 16U) != 0U) {
    
#line 1154 
    _tw32_flush(tp,1108U,tp->mi_mode,0U);
    
#line 1155 
    __const_udelay(343600UL);
  }
  else ;
  
#line 1158 
  tg3_ape_unlock(tp,(int)tp->phy_ape_lock);
  
#line 1160 
  return ret;
}


#line 1163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_readphy(struct tg3 *tp, int reg, u32 *val)
{
  int tmp;
  
#line 1165 
  tmp = __tg3_readphy(tp,(unsigned int)tp->phy_addr,reg,val);
  
#line 1165 
  return tmp;
}


#line 1168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int __tg3_writephy(struct tg3 *tp, unsigned int phy_addr, int reg, u32 val)
{
  int __retres;
  u32 frame_val;
  unsigned int loops;
  int ret;
  
#line 1175 
  if ((tp->phy_flags & 64U) != 0U && (reg == 9 || reg == 24)) {
    
#line 1177 
    __retres = 0;
    
#line 1177 
    goto return_label;
  }
  else ;
  
#line 1179 
  if ((tp->mi_mode & 16U) != 0U) {
    
#line 1180 
    _tw32_flush(tp,1108U,tp->mi_mode & 4294967279U,0U);
    
#line 1182 
    __const_udelay(343600UL);
  }
  else ;
  
#line 1185 
  tg3_ape_lock(tp,(int)tp->phy_ape_lock);
  
#line 1187 
  frame_val = (phy_addr << 21) & 65011712U;
  
#line 1189 
  frame_val = ((unsigned int)(reg << 16) & 2031616U) | frame_val;
  
#line 1191 
  frame_val = (val & 65535U) | frame_val;
  
#line 1192 
  frame_val |= 603979776U;
  
#line 1194 
  _tw32_flush(tp,1100U,frame_val,0U);
  
#line 1196 
  loops = 5000U;
  
#line 1197 
  goto ldv_56098;
  ldv_56097: 
#line 1198 
  ;
  
#line 1198 
  __const_udelay(42950UL);
  
#line 1199 
  frame_val = (*(tp->read32))(tp,1100U);
  
#line 1200 
  if ((frame_val & 536870912U) == 0U) {
    
#line 1201 
    __const_udelay(21475UL);
    
#line 1202 
    frame_val = (*(tp->read32))(tp,1100U);
    
#line 1203 
    goto ldv_56096;
  }
  else ;
  
#line 1205 
  loops += 4294967295U;
  ldv_56098: 
#line 1206 
  ;
  
#line 1197 
  if (loops != 0U) 
#line 1199 
                   goto ldv_56097; else 
#line 1202 
                                        goto ldv_56096;
  ldv_56096: 
#line 1203 
  ;
  
#line 1208 
  ret = -16;
  
#line 1209 
  if (loops != 0U) 
#line 1210 
                   ret = 0; else ;
  
#line 1212 
  if ((tp->mi_mode & 16U) != 0U) {
    
#line 1213 
    _tw32_flush(tp,1108U,tp->mi_mode,0U);
    
#line 1214 
    __const_udelay(343600UL);
  }
  else ;
  
#line 1217 
  tg3_ape_unlock(tp,(int)tp->phy_ape_lock);
  
#line 1219 
  __retres = ret;
  return_label: 
#line 1219 
                return __retres;
}


#line 1222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_writephy(struct tg3 *tp, int reg, u32 val)
{
  int tmp;
  
#line 1224 
  tmp = __tg3_writephy(tp,(unsigned int)tp->phy_addr,reg,val);
  
#line 1224 
  return tmp;
}


#line 1227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_cl45_write(struct tg3 *tp, u32 devad, u32 addr, u32 val)
{
  int err;
  
#line 1231 
  err = tg3_writephy(tp,13,devad);
  
#line 1232 
  if (err != 0) 
#line 1233 
                goto done; else ;
  
#line 1235 
  err = tg3_writephy(tp,14,addr);
  
#line 1236 
  if (err != 0) 
#line 1237 
                goto done; else ;
  
#line 1239 
  err = tg3_writephy(tp,13,devad | 16384U);
  
#line 1241 
  if (err != 0) 
#line 1242 
                goto done; else ;
  
#line 1244 
  err = tg3_writephy(tp,14,val);
  done: 
#line 1246 
  ;
  
#line 1247 
  return err;
}


#line 1250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_cl45_read(struct tg3 *tp, u32 devad, u32 addr, u32 *val)
{
  int err;
  
#line 1254 
  err = tg3_writephy(tp,13,devad);
  
#line 1255 
  if (err != 0) 
#line 1256 
                goto done; else ;
  
#line 1258 
  err = tg3_writephy(tp,14,addr);
  
#line 1259 
  if (err != 0) 
#line 1260 
                goto done; else ;
  
#line 1262 
  err = tg3_writephy(tp,13,devad | 16384U);
  
#line 1264 
  if (err != 0) 
#line 1265 
                goto done; else ;
  
#line 1267 
  err = tg3_readphy(tp,14,val);
  done: 
#line 1269 
  ;
  
#line 1270 
  return err;
}


#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phydsp_read(struct tg3 *tp, u32 reg, u32 *val)
{
  int err;
  
#line 1277 
  err = tg3_writephy(tp,23,reg);
  
#line 1278 
  if (err == 0) 
#line 1279 
                err = tg3_readphy(tp,21,val); else ;
  
#line 1281 
  return err;
}


#line 1284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phydsp_write(struct tg3 *tp, u32 reg, u32 val)
{
  int err;
  
#line 1288 
  err = tg3_writephy(tp,23,reg);
  
#line 1289 
  if (err == 0) 
#line 1290 
                err = tg3_writephy(tp,21,val); else ;
  
#line 1292 
  return err;
}


#line 1295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_auxctl_read(struct tg3 *tp, int reg, u32 *val)
{
  int err;
  
#line 1299 
  err = tg3_writephy(tp,24,(unsigned int)((reg << 12) | 7));
  
#line 1302 
  if (err == 0) 
#line 1303 
                err = tg3_readphy(tp,24,val); else ;
  
#line 1305 
  return err;
}


#line 1308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_auxctl_write(struct tg3 *tp, int reg, u32 set)
{
  int tmp;
  
#line 1310 
  if (reg == 7) 
#line 1311 
                set |= 32768U; else ;
  
#line 1313 
  tmp = tg3_writephy(tp,24,set | (unsigned int)reg);
  
#line 1313 
  return tmp;
}


#line 1316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_toggle_auxctl_smdsp(struct tg3 *tp, bool enable)
{
  int __retres;
  u32 val;
  int err;
  
#line 1321 
  err = tg3_phy_auxctl_read(tp,0,& val);
  
#line 1323 
  if (err != 0) {
    
#line 1324 
    __retres = err;
    
#line 1324 
    goto return_label;
  }
  else ;
  
#line 1326 
  if ((int)enable != 0) 
#line 1327 
                        val |= 2048U; else 
#line 1329 
                                           val &= 4294965247U;
  
#line 1331 
  err = tg3_phy_auxctl_write(tp,0,val | 1024U);
  
#line 1334 
  __retres = err;
  return_label: 
#line 1334 
                return __retres;
}


#line 1337  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_shdw_write(struct tg3 *tp, int reg, u32 val)
{
  int tmp;
  
#line 1339 
  tmp = tg3_writephy(tp,28,((unsigned int)reg | val) | 32768U);
  
#line 1339 
  return tmp;
}


#line 1343  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_bmcr_reset(struct tg3 *tp)
{
  int __retres;
  u32 phy_control;
  int limit;
  int err;
  int tmp;
  
#line 1351 
  phy_control = 32768U;
  
#line 1352 
  err = tg3_writephy(tp,0,phy_control);
  
#line 1353 
  if (err != 0) {
    
#line 1354 
    __retres = -16;
    
#line 1354 
    goto return_label;
  }
  else ;
  
#line 1356 
  limit = 5000;
  
#line 1357 
  goto ldv_56162;
  ldv_56161: 
#line 1358 
  ;
  
#line 1358 
  err = tg3_readphy(tp,0,& phy_control);
  
#line 1359 
  if (err != 0) {
    
#line 1360 
    __retres = -16;
    
#line 1360 
    goto return_label;
  }
  else ;
  
#line 1362 
  if ((phy_control & 32768U) == 0U) {
    
#line 1363 
    __const_udelay(171800UL);
    
#line 1364 
    goto ldv_56160;
  }
  else ;
  
#line 1366 
  __const_udelay(42950UL);
  ldv_56162: 
#line 1368 
  ;
  
#line 1357 
  tmp = limit;
  
#line 1357 
  limit -= 1;
  
#line 1357 
  ;
  
#line 1357 
  if (tmp != 0) 
#line 1359 
                goto ldv_56161; else 
#line 1362 
                                     goto ldv_56160;
  ldv_56160: 
#line 1363 
  ;
  
#line 1368 
  if (limit < 0) {
    
#line 1369 
    __retres = -16;
    
#line 1369 
    goto return_label;
  }
  else ;
  
#line 1371 
  __retres = 0;
  return_label: 
#line 1371 
                return __retres;
}


#line 1374  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_mdio_read(struct mii_bus *bp, int mii_id, int reg)
{
  int __retres;
  u32 val;
  int tmp;
  
#line 1376 
  struct tg3 *tp = (struct tg3 *)bp->priv;
  
#line 1379 
  ldv_spin_lock_bh_86(& tp->lock);
  
#line 1381 
  tmp = __tg3_readphy(tp,(unsigned int)mii_id,reg,& val);
  
#line 1381 
  if (tmp != 0) 
#line 1382 
                val = 4294967291U; else ;
  
#line 1384 
  ldv_spin_unlock_bh_87(& tp->lock);
  
#line 1386 
  __retres = (int)val;
  
#line 1386 
  return __retres;
}


#line 1389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_mdio_write(struct mii_bus *bp, int mii_id, int reg, u16 val)
{
  int __retres;
  int tmp;
  
#line 1391 
  struct tg3 *tp = (struct tg3 *)bp->priv;
  
#line 1392 
  u32 ret = 0U;
  
#line 1394 
  ldv_spin_lock_bh_88(& tp->lock);
  
#line 1396 
  tmp = __tg3_writephy(tp,(unsigned int)mii_id,reg,(unsigned int)val);
  
#line 1396 
  if (tmp != 0) 
#line 1397 
                ret = 4294967291U; else ;
  
#line 1399 
  ldv_spin_unlock_bh_89(& tp->lock);
  
#line 1401 
  __retres = (int)ret;
  
#line 1401 
  return __retres;
}


#line 1404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_mdio_config_5785(struct tg3 *tp)
{
  u32 val;
  struct phy_device *phydev;
  int tmp;
  int tmp_2;
  int tmp_5;
  
#line 1409 
  phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
  
#line 1410 
  switch ((phydev->drv)->phy_id & (phydev->drv)->phy_id_mask) {
    case (unsigned int)21216608: 
#line 1411 
    ;
    case (unsigned int)21216624: 
#line 1412 
    ;
    
#line 1413 
    val = 823182592U;
    
#line 1414 
    goto ldv_56185;
    case (unsigned int)21216368: 
#line 1415 
    ;
    
#line 1416 
    val = 872376000U;
    
#line 1417 
    goto ldv_56185;
    case (unsigned int)1886480: 
#line 1418 
    ;
    
#line 1419 
    val = 857966592U;
    
#line 1420 
    goto ldv_56185;
    case (unsigned int)33280: 
#line 1421 
    ;
    
#line 1422 
    val = 958165440U;
    
#line 1423 
    goto ldv_56185;
    default: 
#line 1424 
    ;
    
#line 1425 
    goto return_label;
  }
  ldv_56185: 
#line 1428 
  ;
  
#line 1428 
  if (phydev->interface != (unsigned int)PHY_INTERFACE_MODE_RGMII) {
    
#line 1429 
    (*(tp->write32))(tp,1444U,val);
    
#line 1431 
    val = (*(tp->read32))(tp,1440U);
    
#line 1432 
    val &= 4261470222U;
    
#line 1434 
    val |= 16781312U;
    
#line 1435 
    (*(tp->write32))(tp,1440U,val);
    
#line 1437 
    goto return_label;
  }
  else ;
  
#line 1440 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_INBAND_DISABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 1440 
  if (tmp == 0) 
#line 1441 
                val |= 857502145U; else ;
  
#line 1448 
  (*(tp->write32))(tp,1444U,val);
  
#line 1450 
  val = (*(tp->read32))(tp,1440U);
  
#line 1451 
  val &= 4160806927U;
  
#line 1453 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_INBAND_DISABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 1453 
  if (tmp_2 == 0) {
    int tmp_0;
    int tmp_1;
    
#line 1454 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_EXT_IBND_RX_EN,(unsigned long *)(& tp->tg3_flags));
    
#line 1454 
    if (tmp_0 != 0) 
#line 1455 
                    val |= 33554432U; else ;
    
#line 1456 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_EXT_IBND_TX_EN,(unsigned long *)(& tp->tg3_flags));
    
#line 1456 
    if (tmp_1 != 0) 
#line 1457 
                    val |= 67108864U; else ;
  }
  else ;
  
#line 1459 
  val |= 553652225U;
  
#line 1461 
  (*(tp->write32))(tp,1440U,val);
  
#line 1463 
  val = (*(tp->read32))(tp,1448U);
  
#line 1464 
  val &= 4294963448U;
  
#line 1471 
  tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_INBAND_DISABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 1471 
  if (tmp_5 == 0) {
    int tmp_3;
    int tmp_4;
    
#line 1472 
    tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_EXT_IBND_RX_EN,(unsigned long *)(& tp->tg3_flags));
    
#line 1472 
    if (tmp_3 != 0) 
#line 1473 
                    val |= 3840U; else ;
    
#line 1477 
    tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_EXT_IBND_TX_EN,(unsigned long *)(& tp->tg3_flags));
    
#line 1477 
    if (tmp_4 != 0) 
#line 1478 
                    val |= 7U; else ;
  }
  else ;
  
#line 1482 
  (*(tp->write32))(tp,1448U,val);
  return_label: 
#line 1483 
                return;
}


#line 1485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_mdio_start(struct tg3 *tp)
{
  int tmp;
  
#line 1487 
  tp->mi_mode &= 4294967279U;
  
#line 1488 
  _tw32_flush(tp,1108U,tp->mi_mode,0U);
  
#line 1489 
  __const_udelay(343600UL);
  
#line 1491 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MDIOBUS_INITED,(unsigned long *)(& tp->tg3_flags));
  
#line 1491 
  if (tmp != 0) {
    
#line 1491 
    if (tp->pci_chip_rev_id >> 12 == 22405U) 
#line 1493 
                                             tg3_mdio_config_5785(tp); else ;
  }
  else ;
  
#line 1494 
  return;
}


#line 1496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_mdio_init(struct tg3 *tp)
{
  int __retres;
  int i;
  u32 reg;
  struct phy_device *phydev;
  int tmp_3;
  int tmp_4;
  int tmp_6;
  
#line 1502 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 1502 
  if (tmp_3 != 0) {
    u32 is_serdes;
    
#line 1505 
    tp->phy_addr = (unsigned char)((unsigned int)((unsigned char)tp->pci_fn) + 1U);
    
#line 1507 
    if (tp->pci_chip_rev_id != 91320320U) {
      u32 tmp;
      
#line 1508 
      tmp = (*(tp->read32))(tp,1460U);
      
#line 1508 
      is_serdes = tmp & 256U;
    }
    else {
      u32 tmp_0;
      
#line 1510 
      tmp_0 = (*(tp->read32))(tp,13924U);
      
#line 1510 
      is_serdes = tmp_0 & 32U;
    }
    
#line 1512 
    if (is_serdes != 0U) 
#line 1513 
                         tp->phy_addr = (unsigned char)((unsigned int)tp->phy_addr + 7U); else ;
  }
  else {
    int tmp_1;
    
#line 1514 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
    
#line 1514 
    if (tmp_1 != 0) {
      int tmp_2;
      
#line 1514 
      tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ROBOSWITCH,(unsigned long *)(& tp->tg3_flags));
      
#line 1514 
      if (tmp_2 != 0) {
        int addr;
        
#line 1517 
        addr = ssb_gige_get_phyaddr(tp->pdev);
        
#line 1518 
        if (addr < 0) {
          
#line 1519 
          __retres = addr;
          
#line 1519 
          goto return_label;
        }
        else ;
        
#line 1520 
        tp->phy_addr = (unsigned char)addr;
      }
      else 
#line 1522 
           tp->phy_addr = (unsigned char)1U;
    }
    else 
#line 1522 
         tp->phy_addr = (unsigned char)1U;
  }
  
#line 1524 
  tg3_mdio_start(tp);
  
#line 1526 
  tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 1526 
  if (tmp_4 == 0) {
    
#line 1527 
    __retres = 0;
    
#line 1527 
    goto return_label;
  }
  else {
    int tmp_5;
    
#line 1526 
    tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MDIOBUS_INITED,(unsigned long *)(& tp->tg3_flags));
    
#line 1526 
    if (tmp_5 != 0) {
      
#line 1527 
      __retres = 0;
      
#line 1527 
      goto return_label;
    }
    else ;
  }
  
#line 1529 
  tp->mdio_bus = mdiobus_alloc();
  
#line 1530 
  if (tp->mdio_bus == (struct mii_bus *)0) {
    
#line 1531 
    __retres = -12;
    
#line 1531 
    goto return_label;
  }
  else ;
  
#line 1533 
  (tp->mdio_bus)->name = "tg3 mdio bus";
  
#line 1534 
  snprintf((char *)(& (tp->mdio_bus)->id),17UL,"%x",(unsigned int)((int)((tp->pdev)->bus)->number << 8) | (tp->pdev)->devfn);
  
#line 1536 
  (tp->mdio_bus)->priv = (void *)tp;
  
#line 1537 
  (tp->mdio_bus)->parent = & (tp->pdev)->dev;
  
#line 1538 
  (tp->mdio_bus)->read = & tg3_mdio_read;
  
#line 1539 
  (tp->mdio_bus)->write = & tg3_mdio_write;
  
#line 1540 
  (tp->mdio_bus)->phy_mask = (unsigned int)(~ (1 << (int)tp->phy_addr));
  
#line 1541 
  (tp->mdio_bus)->irq = & tp->mdio_irq[0];
  
#line 1543 
  i = 0;
  
#line 1543 
  goto ldv_56202;
  ldv_56201: 
#line 1544 
  ;
  
#line 1544 
  *((tp->mdio_bus)->irq + i) = -1;
  
#line 1543 
  i += 1;
  ldv_56202: 
#line 1544 
  ;
  
#line 1543 
  if (i <= 31) 
#line 1545 
               goto ldv_56201; else 
#line 1548 
                                    goto ldv_56203;
  ldv_56203: 
#line 1549 
  ;
  
#line 1551 
  tmp_6 = tg3_readphy(tp,0,& reg);
  
#line 1551 
  if (tmp_6 != 0) 
#line 1552 
                  tg3_bmcr_reset(tp);
  else 
    
#line 1551 
    if ((reg & 2048U) != 0U) 
#line 1552 
                             tg3_bmcr_reset(tp); else ;
  
#line 1554 
  i = mdiobus_register(tp->mdio_bus);
  
#line 1555 
  if (i != 0) {
    
#line 1556 
    dev_warn((struct device const *)(& (tp->pdev)->dev),"mdiobus_reg failed (0x%x)\n",i);
    
#line 1557 
    mdiobus_free(tp->mdio_bus);
    
#line 1558 
    __retres = i;
    
#line 1558 
    goto return_label;
  }
  else ;
  
#line 1561 
  phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
  
#line 1563 
  if (phydev == (struct phy_device *)0 || phydev->drv == (struct phy_driver *)0) {
    
#line 1564 
    dev_warn((struct device const *)(& (tp->pdev)->dev),"No PHY devices\n");
    
#line 1565 
    mdiobus_unregister(tp->mdio_bus);
    
#line 1566 
    mdiobus_free(tp->mdio_bus);
    
#line 1567 
    __retres = -19;
    
#line 1567 
    goto return_label;
  }
  else ;
  
#line 1570 
  switch ((phydev->drv)->phy_id & (phydev->drv)->phy_id_mask) {
    int tmp_7;
    int tmp_8;
    int tmp_9;
    case (unsigned int)56778128: 
#line 1571 
    ;
    
#line 1572 
    phydev->interface = PHY_INTERFACE_MODE_GMII;
    
#line 1573 
    phydev->dev_flags |= 512U;
    
#line 1574 
    goto ldv_56205;
    case (unsigned int)21216608: 
#line 1575 
    ;
    case (unsigned int)21216624: 
#line 1576 
    ;
    
#line 1577 
    phydev->dev_flags |= 50688U;
    
#line 1581 
    tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_INBAND_DISABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 1581 
    if (tmp_7 != 0) 
#line 1582 
                    phydev->dev_flags |= 2048U; else ;
    
#line 1583 
    tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_EXT_IBND_RX_EN,(unsigned long *)(& tp->tg3_flags));
    
#line 1583 
    if (tmp_8 != 0) 
#line 1584 
                    phydev->dev_flags |= 4096U; else ;
    
#line 1585 
    tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_EXT_IBND_TX_EN,(unsigned long *)(& tp->tg3_flags));
    
#line 1585 
    if (tmp_9 != 0) 
#line 1586 
                    phydev->dev_flags |= 8192U; else ;
    case (unsigned int)1886480: 
#line 1588 
    ;
    
#line 1589 
    phydev->interface = PHY_INTERFACE_MODE_RGMII;
    
#line 1590 
    goto ldv_56205;
    case (unsigned int)33280: 
#line 1591 
    ;
    case (unsigned int)21216368: 
#line 1592 
    ;
    
#line 1593 
    phydev->interface = PHY_INTERFACE_MODE_MII;
    
#line 1594 
    phydev->dev_flags |= 512U;
    
#line 1595 
    tp->phy_flags |= 64U;
    
#line 1596 
    goto ldv_56205;
  }
  ldv_56205: 
#line 1599 
  ;
  
#line 1599 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_MDIOBUS_INITED,(unsigned long *)(& tp->tg3_flags));
  
#line 1601 
  if (tp->pci_chip_rev_id >> 12 == 22405U) 
#line 1602 
                                           tg3_mdio_config_5785(tp); else ;
  
#line 1604 
  __retres = 0;
  return_label: 
#line 1604 
                return __retres;
}


#line 1607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_mdio_fini(struct tg3 *tp)
{
  int tmp;
  
#line 1609 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MDIOBUS_INITED,(unsigned long *)(& tp->tg3_flags));
  
#line 1609 
  if (tmp != 0) {
    
#line 1610 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_MDIOBUS_INITED,(unsigned long *)(& tp->tg3_flags));
    
#line 1611 
    mdiobus_unregister(tp->mdio_bus);
    
#line 1612 
    mdiobus_free(tp->mdio_bus);
  }
  else ;
  
#line 1614 
  return;
}


#line 1617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tg3_generate_fw_event(struct tg3 *tp)
{
  u32 val;
  
#line 1621 
  val = (*(tp->read32))(tp,26640U);
  
#line 1622 
  val |= 16384U;
  
#line 1623 
  _tw32_flush(tp,26640U,val,0U);
  
#line 1625 
  tp->__anonCompField_tg3_119.last_event_jiffies = jiffies;
  
#line 1626 
  return;
}


#line 1631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_wait_for_event_ack(struct tg3 *tp)
{
  int i;
  unsigned int delay_cnt;
  long time_remain;
  unsigned long tmp;
  u32 tmp_0;
  int tmp_1;
  
#line 1638 
  tmp = usecs_to_jiffies(2500U);
  
#line 1638 
  time_remain = (long)(((tp->__anonCompField_tg3_119.last_event_jiffies + tmp) - jiffies) + 1UL);
  
#line 1641 
  if (time_remain < 0L) 
#line 1642 
                        goto return_label; else ;
  
#line 1645 
  delay_cnt = jiffies_to_usecs((unsigned long)time_remain);
  
#line 1646 
  if (delay_cnt > 2500U) 
#line 1647 
                         delay_cnt = 2500U; else ;
  
#line 1648 
  delay_cnt = (delay_cnt >> 3) + 1U;
  
#line 1650 
  i = 0;
  
#line 1650 
  goto ldv_56226;
  ldv_56225: 
#line 1651 
  ;
  
#line 1651 
  tmp_0 = (*(tp->read32))(tp,26640U);
  
#line 1651 
  if ((tmp_0 & 16384U) == 0U) 
#line 1652 
                              goto ldv_56224; else ;
  
#line 1653 
  tmp_1 = pci_channel_offline(tp->pdev);
  
#line 1653 
  if (tmp_1 != 0) 
#line 1654 
                  goto ldv_56224; else ;
  
#line 1656 
  __const_udelay(34360UL);
  
#line 1650 
  i += 1;
  ldv_56226: 
#line 1651 
  ;
  
#line 1650 
  if ((unsigned int)i < delay_cnt) 
#line 1652 
                                   goto ldv_56225; else 
#line 1655 
                                                        goto ldv_56224;
  ldv_56224: 
#line 1656 
  ;
  return_label: 
#line 1657 
                return;
}


#line 1661  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_gather_ump_data(struct tg3 *tp, u32 *data)
{
  u32 reg;
  u32 val;
  int tmp;
  int tmp_0;
  u32 *tmp_1;
  int tmp_2;
  int tmp_3;
  u32 *tmp_4;
  u32 *tmp_7;
  int tmp_8;
  u32 *tmp_9;
  
#line 1665 
  val = 0U;
  
#line 1666 
  tmp = tg3_readphy(tp,0,& reg);
  
#line 1666 
  if (tmp == 0) 
#line 1667 
                val = reg << 16; else ;
  
#line 1668 
  tmp_0 = tg3_readphy(tp,1,& reg);
  
#line 1668 
  if (tmp_0 == 0) 
#line 1669 
                  val = (reg & 65535U) | val; else ;
  
#line 1670 
  tmp_1 = data;
  
#line 1670 
  data += 1;
  
#line 1670 
  *tmp_1 = val;
  
#line 1672 
  val = 0U;
  
#line 1673 
  tmp_2 = tg3_readphy(tp,4,& reg);
  
#line 1673 
  if (tmp_2 == 0) 
#line 1674 
                  val = reg << 16; else ;
  
#line 1675 
  tmp_3 = tg3_readphy(tp,5,& reg);
  
#line 1675 
  if (tmp_3 == 0) 
#line 1676 
                  val = (reg & 65535U) | val; else ;
  
#line 1677 
  tmp_4 = data;
  
#line 1677 
  data += 1;
  
#line 1677 
  *tmp_4 = val;
  
#line 1679 
  val = 0U;
  
#line 1680 
  if ((tp->phy_flags & 32U) == 0U) {
    int tmp_5;
    int tmp_6;
    
#line 1681 
    tmp_5 = tg3_readphy(tp,9,& reg);
    
#line 1681 
    if (tmp_5 == 0) 
#line 1682 
                    val = reg << 16; else ;
    
#line 1683 
    tmp_6 = tg3_readphy(tp,10,& reg);
    
#line 1683 
    if (tmp_6 == 0) 
#line 1684 
                    val = (reg & 65535U) | val; else ;
  }
  else ;
  
#line 1686 
  tmp_7 = data;
  
#line 1686 
  data += 1;
  
#line 1686 
  *tmp_7 = val;
  
#line 1688 
  tmp_8 = tg3_readphy(tp,25,& reg);
  
#line 1688 
  if (tmp_8 == 0) 
#line 1689 
                  val = reg << 16; else 
#line 1691 
                                        val = 0U;
  
#line 1692 
  tmp_9 = data;
  
#line 1692 
  data += 1;
  
#line 1692 
  *tmp_9 = val;
  
#line 1693 
  return;
}


#line 1696  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ump_link_report(struct tg3 *tp)
{
  u32 data[4U];
  int tmp;
  
#line 1700 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
  
#line 1700 
  if (tmp == 0) 
#line 1701 
                goto return_label;
  else {
    int tmp_0;
    
#line 1700 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
    
#line 1700 
    if (tmp_0 == 0) 
#line 1701 
                    goto return_label; else ;
  }
  
#line 1703 
  tg3_phy_gather_ump_data(tp,(u32 *)(& data));
  
#line 1705 
  tg3_wait_for_event_ack(tp);
  
#line 1707 
  tg3_write_mem(tp,2936U,12U);
  
#line 1708 
  tg3_write_mem(tp,2940U,14U);
  
#line 1709 
  tg3_write_mem(tp,2944U,data[0]);
  
#line 1710 
  tg3_write_mem(tp,2948U,data[1]);
  
#line 1711 
  tg3_write_mem(tp,2952U,data[2]);
  
#line 1712 
  tg3_write_mem(tp,2956U,data[3]);
  
#line 1714 
  tg3_generate_fw_event(tp);
  return_label: 
#line 1715 
                return;
}


#line 1718  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_stop_fw(struct tg3 *tp)
{
  int tmp;
  
#line 1720 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 1720 
  if (tmp != 0) {
    int tmp_0;
    
#line 1720 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
    
#line 1720 
    if (tmp_0 == 0) {
      
#line 1722 
      tg3_wait_for_event_ack(tp);
      
#line 1724 
      tg3_write_mem(tp,2936U,2U);
      
#line 1726 
      tg3_generate_fw_event(tp);
      
#line 1729 
      tg3_wait_for_event_ack(tp);
    }
    else ;
  }
  else ;
  
#line 1731 
  return;
}


#line 1734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write_sig_pre_reset(struct tg3 *tp, int kind)
{
  int tmp;
  
#line 1736 
  tg3_write_mem(tp,2896U,1264940628U);
  
#line 1739 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ASF_NEW_HANDSHAKE,(unsigned long *)(& tp->tg3_flags));
  
#line 1739 
  if (tmp != 0) {
    
#line 1740 
    switch (kind) {
      case 1: 
#line 1741 
      ;
      
#line 1742 
      tg3_write_mem(tp,3076U,1U);
      
#line 1744 
      goto ldv_56245;
      case 0: 
#line 1746 
      ;
      
#line 1747 
      tg3_write_mem(tp,3076U,2U);
      
#line 1749 
      goto ldv_56245;
      case 2: 
#line 1751 
      ;
      
#line 1752 
      tg3_write_mem(tp,3076U,4U);
      
#line 1754 
      goto ldv_56245;
      default: 
#line 1756 
      ;
      
#line 1757 
      goto ldv_56245;
    }
    ldv_56245: 
#line 1759 
    ;
  }
  else ;
  
#line 1761 
  return;
}


#line 1763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write_sig_post_reset(struct tg3 *tp, int kind)
{
  int tmp;
  
#line 1765 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ASF_NEW_HANDSHAKE,(unsigned long *)(& tp->tg3_flags));
  
#line 1765 
  if (tmp != 0) {
    
#line 1766 
    switch (kind) {
      case 1: 
#line 1767 
      ;
      
#line 1768 
      tg3_write_mem(tp,3076U,2147483649U);
      
#line 1770 
      goto ldv_56254;
      case 0: 
#line 1772 
      ;
      
#line 1773 
      tg3_write_mem(tp,3076U,2147483650U);
      
#line 1775 
      goto ldv_56254;
      default: 
#line 1777 
      ;
      
#line 1778 
      goto ldv_56254;
    }
    ldv_56254: 
#line 1780 
    ;
  }
  else ;
  
#line 1782 
  return;
}


#line 1784  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_write_sig_legacy(struct tg3 *tp, int kind)
{
  int tmp;
  
#line 1786 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 1786 
  if (tmp != 0) {
    
#line 1787 
    switch (kind) {
      case 1: 
#line 1788 
      ;
      
#line 1789 
      tg3_write_mem(tp,3076U,1U);
      
#line 1791 
      goto ldv_56262;
      case 0: 
#line 1793 
      ;
      
#line 1794 
      tg3_write_mem(tp,3076U,2U);
      
#line 1796 
      goto ldv_56262;
      case 2: 
#line 1798 
      ;
      
#line 1799 
      tg3_write_mem(tp,3076U,4U);
      
#line 1801 
      goto ldv_56262;
      default: 
#line 1803 
      ;
      
#line 1804 
      goto ldv_56262;
    }
    ldv_56262: 
#line 1806 
    ;
  }
  else ;
  
#line 1808 
  return;
}


#line 1809  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_poll_fw(struct tg3 *tp)
{
  int __retres;
  int i;
  u32 val;
  int tmp;
  int tmp_0;
  int tmp_4;
  
#line 1814 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_FWARE_REPORTED,(unsigned long *)(& tp->tg3_flags));
  
#line 1814 
  if (tmp != 0) {
    
#line 1815 
    __retres = 0;
    
#line 1815 
    goto return_label;
  }
  else ;
  
#line 1817 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
  
#line 1817 
  if (tmp_0 != 0) {
    
#line 1819 
    __retres = 0;
    
#line 1819 
    goto return_label;
  }
  else ;
  
#line 1822 
  if (tp->pci_chip_rev_id >> 12 == 12U) {
    u32 tmp_1;
    int tmp_2;
    
#line 1824 
    i = 0;
    
#line 1824 
    goto ldv_56272;
    ldv_56271: 
#line 1825 
    ;
    
#line 1825 
    tmp_1 = (*(tp->read32))(tp,20736U);
    
#line 1825 
    if ((tmp_1 & 67108864U) != 0U) {
      
#line 1826 
      __retres = 0;
      
#line 1826 
      goto return_label;
    }
    else ;
    
#line 1827 
    tmp_2 = pci_channel_offline(tp->pdev);
    
#line 1827 
    if (tmp_2 != 0) {
      
#line 1828 
      __retres = -19;
      
#line 1828 
      goto return_label;
    }
    else ;
    
#line 1830 
    __const_udelay(429500UL);
    
#line 1824 
    i += 1;
    ldv_56272: 
#line 1825 
    ;
    
#line 1824 
    if (i <= 199) 
#line 1826 
                  goto ldv_56271; else 
#line 1829 
                                       goto ldv_56273;
    ldv_56273: 
#line 1830 
    ;
    
#line 1832 
    __retres = -19;
    
#line 1832 
    goto return_label;
  }
  else ;
  
#line 1836 
  i = 0;
  
#line 1836 
  goto ldv_56276;
  ldv_56275: 
#line 1837 
  ;
  
#line 1837 
  tg3_read_mem(tp,2896U,& val);
  
#line 1838 
  if (val == 3030026667U) 
#line 1839 
                          goto ldv_56274; else ;
  
#line 1840 
  tmp_4 = pci_channel_offline(tp->pdev);
  
#line 1840 
  if (tmp_4 != 0) {
    int tmp_3;
    
#line 1841 
    tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_FWARE_REPORTED,(unsigned long *)(& tp->tg3_flags));
    
#line 1841 
    if (tmp_3 == 0) {
      
#line 1842 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_FWARE_REPORTED,(unsigned long *)(& tp->tg3_flags));
      
#line 1843 
      netdev_info((struct net_device const *)tp->dev,"No firmware running\n");
    }
    else ;
    
#line 1846 
    goto ldv_56274;
  }
  else ;
  
#line 1849 
  __const_udelay(42950UL);
  
#line 1836 
  i += 1;
  ldv_56276: 
#line 1837 
  ;
  
#line 1836 
  if (i <= 99999) 
#line 1838 
                  goto ldv_56275; else 
#line 1841 
                                       goto ldv_56274;
  ldv_56274: 
#line 1842 
  ;
  
#line 1857 
  if (i > 99999) {
    int tmp_5;
    
#line 1857 
    tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_FWARE_REPORTED,(unsigned long *)(& tp->tg3_flags));
    
#line 1857 
    if (tmp_5 == 0) {
      
#line 1858 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_FWARE_REPORTED,(unsigned long *)(& tp->tg3_flags));
      
#line 1860 
      netdev_info((struct net_device const *)tp->dev,"No firmware running\n");
    }
    else ;
  }
  else ;
  
#line 1863 
  if (tp->pci_chip_rev_id == 1467502592U) {
    
#line 1867 
    unsigned long __ms = 10UL;
    {
      unsigned long tmp_6;
      
#line 1867 
      goto ldv_56279;
      ldv_56278: 
#line 1868 
      ;
      
#line 1867 
      __const_udelay(4295000UL);
      ldv_56279: 
#line 1869 
      ;
      
#line 1867 
      tmp_6 = __ms;
      
#line 1867 
      __ms -= 1UL;
      
#line 1867 
      ;
      
#line 1867 
      if (tmp_6 != 0UL) 
#line 1869 
                        goto ldv_56278; else 
#line 1872 
                                             goto ldv_56280;
      ldv_56280: 
#line 1873 
      ;
    }
  }
  else ;
  
#line 1870 
  __retres = 0;
  return_label: 
#line 1870 
                return __retres;
}


#line 1873  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_link_report(struct tg3 *tp)
{
  int tmp_6;
  bool tmp_5;
  
#line 1875 
  tmp_5 = netif_carrier_ok((struct net_device const *)tp->dev);
  
#line 1875 
  if (tmp_5) 
#line 1875 
             tmp_6 = 0; else 
#line 1875 
                             tmp_6 = 1;
  
#line 1875 
  if (tmp_6) {
    
#line 1876 
    if ((tp->msg_enable & 4U) != 0U) 
#line 1876 
                                     netdev_info((struct net_device const *)tp->dev,"Link is down\n"); else ;
    
#line 1877 
    tg3_ump_link_report(tp);
  }
  else 
    
#line 1878 
    if ((tp->msg_enable & 4U) != 0U) {
      char *tmp;
      int tmp_1;
      char *tmp_2;
      char *tmp_3;
      
#line 1881 
      if ((unsigned int)tp->link_config.active_duplex == 1U) 
#line 1881 
                                                             tmp = (char *)"full"; else 
                                                                    
#line 1881 
                                                                    tmp = (char *)"half";
      
#line 1879 
      if ((unsigned int)tp->link_config.active_speed != 1000U) {
        int tmp_0;
        
#line 1880 
        if ((unsigned int)tp->link_config.active_speed == 100U) 
#line 1880 
                                                                tmp_0 = 100; else 
                                                                    
#line 1880 
                                                                    tmp_0 = 10;
        
#line 1879 
        tmp_1 = tmp_0;
      }
      else 
#line 1879 
           tmp_1 = 1000;
      
#line 1879 
      ;
      
#line 1879 
      netdev_info((struct net_device const *)tp->dev,"Link is up at %d Mbps, %s duplex\n",tmp_1,tmp);
      
#line 1889 
      if (((int)tp->link_config.active_flowctrl & 2) != 0) 
#line 1889 
                                                           tmp_2 = (char *)"on"; else 
                                                                    
#line 1889 
                                                                    tmp_2 = (char *)"off";
      
#line 1887 
      if (((int)tp->link_config.active_flowctrl & 1) != 0) 
#line 1887 
                                                           tmp_3 = (char *)"on"; else 
                                                                    
#line 1887 
                                                                    tmp_3 = (char *)"off";
      
#line 1887 
      ;
      
#line 1887 
      netdev_info((struct net_device const *)tp->dev,"Flow control is %s for TX and %s for RX\n",tmp_3,tmp_2);
      
#line 1893 
      if ((tp->phy_flags & 262144U) != 0U) {
        char *tmp_4;
        
#line 1894 
        if (tp->setlpicnt != 0U) 
#line 1894 
                                 tmp_4 = (char *)"enabled"; else 
#line 1894 
                                                                 tmp_4 = (char *)"disabled";
        
#line 1894 
        ;
        
#line 1894 
        netdev_info((struct net_device const *)tp->dev,"EEE is %s\n",tmp_4);
      }
      else ;
      
#line 1897 
      tg3_ump_link_report(tp);
    }
    else ;
  
#line 1900 
  tp->link_up = netif_carrier_ok((struct net_device const *)tp->dev);
  
#line 1901 
  return;
}


#line 1903  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_decode_flowctrl_1000T(u32 adv)
{
  
#line 1905 
  u32 flowctrl = 0U;
  
#line 1907 
  if ((adv & 1024U) != 0U) {
    
#line 1908 
    flowctrl |= 2U;
    
#line 1909 
    if ((adv & 2048U) == 0U) 
#line 1910 
                             flowctrl |= 1U; else ;
  }
  else 
    
#line 1911 
    if ((adv & 2048U) != 0U) 
#line 1912 
                             flowctrl |= 1U; else ;
  
#line 1914 
  return flowctrl;
}


#line 1917  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u16 tg3_advert_flowctrl_1000X(u8 flow_ctrl)
{
  u16 miireg;
  
#line 1921 
  if (((int)flow_ctrl & 1) != 0 && ((int)flow_ctrl & 2) != 0) 
#line 1922 
                                                              miireg = (unsigned short)128U;
  else 
    
#line 1923 
    if (((int)flow_ctrl & 1) != 0) 
#line 1924 
                                   miireg = (unsigned short)256U;
    else 
      
#line 1925 
      if (((int)flow_ctrl & 2) != 0) 
#line 1926 
                                     miireg = (unsigned short)384U; else 
                                                                    
#line 1928 
                                                                    miireg = (unsigned short)0U;
  
#line 1930 
  return miireg;
}


#line 1933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_decode_flowctrl_1000X(u32 adv)
{
  
#line 1935 
  u32 flowctrl = 0U;
  
#line 1937 
  if ((adv & 128U) != 0U) {
    
#line 1938 
    flowctrl |= 2U;
    
#line 1939 
    if ((adv & 256U) == 0U) 
#line 1940 
                            flowctrl |= 1U; else ;
  }
  else 
    
#line 1941 
    if ((adv & 256U) != 0U) 
#line 1942 
                            flowctrl |= 1U; else ;
  
#line 1944 
  return flowctrl;
}


#line 1947  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u8 tg3_resolve_flowctrl_1000X(u16 lcladv, u16 rmtadv)
{
  
#line 1949 
  u8 cap = (unsigned char)0U;
  
#line 1951 
  if ((((int)lcladv & (int)rmtadv) & 128) != 0) 
#line 1952 
                                                cap = (unsigned char)3U;
  else 
    
#line 1953 
    if ((((int)lcladv & (int)rmtadv) & 256) != 0) {
      
#line 1954 
      if (((int)lcladv & 128) != 0) 
#line 1955 
                                    cap = (unsigned char)2U; else ;
      
#line 1956 
      if (((int)rmtadv & 128) != 0) 
#line 1957 
                                    cap = (unsigned char)1U; else ;
    }
    else ;
  
#line 1960 
  return cap;
}


#line 1963  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_setup_flow_control(struct tg3 *tp, u32 lcladv, u32 rmtadv)
{
  u8 autoneg;
  int tmp;
  
#line 1966 
  u8 flowctrl = (unsigned char)0U;
  
#line 1967 
  u32 old_rx_mode = tp->rx_mode;
  
#line 1968 
  u32 old_tx_mode = tp->tx_mode;
  
#line 1970 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 1970 
  if (tmp != 0) 
#line 1971 
                autoneg = (unsigned char)((tp->mdio_bus)->phy_map[(int)tp->phy_addr])->autoneg; else 
                                                                    
#line 1973 
                                                                    autoneg = tp->link_config.autoneg;
  
#line 1975 
  if ((unsigned int)autoneg == 1U) {
    int tmp_0;
    
#line 1975 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags));
    
#line 1975 
    if (tmp_0 != 0) 
      
#line 1976 
      if ((tp->phy_flags & 48U) != 0U) 
#line 1977 
                                       flowctrl = tg3_resolve_flowctrl_1000X((unsigned short)((int)((unsigned short)lcladv)),(unsigned short)((int)((unsigned short)rmtadv))); else 
                                                                    
#line 1979 
                                                                    flowctrl = mii_resolve_flowctrl_fdx((unsigned short)((int)((unsigned short)lcladv)),(unsigned short)((int)((unsigned short)rmtadv)));
    else 
#line 1981 
         flowctrl = tp->link_config.flowctrl;
  }
  else 
#line 1981 
       flowctrl = tp->link_config.flowctrl;
  
#line 1983 
  tp->link_config.active_flowctrl = flowctrl;
  
#line 1985 
  if (((int)flowctrl & 2) != 0) 
#line 1986 
                                tp->rx_mode |= 4U; else 
#line 1988 
                                                        tp->rx_mode &= 4294967291U;
  
#line 1990 
  if (tp->rx_mode != old_rx_mode) 
#line 1991 
                                  _tw32_flush(tp,1128U,tp->rx_mode,0U); else ;
  
#line 1993 
  if (((int)flowctrl & 1) != 0) 
#line 1994 
                                tp->tx_mode |= 16U; else 
#line 1996 
                                                         tp->tx_mode &= 4294967279U;
  
#line 1998 
  if (tp->tx_mode != old_tx_mode) 
#line 1999 
                                  _tw32_flush(tp,1116U,tp->tx_mode,0U); else ;
  
#line 2000 
  return;
}


#line 2002  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_adjust_link(struct net_device *dev)
{
  u8 oldflowctrl;
  u32 mac_mode;
  u32 lcl_adv;
  u32 rmt_adv;
  
#line 2004 
  u8 linkmesg = (unsigned char)0U;
  
#line 2006 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 2007 
  struct phy_device *phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
  
#line 2009 
  ldv_spin_lock_bh_90(& tp->lock);
  
#line 2011 
  mac_mode = tp->mac_mode & 4294967281U;
  
#line 2014 
  oldflowctrl = tp->link_config.active_flowctrl;
  
#line 2016 
  if (phydev->link != 0) {
    
#line 2017 
    lcl_adv = 0U;
    
#line 2018 
    rmt_adv = 0U;
    
#line 2020 
    if (phydev->speed == 100 || phydev->speed == 10) 
#line 2021 
                                                     mac_mode |= 4U;
    else 
      
#line 2022 
      if (phydev->speed == 1000 || tp->pci_chip_rev_id >> 12 != 22405U) 
        
#line 2024 
        mac_mode |= 8U; else 
#line 2026 
                             mac_mode |= 4U;
    
#line 2028 
    if (phydev->duplex == 0) 
#line 2029 
                             mac_mode |= 2U;
    else {
      u16 tmp_0;
      
#line 2031 
      tmp_0 = mii_advertise_flowctrl((int)tp->link_config.flowctrl);
      
#line 2031 
      lcl_adv = (unsigned int)tmp_0;
      
#line 2034 
      if (phydev->pause != 0) 
#line 2035 
                              rmt_adv = 1024U; else ;
      
#line 2036 
      if (phydev->asym_pause != 0) 
#line 2037 
                                   rmt_adv |= 2048U; else ;
    }
    
#line 2040 
    tg3_setup_flow_control(tp,lcl_adv,rmt_adv);
  }
  else 
#line 2042 
       mac_mode |= 8U;
  
#line 2044 
  if (tp->mac_mode != mac_mode) {
    
#line 2045 
    tp->mac_mode = mac_mode;
    
#line 2046 
    _tw32_flush(tp,1024U,tp->mac_mode,0U);
    
#line 2047 
    __const_udelay(171800UL);
  }
  else ;
  
#line 2050 
  if (tp->pci_chip_rev_id >> 12 == 22405U) 
    
#line 2051 
    if (phydev->speed == 10) 
#line 2052 
                             (*(tp->write32))(tp,1104U,3U); else 
#line 2056 
                                                                 (*(tp->write32))(tp,1104U,1U);
  else ;
  
#line 2059 
  if (phydev->speed == 1000 && phydev->duplex == 0) 
#line 2060 
                                                    (*(tp->write32))(tp,1124U,9983U); else 
                                                                    
#line 2065 
                                                                    (*(tp->write32))(tp,1124U,9760U);
  
#line 2070 
  if (((phydev->link != tp->old_link || phydev->speed != (int)tp->link_config.active_speed) || phydev->duplex != (int)tp->link_config.active_duplex) || (int)tp->link_config.active_flowctrl != (int)oldflowctrl) 
    
#line 2074 
    linkmesg = (unsigned char)1U; else ;
  
#line 2076 
  tp->old_link = phydev->link;
  
#line 2077 
  tp->link_config.active_speed = (unsigned short)phydev->speed;
  
#line 2078 
  tp->link_config.active_duplex = (unsigned char)phydev->duplex;
  
#line 2080 
  ldv_spin_unlock_bh_91(& tp->lock);
  
#line 2082 
  if ((unsigned int)linkmesg != 0U) 
#line 2083 
                                    tg3_link_report(tp); else ;
  
#line 2084 
  return;
}


#line 2086  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_init(struct tg3 *tp)
{
  int __retres;
  struct phy_device *phydev;
  char const *tmp;
  bool tmp_1;
  
#line 2090 
  if ((tp->phy_flags & 2U) != 0U) {
    
#line 2091 
    __retres = 0;
    
#line 2091 
    goto return_label;
  }
  else ;
  
#line 2094 
  tg3_bmcr_reset(tp);
  
#line 2096 
  phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
  
#line 2099 
  ;
  
#line 2099 
  tmp = dev_name((struct device const *)(& phydev->dev));
  
#line 2099 
  ;
  
#line 2099 
  phydev = phy_connect(tp->dev,tmp,& tg3_adjust_link,phydev->interface);
  
#line 2101 
  tmp_1 = IS_ERR((void const *)phydev);
  
#line 2101 
  if ((int)tmp_1 != 0) {
    long tmp_0;
    
#line 2102 
    dev_err((struct device const *)(& (tp->pdev)->dev),"Could not attach to PHY\n");
    
#line 2103 
    tmp_0 = PTR_ERR((void const *)phydev);
    
#line 2103 
    __retres = (int)tmp_0;
    
#line 2103 
    goto return_label;
  }
  else ;
  
#line 2107 
  switch ((unsigned int)phydev->interface) {
    case (unsigned int)2: 
#line 2108 
    ;
    case (unsigned int)7: 
#line 2109 
    ;
    
#line 2110 
    if ((tp->phy_flags & 128U) == 0U) {
      
#line 2111 
      phydev->supported &= 25343U;
      
#line 2114 
      goto ldv_56326;
    }
    else ;
    case (unsigned int)1: 
#line 2117 
    ;
    
#line 2118 
    phydev->supported &= 25295U;
    
#line 2121 
    goto ldv_56326;
    default: 
#line 2122 
    ;
    
#line 2123 
    phy_disconnect((tp->mdio_bus)->phy_map[(int)tp->phy_addr]);
    
#line 2124 
    __retres = -22;
    
#line 2124 
    goto return_label;
  }
  ldv_56326: 
#line 2127 
  ;
  
#line 2127 
  tp->phy_flags |= 2U;
  
#line 2129 
  phydev->advertising = phydev->supported;
  
#line 2131 
  __retres = 0;
  return_label: 
#line 2131 
                return __retres;
}


#line 2134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_start(struct tg3 *tp)
{
  struct phy_device *phydev;
  
#line 2138 
  if ((tp->phy_flags & 2U) == 0U) 
#line 2139 
                                  goto return_label; else ;
  
#line 2141 
  phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
  
#line 2143 
  if ((tp->phy_flags & 1U) != 0U) {
    
#line 2144 
    tp->phy_flags &= 4294967294U;
    
#line 2145 
    phydev->speed = (int)tp->link_config.speed;
    
#line 2146 
    phydev->duplex = (int)tp->link_config.duplex;
    
#line 2147 
    phydev->autoneg = (int)tp->link_config.autoneg;
    
#line 2148 
    phydev->advertising = tp->link_config.advertising;
  }
  else ;
  
#line 2151 
  phy_start(phydev);
  
#line 2153 
  phy_start_aneg(phydev);
  return_label: 
#line 2154 
                return;
}


#line 2156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_stop(struct tg3 *tp)
{
  
#line 2158 
  if ((tp->phy_flags & 2U) == 0U) 
#line 2159 
                                  goto return_label; else ;
  
#line 2161 
  phy_stop((tp->mdio_bus)->phy_map[(int)tp->phy_addr]);
  return_label: 
#line 2162 
                return;
}


#line 2164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_fini(struct tg3 *tp)
{
  
#line 2166 
  if ((tp->phy_flags & 2U) != 0U) {
    
#line 2167 
    phy_disconnect((tp->mdio_bus)->phy_map[(int)tp->phy_addr]);
    
#line 2168 
    tp->phy_flags &= 4294967293U;
  }
  else ;
  
#line 2170 
  return;
}


#line 2172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_set_extloopbk(struct tg3 *tp)
{
  int __retres;
  int err;
  u32 val;
  
#line 2177 
  if ((tp->phy_flags & 64U) != 0U) {
    
#line 2178 
    __retres = 0;
    
#line 2178 
    goto return_label;
  }
  else ;
  
#line 2180 
  if ((tp->phy_id & 4294967280U) == 1610645584U) {
    
#line 2182 
    err = tg3_phy_auxctl_write(tp,0,52256U);
    
#line 2186 
    goto done;
  }
  else ;
  
#line 2189 
  err = tg3_phy_auxctl_read(tp,0,& val);
  
#line 2191 
  if (err != 0) {
    
#line 2192 
    __retres = err;
    
#line 2192 
    goto return_label;
  }
  else ;
  
#line 2194 
  val |= 32768U;
  
#line 2195 
  err = tg3_phy_auxctl_write(tp,0,val);
  done: 
#line 2198 
  ;
  
#line 2199 
  __retres = err;
  return_label: 
#line 2199 
                return __retres;
}


#line 2202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_fet_toggle_apd(struct tg3 *tp, bool enable)
{
  u32 phytest;
  int tmp_0;
  
#line 2206 
  tmp_0 = tg3_readphy(tp,31,& phytest);
  
#line 2206 
  if (tmp_0 == 0) {
    u32 phy;
    int tmp;
    
#line 2209 
    tg3_writephy(tp,31,phytest | 128U);
    
#line 2211 
    tmp = tg3_readphy(tp,27,& phy);
    
#line 2211 
    if (tmp == 0) {
      
#line 2212 
      if ((int)enable != 0) 
#line 2213 
                            phy |= 32U; else 
#line 2215 
                                             phy &= 4294967263U;
      
#line 2216 
      tg3_writephy(tp,27,phy);
    }
    else ;
    
#line 2218 
    tg3_writephy(tp,31,phytest);
  }
  else ;
  
#line 2220 
  return;
}


#line 2222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_toggle_apd(struct tg3 *tp, bool enable)
{
  u32 reg;
  int tmp;
  
#line 2226 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 2226 
  if (tmp == 0) 
#line 2229 
                goto return_label;
  else {
    int tmp_0;
    
#line 2226 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 2226 
    if (tmp_0 != 0) {
      
#line 2227 
      if ((tp->phy_flags & 32U) != 0U) 
#line 2229 
                                       goto return_label; else ;
    }
    else ;
  }
  
#line 2231 
  if ((tp->phy_flags & 64U) != 0U) {
    
#line 2232 
    tg3_phy_fet_toggle_apd(tp,(_Bool)((bool)((int)enable) != 0));
    
#line 2233 
    goto return_label;
  }
  else ;
  
#line 2236 
  reg = 29U;
  
#line 2240 
  if (tp->pci_chip_rev_id >> 12 != 22404U || ! enable) 
#line 2241 
                                                       reg |= 2U; else ;
  
#line 2243 
  tg3_phy_shdw_write(tp,5120,reg);
  
#line 2246 
  reg = 1U;
  
#line 2247 
  if ((int)enable != 0) 
#line 2248 
                        reg |= 32U; else ;
  
#line 2250 
  tg3_phy_shdw_write(tp,10240,reg);
  return_label: 
#line 2251 
                return;
}


#line 2253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_toggle_automdix(struct tg3 *tp, bool enable)
{
  u32 phy;
  int tmp;
  
#line 2257 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 2257 
  if (tmp == 0) 
#line 2259 
                goto return_label;
  else 
    
#line 2257 
    if ((tp->phy_flags & 48U) != 0U) 
#line 2259 
                                     goto return_label; else ;
  
#line 2261 
  if ((tp->phy_flags & 64U) != 0U) {
    u32 ephy;
    int tmp_1;
    
#line 2264 
    tmp_1 = tg3_readphy(tp,31,& ephy);
    
#line 2264 
    if (tmp_1 == 0) {
      int tmp_0;
      
#line 2265 
      u32 reg = 16U;
      
#line 2267 
      tg3_writephy(tp,31,ephy | 128U);
      
#line 2269 
      tmp_0 = tg3_readphy(tp,(int)reg,& phy);
      
#line 2269 
      if (tmp_0 == 0) {
        
#line 2270 
        if ((int)enable != 0) 
#line 2271 
                              phy |= 16384U; else 
#line 2273 
                                                  phy &= 4294950911U;
        
#line 2274 
        tg3_writephy(tp,(int)reg,phy);
      }
      else ;
      
#line 2276 
      tg3_writephy(tp,31,ephy);
    }
    else ;
  }
  else {
    int ret;
    
#line 2281 
    ret = tg3_phy_auxctl_read(tp,7,& phy);
    
#line 2283 
    if (ret == 0) {
      
#line 2284 
      if ((int)enable != 0) 
#line 2285 
                            phy |= 512U; else 
#line 2287 
                                              phy &= 4294966783U;
      
#line 2288 
      tg3_phy_auxctl_write(tp,7,phy);
    }
    else ;
  }
  return_label: 
#line 2291 
                return;
}


#line 2294  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_set_wirespeed(struct tg3 *tp)
{
  int ret;
  u32 val;
  
#line 2299 
  if ((tp->phy_flags & 1024U) != 0U) 
#line 2300 
                                     goto return_label; else ;
  
#line 2302 
  ret = tg3_phy_auxctl_read(tp,7,& val);
  
#line 2303 
  if (ret == 0) 
#line 2304 
                tg3_phy_auxctl_write(tp,7,val | 16U); else ;
  return_label: 
#line 2306 
                return;
}


#line 2308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_apply_otp(struct tg3 *tp)
{
  u32 otp;
  u32 phy;
  int tmp;
  
#line 2312 
  if (tp->phy_otp == 0U) 
#line 2313 
                         goto return_label; else ;
  
#line 2315 
  otp = tp->phy_otp;
  
#line 2317 
  tmp = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)1);
  
#line 2317 
  if (tmp != 0) 
#line 2318 
                goto return_label; else ;
  
#line 2320 
  phy = (otp >> 1) & 112U;
  
#line 2321 
  phy |= 7U;
  
#line 2322 
  tg3_phydsp_write(tp,1U,phy);
  
#line 2324 
  phy = (otp >> 1) & 896U;
  
#line 2326 
  tg3_phydsp_write(tp,31U,phy);
  
#line 2328 
  phy = (otp >> 11) & 1U;
  
#line 2329 
  phy |= 2U;
  
#line 2330 
  tg3_phydsp_write(tp,24607U,phy);
  
#line 2332 
  phy = otp >> 24;
  
#line 2333 
  tg3_phydsp_write(tp,3957U,phy);
  
#line 2335 
  phy = (otp >> 8) & 240U;
  
#line 2336 
  tg3_phydsp_write(tp,3990U,phy);
  
#line 2338 
  phy = ((otp >> 11) & 7168U) | ((otp >> 16) & 28U);
  
#line 2340 
  tg3_phydsp_write(tp,3991U,phy);
  
#line 2342 
  tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)0);
  return_label: 
#line 2343 
                return;
}


#line 2345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_eee_pull_config(struct tg3 *tp, struct ethtool_eee *eee)
{
  u32 val;
  int tmp;
  int tmp_0;
  int tmp_1;
  u32 tmp_2;
  
#line 2348 
  struct ethtool_eee *dest = & tp->eee;
  
#line 2350 
  if ((tp->phy_flags & 262144U) == 0U) 
#line 2351 
                                       goto return_label; else ;
  
#line 2353 
  if (eee != (struct ethtool_eee *)0) 
#line 2354 
                                      dest = eee; else ;
  
#line 2356 
  tmp = tg3_phy_cl45_read(tp,7U,32830U,& val);
  
#line 2356 
  if (tmp != 0) 
#line 2357 
                goto return_label; else ;
  
#line 2360 
  if (val == 4U || val == 2U) 
#line 2362 
                              dest->eee_active = 1U; else 
#line 2364 
                                                          dest->eee_active = 0U;
  
#line 2367 
  tmp_0 = tg3_phy_cl45_read(tp,7U,61U,& val);
  
#line 2367 
  if (tmp_0 != 0) 
#line 2368 
                  goto return_label; else ;
  
#line 2369 
  dest->lp_advertised = mmd_eee_adv_to_ethtool_adv_t((unsigned short)((int)((unsigned short)val)));
  
#line 2372 
  tmp_1 = tg3_phy_cl45_read(tp,7U,60U,& val);
  
#line 2372 
  if (tmp_1 != 0) 
#line 2373 
                  goto return_label; else ;
  
#line 2374 
  dest->eee_enabled = (unsigned int)(val != 0U);
  
#line 2375 
  dest->advertised = mmd_eee_adv_to_ethtool_adv_t((unsigned short)((int)((unsigned short)val)));
  
#line 2378 
  val = (*(tp->read32))(tp,14000U);
  
#line 2379 
  dest->tx_lpi_enabled = (unsigned int)((val & 256U) != 0U);
  
#line 2382 
  tmp_2 = (*(tp->read32))(tp,14004U);
  
#line 2382 
  dest->tx_lpi_timer = tmp_2 & 65535U;
  return_label: 
#line 2383 
                return;
}


#line 2385  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_eee_adjust(struct tg3 *tp, bool current_link_up)
{
  u32 val;
  
#line 2389 
  if ((tp->phy_flags & 262144U) == 0U) 
#line 2390 
                                       goto return_label; else ;
  
#line 2392 
  tp->setlpicnt = 0U;
  
#line 2394 
  if ((((unsigned int)tp->link_config.autoneg == 1U && (int)current_link_up != 0) && (unsigned int)tp->link_config.active_duplex == 1U) && ((unsigned int)tp->link_config.active_speed == 100U || (unsigned int)tp->link_config.active_speed == 1000U)) {
    u32 eeectl;
    
#line 2401 
    if ((unsigned int)tp->link_config.active_speed == 1000U) 
#line 2402 
                                                             eeectl = 413U; else 
                                                                    
#line 2404 
                                                                    eeectl = 900U;
    
#line 2406 
    (*(tp->write32))(tp,14032U,eeectl);
    
#line 2408 
    tg3_eee_pull_config(tp,(struct ethtool_eee *)0);
    
#line 2409 
    if (tp->eee.eee_active != 0U) 
#line 2410 
                                  tp->setlpicnt = 2U; else ;
  }
  else ;
  
#line 2413 
  if (tp->setlpicnt == 0U) {
    
#line 2414 
    if ((int)current_link_up != 0) {
      int tmp;
      
#line 2414 
      tmp = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)1);
      
#line 2414 
      if (tmp == 0) {
        
#line 2416 
        tg3_phydsp_write(tp,26U,0U);
        
#line 2417 
        tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)0);
      }
      else ;
    }
    else ;
    
#line 2420 
    val = (*(tp->read32))(tp,14000U);
    
#line 2421 
    (*(tp->write32))(tp,14000U,val & 4294967167U);
  }
  else ;
  return_label: 
#line 2423 
                return;
}


#line 2425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_eee_enable(struct tg3 *tp)
{
  u32 val;
  
#line 2429 
  if ((unsigned int)tp->link_config.active_speed == 1000U) {
    
#line 2429 
    if (tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) 
      
#line 2429 
      goto _LOR;
    else {
      int tmp;
      
#line 2431 
      tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
      
#line 2431 
      if (tmp != 0) {
        int tmp_0;
        _LOR: 
#line 2432 
        tmp_0 = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)1);
        
#line 2432 
        if (tmp_0 == 0) {
          
#line 2434 
          val = 3U;
          
#line 2436 
          tg3_phydsp_write(tp,26U,val);
          
#line 2437 
          tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)0);
        }
        else ;
      }
      else ;
    }
  }
  else ;
  
#line 2440 
  val = (*(tp->read32))(tp,14000U);
  
#line 2441 
  (*(tp->write32))(tp,14000U,val | 128U);
  
#line 2442 
  return;
}


#line 2444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_wait_macro_done(struct tg3 *tp)
{
  int __retres;
  int tmp_0;
  
#line 2446 
  int limit = 100;
  
#line 2448 
  goto ldv_56397;
  ldv_56396: 
#line 2449 
  ;
  {
    u32 tmp32;
    int tmp;
    
#line 2451 
    tmp = tg3_readphy(tp,22,& tmp32);
    
#line 2451 
    if (tmp == 0) {
      
#line 2452 
      if ((tmp32 & 4096U) == 0U) 
#line 2453 
                                 goto ldv_56395; else ;
    }
    else ;
  }
  ldv_56397: 
#line 2455 
  ;
  
#line 2448 
  tmp_0 = limit;
  
#line 2448 
  limit -= 1;
  
#line 2448 
  ;
  
#line 2448 
  if (tmp_0 != 0) 
#line 2450 
                  goto ldv_56396; else 
#line 2453 
                                       goto ldv_56395;
  ldv_56395: 
#line 2454 
  ;
  
#line 2456 
  if (limit < 0) {
    
#line 2457 
    __retres = -16;
    
#line 2457 
    goto return_label;
  }
  else ;
  
#line 2459 
  __retres = 0;
  return_label: 
#line 2459 
                return __retres;
}


#line 2462  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_write_and_check_testpat(struct tg3 *tp, int *resetp)
{
  int __retres;
  int chan;
  
#line 2464 
  u32 const test_pat[4U][6U] = {{21845U, 5U, 10922U, 10U, 13398U, 3U}, {10922U, 10U, 13107U, 3U, 30874U, 5U}, {23130U, 5U, 10858U, 10U, 7117U, 3U}, {10842U, 10U, 13251U, 3U, 12017U, 5U}};
  
#line 2472 
  chan = 0;
  
#line 2472 
  goto ldv_56414;
  ldv_56413: 
#line 2473 
  ;
  {
    int i;
    int tmp;
    int tmp_0;
    int tmp_1;
    
#line 2475 
    tg3_writephy(tp,23,(unsigned int)(chan * 8192 | 512));
    
#line 2477 
    tg3_writephy(tp,22,2U);
    
#line 2479 
    i = 0;
    
#line 2479 
    goto ldv_56406;
    ldv_56405: 
#line 2480 
    ;
    
#line 2480 
    tg3_writephy(tp,21,test_pat[chan][i]);
    
#line 2479 
    i += 1;
    ldv_56406: 
#line 2480 
    ;
    
#line 2479 
    if (i <= 5) 
#line 2481 
                goto ldv_56405; else 
#line 2484 
                                     goto ldv_56407;
    ldv_56407: 
#line 2485 
    ;
    
#line 2483 
    tg3_writephy(tp,22,514U);
    
#line 2484 
    tmp = tg3_wait_macro_done(tp);
    
#line 2484 
    if (tmp != 0) {
      
#line 2485 
      *resetp = 1;
      
#line 2486 
      __retres = -16;
      
#line 2486 
      goto return_label;
    }
    else ;
    
#line 2489 
    tg3_writephy(tp,23,(unsigned int)(chan * 8192 | 512));
    
#line 2491 
    tg3_writephy(tp,22,130U);
    
#line 2492 
    tmp_0 = tg3_wait_macro_done(tp);
    
#line 2492 
    if (tmp_0 != 0) {
      
#line 2493 
      *resetp = 1;
      
#line 2494 
      __retres = -16;
      
#line 2494 
      goto return_label;
    }
    else ;
    
#line 2497 
    tg3_writephy(tp,22,2050U);
    
#line 2498 
    tmp_1 = tg3_wait_macro_done(tp);
    
#line 2498 
    if (tmp_1 != 0) {
      
#line 2499 
      *resetp = 1;
      
#line 2500 
      __retres = -16;
      
#line 2500 
      goto return_label;
    }
    else ;
    
#line 2503 
    i = 0;
    
#line 2503 
    goto ldv_56411;
    ldv_56410: 
#line 2504 
    ;
    {
      u32 low;
      u32 high;
      int tmp_2;
      
#line 2506 
      tmp_2 = tg3_readphy(tp,21,& low);
      
#line 2506 
      if (tmp_2 != 0) 
#line 2506 
                      goto _LOR;
      else {
        int tmp_3;
        
#line 2506 
        tmp_3 = tg3_readphy(tp,21,& high);
        
#line 2506 
        if (tmp_3 != 0) 
#line 2506 
                        goto _LOR;
        else {
          int tmp_4;
          
#line 2507 
          tmp_4 = tg3_wait_macro_done(tp);
          
#line 2507 
          if (tmp_4 != 0) {
            _LOR: {
                    
#line 2509 
                    *resetp = 1;
                    
#line 2510 
                    __retres = -16;
                    
#line 2510 
                    goto return_label;
                  }
          }
          else ;
        }
      }
      
#line 2512 
      low &= 32767U;
      
#line 2513 
      high &= 15U;
      
#line 2514 
      if (test_pat[chan][i] != low || test_pat[chan][i + 1] != high) {
        
#line 2516 
        tg3_writephy(tp,23,11U);
        
#line 2517 
        tg3_writephy(tp,21,16385U);
        
#line 2518 
        tg3_writephy(tp,21,16389U);
        
#line 2520 
        __retres = -16;
        
#line 2520 
        goto return_label;
      }
      else ;
    }
    
#line 2503 
    i += 2;
    ldv_56411: 
#line 2504 
    ;
    
#line 2503 
    if (i <= 5) 
#line 2505 
                goto ldv_56410; else 
#line 2508 
                                     goto ldv_56412;
    ldv_56412: 
#line 2509 
    ;
  }
  
#line 2472 
  chan += 1;
  ldv_56414: 
#line 2473 
  ;
  
#line 2472 
  if (chan <= 3) 
#line 2474 
                 goto ldv_56413; else 
#line 2477 
                                      goto ldv_56415;
  ldv_56415: 
#line 2478 
  ;
  
#line 2525 
  __retres = 0;
  return_label: 
#line 2525 
                return __retres;
}


#line 2528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_reset_chanpat(struct tg3 *tp)
{
  int __retres;
  int chan;
  
#line 2532 
  chan = 0;
  
#line 2532 
  goto ldv_56425;
  ldv_56424: 
#line 2533 
  ;
  {
    int i;
    int tmp;
    
#line 2535 
    tg3_writephy(tp,23,(unsigned int)(chan * 8192 | 512));
    
#line 2537 
    tg3_writephy(tp,22,2U);
    
#line 2538 
    i = 0;
    
#line 2538 
    goto ldv_56422;
    ldv_56421: 
#line 2539 
    ;
    
#line 2539 
    tg3_writephy(tp,21,0U);
    
#line 2538 
    i += 1;
    ldv_56422: 
#line 2539 
    ;
    
#line 2538 
    if (i <= 5) 
#line 2540 
                goto ldv_56421; else 
#line 2543 
                                     goto ldv_56423;
    ldv_56423: 
#line 2544 
    ;
    
#line 2540 
    tg3_writephy(tp,22,514U);
    
#line 2541 
    tmp = tg3_wait_macro_done(tp);
    
#line 2541 
    if (tmp != 0) {
      
#line 2542 
      __retres = -16;
      
#line 2542 
      goto return_label;
    }
    else ;
  }
  
#line 2532 
  chan += 1;
  ldv_56425: 
#line 2533 
  ;
  
#line 2532 
  if (chan <= 3) 
#line 2534 
                 goto ldv_56424; else 
#line 2537 
                                      goto ldv_56426;
  ldv_56426: 
#line 2538 
  ;
  
#line 2545 
  __retres = 0;
  return_label: 
#line 2545 
                return __retres;
}


#line 2548  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_reset_5703_4_5(struct tg3 *tp)
{
  int __retres;
  u32 reg32;
  u32 phy9_orig;
  int retries;
  int do_phy_reset;
  int err;
  int tmp;
  int tmp_0;
  
#line 2553 
  retries = 10;
  
#line 2554 
  do_phy_reset = 1;
  ldv_56437: 
#line 2555 
  ;
  
#line 2556 
  if (do_phy_reset != 0) {
    
#line 2557 
    err = tg3_bmcr_reset(tp);
    
#line 2558 
    if (err != 0) {
      
#line 2559 
      __retres = err;
      
#line 2559 
      goto return_label;
    }
    else ;
    
#line 2560 
    do_phy_reset = 0;
  }
  else ;
  
#line 2564 
  tmp = tg3_readphy(tp,16,& reg32);
  
#line 2564 
  if (tmp != 0) 
#line 2565 
                goto ldv_56435; else ;
  
#line 2567 
  reg32 |= 12288U;
  
#line 2568 
  tg3_writephy(tp,16,reg32);
  
#line 2571 
  tg3_writephy(tp,0,320U);
  
#line 2575 
  tmp_0 = tg3_readphy(tp,9,& phy9_orig);
  
#line 2575 
  if (tmp_0 != 0) 
#line 2576 
                  goto ldv_56435; else ;
  
#line 2578 
  tg3_writephy(tp,9,6144U);
  
#line 2581 
  err = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)1);
  
#line 2582 
  if (err != 0) {
    
#line 2583 
    __retres = err;
    
#line 2583 
    goto return_label;
  }
  else ;
  
#line 2586 
  tg3_phydsp_write(tp,32773U,2048U);
  
#line 2588 
  err = tg3_phy_write_and_check_testpat(tp,& do_phy_reset);
  
#line 2589 
  if (err == 0) 
#line 2590 
                goto ldv_56436; else ;
  ldv_56435: 
#line 2591 
  ;
  
#line 2591 
  retries -= 1;
  
#line 2591 
  if (retries != 0) 
#line 2593 
                    goto ldv_56437; else 
#line 2596 
                                         goto ldv_56436;
  ldv_56436: 
#line 2597 
  ;
  
#line 2593 
  err = tg3_phy_reset_chanpat(tp);
  
#line 2594 
  if (err != 0) {
    
#line 2595 
    __retres = err;
    
#line 2595 
    goto return_label;
  }
  else ;
  
#line 2597 
  tg3_phydsp_write(tp,32773U,0U);
  
#line 2599 
  tg3_writephy(tp,23,33280U);
  
#line 2600 
  tg3_writephy(tp,22,0U);
  
#line 2602 
  tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)0);
  
#line 2604 
  tg3_writephy(tp,9,phy9_orig);
  
#line 2606 
  err = tg3_readphy(tp,16,& reg32);
  
#line 2607 
  if (err != 0) {
    
#line 2608 
    __retres = err;
    
#line 2608 
    goto return_label;
  }
  else ;
  
#line 2610 
  reg32 &= 4294955007U;
  
#line 2611 
  tg3_writephy(tp,16,reg32);
  
#line 2613 
  __retres = 0;
  return_label: 
#line 2613 
                return __retres;
}


#line 2616  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_carrier_off(struct tg3 *tp)
{
  
#line 2618 
  netif_carrier_off(tp->dev);
  
#line 2619 
  tp->link_up = (_Bool)0;
  
#line 2620 
  return;
}


#line 2622  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_warn_mgmt_link_flap(struct tg3 *tp)
{
  int tmp;
  
#line 2624 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 2624 
  if (tmp != 0) 
#line 2625 
                netdev_warn((struct net_device const *)tp->dev,"Management side-band traffic will be interrupted during phy settings change\n"); else ;
  
#line 2627 
  return;
}


#line 2632  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_reset(struct tg3 *tp)
{
  int __retres;
  u32 val;
  u32 cpmuctrl;
  int err;
  int tmp;
  bool tmp_0;
  int tmp_1;
  int tmp_7;
  
#line 2637 
  if (tp->pci_chip_rev_id >> 12 == 12U) {
    
#line 2638 
    val = (*(tp->read32))(tp,26628U);
    
#line 2639 
    _tw32_flush(tp,26628U,val & 4292870143U,0U);
    
#line 2640 
    __const_udelay(171800UL);
  }
  else ;
  
#line 2642 
  err = tg3_readphy(tp,1,& val);
  
#line 2643 
  tmp = tg3_readphy(tp,1,& val);
  
#line 2643 
  err = tmp | err;
  
#line 2644 
  if (err != 0) {
    
#line 2645 
    __retres = -16;
    
#line 2645 
    goto return_label;
  }
  else ;
  
#line 2647 
  tmp_0 = netif_running((struct net_device const *)tp->dev);
  
#line 2647 
  if ((int)tmp_0 != 0) {
    
#line 2647 
    if ((int)tp->link_up != 0) {
      
#line 2648 
      netif_carrier_off(tp->dev);
      
#line 2649 
      tg3_link_report(tp);
    }
    else ;
  }
  else ;
  
#line 2652 
  if ((tp->pci_chip_rev_id >> 12) + 4294967295U <= 2U) {
    
#line 2655 
    err = tg3_phy_reset_5703_4_5(tp);
    
#line 2656 
    if (err != 0) {
      
#line 2657 
      __retres = err;
      
#line 2657 
      goto return_label;
    }
    else ;
    
#line 2658 
    goto out;
  }
  else ;
  
#line 2661 
  cpmuctrl = 0U;
  
#line 2662 
  if (tp->pci_chip_rev_id >> 12 == 22404U && tp->pci_chip_rev_id >> 8 != 358464U) {
    
#line 2664 
    cpmuctrl = (*(tp->read32))(tp,13824U);
    
#line 2665 
    if ((cpmuctrl & 65536U) != 0U) 
#line 2666 
                                   (*(tp->write32))(tp,13824U,cpmuctrl & 4294901759U); else ;
  }
  else ;
  
#line 2670 
  err = tg3_bmcr_reset(tp);
  
#line 2671 
  if (err != 0) {
    
#line 2672 
    __retres = err;
    
#line 2672 
    goto return_label;
  }
  else ;
  
#line 2674 
  if ((cpmuctrl & 65536U) != 0U) {
    
#line 2675 
    val = 513U;
    
#line 2676 
    tg3_phydsp_write(tp,3848U,val);
    
#line 2678 
    (*(tp->write32))(tp,13824U,cpmuctrl);
  }
  else ;
  
#line 2681 
  if (tp->pci_chip_rev_id >> 8 == 358464U || tp->pci_chip_rev_id >> 8 == 357904U) {
    
#line 2683 
    val = (*(tp->read32))(tp,13836U);
    
#line 2684 
    if ((val & 2031616U) == 1114112U) {
      
#line 2686 
      val &= 4292935679U;
      
#line 2687 
      __const_udelay(171800UL);
      
#line 2688 
      _tw32_flush(tp,13836U,val,0U);
    }
    else ;
  }
  else ;
  
#line 2692 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 2692 
  if (tmp_1 != 0) {
    
#line 2692 
    if ((tp->phy_flags & 32U) != 0U) {
      
#line 2694 
      __retres = 0;
      
#line 2694 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2696 
  tg3_phy_apply_otp(tp);
  
#line 2698 
  if ((tp->phy_flags & 256U) != 0U) 
#line 2699 
                                    tg3_phy_toggle_apd(tp,(_Bool)1); else 
                                                                    
#line 2701 
                                                                    tg3_phy_toggle_apd(tp,(_Bool)0);
  out: 
#line 2703 
  ;
  
#line 2704 
  if ((tp->phy_flags & 8192U) != 0U) {
    int tmp_2;
    
#line 2704 
    tmp_2 = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)1);
    
#line 2704 
    if (tmp_2 == 0) {
      
#line 2706 
      tg3_phydsp_write(tp,8223U,10922U);
      
#line 2707 
      tg3_phydsp_write(tp,10U,803U);
      
#line 2708 
      tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 2711 
  if ((tp->phy_flags & 16384U) != 0U) {
    
#line 2712 
    tg3_writephy(tp,28,36200U);
    
#line 2713 
    tg3_writephy(tp,28,36200U);
  }
  else ;
  
#line 2716 
  if ((tp->phy_flags & 32768U) != 0U) {
    int tmp_3;
    
#line 2717 
    tmp_3 = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)1);
    
#line 2717 
    if (tmp_3 == 0) {
      
#line 2718 
      tg3_phydsp_write(tp,10U,12555U);
      
#line 2719 
      tg3_phydsp_write(tp,8223U,38150U);
      
#line 2720 
      tg3_phydsp_write(tp,16415U,5346U);
      
#line 2721 
      tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)0);
    }
    else ;
  }
  else 
    
#line 2723 
    if ((tp->phy_flags & 2048U) != 0U) {
      int tmp_4;
      
#line 2724 
      tmp_4 = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)1);
      
#line 2724 
      if (tmp_4 == 0) {
        
#line 2725 
        tg3_writephy(tp,23,10U);
        
#line 2726 
        if ((tp->phy_flags & 4096U) != 0U) {
          
#line 2727 
          tg3_writephy(tp,21,4363U);
          
#line 2728 
          tg3_writephy(tp,30,20U);
        }
        else 
#line 2731 
             tg3_writephy(tp,21,267U);
        
#line 2733 
        tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)0);
      }
      else ;
    }
    else ;
  
#line 2739 
  if ((tp->phy_id & 4294967280U) == 1610645584U) 
#line 2741 
                                                 tg3_phy_auxctl_write(tp,0,19488U);
  else {
    int tmp_5;
    
#line 2742 
    tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 2742 
    if (tmp_5 != 0) {
      
#line 2744 
      err = tg3_phy_auxctl_read(tp,0,& val);
      
#line 2746 
      if (err == 0) 
#line 2747 
                    tg3_phy_auxctl_write(tp,0,val | 16384U); else ;
    }
    else ;
  }
  
#line 2754 
  tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 2754 
  if (tmp_7 != 0) {
    int tmp_6;
    
#line 2755 
    tmp_6 = tg3_readphy(tp,16,& val);
    
#line 2755 
    if (tmp_6 == 0) 
#line 2756 
                    tg3_writephy(tp,16,val | 1U); else ;
  }
  else ;
  
#line 2760 
  if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 2762 
                                        tg3_writephy(tp,23,18U); else ;
  
#line 2765 
  if (tp->pci_chip_rev_id == 91627520U) 
#line 2766 
                                        tg3_phydsp_write(tp,4091U,16384U); else ;
  
#line 2768 
  tg3_phy_toggle_automdix(tp,(_Bool)1);
  
#line 2769 
  tg3_phy_set_wirespeed(tp);
  
#line 2770 
  __retres = 0;
  return_label: 
#line 2770 
                return __retres;
}


#line 2789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static u32 tg3_set_function_status(struct tg3 *tp, u32 newstat)
{
  u32 __retres;
  u32 status;
  u32 shift;
  
#line 2793 
  if (tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) 
    
#line 2795 
    status = tg3_ape_read32(tp,8U); else 
#line 2797 
                                         status = (*(tp->read32))(tp,13388U);
  
#line 2799 
  shift = (unsigned int)((tp->pci_fn + 1) * 4);
  
#line 2800 
  status = (unsigned int)(~ (3 << shift)) & status;
  
#line 2801 
  status = (newstat << shift) | status;
  
#line 2803 
  if (tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) 
    
#line 2805 
    tg3_ape_write32(tp,8U,status); else 
#line 2807 
                                        (*(tp->write32))(tp,13388U,status);
  
#line 2809 
  __retres = status >> 4;
  
#line 2809 
  return __retres;
}


#line 2812  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static int tg3_pwrsrc_switch_to_vmain(struct tg3 *tp)
{
  int __retres;
  int tmp;
  
#line 2814 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_NIC,(unsigned long *)(& tp->tg3_flags));
  
#line 2814 
  if (tmp == 0) {
    
#line 2815 
    __retres = 0;
    
#line 2815 
    goto return_label;
  }
  else ;
  
#line 2817 
  if ((tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) || tp->pci_chip_rev_id >> 12 == 22304U) {
    int tmp_0;
    
#line 2820 
    tmp_0 = tg3_ape_lock(tp,7);
    
#line 2820 
    if (tmp_0 != 0) {
      
#line 2821 
      __retres = -5;
      
#line 2821 
      goto return_label;
    }
    else ;
    
#line 2823 
    tg3_set_function_status(tp,1U);
    
#line 2825 
    _tw32_flush(tp,26632U,tp->grc_local_ctrl,100U);
    
#line 2828 
    tg3_ape_unlock(tp,7);
  }
  else 
#line 2830 
       _tw32_flush(tp,26632U,tp->grc_local_ctrl,100U);
  
#line 2834 
  __retres = 0;
  return_label: 
#line 2834 
                return __retres;
}


#line 2837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_pwrsrc_die_with_vmain(struct tg3 *tp)
{
  u32 grc_local_ctrl;
  int tmp;
  
#line 2841 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_NIC,(unsigned long *)(& tp->tg3_flags));
  
#line 2841 
  if (tmp == 0) 
#line 2844 
                goto return_label;
  else 
    
#line 2841 
    if (tp->pci_chip_rev_id >> 12 == 7U) 
#line 2844 
                                         goto return_label;
    else 
      
#line 2842 
      if (tp->pci_chip_rev_id >> 12 == 0U) 
#line 2844 
                                           goto return_label; else ;
  
#line 2846 
  grc_local_ctrl = tp->grc_local_ctrl | 4096U;
  
#line 2848 
  _tw32_flush(tp,26632U,grc_local_ctrl | 32768U,100U);
  
#line 2852 
  _tw32_flush(tp,26632U,grc_local_ctrl,100U);
  
#line 2856 
  _tw32_flush(tp,26632U,grc_local_ctrl | 32768U,100U);
  return_label: 
#line 2857 
                return;
}


#line 2861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_pwrsrc_switch_to_vaux(struct tg3 *tp)
{
  int tmp;
  
#line 2863 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_NIC,(unsigned long *)(& tp->tg3_flags));
  
#line 2863 
  if (tmp == 0) 
#line 2864 
                goto return_label; else ;
  
#line 2866 
  if (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) 
    
#line 2868 
    _tw32_flush(tp,26632U,tp->grc_local_ctrl | 63488U,100U);
  else 
    
#line 2875 
    if ((unsigned int)(tp->pdev)->device == 5761U || (unsigned int)(tp->pdev)->device == 5768U) {
      
#line 2878 
      u32 grc_local_ctrl = tp->grc_local_ctrl | 63488U;
      
#line 2884 
      _tw32_flush(tp,26632U,grc_local_ctrl,100U);
      
#line 2887 
      grc_local_ctrl |= 65536U;
      
#line 2888 
      _tw32_flush(tp,26632U,grc_local_ctrl,100U);
      
#line 2891 
      grc_local_ctrl &= 4294950911U;
      
#line 2892 
      _tw32_flush(tp,26632U,grc_local_ctrl,100U);
    }
    else {
      u32 no_gpio2;
      
#line 2896 
      u32 grc_local_ctrl_0 = 0U;
      
#line 2899 
      if (tp->pci_chip_rev_id >> 12 == 9U) {
        
#line 2900 
        grc_local_ctrl_0 |= 64U;
        
#line 2901 
        _tw32_flush(tp,26632U,tp->grc_local_ctrl | grc_local_ctrl_0,100U);
      }
      else ;
      
#line 2907 
      no_gpio2 = tp->nic_sram_data_cfg & 1048576U;
      
#line 2910 
      grc_local_ctrl_0 |= 112640U;
      
#line 2915 
      if (no_gpio2 != 0U) 
#line 2916 
                          grc_local_ctrl_0 &= 4294893567U; else ;
      
#line 2919 
      _tw32_flush(tp,26632U,tp->grc_local_ctrl | grc_local_ctrl_0,100U);
      
#line 2923 
      grc_local_ctrl_0 |= 16384U;
      
#line 2925 
      _tw32_flush(tp,26632U,tp->grc_local_ctrl | grc_local_ctrl_0,100U);
      
#line 2929 
      if (no_gpio2 == 0U) {
        
#line 2930 
        grc_local_ctrl_0 &= 4294901759U;
        
#line 2931 
        _tw32_flush(tp,26632U,tp->grc_local_ctrl | grc_local_ctrl_0,100U);
      }
      else ;
    }
  return_label: 
#line 2934 
                return;
}


#line 2938  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_frob_aux_power_5717(struct tg3 *tp, bool wol_enable)
{
  int tmp;
  int tmp_0;
  
#line 2940 
  u32 msg = 0U;
  
#line 2943 
  tmp = tg3_ape_lock(tp,7);
  
#line 2943 
  if (tmp != 0) 
#line 2944 
                goto return_label; else ;
  
#line 2946 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 2946 
  if (tmp_0 != 0) 
#line 2947 
                  msg = 2U;
  else {
    int tmp_1;
    
#line 2946 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
    
#line 2946 
    if (tmp_1 != 0) 
#line 2947 
                    msg = 2U;
    else 
      
#line 2946 
      if ((int)wol_enable != 0) 
#line 2947 
                                msg = 2U; else ;
  }
  
#line 2949 
  msg = tg3_set_function_status(tp,msg);
  
#line 2951 
  if ((msg & 4369U) != 0U) 
#line 2952 
                           goto done; else ;
  
#line 2954 
  if ((msg & 8738U) != 0U) 
#line 2955 
                           tg3_pwrsrc_switch_to_vaux(tp); else 
#line 2957 
                                                               tg3_pwrsrc_die_with_vmain(tp);
  done: 
#line 2959 
  ;
  
#line 2960 
  tg3_ape_unlock(tp,7);
  return_label: 
#line 2961 
                return;
}


#line 2963  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_frob_aux_power(struct tg3 *tp, bool include_wol)
{
  int tmp;
  
#line 2965 
  bool need_vaux = (_Bool)0;
  
#line 2968 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_NIC,(unsigned long *)(& tp->tg3_flags));
  
#line 2968 
  if (tmp == 0) 
#line 2969 
                goto return_label;
  else {
    int tmp_0;
    
#line 2968 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 2968 
    if (tmp_0 != 0) 
#line 2969 
                    goto return_label; else ;
  }
  
#line 2971 
  if ((tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) || tp->pci_chip_rev_id >> 12 == 22304U) {
    int tmp_2;
    
#line 2975 
    if ((int)include_wol != 0) {
      int tmp_1;
      
#line 2975 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 2975 
      if (tmp_1 != 0) 
#line 2975 
                      tmp_2 = 1; else 
#line 2975 
                                      tmp_2 = 0;
    }
    else 
#line 2975 
         tmp_2 = 0;
    
#line 2974 
    ;
    
#line 2974 
    tg3_frob_aux_power_5717(tp,(_Bool)((int)((_Bool)(tmp_2 != 0))));
    
#line 2976 
    goto return_label;
  }
  else ;
  
#line 2979 
  if (tp->pdev_peer != (struct pci_dev *)0 && tp->pdev_peer != tp->pdev) {
    struct net_device *dev_peer;
    
#line 2982 
    dev_peer = (struct net_device *)pci_get_drvdata(tp->pdev_peer);
    
#line 2985 
    if (dev_peer != (struct net_device *)0) {
      int tmp_5;
      
#line 2986 
      struct tg3 *tp_peer = netdev_priv((struct net_device const *)dev_peer);
      
#line 2988 
      tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp_peer->tg3_flags));
      
#line 2988 
      if (tmp_5 != 0) 
#line 2989 
                      goto return_label; else ;
      
#line 2991 
      if ((int)include_wol != 0) {
        int tmp_6;
        
#line 2991 
        tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp_peer->tg3_flags));
        
#line 2991 
        if (tmp_6 != 0) 
#line 2993 
                        need_vaux = (_Bool)1; else 
#line 2991 
                                                   goto _LAND;
      }
      else {
        int tmp_7;
        _LAND: 
#line 2991 
        tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp_peer->tg3_flags));
        
#line 2991 
        if (tmp_7 != 0) 
#line 2993 
                        need_vaux = (_Bool)1; else ;
      }
    }
    else ;
  }
  else ;
  
#line 2997 
  if ((int)include_wol != 0) {
    int tmp_8;
    
#line 2997 
    tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 2997 
    if (tmp_8 != 0) 
#line 2999 
                    need_vaux = (_Bool)1; else 
#line 2997 
                                               goto _LAND_0;
  }
  else {
    int tmp_9;
    _LAND_0: 
#line 2997 
    tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
    
#line 2997 
    if (tmp_9 != 0) 
#line 2999 
                    need_vaux = (_Bool)1; else ;
  }
  
#line 3001 
  if ((int)need_vaux != 0) 
#line 3002 
                           tg3_pwrsrc_switch_to_vaux(tp); else 
#line 3004 
                                                               tg3_pwrsrc_die_with_vmain(tp);
  return_label: 
#line 3005 
                return;
}


#line 3007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_5700_link_polarity(struct tg3 *tp, u32 speed)
{
  int __retres;
  
#line 3009 
  if (tp->led_ctrl == 4096U) {
    
#line 3010 
    __retres = 1;
    
#line 3010 
    goto return_label;
  }
  else 
    
#line 3011 
    if ((tp->phy_id & 4294967280U) == 1610645616U) {
      
#line 3012 
      if (speed != 10U) {
        
#line 3013 
        __retres = 1;
        
#line 3013 
        goto return_label;
      }
      else ;
    }
    else 
      
#line 3014 
      if (speed == 10U) {
        
#line 3015 
        __retres = 1;
        
#line 3015 
        goto return_label;
      }
      else ;
  
#line 3017 
  __retres = 0;
  return_label: 
#line 3017 
                return __retres;
}


#line 3020  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_phy_power_bug(struct tg3 *tp)
{
  bool __retres;
  
#line 3022 
  switch (tp->pci_chip_rev_id >> 12) {
    case (u32)7: 
#line 3023 
    ;
    case (u32)2: 
#line 3024 
    ;
    
#line 3025 
    __retres = (_Bool)1;
    
#line 3025 
    goto return_label;
    case (u32)8: 
#line 3026 
    ;
    
#line 3027 
    if ((tp->phy_flags & 32U) != 0U) {
      
#line 3028 
      __retres = (_Bool)1;
      
#line 3028 
      goto return_label;
    }
    else ;
    
#line 3029 
    __retres = (_Bool)0;
    
#line 3029 
    goto return_label;
    case (u32)22295: 
#line 3030 
    ;
    
#line 3031 
    if (tp->pci_fn == 0) {
      
#line 3032 
      __retres = (_Bool)1;
      
#line 3032 
      goto return_label;
    }
    else ;
    
#line 3033 
    __retres = (_Bool)0;
    
#line 3033 
    goto return_label;
    case (u32)22297: 
#line 3034 
    ;
    case (u32)22304: 
#line 3035 
    ;
    
#line 3036 
    if ((tp->phy_flags & 16U) != 0U && tp->pci_fn == 0) {
      
#line 3038 
      __retres = (_Bool)1;
      
#line 3038 
      goto return_label;
    }
    else ;
    
#line 3039 
    __retres = (_Bool)0;
    
#line 3039 
    goto return_label;
  }
  
#line 3042 
  __retres = (_Bool)0;
  return_label: 
#line 3042 
                return __retres;
}


#line 3045  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_phy_led_bug(struct tg3 *tp)
{
  bool __retres;
  
#line 3047 
  switch (tp->pci_chip_rev_id >> 12) {
    case (u32)22297: 
#line 3048 
    ;
    case (u32)22304: 
#line 3049 
    ;
    
#line 3050 
    if ((tp->phy_flags & 32U) != 0U && tp->pci_fn == 0) {
      
#line 3052 
      __retres = (_Bool)1;
      
#line 3052 
      goto return_label;
    }
    else ;
    
#line 3053 
    __retres = (_Bool)0;
    
#line 3053 
    goto return_label;
  }
  
#line 3056 
  __retres = (_Bool)0;
  return_label: 
#line 3056 
                return __retres;
}


#line 3059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_power_down_phy(struct tg3 *tp, bool do_low_power)
{
  u32 val;
  bool tmp_5;
  
#line 3063 
  if ((tp->phy_flags & 1048576U) != 0U) 
#line 3064 
                                        goto return_label; else ;
  
#line 3066 
  if ((tp->phy_flags & 16U) != 0U) {
    
#line 3067 
    if (tp->pci_chip_rev_id >> 12 == 2U) {
      u32 tmp;
      u32 tmp_0;
      
#line 3068 
      tmp = (*(tp->read32))(tp,1456U);
      
#line 3068 
      u32 sg_dig_ctrl = tmp;
      
#line 3069 
      tmp_0 = (*(tp->read32))(tp,1424U);
      
#line 3069 
      u32 serdes_cfg = tmp_0;
      
#line 3071 
      sg_dig_ctrl |= 3221225472U;
      
#line 3073 
      (*(tp->write32))(tp,1456U,sg_dig_ctrl);
      
#line 3074 
      (*(tp->write32))(tp,1424U,serdes_cfg | 32768U);
    }
    else ;
    
#line 3076 
    goto return_label;
  }
  else ;
  
#line 3079 
  if (tp->pci_chip_rev_id >> 12 == 12U) {
    
#line 3080 
    tg3_bmcr_reset(tp);
    
#line 3081 
    val = (*(tp->read32))(tp,26628U);
    
#line 3082 
    _tw32_flush(tp,26628U,val | 2097152U,0U);
    
#line 3083 
    __const_udelay(171800UL);
    
#line 3084 
    goto return_label;
  }
  else 
    
#line 3085 
    if ((tp->phy_flags & 64U) != 0U) {
      u32 phytest;
      int tmp_2;
      
#line 3087 
      tmp_2 = tg3_readphy(tp,31,& phytest);
      
#line 3087 
      if (tmp_2 == 0) {
        u32 phy;
        int tmp_1;
        
#line 3090 
        tg3_writephy(tp,4,0U);
        
#line 3091 
        tg3_writephy(tp,0,4608U);
        
#line 3094 
        tg3_writephy(tp,31,phytest | 128U);
        
#line 3096 
        tmp_1 = tg3_readphy(tp,26,& phy);
        
#line 3096 
        if (tmp_1 == 0) {
          
#line 3097 
          phy |= 8U;
          
#line 3098 
          tg3_writephy(tp,26,phy);
        }
        else ;
        
#line 3102 
        tg3_writephy(tp,31,phytest);
      }
      else ;
      
#line 3104 
      goto return_label;
    }
    else 
      
#line 3105 
      if ((int)do_low_power != 0) {
        int tmp_4;
        bool tmp_3;
        
#line 3106 
        tmp_3 = tg3_phy_led_bug(tp);
        
#line 3106 
        if (tmp_3) 
#line 3106 
                   tmp_4 = 0; else 
#line 3106 
                                   tmp_4 = 1;
        
#line 3106 
        if (tmp_4) 
#line 3107 
                   tg3_writephy(tp,16,8U); else ;
        
#line 3110 
        val = 432U;
        
#line 3113 
        tg3_phy_auxctl_write(tp,2,val);
      }
      else ;
  
#line 3119 
  tmp_5 = tg3_phy_power_bug(tp);
  
#line 3119 
  if ((int)tmp_5 != 0) 
#line 3120 
                       goto return_label; else ;
  
#line 3122 
  if (tp->pci_chip_rev_id >> 8 == 358464U || tp->pci_chip_rev_id >> 8 == 357904U) {
    
#line 3124 
    val = (*(tp->read32))(tp,13836U);
    
#line 3125 
    val &= 4292935679U;
    
#line 3126 
    val |= 1114112U;
    
#line 3127 
    _tw32_flush(tp,13836U,val,0U);
  }
  else ;
  
#line 3130 
  tg3_writephy(tp,0,2048U);
  return_label: 
#line 3131 
                return;
}


#line 3134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_lock(struct tg3 *tp)
{
  int __retres;
  int tmp_0;
  
#line 3136 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 3136 
  if (tmp_0 != 0) {
    int i;
    
#line 3139 
    if (tp->nvram_lock_cnt == 0) {
      u32 tmp;
      
#line 3140 
      (*(tp->write32))(tp,28704U,2U);
      
#line 3141 
      i = 0;
      
#line 3141 
      goto ldv_56516;
      ldv_56515: 
#line 3142 
      ;
      
#line 3142 
      tmp = (*(tp->read32))(tp,28704U);
      
#line 3142 
      if ((tmp & 512U) != 0U) 
#line 3143 
                              goto ldv_56514; else ;
      
#line 3144 
      __const_udelay(85900UL);
      
#line 3141 
      i += 1;
      ldv_56516: 
#line 3142 
      ;
      
#line 3141 
      if (i <= 7999) 
#line 3143 
                     goto ldv_56515; else 
#line 3146 
                                          goto ldv_56514;
      ldv_56514: 
#line 3147 
      ;
      
#line 3146 
      if (i == 8000) {
        
#line 3147 
        (*(tp->write32))(tp,28704U,32U);
        
#line 3148 
        __retres = -19;
        
#line 3148 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 3151 
    tp->nvram_lock_cnt += 1;
  }
  else ;
  
#line 3153 
  __retres = 0;
  return_label: 
#line 3153 
                return __retres;
}


#line 3157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_nvram_unlock(struct tg3 *tp)
{
  int tmp;
  
#line 3159 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 3159 
  if (tmp != 0) {
    
#line 3160 
    if (tp->nvram_lock_cnt > 0) 
#line 3161 
                                tp->nvram_lock_cnt -= 1; else ;
    
#line 3162 
    if (tp->nvram_lock_cnt == 0) 
#line 3163 
                                 _tw32_flush(tp,28704U,32U,0U); else ;
  }
  else ;
  
#line 3165 
  return;
}


#line 3168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_enable_nvram_access(struct tg3 *tp)
{
  int tmp_0;
  
#line 3170 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 3170 
  if (tmp_0 != 0) {
    int tmp_1;
    
#line 3170 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PROTECTED_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 3170 
    if (tmp_1 == 0) {
      u32 tmp;
      
#line 3171 
      tmp = (*(tp->read32))(tp,28708U);
      
#line 3171 
      u32 nvaccess = tmp;
      
#line 3173 
      (*(tp->write32))(tp,28708U,nvaccess | 1U);
    }
    else ;
  }
  else ;
  
#line 3175 
  return;
}


#line 3178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_disable_nvram_access(struct tg3 *tp)
{
  int tmp_0;
  
#line 3180 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 3180 
  if (tmp_0 != 0) {
    int tmp_1;
    
#line 3180 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PROTECTED_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 3180 
    if (tmp_1 == 0) {
      u32 tmp;
      
#line 3181 
      tmp = (*(tp->read32))(tp,28708U);
      
#line 3181 
      u32 nvaccess = tmp;
      
#line 3183 
      (*(tp->write32))(tp,28708U,nvaccess & 4294967294U);
    }
    else ;
  }
  else ;
  
#line 3185 
  return;
}


#line 3187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_read_using_eeprom(struct tg3 *tp, u32 offset, u32 *val)
{
  int __retres;
  u32 tmp;
  int i;
  u32 tmp_0;
  
#line 3193 
  if (offset > 65535U || (offset & 3U) != 0U) {
    
#line 3194 
    __retres = -22;
    
#line 3194 
    goto return_label;
  }
  else ;
  
#line 3196 
  tmp_0 = (*(tp->read32))(tp,26680U);
  
#line 3196 
  tmp = tmp_0 & 1677656064U;
  
#line 3199 
  (*(tp->write32))(tp,26680U,((offset & 65535U) | tmp) | 2181038080U);
  
#line 3206 
  i = 0;
  
#line 3206 
  goto ldv_56537;
  ldv_56536: 
#line 3207 
  ;
  
#line 3207 
  tmp = (*(tp->read32))(tp,26680U);
  
#line 3209 
  if ((tmp & 1073741824U) != 0U) 
#line 3210 
                                 goto ldv_56535; else ;
  
#line 3211 
  msleep(1U);
  
#line 3206 
  i += 1;
  ldv_56537: 
#line 3207 
  ;
  
#line 3206 
  if (i <= 999) 
#line 3208 
                goto ldv_56536; else 
#line 3211 
                                     goto ldv_56535;
  ldv_56535: 
#line 3212 
  ;
  
#line 3213 
  if ((tmp & 1073741824U) == 0U) {
    
#line 3214 
    __retres = -16;
    
#line 3214 
    goto return_label;
  }
  else ;
  
#line 3216 
  tmp = (*(tp->read32))(tp,26684U);
  
#line 3222 
  if (0 != 0) 
#line 3222 
              *val = (((tmp << 24) | ((tmp << 8) & 16711680U)) | ((tmp >> 8) & 65280U)) | (tmp >> 24); else 
                                                                    
#line 3222 
                                                                    *val = __fswab32(tmp);
  
#line 3224 
  __retres = 0;
  return_label: 
#line 3224 
                return __retres;
}


#line 3229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_exec_cmd(struct tg3 *tp, u32 nvram_cmd)
{
  int __retres;
  int i;
  u32 tmp;
  
#line 3233 
  (*(tp->write32))(tp,28672U,nvram_cmd);
  
#line 3234 
  i = 0;
  
#line 3234 
  goto ldv_56545;
  ldv_56544: 
#line 3235 
  ;
  
#line 3235 
  usleep_range(10UL,40UL);
  
#line 3236 
  tmp = (*(tp->read32))(tp,28672U);
  
#line 3236 
  if ((tmp & 8U) != 0U) {
    
#line 3237 
    __const_udelay(42950UL);
    
#line 3238 
    goto ldv_56543;
  }
  else ;
  
#line 3234 
  i += 1;
  ldv_56545: 
#line 3235 
  ;
  
#line 3234 
  if (i <= 4999) 
#line 3236 
                 goto ldv_56544; else 
#line 3239 
                                      goto ldv_56543;
  ldv_56543: 
#line 3240 
  ;
  
#line 3242 
  if (i == 5000) {
    
#line 3243 
    __retres = -16;
    
#line 3243 
    goto return_label;
  }
  else ;
  
#line 3245 
  __retres = 0;
  return_label: 
#line 3245 
                return __retres;
}


#line 3248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_nvram_phys_addr(struct tg3 *tp, u32 addr)
{
  int tmp;
  
#line 3250 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 3250 
  if (tmp != 0) {
    int tmp_0;
    
#line 3250 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 3250 
    if (tmp_0 != 0) {
      int tmp_1;
      
#line 3251 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
      
#line 3251 
      if (tmp_1 != 0) {
        int tmp_2;
        
#line 3252 
        tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM_ADDR_TRANS,(unsigned long *)(& tp->tg3_flags));
        
#line 3252 
        if (tmp_2 == 0) {
          
#line 3253 
          if (tp->nvram_jedecnum == 31U) 
#line 3256 
                                         addr = (addr / tp->nvram_pagesize << 9) + addr % tp->nvram_pagesize; else ;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 3260 
  return addr;
}


#line 3263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_nvram_logical_addr(struct tg3 *tp, u32 addr)
{
  int tmp;
  
#line 3265 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 3265 
  if (tmp != 0) {
    int tmp_0;
    
#line 3265 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 3265 
    if (tmp_0 != 0) {
      int tmp_1;
      
#line 3266 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
      
#line 3266 
      if (tmp_1 != 0) {
        int tmp_2;
        
#line 3267 
        tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM_ADDR_TRANS,(unsigned long *)(& tp->tg3_flags));
        
#line 3267 
        if (tmp_2 == 0) {
          
#line 3268 
          if (tp->nvram_jedecnum == 31U) 
#line 3271 
                                         addr = (addr >> 9) * tp->nvram_pagesize + (addr & 511U); else ;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 3275 
  return addr;
}


#line 3284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_read(struct tg3 *tp, u32 offset, u32 *val)
{
  int __retres;
  int ret;
  int tmp_0;
  
#line 3288 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 3288 
  if (tmp_0 == 0) {
    int tmp;
    
#line 3289 
    tmp = tg3_nvram_read_using_eeprom(tp,offset,val);
    
#line 3289 
    __retres = tmp;
    
#line 3289 
    goto return_label;
  }
  else ;
  
#line 3291 
  offset = tg3_nvram_phys_addr(tp,offset);
  
#line 3293 
  if (offset > 16777215U) {
    
#line 3294 
    __retres = -22;
    
#line 3294 
    goto return_label;
  }
  else ;
  
#line 3296 
  ret = tg3_nvram_lock(tp);
  
#line 3297 
  if (ret != 0) {
    
#line 3298 
    __retres = ret;
    
#line 3298 
    goto return_label;
  }
  else ;
  
#line 3300 
  tg3_enable_nvram_access(tp);
  
#line 3302 
  (*(tp->write32))(tp,28684U,offset);
  
#line 3303 
  ret = tg3_nvram_exec_cmd(tp,408U);
  
#line 3306 
  if (ret == 0) 
#line 3307 
                *val = (*(tp->read32))(tp,28688U); else ;
  
#line 3309 
  tg3_disable_nvram_access(tp);
  
#line 3311 
  tg3_nvram_unlock(tp);
  
#line 3313 
  __retres = ret;
  return_label: 
#line 3313 
                return __retres;
}


#line 3317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_read_be32(struct tg3 *tp, u32 offset, __be32 *val)
{
  u32 v;
  
#line 3320 
  int res = tg3_nvram_read(tp,offset,& v);
  
#line 3321 
  if (res == 0) 
    
#line 3322 
    if (0 != 0) 
#line 3322 
                *val = (((v << 24) | ((v << 8) & 16711680U)) | ((v >> 8) & 65280U)) | (v >> 24); else 
                                                                    
#line 3322 
                                                                    *val = __fswab32(v);
  else ;
  
#line 3323 
  return res;
}


#line 3326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_write_block_using_eeprom(struct tg3 *tp, u32 offset, u32 len, u8 *buf)
{
  int i;
  int j;
  u32 val;
  
#line 3329 
  int rc = 0;
  
#line 3332 
  i = 0;
  
#line 3332 
  goto ldv_56584;
  ldv_56583: 
#line 3333 
  ;
  {
    u32 addr;
    __be32 data;
    unsigned int tmp_12;
    
#line 3336 
    addr = offset + (unsigned int)i;
    
#line 3338 
    memcpy((void *)(& data),(void const *)(buf + i),4UL);
    
#line 3346 
    if (0 != 0) {
      unsigned int tmp_2;
      unsigned int tmp_4;
      unsigned int tmp_6;
      unsigned int tmp_8;
      
#line 3346 
      if (0 != 0) 
#line 3346 
                  tmp_2 = ((((data << 24) | ((data << 8) & 16711680U)) | ((data >> 8) & 65280U)) | (data >> 24)) << 24;
      else {
        __u32 tmp_1;
        
#line 3346 
        tmp_1 = __fswab32(data);
        
#line 3346 
        tmp_2 = tmp_1 << 24;
      }
      
#line 3346 
      if (0 != 0) 
#line 3346 
                  tmp_4 = (((((data << 24) | ((data << 8) & 16711680U)) | ((data >> 8) & 65280U)) | (data >> 24)) << 8) & 16711680U;
      else {
        __u32 tmp_3;
        
#line 3346 
        tmp_3 = __fswab32(data);
        
#line 3346 
        tmp_4 = (tmp_3 << 8) & 16711680U;
      }
      
#line 3346 
      if (0 != 0) 
#line 3346 
                  tmp_6 = (((((data << 24) | ((data << 8) & 16711680U)) | ((data >> 8) & 65280U)) | (data >> 24)) >> 8) & 65280U;
      else {
        __u32 tmp_5;
        
#line 3346 
        tmp_5 = __fswab32(data);
        
#line 3346 
        tmp_6 = (tmp_5 >> 8) & 65280U;
      }
      
#line 3346 
      if (0 != 0) 
#line 3346 
                  tmp_8 = ((((data << 24) | ((data << 8) & 16711680U)) | ((data >> 8) & 65280U)) | (data >> 24)) >> 24;
      else {
        __u32 tmp_7;
        
#line 3346 
        tmp_7 = __fswab32(data);
        
#line 3346 
        tmp_8 = tmp_7 >> 24;
      }
      
#line 3346 
      tmp_12 = ((tmp_2 | tmp_4) | tmp_6) | tmp_8;
    }
    else {
      __u32 tmp_11;
      unsigned int tmp_10;
      
#line 3346 
      if (0 != 0) 
#line 3346 
                  tmp_10 = (((data << 24) | ((data << 8) & 16711680U)) | ((data >> 8) & 65280U)) | (data >> 24); else 
                                                                    
#line 3346 
                                                                    tmp_10 = __fswab32(data);
      
#line 3346 
      tmp_11 = __fswab32(tmp_10);
      
#line 3346 
      tmp_12 = tmp_11;
    }
    
#line 3346 
    ;
    
#line 3346 
    (*(tp->write32))(tp,26684U,tmp_12);
    
#line 3348 
    val = (*(tp->read32))(tp,26680U);
    
#line 3349 
    (*(tp->write32))(tp,26680U,val | 1073741824U);
    
#line 3351 
    val &= 1677656064U;
    
#line 3353 
    (*(tp->write32))(tp,26680U,((addr & 65535U) | val) | 33554432U);
    
#line 3359 
    j = 0;
    
#line 3359 
    goto ldv_56581;
    ldv_56580: 
#line 3360 
    ;
    
#line 3360 
    val = (*(tp->read32))(tp,26680U);
    
#line 3362 
    if ((val & 1073741824U) != 0U) 
#line 3363 
                                   goto ldv_56579; else ;
    
#line 3364 
    msleep(1U);
    
#line 3359 
    j += 1;
    ldv_56581: 
#line 3360 
    ;
    
#line 3359 
    if (j <= 999) 
#line 3361 
                  goto ldv_56580; else 
#line 3364 
                                       goto ldv_56579;
    ldv_56579: 
#line 3365 
    ;
    
#line 3366 
    if ((val & 1073741824U) == 0U) {
      
#line 3367 
      rc = -16;
      
#line 3368 
      goto ldv_56582;
    }
    else ;
  }
  
#line 3332 
  i += 4;
  ldv_56584: 
#line 3333 
  ;
  
#line 3332 
  if ((unsigned int)i < len) 
#line 3334 
                             goto ldv_56583; else 
#line 3337 
                                                  goto ldv_56582;
  ldv_56582: 
#line 3338 
  ;
  
#line 3372 
  return rc;
}


#line 3376  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_write_block_unbuffered(struct tg3 *tp, u32 offset, u32 len, u8 *buf)
{
  int __retres;
  u32 nvram_cmd;
  u8 *tmp;
  
#line 3379 
  int ret = 0;
  
#line 3380 
  u32 pagesize = tp->nvram_pagesize;
  
#line 3381 
  u32 pagemask = pagesize + 4294967295U;
  
#line 3385 
  tmp = (u8 *)kmalloc((unsigned long)pagesize,208U);
  
#line 3386 
  if (tmp == (u8 *)0U) {
    
#line 3387 
    __retres = -12;
    
#line 3387 
    goto return_label;
  }
  else ;
  
#line 3389 
  goto ldv_56609;
  ldv_56608: 
#line 3390 
  ;
  {
    int j;
    u32 phy_addr;
    u32 page_off;
    u32 size;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    
#line 3393 
    phy_addr = ~ pagemask & offset;
    
#line 3395 
    j = 0;
    
#line 3395 
    goto ldv_56602;
    ldv_56601: 
#line 3396 
    ;
    
#line 3396 
    ret = tg3_nvram_read_be32(tp,phy_addr + (unsigned int)j,(__be32 *)(tmp + j));
    
#line 3398 
    if (ret != 0) 
#line 3399 
                  goto ldv_56600; else ;
    
#line 3395 
    j += 4;
    ldv_56602: 
#line 3396 
    ;
    
#line 3395 
    if ((unsigned int)j < pagesize) 
#line 3397 
                                    goto ldv_56601; else 
#line 3400 
                                                         goto ldv_56600;
    ldv_56600: 
#line 3401 
    ;
    
#line 3401 
    if (ret != 0) 
#line 3402 
                  goto ldv_56603; else ;
    
#line 3404 
    page_off = offset & pagemask;
    
#line 3405 
    size = pagesize;
    
#line 3406 
    if (len < size) 
#line 3407 
                    size = len; else ;
    
#line 3409 
    len -= size;
    
#line 3411 
    memcpy((void *)(tmp + page_off),(void const *)buf,(unsigned long)size);
    
#line 3413 
    offset = (pagesize - page_off) + offset;
    
#line 3415 
    tg3_enable_nvram_access(tp);
    
#line 3421 
    nvram_cmd = 65560U;
    
#line 3423 
    tmp_1 = tg3_nvram_exec_cmd(tp,nvram_cmd);
    
#line 3423 
    if (tmp_1 != 0) 
#line 3424 
                    goto ldv_56603; else ;
    
#line 3427 
    (*(tp->write32))(tp,28684U,phy_addr);
    
#line 3429 
    nvram_cmd = 504U;
    
#line 3432 
    tmp_2 = tg3_nvram_exec_cmd(tp,nvram_cmd);
    
#line 3432 
    if (tmp_2 != 0) 
#line 3433 
                    goto ldv_56603; else ;
    
#line 3436 
    nvram_cmd = 65560U;
    
#line 3438 
    tmp_3 = tg3_nvram_exec_cmd(tp,nvram_cmd);
    
#line 3438 
    if (tmp_3 != 0) 
#line 3439 
                    goto ldv_56603; else ;
    
#line 3441 
    j = 0;
    
#line 3441 
    goto ldv_56607;
    ldv_56606: 
#line 3442 
    ;
    {
      __be32 data;
      unsigned int tmp_5;
      
#line 3444 
      data = *((__be32 *)(tmp + j));
      
#line 3446 
      if (0 != 0) 
#line 3446 
                  tmp_5 = (((data << 24) | ((data << 8) & 16711680U)) | ((data >> 8) & 65280U)) | (data >> 24); else 
                                                                    
#line 3446 
                                                                    tmp_5 = __fswab32(data);
      
#line 3446 
      ;
      
#line 3446 
      (*(tp->write32))(tp,28680U,tmp_5);
      
#line 3448 
      (*(tp->write32))(tp,28684U,phy_addr + (unsigned int)j);
      
#line 3450 
      nvram_cmd = 56U;
      
#line 3453 
      if (j == 0) 
#line 3454 
                  nvram_cmd |= 128U;
      else 
        
#line 3455 
        if (pagesize + 4294967292U == (unsigned int)j) 
#line 3456 
                                                       nvram_cmd |= 256U; else ;
      
#line 3458 
      ret = tg3_nvram_exec_cmd(tp,nvram_cmd);
      
#line 3459 
      if (ret != 0) 
#line 3460 
                    goto ldv_56605; else ;
    }
    
#line 3441 
    j += 4;
    ldv_56607: 
#line 3442 
    ;
    
#line 3441 
    if ((unsigned int)j < pagesize) 
#line 3443 
                                    goto ldv_56606; else 
#line 3446 
                                                         goto ldv_56605;
    ldv_56605: 
#line 3447 
    ;
    
#line 3462 
    if (ret != 0) 
#line 3463 
                  goto ldv_56603; else ;
  }
  ldv_56609: 
#line 3465 
  ;
  
#line 3389 
  if (len != 0U) 
#line 3391 
                 goto ldv_56608; else 
#line 3394 
                                      goto ldv_56603;
  ldv_56603: 
#line 3395 
  ;
  
#line 3466 
  nvram_cmd = 131096U;
  
#line 3467 
  tg3_nvram_exec_cmd(tp,nvram_cmd);
  
#line 3469 
  kfree((void const *)tmp);
  
#line 3471 
  __retres = ret;
  return_label: 
#line 3471 
                return __retres;
}


#line 3475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_write_block_buffered(struct tg3 *tp, u32 offset, u32 len, u8 *buf)
{
  int i;
  
#line 3478 
  int ret = 0;
  
#line 3480 
  i = 0;
  
#line 3480 
  goto ldv_56625;
  ldv_56624: 
#line 3481 
  ;
  {
    u32 page_off;
    u32 phy_addr;
    u32 nvram_cmd;
    __be32 data;
    unsigned int tmp_0;
    int tmp_4;
    
#line 3484 
    memcpy((void *)(& data),(void const *)(buf + i),4UL);
    
#line 3485 
    if (0 != 0) 
#line 3485 
                tmp_0 = (((data << 24) | ((data << 8) & 16711680U)) | ((data >> 8) & 65280U)) | (data >> 24); else 
                                                                    
#line 3485 
                                                                    tmp_0 = __fswab32(data);
    
#line 3485 
    ;
    
#line 3485 
    (*(tp->write32))(tp,28680U,tmp_0);
    
#line 3487 
    page_off = offset % tp->nvram_pagesize;
    
#line 3489 
    phy_addr = tg3_nvram_phys_addr(tp,offset);
    
#line 3491 
    nvram_cmd = 56U;
    
#line 3493 
    if (page_off == 0U || i == 0) 
#line 3494 
                                  nvram_cmd |= 128U; else ;
    
#line 3495 
    if (tp->nvram_pagesize + 4294967292U == page_off) 
#line 3496 
                                                      nvram_cmd |= 256U; else ;
    
#line 3498 
    if (len + 4294967292U == (unsigned int)i) 
#line 3499 
                                              nvram_cmd |= 256U; else ;
    
#line 3501 
    if ((nvram_cmd & 128U) != 0U) 
#line 3504 
                                  (*(tp->write32))(tp,28684U,phy_addr);
    else {
      int tmp_1;
      
#line 3501 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
      
#line 3501 
      if (tmp_1 == 0) 
#line 3504 
                      (*(tp->write32))(tp,28684U,phy_addr);
      else {
        int tmp_2;
        
#line 3502 
        tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
        
#line 3502 
        if (tmp_2 == 0) 
#line 3504 
                        (*(tp->write32))(tp,28684U,phy_addr); else ;
      }
    }
    
#line 3506 
    if (tp->pci_chip_rev_id >> 12 != 6U) {
      int tmp_3;
      
#line 3506 
      tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 3506 
      if (tmp_3 == 0) {
        
#line 3507 
        if (tp->nvram_jedecnum == 32U) {
          
#line 3508 
          if ((nvram_cmd & 128U) != 0U) {
            u32 cmd;
            
#line 3512 
            cmd = 65560U;
            
#line 3513 
            ret = tg3_nvram_exec_cmd(tp,cmd);
            
#line 3514 
            if (ret != 0) 
#line 3515 
                          goto ldv_56623; else ;
          }
          else ;
        }
        else ;
      }
      else ;
    }
    else ;
    
#line 3517 
    tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 3517 
    if (tmp_4 == 0) 
#line 3519 
                    nvram_cmd |= 384U; else ;
    
#line 3522 
    ret = tg3_nvram_exec_cmd(tp,nvram_cmd);
    
#line 3523 
    if (ret != 0) 
#line 3524 
                  goto ldv_56623; else ;
  }
  
#line 3480 
  i += 4;
  
#line 3480 
  offset += 4U;
  ldv_56625: 
#line 3481 
  ;
  
#line 3480 
  if ((unsigned int)i < len) 
#line 3482 
                             goto ldv_56624; else 
#line 3485 
                                                  goto ldv_56623;
  ldv_56623: 
#line 3486 
  ;
  
#line 3526 
  return ret;
}


#line 3530  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nvram_write_block(struct tg3 *tp, u32 offset, u32 len, u8 *buf)
{
  int __retres;
  int ret;
  int tmp;
  int tmp_4;
  int tmp_5;
  
#line 3534 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags));
  
#line 3534 
  if (tmp != 0) {
    
#line 3535 
    _tw32_flush(tp,26632U,tp->grc_local_ctrl & 4294934527U,0U);
    
#line 3537 
    __const_udelay(171800UL);
  }
  else ;
  
#line 3540 
  tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 3540 
  if (tmp_4 == 0) 
#line 3541 
                  ret = tg3_nvram_write_block_using_eeprom(tp,offset,len,buf);
  else {
    u32 grc_mode;
    int tmp_0;
    int tmp_2;
    
#line 3545 
    ret = tg3_nvram_lock(tp);
    
#line 3546 
    if (ret != 0) {
      
#line 3547 
      __retres = ret;
      
#line 3547 
      goto return_label;
    }
    else ;
    
#line 3549 
    tg3_enable_nvram_access(tp);
    
#line 3550 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 3550 
    if (tmp_0 != 0) {
      int tmp_1;
      
#line 3550 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PROTECTED_NVRAM,(unsigned long *)(& tp->tg3_flags));
      
#line 3550 
      if (tmp_1 == 0) 
#line 3551 
                      (*(tp->write32))(tp,28712U,1030U); else ;
    }
    else ;
    
#line 3553 
    grc_mode = (*(tp->read32))(tp,26624U);
    
#line 3554 
    (*(tp->write32))(tp,26624U,grc_mode | 2097152U);
    
#line 3556 
    tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 3556 
    if (tmp_2 != 0) 
#line 3556 
                    goto _LOR;
    else {
      int tmp_3;
      
#line 3556 
      tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
      
#line 3556 
      if (tmp_3 == 0) _LOR: 
#line 3557 
                            ret = tg3_nvram_write_block_buffered(tp,offset,len,buf); else 
                                                                    
#line 3560 
                                                                    ret = tg3_nvram_write_block_unbuffered(tp,offset,len,buf);
    }
    
#line 3564 
    grc_mode = (*(tp->read32))(tp,26624U);
    
#line 3565 
    (*(tp->write32))(tp,26624U,grc_mode & 4292870143U);
    
#line 3567 
    tg3_disable_nvram_access(tp);
    
#line 3568 
    tg3_nvram_unlock(tp);
  }
  
#line 3571 
  tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags));
  
#line 3571 
  if (tmp_5 != 0) {
    
#line 3572 
    _tw32_flush(tp,26632U,tp->grc_local_ctrl,0U);
    
#line 3573 
    __const_udelay(171800UL);
  }
  else ;
  
#line 3576 
  __retres = ret;
  return_label: 
#line 3576 
                return __retres;
}


#line 3585  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_pause_cpu(struct tg3 *tp, u32 cpu_base)
{
  int __retres;
  int i;
  u32 tmp;
  int tmp_0;
  int tmp_1;
  
#line 3588 
  int const iters = 10000;
  
#line 3590 
  i = 0;
  
#line 3590 
  goto ldv_56642;
  ldv_56641: 
#line 3591 
  ;
  
#line 3591 
  (*(tp->write32))(tp,cpu_base + 4U,4294967295U);
  
#line 3592 
  (*(tp->write32))(tp,cpu_base,1024U);
  
#line 3593 
  tmp = (*(tp->read32))(tp,cpu_base);
  
#line 3593 
  if ((tmp & 1024U) != 0U) 
#line 3594 
                           goto ldv_56640; else ;
  
#line 3595 
  tmp_0 = pci_channel_offline(tp->pdev);
  
#line 3595 
  if (tmp_0 != 0) {
    
#line 3596 
    __retres = -16;
    
#line 3596 
    goto return_label;
  }
  else ;
  
#line 3590 
  i += 1;
  ldv_56642: 
#line 3591 
  ;
  
#line 3590 
  if (i <= 9999) 
#line 3592 
                 goto ldv_56641; else 
#line 3595 
                                      goto ldv_56640;
  ldv_56640: 
#line 3596 
  ;
  
#line 3599 
  if (i == 10000) 
#line 3599 
                  tmp_1 = -16; else 
#line 3599 
                                    tmp_1 = 0;
  
#line 3599 
  __retres = tmp_1;
  return_label: 
#line 3599 
                return __retres;
}


#line 3603  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_rxcpu_pause(struct tg3 *tp)
{
  
#line 3605 
  int rc = tg3_pause_cpu(tp,20480U);
  
#line 3607 
  (*(tp->write32))(tp,20484U,4294967295U);
  
#line 3608 
  _tw32_flush(tp,20480U,1024U,0U);
  
#line 3609 
  __const_udelay(42950UL);
  
#line 3611 
  return rc;
}


#line 3615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_txcpu_pause(struct tg3 *tp)
{
  int tmp;
  
#line 3617 
  tmp = tg3_pause_cpu(tp,21504U);
  
#line 3617 
  return tmp;
}


#line 3621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_resume_cpu(struct tg3 *tp, u32 cpu_base)
{
  
#line 3623 
  (*(tp->write32))(tp,cpu_base + 4U,4294967295U);
  
#line 3624 
  _tw32_flush(tp,cpu_base,0U,0U);
  
#line 3625 
  return;
}


#line 3628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rxcpu_resume(struct tg3 *tp)
{
  
#line 3630 
  tg3_resume_cpu(tp,20480U);
  
#line 3631 
  return;
}


#line 3634  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_halt_cpu(struct tg3 *tp, u32 cpu_base)
{
  int __retres;
  int rc;
  int tmp_3;
  
#line 3638 
  if ((long)(cpu_base == 21504U) != 0L) {
    int tmp;
    
#line 3638 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 3638 
    if ((long)(tmp != 0) != 0L) {
      
#line 3640 
      ldv_inline_asm();
      
#line 3638 
      ;
    }
    else ;
  }
  else ;
  
#line 3640 
  if (tp->pci_chip_rev_id >> 12 == 12U) {
    u32 tmp_0;
    
#line 3641 
    tmp_0 = (*(tp->read32))(tp,26768U);
    
#line 3641 
    u32 val = tmp_0;
    
#line 3643 
    (*(tp->write32))(tp,26768U,val | 4194304U);
    
#line 3644 
    __retres = 0;
    
#line 3644 
    goto return_label;
  }
  else ;
  
#line 3646 
  if (cpu_base == 20480U) 
#line 3647 
                          rc = tg3_rxcpu_pause(tp);
  else {
    int tmp_1;
    
#line 3653 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
    
#line 3653 
    if (tmp_1 != 0) {
      
#line 3654 
      __retres = 0;
      
#line 3654 
      goto return_label;
    }
    else ;
    
#line 3656 
    rc = tg3_txcpu_pause(tp);
  }
  
#line 3659 
  if (rc != 0) {
    char *tmp_2;
    
#line 3661 
    if (cpu_base == 20480U) 
#line 3661 
                            tmp_2 = (char *)"RX"; else 
#line 3661 
                                                       tmp_2 = (char *)"TX";
    
#line 3660 
    ;
    
#line 3660 
    netdev_err((struct net_device const *)tp->dev,"%s timed out, %s CPU\n","tg3_halt_cpu",tmp_2);
    
#line 3662 
    __retres = -19;
    
#line 3662 
    goto return_label;
  }
  else ;
  
#line 3666 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 3666 
  if (tmp_3 != 0) 
#line 3667 
                  (*(tp->write32))(tp,28704U,16U); else ;
  
#line 3668 
  __retres = 0;
  return_label: 
#line 3668 
                return __retres;
}


#line 3671  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_fw_data_len(struct tg3 *tp, struct tg3_firmware_hdr const *fw_hdr)
{
  int __retres;
  int fw_len;
  
#line 3690 
  if (tp->fw_len == 4294967295U) {
    unsigned int tmp_0;
    
#line 3691 
    if (0 != 0) 
#line 3691 
                tmp_0 = (((fw_hdr->len << 24) | ((fw_hdr->len << 8) & 16711680U)) | ((fw_hdr->len >> 8) & 65280U)) | (fw_hdr->len >> 24); else 
                                                                    
#line 3691 
                                                                    tmp_0 = __fswab32(fw_hdr->len);
    
#line 3691 
    fw_len = (int)tmp_0;
  }
  else 
#line 3693 
       fw_len = (int)(tp->fw)->size;
  
#line 3695 
  __retres = (int)(((unsigned long)fw_len + 18446744073709551604UL) / 4UL);
  
#line 3695 
  return __retres;
}


#line 3699  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_load_firmware_cpu(struct tg3 *tp, u32 cpu_base, u32 cpu_scratch_base, int cpu_scratch_size, struct tg3_firmware_hdr const *fw_hdr)
{
  int __retres;
  int err;
  int i;
  void (*write_op)(struct tg3 *, u32 , u32 );
  int tmp_0;
  
#line 3705 
  int total_len = (int)(tp->fw)->size;
  
#line 3707 
  if (cpu_base == 21504U) {
    int tmp;
    
#line 3707 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 3707 
    if (tmp != 0) {
      
#line 3708 
      netdev_err((struct net_device const *)tp->dev,"%s: Trying to load TX cpu firmware which is 5705\n","tg3_load_firmware_cpu");
      
#line 3711 
      __retres = -22;
      
#line 3711 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 3714 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 3714 
  if (tmp_0 != 0) 
    
#line 3714 
    if (tp->pci_chip_rev_id >> 12 != 358246U) 
#line 3715 
                                              write_op = & tg3_write_mem; else 
                                                                    
#line 3717 
                                                                    write_op = & tg3_write_indirect_reg32;
  else 
#line 3717 
       write_op = & tg3_write_indirect_reg32;
  
#line 3719 
  if (tp->pci_chip_rev_id >> 12 != 358246U) {
    u32 tmp_2;
    
#line 3723 
    int lock_err = tg3_nvram_lock(tp);
    
#line 3724 
    err = tg3_halt_cpu(tp,cpu_base);
    
#line 3725 
    if (lock_err == 0) 
#line 3726 
                       tg3_nvram_unlock(tp); else ;
    
#line 3727 
    if (err != 0) 
#line 3728 
                  goto out; else ;
    
#line 3730 
    i = 0;
    
#line 3730 
    goto ldv_56687;
    ldv_56686: 
#line 3731 
    ;
    
#line 3731 
    (*write_op)(tp,cpu_scratch_base + (unsigned int)i,0U);
    
#line 3730 
    i = (int)((unsigned int)i + 4U);
    ldv_56687: 
#line 3731 
    ;
    
#line 3730 
    if (i < cpu_scratch_size) 
#line 3732 
                              goto ldv_56686; else 
#line 3735 
                                                   goto ldv_56688;
    ldv_56688: 
#line 3736 
    ;
    
#line 3732 
    (*(tp->write32))(tp,cpu_base + 4U,4294967295U);
    
#line 3733 
    tmp_2 = (*(tp->read32))(tp,cpu_base);
    
#line 3733 
    ;
    
#line 3733 
    ;
    
#line 3733 
    (*(tp->write32))(tp,cpu_base,tmp_2 | 1024U);
  }
  else {
    
#line 3739 
    total_len = (int)((unsigned int)total_len + 4294967284U);
    
#line 3740 
    fw_hdr += 1;
  }
  ldv_56693: 
#line 3742 
  ;
  {
    unsigned int tmp_4;
    unsigned int tmp_6;
    int tmp_7;
    unsigned int tmp_9;
    unsigned int tmp_11;
    
#line 3744 
    u32 *fw_data = (u32 *)(fw_hdr + 1U);
    
#line 3745 
    i = 0;
    
#line 3745 
    goto ldv_56691;
    ldv_56690: 
#line 3746 
    ;
    
#line 3747 
    if (0 != 0) 
#line 3747 
                tmp_4 = (((*(fw_data + i) << 24) | ((*(fw_data + i) << 8) & 16711680U)) | ((*(fw_data + i) >> 8) & 65280U)) | (*(fw_data + i) >> 24); else 
                                                                    
#line 3749 
                                                                    tmp_4 = __fswab32(*(fw_data + i));
    
#line 3746 
    if (0 != 0) 
#line 3746 
                tmp_6 = ((((fw_hdr->base_addr << 24) | ((fw_hdr->base_addr << 8) & 16711680U)) | ((fw_hdr->base_addr >> 8) & 65280U)) | (fw_hdr->base_addr >> 24)) & 65535U;
    else {
      __u32 tmp_5;
      
#line 3747 
      tmp_5 = __fswab32(fw_hdr->base_addr);
      
#line 3746 
      tmp_6 = tmp_5 & 65535U;
    }
    
#line 3746 
    ;
    
#line 3746 
    ;
    
#line 3746 
    (*write_op)(tp,(tmp_6 + cpu_scratch_base) + (unsigned int)((unsigned long)i) * 4U,tmp_4);
    
#line 3745 
    i += 1;
    ldv_56691: 
#line 3746 
    ;
    
#line 3745 
    tmp_7 = tg3_fw_data_len(tp,fw_hdr);
    
#line 3745 
    ;
    
#line 3745 
    if (tmp_7 > i) 
#line 3747 
                   goto ldv_56690; else 
#line 3750 
                                        goto ldv_56692;
    ldv_56692: 
#line 3751 
    ;
    
#line 3751 
    if (0 != 0) 
#line 3751 
                tmp_9 = (((fw_hdr->len << 24) | ((fw_hdr->len << 8) & 16711680U)) | ((fw_hdr->len >> 8) & 65280U)) | (fw_hdr->len >> 24); else 
                                                                    
#line 3751 
                                                                    tmp_9 = __fswab32(fw_hdr->len);
    
#line 3751 
    total_len = (int)((unsigned int)total_len - tmp_9);
    
#line 3754 
    if (0 != 0) 
#line 3754 
                tmp_11 = (((fw_hdr->len << 24) | ((fw_hdr->len << 8) & 16711680U)) | ((fw_hdr->len >> 8) & 65280U)) | (fw_hdr->len >> 24); else 
                                                                    
#line 3755 
                                                                    tmp_11 = __fswab32(fw_hdr->len);
    
#line 3754 
    fw_hdr += tmp_11;
  }
  
#line 3756 
  if (total_len > 0) 
#line 3758 
                     goto ldv_56693; else 
#line 3761 
                                          goto ldv_56694;
  ldv_56694: 
#line 3762 
  ;
  
#line 3758 
  err = 0;
  out: 
#line 3760 
  ;
  
#line 3761 
  __retres = err;
  return_label: 
#line 3761 
                return __retres;
}


#line 3765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_pause_cpu_and_set_pc(struct tg3 *tp, u32 cpu_base, u32 pc)
{
  int i;
  u32 tmp;
  int tmp_0;
  
#line 3768 
  int const iters = 5;
  
#line 3770 
  (*(tp->write32))(tp,cpu_base + 4U,4294967295U);
  
#line 3771 
  _tw32_flush(tp,cpu_base + 28U,pc,0U);
  
#line 3773 
  i = 0;
  
#line 3773 
  goto ldv_56704;
  ldv_56703: 
#line 3774 
  ;
  
#line 3774 
  tmp = (*(tp->read32))(tp,cpu_base + 28U);
  
#line 3774 
  ;
  
#line 3774 
  if (tmp == pc) 
#line 3775 
                 goto ldv_56702; else ;
  
#line 3776 
  (*(tp->write32))(tp,cpu_base + 4U,4294967295U);
  
#line 3777 
  (*(tp->write32))(tp,cpu_base,1024U);
  
#line 3778 
  _tw32_flush(tp,cpu_base + 28U,pc,0U);
  
#line 3779 
  __const_udelay(4295000UL);
  
#line 3773 
  i += 1;
  ldv_56704: 
#line 3774 
  ;
  
#line 3773 
  if (i <= 4) 
#line 3775 
              goto ldv_56703; else 
#line 3778 
                                   goto ldv_56702;
  ldv_56702: 
#line 3779 
  ;
  
#line 3782 
  if (i == 5) 
#line 3782 
              tmp_0 = -16; else 
#line 3782 
                                tmp_0 = 0;
  
#line 3782 
  return tmp_0;
}


#line 3786  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_load_5701_a0_firmware_fix(struct tg3 *tp)
{
  int __retres;
  struct tg3_firmware_hdr const *fw_hdr;
  int err;
  unsigned int tmp_0;
  
#line 3791 
  fw_hdr = (struct tg3_firmware_hdr const *)(tp->fw)->data;
  
#line 3799 
  err = tg3_load_firmware_cpu(tp,20480U,196608U,16384,fw_hdr);
  
#line 3802 
  if (err != 0) {
    
#line 3803 
    __retres = err;
    
#line 3803 
    goto return_label;
  }
  else ;
  
#line 3805 
  err = tg3_load_firmware_cpu(tp,21504U,212992U,16384,fw_hdr);
  
#line 3808 
  if (err != 0) {
    
#line 3809 
    __retres = err;
    
#line 3809 
    goto return_label;
  }
  else ;
  
#line 3812 
  if (0 != 0) 
#line 3812 
              tmp_0 = (((fw_hdr->base_addr << 24) | ((fw_hdr->base_addr << 8) & 16711680U)) | ((fw_hdr->base_addr >> 8) & 65280U)) | (fw_hdr->base_addr >> 24); else 
                                                                    
#line 3813 
                                                                    tmp_0 = __fswab32(fw_hdr->base_addr);
  
#line 3812 
  ;
  
#line 3812 
  err = tg3_pause_cpu_and_set_pc(tp,20480U,tmp_0);
  
#line 3814 
  if (err != 0) {
    unsigned int tmp_2;
    u32 tmp_3;
    
#line 3817 
    if (0 != 0) 
#line 3817 
                tmp_2 = (((fw_hdr->base_addr << 24) | ((fw_hdr->base_addr << 8) & 16711680U)) | ((fw_hdr->base_addr >> 8) & 65280U)) | (fw_hdr->base_addr >> 24); else 
                                                                    
#line 3818 
                                                                    tmp_2 = __fswab32(fw_hdr->base_addr);
    
#line 3816 
    tmp_3 = (*(tp->read32))(tp,20508U);
    
#line 3815 
    ;
    
#line 3815 
    netdev_err((struct net_device const *)tp->dev,"%s fails to set RX CPU PC, is %08x ","tg3_load_5701_a0_firmware_fix",tmp_3,tmp_2);
    
#line 3819 
    __retres = -19;
    
#line 3819 
    goto return_label;
  }
  else ;
  
#line 3822 
  tg3_rxcpu_resume(tp);
  
#line 3824 
  __retres = 0;
  return_label: 
#line 3824 
                return __retres;
}


#line 3827  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_validate_rxcpu_state(struct tg3 *tp)
{
  int __retres;
  int i;
  u32 val;
  u32 tmp;
  
#line 3829 
  int const iters = 1000;
  
#line 3836 
  i = 0;
  
#line 3836 
  goto ldv_56719;
  ldv_56718: 
#line 3837 
  ;
  
#line 3837 
  tmp = (*(tp->read32))(tp,20532U);
  
#line 3837 
  if (tmp == 81U) 
#line 3838 
                  goto ldv_56717; else ;
  
#line 3840 
  __const_udelay(42950UL);
  
#line 3836 
  i += 1;
  ldv_56719: 
#line 3837 
  ;
  
#line 3836 
  if (i <= 999) 
#line 3838 
                goto ldv_56718; else 
#line 3841 
                                     goto ldv_56717;
  ldv_56717: 
#line 3842 
  ;
  
#line 3843 
  if (i == 1000) {
    
#line 3844 
    netdev_err((struct net_device const *)tp->dev,"Boot code not ready for service patches\n");
    
#line 3845 
    __retres = -16;
    
#line 3845 
    goto return_label;
  }
  else ;
  
#line 3848 
  val = tg3_read_indirect_reg32(tp,261324U);
  
#line 3849 
  if ((val & 255U) != 0U) {
    
#line 3850 
    netdev_warn((struct net_device const *)tp->dev,"Other patches exist. Not downloading EEE patch\n");
    
#line 3852 
    __retres = -17;
    
#line 3852 
    goto return_label;
  }
  else ;
  
#line 3855 
  __retres = 0;
  return_label: 
#line 3855 
                return __retres;
}


#line 3859  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_load_57766_firmware(struct tg3 *tp)
{
  struct tg3_firmware_hdr *fw_hdr;
  int tmp;
  int tmp_0;
  int tmp_2;
  int tmp_3;
  
#line 3863 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 3863 
  if (tmp == 0) 
#line 3864 
                goto return_label; else ;
  
#line 3866 
  tmp_0 = tg3_validate_rxcpu_state(tp);
  
#line 3866 
  if (tmp_0 != 0) 
#line 3867 
                  goto return_label; else ;
  
#line 3869 
  if (tp->fw == (struct firmware const *)0) 
#line 3870 
                                            goto return_label; else ;
  
#line 3886 
  fw_hdr = (struct tg3_firmware_hdr *)(tp->fw)->data;
  
#line 3887 
  if (0 != 0) 
#line 3887 
              tmp_2 = ((((fw_hdr->base_addr << 24) | ((fw_hdr->base_addr << 8) & 16711680U)) | ((fw_hdr->base_addr >> 8) & 65280U)) | (fw_hdr->base_addr >> 24)) != 196608U;
  else {
    __u32 tmp_1;
    
#line 3887 
    tmp_1 = __fswab32(fw_hdr->base_addr);
    
#line 3887 
    tmp_2 = tmp_1 != 196608U;
  }
  
#line 3887 
  if (tmp_2) 
#line 3888 
             goto return_label; else ;
  
#line 3890 
  tmp_3 = tg3_rxcpu_pause(tp);
  
#line 3890 
  if (tmp_3 != 0) 
#line 3891 
                  goto return_label; else ;
  
#line 3894 
  tg3_load_firmware_cpu(tp,0U,196608U,0,(struct tg3_firmware_hdr const *)fw_hdr);
  
#line 3896 
  tg3_rxcpu_resume(tp);
  return_label: 
#line 3897 
                return;
}


#line 3900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_load_tso_firmware(struct tg3 *tp)
{
  int __retres;
  struct tg3_firmware_hdr const *fw_hdr;
  unsigned long cpu_base;
  unsigned long cpu_scratch_base;
  unsigned long cpu_scratch_size;
  int err;
  int tmp;
  unsigned int tmp_1;
  
#line 3906 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FW_TSO,(unsigned long *)(& tp->tg3_flags));
  
#line 3906 
  if (tmp == 0) {
    
#line 3907 
    __retres = 0;
    
#line 3907 
    goto return_label;
  }
  else ;
  
#line 3909 
  fw_hdr = (struct tg3_firmware_hdr const *)(tp->fw)->data;
  
#line 3917 
  cpu_scratch_size = (unsigned long)tp->fw_len;
  
#line 3919 
  if (tp->pci_chip_rev_id >> 12 == 3U) {
    
#line 3920 
    cpu_base = 20480UL;
    
#line 3921 
    cpu_scratch_base = 65536UL;
  }
  else {
    
#line 3923 
    cpu_base = 21504UL;
    
#line 3924 
    cpu_scratch_base = 212992UL;
    
#line 3925 
    cpu_scratch_size = 16384UL;
  }
  
#line 3928 
  err = tg3_load_firmware_cpu(tp,(unsigned int)cpu_base,(unsigned int)cpu_scratch_base,(int)cpu_scratch_size,fw_hdr);
  
#line 3931 
  if (err != 0) {
    
#line 3932 
    __retres = err;
    
#line 3932 
    goto return_label;
  }
  else ;
  
#line 3935 
  if (0 != 0) 
#line 3935 
              tmp_1 = (((fw_hdr->base_addr << 24) | ((fw_hdr->base_addr << 8) & 16711680U)) | ((fw_hdr->base_addr >> 8) & 65280U)) | (fw_hdr->base_addr >> 24); else 
                                                                    
#line 3936 
                                                                    tmp_1 = __fswab32(fw_hdr->base_addr);
  
#line 3935 
  ;
  
#line 3935 
  ;
  
#line 3935 
  err = tg3_pause_cpu_and_set_pc(tp,(unsigned int)cpu_base,tmp_1);
  
#line 3937 
  if (err != 0) {
    unsigned int tmp_3;
    u32 tmp_4;
    
#line 3940 
    if (0 != 0) 
#line 3940 
                tmp_3 = (((fw_hdr->base_addr << 24) | ((fw_hdr->base_addr << 8) & 16711680U)) | ((fw_hdr->base_addr >> 8) & 65280U)) | (fw_hdr->base_addr >> 24); else 
                                                                    
#line 3941 
                                                                    tmp_3 = __fswab32(fw_hdr->base_addr);
    
#line 3940 
    tmp_4 = (*(tp->read32))(tp,(unsigned int)cpu_base + 28U);
    
#line 3938 
    ;
    
#line 3938 
    netdev_err((struct net_device const *)tp->dev,"%s fails to set CPU PC, is %08x should be %08x\n","tg3_load_tso_firmware",tmp_4,tmp_3);
    
#line 3942 
    __retres = -19;
    
#line 3942 
    goto return_label;
  }
  else ;
  
#line 3945 
  tg3_resume_cpu(tp,(unsigned int)cpu_base);
  
#line 3946 
  __retres = 0;
  return_label: 
#line 3946 
                return __retres;
}


#line 3950  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void __tg3_set_one_mac_addr(struct tg3 *tp, u8 *mac_addr, int index)
{
  u32 addr_high;
  u32 addr_low;
  
#line 3954 
  addr_high = (unsigned int)(((int)*mac_addr << 8) | (int)*(mac_addr + 1U));
  
#line 3955 
  addr_low = (unsigned int)(((((int)*(mac_addr + 2U) << 24) | ((int)*(mac_addr + 3U) << 16)) | ((int)*(mac_addr + 4U) << 8)) | (int)*(mac_addr + 5U));
  
#line 3958 
  if (index <= 3) {
    
#line 3959 
    (*(tp->write32))(tp,(unsigned int)((index + 130) * 8),addr_high);
    
#line 3960 
    (*(tp->write32))(tp,(unsigned int)(index * 8 + 1044),addr_low);
  }
  else {
    
#line 3962 
    index += -4;
    
#line 3963 
    (*(tp->write32))(tp,(unsigned int)((index + 166) * 8),addr_high);
    
#line 3964 
    (*(tp->write32))(tp,(unsigned int)(index * 8 + 1332),addr_low);
  }
  
#line 3966 
  return;
}


#line 3969  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void __tg3_set_mac_addr(struct tg3 *tp, bool skip_mac_1)
{
  u32 addr_high;
  int i;
  
#line 3974 
  i = 0;
  
#line 3974 
  goto ldv_56748;
  ldv_56747: 
#line 3975 
  ;
  
#line 3975 
  if (i == 1 && (int)skip_mac_1 != 0) 
#line 3976 
                                      goto ldv_56746; else ;
  
#line 3977 
  __tg3_set_one_mac_addr(tp,(tp->dev)->dev_addr,i);
  ldv_56746: 
#line 3978 
  ;
  
#line 3974 
  i += 1;
  ldv_56748: 
#line 3975 
  ;
  
#line 3974 
  if (i <= 3) 
#line 3976 
              goto ldv_56747; else 
#line 3979 
                                   goto ldv_56749;
  ldv_56749: 
#line 3980 
  ;
  
#line 3980 
  if ((tp->pci_chip_rev_id >> 12) + 4294967295U <= 1U) {
    
#line 3982 
    i = 4;
    
#line 3982 
    goto ldv_56751;
    ldv_56750: 
#line 3983 
    ;
    
#line 3983 
    __tg3_set_one_mac_addr(tp,(tp->dev)->dev_addr,i);
    
#line 3982 
    i += 1;
    ldv_56751: 
#line 3983 
    ;
    
#line 3982 
    if (i <= 15) 
#line 3984 
                 goto ldv_56750; else 
#line 3987 
                                      goto ldv_56752;
    ldv_56752: 
#line 3988 
    ;
  }
  else ;
  
#line 3986 
  addr_high = (unsigned int)((((((int)*((tp->dev)->dev_addr) + (int)*((tp->dev)->dev_addr + 1U)) + (int)*((tp->dev)->dev_addr + 2U)) + (int)*((tp->dev)->dev_addr + 3U)) + (int)*((tp->dev)->dev_addr + 4U)) + (int)*((tp->dev)->dev_addr + 5U)) & 1023U;
  
#line 3993 
  (*(tp->write32))(tp,1080U,addr_high);
  
#line 3994 
  return;
}


#line 3996  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_enable_register_access(struct tg3 *tp)
{
  
#line 4002 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,104,tp->misc_host_ctrl);
  
#line 4004 
  return;
}


#line 4006  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_power_up(struct tg3 *tp)
{
  int err;
  
#line 4010 
  tg3_enable_register_access(tp);
  
#line 4012 
  err = pci_set_power_state(tp->pdev,0);
  
#line 4013 
  if (err == 0) 
#line 4015 
                tg3_pwrsrc_switch_to_vmain(tp); else 
#line 4017 
                                                     netdev_err((struct net_device const *)tp->dev,"Transition to D0 failed\n");
  
#line 4020 
  return err;
}


#line 4023 
static int tg3_setup_phy(struct tg3 *tp, bool force_reset);


#line 4025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_power_down_prepare(struct tg3 *tp)
{
  int __retres;
  u32 misc_host_ctrl;
  bool device_should_wake;
  bool do_low_power;
  int tmp;
  int tmp_2;
  bool tmp_0;
  int tmp_5;
  int tmp_7;
  int tmp_23;
  int tmp_27;
  
#line 4030 
  tg3_enable_register_access(tp);
  
#line 4033 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CLKREQ_BUG,(unsigned long *)(& tp->tg3_flags));
  
#line 4033 
  if (tmp != 0) 
#line 4034 
                pcie_capability_set_word(tp->pdev,16,(unsigned short)256); else ;
  
#line 4037 
  misc_host_ctrl = (*(tp->read32))(tp,104U);
  
#line 4038 
  (*(tp->write32))(tp,104U,misc_host_ctrl | 2U);
  
#line 4041 
  tmp_0 = device_may_wakeup(& (tp->pdev)->dev);
  
#line 4041 
  if ((int)tmp_0 != 0) {
    int tmp_1;
    
#line 4041 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 4041 
    if (tmp_1 != 0) 
#line 4041 
                    tmp_2 = 1; else 
#line 4041 
                                    tmp_2 = 0;
  }
  else 
#line 4041 
       tmp_2 = 0;
  
#line 4041 
  device_should_wake = (_Bool)(tmp_2 != 0);
  
#line 4044 
  tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 4044 
  if (tmp_5 != 0) {
    
#line 4045 
    do_low_power = (_Bool)0;
    
#line 4046 
    if ((tp->phy_flags & 2U) != 0U && (tp->phy_flags & 1U) == 0U) {
      struct phy_device *phydev;
      u32 phyid;
      u32 advertising;
      int tmp_4;
      
#line 4051 
      phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
      
#line 4053 
      tp->phy_flags |= 1U;
      
#line 4055 
      tp->link_config.speed = (unsigned short)phydev->speed;
      
#line 4056 
      tp->link_config.duplex = (unsigned char)phydev->duplex;
      
#line 4057 
      tp->link_config.autoneg = (unsigned char)phydev->autoneg;
      
#line 4058 
      tp->link_config.advertising = phydev->advertising;
      
#line 4060 
      advertising = 8385U;
      
#line 4065 
      tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
      
#line 4065 
      if (tmp_4 != 0) 
#line 4065 
                      goto _LOR;
      else 
        
#line 4065 
        if ((int)device_should_wake != 0) {
          int tmp_3;
          _LOR: 
#line 4066 
          tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_SPEED_100MB,(unsigned long *)(& tp->tg3_flags));
          
#line 4066 
          if (tmp_3 != 0) 
#line 4067 
                          advertising |= 14U; else 
#line 4072 
                                                   advertising |= 2U;
        }
        else ;
      
#line 4075 
      phydev->advertising = advertising;
      
#line 4077 
      phy_start_aneg(phydev);
      
#line 4079 
      phyid = (phydev->drv)->phy_id & (phydev->drv)->phy_id_mask;
      
#line 4080 
      if (phyid != 21216368U) {
        
#line 4081 
        phyid &= 4294966272U;
        
#line 4082 
        if ((phyid == 2121728U || phyid == 21216256U) || phyid == 56777728U) 
          
#line 4085 
          do_low_power = (_Bool)1; else ;
      }
      else ;
    }
    else ;
  }
  else {
    
#line 4089 
    do_low_power = (_Bool)1;
    
#line 4091 
    if ((tp->phy_flags & 1U) == 0U) 
#line 4092 
                                    tp->phy_flags |= 1U; else ;
    
#line 4094 
    if ((tp->phy_flags & 48U) == 0U) 
#line 4095 
                                     tg3_setup_phy(tp,(_Bool)0); else ;
  }
  
#line 4098 
  if (tp->pci_chip_rev_id >> 12 == 12U) {
    u32 val;
    
#line 4101 
    val = (*(tp->read32))(tp,26768U);
    
#line 4102 
    (*(tp->write32))(tp,26768U,val | 536870912U);
  }
  else {
    int tmp_6;
    
#line 4103 
    tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
    
#line 4103 
    if (tmp_6 == 0) {
      int i;
      u32 val_0;
      
#line 4107 
      i = 0;
      
#line 4107 
      goto ldv_56777;
      ldv_56776: 
#line 4108 
      ;
      
#line 4108 
      tg3_read_mem(tp,3072U,& val_0);
      
#line 4109 
      if (val_0 == 3030026667U) 
#line 4110 
                                goto ldv_56775; else ;
      
#line 4111 
      msleep(1U);
      
#line 4107 
      i += 1;
      ldv_56777: 
#line 4108 
      ;
      
#line 4107 
      if (i <= 199) 
#line 4109 
                    goto ldv_56776; else 
#line 4112 
                                         goto ldv_56775;
      ldv_56775: 
#line 4113 
      ;
    }
    else ;
  }
  
#line 4114 
  tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 4114 
  if (tmp_7 != 0) 
#line 4115 
                  tg3_write_mem(tp,3376U,1196163079U); else ;
  
#line 4120 
  if ((int)device_should_wake != 0) {
    u32 mac_mode;
    int tmp_11;
    int tmp_12;
    int tmp_16;
    
#line 4123 
    if ((tp->phy_flags & 16U) == 0U) {
      
#line 4124 
      if ((int)do_low_power != 0 && (tp->phy_flags & 64U) == 0U) {
        
#line 4126 
        tg3_phy_auxctl_write(tp,2,88U);
        
#line 4131 
        __const_udelay(171800UL);
      }
      else ;
      
#line 4134 
      if ((tp->phy_flags & 32U) != 0U) 
#line 4135 
                                       mac_mode = 8U;
      else 
        
#line 4136 
        if ((tp->phy_flags & 1048576U) != 0U) 
          
#line 4138 
          if ((unsigned int)tp->link_config.active_speed == 1000U) 
#line 4139 
                                                                   mac_mode = 8U; else 
                                                                    
#line 4141 
                                                                    mac_mode = 4U;
        else 
#line 4143 
             mac_mode = 4U;
      
#line 4145 
      mac_mode = (tp->mac_mode & 1024U) | mac_mode;
      
#line 4146 
      if (tp->pci_chip_rev_id >> 12 == 7U) {
        int tmp_9;
        int tmp_8;
        int tmp_10;
        
#line 4148 
        tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_SPEED_100MB,(unsigned long *)(& tp->tg3_flags));
        
#line 4148 
        if (tmp_8 != 0) 
#line 4148 
                        tmp_9 = 100; else 
#line 4148 
                                          tmp_9 = 10;
        
#line 4147 
        u32 speed = (unsigned int)tmp_9;
        
#line 4149 
        tmp_10 = tg3_5700_link_polarity(tp,speed);
        
#line 4149 
        if (tmp_10 != 0) 
#line 4150 
                         mac_mode |= 1024U; else 
#line 4152 
                                                 mac_mode &= 4294966271U;
      }
      else ;
    }
    else 
#line 4155 
         mac_mode = 12U;
    
#line 4158 
    tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 4158 
    if (tmp_11 == 0) 
#line 4159 
                     (*(tp->write32))(tp,1036U,tp->led_ctrl); else ;
    
#line 4161 
    mac_mode |= 262144U;
    
#line 4162 
    tmp_12 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 4162 
    if (tmp_12 != 0) {
      int tmp_13;
      
#line 4162 
      tmp_13 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
      
#line 4162 
      if (tmp_13 == 0) {
        int tmp_14;
        
#line 4162 
        tmp_14 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
        
#line 4162 
        if (tmp_14 != 0) 
#line 4164 
                         mac_mode |= 16777216U;
        else {
          int tmp_15;
          
#line 4163 
          tmp_15 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
          
#line 4163 
          if (tmp_15 != 0) 
#line 4164 
                           mac_mode |= 16777216U; else ;
        }
      }
      else ;
    }
    else ;
    
#line 4166 
    tmp_16 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
    
#line 4166 
    if (tmp_16 != 0) 
#line 4167 
                     mac_mode |= 404750336U; else ;
    
#line 4171 
    _tw32_flush(tp,1024U,mac_mode,0U);
    
#line 4172 
    __const_udelay(429500UL);
    
#line 4174 
    _tw32_flush(tp,1128U,2U,0U);
    
#line 4175 
    __const_udelay(42950UL);
  }
  else ;
  
#line 4178 
  tmp_23 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_SPEED_100MB,(unsigned long *)(& tp->tg3_flags));
  
#line 4178 
  if (tmp_23 == 0) {
    
#line 4178 
    if (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) {
      u32 base_val;
      
#line 4183 
      base_val = tp->pci_clock_ctrl;
      
#line 4184 
      base_val |= 3072U;
      
#line 4187 
      _tw32_flush(tp,116U,base_val | 36864U,40U);
    }
    else 
#line 4178 
         goto _LAND;
  }
  else {
    int tmp_21;
    _LAND: 
#line 4189 
    tmp_21 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 4189 
    if (tmp_21 != 0) 
#line 4189 
                     goto _LOR_1;
    else {
      int tmp_22;
      
#line 4189 
      tmp_22 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
      
#line 4189 
      if (tmp_22 != 0) 
#line 4189 
                       goto _LOR_1;
      else 
        
#line 4190 
        if (tp->pci_chip_rev_id >> 12 == 12U) _LOR_1: ;
        else {
          int tmp_19;
          
#line 4193 
          tmp_19 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
          
#line 4193 
          if (tmp_19 == 0) 
#line 4193 
                           goto _LOR_0;
          else {
            int tmp_20;
            
#line 4193 
            tmp_20 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
            
#line 4193 
            if (tmp_20 == 0) {
              _LOR_0: {
                        u32 newbits1;
                        u32 newbits2;
                        int tmp_18;
                        
#line 4196 
                        if (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) {
                          
#line 4198 
                          newbits1 = 7168U;
                          
#line 4201 
                          newbits2 = newbits1 | 262144U;
                        }
                        else {
                          int tmp_17;
                          
#line 4202 
                          tmp_17 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
                          
#line 4202 
                          if (tmp_17 != 0) {
                            
#line 4203 
                            newbits1 = 1048576U;
                            
#line 4204 
                            newbits2 = newbits1 | 4096U;
                          }
                          else {
                            
#line 4206 
                            newbits1 = 4096U;
                            
#line 4207 
                            newbits2 = newbits1 | 262144U;
                          }
                        }
                        
#line 4210 
                        _tw32_flush(tp,116U,tp->pci_clock_ctrl | newbits1,40U);
                        
#line 4213 
                        _tw32_flush(tp,116U,tp->pci_clock_ctrl | newbits2,40U);
                        
#line 4216 
                        tmp_18 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
                        
#line 4216 
                        if (tmp_18 == 0) {
                          u32 newbits3;
                          
#line 4219 
                          if (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) 
                            
#line 4221 
                            newbits3 = 265216U; else 
#line 4225 
                                                     newbits3 = 262144U;
                          
#line 4228 
                          _tw32_flush(tp,116U,tp->pci_clock_ctrl | newbits3,40U);
                        }
                        else ;
                      }
            }
            else ;
          }
        }
    }
  }
  
#line 4233 
  if (! device_should_wake) {
    int tmp_24;
    
#line 4233 
    tmp_24 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
    
#line 4233 
    if (tmp_24 == 0) 
#line 4234 
                     tg3_power_down_phy(tp,(_Bool)((bool)((int)do_low_power) != 0)); else ;
  }
  else ;
  
#line 4236 
  tg3_frob_aux_power(tp,(_Bool)1);
  
#line 4239 
  tmp_27 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
  
#line 4239 
  if (tmp_27 == 0) {
    
#line 4239 
    if ((tp->pci_chip_rev_id >> 8) + 4294967232U <= 1U) {
      u32 tmp_25;
      int tmp_26;
      
#line 4242 
      tmp_25 = (*(tp->read32))(tp,32000U);
      
#line 4242 
      u32 val_1 = tmp_25;
      
#line 4244 
      val_1 &= 4294901736U;
      
#line 4245 
      (*(tp->write32))(tp,32000U,val_1);
      
#line 4246 
      tmp_26 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
      
#line 4246 
      if (tmp_26 == 0) {
        int err;
        
#line 4249 
        err = tg3_nvram_lock(tp);
        
#line 4250 
        tg3_halt_cpu(tp,20480U);
        
#line 4251 
        if (err == 0) 
#line 4252 
                      tg3_nvram_unlock(tp); else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 4256 
  tg3_write_sig_post_reset(tp,0);
  
#line 4258 
  tg3_ape_driver_state_change(tp,0);
  
#line 4260 
  __retres = 0;
  
#line 4260 
  return __retres;
}


#line 4263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_power_down(struct tg3 *tp)
{
  int tmp;
  
#line 4265 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 4265 
  ;
  
#line 4265 
  pci_wake_from_d3(tp->pdev,(_Bool)(tmp != 0));
  
#line 4266 
  pci_set_power_state(tp->pdev,3);
  
#line 4267 
  return;
}


#line 4269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_aux_stat_to_speed_duplex(struct tg3 *tp, u32 val, u16 *speed, u8 *duplex)
{
  
#line 4271 
  switch (val & 1792U) {
    case (unsigned int)256: 
#line 4272 
    ;
    
#line 4273 
    *speed = (unsigned short)10U;
    
#line 4274 
    *duplex = (unsigned char)0U;
    
#line 4275 
    goto ldv_56796;
    case (unsigned int)512: 
#line 4277 
    ;
    
#line 4278 
    *speed = (unsigned short)10U;
    
#line 4279 
    *duplex = (unsigned char)1U;
    
#line 4280 
    goto ldv_56796;
    case (unsigned int)768: 
#line 4282 
    ;
    
#line 4283 
    *speed = (unsigned short)100U;
    
#line 4284 
    *duplex = (unsigned char)0U;
    
#line 4285 
    goto ldv_56796;
    case (unsigned int)1280: 
#line 4287 
    ;
    
#line 4288 
    *speed = (unsigned short)100U;
    
#line 4289 
    *duplex = (unsigned char)1U;
    
#line 4290 
    goto ldv_56796;
    case (unsigned int)1536: 
#line 4292 
    ;
    
#line 4293 
    *speed = (unsigned short)1000U;
    
#line 4294 
    *duplex = (unsigned char)0U;
    
#line 4295 
    goto ldv_56796;
    case (unsigned int)1792: 
#line 4297 
    ;
    
#line 4298 
    *speed = (unsigned short)1000U;
    
#line 4299 
    *duplex = (unsigned char)1U;
    
#line 4300 
    goto ldv_56796;
    default: 
#line 4302 
    ;
    
#line 4303 
    if ((tp->phy_flags & 64U) != 0U) {
      
#line 4304 
      if ((val & 8U) != 0U) 
#line 4304 
                            *speed = (unsigned short)100U; else 
#line 4304 
                                                                *speed = (unsigned short)10U;
      
#line 4306 
      *duplex = (unsigned char)((unsigned int)((unsigned char)val) & 1U);
      
#line 4308 
      goto ldv_56796;
    }
    else ;
    
#line 4310 
    *speed = (unsigned short)65535U;
    
#line 4311 
    *duplex = (unsigned char)255U;
    
#line 4312 
    goto ldv_56796;
  }
  ldv_56796: 
#line 4314 
  ;
  
#line 4315 
  return;
}


#line 4316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_autoneg_cfg(struct tg3 *tp, u32 advertise, u32 flowctrl)
{
  u32 val;
  u32 new_adv;
  u32 tmp;
  u16 tmp_0;
  u32 tmp_1;
  
#line 4318 
  int err = 0;
  
#line 4321 
  new_adv = 1U;
  
#line 4322 
  tmp = ethtool_adv_to_mii_adv_t(advertise);
  
#line 4322 
  new_adv = (tmp & 480U) | new_adv;
  
#line 4323 
  tmp_0 = mii_advertise_flowctrl((int)flowctrl);
  
#line 4323 
  new_adv = (unsigned int)tmp_0 | new_adv;
  
#line 4325 
  err = tg3_writephy(tp,4,new_adv);
  
#line 4326 
  if (err != 0) 
#line 4327 
                goto done; else ;
  
#line 4329 
  if ((tp->phy_flags & 128U) == 0U) {
    
#line 4330 
    new_adv = ethtool_adv_to_mii_ctrl1000_t(advertise);
    
#line 4332 
    if (tp->pci_chip_rev_id == 0U || tp->pci_chip_rev_id == 256U) 
#line 4334 
                                                                  new_adv |= 6144U; else ;
    
#line 4336 
    err = tg3_writephy(tp,9,new_adv);
    
#line 4337 
    if (err != 0) 
#line 4338 
                  goto done; else ;
  }
  else ;
  
#line 4341 
  if ((tp->phy_flags & 262144U) == 0U) 
#line 4342 
                                       goto done; else ;
  
#line 4344 
  tmp_1 = (*(tp->read32))(tp,14000U);
  
#line 4344 
  ;
  
#line 4344 
  (*(tp->write32))(tp,14000U,tmp_1 & 4294967167U);
  
#line 4347 
  err = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)1);
  
#line 4348 
  if (err == 0) {
    u32 err2;
    int tmp_3;
    
#line 4351 
    val = 0U;
    
#line 4353 
    if ((advertise & 8U) != 0U) 
#line 4354 
                                val |= 2U; else ;
    
#line 4356 
    if ((advertise & 32U) != 0U) 
#line 4357 
                                 val |= 4U; else ;
    
#line 4359 
    if (tp->eee.eee_enabled == 0U) {
      
#line 4360 
      val = 0U;
      
#line 4361 
      tp->eee.advertised = 0U;
    }
    else 
#line 4363 
         tp->eee.advertised = advertise & 40U;
    
#line 4368 
    err = tg3_phy_cl45_write(tp,7U,60U,val);
    
#line 4369 
    if (err != 0) 
#line 4370 
                  val = 0U; else ;
    
#line 4372 
    switch (tp->pci_chip_rev_id >> 12) {
      int tmp_2;
      case (u32)22295: 
#line 4373 
      ;
      case (u32)358277: 
#line 4374 
      ;
      case (u32)358246: 
#line 4375 
      ;
      case (u32)22297: 
#line 4376 
      ;
      
#line 4378 
      if (val != 0U) 
#line 4379 
                     val = 7U; else ;
      
#line 4382 
      tg3_phydsp_write(tp,26U,val);
      case (u32)22304: 
#line 4384 
      ;
      case (u32)22370: 
#line 4385 
      ;
      
#line 4386 
      tmp_2 = tg3_phydsp_read(tp,16418U,& val);
      
#line 4386 
      if (tmp_2 == 0) 
#line 4387 
                      tg3_phydsp_write(tp,16418U,val | 511U); else ;
    }
    
#line 4391 
    tmp_3 = tg3_phy_toggle_auxctl_smdsp(tp,(_Bool)0);
    
#line 4391 
    err2 = (unsigned int)tmp_3;
    
#line 4392 
    if (err == 0) 
#line 4393 
                  err = (int)err2; else ;
  }
  else ;
  done: 
#line 4396 
  ;
  
#line 4397 
  return err;
}


#line 4400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_copper_begin(struct tg3 *tp)
{
  
#line 4402 
  if ((unsigned int)tp->link_config.autoneg == 1U || (tp->phy_flags & 1U) != 0U) {
    u32 adv;
    u32 fc;
    
#line 4406 
    if ((tp->phy_flags & 1U) != 0U && (tp->phy_flags & 1048576U) == 0U) {
      int tmp;
      
#line 4408 
      adv = 3U;
      
#line 4410 
      tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_SPEED_100MB,(unsigned long *)(& tp->tg3_flags));
      
#line 4410 
      if (tmp != 0) 
#line 4411 
                    adv |= 12U; else ;
      
#line 4413 
      if ((tp->phy_flags & 524288U) != 0U) {
        
#line 4414 
        if ((tp->phy_flags & 4194304U) == 0U) 
#line 4416 
                                              adv |= 16U; else ;
        
#line 4417 
        adv |= 32U;
      }
      else ;
      
#line 4420 
      fc = 3U;
    }
    else {
      
#line 4422 
      adv = tp->link_config.advertising;
      
#line 4423 
      if ((tp->phy_flags & 128U) != 0U) 
#line 4424 
                                        adv &= 4294967247U; else ;
      
#line 4427 
      fc = (unsigned int)tp->link_config.flowctrl;
    }
    
#line 4430 
    tg3_phy_autoneg_cfg(tp,adv,fc);
    
#line 4432 
    if ((tp->phy_flags & 1U) != 0U && (tp->phy_flags & 1048576U) != 0U) 
      
#line 4438 
      goto return_label; else ;
    
#line 4441 
    tg3_writephy(tp,0,4608U);
  }
  else {
    int i;
    u32 bmcr;
    u32 orig_bmcr;
    int tmp_3;
    
#line 4447 
    tp->link_config.active_speed = tp->link_config.speed;
    
#line 4448 
    tp->link_config.active_duplex = tp->link_config.duplex;
    
#line 4450 
    if (tp->pci_chip_rev_id >> 12 == 9U) 
#line 4455 
                                         tg3_writephy(tp,4,480U); else ;
    
#line 4458 
    bmcr = 0U;
    
#line 4459 
    switch ((int)tp->link_config.speed) {
      default: 
#line 4460 
      ;
      case 10: 
#line 4461 
      ;
      
#line 4462 
      goto ldv_56829;
      case 100: 
#line 4464 
      ;
      
#line 4465 
      bmcr |= 8192U;
      
#line 4466 
      goto ldv_56829;
      case 1000: 
#line 4468 
      ;
      
#line 4469 
      bmcr |= 64U;
      
#line 4470 
      goto ldv_56829;
    }
    ldv_56829: 
#line 4473 
    ;
    
#line 4473 
    if ((unsigned int)tp->link_config.duplex == 1U) 
#line 4474 
                                                    bmcr |= 256U; else ;
    
#line 4476 
    tmp_3 = tg3_readphy(tp,0,& orig_bmcr);
    
#line 4476 
    if (tmp_3 == 0) {
      
#line 4476 
      if (bmcr != orig_bmcr) {
        
#line 4478 
        tg3_writephy(tp,0,16384U);
        
#line 4479 
        i = 0;
        
#line 4479 
        goto ldv_56836;
        ldv_56835: 
#line 4480 
        ;
        {
          u32 tmp_0;
          int tmp_1;
          
#line 4482 
          __const_udelay(42950UL);
          
#line 4483 
          tmp_1 = tg3_readphy(tp,1,& tmp_0);
          
#line 4483 
          if (tmp_1 != 0) 
#line 4483 
                          goto _LOR;
          else {
            int tmp_2;
            
#line 4483 
            tmp_2 = tg3_readphy(tp,1,& tmp_0);
            
#line 4483 
            if (tmp_2 != 0) _LOR: 
#line 4485 
                                  goto ldv_56833; else ;
          }
          
#line 4486 
          if ((tmp_0 & 4U) == 0U) {
            
#line 4487 
            __const_udelay(171800UL);
            
#line 4488 
            goto ldv_56834;
          }
          else ;
        }
        ldv_56833: 
#line 4491 
        ;
        
#line 4479 
        i += 1;
        ldv_56836: 
#line 4480 
        ;
        
#line 4479 
        if (i <= 1499) 
#line 4481 
                       goto ldv_56835; else 
#line 4484 
                                            goto ldv_56834;
        ldv_56834: 
#line 4485 
        ;
        
#line 4491 
        tg3_writephy(tp,0,bmcr);
        
#line 4492 
        __const_udelay(171800UL);
      }
      else ;
    }
    else ;
  }
  return_label: 
#line 4496 
                return;
}


#line 4497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_pull_config(struct tg3 *tp)
{
  int err;
  u32 val;
  
#line 4502 
  err = tg3_readphy(tp,0,& val);
  
#line 4503 
  if (err != 0) 
#line 4504 
                goto done; else ;
  
#line 4506 
  if ((val & 4096U) == 0U) {
    
#line 4507 
    tp->link_config.autoneg = (unsigned char)0U;
    
#line 4508 
    tp->link_config.advertising = 0U;
    
#line 4509 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags));
    
#line 4511 
    err = -5;
    
#line 4513 
    switch (val & 8256U) {
      case (unsigned int)0: 
#line 4514 
      ;
      
#line 4515 
      if ((tp->phy_flags & 48U) != 0U) 
#line 4516 
                                       goto done; else ;
      
#line 4518 
      tp->link_config.speed = (unsigned short)10U;
      
#line 4519 
      goto ldv_56844;
      case (unsigned int)8192: 
#line 4520 
      ;
      
#line 4521 
      if ((tp->phy_flags & 48U) != 0U) 
#line 4522 
                                       goto done; else ;
      
#line 4524 
      tp->link_config.speed = (unsigned short)100U;
      
#line 4525 
      goto ldv_56844;
      case (unsigned int)64: 
#line 4526 
      ;
      
#line 4527 
      if ((tp->phy_flags & 128U) == 0U) {
        
#line 4528 
        tp->link_config.speed = (unsigned short)1000U;
        
#line 4529 
        goto ldv_56844;
      }
      else ;
      default: 
#line 4532 
      ;
      
#line 4533 
      goto done;
    }
    ldv_56844: 
#line 4536 
    ;
    
#line 4536 
    if ((val & 256U) != 0U) 
#line 4537 
                            tp->link_config.duplex = (unsigned char)1U; else 
                                                                    
#line 4539 
                                                                    tp->link_config.duplex = (unsigned char)0U;
    
#line 4541 
    tp->link_config.flowctrl = (unsigned char)3U;
    
#line 4543 
    err = 0;
    
#line 4544 
    goto done;
  }
  else ;
  
#line 4547 
  tp->link_config.autoneg = (unsigned char)1U;
  
#line 4548 
  tp->link_config.advertising = 64U;
  
#line 4549 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags));
  
#line 4551 
  if ((tp->phy_flags & 48U) == 0U) {
    u32 adv;
    u32 tmp;
    
#line 4554 
    err = tg3_readphy(tp,4,& val);
    
#line 4555 
    if (err != 0) 
#line 4556 
                  goto done; else ;
    
#line 4558 
    adv = mii_adv_to_ethtool_adv_t(val & 480U);
    
#line 4559 
    tp->link_config.advertising = (tp->link_config.advertising | adv) | 128U;
    
#line 4561 
    tmp = tg3_decode_flowctrl_1000T(val);
    
#line 4561 
    tp->link_config.flowctrl = (unsigned char)tmp;
  }
  else 
#line 4563 
       tp->link_config.advertising |= 1024U;
  
#line 4566 
  if ((tp->phy_flags & 128U) == 0U) {
    u32 adv_0;
    
#line 4569 
    if ((tp->phy_flags & 48U) == 0U) {
      
#line 4570 
      err = tg3_readphy(tp,9,& val);
      
#line 4571 
      if (err != 0) 
#line 4572 
                    goto done; else ;
      
#line 4574 
      adv_0 = mii_ctrl1000_to_ethtool_adv_t(val);
    }
    else {
      
#line 4576 
      err = tg3_readphy(tp,4,& val);
      
#line 4577 
      if (err != 0) 
#line 4578 
                    goto done; else ;
      
#line 4580 
      adv_0 = tg3_decode_flowctrl_1000X(val);
      
#line 4581 
      tp->link_config.flowctrl = (unsigned char)adv_0;
      
#line 4583 
      val &= 96U;
      
#line 4584 
      adv_0 = mii_adv_to_ethtool_adv_x(val);
    }
    
#line 4587 
    tp->link_config.advertising |= adv_0;
  }
  else ;
  done: 
#line 4590 
  ;
  
#line 4591 
  return err;
}


#line 4594  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_init_5401phy_dsp(struct tg3 *tp)
{
  int err;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  
#line 4600 
  err = tg3_phy_auxctl_write(tp,0,19488U);
  
#line 4602 
  tmp = tg3_phydsp_write(tp,18U,6148U);
  
#line 4602 
  err = tmp | err;
  
#line 4603 
  tmp_0 = tg3_phydsp_write(tp,19U,4612U);
  
#line 4603 
  err = tmp_0 | err;
  
#line 4604 
  tmp_1 = tg3_phydsp_write(tp,32774U,306U);
  
#line 4604 
  err = tmp_1 | err;
  
#line 4605 
  tmp_2 = tg3_phydsp_write(tp,32774U,562U);
  
#line 4605 
  err = tmp_2 | err;
  
#line 4606 
  tmp_3 = tg3_phydsp_write(tp,8223U,2592U);
  
#line 4606 
  err = tmp_3 | err;
  
#line 4608 
  __const_udelay(171800UL);
  
#line 4610 
  return err;
}


#line 4613  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_phy_eee_config_ok(struct tg3 *tp)
{
  bool __retres;
  struct ethtool_eee eee;
  
#line 4617 
  if ((tp->phy_flags & 262144U) == 0U) {
    
#line 4618 
    __retres = (_Bool)1;
    
#line 4618 
    goto return_label;
  }
  else ;
  
#line 4620 
  tg3_eee_pull_config(tp,& eee);
  
#line 4622 
  if (tp->eee.eee_enabled != 0U) {
    
#line 4623 
    if ((tp->eee.advertised != eee.advertised || tp->eee.tx_lpi_timer != eee.tx_lpi_timer) || tp->eee.tx_lpi_enabled != eee.tx_lpi_enabled) {
      
#line 4626 
      __retres = (_Bool)0;
      
#line 4626 
      goto return_label;
    }
    else ;
  }
  else 
    
#line 4629 
    if (eee.advertised != 0U) {
      
#line 4630 
      __retres = (_Bool)0;
      
#line 4630 
      goto return_label;
    }
    else ;
  
#line 4633 
  __retres = (_Bool)1;
  return_label: 
#line 4633 
                return __retres;
}


#line 4636  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_phy_copper_an_config_ok(struct tg3 *tp, u32 *lcladv)
{
  bool __retres;
  u32 advmsk;
  u32 tgtadv;
  u32 advertising;
  u32 tmp;
  int tmp_1;
  
#line 4640 
  advertising = tp->link_config.advertising;
  
#line 4641 
  tmp = ethtool_adv_to_mii_adv_t(advertising);
  
#line 4641 
  tgtadv = tmp & 480U;
  
#line 4643 
  advmsk = 480U;
  
#line 4644 
  if ((unsigned int)tp->link_config.active_duplex == 1U) {
    u16 tmp_0;
    
#line 4645 
    tmp_0 = mii_advertise_flowctrl((int)tp->link_config.flowctrl);
    
#line 4645 
    tgtadv = (unsigned int)tmp_0 | tgtadv;
    
#line 4646 
    advmsk |= 3072U;
  }
  else ;
  
#line 4649 
  tmp_1 = tg3_readphy(tp,4,lcladv);
  
#line 4649 
  if (tmp_1 != 0) {
    
#line 4650 
    __retres = (_Bool)0;
    
#line 4650 
    goto return_label;
  }
  else ;
  
#line 4652 
  if ((*lcladv & advmsk) != tgtadv) {
    
#line 4653 
    __retres = (_Bool)0;
    
#line 4653 
    goto return_label;
  }
  else ;
  
#line 4655 
  if ((tp->phy_flags & 128U) == 0U) {
    u32 tg3_ctrl;
    int tmp_2;
    
#line 4658 
    tgtadv = ethtool_adv_to_mii_ctrl1000_t(advertising);
    
#line 4660 
    tmp_2 = tg3_readphy(tp,9,& tg3_ctrl);
    
#line 4660 
    if (tmp_2 != 0) {
      
#line 4661 
      __retres = (_Bool)0;
      
#line 4661 
      goto return_label;
    }
    else ;
    
#line 4663 
    if (tgtadv != 0U && (tp->pci_chip_rev_id == 0U || tp->pci_chip_rev_id == 256U)) {
      
#line 4666 
      tgtadv |= 6144U;
      
#line 4667 
      tg3_ctrl &= 6912U;
    }
    else 
#line 4670 
         tg3_ctrl &= 768U;
    
#line 4673 
    if (tg3_ctrl != tgtadv) {
      
#line 4674 
      __retres = (_Bool)0;
      
#line 4674 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 4677 
  __retres = (_Bool)1;
  return_label: 
#line 4677 
                return __retres;
}


#line 4680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_phy_copper_fetch_rmtadv(struct tg3 *tp, u32 *rmtadv)
{
  bool __retres;
  int tmp_0;
  u32 tmp_1;
  
#line 4682 
  u32 lpeth = 0U;
  
#line 4684 
  if ((tp->phy_flags & 128U) == 0U) {
    u32 val;
    int tmp;
    
#line 4687 
    tmp = tg3_readphy(tp,10,& val);
    
#line 4687 
    if (tmp != 0) {
      
#line 4688 
      __retres = (_Bool)0;
      
#line 4688 
      goto return_label;
    }
    else ;
    
#line 4690 
    lpeth = mii_stat1000_to_ethtool_lpa_t(val);
  }
  else ;
  
#line 4693 
  tmp_0 = tg3_readphy(tp,5,rmtadv);
  
#line 4693 
  if (tmp_0 != 0) {
    
#line 4694 
    __retres = (_Bool)0;
    
#line 4694 
    goto return_label;
  }
  else ;
  
#line 4696 
  tmp_1 = mii_lpa_to_ethtool_lpa_t(*rmtadv);
  
#line 4696 
  lpeth = tmp_1 | lpeth;
  
#line 4697 
  tp->link_config.rmt_adv = lpeth;
  
#line 4699 
  __retres = (_Bool)1;
  return_label: 
#line 4699 
                return __retres;
}


#line 4702  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_test_and_report_link_chg(struct tg3 *tp, bool curr_link_up)
{
  bool __retres;
  
#line 4704 
  if ((int)tp->link_up != (int)curr_link_up) {
    
#line 4705 
    if ((int)curr_link_up != 0) 
#line 4706 
                                netif_carrier_on(tp->dev);
    else {
      
#line 4708 
      netif_carrier_off(tp->dev);
      
#line 4709 
      if ((tp->phy_flags & 32U) != 0U) 
#line 4710 
                                       tp->phy_flags &= 4294836223U; else ;
    }
    
#line 4713 
    tg3_link_report(tp);
    
#line 4714 
    __retres = (_Bool)1;
    
#line 4714 
    goto return_label;
  }
  else ;
  
#line 4717 
  __retres = (_Bool)0;
  return_label: 
#line 4717 
                return __retres;
}


#line 4720  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_clear_mac_status(struct tg3 *tp)
{
  
#line 4722 
  (*(tp->write32))(tp,1032U,0U);
  
#line 4724 
  _tw32_flush(tp,1028U,4198424U,0U);
  
#line 4729 
  __const_udelay(171800UL);
  
#line 4731 
  return;
}


#line 4732  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_setup_eee(struct tg3 *tp)
{
  u32 val;
  int tmp;
  int tmp_0;
  u32 tmp_1;
  
#line 4736 
  val = 16777220U;
  
#line 4738 
  if (tp->pci_chip_rev_id == 1467502592U) 
#line 4739 
                                          val |= 2U; else ;
  
#line 4741 
  _tw32_flush(tp,14012U,val,0U);
  
#line 4743 
  _tw32_flush(tp,14032U,504U,0U);
  
#line 4748 
  if (tp->eee.tx_lpi_enabled != 0U) 
#line 4748 
                                    tmp = 1049352; else 
#line 4748 
                                                        tmp = 1049096;
  
#line 4746 
  val = (unsigned int)tmp;
  
#line 4751 
  if (tp->pci_chip_rev_id >> 12 != 22295U) 
#line 4752 
                                           val |= 64U; else ;
  
#line 4754 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 4754 
  if (tmp_0 != 0) 
#line 4755 
                  val |= 4U; else ;
  
#line 4757 
  if (tp->eee.eee_enabled != 0U) 
#line 4757 
                                 tmp_1 = val; else 
#line 4757 
                                                   tmp_1 = 0U;
  
#line 4757 
  ;
  
#line 4757 
  _tw32_flush(tp,14000U,tmp_1,0U);
  
#line 4759 
  _tw32_flush(tp,14004U,(tp->eee.tx_lpi_timer & 65535U) | 134152192U,0U);
  
#line 4763 
  _tw32_flush(tp,14008U,134154239U,0U);
  
#line 4764 
  return;
}


#line 4768  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_setup_copper_phy(struct tg3 *tp, bool force_reset)
{
  int __retres;
  bool current_link_up;
  u32 bmsr;
  u32 val;
  u32 lcl_adv;
  u32 rmt_adv;
  u16 current_speed;
  u8 current_duplex;
  int i;
  int err;
  int tmp_3;
  int tmp_13;
  int tmp_15;
  int tmp_18;
  
#line 4777 
  tg3_clear_mac_status(tp);
  
#line 4779 
  if ((tp->mi_mode & 16U) != 0U) {
    
#line 4780 
    _tw32_flush(tp,1108U,tp->mi_mode & 4294967279U,0U);
    
#line 4782 
    __const_udelay(343600UL);
  }
  else ;
  
#line 4785 
  tg3_phy_auxctl_write(tp,2,0U);
  
#line 4790 
  if ((tp->pci_chip_rev_id >> 12) + 4294967295U <= 2U && (int)tp->link_up != 0) {
    int tmp;
    
#line 4794 
    tg3_readphy(tp,1,& bmsr);
    
#line 4795 
    tmp = tg3_readphy(tp,1,& bmsr);
    
#line 4795 
    if (tmp == 0) {
      
#line 4795 
      if ((bmsr & 4U) == 0U) 
#line 4797 
                             force_reset = (_Bool)1; else ;
    }
    else ;
  }
  else ;
  
#line 4799 
  if ((int)force_reset != 0) 
#line 4800 
                             tg3_phy_reset(tp); else ;
  
#line 4802 
  if ((tp->phy_id & 4294967280U) == 1610645584U) {
    int tmp_0;
    
#line 4803 
    tg3_readphy(tp,1,& bmsr);
    
#line 4804 
    tmp_0 = tg3_readphy(tp,1,& bmsr);
    
#line 4804 
    if (tmp_0 != 0) 
#line 4806 
                    bmsr = 0U;
    else {
      int tmp_1;
      
#line 4804 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
      
#line 4804 
      if (tmp_1 == 0) 
#line 4806 
                      bmsr = 0U; else ;
    }
    
#line 4808 
    if ((bmsr & 4U) == 0U) {
      int tmp_2;
      
#line 4809 
      err = tg3_init_5401phy_dsp(tp);
      
#line 4810 
      if (err != 0) {
        
#line 4811 
        __retres = err;
        
#line 4811 
        goto return_label;
      }
      else ;
      
#line 4813 
      tg3_readphy(tp,1,& bmsr);
      
#line 4814 
      i = 0;
      
#line 4814 
      goto ldv_56898;
      ldv_56897: 
#line 4815 
      ;
      
#line 4815 
      __const_udelay(42950UL);
      
#line 4816 
      tmp_2 = tg3_readphy(tp,1,& bmsr);
      
#line 4816 
      if (tmp_2 == 0) {
        
#line 4816 
        if ((bmsr & 4U) != 0U) {
          
#line 4818 
          __const_udelay(171800UL);
          
#line 4819 
          goto ldv_56896;
        }
        else ;
      }
      else ;
      
#line 4814 
      i += 1;
      ldv_56898: 
#line 4815 
      ;
      
#line 4814 
      if (i <= 999) 
#line 4816 
                    goto ldv_56897; else 
#line 4819 
                                         goto ldv_56896;
      ldv_56896: 
#line 4820 
      ;
      
#line 4823 
      if (((tp->phy_id & 15U) == 1U && (bmsr & 4U) == 0U) && (unsigned int)tp->link_config.active_speed == 1000U) {
        
#line 4827 
        err = tg3_phy_reset(tp);
        
#line 4828 
        if (err == 0) 
#line 4829 
                      err = tg3_init_5401phy_dsp(tp); else ;
        
#line 4830 
        if (err != 0) {
          
#line 4831 
          __retres = err;
          
#line 4831 
          goto return_label;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else 
    
#line 4834 
    if (tp->pci_chip_rev_id == 0U || tp->pci_chip_rev_id == 256U) {
      
#line 4837 
      tg3_writephy(tp,21,2677U);
      
#line 4838 
      tg3_writephy(tp,28,35944U);
      
#line 4839 
      tg3_writephy(tp,28,36200U);
      
#line 4840 
      tg3_writephy(tp,28,35944U);
    }
    else ;
  
#line 4844 
  tg3_readphy(tp,26,& val);
  
#line 4845 
  tg3_readphy(tp,26,& val);
  
#line 4847 
  if ((tp->phy_flags & 4U) != 0U) 
#line 4848 
                                  tg3_writephy(tp,27,4294967293U);
  else 
    
#line 4849 
    if ((tp->phy_flags & 64U) == 0U) 
#line 4850 
                                     tg3_writephy(tp,27,4294967295U); else ;
  
#line 4852 
  if (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) 
    
#line 4854 
    if (tp->led_ctrl == 2048U) 
#line 4855 
                               tg3_writephy(tp,16,2U); else 
#line 4858 
                                                            tg3_writephy(tp,16,0U);
  else ;
  
#line 4861 
  current_link_up = (_Bool)0;
  
#line 4862 
  current_speed = (unsigned short)65535U;
  
#line 4863 
  current_duplex = (unsigned char)255U;
  
#line 4864 
  tp->phy_flags &= 4292870143U;
  
#line 4865 
  tp->link_config.rmt_adv = 0U;
  
#line 4867 
  if ((tp->phy_flags & 512U) != 0U) {
    
#line 4868 
    err = tg3_phy_auxctl_read(tp,4,& val);
    
#line 4871 
    if (err == 0 && (val & 1024U) == 0U) {
      
#line 4872 
      tg3_phy_auxctl_write(tp,4,val | 1024U);
      
#line 4875 
      goto relink;
    }
    else ;
  }
  else ;
  
#line 4879 
  bmsr = 0U;
  
#line 4880 
  i = 0;
  
#line 4880 
  goto ldv_56902;
  ldv_56901: 
#line 4881 
  ;
  
#line 4881 
  tg3_readphy(tp,1,& bmsr);
  
#line 4882 
  tmp_3 = tg3_readphy(tp,1,& bmsr);
  
#line 4882 
  if (tmp_3 == 0) {
    
#line 4882 
    if ((bmsr & 4U) != 0U) 
#line 4884 
                           goto ldv_56900; else ;
  }
  else ;
  
#line 4885 
  __const_udelay(171800UL);
  
#line 4880 
  i += 1;
  ldv_56902: 
#line 4881 
  ;
  
#line 4880 
  if (i <= 99) 
#line 4882 
               goto ldv_56901; else 
#line 4885 
                                    goto ldv_56900;
  ldv_56900: 
#line 4886 
  ;
  
#line 4888 
  if ((bmsr & 4U) != 0U) {
    u32 aux_stat;
    u32 bmcr;
    int tmp_4;
    int tmp_5;
    
#line 4891 
    tg3_readphy(tp,25,& aux_stat);
    
#line 4892 
    i = 0;
    
#line 4892 
    goto ldv_56907;
    ldv_56906: 
#line 4893 
    ;
    
#line 4893 
    __const_udelay(42950UL);
    
#line 4894 
    tmp_4 = tg3_readphy(tp,25,& aux_stat);
    
#line 4894 
    if (tmp_4 == 0) {
      
#line 4894 
      if (aux_stat != 0U) 
#line 4896 
                          goto ldv_56905; else ;
    }
    else ;
    
#line 4892 
    i += 1;
    ldv_56907: 
#line 4893 
    ;
    
#line 4892 
    if (i <= 1999) 
#line 4894 
                   goto ldv_56906; else 
#line 4897 
                                        goto ldv_56905;
    ldv_56905: 
#line 4898 
    ;
    
#line 4899 
    tg3_aux_stat_to_speed_duplex(tp,aux_stat,& current_speed,& current_duplex);
    
#line 4903 
    bmcr = 0U;
    
#line 4904 
    i = 0;
    
#line 4904 
    goto ldv_56911;
    ldv_56910: 
#line 4905 
    ;
    
#line 4905 
    tg3_readphy(tp,0,& bmcr);
    
#line 4906 
    tmp_5 = tg3_readphy(tp,0,& bmcr);
    
#line 4906 
    if (tmp_5 != 0) 
#line 4907 
                    goto ldv_56908; else ;
    
#line 4908 
    if (bmcr != 0U && bmcr != 32767U) 
#line 4909 
                                      goto ldv_56909; else ;
    
#line 4910 
    __const_udelay(42950UL);
    ldv_56908: 
#line 4912 
    ;
    
#line 4904 
    i += 1;
    ldv_56911: 
#line 4905 
    ;
    
#line 4904 
    if (i <= 199) 
#line 4906 
                  goto ldv_56910; else 
#line 4909 
                                       goto ldv_56909;
    ldv_56909: 
#line 4910 
    ;
    
#line 4913 
    lcl_adv = 0U;
    
#line 4914 
    rmt_adv = 0U;
    
#line 4916 
    tp->link_config.active_speed = current_speed;
    
#line 4917 
    tp->link_config.active_duplex = current_duplex;
    
#line 4919 
    if ((unsigned int)tp->link_config.autoneg == 1U) {
      
#line 4920 
      bool eee_config_ok = tg3_phy_eee_config_ok(tp);
      
#line 4922 
      if ((bmcr & 4096U) != 0U && (int)eee_config_ok != 0) {
        bool tmp_7;
        
#line 4923 
        tmp_7 = tg3_phy_copper_an_config_ok(tp,& lcl_adv);
        
#line 4923 
        if ((int)tmp_7 != 0) {
          bool tmp_8;
          
#line 4924 
          tmp_8 = tg3_phy_copper_fetch_rmtadv(tp,& rmt_adv);
          
#line 4924 
          if ((int)tmp_8 != 0) 
#line 4926 
                               current_link_up = (_Bool)1; else ;
        }
        else ;
      }
      else ;
      
#line 4932 
      if ((! eee_config_ok && (tp->phy_flags & 1048576U) != 0U) && ! force_reset) {
        
#line 4935 
        tg3_setup_eee(tp);
        
#line 4936 
        tg3_phy_reset(tp);
      }
      else ;
    }
    else 
      
#line 4939 
      if (((bmcr & 4096U) == 0U && (int)tp->link_config.speed == (int)current_speed) && (int)tp->link_config.duplex == (int)current_duplex) 
        
#line 4942 
        current_link_up = (_Bool)1; else ;
    
#line 4946 
    if ((int)current_link_up != 0 && (unsigned int)tp->link_config.active_duplex == 1U) {
      u32 reg;
      u32 bit;
      int tmp_9;
      
#line 4950 
      if ((tp->phy_flags & 64U) != 0U) {
        
#line 4951 
        reg = 28U;
        
#line 4952 
        bit = 8192U;
      }
      else {
        
#line 4954 
        reg = 17U;
        
#line 4955 
        bit = 8192U;
      }
      
#line 4958 
      tmp_9 = tg3_readphy(tp,(int)reg,& val);
      
#line 4958 
      if (tmp_9 == 0) {
        
#line 4958 
        if ((val & bit) != 0U) 
#line 4959 
                               tp->phy_flags |= 2097152U; else ;
      }
      else ;
      
#line 4961 
      tg3_setup_flow_control(tp,lcl_adv,rmt_adv);
    }
    else ;
  }
  else ;
  relink: 
#line 4965 
  ;
  
#line 4966 
  if (! current_link_up || (tp->phy_flags & 1U) != 0U) {
    int tmp_10;
    int tmp_11;
    
#line 4967 
    tg3_phy_copper_begin(tp);
    
#line 4969 
    tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ROBOSWITCH,(unsigned long *)(& tp->tg3_flags));
    
#line 4969 
    if (tmp_10 != 0) {
      
#line 4970 
      current_link_up = (_Bool)1;
      
#line 4972 
      current_speed = (unsigned short)1000U;
      
#line 4973 
      current_duplex = (unsigned char)1U;
      
#line 4974 
      tp->link_config.active_speed = current_speed;
      
#line 4975 
      tp->link_config.active_duplex = current_duplex;
    }
    else ;
    
#line 4978 
    tg3_readphy(tp,1,& bmsr);
    
#line 4979 
    tmp_11 = tg3_readphy(tp,1,& bmsr);
    
#line 4979 
    if (tmp_11 == 0) {
      
#line 4979 
      if ((bmsr & 4U) != 0U) 
#line 4981 
                             current_link_up = (_Bool)1; else 
#line 4979 
                                                              goto _LAND;
    }
    else {
      _LAND: 
#line 4979 
      ;
      
#line 4979 
      if ((tp->mac_mode & 16U) != 0U) 
#line 4981 
                                      current_link_up = (_Bool)1; else ;
    }
  }
  else ;
  
#line 4984 
  tp->mac_mode &= 4294967283U;
  
#line 4985 
  if ((int)current_link_up != 0) 
    
#line 4986 
    if ((unsigned int)tp->link_config.active_speed == 100U || (unsigned int)tp->link_config.active_speed == 10U) 
      
#line 4988 
      tp->mac_mode |= 4U; else 
#line 4990 
                               tp->mac_mode |= 8U;
  else 
    
#line 4991 
    if ((tp->phy_flags & 64U) != 0U) 
#line 4992 
                                     tp->mac_mode |= 4U; else 
#line 4994 
                                                              tp->mac_mode |= 8U;
  
#line 4999 
  tmp_13 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RGMII_MODE,(unsigned long *)(& tp->tg3_flags));
  
#line 4999 
  if (tmp_13 != 0) {
    u32 tmp_12;
    
#line 5000 
    tmp_12 = (*(tp->read32))(tp,1036U);
    
#line 5000 
    u32 led_ctrl = tmp_12;
    
#line 5001 
    led_ctrl &= 4294967289U;
    
#line 5003 
    if ((unsigned int)tp->link_config.active_speed == 10U) 
#line 5004 
                                                           led_ctrl |= 1U;
    else 
      
#line 5005 
      if ((unsigned int)tp->link_config.active_speed == 100U) 
#line 5006 
                                                              led_ctrl |= 5U;
      else 
        
#line 5008 
        if ((unsigned int)tp->link_config.active_speed == 1000U) 
#line 5009 
                                                                 led_ctrl |= 3U; else ;
    
#line 5012 
    (*(tp->write32))(tp,1036U,led_ctrl);
    
#line 5013 
    __const_udelay(171800UL);
  }
  else ;
  
#line 5016 
  tp->mac_mode &= 4294967293U;
  
#line 5017 
  if ((unsigned int)tp->link_config.active_duplex == 0U) 
#line 5018 
                                                         tp->mac_mode |= 2U; else ;
  
#line 5020 
  if (tp->pci_chip_rev_id >> 12 == 7U) 
    
#line 5021 
    if ((int)current_link_up != 0) {
      int tmp_14;
      
#line 5021 
      tmp_14 = tg3_5700_link_polarity(tp,(unsigned int)tp->link_config.active_speed);
      
#line 5021 
      if (tmp_14 != 0) 
#line 5023 
                       tp->mac_mode |= 1024U; else 
#line 5025 
                                                   tp->mac_mode &= 4294966271U;
    }
    else 
#line 5025 
         tp->mac_mode &= 4294966271U;
  else ;
  
#line 5031 
  if ((tp->phy_id & 4294967280U) == 1610645616U && tp->pci_chip_rev_id == 28932U) {
    
#line 5033 
    tp->mi_mode |= 16U;
    
#line 5034 
    _tw32_flush(tp,1108U,tp->mi_mode,0U);
    
#line 5035 
    __const_udelay(343600UL);
  }
  else ;
  
#line 5038 
  _tw32_flush(tp,1024U,tp->mac_mode,0U);
  
#line 5039 
  __const_udelay(171800UL);
  
#line 5041 
  tg3_phy_eee_adjust(tp,(_Bool)((bool)((int)current_link_up) != 0));
  
#line 5043 
  tmp_15 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_LINKCHG_REG,(unsigned long *)(& tp->tg3_flags));
  
#line 5043 
  if (tmp_15 != 0) 
#line 5045 
                   _tw32_flush(tp,1032U,0U,0U); else 
#line 5047 
                                                     _tw32_flush(tp,1032U,4096U,0U);
  
#line 5049 
  __const_udelay(171800UL);
  
#line 5051 
  if ((tp->pci_chip_rev_id >> 12 == 7U && (int)current_link_up != 0) && (unsigned int)tp->link_config.active_speed == 1000U) {
    int tmp_16;
    
#line 5053 
    tmp_16 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
    
#line 5053 
    if (tmp_16 != 0) 
#line 5051 
                     goto _LOR;
    else {
      int tmp_17;
      
#line 5054 
      tmp_17 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_HIGH_SPEED,(unsigned long *)(& tp->tg3_flags));
      
#line 5054 
      if (tmp_17 != 0) {
        _LOR: {
                
#line 5055 
                __const_udelay(515400UL);
                
#line 5056 
                _tw32_flush(tp,1028U,24U,0U);
                
#line 5059 
                __const_udelay(171800UL);
                
#line 5060 
                tg3_write_mem(tp,2896U,1214346827U);
              }
      }
      else ;
    }
  }
  else ;
  
#line 5066 
  tmp_18 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CLKREQ_BUG,(unsigned long *)(& tp->tg3_flags));
  
#line 5066 
  if (tmp_18 != 0) 
    
#line 5067 
    if ((unsigned int)tp->link_config.active_speed == 100U || (unsigned int)tp->link_config.active_speed == 10U) 
      
#line 5069 
      pcie_capability_clear_word(tp->pdev,16,(unsigned short)256); else 
                                                                    
#line 5072 
                                                                    pcie_capability_set_word(tp->pdev,16,(unsigned short)256);
  else ;
  
#line 5076 
  tg3_test_and_report_link_chg(tp,(_Bool)((bool)((int)current_link_up) != 0));
  
#line 5078 
  __retres = 0;
  return_label: 
#line 5078 
                return __retres;
}


#line 5145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_fiber_aneg_smachine(struct tg3 *tp, struct tg3_fiber_aneginfo *ap)
{
  u16 flowctrl;
  unsigned long delta;
  u32 rx_cfg_reg;
  int ret;
  u32 tmp;
  
#line 5153 
  if (ap->state == 0) {
    
#line 5154 
    ap->rxconfig = 0U;
    
#line 5155 
    ap->link_time = 0UL;
    
#line 5156 
    ap->cur_time = 0UL;
    
#line 5157 
    ap->ability_match_cfg = 0U;
    
#line 5158 
    ap->ability_match_count = 0;
    
#line 5159 
    ap->ability_match = (char)0;
    
#line 5160 
    ap->idle_match = (char)0;
    
#line 5161 
    ap->ack_match = (char)0;
  }
  else ;
  
#line 5163 
  ap->cur_time += 1UL;
  
#line 5165 
  tmp = (*(tp->read32))(tp,1028U);
  
#line 5165 
  if ((tmp & 4U) != 0U) {
    
#line 5166 
    rx_cfg_reg = (*(tp->read32))(tp,1096U);
    
#line 5168 
    if (ap->ability_match_cfg != rx_cfg_reg) {
      
#line 5169 
      ap->ability_match_cfg = rx_cfg_reg;
      
#line 5170 
      ap->ability_match = (char)0;
      
#line 5171 
      ap->ability_match_count = 0;
    }
    else {
      
#line 5173 
      ap->ability_match_count += 1;
      
#line 5173 
      if (ap->ability_match_count > 1) {
        
#line 5174 
        ap->ability_match = (char)1;
        
#line 5175 
        ap->ability_match_cfg = rx_cfg_reg;
      }
      else ;
    }
    
#line 5178 
    if ((rx_cfg_reg & 64U) != 0U) 
#line 5179 
                                  ap->ack_match = (char)1; else 
#line 5181 
                                                                ap->ack_match = (char)0;
    
#line 5183 
    ap->idle_match = (char)0;
  }
  else {
    
#line 5185 
    ap->idle_match = (char)1;
    
#line 5186 
    ap->ability_match_cfg = 0U;
    
#line 5187 
    ap->ability_match_count = 0;
    
#line 5188 
    ap->ability_match = (char)0;
    
#line 5189 
    ap->ack_match = (char)0;
    
#line 5191 
    rx_cfg_reg = 0U;
  }
  
#line 5194 
  ap->rxconfig = rx_cfg_reg;
  
#line 5195 
  ret = 0;
  
#line 5197 
  switch (ap->state) {
    case 0: 
#line 5198 
    ;
    
#line 5199 
    if ((ap->flags & 3U) != 0U) 
#line 5200 
                                ap->state = 1; else ;
    case 1: 
#line 5203 
    ;
    
#line 5204 
    ap->flags &= 4294967283U;
    
#line 5205 
    if ((ap->flags & 1U) != 0U) {
      
#line 5206 
      ap->link_time = 0UL;
      
#line 5207 
      ap->cur_time = 0UL;
      
#line 5208 
      ap->ability_match_cfg = 0U;
      
#line 5209 
      ap->ability_match_count = 0;
      
#line 5210 
      ap->ability_match = (char)0;
      
#line 5211 
      ap->idle_match = (char)0;
      
#line 5212 
      ap->ack_match = (char)0;
      
#line 5214 
      ap->state = 2;
    }
    else 
#line 5216 
         ap->state = 4;
    
#line 5218 
    goto ldv_56938;
    case 2: 
#line 5220 
    ;
    
#line 5221 
    ap->link_time = ap->cur_time;
    
#line 5222 
    ap->flags &= 4294967279U;
    
#line 5223 
    ap->txconfig = 0U;
    
#line 5224 
    (*(tp->write32))(tp,1092U,0U);
    
#line 5225 
    tp->mac_mode |= 131072U;
    
#line 5226 
    _tw32_flush(tp,1024U,tp->mac_mode,0U);
    
#line 5227 
    __const_udelay(171800UL);
    
#line 5229 
    ret = 2;
    
#line 5230 
    ap->state = 3;
    case 3: 
#line 5233 
    ;
    
#line 5234 
    delta = ap->cur_time - ap->link_time;
    
#line 5235 
    if (delta > 10000UL) 
#line 5236 
                         ap->state = 5; else 
#line 5238 
                                             ret = 2;
    
#line 5239 
    goto ldv_56938;
    case 4: 
#line 5241 
    ;
    
#line 5242 
    ret = 1;
    
#line 5243 
    goto ldv_56938;
    case 5: 
#line 5245 
    ;
    
#line 5246 
    ap->flags &= 4294967263U;
    
#line 5247 
    ap->txconfig = 8192U;
    
#line 5248 
    flowctrl = tg3_advert_flowctrl_1000X((unsigned char)((int)tp->link_config.flowctrl));
    
#line 5249 
    if (((int)flowctrl & 128) != 0) 
#line 5250 
                                    ap->txconfig |= 32768U; else ;
    
#line 5251 
    if (((int)flowctrl & 256) != 0) 
#line 5252 
                                    ap->txconfig |= 1U; else ;
    
#line 5253 
    (*(tp->write32))(tp,1092U,ap->txconfig);
    
#line 5254 
    tp->mac_mode |= 131072U;
    
#line 5255 
    _tw32_flush(tp,1024U,tp->mac_mode,0U);
    
#line 5256 
    __const_udelay(171800UL);
    
#line 5258 
    ap->state = 6;
    
#line 5259 
    goto ldv_56938;
    case 6: 
#line 5261 
    ;
    
#line 5262 
    if ((int)ap->ability_match != 0 && ap->rxconfig != 0U) 
#line 5263 
                                                           ap->state = 7; else ;
    
#line 5264 
    goto ldv_56938;
    case 7: 
#line 5266 
    ;
    
#line 5267 
    ap->txconfig |= 64U;
    
#line 5268 
    (*(tp->write32))(tp,1092U,ap->txconfig);
    
#line 5269 
    tp->mac_mode |= 131072U;
    
#line 5270 
    _tw32_flush(tp,1024U,tp->mac_mode,0U);
    
#line 5271 
    __const_udelay(171800UL);
    
#line 5273 
    ap->state = 8;
    case 8: 
#line 5276 
    ;
    
#line 5277 
    if ((int)ap->ack_match != 0) 
      
#line 5278 
      if (((ap->rxconfig ^ ap->ability_match_cfg) & 4294967231U) == 0U) 
        
#line 5280 
        ap->state = 9; else 
#line 5282 
                            ap->state = 1;
    else 
      
#line 5284 
      if ((int)ap->ability_match != 0 && ap->rxconfig == 0U) 
#line 5286 
                                                             ap->state = 1; else ;
    
#line 5288 
    goto ldv_56938;
    case 9: 
#line 5290 
    ;
    
#line 5291 
    if ((ap->rxconfig & 7942U) != 0U) {
      
#line 5292 
      ret = -1;
      
#line 5293 
      goto ldv_56938;
    }
    else ;
    
#line 5295 
    ap->flags &= 4294934591U;
    
#line 5304 
    if ((ap->rxconfig & 8192U) != 0U) 
#line 5305 
                                      ap->flags |= 64U; else ;
    
#line 5306 
    if ((ap->rxconfig & 16384U) != 0U) 
#line 5307 
                                       ap->flags |= 128U; else ;
    
#line 5308 
    if ((ap->rxconfig & 32768U) != 0U) 
#line 5309 
                                       ap->flags |= 256U; else ;
    
#line 5310 
    if ((ap->rxconfig & 1U) != 0U) 
#line 5311 
                                   ap->flags |= 512U; else ;
    
#line 5312 
    if ((ap->rxconfig & 16U) != 0U) 
#line 5313 
                                    ap->flags |= 1024U; else ;
    
#line 5314 
    if ((ap->rxconfig & 32U) != 0U) 
#line 5315 
                                    ap->flags |= 2048U; else ;
    
#line 5316 
    if ((ap->rxconfig & 128U) != 0U) 
#line 5317 
                                     ap->flags |= 4096U; else ;
    
#line 5319 
    ap->link_time = ap->cur_time;
    
#line 5321 
    ap->flags ^= 32U;
    
#line 5322 
    if ((ap->rxconfig & 8U) != 0U) 
#line 5323 
                                   ap->flags |= 8192U; else ;
    
#line 5324 
    if ((ap->rxconfig & 128U) != 0U) 
#line 5325 
                                     ap->flags |= 16384U; else ;
    
#line 5326 
    ap->flags |= 8U;
    
#line 5328 
    ap->state = 10;
    
#line 5329 
    ret = 2;
    
#line 5330 
    goto ldv_56938;
    case 10: 
#line 5332 
    ;
    
#line 5333 
    if ((int)ap->ability_match != 0 && ap->rxconfig == 0U) {
      
#line 5335 
      ap->state = 1;
      
#line 5336 
      goto ldv_56938;
    }
    else ;
    
#line 5338 
    delta = ap->cur_time - ap->link_time;
    
#line 5339 
    if (delta > 10000UL) 
      
#line 5340 
      if ((ap->flags & 4096U) == 0U) 
#line 5341 
                                     ap->state = 11;
      else 
        
#line 5343 
        if ((ap->txconfig & 128U) == 0U && (ap->flags & 16384U) == 0U) 
          
#line 5345 
          ap->state = 11; else 
#line 5347 
                               ret = -1;
    else ;
    
#line 5351 
    goto ldv_56938;
    case 11: 
#line 5353 
    ;
    
#line 5354 
    ap->link_time = ap->cur_time;
    
#line 5355 
    tp->mac_mode &= 4294836223U;
    
#line 5356 
    _tw32_flush(tp,1024U,tp->mac_mode,0U);
    
#line 5357 
    __const_udelay(171800UL);
    
#line 5359 
    ap->state = 12;
    
#line 5360 
    ret = 2;
    
#line 5361 
    goto ldv_56938;
    case 12: 
#line 5363 
    ;
    
#line 5364 
    if ((int)ap->ability_match != 0 && ap->rxconfig == 0U) {
      
#line 5366 
      ap->state = 1;
      
#line 5367 
      goto ldv_56938;
    }
    else ;
    
#line 5369 
    delta = ap->cur_time - ap->link_time;
    
#line 5370 
    if (delta > 10000UL) 
#line 5372 
                         ap->state = 13; else ;
    
#line 5374 
    goto ldv_56938;
    case 13: 
#line 5376 
    ;
    
#line 5377 
    ap->flags |= 2147483652U;
    
#line 5378 
    ret = 1;
    
#line 5379 
    goto ldv_56938;
    case 14: 
#line 5381 
    ;
    
#line 5383 
    goto ldv_56938;
    case 15: 
#line 5385 
    ;
    
#line 5387 
    goto ldv_56938;
    default: 
#line 5389 
    ;
    
#line 5390 
    ret = -1;
    
#line 5391 
    goto ldv_56938;
  }
  ldv_56938: 
#line 5394 
  ;
  
#line 5394 
  return ret;
}


#line 5397  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int fiber_autoneg(struct tg3 *tp, u32 *txflags, u32 *rxflags)
{
  struct tg3_fiber_aneginfo aninfo;
  unsigned int tick;
  u32 tmp;
  
#line 5399 
  int res = 0;
  
#line 5401 
  int status = -1;
  
#line 5405 
  _tw32_flush(tp,1092U,0U,0U);
  
#line 5407 
  tmp = tp->mac_mode & 4294967283U;
  
#line 5408 
  _tw32_flush(tp,1024U,tmp | 8U,0U);
  
#line 5409 
  __const_udelay(171800UL);
  
#line 5411 
  _tw32_flush(tp,1024U,tp->mac_mode | 131072U,0U);
  
#line 5412 
  __const_udelay(171800UL);
  
#line 5414 
  memset((void *)(& aninfo),0,48UL);
  
#line 5415 
  aninfo.flags |= 1U;
  
#line 5416 
  aninfo.state = 0;
  
#line 5417 
  aninfo.cur_time = 0UL;
  
#line 5418 
  tick = 0U;
  
#line 5419 
  goto ldv_56966;
  ldv_56965: 
#line 5420 
  ;
  
#line 5420 
  status = tg3_fiber_aneg_smachine(tp,& aninfo);
  
#line 5421 
  if (status == 1 || status == -1) 
#line 5422 
                                   goto ldv_56964; else ;
  
#line 5424 
  __const_udelay(4295UL);
  ldv_56966: 
#line 5426 
  ;
  
#line 5419 
  tick += 1U;
  
#line 5419 
  if (tick <= 194999U) 
#line 5421 
                       goto ldv_56965; else 
#line 5424 
                                            goto ldv_56964;
  ldv_56964: 
#line 5425 
  ;
  
#line 5427 
  tp->mac_mode &= 4294836223U;
  
#line 5428 
  _tw32_flush(tp,1024U,tp->mac_mode,0U);
  
#line 5429 
  __const_udelay(171800UL);
  
#line 5431 
  *txflags = aninfo.txconfig;
  
#line 5432 
  *rxflags = aninfo.flags;
  
#line 5434 
  if (status == 1 && (aninfo.flags & 2147483716U) != 0U) 
#line 5437 
                                                         res = 1; else ;
  
#line 5439 
  return res;
}


#line 5442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_init_bcm8002(struct tg3 *tp)
{
  u32 tmp;
  int i;
  int tmp_0;
  
#line 5444 
  tmp = (*(tp->read32))(tp,1028U);
  
#line 5444 
  u32 mac_status = tmp;
  
#line 5448 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
  
#line 5448 
  if (tmp_0 != 0) {
    
#line 5448 
    if ((mac_status & 1U) == 0U) 
#line 5450 
                                 goto return_label; else ;
  }
  else ;
  
#line 5453 
  tg3_writephy(tp,22,32775U);
  
#line 5456 
  tg3_writephy(tp,0,32768U);
  
#line 5460 
  i = 0;
  
#line 5460 
  goto ldv_56973;
  ldv_56972: 
#line 5461 
  ;
  
#line 5461 
  __const_udelay(42950UL);
  
#line 5460 
  i += 1;
  ldv_56973: 
#line 5461 
  ;
  
#line 5460 
  if (i <= 499) 
#line 5462 
                goto ldv_56972; else 
#line 5465 
                                     goto ldv_56974;
  ldv_56974: 
#line 5466 
  ;
  
#line 5464 
  tg3_writephy(tp,16,33809U);
  
#line 5467 
  tg3_writephy(tp,17,2576U);
  
#line 5469 
  tg3_writephy(tp,24,160U);
  
#line 5470 
  tg3_writephy(tp,22,16895U);
  
#line 5473 
  tg3_writephy(tp,19,1024U);
  
#line 5474 
  __const_udelay(171800UL);
  
#line 5475 
  tg3_writephy(tp,19,0U);
  
#line 5477 
  tg3_writephy(tp,17,2640U);
  
#line 5478 
  __const_udelay(171800UL);
  
#line 5479 
  tg3_writephy(tp,17,2576U);
  
#line 5483 
  i = 0;
  
#line 5483 
  goto ldv_56976;
  ldv_56975: 
#line 5484 
  ;
  
#line 5484 
  __const_udelay(42950UL);
  
#line 5483 
  i += 1;
  ldv_56976: 
#line 5484 
  ;
  
#line 5483 
  if (i <= 14999) 
#line 5485 
                  goto ldv_56975; else 
#line 5488 
                                       goto ldv_56977;
  ldv_56977: 
#line 5489 
  ;
  
#line 5489 
  tg3_writephy(tp,16,32785U);
  return_label: 
#line 5490 
                return;
}


#line 5492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_setup_fiber_hw_autoneg(struct tg3 *tp, u32 mac_status)
{
  u16 flowctrl;
  bool current_link_up;
  u32 sg_dig_ctrl;
  u32 sg_dig_status;
  u32 serdes_cfg;
  u32 expected_sg_dig_ctrl;
  int workaround;
  int port_a;
  
#line 5500 
  serdes_cfg = 0U;
  
#line 5501 
  expected_sg_dig_ctrl = 0U;
  
#line 5502 
  workaround = 0;
  
#line 5503 
  port_a = 1;
  
#line 5504 
  current_link_up = (_Bool)0;
  
#line 5506 
  if (tp->pci_chip_rev_id + 4294959104U > 1U) {
    u32 tmp;
    u32 tmp_0;
    
#line 5508 
    workaround = 1;
    
#line 5509 
    tmp = (*(tp->read32))(tp,184U);
    
#line 5509 
    if ((tmp & 4U) != 0U) 
#line 5510 
                          port_a = 0; else ;
    
#line 5514 
    tmp_0 = (*(tp->read32))(tp,1424U);
    
#line 5514 
    serdes_cfg = tmp_0 & 15757311U;
  }
  else ;
  
#line 5517 
  sg_dig_ctrl = (*(tp->read32))(tp,1456U);
  
#line 5519 
  if ((unsigned int)tp->link_config.autoneg != 1U) {
    
#line 5520 
    if (sg_dig_ctrl < (u32)0) {
      
#line 5521 
      if (workaround != 0) {
        
#line 5522 
        u32 val = serdes_cfg;
        
#line 5524 
        if (port_a != 0) 
#line 5525 
                         val |= 201392128U; else 
#line 5527 
                                                 val |= 67174400U;
        
#line 5528 
        _tw32_flush(tp,1424U,val,0U);
      }
      else ;
      
#line 5531 
      _tw32_flush(tp,1456U,20481024U,0U);
    }
    else ;
    
#line 5533 
    if ((mac_status & 1U) != 0U) {
      
#line 5534 
      tg3_setup_flow_control(tp,0U,0U);
      
#line 5535 
      current_link_up = (_Bool)1;
    }
    else ;
    
#line 5537 
    goto out;
  }
  else ;
  
#line 5541 
  expected_sg_dig_ctrl = 2167964672U;
  
#line 5543 
  flowctrl = tg3_advert_flowctrl_1000X((unsigned char)((int)tp->link_config.flowctrl));
  
#line 5544 
  if (((int)flowctrl & 128) != 0) 
#line 5545 
                                  expected_sg_dig_ctrl |= 2048U; else ;
  
#line 5546 
  if (((int)flowctrl & 256) != 0) 
#line 5547 
                                  expected_sg_dig_ctrl |= 4096U; else ;
  
#line 5549 
  if (sg_dig_ctrl != expected_sg_dig_ctrl) {
    
#line 5550 
    if (((tp->phy_flags & 131072U) != 0U && tp->serdes_counter != 0U) && (mac_status & 5U) == 1U) {
      
#line 5555 
      tp->serdes_counter -= 1U;
      
#line 5556 
      current_link_up = (_Bool)1;
      
#line 5557 
      goto out;
    }
    else ;
    restart_autoneg: 
#line 5559 
    ;
    
#line 5560 
    if (workaround != 0) 
#line 5561 
                         _tw32_flush(tp,1424U,serdes_cfg | 201396224U,0U); else ;
    
#line 5562 
    _tw32_flush(tp,1456U,expected_sg_dig_ctrl | 1073741824U,0U);
    
#line 5563 
    __const_udelay(21475UL);
    
#line 5564 
    _tw32_flush(tp,1456U,expected_sg_dig_ctrl,0U);
    
#line 5566 
    tp->serdes_counter = 2U;
    
#line 5567 
    tp->phy_flags &= 4294836223U;
  }
  else 
    
#line 5568 
    if ((mac_status & 3U) != 0U) {
      
#line 5570 
      sg_dig_status = (*(tp->read32))(tp,1460U);
      
#line 5571 
      mac_status = (*(tp->read32))(tp,1028U);
      
#line 5573 
      if ((sg_dig_status & 2U) != 0U && (mac_status & 1U) != 0U) {
        
#line 5575 
        u32 local_adv = 0U;
        
#line 5575 
        u32 remote_adv = 0U;
        
#line 5577 
        if ((sg_dig_ctrl & 2048U) != 0U) 
#line 5578 
                                         local_adv |= 128U; else ;
        
#line 5579 
        if ((sg_dig_ctrl & 4096U) != 0U) 
#line 5580 
                                         local_adv |= 256U; else ;
        
#line 5582 
        if ((sg_dig_status & 524288U) != 0U) 
#line 5583 
                                             remote_adv |= 128U; else ;
        
#line 5584 
        if ((sg_dig_status & 1048576U) != 0U) 
#line 5585 
                                              remote_adv |= 256U; else ;
        
#line 5587 
        tp->link_config.rmt_adv = mii_adv_to_ethtool_adv_x(remote_adv);
        
#line 5590 
        tg3_setup_flow_control(tp,local_adv,remote_adv);
        
#line 5591 
        current_link_up = (_Bool)1;
        
#line 5592 
        tp->serdes_counter = 0U;
        
#line 5593 
        tp->phy_flags &= 4294836223U;
      }
      else 
        
#line 5594 
        if ((sg_dig_status & 2U) == 0U) 
          
#line 5595 
          if (tp->serdes_counter != 0U) 
#line 5596 
                                        tp->serdes_counter -= 1U;
          else {
            
#line 5598 
            if (workaround != 0) {
              
#line 5599 
              u32 val_0 = serdes_cfg;
              
#line 5601 
              if (port_a != 0) 
#line 5602 
                               val_0 |= 201392128U; else 
#line 5604 
                                                         val_0 |= 67174400U;
              
#line 5606 
              _tw32_flush(tp,1424U,val_0,0U);
            }
            else ;
            
#line 5609 
            _tw32_flush(tp,1456U,20481024U,0U);
            
#line 5610 
            __const_udelay(171800UL);
            
#line 5615 
            mac_status = (*(tp->read32))(tp,1028U);
            
#line 5616 
            if ((mac_status & 1U) != 0U && (mac_status & 4U) == 0U) {
              
#line 5618 
              tg3_setup_flow_control(tp,0U,0U);
              
#line 5619 
              current_link_up = (_Bool)1;
              
#line 5620 
              tp->phy_flags |= 131072U;
              
#line 5622 
              tp->serdes_counter = 1U;
            }
            else 
#line 5625 
                 goto restart_autoneg;
          }
        else ;
    }
    else {
      
#line 5629 
      tp->serdes_counter = 2U;
      
#line 5630 
      tp->phy_flags &= 4294836223U;
    }
  out: 
#line 5633 
  ;
  
#line 5634 
  return current_link_up;
}


#line 5637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_setup_fiber_by_hand(struct tg3 *tp, u32 mac_status)
{
  
#line 5639 
  bool current_link_up = (_Bool)0;
  
#line 5641 
  if ((mac_status & 1U) == 0U) 
#line 5642 
                               goto out; else ;
  
#line 5644 
  if ((unsigned int)tp->link_config.autoneg == 1U) {
    u32 txflags;
    u32 rxflags;
    int i;
    int tmp;
    u32 tmp_0;
    
#line 5648 
    tmp = fiber_autoneg(tp,& txflags,& rxflags);
    
#line 5648 
    if (tmp != 0) {
      
#line 5649 
      u32 local_adv = 0U;
      
#line 5649 
      u32 remote_adv = 0U;
      
#line 5651 
      if ((txflags & 32768U) != 0U) 
#line 5652 
                                    local_adv |= 128U; else ;
      
#line 5653 
      if ((txflags & 1U) != 0U) 
#line 5654 
                                local_adv |= 256U; else ;
      
#line 5656 
      if ((rxflags & 256U) != 0U) 
#line 5657 
                                  remote_adv |= 128U; else ;
      
#line 5658 
      if ((rxflags & 512U) != 0U) 
#line 5659 
                                  remote_adv |= 256U; else ;
      
#line 5661 
      tp->link_config.rmt_adv = mii_adv_to_ethtool_adv_x(remote_adv);
      
#line 5664 
      tg3_setup_flow_control(tp,local_adv,remote_adv);
      
#line 5666 
      current_link_up = (_Bool)1;
    }
    else ;
    
#line 5668 
    i = 0;
    
#line 5668 
    goto ldv_57009;
    ldv_57008: 
#line 5669 
    ;
    
#line 5669 
    __const_udelay(85900UL);
    
#line 5670 
    _tw32_flush(tp,1028U,24U,0U);
    
#line 5673 
    __const_udelay(171800UL);
    
#line 5674 
    tmp_0 = (*(tp->read32))(tp,1028U);
    
#line 5674 
    if ((tmp_0 & 24U) == 0U) 
#line 5677 
                             goto ldv_57007; else ;
    
#line 5668 
    i += 1;
    ldv_57009: 
#line 5669 
    ;
    
#line 5668 
    if (i <= 29) 
#line 5670 
                 goto ldv_57008; else 
#line 5673 
                                      goto ldv_57007;
    ldv_57007: 
#line 5674 
    ;
    
#line 5680 
    mac_status = (*(tp->read32))(tp,1028U);
    
#line 5681 
    if ((! current_link_up && (mac_status & 1U) != 0U) && (mac_status & 4U) == 0U) 
      
#line 5684 
      current_link_up = (_Bool)1; else ;
  }
  else {
    
#line 5686 
    tg3_setup_flow_control(tp,0U,0U);
    
#line 5689 
    current_link_up = (_Bool)1;
    
#line 5691 
    _tw32_flush(tp,1024U,tp->mac_mode | 131072U,0U);
    
#line 5692 
    __const_udelay(171800UL);
    
#line 5694 
    _tw32_flush(tp,1024U,tp->mac_mode,0U);
    
#line 5695 
    __const_udelay(171800UL);
  }
  out: 
#line 5698 
  ;
  
#line 5699 
  return current_link_up;
}


#line 5702  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_setup_fiber_phy(struct tg3 *tp, bool force_reset)
{
  int __retres;
  u32 orig_pause_cfg;
  u16 orig_active_speed;
  u8 orig_active_duplex;
  u32 mac_status;
  bool current_link_up;
  int i;
  int tmp;
  int tmp_1;
  u32 tmp_2;
  int tmp_4;
  bool tmp_3;
  
#line 5711 
  orig_pause_cfg = (unsigned int)tp->link_config.active_flowctrl;
  
#line 5712 
  orig_active_speed = tp->link_config.active_speed;
  
#line 5713 
  orig_active_duplex = tp->link_config.active_duplex;
  
#line 5715 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_AUTONEG,(unsigned long *)(& tp->tg3_flags));
  
#line 5715 
  if (tmp == 0) {
    
#line 5715 
    if ((int)tp->link_up != 0) {
      int tmp_0;
      
#line 5716 
      tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
      
#line 5716 
      if (tmp_0 != 0) {
        
#line 5718 
        mac_status = (*(tp->read32))(tp,1028U);
        
#line 5719 
        mac_status &= 15U;
        
#line 5723 
        if (mac_status == 3U) {
          
#line 5725 
          _tw32_flush(tp,1028U,24U,0U);
          
#line 5727 
          __retres = 0;
          
#line 5727 
          goto return_label;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 5731 
  _tw32_flush(tp,1092U,0U,0U);
  
#line 5733 
  tp->mac_mode &= 4294967281U;
  
#line 5734 
  tp->mac_mode |= 12U;
  
#line 5735 
  _tw32_flush(tp,1024U,tp->mac_mode,0U);
  
#line 5736 
  __const_udelay(171800UL);
  
#line 5738 
  if (tp->phy_id == 1610678592U) 
#line 5739 
                                 tg3_init_bcm8002(tp); else ;
  
#line 5742 
  _tw32_flush(tp,1032U,4096U,0U);
  
#line 5743 
  __const_udelay(171800UL);
  
#line 5745 
  current_link_up = (_Bool)0;
  
#line 5746 
  tp->link_config.rmt_adv = 0U;
  
#line 5747 
  mac_status = (*(tp->read32))(tp,1028U);
  
#line 5749 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_AUTONEG,(unsigned long *)(& tp->tg3_flags));
  
#line 5749 
  if (tmp_1 != 0) 
#line 5750 
                  current_link_up = tg3_setup_fiber_hw_autoneg(tp,mac_status); else 
                                                                    
#line 5752 
                                                                    current_link_up = tg3_setup_fiber_by_hand(tp,mac_status);
  
#line 5754 
  (tp->napi[0].hw_status)->status = ((tp->napi[0].hw_status)->status & 4294967292U) | 1U;
  
#line 5758 
  i = 0;
  
#line 5758 
  goto ldv_57022;
  ldv_57021: 
#line 5759 
  ;
  
#line 5759 
  _tw32_flush(tp,1028U,24U,0U);
  
#line 5761 
  __const_udelay(21475UL);
  
#line 5762 
  tmp_2 = (*(tp->read32))(tp,1028U);
  
#line 5762 
  if ((tmp_2 & 4120U) == 0U) 
#line 5765 
                             goto ldv_57020; else ;
  
#line 5758 
  i += 1;
  ldv_57022: 
#line 5759 
  ;
  
#line 5758 
  if (i <= 99) 
#line 5760 
               goto ldv_57021; else 
#line 5763 
                                    goto ldv_57020;
  ldv_57020: 
#line 5764 
  ;
  
#line 5768 
  mac_status = (*(tp->read32))(tp,1028U);
  
#line 5769 
  if ((mac_status & 1U) == 0U) {
    
#line 5770 
    current_link_up = (_Bool)0;
    
#line 5771 
    if ((unsigned int)tp->link_config.autoneg == 1U && tp->serdes_counter == 0U) {
      
#line 5773 
      _tw32_flush(tp,1024U,tp->mac_mode | 131072U,0U);
      
#line 5775 
      __const_udelay(4295UL);
      
#line 5776 
      _tw32_flush(tp,1024U,tp->mac_mode,0U);
    }
    else ;
  }
  else ;
  
#line 5780 
  if ((int)current_link_up != 0) {
    
#line 5781 
    tp->link_config.active_speed = (unsigned short)1000U;
    
#line 5782 
    tp->link_config.active_duplex = (unsigned char)1U;
    
#line 5783 
    (*(tp->write32))(tp,1036U,tp->led_ctrl | 3U);
  }
  else {
    
#line 5787 
    tp->link_config.active_speed = (unsigned short)65535U;
    
#line 5788 
    tp->link_config.active_duplex = (unsigned char)255U;
    
#line 5789 
    (*(tp->write32))(tp,1036U,tp->led_ctrl | 17U);
  }
  
#line 5794 
  tmp_3 = tg3_test_and_report_link_chg(tp,(_Bool)((bool)((int)current_link_up) != 0));
  
#line 5794 
  if (tmp_3) 
#line 5794 
             tmp_4 = 0; else 
#line 5794 
                             tmp_4 = 1;
  
#line 5794 
  if (tmp_4) {
    
#line 5795 
    u32 now_pause_cfg = (unsigned int)tp->link_config.active_flowctrl;
    
#line 5796 
    if ((orig_pause_cfg != now_pause_cfg || (int)tp->link_config.active_speed != (int)orig_active_speed) || (int)tp->link_config.active_duplex != (int)orig_active_duplex) 
      
#line 5799 
      tg3_link_report(tp); else ;
  }
  else ;
  
#line 5802 
  __retres = 0;
  return_label: 
#line 5802 
                return __retres;
}


#line 5805  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_setup_fiber_mii_phy(struct tg3 *tp, bool force_reset)
{
  int __retres;
  u32 bmsr;
  u32 bmcr;
  u32 local_adv;
  u32 remote_adv;
  u32 sgsr;
  int tmp_0;
  int tmp_1;
  int tmp_3;
  
#line 5807 
  int err = 0;
  
#line 5809 
  u16 current_speed = (unsigned short)65535U;
  
#line 5810 
  u8 current_duplex = (unsigned char)255U;
  
#line 5811 
  bool current_link_up = (_Bool)0;
  
#line 5814 
  if (tp->pci_chip_rev_id >> 12 == 22297U || tp->pci_chip_rev_id >> 12 == 22304U) {
    int tmp;
    
#line 5815 
    tmp = tg3_readphy(tp,20,& sgsr);
    
#line 5815 
    if (tmp == 0) {
      
#line 5816 
      if ((sgsr & 1U) != 0U) {
        
#line 5819 
        if ((int)force_reset != 0) 
#line 5820 
                                   tg3_phy_reset(tp); else ;
        
#line 5822 
        tp->mac_mode &= 4294967283U;
        
#line 5824 
        if ((sgsr & 2U) == 0U) 
#line 5825 
                               tp->mac_mode |= 8U;
        else {
          
#line 5827 
          current_link_up = (_Bool)1;
          
#line 5828 
          if ((sgsr & 16U) != 0U) {
            
#line 5829 
            current_speed = (unsigned short)1000U;
            
#line 5830 
            tp->mac_mode |= 8U;
          }
          else 
            
#line 5831 
            if ((sgsr & 8U) != 0U) {
              
#line 5832 
              current_speed = (unsigned short)100U;
              
#line 5833 
              tp->mac_mode |= 4U;
            }
            else {
              
#line 5835 
              current_speed = (unsigned short)10U;
              
#line 5836 
              tp->mac_mode |= 4U;
            }
          
#line 5839 
          if ((sgsr & 4U) != 0U) 
#line 5840 
                                 current_duplex = (unsigned char)1U; else 
                                                                    
#line 5842 
                                                                    current_duplex = (unsigned char)0U;
        }
        
#line 5845 
        _tw32_flush(tp,1024U,tp->mac_mode,0U);
        
#line 5846 
        __const_udelay(171800UL);
        
#line 5848 
        tg3_clear_mac_status(tp);
        
#line 5850 
        goto fiber_setup_done;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 5853 
  tp->mac_mode |= 8U;
  
#line 5854 
  _tw32_flush(tp,1024U,tp->mac_mode,0U);
  
#line 5855 
  __const_udelay(171800UL);
  
#line 5857 
  tg3_clear_mac_status(tp);
  
#line 5859 
  if ((int)force_reset != 0) 
#line 5860 
                             tg3_phy_reset(tp); else ;
  
#line 5862 
  tp->link_config.rmt_adv = 0U;
  
#line 5864 
  tmp_0 = tg3_readphy(tp,1,& bmsr);
  
#line 5864 
  err = tmp_0 | err;
  
#line 5865 
  tmp_1 = tg3_readphy(tp,1,& bmsr);
  
#line 5865 
  err = tmp_1 | err;
  
#line 5866 
  if (tp->pci_chip_rev_id >> 12 == 9U) {
    u32 tmp_2;
    
#line 5867 
    tmp_2 = (*(tp->read32))(tp,1120U);
    
#line 5867 
    if ((tmp_2 & 8U) != 0U) 
#line 5868 
                            bmsr |= 4U; else 
#line 5870 
                                             bmsr &= 4294967291U;
  }
  else ;
  
#line 5873 
  tmp_3 = tg3_readphy(tp,0,& bmcr);
  
#line 5873 
  err = tmp_3 | err;
  
#line 5875 
  if (((unsigned int)tp->link_config.autoneg == 1U && ! force_reset) && (tp->phy_flags & 131072U) != 0U) ;
  else 
    
#line 5878 
    if ((unsigned int)tp->link_config.autoneg == 1U) {
      u32 adv;
      u32 newadv;
      int tmp_4;
      u16 tmp_5;
      u32 tmp_6;
      
#line 5881 
      tmp_4 = tg3_readphy(tp,4,& adv);
      
#line 5881 
      err = tmp_4 | err;
      
#line 5882 
      newadv = adv & 4294966784U;
      
#line 5887 
      tmp_5 = tg3_advert_flowctrl_1000X((unsigned char)((int)tp->link_config.flowctrl));
      
#line 5887 
      newadv = (unsigned int)tmp_5 | newadv;
      
#line 5888 
      tmp_6 = ethtool_adv_to_mii_adv_x(tp->link_config.advertising);
      
#line 5888 
      newadv = tmp_6 | newadv;
      
#line 5890 
      if (newadv != adv || (bmcr & 4096U) == 0U) {
        
#line 5891 
        tg3_writephy(tp,4,newadv);
        
#line 5892 
        bmcr |= 4608U;
        
#line 5893 
        tg3_writephy(tp,0,bmcr);
        
#line 5895 
        _tw32_flush(tp,1032U,4096U,0U);
        
#line 5896 
        tp->serdes_counter = 1U;
        
#line 5897 
        tp->phy_flags &= 4294836223U;
        
#line 5899 
        __retres = err;
        
#line 5899 
        goto return_label;
      }
      else ;
    }
    else {
      u32 new_bmcr;
      
#line 5904 
      bmcr &= 4294967231U;
      
#line 5905 
      new_bmcr = bmcr & 4294962943U;
      
#line 5907 
      if ((unsigned int)tp->link_config.duplex == 1U) 
#line 5908 
                                                      new_bmcr |= 256U; else ;
      
#line 5910 
      if (new_bmcr != bmcr) {
        int tmp_8;
        int tmp_9;
        
#line 5914 
        new_bmcr |= 64U;
        
#line 5917 
        if ((int)tp->link_up != 0) {
          u32 adv_0;
          int tmp_7;
          
#line 5920 
          tmp_7 = tg3_readphy(tp,4,& adv_0);
          
#line 5920 
          err = tmp_7 | err;
          
#line 5921 
          adv_0 &= 4294967168U;
          
#line 5924 
          tg3_writephy(tp,4,adv_0);
          
#line 5925 
          tg3_writephy(tp,0,bmcr | 4608U);
          
#line 5928 
          __const_udelay(42950UL);
          
#line 5929 
          tg3_carrier_off(tp);
        }
        else ;
        
#line 5931 
        tg3_writephy(tp,0,new_bmcr);
        
#line 5932 
        bmcr = new_bmcr;
        
#line 5933 
        tmp_8 = tg3_readphy(tp,1,& bmsr);
        
#line 5933 
        err = tmp_8 | err;
        
#line 5934 
        tmp_9 = tg3_readphy(tp,1,& bmsr);
        
#line 5934 
        err = tmp_9 | err;
        
#line 5935 
        if (tp->pci_chip_rev_id >> 12 == 9U) {
          u32 tmp_10;
          
#line 5936 
          tmp_10 = (*(tp->read32))(tp,1120U);
          
#line 5936 
          if ((tmp_10 & 8U) != 0U) 
#line 5937 
                                   bmsr |= 4U; else 
#line 5939 
                                                    bmsr &= 4294967291U;
        }
        else ;
        
#line 5941 
        tp->phy_flags &= 4294836223U;
      }
      else ;
    }
  
#line 5945 
  if ((bmsr & 4U) != 0U) {
    
#line 5946 
    current_speed = (unsigned short)1000U;
    
#line 5947 
    current_link_up = (_Bool)1;
    
#line 5948 
    if ((bmcr & 256U) != 0U) 
#line 5949 
                             current_duplex = (unsigned char)1U; else 
                                                                   
#line 5951 
                                                                   current_duplex = (unsigned char)0U;
    
#line 5953 
    local_adv = 0U;
    
#line 5954 
    remote_adv = 0U;
    
#line 5956 
    if ((bmcr & 4096U) != 0U) {
      u32 common;
      int tmp_11;
      int tmp_12;
      
#line 5959 
      tmp_11 = tg3_readphy(tp,4,& local_adv);
      
#line 5959 
      err = tmp_11 | err;
      
#line 5960 
      tmp_12 = tg3_readphy(tp,5,& remote_adv);
      
#line 5960 
      err = tmp_12 | err;
      
#line 5961 
      common = local_adv & remote_adv;
      
#line 5962 
      if ((common & 96U) != 0U) {
        
#line 5964 
        if ((common & 32U) != 0U) 
#line 5965 
                                  current_duplex = (unsigned char)1U; else 
                                                                    
#line 5967 
                                                                    current_duplex = (unsigned char)0U;
        
#line 5969 
        tp->link_config.rmt_adv = mii_adv_to_ethtool_adv_x(remote_adv);
      }
      else {
        int tmp_13;
        
#line 5971 
        tmp_13 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
        
#line 5971 
        if (tmp_13 == 0) ; else 
#line 5974 
                                current_link_up = (_Bool)0;
      }
    }
    else ;
  }
  else ;
  fiber_setup_done: 
#line 5979 
  ;
  
#line 5980 
  if ((int)current_link_up != 0 && (unsigned int)current_duplex == 1U) 
    
#line 5981 
    tg3_setup_flow_control(tp,local_adv,remote_adv); else ;
  
#line 5983 
  tp->mac_mode &= 4294967293U;
  
#line 5984 
  if ((unsigned int)tp->link_config.active_duplex == 0U) 
#line 5985 
                                                         tp->mac_mode |= 2U; else ;
  
#line 5987 
  _tw32_flush(tp,1024U,tp->mac_mode,0U);
  
#line 5988 
  __const_udelay(171800UL);
  
#line 5990 
  _tw32_flush(tp,1032U,4096U,0U);
  
#line 5992 
  tp->link_config.active_speed = current_speed;
  
#line 5993 
  tp->link_config.active_duplex = current_duplex;
  
#line 5995 
  tg3_test_and_report_link_chg(tp,(_Bool)((bool)((int)current_link_up) != 0));
  
#line 5996 
  __retres = err;
  return_label: 
#line 5996 
                return __retres;
}


#line 5999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_serdes_parallel_detect(struct tg3 *tp)
{
  
#line 6001 
  if (tp->serdes_counter != 0U) {
    
#line 6003 
    tp->serdes_counter -= 1U;
    
#line 6004 
    goto return_label;
  }
  else ;
  
#line 6007 
  if (! tp->link_up && (unsigned int)tp->link_config.autoneg == 1U) {
    u32 bmcr;
    
#line 6011 
    tg3_readphy(tp,0,& bmcr);
    
#line 6012 
    if ((bmcr & 4096U) != 0U) {
      u32 phy1;
      u32 phy2;
      
#line 6016 
      tg3_writephy(tp,28,31744U);
      
#line 6017 
      tg3_readphy(tp,28,& phy1);
      
#line 6020 
      tg3_writephy(tp,23,3841U);
      
#line 6022 
      tg3_readphy(tp,21,& phy2);
      
#line 6023 
      tg3_readphy(tp,21,& phy2);
      
#line 6025 
      if ((phy1 & 16U) != 0U && (phy2 & 32U) == 0U) {
        
#line 6031 
        bmcr &= 4294963199U;
        
#line 6032 
        bmcr |= 320U;
        
#line 6033 
        tg3_writephy(tp,0,bmcr);
        
#line 6034 
        tp->phy_flags |= 131072U;
      }
      else ;
    }
    else ;
  }
  else 
    
#line 6037 
    if (((int)tp->link_up != 0 && (unsigned int)tp->link_config.autoneg == 1U) && (tp->phy_flags & 131072U) != 0U) {
      u32 phy2_0;
      
#line 6043 
      tg3_writephy(tp,23,3841U);
      
#line 6045 
      tg3_readphy(tp,21,& phy2_0);
      
#line 6046 
      if ((phy2_0 & 32U) != 0U) {
        u32 bmcr_0;
        
#line 6050 
        tg3_readphy(tp,0,& bmcr_0);
        
#line 6051 
        tg3_writephy(tp,0,bmcr_0 | 4096U);
        
#line 6053 
        tp->phy_flags &= 4294836223U;
      }
      else ;
    }
    else ;
  return_label: 
#line 6056 
                return;
}


#line 6059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_setup_phy(struct tg3 *tp, bool force_reset)
{
  u32 val;
  int err;
  int tmp_2;
  int tmp_3;
  
#line 6064 
  if ((tp->phy_flags & 16U) != 0U) 
#line 6065 
                                   err = tg3_setup_fiber_phy(tp,(_Bool)((bool)((int)force_reset) != 0));
  else 
    
#line 6066 
    if ((tp->phy_flags & 32U) != 0U) 
#line 6067 
                                     err = tg3_setup_fiber_mii_phy(tp,(_Bool)((bool)((int)force_reset) != 0)); else 
                                                                    
#line 6069 
                                                                    err = tg3_setup_copper_phy(tp,(_Bool)((bool)((int)force_reset) != 0));
  
#line 6071 
  if (tp->pci_chip_rev_id >> 8 == 358464U) {
    u32 scale;
    u32 tmp;
    u32 tmp_0;
    
#line 6074 
    tmp = (*(tp->read32))(tp,13872U);
    
#line 6074 
    val = tmp & 2031616U;
    
#line 6075 
    if (val == 0U) 
#line 6076 
                   scale = 65U;
    else 
      
#line 6077 
      if (val == 1245184U) 
#line 6078 
                           scale = 6U; else 
#line 6080 
                                            scale = 12U;
    
#line 6082 
    tmp_0 = (*(tp->read32))(tp,26628U);
    
#line 6082 
    val = tmp_0 & 4294967041U;
    
#line 6083 
    val = (scale << 1) | val;
    
#line 6084 
    (*(tp->write32))(tp,26628U,val);
  }
  else ;
  
#line 6087 
  val = 9728U;
  
#line 6089 
  if (tp->pci_chip_rev_id >> 12 == 22304U || tp->pci_chip_rev_id >> 12 == 22370U) {
    u32 tmp_1;
    
#line 6091 
    tmp_1 = (*(tp->read32))(tp,1124U);
    
#line 6093 
    val = (tmp_1 & 4294901760U) | val;
  }
  else ;
  
#line 6095 
  if ((unsigned int)tp->link_config.active_speed == 1000U && (unsigned int)tp->link_config.active_duplex == 0U) 
    
#line 6097 
    (*(tp->write32))(tp,1124U,val | 255U); else 
#line 6100 
                                                (*(tp->write32))(tp,1124U,val | 32U);
  
#line 6103 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 6103 
  if (tmp_2 == 0) 
    
#line 6104 
    if ((int)tp->link_up != 0) 
#line 6105 
                               (*(tp->write32))(tp,15400U,tp->coal.stats_block_coalesce_usecs); else 
                                                                    
#line 6108 
                                                                    (*(tp->write32))(tp,15400U,0U);
  else ;
  
#line 6112 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ASPM_WORKAROUND,(unsigned long *)(& tp->tg3_flags));
  
#line 6112 
  if (tmp_3 != 0) {
    
#line 6113 
    val = (*(tp->read32))(tp,32040U);
    
#line 6114 
    if (! tp->link_up) 
#line 6115 
                       val = (val & 4294902015U) | tp->pwrmgmt_thresh; else 
                                                                    
#line 6118 
                                                                    val |= 65280U;
    
#line 6119 
    (*(tp->write32))(tp,32040U,val);
  }
  else ;
  
#line 6122 
  return err;
}


#line 6126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u64 tg3_refclk_read(struct tg3 *tp)
{
  u64 __retres;
  u32 tmp;
  u32 tmp_0;
  
#line 6128 
  tmp = (*(tp->read32))(tp,26880U);
  
#line 6128 
  u64 stamp = (unsigned long long)tmp;
  
#line 6129 
  tmp_0 = (*(tp->read32))(tp,26884U);
  
#line 6129 
  ;
  
#line 6129 
  __retres = ((unsigned long long)tmp_0 << 32) | stamp;
  
#line 6129 
  return __retres;
}


#line 6133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_refclk_write(struct tg3 *tp, u64 newval)
{
  u32 tmp;
  
#line 6135 
  tmp = (*(tp->read32))(tp,26888U);
  
#line 6135 
  u32 clock_ctl = tmp;
  
#line 6137 
  (*(tp->write32))(tp,26888U,clock_ctl | 2U);
  
#line 6138 
  (*(tp->write32))(tp,26880U,(unsigned int)newval);
  
#line 6139 
  (*(tp->write32))(tp,26884U,(unsigned int)(newval >> 32));
  
#line 6140 
  _tw32_flush(tp,26888U,clock_ctl | 4U,0U);
  
#line 6141 
  return;
}


#line 6143 
static void tg3_full_lock(struct tg3 *tp, int irq_sync);


#line 6144 
static void tg3_full_unlock(struct tg3 *tp);


#line 6145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
{
  int __retres;
  int tmp_0;
  
#line 6147 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 6149 
  info->so_timestamping = 26U;
  
#line 6153 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 6153 
  if (tmp_0 != 0) 
#line 6154 
                  info->so_timestamping |= 69U; else ;
  
#line 6159 
  if (tp->ptp_clock != (struct ptp_clock *)0) 
#line 6160 
                                              info->phc_index = ptp_clock_index(tp->ptp_clock); else 
                                                                    
#line 6162 
                                                                    info->phc_index = -1;
  
#line 6164 
  info->tx_types = 3U;
  
#line 6166 
  info->rx_filters = 585U;
  
#line 6170 
  __retres = 0;
  
#line 6170 
  return __retres;
}


#line 6173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
{
  int __retres;
  struct tg3 *tmp;
  u64 tmp_0;
  {
    
#line 6175 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 6175 
    tmp = (struct tg3 *)__mptr + 18446744073709551392U;
  }
  
#line 6175 
  struct tg3 *tp = tmp;
  
#line 6176 
  bool neg_adj = (_Bool)0;
  
#line 6177 
  u32 correction = 0U;
  
#line 6179 
  if (ppb < 0) {
    
#line 6180 
    neg_adj = (_Bool)1;
    
#line 6181 
    ppb = - ppb;
  }
  else ;
  
#line 6192 
  tmp_0 = div_u64((unsigned long long)ppb * 16777216ULL,1000000000U);
  
#line 6192 
  correction = (unsigned int)tmp_0 & 16777215U;
  
#line 6195 
  tg3_full_lock(tp,0);
  
#line 6197 
  if (correction != 0U) {
    unsigned int tmp_1;
    
#line 6198 
    if ((int)neg_adj != 0) 
#line 6198 
                           tmp_1 = (unsigned int)(-1073741824); else 
                                                                  
#line 6198 
                                                                  tmp_1 = -2147483648;
    
#line 6198 
    ;
    
#line 6198 
    ;
    
#line 6198 
    (*(tp->write32))(tp,26920U,tmp_1 | correction);
  }
  else 
#line 6202 
       (*(tp->write32))(tp,26920U,0U);
  
#line 6204 
  tg3_full_unlock(tp);
  
#line 6206 
  __retres = 0;
  
#line 6206 
  return __retres;
}


#line 6209  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
  int __retres;
  struct tg3 *tmp;
  {
    
#line 6211 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 6211 
    tmp = (struct tg3 *)__mptr + 18446744073709551392U;
  }
  
#line 6211 
  struct tg3 *tp = tmp;
  
#line 6213 
  tg3_full_lock(tp,0);
  
#line 6214 
  tp->ptp_adjust += delta;
  
#line 6215 
  tg3_full_unlock(tp);
  
#line 6217 
  __retres = 0;
  
#line 6217 
  return __retres;
}


#line 6220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ptp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)
{
  int __retres;
  u64 ns;
  struct tg3 *tmp;
  {
    
#line 6223 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 6223 
    tmp = (struct tg3 *)__mptr + 18446744073709551392U;
  }
  
#line 6223 
  struct tg3 *tp = tmp;
  
#line 6225 
  tg3_full_lock(tp,0);
  
#line 6226 
  ns = tg3_refclk_read(tp);
  
#line 6227 
  ns = (unsigned long long)tp->ptp_adjust + ns;
  
#line 6228 
  tg3_full_unlock(tp);
  
#line 6230 
  *ts = ns_to_timespec((long long)ns);
  
#line 6232 
  __retres = 0;
  
#line 6232 
  return __retres;
}


#line 6235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ptp_settime(struct ptp_clock_info *ptp, struct timespec const *ts)
{
  int __retres;
  u64 ns;
  struct tg3 *tmp;
  s64 tmp_0;
  {
    
#line 6239 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 6239 
    tmp = (struct tg3 *)__mptr + 18446744073709551392U;
  }
  
#line 6239 
  struct tg3 *tp = tmp;
  
#line 6241 
  tmp_0 = timespec_to_ns(ts);
  
#line 6241 
  ns = (unsigned long long)tmp_0;
  
#line 6243 
  tg3_full_lock(tp,0);
  
#line 6244 
  tg3_refclk_write(tp,ns);
  
#line 6245 
  tp->ptp_adjust = 0LL;
  
#line 6246 
  tg3_full_unlock(tp);
  
#line 6248 
  __retres = 0;
  
#line 6248 
  return __retres;
}


#line 6251  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ptp_enable(struct ptp_clock_info *ptp, struct ptp_clock_request *rq, int on)
{
  int __retres;
  struct tg3 *tmp;
  u32 clock_ctl;
  {
    
#line 6254 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 6254 
    tmp = (struct tg3 *)__mptr + 18446744073709551392U;
  }
  
#line 6254 
  struct tg3 *tp = tmp;
  
#line 6256 
  int rval = 0;
  
#line 6258 
  switch ((unsigned int)rq->type) {
    case (unsigned int)1: 
#line 6259 
    ;
    
#line 6260 
    if (rq->__anonCompField_ptp_clock_request_117.perout.index != 0U) {
      
#line 6261 
      __retres = -22;
      
#line 6261 
      goto return_label;
    }
    else ;
    
#line 6263 
    tg3_full_lock(tp,0);
    
#line 6264 
    clock_ctl = (*(tp->read32))(tp,26888U);
    
#line 6265 
    clock_ctl &= 4294770687U;
    
#line 6267 
    if (on != 0) {
      u64 nsec;
      
#line 6270 
      nsec = (unsigned long long)rq->__anonCompField_ptp_clock_request_117.perout.start.sec * 1000000000ULL + (unsigned long long)rq->__anonCompField_ptp_clock_request_117.perout.start.nsec;
      
#line 6273 
      if (rq->__anonCompField_ptp_clock_request_117.perout.period.sec != 0LL || rq->__anonCompField_ptp_clock_request_117.perout.period.nsec != 0U) {
        
#line 6274 
        netdev_warn((struct net_device const *)tp->dev,"Device supports only a one-shot timesync output, period must be 0\n");
        
#line 6276 
        rval = -22;
        
#line 6277 
        goto err_out;
      }
      else ;
      
#line 6280 
      if (nsec < (u64)0) {
        
#line 6281 
        netdev_warn((struct net_device const *)tp->dev,"Start value (nsec) is over limit. Maximum size of start is only 63 bits\n");
        
#line 6283 
        rval = -22;
        
#line 6284 
        goto err_out;
      }
      else ;
      
#line 6287 
      (*(tp->write32))(tp,26904U,(unsigned int)nsec);
      
#line 6288 
      (*(tp->write32))(tp,26908U,(unsigned int)(nsec >> 32) | 2147483648U);
      
#line 6292 
      (*(tp->write32))(tp,26888U,clock_ctl | 131072U);
    }
    else {
      
#line 6295 
      (*(tp->write32))(tp,26908U,0U);
      
#line 6296 
      (*(tp->write32))(tp,26888U,clock_ctl);
    }
    err_out: 
#line 6299 
    ;
    
#line 6300 
    tg3_full_unlock(tp);
    
#line 6301 
    __retres = rval;
    
#line 6301 
    goto return_label;
    default: 
#line 6303 
    ;
    
#line 6304 
    goto ldv_57123;
  }
  ldv_57123: 
#line 6307 
  ;
  
#line 6307 
  __retres = -95;
  return_label: 
#line 6307 
                return __retres;
}


#line 6310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct ptp_clock_info const tg3_ptp_caps = {.owner = & __this_module, .name = {(char)'t', (char)'g', (char)'3', (char)' ', (char)'c', (char)'l', (char)'o', (char)'c', (char)'k', (char)'\000'}, .max_adj = 250000000, .n_alarm = 0, .n_ext_ts = 0, .n_per_out = 1, .n_pins = 0, .pps = 0, .pin_config = (struct ptp_pin_desc *)0, .adjfreq = & tg3_ptp_adjfreq, .adjtime = & tg3_ptp_adjtime, .gettime64 = & tg3_ptp_gettime, .settime64 = & tg3_ptp_settime, .enable = & tg3_ptp_enable, .verify = (int (*)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ))0};

#line 6326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_hwclock_to_timestamp(struct tg3 *tp, u64 hwclock, struct skb_shared_hwtstamps *timestamp)
{
  
#line 6329 
  memset((void *)timestamp,0,8UL);
  
#line 6330 
  timestamp->hwtstamp = ns_to_ktime((hwclock & 9223372036854775807ULL) + (unsigned long long)tp->ptp_adjust);
  
#line 6332 
  return;
}


#line 6335  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ptp_init(struct tg3 *tp)
{
  int tmp;
  ktime_t tmp_0;
  
#line 6337 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 6337 
  if (tmp == 0) 
#line 6338 
                goto return_label; else ;
  
#line 6341 
  tmp_0 = ktime_get_real();
  
#line 6341 
  ;
  
#line 6341 
  tg3_refclk_write(tp,(unsigned long long)tmp_0.tv64);
  
#line 6342 
  tp->ptp_adjust = 0LL;
  
#line 6343 
  tp->ptp_info = tg3_ptp_caps;
  return_label: 
#line 6344 
                return;
}


#line 6347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ptp_resume(struct tg3 *tp)
{
  int tmp;
  ktime_t tmp_0;
  
#line 6349 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 6349 
  if (tmp == 0) 
#line 6350 
                goto return_label; else ;
  
#line 6352 
  tmp_0 = ktime_get_real();
  
#line 6352 
  ;
  
#line 6352 
  ;
  
#line 6352 
  tg3_refclk_write(tp,(unsigned long long)(tmp_0.tv64 + tp->ptp_adjust));
  
#line 6353 
  tp->ptp_adjust = 0LL;
  return_label: 
#line 6354 
                return;
}


#line 6356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ptp_fini(struct tg3 *tp)
{
  int tmp;
  
#line 6358 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 6358 
  if (tmp == 0) 
#line 6359 
                goto return_label;
  else 
    
#line 6358 
    if (tp->ptp_clock == (struct ptp_clock *)0) 
#line 6359 
                                                goto return_label; else ;
  
#line 6361 
  ptp_clock_unregister(tp->ptp_clock);
  
#line 6362 
  tp->ptp_clock = (struct ptp_clock *)0;
  
#line 6363 
  tp->ptp_adjust = 0LL;
  return_label: 
#line 6364 
                return;
}


#line 6366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static int tg3_irq_sync(struct tg3 *tp)
{
  int __retres;
  
#line 6368 
  __retres = (int)tp->irq_sync;
  
#line 6368 
  return __retres;
}


#line 6371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tg3_rd32_loop(struct tg3 *tp, u32 *dst, u32 off, u32 len)
{
  int i;
  u32 *tmp;
  
#line 6375 
  dst += off;
  
#line 6376 
  i = 0;
  
#line 6376 
  goto ldv_57150;
  ldv_57149: 
#line 6377 
  ;
  
#line 6377 
  tmp = dst;
  
#line 6377 
  dst += 1;
  
#line 6377 
  *tmp = (*(tp->read32))(tp,off + (unsigned int)i);
  
#line 6376 
  i = (int)((unsigned int)i + 4U);
  ldv_57150: 
#line 6377 
  ;
  
#line 6376 
  if ((unsigned int)i < len) 
#line 6378 
                             goto ldv_57149; else 
#line 6381 
                                                  goto ldv_57151;
  ldv_57151: 
#line 6382 
  ;
  
#line 6383 
  return;
}


#line 6380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_dump_legacy_regs(struct tg3 *tp, u32 *regs)
{
  int tmp;
  int tmp_0;
  int tmp_1;
  
#line 6382 
  tg3_rd32_loop(tp,regs,0U,176U);
  
#line 6383 
  tg3_rd32_loop(tp,regs,512U,512U);
  
#line 6384 
  tg3_rd32_loop(tp,regs,1024U,1264U);
  
#line 6385 
  tg3_rd32_loop(tp,regs,3072U,224U);
  
#line 6386 
  tg3_rd32_loop(tp,regs,4096U,4U);
  
#line 6387 
  tg3_rd32_loop(tp,regs,5120U,128U);
  
#line 6388 
  tg3_rd32_loop(tp,regs,6144U,72U);
  
#line 6389 
  tg3_rd32_loop(tp,regs,7168U,4U);
  
#line 6390 
  tg3_rd32_loop(tp,regs,8192U,32U);
  
#line 6391 
  tg3_rd32_loop(tp,regs,8448U,348U);
  
#line 6392 
  tg3_rd32_loop(tp,regs,9216U,12U);
  
#line 6393 
  tg3_rd32_loop(tp,regs,9280U,60U);
  
#line 6394 
  tg3_rd32_loop(tp,regs,9344U,68U);
  
#line 6395 
  tg3_rd32_loop(tp,regs,10240U,4U);
  
#line 6396 
  tg3_rd32_loop(tp,regs,11264U,32U);
  
#line 6397 
  tg3_rd32_loop(tp,regs,12288U,20U);
  
#line 6398 
  tg3_rd32_loop(tp,regs,13312U,8U);
  
#line 6399 
  tg3_rd32_loop(tp,regs,14336U,8U);
  
#line 6400 
  tg3_rd32_loop(tp,regs,15360U,256U);
  
#line 6402 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 6402 
  if (tmp != 0) 
#line 6403 
                tg3_rd32_loop(tp,regs,15744U,384U); else ;
  
#line 6405 
  tg3_rd32_loop(tp,regs,16384U,16U);
  
#line 6406 
  tg3_rd32_loop(tp,regs,17408U,88U);
  
#line 6407 
  tg3_rd32_loop(tp,regs,18432U,8U);
  
#line 6408 
  tg3_rd32_loop(tp,regs,19456U,8U);
  
#line 6409 
  tg3_rd32_loop(tp,regs,20480U,4U);
  
#line 6410 
  tg3_rd32_loop(tp,regs,20484U,4U);
  
#line 6411 
  tg3_rd32_loop(tp,regs,20508U,4U);
  
#line 6412 
  tg3_rd32_loop(tp,regs,20532U,4U);
  
#line 6414 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 6414 
  if (tmp_0 == 0) {
    
#line 6415 
    tg3_rd32_loop(tp,regs,21504U,4U);
    
#line 6416 
    tg3_rd32_loop(tp,regs,21508U,4U);
    
#line 6417 
    tg3_rd32_loop(tp,regs,21532U,4U);
  }
  else ;
  
#line 6420 
  tg3_rd32_loop(tp,regs,22528U,272U);
  
#line 6421 
  tg3_rd32_loop(tp,regs,23552U,288U);
  
#line 6422 
  tg3_rd32_loop(tp,regs,24576U,12U);
  
#line 6423 
  tg3_rd32_loop(tp,regs,25600U,4U);
  
#line 6424 
  tg3_rd32_loop(tp,regs,26624U,76U);
  
#line 6426 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 6426 
  if (tmp_1 != 0) 
#line 6427 
                  tg3_rd32_loop(tp,regs,28672U,36U); else ;
  
#line 6428 
  return;
}


#line 6430  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_dump_state(struct tg3 *tp)
{
  int i;
  u32 *regs;
  int tmp_0;
  
#line 6435 
  regs = (u32 *)kzalloc(32768UL,32U);
  
#line 6436 
  if (regs == (u32 *)0U) 
#line 6437 
                         goto return_label; else ;
  
#line 6439 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
  
#line 6439 
  if (tmp_0 != 0) {
    
#line 6441 
    i = 0;
    
#line 6441 
    goto ldv_57162;
    ldv_57161: 
#line 6442 
    ;
    
#line 6442 
    *(regs + (unsigned long)i / 4UL) = (*(tp->read32))(tp,(unsigned int)i);
    
#line 6441 
    i = (int)((unsigned int)i + 4U);
    ldv_57162: 
#line 6442 
    ;
    
#line 6441 
    if (i <= 31743) 
#line 6443 
                    goto ldv_57161; else 
#line 6446 
                                         goto ldv_57163;
    ldv_57163: 
#line 6447 
    ;
  }
  else 
#line 6444 
       tg3_dump_legacy_regs(tp,regs);
  
#line 6446 
  i = 0;
  
#line 6446 
  goto ldv_57166;
  ldv_57165: 
#line 6447 
  ;
  
#line 6447 
  if (((*(regs + i) == 0U && *(regs + ((unsigned int)i + 1U)) == 0U) && *(regs + ((unsigned int)i + 2U)) == 0U) && *(regs + ((unsigned int)i + 3U)) == 0U) 
    
#line 6449 
    goto ldv_57164; else ;
  
#line 6451 
  netdev_err((struct net_device const *)tp->dev,"0x%08x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",i * 4,*(regs + i),*(regs + ((unsigned int)i + 1U)),*(regs + ((unsigned int)i + 2U)),*(regs + ((unsigned int)i + 3U)));
  ldv_57164: 
#line 6454 
  ;
  
#line 6446 
  i += 4;
  ldv_57166: 
#line 6447 
  ;
  
#line 6446 
  if ((unsigned int)i <= 8191U) 
#line 6448 
                                goto ldv_57165; else 
#line 6451 
                                                     goto ldv_57167;
  ldv_57167: 
#line 6452 
  ;
  
#line 6456 
  kfree((void const *)regs);
  
#line 6458 
  i = 0;
  
#line 6458 
  goto ldv_57170;
  ldv_57169: 
#line 6459 
  ;
  {
    
#line 6459 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 6462 
    netdev_err((struct net_device const *)tp->dev,"%d: Host status block [%08x:%08x:(%04x:%04x:%04x):(%04x:%04x)]\n",i,(tnapi->hw_status)->status,(tnapi->hw_status)->status_tag,(int)(tnapi->hw_status)->rx_jumbo_consumer,(int)(tnapi->hw_status)->rx_consumer,(int)(tnapi->hw_status)->rx_mini_consumer,(int)(tnapi->hw_status)->idx[0].rx_producer,(int)(tnapi->hw_status)->idx[0].tx_consumer);
    
#line 6473 
    netdev_err((struct net_device const *)tp->dev,"%d: NAPI info [%08x:%08x:(%04x:%04x:%04x):%04x:(%04x:%04x:%04x:%04x)]\n",i,tnapi->last_tag,tnapi->last_irq_tag,tnapi->tx_prod,tnapi->tx_cons,tnapi->tx_pending,tnapi->rx_rcb_ptr,tnapi->prodring.rx_std_prod_idx,tnapi->prodring.rx_std_cons_idx,tnapi->prodring.rx_jmb_prod_idx,tnapi->prodring.rx_jmb_cons_idx);
  }
  
#line 6458 
  i += 1;
  ldv_57170: 
#line 6459 
  ;
  
#line 6458 
  if (tp->irq_cnt > (unsigned int)i) 
#line 6460 
                                     goto ldv_57169; else 
#line 6463 
                                                          goto ldv_57171;
  ldv_57171: 
#line 6464 
  ;
  return_label: 
#line 6465 
                return;
}


#line 6492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_tx_recover(struct tg3 *tp)
{
  int tmp;
  
#line 6494 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MBOX_WRITE_REORDER,(unsigned long *)(& tp->tg3_flags));
  
#line 6494 
  if ((long)(tmp != 0) != 0L) 
#line 6494 
                              goto _LOR;
  else 
    
#line 6494 
    if ((long)(tp->write32_tx_mbox == & tg3_write_indirect_mbox) != 0L) {
      _LOR: {
              
#line 6496 
              ldv_inline_asm();
              
#line 6494 
              ;
            }
    }
    else ;
  
#line 6497 
  netdev_warn((struct net_device const *)tp->dev,"The system may be re-ordering memory-mapped I/O ");
  
#line 6503 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TX_RECOVERY_PENDING,(unsigned long *)(& tp->tg3_flags));
  
#line 6504 
  return;
}


#line 6506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static u32 tg3_tx_avail(struct tg3_napi *tnapi)
{
  u32 __retres;
  
#line 6508 
  ldv_inline_asm();
  
#line 6510 
  __retres = tnapi->tx_pending - ((tnapi->tx_prod - tnapi->tx_cons) & 511U);
  
#line 6510 
  return __retres;
}


#line 6518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_tx(struct tg3_napi *tnapi)
{
  struct netdev_queue *txq;
  int tmp;
  bool tmp_13;
  
#line 6520 
  struct tg3 *tp = tnapi->tp;
  
#line 6521 
  u32 hw_idx = (unsigned int)(tnapi->hw_status)->idx[0].tx_consumer;
  
#line 6522 
  u32 sw_idx = tnapi->tx_cons;
  
#line 6524 
  int index = (int)(((long)tnapi - (long)(& tp->napi)) / 576L);
  
#line 6525 
  unsigned int pkts_compl = 0U;
  
#line 6525 
  unsigned int bytes_compl = 0U;
  
#line 6527 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
  
#line 6527 
  if (tmp != 0) 
#line 6528 
                index -= 1; else ;
  
#line 6530 
  txq = netdev_get_tx_queue((struct net_device const *)tp->dev,(unsigned int)index);
  
#line 6532 
  goto ldv_57204;
  ldv_57203: 
#line 6533 
  ;
  {
    int i;
    unsigned int tmp_2;
    unsigned int tmp_4;
    unsigned char *tmp_3;
    unsigned char *tmp_5;
    
#line 6533 
    struct tg3_tx_ring_info *ri = tnapi->tx_buffers + sw_idx;
    
#line 6534 
    struct sk_buff *skb = ri->skb;
    
#line 6535 
    int tx_bug = 0;
    
#line 6537 
    if ((long)(skb == (struct sk_buff *)0) != 0L) {
      
#line 6538 
      tg3_tx_recover(tp);
      
#line 6539 
      goto return_label;
    }
    else ;
    
#line 6542 
    if (((tnapi->tx_ring + sw_idx)->len_flags & 32U) != 0U) {
      struct skb_shared_hwtstamps timestamp;
      u32 tmp_0;
      u32 tmp_1;
      
#line 6544 
      tmp_0 = (*(tp->read32))(tp,1472U);
      
#line 6544 
      u64 hwclock = (unsigned long long)tmp_0;
      
#line 6545 
      tmp_1 = (*(tp->read32))(tp,1476U);
      
#line 6545 
      hwclock = ((unsigned long long)tmp_1 << 32) | hwclock;
      
#line 6547 
      tg3_hwclock_to_timestamp(tp,hwclock,& timestamp);
      
#line 6549 
      skb_tstamp_tx(skb,& timestamp);
    }
    else ;
    
#line 6554 
    tmp_2 = skb_headlen((struct sk_buff const *)skb);
    
#line 6552 
    ;
    
#line 6552 
    ;
    
#line 6552 
    pci_unmap_single(tp->pdev,ri->mapping,(unsigned long)tmp_2,1);
    
#line 6557 
    ri->skb = (struct sk_buff *)0;
    
#line 6559 
    goto ldv_57195;
    ldv_57194: 
#line 6560 
    ;
    
#line 6560 
    ri->fragmented = (_Bool)0;
    
#line 6561 
    sw_idx = (sw_idx + 1U) & 511U;
    
#line 6562 
    ri = tnapi->tx_buffers + sw_idx;
    ldv_57195: 
#line 6563 
    ;
    
#line 6559 
    if ((int)ri->fragmented != 0) 
#line 6561 
                                  goto ldv_57194; else 
#line 6564 
                                                       goto ldv_57196;
    ldv_57196: 
#line 6565 
    ;
    
#line 6565 
    sw_idx = (sw_idx + 1U) & 511U;
    
#line 6567 
    i = 0;
    
#line 6567 
    goto ldv_57201;
    ldv_57200: 
#line 6568 
    ;
    
#line 6568 
    ri = tnapi->tx_buffers + sw_idx;
    
#line 6569 
    if ((long)(ri->skb != (struct sk_buff *)0) != 0L || (long)(sw_idx == hw_idx) != 0L) 
      
#line 6570 
      tx_bug = 1; else ;
    
#line 6574 
    tmp_3 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 6574 
    tmp_4 = skb_frag_size((skb_frag_t const *)(& ((struct skb_shared_info *)tmp_3)->frags[i]));
    
#line 6572 
    ;
    
#line 6572 
    ;
    
#line 6572 
    pci_unmap_page(tp->pdev,ri->mapping,(unsigned long)tmp_4,1);
    
#line 6577 
    goto ldv_57198;
    ldv_57197: 
#line 6578 
    ;
    
#line 6578 
    ri->fragmented = (_Bool)0;
    
#line 6579 
    sw_idx = (sw_idx + 1U) & 511U;
    
#line 6580 
    ri = tnapi->tx_buffers + sw_idx;
    ldv_57198: 
#line 6581 
    ;
    
#line 6577 
    if ((int)ri->fragmented != 0) 
#line 6579 
                                  goto ldv_57197; else 
#line 6582 
                                                       goto ldv_57199;
    ldv_57199: 
#line 6583 
    ;
    
#line 6583 
    sw_idx = (sw_idx + 1U) & 511U;
    
#line 6567 
    i += 1;
    ldv_57201: 
#line 6568 
    ;
    
#line 6567 
    tmp_5 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 6567 
    ;
    
#line 6567 
    if ((int)((struct skb_shared_info *)tmp_5)->nr_frags > i) 
#line 6569 
                                                              goto ldv_57200; else 
                                                                    
#line 6572 
                                                                    goto ldv_57202;
    ldv_57202: 
#line 6573 
    ;
    
#line 6586 
    pkts_compl += 1U;
    
#line 6587 
    bytes_compl = skb->len + bytes_compl;
    
#line 6589 
    dev_kfree_skb_any(skb);
    
#line 6591 
    if ((long)(tx_bug != 0) != 0L) {
      
#line 6592 
      tg3_tx_recover(tp);
      
#line 6593 
      goto return_label;
    }
    else ;
  }
  ldv_57204: 
#line 6596 
  ;
  
#line 6532 
  if (sw_idx != hw_idx) 
#line 6534 
                        goto ldv_57203; else 
#line 6537 
                                             goto ldv_57205;
  ldv_57205: 
#line 6538 
  ;
  
#line 6597 
  netdev_tx_completed_queue(txq,pkts_compl,bytes_compl);
  
#line 6599 
  tnapi->tx_cons = sw_idx;
  
#line 6600 
  ldv_inline_asm();
  
#line 6608 
  tmp_13 = netif_tx_queue_stopped((struct netdev_queue const *)txq);
  
#line 6608 
  if ((long)((int)tmp_13 != 0) != 0L) {
    u32 tmp_14;
    
#line 6608 
    tmp_14 = tg3_tx_avail(tnapi);
    
#line 6608 
    ;
    
#line 6608 
    if ((long)(tmp_14 > tnapi->tx_pending / 4U) != 0L) {
      int tmp_10;
      bool tmp_11;
      {
        int pscr_ret__;
        {
          
#line 6610 
          void const *__vpp_verify = (void const *)0;
          
#line 6610 
          void const *tmp_6 = __vpp_verify;
        }
        
#line 6610 
        switch (4UL) {
          int tmp_6_0;
          int tmp_7;
          int tmp_8;
          int tmp_9;
          case (unsigned long)1: 
#line 6610 
          ;
          {
            int pfo_ret__;
            
#line 6610 
            switch (4UL) {
              case (unsigned long)1: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57211;
              case (unsigned long)2: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57211;
              case (unsigned long)4: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57211;
              case (unsigned long)8: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57211;
              default: 
#line 6610 
              ;
              
#line 6610 
              __bad_percpu_size();
            }
            ldv_57211: 
#line 6610 
            ;
            
#line 6610 
            tmp_6_0 = pfo_ret__;
          }
          
#line 6610 
          pscr_ret__ = tmp_6_0;
          
#line 6610 
          goto ldv_57217;
          case (unsigned long)2: 
#line 6610 
          ;
          {
            int pfo_ret___0;
            
#line 6610 
            switch (4UL) {
              case (unsigned long)1: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57221;
              case (unsigned long)2: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57221;
              case (unsigned long)4: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57221;
              case (unsigned long)8: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57221;
              default: 
#line 6610 
              ;
              
#line 6610 
              __bad_percpu_size();
            }
            ldv_57221: 
#line 6610 
            ;
            
#line 6610 
            tmp_7 = pfo_ret___0;
          }
          
#line 6610 
          pscr_ret__ = tmp_7;
          
#line 6610 
          goto ldv_57217;
          case (unsigned long)4: 
#line 6610 
          ;
          {
            int pfo_ret___1;
            
#line 6610 
            switch (4UL) {
              case (unsigned long)1: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57230;
              case (unsigned long)2: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57230;
              case (unsigned long)4: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57230;
              case (unsigned long)8: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57230;
              default: 
#line 6610 
              ;
              
#line 6610 
              __bad_percpu_size();
            }
            ldv_57230: 
#line 6610 
            ;
            
#line 6610 
            tmp_8 = pfo_ret___1;
          }
          
#line 6610 
          pscr_ret__ = tmp_8;
          
#line 6610 
          goto ldv_57217;
          case (unsigned long)8: 
#line 6610 
          ;
          {
            int pfo_ret___2;
            
#line 6610 
            switch (4UL) {
              case (unsigned long)1: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57239;
              case (unsigned long)2: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57239;
              case (unsigned long)4: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57239;
              case (unsigned long)8: 
#line 6610 
              ;
              
#line 6611 
              ldv_inline_asm();
              
#line 6610 
              goto ldv_57239;
              default: 
#line 6610 
              ;
              
#line 6610 
              __bad_percpu_size();
            }
            ldv_57239: 
#line 6610 
            ;
            
#line 6610 
            tmp_9 = pfo_ret___2;
          }
          
#line 6610 
          pscr_ret__ = tmp_9;
          
#line 6610 
          goto ldv_57217;
          default: 
#line 6610 
          ;
          
#line 6610 
          __bad_size_call_parameter();
          
#line 6610 
          goto ldv_57217;
        }
        ldv_57217: 
#line 6610 
        ;
        
#line 6610 
        tmp_10 = pscr_ret__;
      }
      
#line 6610 
      ;
      
#line 6610 
      __netif_tx_lock(txq,tmp_10);
      
#line 6611 
      tmp_11 = netif_tx_queue_stopped((struct netdev_queue const *)txq);
      
#line 6611 
      if ((int)tmp_11 != 0) {
        u32 tmp_12;
        
#line 6611 
        tmp_12 = tg3_tx_avail(tnapi);
        
#line 6611 
        ;
        
#line 6611 
        if (tmp_12 > tnapi->tx_pending / 4U) 
#line 6613 
                                             netif_tx_wake_queue(txq); else ;
      }
      else ;
      
#line 6614 
      __netif_tx_unlock(txq);
    }
    else ;
  }
  else ;
  return_label: 
#line 6616 
                return;
}


#line 6618  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_frag_free(bool is_frag, void *data)
{
  
#line 6620 
  if ((int)is_frag != 0) 
#line 6621 
                         skb_free_frag(data); else 
#line 6623 
                                                   kfree((void const *)data);
  
#line 6624 
  return;
}


#line 6626  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rx_data_free(struct tg3 *tp, struct ring_info *ri, u32 map_sz)
{
  int tmp_0;
  {
    int tmp;
    
#line 6628 
    int _max1 = 32;
    
#line 6628 
    int _max2 = 64;
    
#line 6628 
    if (_max1 > _max2) 
#line 6628 
                       tmp = _max1; else 
#line 6628 
                                         tmp = _max2;
    
#line 6628 
    tmp_0 = tmp;
  }
  
#line 6628 
  unsigned int skb_size = ((((unsigned int)tmp_0 + map_sz) + 63U) & 4294967232U) + 320U;
  
#line 6631 
  if (ri->data == (u8 *)0U) 
#line 6632 
                            goto return_label; else ;
  
#line 6634 
  pci_unmap_single(tp->pdev,ri->mapping,(unsigned long)map_sz,2);
  
#line 6636 
  tg3_frag_free((_Bool)(skb_size <= 4096U),(void *)ri->data);
  
#line 6637 
  ri->data = (u8 *)0U;
  return_label: 
#line 6638 
                return;
}


#line 6652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_alloc_rx_data(struct tg3 *tp, struct tg3_rx_prodring_set *tpr, u32 opaque_key, u32 dest_idx_unmasked, unsigned int *frag_size)
{
  int __retres;
  struct tg3_rx_buffer_desc *desc;
  struct ring_info *map;
  u8 *data;
  dma_addr_t mapping;
  int skb_size;
  int data_size;
  int dest_idx;
  int tmp_0;
  int tmp_4;
  int tmp_5;
  
#line 6662 
  switch (opaque_key) {
    case (u32)65536: 
#line 6663 
    ;
    
#line 6664 
    dest_idx = (int)(tp->rx_std_ring_mask & dest_idx_unmasked);
    
#line 6665 
    desc = tpr->rx_std + dest_idx;
    
#line 6666 
    map = tpr->rx_std_buffers + dest_idx;
    
#line 6667 
    data_size = (int)tp->rx_pkt_map_sz;
    
#line 6668 
    goto ldv_57281;
    case (u32)131072: 
#line 6670 
    ;
    
#line 6671 
    dest_idx = (int)(tp->rx_jmb_ring_mask & dest_idx_unmasked);
    
#line 6672 
    desc = & (tpr->rx_jmb + dest_idx)->std;
    
#line 6673 
    map = tpr->rx_jmb_buffers + dest_idx;
    
#line 6674 
    data_size = 9110;
    
#line 6675 
    goto ldv_57281;
    default: 
#line 6677 
    ;
    
#line 6678 
    __retres = -22;
    
#line 6678 
    goto return_label;
  }
  ldv_57281: 
#line 6687 
  ;
  {
    int tmp;
    
#line 6687 
    int _max1 = 32;
    
#line 6687 
    int _max2 = 64;
    
#line 6687 
    if (_max1 > _max2) 
#line 6687 
                       tmp = _max1; else 
#line 6687 
                                         tmp = _max2;
    
#line 6687 
    tmp_0 = tmp;
  }
  
#line 6687 
  skb_size = (int)(((unsigned int)((tmp_0 + data_size) + 63) & 4294967232U) + 320U);
  
#line 6689 
  if ((unsigned int)skb_size <= 4096U) {
    
#line 6690 
    data = (u8 *)netdev_alloc_frag((unsigned int)skb_size);
    
#line 6691 
    *frag_size = (unsigned int)skb_size;
  }
  else {
    
#line 6693 
    data = (u8 *)kmalloc((unsigned long)skb_size,32U);
    
#line 6694 
    *frag_size = 0U;
  }
  
#line 6696 
  if (data == (u8 *)0U) {
    
#line 6697 
    __retres = -12;
    
#line 6697 
    goto return_label;
  }
  else ;
  
#line 6699 
  ;
  {
    int tmp_3;
    
#line 6700 
    int _max1_0 = 32;
    
#line 6700 
    int _max2_0 = 64;
    
#line 6700 
    if (_max1_0 > _max2_0) 
#line 6700 
                           tmp_3 = _max1_0; else 
#line 6700 
                                                 tmp_3 = _max2_0;
    
#line 6700 
    tmp_4 = tmp_3;
  }
  
#line 6699 
  ;
  
#line 6699 
  ;
  
#line 6699 
  mapping = pci_map_single(tp->pdev,(void *)(data + tmp_4),(unsigned long)data_size,2);
  
#line 6703 
  tmp_5 = pci_dma_mapping_error(tp->pdev,mapping);
  
#line 6703 
  if ((long)(tmp_5 != 0) != 0L) {
    
#line 6704 
    tg3_frag_free((_Bool)((unsigned int)skb_size <= 4096U),(void *)data);
    
#line 6705 
    __retres = -5;
    
#line 6705 
    goto return_label;
  }
  else ;
  
#line 6708 
  map->data = data;
  
#line 6709 
  map->mapping = mapping;
  
#line 6711 
  desc->addr_hi = (unsigned int)(mapping >> 32);
  
#line 6712 
  desc->addr_lo = (unsigned int)mapping;
  
#line 6714 
  __retres = data_size;
  return_label: 
#line 6714 
                return __retres;
}


#line 6721  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_recycle_rx(struct tg3_napi *tnapi, struct tg3_rx_prodring_set *dpr, u32 opaque_key, int src_idx, u32 dest_idx_unmasked)
{
  struct tg3_rx_buffer_desc *src_desc;
  struct tg3_rx_buffer_desc *dest_desc;
  struct ring_info *src_map;
  struct ring_info *dest_map;
  int dest_idx;
  
#line 6726 
  struct tg3 *tp = tnapi->tp;
  
#line 6729 
  struct tg3_rx_prodring_set *spr = & tp->napi[0].prodring;
  
#line 6732 
  switch (opaque_key) {
    case (u32)65536: 
#line 6733 
    ;
    
#line 6734 
    dest_idx = (int)(tp->rx_std_ring_mask & dest_idx_unmasked);
    
#line 6735 
    dest_desc = dpr->rx_std + dest_idx;
    
#line 6736 
    dest_map = dpr->rx_std_buffers + dest_idx;
    
#line 6737 
    src_desc = spr->rx_std + src_idx;
    
#line 6738 
    src_map = spr->rx_std_buffers + src_idx;
    
#line 6739 
    goto ldv_57311;
    case (u32)131072: 
#line 6741 
    ;
    
#line 6742 
    dest_idx = (int)(tp->rx_jmb_ring_mask & dest_idx_unmasked);
    
#line 6743 
    dest_desc = & (dpr->rx_jmb + dest_idx)->std;
    
#line 6744 
    dest_map = dpr->rx_jmb_buffers + dest_idx;
    
#line 6745 
    src_desc = & (spr->rx_jmb + src_idx)->std;
    
#line 6746 
    src_map = spr->rx_jmb_buffers + src_idx;
    
#line 6747 
    goto ldv_57311;
    default: 
#line 6749 
    ;
    
#line 6750 
    goto return_label;
  }
  ldv_57311: 
#line 6753 
  ;
  
#line 6753 
  dest_map->data = src_map->data;
  
#line 6754 
  dest_map->mapping = src_map->mapping;
  
#line 6756 
  dest_desc->addr_hi = src_desc->addr_hi;
  
#line 6757 
  dest_desc->addr_lo = src_desc->addr_lo;
  
#line 6758 
  ldv_inline_asm();
  
#line 6764 
  src_map->data = (u8 *)0U;
  return_label: 
#line 6765 
                return;
}


#line 6791  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_rx(struct tg3_napi *tnapi, int budget)
{
  u32 work_mask;
  u32 std_prod_idx;
  u32 jmb_prod_idx;
  u16 hw_idx;
  int received;
  int tmp_8;
  
#line 6793 
  struct tg3 *tp = tnapi->tp;
  
#line 6794 
  u32 rx_std_posted = 0U;
  
#line 6796 
  u32 sw_idx = tnapi->rx_rcb_ptr;
  
#line 6799 
  struct tg3_rx_prodring_set *tpr = & tnapi->prodring;
  
#line 6801 
  hw_idx = *(tnapi->rx_rcb_prod_idx);
  
#line 6802 
  ldv_inline_asm();
  
#line 6807 
  work_mask = 0U;
  
#line 6808 
  received = 0;
  
#line 6809 
  std_prod_idx = tpr->rx_std_prod_idx;
  
#line 6810 
  jmb_prod_idx = tpr->rx_jmb_prod_idx;
  
#line 6811 
  goto ldv_57353;
  ldv_57352: 
#line 6812 
  ;
  {
    struct ring_info *ri;
    unsigned int len;
    struct sk_buff *skb;
    dma_addr_t dma_addr;
    u32 opaque_key;
    u32 desc_idx;
    u32 *post_ptr;
    u8 *data;
    int tmp_0;
    
#line 6813 
    struct tg3_rx_buffer_desc *desc = tnapi->rx_rcb + sw_idx;
    
#line 6819 
    u64 tstamp = 0ULL;
    
#line 6821 
    desc_idx = desc->opaque & 65535U;
    
#line 6822 
    opaque_key = desc->opaque & 458752U;
    
#line 6823 
    if (opaque_key == 65536U) {
      
#line 6824 
      ri = tp->napi[0].prodring.rx_std_buffers + desc_idx;
      
#line 6825 
      dma_addr = ri->mapping;
      
#line 6826 
      data = ri->data;
      
#line 6827 
      post_ptr = & std_prod_idx;
      
#line 6828 
      rx_std_posted += 1U;
    }
    else 
      
#line 6829 
      if (opaque_key == 131072U) {
        
#line 6830 
        ri = tp->napi[0].prodring.rx_jmb_buffers + desc_idx;
        
#line 6831 
        dma_addr = ri->mapping;
        
#line 6832 
        data = ri->data;
        
#line 6833 
        post_ptr = & jmb_prod_idx;
      }
      else 
#line 6835 
           goto next_pkt_nopost;
    
#line 6837 
    work_mask |= opaque_key;
    
#line 6839 
    if ((desc->err_vlan & 32440320U) != 0U) {
      drop_it: 
#line 6840 
      ;
      
#line 6841 
      tg3_recycle_rx(tnapi,tpr,opaque_key,(int)desc_idx,*post_ptr);
      drop_it_no_recycle: 
#line 6843 
      ;
      
#line 6845 
      tp->rx_dropped += 1UL;
      
#line 6846 
      goto next_pkt;
    }
    else ;
    {
      int tmp;
      
#line 6849 
      int _max1 = 32;
      
#line 6849 
      int _max2 = 64;
      
#line 6849 
      if (_max1 > _max2) 
#line 6849 
                         tmp = _max1; else 
#line 6849 
                                           tmp = _max2;
      
#line 6849 
      tmp_0 = tmp;
    }
    
#line 6849 
    ;
    
#line 6849 
    __builtin_prefetch((void const *)(data + tmp_0));
    
#line 6850 
    len = (desc->idx_len & 65535U) + 4294967292U;
    
#line 6853 
    if ((desc->type_flags & 528U) == 16U || (desc->type_flags & 528U) == 512U) {
      u32 tmp_1;
      u32 tmp_2;
      
#line 6857 
      tmp_1 = (*(tp->read32))(tp,1712U);
      
#line 6857 
      tstamp = (unsigned long long)tmp_1;
      
#line 6858 
      tmp_2 = (*(tp->read32))(tp,1716U);
      
#line 6858 
      tstamp = ((unsigned long long)tmp_2 << 32) | tstamp;
    }
    else ;
    
#line 6861 
    if (len > 256U) {
      int skb_size;
      unsigned int frag_size;
      int tmp_4;
      
#line 6865 
      skb_size = tg3_alloc_rx_data(tp,tpr,opaque_key,*post_ptr,& frag_size);
      
#line 6867 
      if (skb_size < 0) 
#line 6868 
                        goto drop_it; else ;
      
#line 6870 
      pci_unmap_single(tp->pdev,dma_addr,(unsigned long)skb_size,2);
      
#line 6871 
      ldv_inline_asm();
      
#line 6878 
      ri->data = (u8 *)0U;
      
#line 6880 
      skb = build_skb((void *)data,frag_size);
      
#line 6881 
      if (skb == (struct sk_buff *)0) {
        
#line 6882 
        tg3_frag_free((_Bool)(frag_size != 0U),(void *)data);
        
#line 6883 
        goto drop_it_no_recycle;
      }
      else ;
      {
        int tmp_3;
        
#line 6885 
        int _max1_0 = 32;
        
#line 6885 
        int _max2_0 = 64;
        
#line 6885 
        if (_max1_0 > _max2_0) 
#line 6885 
                               tmp_3 = _max1_0; else 
#line 6885 
                                                     tmp_3 = _max2_0;
        
#line 6885 
        tmp_4 = tmp_3;
      }
      
#line 6885 
      ;
      
#line 6885 
      skb_reserve(skb,tmp_4);
    }
    else {
      int tmp_6;
      
#line 6887 
      tg3_recycle_rx(tnapi,tpr,opaque_key,(int)desc_idx,*post_ptr);
      
#line 6890 
      skb = netdev_alloc_skb(tp->dev,len + 2U);
      
#line 6892 
      if (skb == (struct sk_buff *)0) 
#line 6893 
                                      goto drop_it_no_recycle; else ;
      
#line 6895 
      skb_reserve(skb,2);
      
#line 6896 
      pci_dma_sync_single_for_cpu(tp->pdev,dma_addr,(unsigned long)len,2);
      
#line 6897 
      ;
      {
        int tmp_5;
        
#line 6898 
        int _max1_1 = 32;
        
#line 6898 
        int _max2_1 = 64;
        
#line 6898 
        if (_max1_1 > _max2_1) 
#line 6898 
                               tmp_5 = _max1_1; else 
#line 6898 
                                                     tmp_5 = _max2_1;
        
#line 6898 
        tmp_6 = tmp_5;
      }
      
#line 6897 
      ;
      
#line 6897 
      ;
      
#line 6897 
      memcpy((void *)skb->data,(void const *)(data + tmp_6),(unsigned long)len);
      
#line 6900 
      pci_dma_sync_single_for_device(tp->pdev,dma_addr,(unsigned long)len,2);
    }
    
#line 6903 
    skb_put(skb,len);
    
#line 6904 
    if (tstamp != 0ULL) {
      struct skb_shared_hwtstamps *tmp_7;
      
#line 6905 
      tmp_7 = skb_hwtstamps(skb);
      
#line 6905 
      ;
      
#line 6905 
      ;
      
#line 6905 
      tg3_hwclock_to_timestamp(tp,tstamp,tmp_7);
    }
    else ;
    
#line 6908 
    if ((((tp->dev)->features & 17179869184ULL) != 0ULL && (desc->type_flags & 8192U) != 0U) && (desc->ip_tcp_csum & 65535U) == 65535U) 
      
#line 6912 
      skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U; else 
                                                                    
#line 6914 
                                                                    skb_checksum_none_assert((struct sk_buff const *)skb);
    
#line 6916 
    skb->protocol = eth_type_trans(skb,tp->dev);
    
#line 6918 
    if (((tp->dev)->mtu + 14U < len && (unsigned int)skb->protocol != 129U) && (unsigned int)skb->protocol != 43144U) {
      
#line 6921 
      dev_kfree_skb_any(skb);
      
#line 6922 
      goto drop_it_no_recycle;
    }
    else ;
    
#line 6925 
    if ((desc->type_flags & 64U) != 0U && (tp->rx_mode & 1024U) == 0U) 
      
#line 6927 
      __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)((int)((unsigned short)desc->err_vlan))); else ;
    
#line 6930 
    napi_gro_receive(& tnapi->napi,skb);
    
#line 6932 
    received += 1;
    
#line 6933 
    budget -= 1;
    next_pkt: 
#line 6935 
    ;
    
#line 6936 
    *post_ptr += 1U;
    
#line 6938 
    if ((long)(tp->rx_std_max_post <= rx_std_posted) != 0L) {
      
#line 6939 
      tpr->rx_std_prod_idx = tp->rx_std_ring_mask & std_prod_idx;
      
#line 6941 
      (*(tp->write32_rx_mbox))(tp,620U,tpr->rx_std_prod_idx);
      
#line 6943 
      work_mask &= 4294901759U;
      
#line 6944 
      rx_std_posted = 0U;
    }
    else ;
    next_pkt_nopost: 
#line 6946 
    ;
    
#line 6947 
    sw_idx += 1U;
    
#line 6948 
    sw_idx = tp->rx_ret_ring_mask & sw_idx;
    
#line 6951 
    if ((unsigned int)hw_idx == sw_idx) {
      
#line 6952 
      hw_idx = *(tnapi->rx_rcb_prod_idx);
      
#line 6953 
      ldv_inline_asm();
    }
    else ;
  }
  ldv_57353: 
#line 6956 
  ;
  
#line 6811 
  if ((unsigned int)hw_idx != sw_idx && budget > 0) 
#line 6813 
                                                    goto ldv_57352; else 
                                                                    
#line 6816 
                                                                    goto ldv_57354;
  ldv_57354: 
#line 6817 
  ;
  
#line 6958 
  tnapi->rx_rcb_ptr = sw_idx;
  
#line 6959 
  (*(tp->write32_rx_mbox))(tp,tnapi->consmbox,sw_idx);
  
#line 6962 
  tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 6962 
  if (tmp_8 == 0) {
    
#line 6964 
    ldv_inline_asm();
    
#line 6966 
    if ((work_mask & 65536U) != 0U) {
      
#line 6967 
      tpr->rx_std_prod_idx = tp->rx_std_ring_mask & std_prod_idx;
      
#line 6969 
      (*(tp->write32_rx_mbox))(tp,620U,tpr->rx_std_prod_idx);
    }
    else ;
    
#line 6972 
    if ((work_mask & 131072U) != 0U) {
      
#line 6973 
      tpr->rx_jmb_prod_idx = tp->rx_jmb_ring_mask & jmb_prod_idx;
      
#line 6975 
      (*(tp->write32_rx_mbox))(tp,628U,tpr->rx_jmb_prod_idx);
    }
    else ;
    
#line 6977 
    ldv_inline_asm();
  }
  else 
    
#line 6979 
    if (work_mask != 0U) {
      
#line 6981 
      ldv_inline_asm();
      
#line 6985 
      tpr->rx_std_prod_idx = tp->rx_std_ring_mask & std_prod_idx;
      
#line 6986 
      tpr->rx_jmb_prod_idx = tp->rx_jmb_ring_mask & jmb_prod_idx;
      
#line 6988 
      if (& tp->napi[1] != tnapi) {
        
#line 6989 
        tp->rx_refill = (_Bool)1;
        
#line 6990 
        napi_schedule(& tp->napi[1].napi);
      }
      else ;
    }
    else ;
  
#line 6994 
  return received;
}


#line 6997  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_poll_link(struct tg3 *tp)
{
  int tmp_0;
  
#line 7000 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_LINKCHG_REG,(unsigned long *)(& tp->tg3_flags));
  
#line 7000 
  if (tmp_0 == 0) {
    int tmp_1;
    
#line 7000 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_POLL_SERDES,(unsigned long *)(& tp->tg3_flags));
    
#line 7000 
    if (tmp_1 == 0) {
      
#line 7001 
      struct tg3_hw_status *sblk = tp->napi[0].hw_status;
      
#line 7003 
      if ((sblk->status & 2U) != 0U) {
        int tmp;
        
#line 7004 
        sblk->status = (sblk->status & 4294967292U) | 1U;
        
#line 7006 
        ldv_spin_lock_92(& tp->lock);
        
#line 7007 
        tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
        
#line 7007 
        if (tmp != 0) {
          
#line 7008 
          _tw32_flush(tp,1028U,4198424U,0U);
          
#line 7013 
          __const_udelay(171800UL);
        }
        else 
#line 7015 
             tg3_setup_phy(tp,(_Bool)0);
        
#line 7016 
        ldv_spin_unlock_93(& tp->lock);
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 7019 
  return;
}


#line 7021  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_rx_prodring_xfer(struct tg3 *tp, struct tg3_rx_prodring_set *dpr, struct tg3_rx_prodring_set *spr)
{
  u32 si;
  u32 di;
  u32 cpycnt;
  u32 src_prod_idx;
  int i;
  u32 tmp_0;
  u32 tmp_2;
  
#line 7026 
  int err = 0;
  ldv_57382: 
#line 7027 
  ;
  
#line 7029 
  src_prod_idx = spr->rx_std_prod_idx;
  
#line 7030 
  ldv_inline_asm();
  
#line 7036 
  if (spr->rx_std_cons_idx == src_prod_idx) 
#line 7037 
                                            goto ldv_57370; else ;
  
#line 7039 
  if (spr->rx_std_cons_idx < src_prod_idx) 
#line 7040 
                                           cpycnt = src_prod_idx - spr->rx_std_cons_idx; else 
                                                                    
#line 7042 
                                                                    cpycnt = (tp->rx_std_ring_mask - spr->rx_std_cons_idx) + 1U;
  {
    u32 tmp;
    
#line 7045 
    u32 _min1 = cpycnt;
    
#line 7045 
    u32 _min2 = (tp->rx_std_ring_mask - dpr->rx_std_prod_idx) + 1U;
    
#line 7045 
    if (_min1 < _min2) 
#line 7045 
                       tmp = _min1; else 
#line 7045 
                                         tmp = _min2;
    
#line 7045 
    tmp_0 = tmp;
  }
  
#line 7045 
  cpycnt = tmp_0;
  
#line 7048 
  si = spr->rx_std_cons_idx;
  
#line 7049 
  di = dpr->rx_std_prod_idx;
  
#line 7051 
  i = (int)di;
  
#line 7051 
  goto ldv_57376;
  ldv_57375: 
#line 7052 
  ;
  
#line 7052 
  if ((dpr->rx_std_buffers + i)->data != (u8 *)0U) {
    
#line 7053 
    cpycnt = (unsigned int)i - di;
    
#line 7054 
    err = -28;
    
#line 7055 
    goto ldv_57374;
  }
  else ;
  
#line 7051 
  i += 1;
  ldv_57376: 
#line 7052 
  ;
  
#line 7051 
  if (di + cpycnt > (unsigned int)i) 
#line 7053 
                                     goto ldv_57375; else 
#line 7056 
                                                          goto ldv_57374;
  ldv_57374: 
#line 7057 
  ;
  
#line 7059 
  if (cpycnt == 0U) 
#line 7060 
                    goto ldv_57370; else ;
  
#line 7061 
  ldv_inline_asm();
  
#line 7068 
  memcpy((void *)(dpr->rx_std_buffers + di),(void const *)(spr->rx_std_buffers + si),(unsigned long)cpycnt * 16UL);
  
#line 7072 
  i = 0;
  
#line 7072 
  goto ldv_57380;
  ldv_57379: 
#line 7073 
  ;
  {
    struct tg3_rx_buffer_desc *sbd;
    struct tg3_rx_buffer_desc *dbd;
    
#line 7074 
    sbd = spr->rx_std + si;
    
#line 7075 
    dbd = dpr->rx_std + di;
    
#line 7076 
    dbd->addr_hi = sbd->addr_hi;
    
#line 7077 
    dbd->addr_lo = sbd->addr_lo;
  }
  
#line 7072 
  i += 1;
  
#line 7072 
  di += 1U;
  
#line 7072 
  si += 1U;
  ldv_57380: 
#line 7073 
  ;
  
#line 7072 
  if ((unsigned int)i < cpycnt) 
#line 7074 
                                goto ldv_57379; else 
#line 7077 
                                                     goto ldv_57381;
  ldv_57381: 
#line 7078 
  ;
  
#line 7080 
  spr->rx_std_cons_idx = (spr->rx_std_cons_idx + cpycnt) & tp->rx_std_ring_mask;
  
#line 7082 
  dpr->rx_std_prod_idx = (dpr->rx_std_prod_idx + cpycnt) & tp->rx_std_ring_mask;
  
#line 7029 
  goto ldv_57382;
  ldv_57370: 
#line 7030 
  ;
  ldv_57395: 
#line 7031 
  ;
  
#line 7087 
  src_prod_idx = spr->rx_jmb_prod_idx;
  
#line 7088 
  ldv_inline_asm();
  
#line 7094 
  if (spr->rx_jmb_cons_idx == src_prod_idx) 
#line 7095 
                                            goto ldv_57383; else ;
  
#line 7097 
  if (spr->rx_jmb_cons_idx < src_prod_idx) 
#line 7098 
                                           cpycnt = src_prod_idx - spr->rx_jmb_cons_idx; else 
                                                                    
#line 7100 
                                                                    cpycnt = (tp->rx_jmb_ring_mask - spr->rx_jmb_cons_idx) + 1U;
  {
    u32 tmp_1;
    
#line 7103 
    u32 _min1_0 = cpycnt;
    
#line 7103 
    u32 _min2_0 = (tp->rx_jmb_ring_mask - dpr->rx_jmb_prod_idx) + 1U;
    
#line 7103 
    if (_min1_0 < _min2_0) 
#line 7103 
                           tmp_1 = _min1_0; else 
#line 7103 
                                                 tmp_1 = _min2_0;
    
#line 7103 
    tmp_2 = tmp_1;
  }
  
#line 7103 
  cpycnt = tmp_2;
  
#line 7106 
  si = spr->rx_jmb_cons_idx;
  
#line 7107 
  di = dpr->rx_jmb_prod_idx;
  
#line 7109 
  i = (int)di;
  
#line 7109 
  goto ldv_57389;
  ldv_57388: 
#line 7110 
  ;
  
#line 7110 
  if ((dpr->rx_jmb_buffers + i)->data != (u8 *)0U) {
    
#line 7111 
    cpycnt = (unsigned int)i - di;
    
#line 7112 
    err = -28;
    
#line 7113 
    goto ldv_57387;
  }
  else ;
  
#line 7109 
  i += 1;
  ldv_57389: 
#line 7110 
  ;
  
#line 7109 
  if (di + cpycnt > (unsigned int)i) 
#line 7111 
                                     goto ldv_57388; else 
#line 7114 
                                                          goto ldv_57387;
  ldv_57387: 
#line 7115 
  ;
  
#line 7117 
  if (cpycnt == 0U) 
#line 7118 
                    goto ldv_57383; else ;
  
#line 7119 
  ldv_inline_asm();
  
#line 7126 
  memcpy((void *)(dpr->rx_jmb_buffers + di),(void const *)(spr->rx_jmb_buffers + si),(unsigned long)cpycnt * 16UL);
  
#line 7130 
  i = 0;
  
#line 7130 
  goto ldv_57393;
  ldv_57392: 
#line 7131 
  ;
  {
    struct tg3_rx_buffer_desc *sbd_0;
    struct tg3_rx_buffer_desc *dbd_0;
    
#line 7132 
    sbd_0 = & (spr->rx_jmb + si)->std;
    
#line 7133 
    dbd_0 = & (dpr->rx_jmb + di)->std;
    
#line 7134 
    dbd_0->addr_hi = sbd_0->addr_hi;
    
#line 7135 
    dbd_0->addr_lo = sbd_0->addr_lo;
  }
  
#line 7130 
  i += 1;
  
#line 7130 
  di += 1U;
  
#line 7130 
  si += 1U;
  ldv_57393: 
#line 7131 
  ;
  
#line 7130 
  if ((unsigned int)i < cpycnt) 
#line 7132 
                                goto ldv_57392; else 
#line 7135 
                                                     goto ldv_57394;
  ldv_57394: 
#line 7136 
  ;
  
#line 7138 
  spr->rx_jmb_cons_idx = (spr->rx_jmb_cons_idx + cpycnt) & tp->rx_jmb_ring_mask;
  
#line 7140 
  dpr->rx_jmb_prod_idx = (dpr->rx_jmb_prod_idx + cpycnt) & tp->rx_jmb_ring_mask;
  
#line 7087 
  goto ldv_57395;
  ldv_57383: 
#line 7088 
  ;
  
#line 7144 
  return err;
}


#line 7147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_poll_work(struct tg3_napi *tnapi, int work_done, int budget)
{
  int __retres;
  int tmp_2;
  
#line 7149 
  struct tg3 *tp = tnapi->tp;
  
#line 7152 
  if ((unsigned int)(tnapi->hw_status)->idx[0].tx_consumer != tnapi->tx_cons) {
    int tmp;
    
#line 7153 
    tg3_tx(tnapi);
    
#line 7154 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TX_RECOVERY_PENDING,(unsigned long *)(& tp->tg3_flags));
    
#line 7154 
    if ((long)(tmp != 0) != 0L) {
      
#line 7155 
      __retres = work_done;
      
#line 7155 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 7158 
  if (tnapi->rx_rcb_prod_idx == (u16 *)0U) {
    
#line 7159 
    __retres = work_done;
    
#line 7159 
    goto return_label;
  }
  else ;
  
#line 7165 
  if ((unsigned int)*(tnapi->rx_rcb_prod_idx) != tnapi->rx_rcb_ptr) {
    int tmp_0;
    
#line 7166 
    tmp_0 = tg3_rx(tnapi,budget - work_done);
    
#line 7166 
    work_done = tmp_0 + work_done;
  }
  else ;
  
#line 7168 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 7168 
  if (tmp_2 != 0) {
    
#line 7168 
    if (& tp->napi[1] == tnapi) {
      int i;
      int tmp_1;
      
#line 7169 
      struct tg3_rx_prodring_set *dpr = & tp->napi[0].prodring;
      
#line 7170 
      int err = 0;
      
#line 7171 
      u32 std_prod_idx = dpr->rx_std_prod_idx;
      
#line 7172 
      u32 jmb_prod_idx = dpr->rx_jmb_prod_idx;
      
#line 7174 
      tp->rx_refill = (_Bool)0;
      
#line 7175 
      i = 1;
      
#line 7175 
      goto ldv_57408;
      ldv_57407: 
#line 7176 
      ;
      
#line 7176 
      tmp_1 = tg3_rx_prodring_xfer(tp,dpr,& tp->napi[i].prodring);
      
#line 7177 
      err = tmp_1 | err;
      
#line 7175 
      i += 1;
      ldv_57408: 
#line 7176 
      ;
      
#line 7175 
      if (tp->rxq_cnt >= (unsigned int)i) 
#line 7177 
                                          goto ldv_57407; else 
#line 7180 
                                                               goto ldv_57409;
      ldv_57409: 
#line 7181 
      ;
      
#line 7182 
      ldv_inline_asm();
      
#line 7181 
      if (dpr->rx_std_prod_idx != std_prod_idx) 
#line 7182 
                                                (*(tp->write32_rx_mbox))(tp,620U,dpr->rx_std_prod_idx); else ;
      
#line 7185 
      if (dpr->rx_jmb_prod_idx != jmb_prod_idx) 
#line 7186 
                                                (*(tp->write32_rx_mbox))(tp,628U,dpr->rx_jmb_prod_idx); else ;
      
#line 7187 
      ldv_inline_asm();
      
#line 7191 
      if (err != 0) 
#line 7192 
                    _tw32_flush(tp,15360U,tp->coal_now,0U); else ;
    }
    else ;
  }
  else ;
  
#line 7195 
  __retres = work_done;
  return_label: 
#line 7195 
                return __retres;
}


#line 7198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tg3_reset_task_schedule(struct tg3 *tp)
{
  int tmp;
  
#line 7200 
  tmp = test_and_set_bit(69L,(unsigned long volatile *)(& tp->tg3_flags));
  
#line 7200 
  if (tmp == 0) 
#line 7201 
                ldv_schedule_work_94(& tp->reset_task); else ;
  
#line 7202 
  return;
}


#line 7204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tg3_reset_task_cancel(struct tg3 *tp)
{
  
#line 7206 
  cancel_work_sync(& tp->reset_task);
  
#line 7207 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_RESET_TASK_PENDING,(unsigned long *)(& tp->tg3_flags));
  
#line 7208 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TX_RECOVERY_PENDING,(unsigned long *)(& tp->tg3_flags));
  
#line 7209 
  return;
}


#line 7211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_poll_msix(struct napi_struct *napi, int budget)
{
  int __retres;
  struct tg3_napi *tmp;
  int tmp_0;
  {
    
#line 7213 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 7213 
    tmp = (struct tg3_napi *)__mptr;
  }
  
#line 7213 
  struct tg3_napi *tnapi = tmp;
  
#line 7214 
  struct tg3 *tp = tnapi->tp;
  
#line 7215 
  int work_done = 0;
  
#line 7216 
  struct tg3_hw_status *sblk = tnapi->hw_status;
  ldv_57429: 
#line 7217 
  ;
  
#line 7219 
  work_done = tg3_poll_work(tnapi,work_done,budget);
  
#line 7221 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TX_RECOVERY_PENDING,(unsigned long *)(& tp->tg3_flags));
  
#line 7221 
  if ((long)(tmp_0 != 0) != 0L) 
#line 7222 
                                goto tx_recovery; else ;
  
#line 7224 
  if ((long)(work_done >= budget) != 0L) 
#line 7225 
                                         goto ldv_57427; else ;
  
#line 7231 
  tnapi->last_tag = sblk->status_tag;
  
#line 7232 
  tnapi->last_irq_tag = tnapi->last_tag;
  
#line 7233 
  ldv_inline_asm();
  
#line 7236 
  if ((long)((unsigned int)sblk->idx[0].tx_consumer == tnapi->tx_cons) != 0L && (long)((unsigned int)*(tnapi->rx_rcb_prod_idx) == tnapi->rx_rcb_ptr) != 0L) {
    
#line 7242 
    if (& tp->napi[1] == tnapi && (int)tp->rx_refill != 0) 
#line 7243 
                                                           goto ldv_57428; else ;
    
#line 7245 
    napi_complete_done(napi,work_done);
    
#line 7247 
    (*(tp->write32_mbox))(tp,tnapi->int_mbox,tnapi->last_tag << 24);
    
#line 7252 
    if ((long)(& tp->napi[1] == tnapi) != 0L && (long)((int)tp->rx_refill != 0) != 0L) 
      
#line 7253 
      (*(tp->write32))(tp,15360U,(tp->coalesce_mode | tnapi->coal_now) | 2U); else ;
    
#line 7254 
    ldv_inline_asm();
    
#line 7258 
    goto ldv_57427;
  }
  else ;
  ldv_57428: 
#line 7260 
  ;
  
#line 7219 
  goto ldv_57429;
  ldv_57427: 
#line 7220 
  ;
  
#line 7262 
  __retres = work_done;
  
#line 7262 
  goto return_label;
  tx_recovery: 
#line 7264 
  ;
  
#line 7266 
  napi_complete(napi);
  
#line 7267 
  tg3_reset_task_schedule(tp);
  
#line 7268 
  __retres = work_done;
  return_label: 
#line 7268 
                return __retres;
}


#line 7271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_process_error(struct tg3 *tp)
{
  u32 val;
  int tmp;
  u32 tmp_0;
  u32 tmp_1;
  
#line 7274 
  bool real_error = (_Bool)0;
  
#line 7276 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ERROR_PROCESSED,(unsigned long *)(& tp->tg3_flags));
  
#line 7276 
  if (tmp != 0) 
#line 7277 
                goto return_label; else ;
  
#line 7280 
  val = (*(tp->read32))(tp,15432U);
  
#line 7281 
  if ((val & 4294967231U) != 0U) {
    
#line 7282 
    netdev_err((struct net_device const *)tp->dev,"FLOW Attention error.  Resetting chip.\n");
    
#line 7283 
    real_error = (_Bool)1;
  }
  else ;
  
#line 7286 
  tmp_0 = (*(tp->read32))(tp,24580U);
  
#line 7286 
  if ((tmp_0 & 4294967294U) != 0U) {
    
#line 7287 
    netdev_err((struct net_device const *)tp->dev,"MSI Status error.  Resetting chip.\n");
    
#line 7288 
    real_error = (_Bool)1;
  }
  else ;
  
#line 7291 
  tmp_1 = (*(tp->read32))(tp,18436U);
  
#line 7291 
  if (tmp_1 != 0U) 
#line 7291 
                   goto _LOR;
  else {
    u32 tmp_2;
    
#line 7291 
    tmp_2 = (*(tp->read32))(tp,19460U);
    
#line 7291 
    if (tmp_2 != 0U) {
      _LOR: {
              
#line 7292 
              netdev_err((struct net_device const *)tp->dev,"DMA Status error.  Resetting chip.\n");
              
#line 7293 
              real_error = (_Bool)1;
            }
    }
    else ;
  }
  
#line 7296 
  if (! real_error) 
#line 7297 
                    goto return_label; else ;
  
#line 7299 
  tg3_dump_state(tp);
  
#line 7301 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ERROR_PROCESSED,(unsigned long *)(& tp->tg3_flags));
  
#line 7302 
  tg3_reset_task_schedule(tp);
  return_label: 
#line 7303 
                return;
}


#line 7305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_poll(struct napi_struct *napi, int budget)
{
  int __retres;
  struct tg3_napi *tmp;
  int tmp_0;
  int tmp_1;
  unsigned int tmp_2;
  {
    
#line 7307 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 7307 
    tmp = (struct tg3_napi *)__mptr;
  }
  
#line 7307 
  struct tg3_napi *tnapi = tmp;
  
#line 7308 
  struct tg3 *tp = tnapi->tp;
  
#line 7309 
  int work_done = 0;
  
#line 7310 
  struct tg3_hw_status *sblk = tnapi->hw_status;
  ldv_57447: 
#line 7311 
  ;
  
#line 7313 
  if ((sblk->status & 4U) != 0U) 
#line 7314 
                                 tg3_process_error(tp); else ;
  
#line 7316 
  tg3_poll_link(tp);
  
#line 7318 
  work_done = tg3_poll_work(tnapi,work_done,budget);
  
#line 7320 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TX_RECOVERY_PENDING,(unsigned long *)(& tp->tg3_flags));
  
#line 7320 
  if ((long)(tmp_0 != 0) != 0L) 
#line 7321 
                                goto tx_recovery; else ;
  
#line 7323 
  if ((long)(work_done >= budget) != 0L) 
#line 7324 
                                         goto ldv_57446; else ;
  
#line 7326 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags));
  
#line 7326 
  if (tmp_1 != 0) {
    
#line 7331 
    tnapi->last_tag = sblk->status_tag;
    
#line 7332 
    tnapi->last_irq_tag = tnapi->last_tag;
    
#line 7333 
    ldv_inline_asm();
  }
  else 
#line 7335 
       sblk->status &= 4294967294U;
  
#line 7337 
  tmp_2 = tg3_has_work(tnapi);
  
#line 7337 
  if ((long)(tmp_2 == 0U) != 0L) {
    
#line 7338 
    napi_complete_done(napi,work_done);
    
#line 7339 
    tg3_int_reenable(tnapi);
    
#line 7340 
    goto ldv_57446;
  }
  else ;
  
#line 7313 
  goto ldv_57447;
  ldv_57446: 
#line 7314 
  ;
  
#line 7344 
  __retres = work_done;
  
#line 7344 
  goto return_label;
  tx_recovery: 
#line 7346 
  ;
  
#line 7348 
  napi_complete(napi);
  
#line 7349 
  tg3_reset_task_schedule(tp);
  
#line 7350 
  __retres = work_done;
  return_label: 
#line 7350 
                return __retres;
}


#line 7353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_napi_disable(struct tg3 *tp)
{
  int i;
  
#line 7357 
  i = (int)(tp->irq_cnt + 4294967295U);
  
#line 7357 
  goto ldv_57453;
  ldv_57452: 
#line 7358 
  ;
  
#line 7358 
  napi_disable(& tp->napi[i].napi);
  
#line 7357 
  i -= 1;
  ldv_57453: 
#line 7358 
  ;
  
#line 7357 
  if (i >= 0) 
#line 7359 
              goto ldv_57452; else 
#line 7362 
                                   goto ldv_57454;
  ldv_57454: 
#line 7363 
  ;
  
#line 7364 
  return;
}


#line 7361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_napi_enable(struct tg3 *tp)
{
  int i;
  
#line 7365 
  i = 0;
  
#line 7365 
  goto ldv_57460;
  ldv_57459: 
#line 7366 
  ;
  
#line 7366 
  napi_enable(& tp->napi[i].napi);
  
#line 7365 
  i += 1;
  ldv_57460: 
#line 7366 
  ;
  
#line 7365 
  if (tp->irq_cnt > (unsigned int)i) 
#line 7367 
                                     goto ldv_57459; else 
#line 7370 
                                                          goto ldv_57461;
  ldv_57461: 
#line 7371 
  ;
  
#line 7372 
  return;
}


#line 7369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_napi_init(struct tg3 *tp)
{
  int i;
  
#line 7373 
  netif_napi_add(tp->dev,& tp->napi[0].napi,& tg3_poll,64);
  
#line 7374 
  i = 1;
  
#line 7374 
  goto ldv_57467;
  ldv_57466: 
#line 7375 
  ;
  
#line 7375 
  netif_napi_add(tp->dev,& tp->napi[i].napi,& tg3_poll_msix,64);
  
#line 7374 
  i += 1;
  ldv_57467: 
#line 7375 
  ;
  
#line 7374 
  if (tp->irq_cnt > (unsigned int)i) 
#line 7376 
                                     goto ldv_57466; else 
#line 7379 
                                                          goto ldv_57468;
  ldv_57468: 
#line 7380 
  ;
  
#line 7381 
  return;
}


#line 7378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_napi_fini(struct tg3 *tp)
{
  int i;
  
#line 7382 
  i = 0;
  
#line 7382 
  goto ldv_57474;
  ldv_57473: 
#line 7383 
  ;
  
#line 7383 
  netif_napi_del(& tp->napi[i].napi);
  
#line 7382 
  i += 1;
  ldv_57474: 
#line 7383 
  ;
  
#line 7382 
  if (tp->irq_cnt > (unsigned int)i) 
#line 7384 
                                     goto ldv_57473; else 
#line 7387 
                                                          goto ldv_57475;
  ldv_57475: 
#line 7388 
  ;
  
#line 7389 
  return;
}


#line 7386  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tg3_netif_stop(struct tg3 *tp)
{
  
#line 7388 
  (tp->dev)->trans_start = jiffies;
  
#line 7389 
  tg3_napi_disable(tp);
  
#line 7390 
  netif_carrier_off(tp->dev);
  
#line 7391 
  netif_tx_disable(tp->dev);
  
#line 7392 
  return;
}


#line 7395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tg3_netif_start(struct tg3 *tp)
{
  
#line 7397 
  tg3_ptp_resume(tp);
  
#line 7403 
  netif_tx_wake_all_queues(tp->dev);
  
#line 7405 
  if ((int)tp->link_up != 0) 
#line 7406 
                             netif_carrier_on(tp->dev); else ;
  
#line 7408 
  tg3_napi_enable(tp);
  
#line 7409 
  (tp->napi[0].hw_status)->status |= 1U;
  
#line 7410 
  tg3_enable_ints(tp);
  
#line 7411 
  return;
}


#line 7413  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_irq_quiesce(struct tg3 *tp)
{
  int i;
  
#line 7419 
  if ((long)(tp->irq_sync != 0U) != 0L) {
    
#line 7421 
    ldv_inline_asm();
    
#line 7419 
    ;
  }
  else ;
  
#line 7421 
  tp->irq_sync = 1U;
  
#line 7422 
  ldv_inline_asm();
  
#line 7424 
  ldv_spin_unlock_bh_95(& tp->lock);
  
#line 7426 
  i = 0;
  
#line 7426 
  goto ldv_57487;
  ldv_57486: 
#line 7427 
  ;
  
#line 7427 
  synchronize_irq(tp->napi[i].irq_vec);
  
#line 7426 
  i += 1;
  ldv_57487: 
#line 7427 
  ;
  
#line 7426 
  if (tp->irq_cnt > (unsigned int)i) 
#line 7428 
                                     goto ldv_57486; else 
#line 7431 
                                                          goto ldv_57488;
  ldv_57488: 
#line 7432 
  ;
  
#line 7429 
  ldv_spin_lock_bh_96(& tp->lock);
  
#line 7430 
  return;
}


#line 7437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_full_lock(struct tg3 *tp, int irq_sync)
{
  
#line 7439 
  ldv_spin_lock_bh_97(& tp->lock);
  
#line 7440 
  if (irq_sync != 0) 
#line 7441 
                     tg3_irq_quiesce(tp); else ;
  
#line 7442 
  return;
}


#line 7444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_full_unlock(struct tg3 *tp)
{
  
#line 7446 
  ldv_spin_unlock_bh_98(& tp->lock);
  
#line 7447 
  return;
}


#line 7452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static irqreturn_t tg3_msi_1shot(int irq, void *dev_id)
{
  irqreturn_t __retres;
  int tmp;
  
#line 7454 
  struct tg3_napi *tnapi = (struct tg3_napi *)dev_id;
  
#line 7455 
  struct tg3 *tp = tnapi->tp;
  
#line 7457 
  __builtin_prefetch((void const *)tnapi->hw_status);
  
#line 7458 
  if (tnapi->rx_rcb != (struct tg3_rx_buffer_desc *)0) 
#line 7459 
                                                       __builtin_prefetch((void const *)(tnapi->rx_rcb + tnapi->rx_rcb_ptr)); else ;
  
#line 7461 
  tmp = tg3_irq_sync(tp);
  
#line 7461 
  if ((long)(tmp == 0) != 0L) 
#line 7462 
                              napi_schedule(& tnapi->napi); else ;
  
#line 7464 
  __retres = IRQ_HANDLED;
  
#line 7464 
  return __retres;
}


#line 7471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static irqreturn_t tg3_msi(int irq, void *dev_id)
{
  irqreturn_t __retres;
  int tmp;
  
#line 7473 
  struct tg3_napi *tnapi = (struct tg3_napi *)dev_id;
  
#line 7474 
  struct tg3 *tp = tnapi->tp;
  
#line 7476 
  __builtin_prefetch((void const *)tnapi->hw_status);
  
#line 7477 
  if (tnapi->rx_rcb != (struct tg3_rx_buffer_desc *)0) 
#line 7478 
                                                       __builtin_prefetch((void const *)(tnapi->rx_rcb + tnapi->rx_rcb_ptr)); else ;
  
#line 7486 
  (*(tp->write32_mbox))(tp,tnapi->int_mbox,1U);
  
#line 7487 
  tmp = tg3_irq_sync(tp);
  
#line 7487 
  if ((long)(tmp == 0) != 0L) 
#line 7488 
                              napi_schedule(& tnapi->napi); else ;
  
#line 7490 
  __retres = IRQ_HANDLED;
  
#line 7490 
  return __retres;
}


#line 7493  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static irqreturn_t tg3_interrupt(int irq, void *dev_id)
{
  irqreturn_t __retres;
  int tmp_1;
  unsigned int tmp_2;
  
#line 7495 
  struct tg3_napi *tnapi = (struct tg3_napi *)dev_id;
  
#line 7496 
  struct tg3 *tp = tnapi->tp;
  
#line 7497 
  struct tg3_hw_status *sblk = tnapi->hw_status;
  
#line 7498 
  unsigned int handled = 1U;
  
#line 7505 
  if ((long)((sblk->status & 1U) == 0U) != 0L) {
    int tmp;
    
#line 7506 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CHIP_RESETTING,(unsigned long *)(& tp->tg3_flags));
    
#line 7506 
    if (tmp != 0) 
#line 7506 
                  goto _LOR;
    else {
      u32 tmp_0;
      
#line 7506 
      tmp_0 = (*(tp->read32))(tp,112U);
      
#line 7506 
      if ((tmp_0 & 2U) != 0U) {
        _LOR: {
                
#line 7508 
                handled = 0U;
                
#line 7509 
                goto out;
              }
      }
      else ;
    }
  }
  else ;
  
#line 7524 
  tw32_mailbox_flush(tp,516U,1U);
  
#line 7525 
  tmp_1 = tg3_irq_sync(tp);
  
#line 7525 
  if (tmp_1 != 0) 
#line 7526 
                  goto out; else ;
  
#line 7527 
  sblk->status &= 4294967294U;
  
#line 7528 
  tmp_2 = tg3_has_work(tnapi);
  
#line 7528 
  if ((long)(tmp_2 != 0U) != 0L) {
    
#line 7529 
    __builtin_prefetch((void const *)(tnapi->rx_rcb + tnapi->rx_rcb_ptr));
    
#line 7530 
    napi_schedule(& tnapi->napi);
  }
  else 
#line 7535 
       tw32_mailbox_flush(tp,516U,0U);
  out: 
#line 7538 
  ;
  
#line 7539 
  __retres = (enum irqreturn)(handled != 0U);
  
#line 7539 
  return __retres;
}


#line 7542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static irqreturn_t tg3_interrupt_tagged(int irq, void *dev_id)
{
  irqreturn_t __retres;
  int tmp_1;
  
#line 7544 
  struct tg3_napi *tnapi = (struct tg3_napi *)dev_id;
  
#line 7545 
  struct tg3 *tp = tnapi->tp;
  
#line 7546 
  struct tg3_hw_status *sblk = tnapi->hw_status;
  
#line 7547 
  unsigned int handled = 1U;
  
#line 7554 
  if ((long)(sblk->status_tag == tnapi->last_irq_tag) != 0L) {
    int tmp;
    
#line 7555 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CHIP_RESETTING,(unsigned long *)(& tp->tg3_flags));
    
#line 7555 
    if (tmp != 0) 
#line 7555 
                  goto _LOR;
    else {
      u32 tmp_0;
      
#line 7555 
      tmp_0 = (*(tp->read32))(tp,112U);
      
#line 7555 
      if ((tmp_0 & 2U) != 0U) {
        _LOR: {
                
#line 7557 
                handled = 0U;
                
#line 7558 
                goto out;
              }
      }
      else ;
    }
  }
  else ;
  
#line 7573 
  tw32_mailbox_flush(tp,516U,1U);
  
#line 7581 
  tnapi->last_irq_tag = sblk->status_tag;
  
#line 7583 
  tmp_1 = tg3_irq_sync(tp);
  
#line 7583 
  if (tmp_1 != 0) 
#line 7584 
                  goto out; else ;
  
#line 7586 
  __builtin_prefetch((void const *)(tnapi->rx_rcb + tnapi->rx_rcb_ptr));
  
#line 7588 
  napi_schedule(& tnapi->napi);
  out: 
#line 7590 
  ;
  
#line 7591 
  __retres = (enum irqreturn)(handled != 0U);
  
#line 7591 
  return __retres;
}


#line 7595  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static irqreturn_t tg3_test_isr(int irq, void *dev_id)
{
  irqreturn_t __retres;
  
#line 7597 
  struct tg3_napi *tnapi = (struct tg3_napi *)dev_id;
  
#line 7598 
  struct tg3 *tp = tnapi->tp;
  
#line 7599 
  struct tg3_hw_status *sblk = tnapi->hw_status;
  
#line 7601 
  if ((sblk->status & 1U) != 0U) 
#line 7601 
                                 goto _LOR;
  else {
    u32 tmp;
    
#line 7601 
    tmp = (*(tp->read32))(tp,112U);
    
#line 7601 
    if ((tmp & 2U) == 0U) {
      _LOR: {
              
#line 7603 
              tg3_disable_ints(tp);
              
#line 7604 
              __retres = IRQ_HANDLED;
              
#line 7604 
              goto return_label;
            }
    }
    else ;
  }
  
#line 7606 
  __retres = IRQ_NONE;
  return_label: 
#line 7606 
                return __retres;
}


#line 7610  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_poll_controller(struct net_device *dev)
{
  int i;
  int tmp_0;
  
#line 7613 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 7615 
  tmp_0 = tg3_irq_sync(tp);
  
#line 7615 
  if (tmp_0 != 0) 
#line 7616 
                  goto return_label; else ;
  
#line 7618 
  i = 0;
  
#line 7618 
  goto ldv_57539;
  ldv_57538: 
#line 7619 
  ;
  
#line 7619 
  tg3_interrupt((int)tp->napi[i].irq_vec,(void *)(& tp->napi[i]));
  
#line 7618 
  i += 1;
  ldv_57539: 
#line 7619 
  ;
  
#line 7618 
  if (tp->irq_cnt > (unsigned int)i) 
#line 7620 
                                     goto ldv_57538; else 
#line 7623 
                                                          goto ldv_57540;
  ldv_57540: 
#line 7624 
  ;
  return_label: 
#line 7625 
                return;
}


#line 7623  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_tx_timeout(struct net_device *dev)
{
  
#line 7625 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 7627 
  if ((tp->msg_enable & 128U) != 0U) {
    
#line 7628 
    netdev_err((struct net_device const *)dev,"transmit timed out, resetting\n");
    
#line 7629 
    tg3_dump_state(tp);
  }
  else ;
  
#line 7632 
  tg3_reset_task_schedule(tp);
  
#line 7633 
  return;
}


#line 7636  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static int tg3_4g_overflow_test(dma_addr_t mapping, int len)
{
  int __retres;
  
#line 7638 
  u32 base = (unsigned int)mapping;
  
#line 7640 
  __retres = (base + (unsigned int)len) + 8U < base;
  
#line 7640 
  return __retres;
}


#line 7646  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static int tg3_4g_tso_overflow_test(struct tg3 *tp, dma_addr_t mapping, u32 len, u32 mss)
{
  int __retres;
  
#line 7649 
  if (tp->pci_chip_rev_id >> 12 == 22370U && mss != 0U) {
    
#line 7650 
    u32 base = (unsigned int)mapping;
    
#line 7652 
    __retres = (base + len) + (mss & 16383U) < base;
    
#line 7652 
    goto return_label;
  }
  else ;
  
#line 7654 
  __retres = 0;
  return_label: 
#line 7654 
                return __retres;
}


#line 7658  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static int tg3_40bit_overflow_test(struct tg3 *tp, dma_addr_t mapping, int len)
{
  int __retres;
  
#line 7666 
  __retres = 0;
  
#line 7666 
  return __retres;
}


#line 7670  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tg3_tx_set_bd(struct tg3_tx_buffer_desc *txbd, dma_addr_t mapping, u32 len, u32 flags, u32 mss, u32 vlan)
{
  
#line 7674 
  txbd->addr_hi = (unsigned int)(mapping >> 32);
  
#line 7675 
  txbd->addr_lo = (unsigned int)mapping;
  
#line 7676 
  txbd->len_flags = (len << 16) | (flags & 65535U);
  
#line 7677 
  txbd->vlan_tag = (mss << 16) | vlan;
  
#line 7678 
  return;
}


#line 7680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_tx_frag_set(struct tg3_napi *tnapi, u32 *entry, u32 *budget, dma_addr_t map, u32 len, u32 flags, u32 mss, u32 vlan)
{
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  
#line 7684 
  struct tg3 *tp = tnapi->tp;
  
#line 7685 
  bool hwbug = (_Bool)0;
  
#line 7687 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SHORT_DMA_BUG,(unsigned long *)(& tp->tg3_flags));
  
#line 7687 
  if (tmp != 0) {
    
#line 7687 
    if (len <= 8U) 
#line 7688 
                   hwbug = (_Bool)1; else ;
  }
  else ;
  
#line 7690 
  tmp_0 = tg3_4g_overflow_test(map,(int)len);
  
#line 7690 
  if (tmp_0 != 0) 
#line 7691 
                  hwbug = (_Bool)1; else ;
  
#line 7693 
  tmp_1 = tg3_4g_tso_overflow_test(tp,map,len,mss);
  
#line 7693 
  if (tmp_1 != 0) 
#line 7694 
                  hwbug = (_Bool)1; else ;
  
#line 7696 
  tmp_2 = tg3_40bit_overflow_test(tp,map,(int)len);
  
#line 7696 
  if (tmp_2 != 0) 
#line 7697 
                  hwbug = (_Bool)1; else ;
  
#line 7699 
  if (tp->dma_limit != 0U) {
    
#line 7700 
    u32 prvidx = *entry;
    
#line 7701 
    u32 tmp_flag = flags & 4294967291U;
    
#line 7702 
    goto ldv_57586;
    ldv_57585: 
#line 7703 
    ;
    {
      
#line 7703 
      u32 frag_len = tp->dma_limit;
      
#line 7704 
      len -= tp->dma_limit;
      
#line 7707 
      if (len <= 8U) {
        
#line 7708 
        len = tp->dma_limit / 2U + len;
        
#line 7709 
        frag_len = tp->dma_limit / 2U;
      }
      else ;
      
#line 7712 
      (tnapi->tx_buffers + *entry)->fragmented = (_Bool)1;
      
#line 7714 
      tg3_tx_set_bd(tnapi->tx_ring + *entry,map,frag_len,tmp_flag,mss,vlan);
      
#line 7716 
      *budget += 4294967295U;
      
#line 7717 
      prvidx = *entry;
      
#line 7718 
      *entry = (*entry + 1U) & 511U;
      
#line 7720 
      map = (unsigned long long)frag_len + map;
    }
    ldv_57586: 
#line 7722 
    ;
    
#line 7702 
    if (tp->dma_limit < len && *budget != 0U) 
#line 7704 
                                              goto ldv_57585; else 
#line 7707 
                                                                   goto ldv_57587;
    ldv_57587: 
#line 7708 
    ;
    
#line 7723 
    if (len != 0U) 
      
#line 7724 
      if (*budget != 0U) {
        
#line 7725 
        tg3_tx_set_bd(tnapi->tx_ring + *entry,map,len,flags,mss,vlan);
        
#line 7727 
        *budget += 4294967295U;
        
#line 7728 
        *entry = (*entry + 1U) & 511U;
      }
      else {
        
#line 7730 
        hwbug = (_Bool)1;
        
#line 7731 
        (tnapi->tx_buffers + prvidx)->fragmented = (_Bool)0;
      }
    else ;
  }
  else {
    
#line 7735 
    tg3_tx_set_bd(tnapi->tx_ring + *entry,map,len,flags,mss,vlan);
    
#line 7737 
    *entry = (*entry + 1U) & 511U;
  }
  
#line 7740 
  return hwbug;
}


#line 7743  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_tx_skb_unmap(struct tg3_napi *tnapi, u32 entry, int last)
{
  int i;
  struct sk_buff *skb;
  unsigned int tmp;
  
#line 7747 
  struct tg3_tx_ring_info *txb = tnapi->tx_buffers + entry;
  
#line 7749 
  skb = txb->skb;
  
#line 7750 
  txb->skb = (struct sk_buff *)0;
  
#line 7754 
  tmp = skb_headlen((struct sk_buff const *)skb);
  
#line 7752 
  ;
  
#line 7752 
  ;
  
#line 7752 
  pci_unmap_single((tnapi->tp)->pdev,txb->mapping,(unsigned long)tmp,1);
  
#line 7757 
  goto ldv_57597;
  ldv_57596: 
#line 7758 
  ;
  
#line 7758 
  txb->fragmented = (_Bool)0;
  
#line 7759 
  entry = (entry + 1U) & 511U;
  
#line 7760 
  txb = tnapi->tx_buffers + entry;
  ldv_57597: 
#line 7761 
  ;
  
#line 7757 
  if ((int)txb->fragmented != 0) 
#line 7759 
                                 goto ldv_57596; else 
#line 7762 
                                                      goto ldv_57598;
  ldv_57598: 
#line 7763 
  ;
  
#line 7763 
  i = 0;
  
#line 7763 
  goto ldv_57604;
  ldv_57603: 
#line 7764 
  ;
  {
    unsigned char *tmp_0;
    unsigned int tmp_1;
    
#line 7764 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 7764 
    skb_frag_t const *frag = (skb_frag_t const *)(& ((struct skb_shared_info *)tmp_0)->frags[i]);
    
#line 7766 
    entry = (entry + 1U) & 511U;
    
#line 7767 
    txb = tnapi->tx_buffers + entry;
    
#line 7771 
    tmp_1 = skb_frag_size(frag);
    
#line 7769 
    ;
    
#line 7769 
    ;
    
#line 7769 
    pci_unmap_page((tnapi->tp)->pdev,txb->mapping,(unsigned long)tmp_1,1);
    
#line 7773 
    goto ldv_57601;
    ldv_57600: 
#line 7774 
    ;
    
#line 7774 
    txb->fragmented = (_Bool)0;
    
#line 7775 
    entry = (entry + 1U) & 511U;
    
#line 7776 
    txb = tnapi->tx_buffers + entry;
    ldv_57601: 
#line 7777 
    ;
    
#line 7773 
    if ((int)txb->fragmented != 0) 
#line 7775 
                                   goto ldv_57600; else 
#line 7778 
                                                        goto ldv_57602;
    ldv_57602: 
#line 7779 
    ;
  }
  
#line 7763 
  i += 1;
  ldv_57604: 
#line 7764 
  ;
  
#line 7763 
  if (i <= last) 
#line 7765 
                 goto ldv_57603; else 
#line 7768 
                                      goto ldv_57605;
  ldv_57605: 
#line 7769 
  ;
  
#line 7770 
  return;
}


#line 7782  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tigon3_dma_hwbug_workaround(struct tg3_napi *tnapi, struct sk_buff **pskb, u32 *entry, u32 *budget, u32 base_flags, u32 mss, u32 vlan)
{
  struct sk_buff *new_skb;
  
#line 7787 
  struct tg3 *tp = tnapi->tp;
  
#line 7788 
  struct sk_buff *skb = *pskb;
  
#line 7789 
  dma_addr_t new_addr = 0ULL;
  
#line 7790 
  int ret = 0;
  
#line 7792 
  if (tp->pci_chip_rev_id >> 12 != 0U) 
#line 7793 
                                       new_skb = skb_copy((struct sk_buff const *)skb,32U);
  else {
    int tmp;
    unsigned int tmp_0;
    
#line 7795 
    int more_headroom = (int)((long)4U - ((long)skb->data & (long)3U));
    
#line 7798 
    tmp = skb_tailroom((struct sk_buff const *)skb);
    
#line 7798 
    tmp_0 = skb_headroom((struct sk_buff const *)skb);
    
#line 7797 
    ;
    
#line 7797 
    ;
    
#line 7797 
    new_skb = skb_copy_expand((struct sk_buff const *)skb,(int)(tmp_0 + (unsigned int)more_headroom),tmp,32U);
  }
  
#line 7802 
  if (new_skb == (struct sk_buff *)0) 
#line 7803 
                                      ret = -1;
  else {
    int tmp_2;
    
#line 7806 
    new_addr = pci_map_single(tp->pdev,(void *)new_skb->data,(unsigned long)new_skb->len,1);
    
#line 7809 
    tmp_2 = pci_dma_mapping_error(tp->pdev,new_addr);
    
#line 7809 
    if (tmp_2 != 0) {
      
#line 7810 
      dev_kfree_skb_any(new_skb);
      
#line 7811 
      ret = -1;
    }
    else {
      bool tmp_1;
      
#line 7813 
      u32 save_entry = *entry;
      
#line 7815 
      base_flags |= 4U;
      
#line 7817 
      (tnapi->tx_buffers + *entry)->skb = new_skb;
      
#line 7818 
      (tnapi->tx_buffers + *entry)->mapping = new_addr;
      
#line 7821 
      tmp_1 = tg3_tx_frag_set(tnapi,entry,budget,new_addr,new_skb->len,base_flags,mss,vlan);
      
#line 7821 
      if ((int)tmp_1 != 0) {
        
#line 7824 
        tg3_tx_skb_unmap(tnapi,save_entry,-1);
        
#line 7825 
        dev_kfree_skb_any(new_skb);
        
#line 7826 
        ret = -1;
      }
      else ;
    }
  }
  
#line 7831 
  dev_kfree_skb_any(skb);
  
#line 7832 
  *pskb = new_skb;
  
#line 7833 
  return ret;
}


#line 7836 
static netdev_tx_t tg3_start_xmit(struct sk_buff *skb, struct net_device *dev);


#line 7841  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_tso_bug(struct tg3 *tp, struct tg3_napi *tnapi, struct netdev_queue *txq, struct sk_buff *skb)
{
  int __retres;
  struct sk_buff *segs;
  struct sk_buff *nskb;
  unsigned char *tmp;
  u32 tmp_1;
  bool tmp_2;
  
#line 7845 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 7845 
  u32 frag_cnt_est = (unsigned int)((int)((struct skb_shared_info *)tmp)->gso_segs * 3);
  
#line 7848 
  tmp_1 = tg3_tx_avail(tnapi);
  
#line 7848 
  ;
  
#line 7848 
  if ((long)(tmp_1 <= frag_cnt_est) != 0L) {
    u32 tmp_0;
    
#line 7849 
    netif_tx_start_queue(txq);
    
#line 7850 
    ldv_inline_asm();
    
#line 7857 
    tmp_0 = tg3_tx_avail(tnapi);
    
#line 7857 
    ;
    
#line 7857 
    if (tmp_0 <= frag_cnt_est) {
      
#line 7858 
      __retres = 16;
      
#line 7858 
      goto return_label;
    }
    else ;
    
#line 7860 
    netif_tx_wake_queue(txq);
  }
  else ;
  
#line 7863 
  segs = skb_gso_segment(skb,(tp->dev)->features & 18446744073708437503ULL);
  
#line 7865 
  tmp_2 = IS_ERR((void const *)segs);
  
#line 7865 
  if ((int)tmp_2 != 0) 
#line 7866 
                       goto tg3_tso_bug_end;
  else 
    
#line 7865 
    if (segs == (struct sk_buff *)0) 
#line 7866 
                                     goto tg3_tso_bug_end; else ;
  ldv_57635: 
#line 7867 
  ;
  
#line 7869 
  nskb = segs;
  
#line 7870 
  segs = segs->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.next;
  
#line 7871 
  nskb->__anonCompField_sk_buff_87.__anonCompField___anonunion_290_86.next = (struct sk_buff *)0;
  
#line 7872 
  tg3_start_xmit(nskb,tp->dev);
  
#line 7873 
  if (segs != (struct sk_buff *)0) 
#line 7875 
                                   goto ldv_57635; else 
#line 7878 
                                                        goto ldv_57636;
  ldv_57636: 
#line 7879 
  ;
  tg3_tso_bug_end: 
#line 7875 
  ;
  
#line 7876 
  dev_kfree_skb_any(skb);
  
#line 7878 
  __retres = 0;
  return_label: 
#line 7878 
                return __retres;
}


#line 7882  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static netdev_tx_t tg3_start_xmit(struct sk_buff *skb, struct net_device *dev)
{
  netdev_tx_t __retres;
  u32 len;
  u32 entry;
  u32 base_flags;
  u32 mss;
  u32 budget;
  int would_hit_hwbug;
  dma_addr_t mapping;
  struct tg3_napi *tnapi;
  struct netdev_queue *txq;
  unsigned int last;
  u16 tmp_0;
  u16 tmp_1;
  int tmp_2;
  unsigned char *tmp_5;
  unsigned char *tmp_6;
  int tmp_24;
  unsigned char *tmp_27;
  int tmp_29;
  int tmp_30;
  bool tmp_42;
  int tmp_41;
  unsigned char *tmp_40;
  u32 tmp_46;
  
#line 7884 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 7885 
  u32 vlan = 0U;
  
#line 7887 
  int i = -1;
  
#line 7892 
  struct iphdr *iph = (struct iphdr *)0;
  
#line 7893 
  struct tcphdr *tcph = (struct tcphdr *)0;
  
#line 7894 
  __sum16 tcp_csum = (unsigned short)0U;
  
#line 7894 
  __sum16 ip_csum = (unsigned short)0U;
  
#line 7895 
  __be16 ip_tot_len = (unsigned short)0U;
  
#line 7897 
  tmp_0 = skb_get_queue_mapping((struct sk_buff const *)skb);
  
#line 7897 
  ;
  
#line 7897 
  txq = netdev_get_tx_queue((struct net_device const *)dev,(unsigned int)tmp_0);
  
#line 7898 
  tmp_1 = skb_get_queue_mapping((struct sk_buff const *)skb);
  
#line 7898 
  tnapi = & tp->napi[(int)tmp_1];
  
#line 7899 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
  
#line 7899 
  if (tmp_2 != 0) 
#line 7900 
                  tnapi += 1; else ;
  
#line 7902 
  budget = tg3_tx_avail(tnapi);
  
#line 7909 
  tmp_5 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 7909 
  ;
  
#line 7909 
  if ((long)((unsigned int)((int)((struct skb_shared_info *)tmp_5)->nr_frags + 1) >= budget) != 0L) {
    int tmp_4;
    bool tmp_3;
    
#line 7910 
    tmp_3 = netif_tx_queue_stopped((struct netdev_queue const *)txq);
    
#line 7910 
    if (tmp_3) 
#line 7910 
               tmp_4 = 0; else 
#line 7910 
                               tmp_4 = 1;
    
#line 7910 
    if (tmp_4) {
      
#line 7911 
      netif_tx_start_queue(txq);
      
#line 7914 
      netdev_err((struct net_device const *)dev,"BUG! Tx Ring full when queue awake!\n");
    }
    else ;
    
#line 7917 
    __retres = NETDEV_TX_BUSY;
    
#line 7917 
    goto return_label;
  }
  else ;
  
#line 7920 
  entry = tnapi->tx_prod;
  
#line 7921 
  base_flags = 0U;
  
#line 7923 
  tmp_6 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 7923 
  mss = (unsigned int)((struct skb_shared_info *)tmp_6)->gso_size;
  
#line 7924 
  if (mss != 0U) {
    u32 tcp_opt_len;
    u32 hdr_len;
    int tmp_7;
    int tmp_8;
    unsigned int tmp_9;
    int tmp_15;
    bool tmp_14;
    int tmp_17;
    int tmp_22;
    
#line 7927 
    tmp_7 = skb_cow_head(skb,0U);
    
#line 7927 
    if (tmp_7 != 0) 
#line 7928 
                    goto drop; else ;
    
#line 7930 
    iph = ip_hdr((struct sk_buff const *)skb);
    
#line 7931 
    tcp_opt_len = tcp_optlen((struct sk_buff const *)skb);
    
#line 7933 
    tmp_8 = skb_transport_offset((struct sk_buff const *)skb);
    
#line 7933 
    tmp_9 = tcp_hdrlen((struct sk_buff const *)skb);
    
#line 7933 
    hdr_len = ((unsigned int)tmp_8 + tmp_9) + 4294967282U;
    
#line 7938 
    if ((unsigned int)skb->protocol == 129U || (unsigned int)skb->protocol == 43144U) {
      int tmp_10;
      
#line 7940 
      tmp_10 = tg3_tso_bug(tp,tnapi,txq,skb);
      
#line 7940 
      __retres = (enum netdev_tx)tmp_10;
      
#line 7940 
      goto return_label;
    }
    else ;
    
#line 7942 
    tmp_14 = skb_is_gso_v6((struct sk_buff const *)skb);
    
#line 7942 
    if (tmp_14) 
#line 7942 
                tmp_15 = 0; else 
#line 7942 
                                 tmp_15 = 1;
    
#line 7942 
    if (tmp_15) {
      
#line 7943 
      if ((long)(hdr_len + 14U > 80U) != 0L) {
        int tmp_12;
        
#line 7943 
        tmp_12 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_BUG,(unsigned long *)(& tp->tg3_flags));
        
#line 7943 
        if (tmp_12 != 0) {
          int tmp_11;
          
#line 7945 
          tmp_11 = tg3_tso_bug(tp,tnapi,txq,skb);
          
#line 7945 
          __retres = (enum netdev_tx)tmp_11;
          
#line 7945 
          goto return_label;
        }
        else ;
      }
      else ;
      
#line 7947 
      ip_csum = iph->check;
      
#line 7948 
      ip_tot_len = iph->tot_len;
      
#line 7949 
      iph->check = (unsigned short)0U;
      
#line 7950 
      if (0 != 0) 
#line 7950 
                  iph->tot_len = (unsigned short)((((int)((unsigned short)mss) + (int)((unsigned short)hdr_len)) << 8) | (((int)((unsigned short)mss) + (int)((unsigned short)hdr_len)) >> 8)); else 
                                                                    
#line 7950 
                                                                    iph->tot_len = __fswab16((unsigned short)((int)((unsigned short)mss) + (int)((unsigned short)hdr_len)));
    }
    else ;
    
#line 7953 
    base_flags |= 768U;
    
#line 7956 
    tcph = tcp_hdr((struct sk_buff const *)skb);
    
#line 7957 
    tcp_csum = tcph->check;
    
#line 7959 
    tmp_17 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
    
#line 7959 
    if (tmp_17 != 0) 
#line 7959 
                     goto _LOR;
    else {
      int tmp_18;
      
#line 7959 
      tmp_18 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
      
#line 7959 
      if (tmp_18 != 0) 
#line 7959 
                       goto _LOR;
      else {
        int tmp_19;
        
#line 7960 
        tmp_19 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
        
#line 7960 
        if (tmp_19 != 0) {
          _LOR: {
                  
#line 7962 
                  tcph->check = (unsigned short)0U;
                  
#line 7963 
                  base_flags &= 4294967294U;
                }
        }
        else {
          __sum16 tmp_16;
          
#line 7965 
          tmp_16 = csum_tcpudp_magic(iph->saddr,iph->daddr,(unsigned short)0,(unsigned short)6,0U);
          
#line 7965 
          tcph->check = (unsigned short)(~ ((int)tmp_16));
        }
      }
    }
    
#line 7969 
    tmp_22 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
    
#line 7969 
    if (tmp_22 != 0) {
      
#line 7970 
      mss = ((hdr_len << 12) & 49152U) | mss;
      
#line 7971 
      if ((hdr_len & 16U) != 0U) 
#line 7972 
                                 base_flags |= 16U; else ;
      
#line 7973 
      base_flags = ((hdr_len << 5) & 31744U) | base_flags;
    }
    else {
      int tmp_21;
      
#line 7974 
      tmp_21 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
      
#line 7974 
      if (tmp_21 != 0) 
#line 7975 
                       mss = (hdr_len << 9) | mss;
      else {
        int tmp_20;
        
#line 7976 
        tmp_20 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
        
#line 7976 
        if (tmp_20 != 0) 
#line 7976 
                         goto _LOR_0;
        else 
          
#line 7976 
          if (tp->pci_chip_rev_id >> 12 == 3U) {
            _LOR_0: 
#line 7978 
                    if (tcp_opt_len != 0U || (unsigned int)iph->ihl > 5U) {
                      int tsflags;
                      
#line 7981 
                      tsflags = (int)(((unsigned int)iph->ihl + (tcp_opt_len >> 2)) + 4294967291U);
                      
#line 7982 
                      mss = (unsigned int)(tsflags << 11) | mss;
                    }
                    else ;
          }
          else 
            
#line 7985 
            if (tcp_opt_len != 0U || (unsigned int)iph->ihl > 5U) {
              int tsflags_0;
              
#line 7988 
              tsflags_0 = (int)(((unsigned int)iph->ihl + (tcp_opt_len >> 2)) + 4294967291U);
              
#line 7989 
              base_flags = (unsigned int)(tsflags_0 << 12) | base_flags;
            }
            else ;
      }
    }
  }
  else 
    
#line 7992 
    if ((unsigned int)*((unsigned char *)skb + 145UL) == 6U) 
      
#line 7996 
      if ((unsigned int)skb->protocol == 129U || (unsigned int)skb->protocol == 43144U) {
        int tmp_23;
        
#line 7998 
        tmp_23 = skb_checksum_help(skb);
        
#line 7998 
        if (tmp_23 != 0) 
#line 7999 
                         goto drop; else ;
      }
      else 
#line 8001 
           base_flags |= 1U;
    else ;
  
#line 8005 
  tmp_24 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_JUMBO_BDFLAG,(unsigned long *)(& tp->tg3_flags));
  
#line 8005 
  if (tmp_24 != 0) {
    
#line 8005 
    if (mss == 0U) {
      
#line 8006 
      if (skb->len > 1518U) 
#line 8007 
                            base_flags |= 8U; else ;
    }
    else ;
  }
  else ;
  
#line 8009 
  if (((int)skb->vlan_tci & 4096) != 0) {
    
#line 8010 
    base_flags |= 64U;
    
#line 8011 
    vlan = (unsigned int)skb->vlan_tci & 4294963199U;
  }
  else ;
  
#line 8014 
  tmp_27 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 8014 
  ;
  
#line 8014 
  if ((long)(((int)((struct skb_shared_info *)tmp_27)->tx_flags & 1) != 0) != 0L) {
    int tmp_28;
    
#line 8014 
    tmp_28 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TX_TSTAMP_EN,(unsigned long *)(& tp->tg3_flags));
    
#line 8014 
    if (tmp_28 != 0) {
      unsigned char *tmp_25;
      unsigned char *tmp_26;
      
#line 8016 
      tmp_25 = skb_end_pointer((struct sk_buff const *)skb);
      
#line 8016 
      tmp_26 = skb_end_pointer((struct sk_buff const *)skb);
      
#line 8016 
      ((struct skb_shared_info *)tmp_25)->tx_flags = (unsigned char)((unsigned int)((struct skb_shared_info *)tmp_26)->tx_flags | 4U);
      
#line 8017 
      base_flags |= 32U;
    }
    else ;
  }
  else ;
  
#line 8020 
  len = skb_headlen((struct sk_buff const *)skb);
  
#line 8022 
  mapping = pci_map_single(tp->pdev,(void *)skb->data,(unsigned long)len,1);
  
#line 8023 
  tmp_29 = pci_dma_mapping_error(tp->pdev,mapping);
  
#line 8023 
  if (tmp_29 != 0) 
#line 8024 
                   goto drop; else ;
  
#line 8027 
  (tnapi->tx_buffers + entry)->skb = skb;
  
#line 8028 
  (tnapi->tx_buffers + entry)->mapping = mapping;
  
#line 8030 
  would_hit_hwbug = 0;
  
#line 8032 
  tmp_30 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5701_DMA_BUG,(unsigned long *)(& tp->tg3_flags));
  
#line 8032 
  if (tmp_30 != 0) 
#line 8033 
                   would_hit_hwbug = 1; else ;
  
#line 8035 
  ;
  
#line 8035 
  ;
  
#line 8036 
  tmp_40 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 8036 
  ;
  
#line 8036 
  if ((unsigned int)((struct skb_shared_info *)tmp_40)->nr_frags == 0U) 
    
#line 8036 
    tmp_41 = 4; else 
#line 8036 
                     tmp_41 = 0;
  
#line 8035 
  ;
  
#line 8035 
  ;
  
#line 8035 
  ;
  
#line 8035 
  ;
  
#line 8035 
  tmp_42 = tg3_tx_frag_set(tnapi,& entry,& budget,mapping,len,(unsigned int)tmp_41 | base_flags,mss,vlan);
  
#line 8035 
  if ((int)tmp_42 != 0) 
#line 8038 
                        would_hit_hwbug = 1;
  else {
    unsigned char *tmp_39;
    
#line 8039 
    tmp_39 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 8039 
    ;
    
#line 8039 
    if ((unsigned int)((struct skb_shared_info *)tmp_39)->nr_frags != 0U) {
      int tmp_31;
      unsigned char *tmp_34;
      
#line 8040 
      u32 tmp_mss = mss;
      
#line 8042 
      tmp_31 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
      
#line 8042 
      if (tmp_31 == 0) {
        int tmp_32;
        
#line 8042 
        tmp_32 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
        
#line 8042 
        if (tmp_32 == 0) {
          int tmp_33;
          
#line 8043 
          tmp_33 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
          
#line 8043 
          if (tmp_33 == 0) 
#line 8045 
                           tmp_mss = 0U; else ;
        }
        else ;
      }
      else ;
      
#line 8050 
      tmp_34 = skb_end_pointer((struct sk_buff const *)skb);
      
#line 8050 
      last = (unsigned int)((int)((struct skb_shared_info *)tmp_34)->nr_frags + -1);
      
#line 8051 
      i = 0;
      
#line 8051 
      goto ldv_57669;
      ldv_57668: 
#line 8052 
      ;
      {
        unsigned char *tmp_35;
        int tmp_36;
        
#line 8052 
        tmp_35 = skb_end_pointer((struct sk_buff const *)skb);
        
#line 8052 
        skb_frag_t *frag = & ((struct skb_shared_info *)tmp_35)->frags[i];
        
#line 8054 
        len = skb_frag_size((skb_frag_t const *)frag);
        
#line 8055 
        mapping = skb_frag_dma_map(& (tp->pdev)->dev,(skb_frag_t const *)frag,0UL,(unsigned long)len,(enum dma_data_direction)DMA_TO_DEVICE);
        
#line 8058 
        (tnapi->tx_buffers + entry)->skb = (struct sk_buff *)0;
        
#line 8059 
        (tnapi->tx_buffers + entry)->mapping = mapping;
        
#line 8061 
        tmp_36 = dma_mapping_error(& (tp->pdev)->dev,mapping);
        
#line 8061 
        if (tmp_36 != 0) 
#line 8062 
                         goto dma_error; else ;
        
#line 8064 
        if (budget == 0U) 
#line 8064 
                          goto _LOR_1;
        else {
          bool tmp_38;
          int tmp_37;
          
#line 8064 
          ;
          
#line 8064 
          ;
          
#line 8067 
          if ((unsigned int)i == last) 
#line 8067 
                                       tmp_37 = 4; else 
#line 8067 
                                                        tmp_37 = 0;
          
#line 8064 
          ;
          
#line 8064 
          ;
          
#line 8064 
          ;
          
#line 8064 
          ;
          
#line 8064 
          tmp_38 = tg3_tx_frag_set(tnapi,& entry,& budget,mapping,len,(unsigned int)tmp_37 | base_flags,tmp_mss,vlan);
          
#line 8064 
          if ((int)tmp_38 != 0) {
            _LOR_1: {
                      
#line 8069 
                      would_hit_hwbug = 1;
                      
#line 8070 
                      goto ldv_57667;
                    }
          }
          else ;
        }
      }
      
#line 8051 
      i += 1;
      ldv_57669: 
#line 8052 
      ;
      
#line 8051 
      if ((unsigned int)i <= last) 
#line 8053 
                                   goto ldv_57668; else 
#line 8056 
                                                        goto ldv_57667;
      ldv_57667: 
#line 8057 
      ;
    }
    else ;
  }
  
#line 8075 
  if (would_hit_hwbug != 0) {
    int tmp_44;
    
#line 8076 
    tg3_tx_skb_unmap(tnapi,tnapi->tx_prod,i);
    
#line 8078 
    if (mss != 0U) {
      int tmp_43;
      
#line 8082 
      if ((unsigned int)ip_tot_len != 0U) {
        
#line 8083 
        iph->check = ip_csum;
        
#line 8084 
        iph->tot_len = ip_tot_len;
      }
      else ;
      
#line 8086 
      tcph->check = tcp_csum;
      
#line 8087 
      tmp_43 = tg3_tso_bug(tp,tnapi,txq,skb);
      
#line 8087 
      __retres = (enum netdev_tx)tmp_43;
      
#line 8087 
      goto return_label;
    }
    else ;
    
#line 8093 
    entry = tnapi->tx_prod;
    
#line 8094 
    budget = tg3_tx_avail(tnapi);
    
#line 8095 
    tmp_44 = tigon3_dma_hwbug_workaround(tnapi,& skb,& entry,& budget,base_flags,mss,vlan);
    
#line 8095 
    if (tmp_44 != 0) 
#line 8097 
                     goto drop_nofree; else ;
  }
  else ;
  
#line 8100 
  skb_tx_timestamp(skb);
  
#line 8101 
  netdev_tx_sent_queue(txq,skb->len);
  
#line 8102 
  ldv_inline_asm();
  
#line 8106 
  tnapi->tx_prod = entry;
  
#line 8107 
  tmp_46 = tg3_tx_avail(tnapi);
  
#line 8107 
  if ((long)(tmp_46 <= 18U) != 0L) {
    u32 tmp_45;
    
#line 8108 
    netif_tx_start_queue(txq);
    
#line 8109 
    ldv_inline_asm();
    
#line 8116 
    tmp_45 = tg3_tx_avail(tnapi);
    
#line 8116 
    ;
    
#line 8116 
    if (tmp_45 > tnapi->tx_pending / 4U) 
#line 8117 
                                         netif_tx_wake_queue(txq); else ;
  }
  else ;
  
#line 8120 
  if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) 
#line 8120 
                                                           goto _LOR_2;
  else {
    bool tmp_47;
    
#line 8120 
    tmp_47 = netif_xmit_stopped((struct netdev_queue const *)txq);
    
#line 8120 
    if ((int)tmp_47 != 0) {
      _LOR_2: {
                
#line 8122 
                (*(tp->write32_tx_mbox))(tp,tnapi->prodmbox,entry);
                
#line 8123 
                ldv_inline_asm();
              }
    }
    else ;
  }
  
#line 8126 
  __retres = NETDEV_TX_OK;
  
#line 8126 
  goto return_label;
  dma_error: 
#line 8128 
  ;
  
#line 8129 
  i -= 1;
  
#line 8129 
  ;
  
#line 8129 
  ;
  
#line 8129 
  tg3_tx_skb_unmap(tnapi,tnapi->tx_prod,i);
  
#line 8130 
  (tnapi->tx_buffers + tnapi->tx_prod)->skb = (struct sk_buff *)0;
  drop: 
#line 8131 
  ;
  
#line 8132 
  dev_kfree_skb_any(skb);
  drop_nofree: 
#line 8133 
  ;
  
#line 8134 
  tp->tx_dropped += 1UL;
  
#line 8135 
  __retres = NETDEV_TX_OK;
  return_label: 
#line 8135 
                return __retres;
}


#line 8138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_mac_loopback(struct tg3 *tp, bool enable)
{
  
#line 8140 
  if ((int)enable != 0) {
    int tmp;
    
#line 8141 
    tp->mac_mode &= 4294967281U;
    
#line 8144 
    tp->mac_mode |= 16U;
    
#line 8146 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 8146 
    if (tmp == 0) 
#line 8147 
                  tp->mac_mode |= 1024U; else ;
    
#line 8149 
    if ((tp->phy_flags & 128U) != 0U) 
#line 8150 
                                      tp->mac_mode |= 4U; else 
#line 8152 
                                                               tp->mac_mode |= 8U;
  }
  else {
    int tmp_0;
    
#line 8154 
    tp->mac_mode &= 4294967279U;
    
#line 8156 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 8156 
    if (tmp_0 != 0) 
#line 8159 
                    tp->mac_mode &= 4294966271U;
    else 
      
#line 8156 
      if ((tp->phy_flags & 16U) != 0U) 
#line 8159 
                                       tp->mac_mode &= 4294966271U;
      else 
        
#line 8157 
        if (tp->pci_chip_rev_id >> 12 == 7U) 
#line 8159 
                                             tp->mac_mode &= 4294966271U; else ;
  }
  
#line 8162 
  (*(tp->write32))(tp,1024U,tp->mac_mode);
  
#line 8163 
  __const_udelay(171800UL);
  
#line 8165 
  return;
}


#line 8166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_lpbk_set(struct tg3 *tp, u32 speed, bool extlpbk)
{
  int __retres;
  u32 val;
  u32 bmcr;
  u32 mac_mode;
  
#line 8168 
  u32 ptest = 0U;
  
#line 8170 
  tg3_phy_toggle_apd(tp,(_Bool)0);
  
#line 8171 
  tg3_phy_toggle_automdix(tp,(_Bool)0);
  
#line 8173 
  if ((int)extlpbk != 0) {
    int tmp;
    
#line 8173 
    tmp = tg3_phy_set_extloopbk(tp);
    
#line 8173 
    if (tmp != 0) {
      
#line 8174 
      __retres = -5;
      
#line 8174 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 8176 
  bmcr = 256U;
  
#line 8177 
  switch (speed) {
    case (u32)10: 
#line 8178 
    ;
    
#line 8179 
    goto ldv_57685;
    case (u32)100: 
#line 8180 
    ;
    
#line 8181 
    bmcr |= 8192U;
    
#line 8182 
    goto ldv_57685;
    case (u32)1000: 
#line 8183 
    ;
    default: 
#line 8184 
    ;
    
#line 8185 
    if ((tp->phy_flags & 64U) != 0U) {
      
#line 8186 
      speed = 100U;
      
#line 8187 
      bmcr |= 8192U;
    }
    else {
      
#line 8189 
      speed = 1000U;
      
#line 8190 
      bmcr |= 64U;
    }
  }
  ldv_57685: 
#line 8194 
  ;
  
#line 8194 
  if ((int)extlpbk != 0) 
    
#line 8195 
    if ((tp->phy_flags & 64U) == 0U) {
      
#line 8196 
      tg3_readphy(tp,9,& val);
      
#line 8197 
      val |= 6144U;
      
#line 8199 
      tg3_writephy(tp,9,val);
    }
    else {
      
#line 8201 
      ptest = 18U;
      
#line 8203 
      tg3_writephy(tp,23,ptest);
    }
  else 
#line 8206 
       bmcr |= 16384U;
  
#line 8208 
  tg3_writephy(tp,0,bmcr);
  
#line 8211 
  if ((tp->phy_flags & 64U) != 0U) 
#line 8212 
                                   tg3_readphy(tp,0,& bmcr); else ;
  
#line 8214 
  __const_udelay(171800UL);
  
#line 8216 
  if ((tp->phy_flags & 64U) != 0U && tp->pci_chip_rev_id >> 12 == 22405U) {
    
#line 8218 
    tg3_writephy(tp,23,ptest | 6144U);
    
#line 8223 
    tg3_readphy(tp,23,& val);
  }
  else ;
  
#line 8227 
  if ((tp->phy_flags & 32U) != 0U) {
    int tmp_0;
    
#line 8227 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 8227 
    if (tmp_0 != 0) {
      
#line 8229 
      _tw32_flush(tp,1128U,1U,0U);
      
#line 8230 
      __const_udelay(42950UL);
      
#line 8231 
      _tw32_flush(tp,1128U,tp->rx_mode,0U);
    }
    else ;
  }
  else ;
  
#line 8234 
  mac_mode = tp->mac_mode & 4294967281U;
  
#line 8236 
  if (speed == 1000U) 
#line 8237 
                      mac_mode |= 8U; else 
#line 8239 
                                           mac_mode |= 4U;
  
#line 8241 
  if (tp->pci_chip_rev_id >> 12 == 7U) {
    
#line 8242 
    u32 masked_phy_id = tp->phy_id & 4294967280U;
    
#line 8244 
    if (masked_phy_id == 1610645584U) 
#line 8245 
                                      mac_mode &= 4294966271U;
    else 
      
#line 8246 
      if (masked_phy_id == 1610645616U) 
#line 8247 
                                        mac_mode |= 1024U; else ;
    
#line 8249 
    tg3_writephy(tp,16,2U);
  }
  else ;
  
#line 8253 
  (*(tp->write32))(tp,1024U,mac_mode);
  
#line 8254 
  __const_udelay(171800UL);
  
#line 8256 
  __retres = 0;
  return_label: 
#line 8256 
                return __retres;
}


#line 8259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_set_loopback(struct net_device *dev, netdev_features_t features)
{
  
#line 8261 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 8263 
  if ((features & 68719476736ULL) != 0ULL) {
    
#line 8264 
    if ((tp->mac_mode & 16U) != 0U) 
#line 8265 
                                    goto return_label; else ;
    
#line 8267 
    ldv_spin_lock_bh_99(& tp->lock);
    
#line 8268 
    tg3_mac_loopback(tp,(_Bool)1);
    
#line 8269 
    netif_carrier_on(tp->dev);
    
#line 8270 
    ldv_spin_unlock_bh_100(& tp->lock);
    
#line 8271 
    netdev_info((struct net_device const *)dev,"Internal MAC loopback mode enabled.\n");
  }
  else {
    
#line 8273 
    if ((tp->mac_mode & 16U) == 0U) 
#line 8274 
                                    goto return_label; else ;
    
#line 8276 
    ldv_spin_lock_bh_101(& tp->lock);
    
#line 8277 
    tg3_mac_loopback(tp,(_Bool)0);
    
#line 8279 
    tg3_setup_phy(tp,(_Bool)1);
    
#line 8280 
    ldv_spin_unlock_bh_102(& tp->lock);
    
#line 8281 
    netdev_info((struct net_device const *)dev,"Internal MAC loopback mode disabled.\n");
  }
  return_label: 
#line 8283 
                return;
}


#line 8285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static netdev_features_t tg3_fix_features(struct net_device *dev, netdev_features_t features)
{
  
#line 8288 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 8290 
  if (dev->mtu > 1500U) {
    int tmp_0;
    
#line 8290 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 8290 
    if (tmp_0 != 0) 
#line 8291 
                    features &= 18446744073707913215ULL; else ;
  }
  else ;
  
#line 8293 
  return features;
}


#line 8296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_features(struct net_device *dev, netdev_features_t features)
{
  int __retres;
  
#line 8298 
  netdev_features_t changed = dev->features ^ features;
  
#line 8300 
  if ((changed & 68719476736ULL) != 0ULL) {
    bool tmp;
    
#line 8300 
    tmp = netif_running((struct net_device const *)dev);
    
#line 8300 
    if ((int)tmp != 0) 
#line 8301 
                       tg3_set_loopback(dev,features); else ;
  }
  else ;
  
#line 8303 
  __retres = 0;
  
#line 8303 
  return __retres;
}


#line 8306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rx_prodring_free(struct tg3 *tp, struct tg3_rx_prodring_set *tpr)
{
  int i;
  int tmp_0;
  
#line 8311 
  if (& tp->napi[0].prodring != tpr) {
    int tmp;
    
#line 8312 
    i = (int)tpr->rx_std_cons_idx;
    
#line 8312 
    goto ldv_57711;
    ldv_57710: 
#line 8313 
    ;
    
#line 8314 
    tg3_rx_data_free(tp,tpr->rx_std_buffers + i,tp->rx_pkt_map_sz);
    
#line 8313 
    i = (int)((unsigned int)(i + 1) & tp->rx_std_ring_mask);
    ldv_57711: 
#line 8314 
    ;
    
#line 8312 
    if (tpr->rx_std_prod_idx != (unsigned int)i) 
#line 8314 
                                                 goto ldv_57710; else 
                                                                   
#line 8317 
                                                                   goto ldv_57712;
    ldv_57712: 
#line 8318 
    ;
    
#line 8317 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 8317 
    if (tmp != 0) {
      
#line 8318 
      i = (int)tpr->rx_jmb_cons_idx;
      
#line 8318 
      goto ldv_57714;
      ldv_57713: 
#line 8319 
      ;
      
#line 8321 
      tg3_rx_data_free(tp,tpr->rx_jmb_buffers + i,9110U);
      
#line 8320 
      i = (int)((unsigned int)(i + 1) & tp->rx_jmb_ring_mask);
      ldv_57714: 
#line 8321 
      ;
      
#line 8318 
      if (tpr->rx_jmb_prod_idx != (unsigned int)i) 
#line 8321 
                                                   goto ldv_57713; else 
                                                                    
#line 8324 
                                                                    goto ldv_57715;
      ldv_57715: 
#line 8325 
      ;
    }
    else ;
    
#line 8326 
    goto return_label;
  }
  else ;
  
#line 8329 
  i = 0;
  
#line 8329 
  goto ldv_57717;
  ldv_57716: 
#line 8330 
  ;
  
#line 8330 
  tg3_rx_data_free(tp,tpr->rx_std_buffers + i,tp->rx_pkt_map_sz);
  
#line 8329 
  i += 1;
  ldv_57717: 
#line 8330 
  ;
  
#line 8329 
  if (tp->rx_std_ring_mask >= (unsigned int)i) 
#line 8331 
                                               goto ldv_57716; else 
#line 8334 
                                                                    goto ldv_57718;
  ldv_57718: 
#line 8335 
  ;
  
#line 8333 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 8333 
  if (tmp_0 != 0) {
    int tmp_1;
    
#line 8333 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 8333 
    if (tmp_1 == 0) {
      
#line 8334 
      i = 0;
      
#line 8334 
      goto ldv_57720;
      ldv_57719: 
#line 8335 
      ;
      
#line 8335 
      tg3_rx_data_free(tp,tpr->rx_jmb_buffers + i,9110U);
      
#line 8334 
      i += 1;
      ldv_57720: 
#line 8335 
      ;
      
#line 8334 
      if (tp->rx_jmb_ring_mask >= (unsigned int)i) 
#line 8336 
                                                   goto ldv_57719; else 
                                                                    
#line 8339 
                                                                    goto ldv_57721;
      ldv_57721: 
#line 8340 
      ;
    }
    else ;
  }
  else ;
  return_label: 
#line 8342 
                return;
}


#line 8347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_rx_prodring_alloc(struct tg3 *tp, struct tg3_rx_prodring_set *tpr)
{
  int __retres;
  u32 i;
  u32 rx_pkt_dma_sz;
  int tmp_4;
  int tmp_3;
  int tmp_5;
  int tmp_7;
  int tmp_10;
  int tmp_9;
  int tmp_11;
  
#line 8352 
  tpr->rx_std_cons_idx = 0U;
  
#line 8353 
  tpr->rx_std_prod_idx = 0U;
  
#line 8354 
  tpr->rx_jmb_cons_idx = 0U;
  
#line 8355 
  tpr->rx_jmb_prod_idx = 0U;
  
#line 8357 
  if (& tp->napi[0].prodring != tpr) {
    int tmp_0;
    int tmp;
    
#line 8359 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
    
#line 8359 
    if (tmp != 0) 
#line 8359 
                  tmp_0 = 2048; else 
#line 8359 
                                     tmp_0 = 512;
    
#line 8358 
    ;
    
#line 8358 
    memset((void *)tpr->rx_std_buffers,0,(unsigned long)tmp_0 * 16UL);
    
#line 8360 
    if (tpr->rx_jmb_buffers != (struct ring_info *)0) {
      int tmp_2;
      int tmp_1;
      
#line 8362 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
      
#line 8362 
      if (tmp_1 != 0) 
#line 8362 
                      tmp_2 = 1024; else 
#line 8362 
                                         tmp_2 = 256;
      
#line 8361 
      ;
      
#line 8361 
      memset((void *)tpr->rx_jmb_buffers,0,(unsigned long)tmp_2 * 16UL);
    }
    else ;
    
#line 8363 
    goto done;
  }
  else ;
  
#line 8367 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 8367 
  if (tmp_3 != 0) 
#line 8367 
                  tmp_4 = 2048; else 
#line 8367 
                                     tmp_4 = 512;
  
#line 8367 
  ;
  
#line 8367 
  memset((void *)tpr->rx_std,0,(unsigned long)tmp_4 * 32UL);
  
#line 8369 
  rx_pkt_dma_sz = 1536U;
  
#line 8370 
  tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
  
#line 8370 
  if (tmp_5 != 0) {
    
#line 8370 
    if ((tp->dev)->mtu > 1500U) 
#line 8372 
                                rx_pkt_dma_sz = 9046U; else ;
  }
  else ;
  
#line 8373 
  tp->rx_pkt_map_sz = rx_pkt_dma_sz + 64U;
  
#line 8379 
  i = 0U;
  
#line 8379 
  goto ldv_57731;
  ldv_57730: 
#line 8380 
  ;
  {
    struct tg3_rx_buffer_desc *rxd;
    
#line 8382 
    rxd = tpr->rx_std + i;
    
#line 8383 
    rxd->idx_len = rx_pkt_dma_sz;
    
#line 8384 
    rxd->type_flags = 4U;
    
#line 8385 
    rxd->opaque = i | 65536U;
  }
  
#line 8379 
  i += 1U;
  ldv_57731: 
#line 8380 
  ;
  
#line 8379 
  if (tp->rx_std_ring_mask >= i) 
#line 8381 
                                 goto ldv_57730; else 
#line 8384 
                                                      goto ldv_57732;
  ldv_57732: 
#line 8385 
  ;
  
#line 8390 
  i = 0U;
  
#line 8390 
  goto ldv_57737;
  ldv_57736: 
#line 8391 
  ;
  {
    unsigned int frag_size;
    int tmp_6;
    
#line 8393 
    tmp_6 = tg3_alloc_rx_data(tp,tpr,65536U,i,& frag_size);
    
#line 8393 
    if (tmp_6 < 0) {
      
#line 8395 
      netdev_warn((struct net_device const *)tp->dev,"Using a smaller RX standard ring. Only ",i,tp->rx_pending);
      
#line 8399 
      if (i == 0U) 
#line 8400 
                   goto initfail; else ;
      
#line 8401 
      tp->rx_pending = i;
      
#line 8402 
      goto ldv_57735;
    }
    else ;
  }
  
#line 8390 
  i += 1U;
  ldv_57737: 
#line 8391 
  ;
  
#line 8390 
  if (tp->rx_pending > i) 
#line 8392 
                          goto ldv_57736; else 
#line 8395 
                                               goto ldv_57735;
  ldv_57735: 
#line 8396 
  ;
  
#line 8406 
  tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 8406 
  if (tmp_7 == 0) 
#line 8407 
                  goto done;
  else {
    int tmp_8;
    
#line 8406 
    tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 8406 
    if (tmp_8 != 0) 
#line 8407 
                    goto done; else ;
  }
  
#line 8409 
  tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 8409 
  if (tmp_9 != 0) 
#line 8409 
                  tmp_10 = 1024; else 
#line 8409 
                                      tmp_10 = 256;
  
#line 8409 
  ;
  
#line 8409 
  memset((void *)tpr->rx_jmb,0,(unsigned long)tmp_10 * 64UL);
  
#line 8411 
  tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 8411 
  if (tmp_11 == 0) 
#line 8412 
                   goto done; else ;
  
#line 8414 
  i = 0U;
  
#line 8414 
  goto ldv_57740;
  ldv_57739: 
#line 8415 
  ;
  {
    struct tg3_rx_buffer_desc *rxd_0;
    
#line 8417 
    rxd_0 = & (tpr->rx_jmb + i)->std;
    
#line 8418 
    rxd_0->idx_len = 9046U;
    
#line 8419 
    rxd_0->type_flags = 36U;
    
#line 8421 
    rxd_0->opaque = i | 131072U;
  }
  
#line 8414 
  i += 1U;
  ldv_57740: 
#line 8415 
  ;
  
#line 8414 
  if (tp->rx_jmb_ring_mask >= i) 
#line 8416 
                                 goto ldv_57739; else 
#line 8419 
                                                      goto ldv_57741;
  ldv_57741: 
#line 8420 
  ;
  
#line 8425 
  i = 0U;
  
#line 8425 
  goto ldv_57745;
  ldv_57744: 
#line 8426 
  ;
  {
    unsigned int frag_size_0;
    int tmp_12;
    
#line 8428 
    tmp_12 = tg3_alloc_rx_data(tp,tpr,131072U,i,& frag_size_0);
    
#line 8428 
    if (tmp_12 < 0) {
      
#line 8430 
      netdev_warn((struct net_device const *)tp->dev,"Using a smaller RX jumbo ring. Only %d ",i,tp->rx_jumbo_pending);
      
#line 8434 
      if (i == 0U) 
#line 8435 
                   goto initfail; else ;
      
#line 8436 
      tp->rx_jumbo_pending = i;
      
#line 8437 
      goto ldv_57743;
    }
    else ;
  }
  
#line 8425 
  i += 1U;
  ldv_57745: 
#line 8426 
  ;
  
#line 8425 
  if (tp->rx_jumbo_pending > i) 
#line 8427 
                                goto ldv_57744; else 
#line 8430 
                                                     goto ldv_57743;
  ldv_57743: 
#line 8431 
  ;
  done: 
#line 8441 
  ;
  
#line 8442 
  __retres = 0;
  
#line 8442 
  goto return_label;
  initfail: 
#line 8444 
  ;
  
#line 8445 
  tg3_rx_prodring_free(tp,tpr);
  
#line 8446 
  __retres = -12;
  return_label: 
#line 8446 
                return __retres;
}


#line 8449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rx_prodring_fini(struct tg3 *tp, struct tg3_rx_prodring_set *tpr)
{
  
#line 8452 
  kfree((void const *)tpr->rx_std_buffers);
  
#line 8453 
  tpr->rx_std_buffers = (struct ring_info *)0;
  
#line 8454 
  kfree((void const *)tpr->rx_jmb_buffers);
  
#line 8455 
  tpr->rx_jmb_buffers = (struct ring_info *)0;
  
#line 8456 
  if (tpr->rx_std != (struct tg3_rx_buffer_desc *)0) {
    int tmp_0;
    int tmp;
    
#line 8457 
    ;
    
#line 8457 
    ;
    
#line 8457 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
    
#line 8457 
    if (tmp != 0) 
#line 8457 
                  tmp_0 = 2048; else 
#line 8457 
                                     tmp_0 = 512;
    
#line 8457 
    ;
    
#line 8457 
    dma_free_attrs(& (tp->pdev)->dev,(unsigned long)tmp_0 * 32UL,(void *)tpr->rx_std,tpr->rx_std_mapping,(struct dma_attrs *)0);
    
#line 8459 
    tpr->rx_std = (struct tg3_rx_buffer_desc *)0;
  }
  else ;
  
#line 8461 
  if (tpr->rx_jmb != (struct tg3_ext_rx_buffer_desc *)0) {
    int tmp_2;
    int tmp_1;
    
#line 8462 
    ;
    
#line 8462 
    ;
    
#line 8462 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
    
#line 8462 
    if (tmp_1 != 0) 
#line 8462 
                    tmp_2 = 1024; else 
#line 8462 
                                       tmp_2 = 256;
    
#line 8462 
    ;
    
#line 8462 
    dma_free_attrs(& (tp->pdev)->dev,(unsigned long)tmp_2 * 64UL,(void *)tpr->rx_jmb,tpr->rx_jmb_mapping,(struct dma_attrs *)0);
    
#line 8464 
    tpr->rx_jmb = (struct tg3_ext_rx_buffer_desc *)0;
  }
  else ;
  
#line 8466 
  return;
}


#line 8468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_rx_prodring_init(struct tg3 *tp, struct tg3_rx_prodring_set *tpr)
{
  int __retres;
  void *tmp_1;
  int tmp_0;
  int tmp;
  void *tmp_4;
  int tmp_3;
  int tmp_2;
  int tmp_11;
  
#line 8471 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 8471 
  if (tmp != 0) 
#line 8471 
                tmp_0 = 2048; else 
#line 8471 
                                   tmp_0 = 512;
  
#line 8471 
  tmp_1 = kzalloc((unsigned long)tmp_0 * 16UL,208U);
  
#line 8471 
  tpr->rx_std_buffers = (struct ring_info *)tmp_1;
  
#line 8473 
  if (tpr->rx_std_buffers == (struct ring_info *)0) {
    
#line 8474 
    __retres = -12;
    
#line 8474 
    goto return_label;
  }
  else ;
  
#line 8476 
  ;
  
#line 8476 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 8476 
  if (tmp_2 != 0) 
#line 8476 
                  tmp_3 = 2048; else 
#line 8476 
                                     tmp_3 = 512;
  
#line 8476 
  ;
  
#line 8476 
  tmp_4 = dma_alloc_attrs(& (tp->pdev)->dev,(unsigned long)tmp_3 * 32UL,& tpr->rx_std_mapping,208U,(struct dma_attrs *)0);
  
#line 8476 
  tpr->rx_std = (struct tg3_rx_buffer_desc *)tmp_4;
  
#line 8480 
  if (tpr->rx_std == (struct tg3_rx_buffer_desc *)0) 
#line 8481 
                                                     goto err_out; else ;
  
#line 8483 
  tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 8483 
  if (tmp_11 != 0) {
    int tmp_12;
    
#line 8483 
    tmp_12 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 8483 
    if (tmp_12 == 0) {
      void *tmp_7;
      int tmp_6;
      int tmp_5;
      void *tmp_10;
      int tmp_9;
      int tmp_8;
      
#line 8484 
      tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
      
#line 8484 
      if (tmp_5 != 0) 
#line 8484 
                      tmp_6 = 1024; else 
#line 8484 
                                         tmp_6 = 256;
      
#line 8484 
      tmp_7 = kzalloc((unsigned long)tmp_6 * 16UL,208U);
      
#line 8484 
      tpr->rx_jmb_buffers = (struct ring_info *)tmp_7;
      
#line 8486 
      if (tpr->rx_jmb_buffers == (struct ring_info *)0) 
#line 8487 
                                                        goto err_out; else ;
      
#line 8489 
      ;
      
#line 8489 
      tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
      
#line 8489 
      if (tmp_8 != 0) 
#line 8489 
                      tmp_9 = 1024; else 
#line 8489 
                                         tmp_9 = 256;
      
#line 8489 
      ;
      
#line 8489 
      tmp_10 = dma_alloc_attrs(& (tp->pdev)->dev,(unsigned long)tmp_9 * 64UL,& tpr->rx_jmb_mapping,208U,(struct dma_attrs *)0);
      
#line 8489 
      tpr->rx_jmb = (struct tg3_ext_rx_buffer_desc *)tmp_10;
      
#line 8493 
      if (tpr->rx_jmb == (struct tg3_ext_rx_buffer_desc *)0) 
#line 8494 
                                                             goto err_out; else ;
    }
    else ;
  }
  else ;
  
#line 8497 
  __retres = 0;
  
#line 8497 
  goto return_label;
  err_out: 
#line 8499 
  ;
  
#line 8500 
  tg3_rx_prodring_fini(tp,tpr);
  
#line 8501 
  __retres = -12;
  return_label: 
#line 8501 
                return __retres;
}


#line 8511  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_free_rings(struct tg3 *tp)
{
  int i;
  int j;
  
#line 8515 
  j = 0;
  
#line 8515 
  goto ldv_57768;
  ldv_57767: 
#line 8516 
  ;
  {
    struct netdev_queue *tmp_0;
    
#line 8516 
    struct tg3_napi *tnapi = & tp->napi[j];
    
#line 8518 
    tg3_rx_prodring_free(tp,& tnapi->prodring);
    
#line 8520 
    if (tnapi->tx_buffers == (struct tg3_tx_ring_info *)0) 
#line 8521 
                                                           goto ldv_57761; else ;
    
#line 8523 
    i = 0;
    
#line 8523 
    goto ldv_57765;
    ldv_57764: 
#line 8524 
    ;
    {
      unsigned char *tmp;
      
#line 8524 
      struct sk_buff *skb = (tnapi->tx_buffers + i)->skb;
      
#line 8526 
      if (skb == (struct sk_buff *)0) 
#line 8527 
                                      goto ldv_57763; else ;
      
#line 8530 
      tmp = skb_end_pointer((struct sk_buff const *)skb);
      
#line 8529 
      ;
      
#line 8529 
      ;
      
#line 8529 
      ;
      
#line 8529 
      tg3_tx_skb_unmap(tnapi,(unsigned int)i,(int)((struct skb_shared_info *)tmp)->nr_frags + -1);
      
#line 8532 
      dev_kfree_skb_any(skb);
    }
    ldv_57763: 
#line 8534 
    ;
    
#line 8523 
    i += 1;
    ldv_57765: 
#line 8524 
    ;
    
#line 8523 
    if (i <= 511) 
#line 8525 
                  goto ldv_57764; else 
#line 8528 
                                       goto ldv_57766;
    ldv_57766: 
#line 8529 
    ;
    
#line 8534 
    tmp_0 = netdev_get_tx_queue((struct net_device const *)tp->dev,(unsigned int)j);
    
#line 8534 
    netdev_tx_reset_queue(tmp_0);
  }
  ldv_57761: 
#line 8536 
  ;
  
#line 8515 
  j += 1;
  ldv_57768: 
#line 8516 
  ;
  
#line 8515 
  if (tp->irq_cnt > (unsigned int)j) 
#line 8517 
                                     goto ldv_57767; else 
#line 8520 
                                                          goto ldv_57769;
  ldv_57769: 
#line 8521 
  ;
  
#line 8522 
  return;
}


#line 8545  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_init_rings(struct tg3 *tp)
{
  int __retres;
  int i;
  
#line 8550 
  tg3_free_rings(tp);
  
#line 8552 
  i = 0;
  
#line 8552 
  goto ldv_57776;
  ldv_57775: 
#line 8553 
  ;
  {
    
#line 8553 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 8555 
    tnapi->last_tag = 0U;
    
#line 8556 
    tnapi->last_irq_tag = 0U;
    
#line 8557 
    (tnapi->hw_status)->status = 0U;
    
#line 8558 
    (tnapi->hw_status)->status_tag = 0U;
    
#line 8559 
    memset((void *)tnapi->hw_status,0,80UL);
    
#line 8561 
    tnapi->tx_prod = 0U;
    
#line 8562 
    tnapi->tx_cons = 0U;
    
#line 8563 
    if (tnapi->tx_ring != (struct tg3_tx_buffer_desc *)0) 
#line 8564 
                                                          memset((void *)tnapi->tx_ring,0,8192UL); else ;
    
#line 8566 
    tnapi->rx_rcb_ptr = 0U;
    
#line 8567 
    if (tnapi->rx_rcb != (struct tg3_rx_buffer_desc *)0) 
#line 8568 
                                                         memset((void *)tnapi->rx_rcb,0,(unsigned long)(tp->rx_ret_ring_mask + 1U) * 32UL); else ;
    
#line 8570 
    if (tnapi->prodring.rx_std != (struct tg3_rx_buffer_desc *)0) {
      int tmp;
      
#line 8570 
      tmp = tg3_rx_prodring_alloc(tp,& tnapi->prodring);
      
#line 8570 
      if (tmp != 0) {
        
#line 8572 
        tg3_free_rings(tp);
        
#line 8573 
        __retres = -12;
        
#line 8573 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  
#line 8552 
  i += 1;
  ldv_57776: 
#line 8553 
  ;
  
#line 8552 
  if (tp->irq_cnt > (unsigned int)i) 
#line 8554 
                                     goto ldv_57775; else 
#line 8557 
                                                          goto ldv_57777;
  ldv_57777: 
#line 8558 
  ;
  
#line 8577 
  __retres = 0;
  return_label: 
#line 8577 
                return __retres;
}


#line 8580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_mem_tx_release(struct tg3 *tp)
{
  int i;
  
#line 8584 
  i = 0;
  
#line 8584 
  goto ldv_57784;
  ldv_57783: 
#line 8585 
  ;
  {
    
#line 8585 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 8587 
    if (tnapi->tx_ring != (struct tg3_tx_buffer_desc *)0) {
      
#line 8588 
      dma_free_attrs(& (tp->pdev)->dev,8192UL,(void *)tnapi->tx_ring,tnapi->tx_desc_mapping,(struct dma_attrs *)0);
      
#line 8590 
      tnapi->tx_ring = (struct tg3_tx_buffer_desc *)0;
    }
    else ;
    
#line 8593 
    kfree((void const *)tnapi->tx_buffers);
    
#line 8594 
    tnapi->tx_buffers = (struct tg3_tx_ring_info *)0;
  }
  
#line 8584 
  i += 1;
  ldv_57784: 
#line 8585 
  ;
  
#line 8584 
  if (tp->irq_max > (unsigned int)i) 
#line 8586 
                                     goto ldv_57783; else 
#line 8589 
                                                          goto ldv_57785;
  ldv_57785: 
#line 8590 
  ;
  
#line 8591 
  return;
}


#line 8598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_mem_tx_acquire(struct tg3 *tp)
{
  int __retres;
  int i;
  int tmp;
  
#line 8601 
  struct tg3_napi *tnapi = & tp->napi[0];
  
#line 8606 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
  
#line 8606 
  if (tmp != 0) 
#line 8607 
                tnapi += 1; else ;
  
#line 8609 
  i = 0;
  
#line 8609 
  goto ldv_57793;
  ldv_57792: 
#line 8610 
  ;
  
#line 8610 
  tnapi->tx_buffers = (struct tg3_tx_ring_info *)kzalloc(12288UL,208U);
  
#line 8612 
  if (tnapi->tx_buffers == (struct tg3_tx_ring_info *)0) 
#line 8613 
                                                         goto err_out; else ;
  
#line 8615 
  tnapi->tx_ring = (struct tg3_tx_buffer_desc *)dma_alloc_attrs(& (tp->pdev)->dev,8192UL,& tnapi->tx_desc_mapping,208U,(struct dma_attrs *)0);
  
#line 8619 
  if (tnapi->tx_ring == (struct tg3_tx_buffer_desc *)0) 
#line 8620 
                                                        goto err_out; else ;
  
#line 8609 
  i += 1;
  
#line 8609 
  tnapi += 1;
  ldv_57793: 
#line 8610 
  ;
  
#line 8609 
  if (tp->txq_cnt > (unsigned int)i) 
#line 8611 
                                     goto ldv_57792; else 
#line 8614 
                                                          goto ldv_57794;
  ldv_57794: 
#line 8615 
  ;
  
#line 8623 
  __retres = 0;
  
#line 8623 
  goto return_label;
  err_out: 
#line 8625 
  ;
  
#line 8626 
  tg3_mem_tx_release(tp);
  
#line 8627 
  __retres = -12;
  return_label: 
#line 8627 
                return __retres;
}


#line 8630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_mem_rx_release(struct tg3 *tp)
{
  int i;
  
#line 8634 
  i = 0;
  
#line 8634 
  goto ldv_57802;
  ldv_57801: 
#line 8635 
  ;
  {
    
#line 8635 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 8637 
    tg3_rx_prodring_fini(tp,& tnapi->prodring);
    
#line 8639 
    if (tnapi->rx_rcb == (struct tg3_rx_buffer_desc *)0) 
#line 8640 
                                                         goto ldv_57800; else ;
    
#line 8642 
    dma_free_attrs(& (tp->pdev)->dev,(unsigned long)(tp->rx_ret_ring_mask + 1U) * 32UL,(void *)tnapi->rx_rcb,tnapi->rx_rcb_mapping,(struct dma_attrs *)0);
    
#line 8646 
    tnapi->rx_rcb = (struct tg3_rx_buffer_desc *)0;
  }
  ldv_57800: 
#line 8648 
  ;
  
#line 8634 
  i += 1;
  ldv_57802: 
#line 8635 
  ;
  
#line 8634 
  if (tp->irq_max > (unsigned int)i) 
#line 8636 
                                     goto ldv_57801; else 
#line 8639 
                                                          goto ldv_57803;
  ldv_57803: 
#line 8640 
  ;
  
#line 8641 
  return;
}


#line 8650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_mem_rx_acquire(struct tg3 *tp)
{
  int __retres;
  unsigned int i;
  unsigned int limit;
  int tmp;
  
#line 8654 
  limit = tp->rxq_cnt;
  
#line 8659 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 8659 
  if (tmp != 0) 
#line 8660 
                limit += 1U; else ;
  
#line 8662 
  i = 0U;
  
#line 8662 
  goto ldv_57813;
  ldv_57812: 
#line 8663 
  ;
  {
    int tmp_0;
    
#line 8663 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 8665 
    tmp_0 = tg3_rx_prodring_init(tp,& tnapi->prodring);
    
#line 8665 
    if (tmp_0 != 0) 
#line 8666 
                    goto err_out; else ;
    
#line 8672 
    if (i == 0U) {
      int tmp_1;
      
#line 8672 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
      
#line 8672 
      if (tmp_1 != 0) 
#line 8673 
                      goto ldv_57811; else ;
    }
    else ;
    
#line 8675 
    tnapi->rx_rcb = (struct tg3_rx_buffer_desc *)dma_zalloc_coherent(& (tp->pdev)->dev,(unsigned long)(tp->rx_ret_ring_mask + 1U) * 32UL,& tnapi->rx_rcb_mapping,208U);
    
#line 8679 
    if (tnapi->rx_rcb == (struct tg3_rx_buffer_desc *)0) 
#line 8680 
                                                         goto err_out; else ;
  }
  ldv_57811: 
#line 8682 
  ;
  
#line 8662 
  i += 1U;
  ldv_57813: 
#line 8663 
  ;
  
#line 8662 
  if (i < limit) 
#line 8664 
                 goto ldv_57812; else 
#line 8667 
                                      goto ldv_57814;
  ldv_57814: 
#line 8668 
  ;
  
#line 8683 
  __retres = 0;
  
#line 8683 
  goto return_label;
  err_out: 
#line 8685 
  ;
  
#line 8686 
  tg3_mem_rx_release(tp);
  
#line 8687 
  __retres = -12;
  return_label: 
#line 8687 
                return __retres;
}


#line 8694  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_free_consistent(struct tg3 *tp)
{
  int i;
  
#line 8698 
  i = 0;
  
#line 8698 
  goto ldv_57821;
  ldv_57820: 
#line 8699 
  ;
  {
    
#line 8699 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 8701 
    if (tnapi->hw_status != (struct tg3_hw_status *)0) {
      
#line 8702 
      dma_free_attrs(& (tp->pdev)->dev,80UL,(void *)tnapi->hw_status,tnapi->status_mapping,(struct dma_attrs *)0);
      
#line 8705 
      tnapi->hw_status = (struct tg3_hw_status *)0;
    }
    else ;
  }
  
#line 8698 
  i += 1;
  ldv_57821: 
#line 8699 
  ;
  
#line 8698 
  if (tp->irq_cnt > (unsigned int)i) 
#line 8700 
                                     goto ldv_57820; else 
#line 8703 
                                                          goto ldv_57822;
  ldv_57822: 
#line 8704 
  ;
  
#line 8709 
  tg3_mem_rx_release(tp);
  
#line 8710 
  tg3_mem_tx_release(tp);
  
#line 8712 
  if (tp->hw_stats != (struct tg3_hw_stats *)0) {
    
#line 8713 
    dma_free_attrs(& (tp->pdev)->dev,2048UL,(void *)tp->hw_stats,tp->stats_mapping,(struct dma_attrs *)0);
    
#line 8715 
    tp->hw_stats = (struct tg3_hw_stats *)0;
  }
  else ;
  
#line 8717 
  return;
}


#line 8723  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_alloc_consistent(struct tg3 *tp)
{
  int __retres;
  int i;
  int tmp_2;
  
#line 8727 
  tp->hw_stats = (struct tg3_hw_stats *)dma_zalloc_coherent(& (tp->pdev)->dev,2048UL,& tp->stats_mapping,208U);
  
#line 8730 
  if (tp->hw_stats == (struct tg3_hw_stats *)0) 
#line 8731 
                                                goto err_out; else ;
  
#line 8733 
  i = 0;
  
#line 8733 
  goto ldv_57837;
  ldv_57836: 
#line 8734 
  ;
  {
    struct tg3_hw_status *sblk;
    int tmp_1;
    
#line 8734 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 8737 
    tnapi->hw_status = (struct tg3_hw_status *)dma_zalloc_coherent(& (tp->pdev)->dev,80UL,& tnapi->status_mapping,208U);
    
#line 8741 
    if (tnapi->hw_status == (struct tg3_hw_status *)0) 
#line 8742 
                                                       goto err_out; else ;
    
#line 8744 
    sblk = tnapi->hw_status;
    
#line 8746 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
    
#line 8746 
    if (tmp_1 != 0) {
      
#line 8747 
      u16 *prodptr = (u16 *)0U;
      
#line 8755 
      switch (i) {
        case 1: 
#line 8756 
        ;
        
#line 8757 
        prodptr = & sblk->idx[0].rx_producer;
        
#line 8758 
        goto ldv_57832;
        case 2: 
#line 8759 
        ;
        
#line 8760 
        prodptr = & sblk->rx_jumbo_consumer;
        
#line 8761 
        goto ldv_57832;
        case 3: 
#line 8762 
        ;
        
#line 8763 
        prodptr = & sblk->reserved;
        
#line 8764 
        goto ldv_57832;
        case 4: 
#line 8765 
        ;
        
#line 8766 
        prodptr = & sblk->rx_mini_consumer;
        
#line 8767 
        goto ldv_57832;
      }
      ldv_57832: 
#line 8769 
      ;
      
#line 8769 
      tnapi->rx_rcb_prod_idx = prodptr;
    }
    else 
#line 8771 
         tnapi->rx_rcb_prod_idx = & sblk->idx[0].rx_producer;
  }
  
#line 8733 
  i += 1;
  ldv_57837: 
#line 8734 
  ;
  
#line 8733 
  if (tp->irq_cnt > (unsigned int)i) 
#line 8735 
                                     goto ldv_57836; else 
#line 8738 
                                                          goto ldv_57838;
  ldv_57838: 
#line 8739 
  ;
  
#line 8775 
  tmp_2 = tg3_mem_tx_acquire(tp);
  
#line 8775 
  if (tmp_2 != 0) 
#line 8776 
                  goto err_out;
  else {
    int tmp_3;
    
#line 8775 
    tmp_3 = tg3_mem_rx_acquire(tp);
    
#line 8775 
    if (tmp_3 != 0) 
#line 8776 
                    goto err_out; else ;
  }
  
#line 8778 
  __retres = 0;
  
#line 8778 
  goto return_label;
  err_out: 
#line 8780 
  ;
  
#line 8781 
  tg3_free_consistent(tp);
  
#line 8782 
  __retres = -12;
  return_label: 
#line 8782 
                return __retres;
}


#line 8790  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_stop_block(struct tg3 *tp, unsigned long ofs, u32 enable_bit, bool silent)
{
  int __retres;
  unsigned int i;
  u32 val;
  int tmp;
  int tmp_0;
  
#line 8795 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 8795 
  if (tmp != 0) {
    
#line 8796 
    switch (ofs) {
      case (unsigned long)13312: 
#line 8797 
      ;
      case (unsigned long)25600: 
#line 8798 
      ;
      case (unsigned long)14336: 
#line 8799 
      ;
      case (unsigned long)17408: 
#line 8800 
      ;
      case (unsigned long)16384: 
#line 8801 
      ;
      
#line 8805 
      __retres = 0;
      
#line 8805 
      goto return_label;
      default: 
#line 8807 
      ;
      
#line 8808 
      goto ldv_57853;
    }
    ldv_57853: 
#line 8810 
    ;
  }
  else ;
  
#line 8812 
  val = (*(tp->read32))(tp,(unsigned int)ofs);
  
#line 8813 
  val = ~ enable_bit & val;
  
#line 8814 
  _tw32_flush(tp,(unsigned int)ofs,val,0U);
  
#line 8816 
  i = 0U;
  
#line 8816 
  goto ldv_57856;
  ldv_57855: 
#line 8817 
  ;
  
#line 8817 
  tmp_0 = pci_channel_offline(tp->pdev);
  
#line 8817 
  if (tmp_0 != 0) {
    
#line 8818 
    dev_err((struct device const *)(& (tp->pdev)->dev),"tg3_stop_block device offline, ",ofs,enable_bit);
    
#line 8822 
    __retres = -19;
    
#line 8822 
    goto return_label;
  }
  else ;
  
#line 8825 
  __const_udelay(429500UL);
  
#line 8826 
  val = (*(tp->read32))(tp,(unsigned int)ofs);
  
#line 8827 
  if ((val & enable_bit) == 0U) 
#line 8828 
                                goto ldv_57854; else ;
  
#line 8816 
  i += 1U;
  ldv_57856: 
#line 8817 
  ;
  
#line 8816 
  if (i <= 999U) 
#line 8818 
                 goto ldv_57855; else 
#line 8821 
                                      goto ldv_57854;
  ldv_57854: 
#line 8822 
  ;
  
#line 8831 
  if (i == 1000U && ! silent) {
    
#line 8832 
    dev_err((struct device const *)(& (tp->pdev)->dev),"tg3_stop_block timed out, ofs=%lx enable_bit=%x\n",ofs,enable_bit);
    
#line 8835 
    __retres = -19;
    
#line 8835 
    goto return_label;
  }
  else ;
  
#line 8838 
  __retres = 0;
  return_label: 
#line 8838 
                return __retres;
}


#line 8842  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_abort_hw(struct tg3 *tp, bool silent)
{
  int i;
  int err;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  u32 tmp_12;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_17;
  int tmp_18;
  
#line 8846 
  tg3_disable_ints(tp);
  
#line 8848 
  tmp = pci_channel_offline(tp->pdev);
  
#line 8848 
  if (tmp != 0) {
    
#line 8849 
    tp->rx_mode &= 4294967293U;
    
#line 8850 
    tp->mac_mode &= 4292870143U;
    
#line 8851 
    err = -19;
    
#line 8852 
    goto err_no_dev;
  }
  else ;
  
#line 8855 
  tp->rx_mode &= 4294967293U;
  
#line 8856 
  _tw32_flush(tp,1128U,tp->rx_mode,0U);
  
#line 8857 
  __const_udelay(42950UL);
  
#line 8859 
  err = tg3_stop_block(tp,11264UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8860 
  tmp_0 = tg3_stop_block(tp,8192UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8860 
  err = tmp_0 | err;
  
#line 8861 
  tmp_1 = tg3_stop_block(tp,13312UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8861 
  err = tmp_1 | err;
  
#line 8862 
  tmp_2 = tg3_stop_block(tp,9216UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8862 
  err = tmp_2 | err;
  
#line 8863 
  tmp_3 = tg3_stop_block(tp,10240UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8863 
  err = tmp_3 | err;
  
#line 8864 
  tmp_4 = tg3_stop_block(tp,12288UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8864 
  err = tmp_4 | err;
  
#line 8866 
  tmp_5 = tg3_stop_block(tp,5120UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8866 
  err = tmp_5 | err;
  
#line 8867 
  tmp_6 = tg3_stop_block(tp,6144UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8867 
  err = tmp_6 | err;
  
#line 8868 
  tmp_7 = tg3_stop_block(tp,3072UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8868 
  err = tmp_7 | err;
  
#line 8869 
  tmp_8 = tg3_stop_block(tp,18432UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8869 
  err = tmp_8 | err;
  
#line 8870 
  tmp_9 = tg3_stop_block(tp,4096UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8870 
  err = tmp_9 | err;
  
#line 8871 
  tmp_10 = tg3_stop_block(tp,25600UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8871 
  err = tmp_10 | err;
  
#line 8872 
  tmp_11 = tg3_stop_block(tp,7168UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8872 
  err = tmp_11 | err;
  
#line 8874 
  tp->mac_mode &= 4292870143U;
  
#line 8875 
  _tw32_flush(tp,1024U,tp->mac_mode,0U);
  
#line 8876 
  __const_udelay(171800UL);
  
#line 8878 
  tp->tx_mode &= 4294967293U;
  
#line 8879 
  _tw32_flush(tp,1116U,tp->tx_mode,0U);
  
#line 8881 
  i = 0;
  
#line 8881 
  goto ldv_57866;
  ldv_57865: 
#line 8882 
  ;
  
#line 8882 
  __const_udelay(429500UL);
  
#line 8883 
  tmp_12 = (*(tp->read32))(tp,1116U);
  
#line 8883 
  if ((tmp_12 & 2U) == 0U) 
#line 8884 
                           goto ldv_57864; else ;
  
#line 8881 
  i += 1;
  ldv_57866: 
#line 8882 
  ;
  
#line 8881 
  if (i <= 999) 
#line 8883 
                goto ldv_57865; else 
#line 8886 
                                     goto ldv_57864;
  ldv_57864: 
#line 8887 
  ;
  
#line 8886 
  if (i > 999) {
    u32 tmp_13;
    
#line 8889 
    tmp_13 = (*(tp->read32))(tp,1116U);
    
#line 8887 
    ;
    
#line 8887 
    dev_err((struct device const *)(& (tp->pdev)->dev),"%s timed out, TX_MODE_ENABLE will not clear ","tg3_abort_hw",tmp_13);
    
#line 8890 
    err |= -19;
  }
  else ;
  
#line 8893 
  tmp_14 = tg3_stop_block(tp,15360UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8893 
  err = tmp_14 | err;
  
#line 8894 
  tmp_15 = tg3_stop_block(tp,19456UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8894 
  err = tmp_15 | err;
  
#line 8895 
  tmp_16 = tg3_stop_block(tp,14336UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8895 
  err = tmp_16 | err;
  
#line 8897 
  (*(tp->write32))(tp,23552U,4294967295U);
  
#line 8898 
  (*(tp->write32))(tp,23552U,0U);
  
#line 8900 
  tmp_17 = tg3_stop_block(tp,17408UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8900 
  err = tmp_17 | err;
  
#line 8901 
  tmp_18 = tg3_stop_block(tp,16384UL,2U,(_Bool)((bool)((int)silent) != 0));
  
#line 8901 
  err = tmp_18 | err;
  err_no_dev: 
#line 8903 
  ;
  
#line 8904 
  i = 0;
  
#line 8904 
  goto ldv_57870;
  ldv_57869: 
#line 8905 
  ;
  {
    
#line 8905 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 8906 
    if (tnapi->hw_status != (struct tg3_hw_status *)0) 
#line 8907 
                                                       memset((void *)tnapi->hw_status,0,80UL); else ;
  }
  
#line 8904 
  i += 1;
  ldv_57870: 
#line 8905 
  ;
  
#line 8904 
  if (tp->irq_cnt > (unsigned int)i) 
#line 8906 
                                     goto ldv_57869; else 
#line 8909 
                                                          goto ldv_57871;
  ldv_57871: 
#line 8910 
  ;
  
#line 8910 
  return err;
}


#line 8914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_save_pci_state(struct tg3 *tp)
{
  
#line 8916 
  pci_read_config_word((struct pci_dev const *)tp->pdev,4,& tp->pci_cmd);
  
#line 8917 
  return;
}


#line 8920  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_restore_pci_state(struct tg3 *tp)
{
  u32 val;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_4;
  
#line 8925 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,104,tp->misc_host_ctrl);
  
#line 8929 
  val = 96U;
  
#line 8930 
  if (tp->pci_chip_rev_id == 8192U) {
    int tmp;
    
#line 8930 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
    
#line 8930 
    if (tmp != 0) 
#line 8932 
                  val |= 8192U; else ;
  }
  else ;
  
#line 8934 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 8934 
  if (tmp_0 != 0) 
#line 8935 
                  val |= 458752U; else ;
  
#line 8938 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,112,val);
  
#line 8940 
  pci_write_config_word((struct pci_dev const *)tp->pdev,4,(unsigned short)((int)tp->pci_cmd));
  
#line 8942 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
  
#line 8942 
  if (tmp_1 == 0) {
    
#line 8943 
    pci_write_config_byte((struct pci_dev const *)tp->pdev,12,(unsigned char)((int)tp->pci_cacheline_sz));
    
#line 8945 
    pci_write_config_byte((struct pci_dev const *)tp->pdev,13,(unsigned char)((int)tp->pci_lat_timer));
  }
  else ;
  
#line 8950 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
  
#line 8950 
  if (tmp_2 != 0) {
    u16 pcix_cmd;
    
#line 8953 
    pci_read_config_word((struct pci_dev const *)tp->pdev,tp->pcix_cap + 2,& pcix_cmd);
    
#line 8955 
    pcix_cmd = (unsigned short)((unsigned int)pcix_cmd & 65533U);
    
#line 8956 
    pci_write_config_word((struct pci_dev const *)tp->pdev,tp->pcix_cap + 2,(unsigned short)((int)pcix_cmd));
  }
  else ;
  
#line 8960 
  tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
  
#line 8960 
  if (tmp_4 != 0) {
    int tmp_3;
    
#line 8965 
    tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
    
#line 8965 
    if (tmp_3 != 0) {
      u16 ctrl;
      
#line 8968 
      pci_read_config_word((struct pci_dev const *)tp->pdev,tp->msi_cap + 2,& ctrl);
      
#line 8971 
      pci_write_config_word((struct pci_dev const *)tp->pdev,tp->msi_cap + 2,(unsigned short)((int)((unsigned int)ctrl | 1U)));
      
#line 8974 
      val = (*(tp->read32))(tp,24576U);
      
#line 8975 
      (*(tp->write32))(tp,24576U,val | 2U);
    }
    else ;
  }
  else ;
  
#line 8977 
  return;
}


#line 8980  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_override_clk(struct tg3 *tp)
{
  u32 val;
  
#line 8984 
  switch (tp->pci_chip_rev_id >> 12) {
    case (u32)22295: 
#line 8985 
    ;
    
#line 8986 
    val = (*(tp->read32))(tp,13864U);
    
#line 8987 
    (*(tp->write32))(tp,13864U,val | 8192U);
    
#line 8989 
    goto ldv_57886;
    case (u32)22297: 
#line 8991 
    ;
    case (u32)22304: 
#line 8992 
    ;
    
#line 8993 
    (*(tp->write32))(tp,13860U,2147483648U);
    
#line 8994 
    goto ldv_57886;
    default: 
#line 8996 
    ;
    
#line 8997 
    goto return_label;
  }
  ldv_57886: 
#line 8999 
  ;
  return_label: 
#line 9000 
                return;
}


#line 9001  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_restore_clk(struct tg3 *tp)
{
  u32 val;
  
#line 9005 
  switch (tp->pci_chip_rev_id >> 12) {
    case (u32)22295: 
#line 9006 
    ;
    
#line 9007 
    val = (*(tp->read32))(tp,13864U);
    
#line 9008 
    (*(tp->write32))(tp,13864U,val & 4294959103U);
    
#line 9010 
    goto ldv_57895;
    case (u32)22297: 
#line 9012 
    ;
    case (u32)22304: 
#line 9013 
    ;
    
#line 9014 
    val = (*(tp->read32))(tp,13860U);
    
#line 9015 
    (*(tp->write32))(tp,13860U,val & 2147483647U);
    
#line 9016 
    goto ldv_57895;
    default: 
#line 9018 
    ;
    
#line 9019 
    goto return_label;
  }
  ldv_57895: 
#line 9021 
  ;
  return_label: 
#line 9022 
                return;
}


#line 9024  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_chip_reset(struct tg3 *tp)
{
  int __retres;
  u32 val;
  void (*write_op)(struct tg3 *, u32 , u32 );
  int i;
  int err;
  int tmp_0;
  bool tmp;
  int tmp_5;
  int tmp_8;
  int tmp_11;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  
#line 9032 
  tmp = pci_device_is_present(tp->pdev);
  
#line 9032 
  if (tmp) 
#line 9032 
           tmp_0 = 0; else 
#line 9032 
                           tmp_0 = 1;
  
#line 9032 
  if (tmp_0) {
    
#line 9033 
    __retres = -19;
    
#line 9033 
    goto return_label;
  }
  else ;
  
#line 9035 
  tg3_nvram_lock(tp);
  
#line 9037 
  tg3_ape_lock(tp,1);
  
#line 9042 
  tp->nvram_lock_cnt = 0;
  
#line 9048 
  tg3_save_pci_state(tp);
  
#line 9050 
  if (tp->pci_chip_rev_id >> 12 == 6U) 
#line 9052 
                                       (*(tp->write32))(tp,26772U,0U);
  else {
    int tmp_1;
    
#line 9050 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 9050 
    if (tmp_1 != 0) 
#line 9052 
                    (*(tp->write32))(tp,26772U,0U); else ;
  }
  
#line 9060 
  write_op = tp->write32;
  
#line 9061 
  if (write_op == & tg3_write_flush_reg32) 
#line 9062 
                                           tp->write32 = & tg3_write32; else ;
  
#line 9070 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_CHIP_RESETTING,(unsigned long *)(& tp->tg3_flags));
  
#line 9071 
  i = 0;
  
#line 9071 
  goto ldv_57911;
  ldv_57910: 
#line 9072 
  ;
  {
    
#line 9072 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 9073 
    if (tnapi->hw_status != (struct tg3_hw_status *)0) {
      
#line 9074 
      (tnapi->hw_status)->status = 0U;
      
#line 9075 
      (tnapi->hw_status)->status_tag = 0U;
    }
    else ;
    
#line 9077 
    tnapi->last_tag = 0U;
    
#line 9078 
    tnapi->last_irq_tag = 0U;
  }
  
#line 9071 
  i += 1;
  ldv_57911: 
#line 9072 
  ;
  
#line 9071 
  if (tp->irq_cnt > (unsigned int)i) 
#line 9073 
                                     goto ldv_57910; else 
#line 9076 
                                                          goto ldv_57912;
  ldv_57912: 
#line 9077 
  ;
  
#line 9078 
  ldv_inline_asm();
  
#line 9082 
  tg3_full_unlock(tp);
  
#line 9084 
  i = 0;
  
#line 9084 
  goto ldv_57914;
  ldv_57913: 
#line 9085 
  ;
  
#line 9085 
  synchronize_irq(tp->napi[i].irq_vec);
  
#line 9084 
  i += 1;
  ldv_57914: 
#line 9085 
  ;
  
#line 9084 
  if (tp->irq_cnt > (unsigned int)i) 
#line 9086 
                                     goto ldv_57913; else 
#line 9089 
                                                          goto ldv_57915;
  ldv_57915: 
#line 9090 
  ;
  
#line 9087 
  tg3_full_lock(tp,0);
  
#line 9089 
  if (tp->pci_chip_rev_id >> 12 == 358272U) {
    u32 tmp_2;
    
#line 9090 
    tmp_2 = (*(tp->read32))(tp,32084U);
    
#line 9090 
    val = tmp_2 & 4294967287U;
    
#line 9091 
    (*(tp->write32))(tp,32084U,val | 128U);
  }
  else ;
  
#line 9095 
  val = 1U;
  
#line 9097 
  tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
  
#line 9097 
  if (tmp_5 != 0) {
    
#line 9099 
    if (tp->pci_chip_rev_id >> 12 != 22405U) {
      int tmp_3;
      
#line 9099 
      tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 9099 
      if (tmp_3 == 0) {
        u32 tmp_4;
        
#line 9100 
        tmp_4 = (*(tp->read32))(tp,32300U);
        
#line 9100 
        if (tmp_4 == 96U) 
#line 9103 
                          (*(tp->write32))(tp,32300U,32U); else ;
      }
      else ;
    }
    else ;
    
#line 9105 
    if (tp->pci_chip_rev_id != 16384U) {
      
#line 9106 
      (*(tp->write32))(tp,26628U,536870912U);
      
#line 9107 
      val |= 536870912U;
    }
    else ;
  }
  else ;
  
#line 9111 
  if (tp->pci_chip_rev_id >> 12 == 12U) {
    u32 tmp_6;
    u32 tmp_7;
    
#line 9112 
    tmp_6 = (*(tp->read32))(tp,20736U);
    
#line 9112 
    ;
    
#line 9112 
    (*(tp->write32))(tp,20736U,tmp_6 | 134217728U);
    
#line 9113 
    tmp_7 = (*(tp->read32))(tp,26768U);
    
#line 9113 
    ;
    
#line 9113 
    (*(tp->write32))(tp,26768U,tmp_7 & 4290772991U);
  }
  else ;
  
#line 9122 
  tg3_override_clk(tp);
  
#line 9125 
  tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9125 
  if (tmp_8 != 0) {
    int tmp_9;
    
#line 9125 
    tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
    
#line 9125 
    if (tmp_9 == 0) 
#line 9126 
                    val |= 67108864U; else ;
  }
  else ;
  
#line 9128 
  (*(tp->write32))(tp,26628U,val);
  
#line 9131 
  tp->write32 = write_op;
  
#line 9146 
  __const_udelay(515400UL);
  
#line 9154 
  pci_read_config_dword((struct pci_dev const *)tp->pdev,4,& val);
  
#line 9156 
  __const_udelay(515400UL);
  
#line 9158 
  tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
  
#line 9158 
  if (tmp_11 != 0) {
    bool tmp_12;
    
#line 9158 
    tmp_12 = pci_is_pcie(tp->pdev);
    
#line 9158 
    if ((int)tmp_12 != 0) {
      u16 val16;
      int tmp_10;
      
#line 9161 
      if (tp->pci_chip_rev_id == 16384U) {
        int j;
        u32 cfg_val;
        
#line 9166 
        j = 0;
        
#line 9166 
        goto ldv_57920;
        ldv_57919: 
#line 9167 
        ;
        
#line 9167 
        __const_udelay(429500UL);
        
#line 9166 
        j += 1;
        ldv_57920: 
#line 9167 
        ;
        
#line 9166 
        if (j <= 4999) 
#line 9168 
                       goto ldv_57919; else 
#line 9171 
                                            goto ldv_57921;
        ldv_57921: 
#line 9172 
        ;
        
#line 9169 
        pci_read_config_dword((struct pci_dev const *)tp->pdev,196,& cfg_val);
        
#line 9170 
        pci_write_config_dword((struct pci_dev const *)tp->pdev,196,cfg_val | 32768U);
      }
      else ;
      
#line 9175 
      val16 = (unsigned short)2064U;
      
#line 9180 
      tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
      
#line 9180 
      if (tmp_10 == 0) 
#line 9181 
                       val16 = (unsigned short)((unsigned int)val16 | 224U); else ;
      
#line 9182 
      pcie_capability_clear_word(tp->pdev,8,(unsigned short)((int)val16));
      
#line 9185 
      pcie_capability_write_word(tp->pdev,10,(unsigned short)15);
    }
    else ;
  }
  else ;
  
#line 9192 
  tg3_restore_pci_state(tp);
  
#line 9194 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_CHIP_RESETTING,(unsigned long *)(& tp->tg3_flags));
  
#line 9195 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ERROR_PROCESSED,(unsigned long *)(& tp->tg3_flags));
  
#line 9197 
  val = 0U;
  
#line 9198 
  tmp_13 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
  
#line 9198 
  if (tmp_13 != 0) 
#line 9199 
                   val = (*(tp->read32))(tp,16384U); else ;
  
#line 9200 
  (*(tp->write32))(tp,16384U,val | 2U);
  
#line 9202 
  if (tp->pci_chip_rev_id == 16387U) {
    
#line 9203 
    tg3_stop_fw(tp);
    
#line 9204 
    (*(tp->write32))(tp,20480U,1024U);
  }
  else ;
  
#line 9207 
  tmp_14 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
  
#line 9207 
  if (tmp_14 != 0) {
    
#line 9213 
    tg3_stop_fw(tp);
    
#line 9214 
    tg3_halt_cpu(tp,20480U);
  }
  else ;
  
#line 9217 
  err = tg3_poll_fw(tp);
  
#line 9218 
  if (err != 0) {
    
#line 9219 
    __retres = err;
    
#line 9219 
    goto return_label;
  }
  else ;
  
#line 9221 
  (*(tp->write32))(tp,26624U,tp->grc_mode);
  
#line 9223 
  if (tp->pci_chip_rev_id == 12288U) {
    
#line 9224 
    val = (*(tp->read32))(tp,196U);
    
#line 9226 
    (*(tp->write32))(tp,196U,val | 32768U);
  }
  else ;
  
#line 9229 
  if ((tp->nic_sram_data_cfg & 4096U) != 0U && tp->pci_chip_rev_id >> 12 == 3U) {
    
#line 9231 
    tp->pci_clock_ctrl |= 4194304U;
    
#line 9232 
    if (tp->pci_chip_rev_id == 12288U) 
#line 9233 
                                       tp->pci_clock_ctrl |= 2097152U; else ;
    
#line 9234 
    (*(tp->write32))(tp,116U,tp->pci_clock_ctrl);
  }
  else ;
  
#line 9237 
  if ((tp->phy_flags & 16U) != 0U) {
    
#line 9238 
    tp->mac_mode = 12U;
    
#line 9239 
    val = tp->mac_mode;
  }
  else 
    
#line 9240 
    if ((tp->phy_flags & 32U) != 0U) {
      
#line 9241 
      tp->mac_mode = 8U;
      
#line 9242 
      val = tp->mac_mode;
    }
    else 
#line 9244 
         val = 0U;
  
#line 9246 
  _tw32_flush(tp,1024U,val,0U);
  
#line 9247 
  __const_udelay(171800UL);
  
#line 9249 
  tg3_ape_unlock(tp,1);
  
#line 9251 
  tg3_mdio_start(tp);
  
#line 9253 
  tmp_15 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
  
#line 9253 
  if (tmp_15 != 0) {
    
#line 9253 
    if (tp->pci_chip_rev_id != 16384U) {
      
#line 9254 
      if (tp->pci_chip_rev_id >> 12 != 22405U) {
        int tmp_16;
        
#line 9255 
        tmp_16 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
        
#line 9255 
        if (tmp_16 == 0) {
          
#line 9257 
          val = (*(tp->read32))(tp,31744U);
          
#line 9259 
          (*(tp->write32))(tp,31744U,val | 33554432U);
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 9262 
  tg3_restore_clk(tp);
  
#line 9265 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 9266 
  tp->phy_flags &= 4293394431U;
  
#line 9269 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ASF_NEW_HANDSHAKE,(unsigned long *)(& tp->tg3_flags));
  
#line 9270 
  tg3_read_mem(tp,2900U,& val);
  
#line 9271 
  if (val == 1264940628U) {
    u32 nic_cfg;
    
#line 9274 
    tg3_read_mem(tp,2904U,& nic_cfg);
    
#line 9275 
    if ((nic_cfg & 128U) != 0U) {
      int tmp_17;
      
#line 9276 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
      
#line 9277 
      tp->__anonCompField_tg3_119.last_event_jiffies = jiffies;
      
#line 9278 
      tmp_17 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 9278 
      if (tmp_17 != 0) 
#line 9279 
                       _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ASF_NEW_HANDSHAKE,(unsigned long *)(& tp->tg3_flags)); else ;
      
#line 9281 
      tg3_read_mem(tp,3388U,& nic_cfg);
      
#line 9282 
      if ((nic_cfg & 8388608U) != 0U) 
#line 9283 
                                      tp->phy_flags |= 524288U; else ;
      
#line 9284 
      if ((nic_cfg & 4194304U) != 0U) 
#line 9285 
                                      tp->phy_flags |= 1048576U; else ;
    }
    else ;
  }
  else ;
  
#line 9289 
  __retres = 0;
  return_label: 
#line 9289 
                return __retres;
}


#line 9292 
static void tg3_get_nstats(struct tg3 *tp, struct rtnl_link_stats64 *stats);


#line 9293 
static void tg3_get_estats(struct tg3 *tp, struct tg3_ethtool_stats *estats);


#line 9294 
static void __tg3_set_rx_mode(struct net_device *dev);


#line 9297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_halt(struct tg3 *tp, int kind, bool silent)
{
  int err;
  
#line 9301 
  tg3_stop_fw(tp);
  
#line 9303 
  tg3_write_sig_pre_reset(tp,kind);
  
#line 9305 
  tg3_abort_hw(tp,(_Bool)((bool)((int)silent) != 0));
  
#line 9306 
  err = tg3_chip_reset(tp);
  
#line 9308 
  __tg3_set_mac_addr(tp,(_Bool)0);
  
#line 9310 
  tg3_write_sig_legacy(tp,kind);
  
#line 9311 
  tg3_write_sig_post_reset(tp,kind);
  
#line 9313 
  if (tp->hw_stats != (struct tg3_hw_stats *)0) {
    
#line 9315 
    tg3_get_nstats(tp,& tp->net_stats_prev);
    
#line 9316 
    tg3_get_estats(tp,& tp->estats_prev);
    
#line 9319 
    memset((void *)tp->hw_stats,0,2048UL);
  }
  else ;
  
#line 9322 
  return err;
}


#line 9325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_mac_addr(struct net_device *dev, void *p)
{
  int __retres;
  int tmp_1;
  bool tmp_0;
  int tmp_3;
  bool tmp_2;
  int tmp_4;
  
#line 9327 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 9328 
  struct sockaddr *addr = (struct sockaddr *)p;
  
#line 9329 
  int err = 0;
  
#line 9330 
  bool skip_mac_1 = (_Bool)0;
  
#line 9332 
  tmp_0 = is_valid_ether_addr((u8 const *)(& addr->sa_data));
  
#line 9332 
  if (tmp_0) 
#line 9332 
             tmp_1 = 0; else 
#line 9332 
                             tmp_1 = 1;
  
#line 9332 
  if (tmp_1) {
    
#line 9333 
    __retres = -99;
    
#line 9333 
    goto return_label;
  }
  else ;
  
#line 9335 
  memcpy((void *)dev->dev_addr,(void const *)(& addr->sa_data),(unsigned long)dev->addr_len);
  
#line 9337 
  tmp_2 = netif_running((struct net_device const *)dev);
  
#line 9337 
  if (tmp_2) 
#line 9337 
             tmp_3 = 0; else 
#line 9337 
                             tmp_3 = 1;
  
#line 9337 
  if (tmp_3) {
    
#line 9338 
    __retres = 0;
    
#line 9338 
    goto return_label;
  }
  else ;
  
#line 9340 
  tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 9340 
  if (tmp_4 != 0) {
    u32 addr0_high;
    u32 addr0_low;
    u32 addr1_high;
    u32 addr1_low;
    
#line 9343 
    addr0_high = (*(tp->read32))(tp,1040U);
    
#line 9344 
    addr0_low = (*(tp->read32))(tp,1044U);
    
#line 9345 
    addr1_high = (*(tp->read32))(tp,1048U);
    
#line 9346 
    addr1_low = (*(tp->read32))(tp,1052U);
    
#line 9349 
    if ((addr0_high != addr1_high || addr0_low != addr1_low) && (addr1_high != 0U || addr1_low != 0U)) 
      
#line 9351 
      skip_mac_1 = (_Bool)1; else ;
  }
  else ;
  
#line 9353 
  ldv_spin_lock_bh_103(& tp->lock);
  
#line 9354 
  __tg3_set_mac_addr(tp,(_Bool)((bool)((int)skip_mac_1) != 0));
  
#line 9355 
  __tg3_set_rx_mode(dev);
  
#line 9356 
  ldv_spin_unlock_bh_104(& tp->lock);
  
#line 9358 
  __retres = err;
  return_label: 
#line 9358 
                return __retres;
}


#line 9362  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_set_bdinfo(struct tg3 *tp, u32 bdinfo_addr, dma_addr_t mapping, u32 maxlen_flags, u32 nic_addr)
{
  int tmp;
  
#line 9366 
  tg3_write_mem(tp,bdinfo_addr,(unsigned int)(mapping >> 32));
  
#line 9369 
  tg3_write_mem(tp,bdinfo_addr + 4U,(unsigned int)mapping);
  
#line 9372 
  tg3_write_mem(tp,bdinfo_addr + 8U,maxlen_flags);
  
#line 9376 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9376 
  if (tmp == 0) 
#line 9377 
                tg3_write_mem(tp,bdinfo_addr + 12U,nic_addr); else ;
  
#line 9379 
  return;
}


#line 9383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_coal_tx_init(struct tg3 *tp, struct ethtool_coalesce *ec)
{
  int tmp;
  
#line 9385 
  int i = 0;
  
#line 9387 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
  
#line 9387 
  if (tmp == 0) {
    
#line 9388 
    (*(tp->write32))(tp,15372U,ec->tx_coalesce_usecs);
    
#line 9389 
    (*(tp->write32))(tp,15380U,ec->tx_max_coalesced_frames);
    
#line 9390 
    (*(tp->write32))(tp,15396U,ec->tx_max_coalesced_frames_irq);
  }
  else {
    
#line 9392 
    (*(tp->write32))(tp,15372U,0U);
    
#line 9393 
    (*(tp->write32))(tp,15380U,0U);
    
#line 9394 
    (*(tp->write32))(tp,15396U,0U);
    
#line 9396 
    goto ldv_57963;
    ldv_57962: 
#line 9397 
    ;
    {
      u32 reg;
      
#line 9399 
      reg = (unsigned int)(i * 24 + 15748);
      
#line 9400 
      (*(tp->write32))(tp,reg,ec->tx_coalesce_usecs);
      
#line 9401 
      reg = (unsigned int)(i * 24 + 15756);
      
#line 9402 
      (*(tp->write32))(tp,reg,ec->tx_max_coalesced_frames);
      
#line 9403 
      reg = (unsigned int)(i * 24 + 15764);
      
#line 9404 
      (*(tp->write32))(tp,reg,ec->tx_max_coalesced_frames_irq);
    }
    
#line 9396 
    i += 1;
    ldv_57963: 
#line 9397 
    ;
    
#line 9396 
    if (tp->txq_cnt > (unsigned int)i) 
#line 9398 
                                       goto ldv_57962; else 
#line 9401 
                                                            goto ldv_57964;
    ldv_57964: 
#line 9402 
    ;
  }
  
#line 9408 
  goto ldv_57966;
  ldv_57965: 
#line 9409 
  ;
  
#line 9409 
  (*(tp->write32))(tp,(unsigned int)(i * 24 + 15748),0U);
  
#line 9410 
  (*(tp->write32))(tp,(unsigned int)(i * 24 + 15756),0U);
  
#line 9411 
  (*(tp->write32))(tp,(unsigned int)(i * 24 + 15764),0U);
  
#line 9408 
  i += 1;
  ldv_57966: 
#line 9409 
  ;
  
#line 9408 
  if (tp->irq_max + 4294967295U > (unsigned int)i) 
#line 9410 
                                                   goto ldv_57965; else 
                                                                    
#line 9413 
                                                                    goto ldv_57967;
  ldv_57967: 
#line 9414 
  ;
  
#line 9415 
  return;
}


#line 9415  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_coal_rx_init(struct tg3 *tp, struct ethtool_coalesce *ec)
{
  int tmp;
  
#line 9417 
  int i = 0;
  
#line 9418 
  u32 limit = tp->rxq_cnt;
  
#line 9420 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 9420 
  if (tmp == 0) {
    
#line 9421 
    (*(tp->write32))(tp,15368U,ec->rx_coalesce_usecs);
    
#line 9422 
    (*(tp->write32))(tp,15376U,ec->rx_max_coalesced_frames);
    
#line 9423 
    (*(tp->write32))(tp,15392U,ec->rx_max_coalesced_frames_irq);
    
#line 9424 
    limit -= 1U;
  }
  else {
    
#line 9426 
    (*(tp->write32))(tp,15368U,0U);
    
#line 9427 
    (*(tp->write32))(tp,15376U,0U);
    
#line 9428 
    (*(tp->write32))(tp,15392U,0U);
  }
  
#line 9431 
  goto ldv_57976;
  ldv_57975: 
#line 9432 
  ;
  {
    u32 reg;
    
#line 9434 
    reg = (unsigned int)(i * 24 + 15744);
    
#line 9435 
    (*(tp->write32))(tp,reg,ec->rx_coalesce_usecs);
    
#line 9436 
    reg = (unsigned int)(i * 24 + 15752);
    
#line 9437 
    (*(tp->write32))(tp,reg,ec->rx_max_coalesced_frames);
    
#line 9438 
    reg = (unsigned int)(i * 24 + 15760);
    
#line 9439 
    (*(tp->write32))(tp,reg,ec->rx_max_coalesced_frames_irq);
  }
  
#line 9431 
  i += 1;
  ldv_57976: 
#line 9432 
  ;
  
#line 9431 
  if ((unsigned int)i < limit) 
#line 9433 
                               goto ldv_57975; else 
#line 9436 
                                                    goto ldv_57977;
  ldv_57977: 
#line 9437 
  ;
  
#line 9442 
  goto ldv_57979;
  ldv_57978: 
#line 9443 
  ;
  
#line 9443 
  (*(tp->write32))(tp,(unsigned int)(i * 24 + 15744),0U);
  
#line 9444 
  (*(tp->write32))(tp,(unsigned int)(i * 24 + 15752),0U);
  
#line 9445 
  (*(tp->write32))(tp,(unsigned int)(i * 24 + 15760),0U);
  
#line 9442 
  i += 1;
  ldv_57979: 
#line 9443 
  ;
  
#line 9442 
  if (tp->irq_max + 4294967295U > (unsigned int)i) 
#line 9444 
                                                   goto ldv_57978; else 
                                                                    
#line 9447 
                                                                    goto ldv_57980;
  ldv_57980: 
#line 9448 
  ;
  
#line 9449 
  return;
}


#line 9449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void __tg3_set_coalesce(struct tg3 *tp, struct ethtool_coalesce *ec)
{
  int tmp;
  
#line 9451 
  tg3_coal_tx_init(tp,ec);
  
#line 9452 
  tg3_coal_rx_init(tp,ec);
  
#line 9454 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9454 
  if (tmp == 0) {
    
#line 9455 
    u32 val = ec->stats_block_coalesce_usecs;
    
#line 9457 
    (*(tp->write32))(tp,15384U,ec->rx_coalesce_usecs_irq);
    
#line 9458 
    (*(tp->write32))(tp,15388U,ec->tx_coalesce_usecs_irq);
    
#line 9460 
    if (! tp->link_up) 
#line 9461 
                       val = 0U; else ;
    
#line 9463 
    (*(tp->write32))(tp,15400U,val);
  }
  else ;
  
#line 9465 
  return;
}


#line 9468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_tx_rcbs_disable(struct tg3 *tp)
{
  u32 txrcb;
  u32 limit;
  int tmp_1;
  
#line 9473 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9473 
  if (tmp_1 == 0) 
#line 9474 
                  limit = 512U;
  else {
    int tmp_0;
    
#line 9475 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 9475 
    if (tmp_0 != 0) 
#line 9476 
                    limit = 320U;
    else {
      int tmp;
      
#line 9477 
      tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
      
#line 9477 
      if (tmp != 0) 
#line 9477 
                    goto _LOR;
      else 
        
#line 9477 
        if (tp->pci_chip_rev_id >> 12 == 22370U) _LOR: 
#line 9479 
                                                       limit = 288U; else 
                                                                    
#line 9481 
                                                                    limit = 272U;
    }
  }
  
#line 9483 
  txrcb = 272U;
  
#line 9483 
  goto ldv_57992;
  ldv_57991: 
#line 9484 
  ;
  
#line 9485 
  tg3_write_mem(tp,txrcb + 8U,2U);
  
#line 9484 
  txrcb += 16U;
  ldv_57992: 
#line 9485 
  ;
  
#line 9483 
  if (txrcb < limit) 
#line 9486 
                     goto ldv_57991; else 
#line 9489 
                                          goto ldv_57993;
  ldv_57993: 
#line 9490 
  ;
  
#line 9491 
  return;
}


#line 9490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_tx_rcbs_init(struct tg3 *tp)
{
  int tmp;
  
#line 9492 
  int i = 0;
  
#line 9493 
  u32 txrcb = 256U;
  
#line 9495 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
  
#line 9495 
  if (tmp != 0) 
#line 9496 
                i += 1; else ;
  
#line 9498 
  goto ldv_58002;
  ldv_58001: 
#line 9499 
  ;
  {
    
#line 9499 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 9501 
    if (tnapi->tx_ring == (struct tg3_tx_buffer_desc *)0) 
#line 9502 
                                                          goto ldv_58000; else ;
    
#line 9504 
    tg3_set_bdinfo(tp,txrcb,tnapi->tx_desc_mapping,33554432U,16384U);
  }
  ldv_58000: 
#line 9506 
  ;
  
#line 9498 
  i += 1;
  
#line 9498 
  txrcb += 16U;
  ldv_58002: 
#line 9499 
  ;
  
#line 9498 
  if (tp->irq_max > (unsigned int)i) 
#line 9500 
                                     goto ldv_58001; else 
#line 9503 
                                                          goto ldv_58003;
  ldv_58003: 
#line 9504 
  ;
  
#line 9505 
  return;
}


#line 9511  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rx_ret_rcbs_disable(struct tg3 *tp)
{
  u32 rxrcb;
  u32 limit;
  int tmp_1;
  
#line 9516 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9516 
  if (tmp_1 != 0) 
#line 9517 
                  limit = 784U;
  else {
    int tmp_0;
    
#line 9518 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 9518 
    if (tmp_0 == 0) 
#line 9519 
                    limit = 768U;
    else 
      
#line 9520 
      if (tp->pci_chip_rev_id >> 12 == 10U || tp->pci_chip_rev_id >> 12 == 22370U) 
        
#line 9520 
        goto _LOR;
      else {
        int tmp;
        
#line 9521 
        tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
        
#line 9521 
        if (tmp != 0) _LOR: 
#line 9523 
                            limit = 576U; else 
#line 9525 
                                               limit = 528U;
      }
  }
  
#line 9527 
  rxrcb = 528U;
  
#line 9527 
  goto ldv_58010;
  ldv_58009: 
#line 9528 
  ;
  
#line 9529 
  tg3_write_mem(tp,rxrcb + 8U,2U);
  
#line 9528 
  rxrcb += 16U;
  ldv_58010: 
#line 9529 
  ;
  
#line 9527 
  if (rxrcb < limit) 
#line 9530 
                     goto ldv_58009; else 
#line 9533 
                                          goto ldv_58011;
  ldv_58011: 
#line 9534 
  ;
  
#line 9535 
  return;
}


#line 9534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rx_ret_rcbs_init(struct tg3 *tp)
{
  int tmp;
  
#line 9536 
  int i = 0;
  
#line 9537 
  u32 rxrcb = 512U;
  
#line 9539 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 9539 
  if (tmp != 0) 
#line 9540 
                i += 1; else ;
  
#line 9542 
  goto ldv_58020;
  ldv_58019: 
#line 9543 
  ;
  {
    
#line 9543 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 9545 
    if (tnapi->rx_rcb == (struct tg3_rx_buffer_desc *)0) 
#line 9546 
                                                         goto ldv_58018; else ;
    
#line 9548 
    tg3_set_bdinfo(tp,rxrcb,tnapi->rx_rcb_mapping,(tp->rx_ret_ring_mask + 1U) << 16,0U);
  }
  ldv_58018: 
#line 9551 
  ;
  
#line 9542 
  i += 1;
  
#line 9542 
  rxrcb += 16U;
  ldv_58020: 
#line 9543 
  ;
  
#line 9542 
  if (tp->irq_max > (unsigned int)i) 
#line 9544 
                                     goto ldv_58019; else 
#line 9547 
                                                          goto ldv_58021;
  ldv_58021: 
#line 9548 
  ;
  
#line 9549 
  return;
}


#line 9555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rings_reset(struct tg3 *tp)
{
  int i;
  u32 stblk;
  int tmp_1;
  int tmp_2;
  
#line 9559 
  struct tg3_napi *tnapi = & tp->napi[0];
  
#line 9561 
  tg3_tx_rcbs_disable(tp);
  
#line 9563 
  tg3_rx_ret_rcbs_disable(tp);
  
#line 9566 
  tw32_mailbox_flush(tp,tp->napi[0].int_mbox,1U);
  
#line 9567 
  tp->napi[0].chk_msi_cnt = 0U;
  
#line 9568 
  tp->napi[0].last_rx_cons = 0U;
  
#line 9569 
  tp->napi[0].last_tx_cons = 0U;
  
#line 9572 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 9572 
  if (tmp_1 != 0) {
    int tmp;
    int tmp_0;
    
#line 9573 
    i = 1;
    
#line 9573 
    goto ldv_58029;
    ldv_58028: 
#line 9574 
    ;
    
#line 9574 
    tp->napi[i].tx_prod = 0U;
    
#line 9575 
    tp->napi[i].tx_cons = 0U;
    
#line 9576 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
    
#line 9576 
    if (tmp != 0) 
#line 9577 
                  (*(tp->write32_mbox))(tp,tp->napi[i].prodmbox,0U); else ;
    
#line 9578 
    (*(tp->write32_rx_mbox))(tp,tp->napi[i].consmbox,0U);
    
#line 9579 
    tw32_mailbox_flush(tp,tp->napi[i].int_mbox,1U);
    
#line 9580 
    tp->napi[i].chk_msi_cnt = 0U;
    
#line 9581 
    tp->napi[i].last_rx_cons = 0U;
    
#line 9582 
    tp->napi[i].last_tx_cons = 0U;
    
#line 9573 
    i += 1;
    ldv_58029: 
#line 9574 
    ;
    
#line 9573 
    if (tp->irq_max > (unsigned int)i) 
#line 9575 
                                       goto ldv_58028; else 
#line 9578 
                                                            goto ldv_58030;
    ldv_58030: 
#line 9579 
    ;
    
#line 9584 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
    
#line 9584 
    if (tmp_0 == 0) 
#line 9585 
                    (*(tp->write32_mbox))(tp,tp->napi[0].prodmbox,0U); else ;
  }
  else {
    
#line 9587 
    tp->napi[0].tx_prod = 0U;
    
#line 9588 
    tp->napi[0].tx_cons = 0U;
    
#line 9589 
    (*(tp->write32_mbox))(tp,tp->napi[0].prodmbox,0U);
    
#line 9590 
    (*(tp->write32_rx_mbox))(tp,tp->napi[0].consmbox,0U);
  }
  
#line 9594 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9594 
  if (tmp_2 == 0) {
    
#line 9595 
    u32 mbox = 900U;
    
#line 9596 
    i = 0;
    
#line 9596 
    goto ldv_58033;
    ldv_58032: 
#line 9597 
    ;
    
#line 9597 
    (*(tp->write32_tx_mbox))(tp,(unsigned int)(i * 8) + mbox,0U);
    
#line 9596 
    i += 1;
    ldv_58033: 
#line 9597 
    ;
    
#line 9596 
    if (i <= 15) 
#line 9598 
                 goto ldv_58032; else 
#line 9601 
                                      goto ldv_58034;
    ldv_58034: 
#line 9602 
    ;
  }
  else ;
  
#line 9601 
  memset((void *)tnapi->hw_status,0,80UL);
  
#line 9604 
  (*(tp->write32))(tp,15416U,(unsigned int)(tnapi->status_mapping >> 32));
  
#line 9606 
  (*(tp->write32))(tp,15420U,(unsigned int)tnapi->status_mapping);
  
#line 9609 
  stblk = 15616U;
  
#line 9611 
  i = 1;
  
#line 9611 
  tnapi += 1;
  
#line 9611 
  goto ldv_58037;
  ldv_58036: 
#line 9612 
  ;
  {
    
#line 9612 
    u64 mapping = tnapi->status_mapping;
    
#line 9613 
    (*(tp->write32))(tp,stblk,(unsigned int)(mapping >> 32));
    
#line 9614 
    (*(tp->write32))(tp,stblk + 4U,(unsigned int)mapping);
    
#line 9615 
    stblk += 8U;
    
#line 9618 
    memset((void *)tnapi->hw_status,0,80UL);
  }
  
#line 9611 
  i += 1;
  
#line 9611 
  tnapi += 1;
  ldv_58037: 
#line 9612 
  ;
  
#line 9611 
  if (tp->irq_cnt > (unsigned int)i) 
#line 9613 
                                     goto ldv_58036; else 
#line 9616 
                                                          goto ldv_58038;
  ldv_58038: 
#line 9617 
  ;
  
#line 9621 
  tg3_tx_rcbs_init(tp);
  
#line 9622 
  tg3_rx_ret_rcbs_init(tp);
  
#line 9623 
  return;
}


#line 9625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_setup_rxbd_thresholds(struct tg3 *tp)
{
  u32 val;
  u32 bdcache_maxcnt;
  u32 host_rep_thresh;
  u32 nic_rep_thresh;
  int tmp;
  u32 tmp_3;
  u32 tmp_5;
  u32 tmp_7;
  int tmp_8;
  int tmp_9;
  u32 tmp_12;
  u32 tmp_14;
  int tmp_15;
  
#line 9629 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9629 
  if (tmp == 0) 
#line 9629 
                goto _LOR;
  else {
    int tmp_0;
    
#line 9629 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 9629 
    if (tmp_0 != 0) 
#line 9629 
                    goto _LOR;
    else 
      
#line 9630 
      if (tp->pci_chip_rev_id >> 12 == 4U) 
#line 9629 
                                           goto _LOR;
      else 
        
#line 9631 
        if (tp->pci_chip_rev_id >> 12 == 6U) 
#line 9629 
                                             goto _LOR;
        else {
          int tmp_1;
          
#line 9632 
          tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
          
#line 9632 
          if (tmp_1 != 0) _LOR: 
#line 9634 
                                bdcache_maxcnt = 128U;
          else 
            
#line 9635 
            if ((tp->pci_chip_rev_id >> 12) + 4294967286U <= 1U) 
#line 9637 
                                                                 bdcache_maxcnt = 64U; else 
                                                                    
#line 9639 
                                                                    bdcache_maxcnt = 32U;
        }
  }
  {
    u32 tmp_2;
    
#line 9641 
    u32 _min1 = bdcache_maxcnt / 2U;
    
#line 9641 
    u32 _min2 = tp->rx_std_max_post;
    
#line 9641 
    if (_min1 < _min2) 
#line 9641 
                       tmp_2 = _min1; else 
#line 9641 
                                           tmp_2 = _min2;
    
#line 9641 
    tmp_3 = tmp_2;
  }
  
#line 9641 
  nic_rep_thresh = tmp_3;
  {
    u32 tmp_4;
    
#line 9642 
    u32 __max1 = tp->rx_pending / 8U;
    
#line 9642 
    u32 __max2 = 1U;
    
#line 9642 
    if (__max1 > __max2) 
#line 9642 
                         tmp_4 = __max1; else 
#line 9642 
                                              tmp_4 = __max2;
    
#line 9642 
    tmp_5 = tmp_4;
  }
  
#line 9642 
  host_rep_thresh = tmp_5;
  {
    u32 tmp_6;
    
#line 9644 
    u32 _min1_0 = nic_rep_thresh;
    
#line 9644 
    u32 _min2_0 = host_rep_thresh;
    
#line 9644 
    if (_min1_0 < _min2_0) 
#line 9644 
                           tmp_6 = _min1_0; else 
#line 9644 
                                                 tmp_6 = _min2_0;
    
#line 9644 
    tmp_7 = tmp_6;
  }
  
#line 9644 
  val = tmp_7;
  
#line 9645 
  (*(tp->write32))(tp,11288U,val);
  
#line 9647 
  tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9647 
  if (tmp_8 != 0) 
#line 9648 
                  (*(tp->write32))(tp,11520U,bdcache_maxcnt); else ;
  
#line 9650 
  tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 9650 
  if (tmp_9 == 0) 
#line 9651 
                  goto return_label;
  else {
    int tmp_10;
    
#line 9650 
    tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 9650 
    if (tmp_10 != 0) 
#line 9651 
                     goto return_label; else ;
  }
  
#line 9653 
  bdcache_maxcnt = 64U;
  {
    u32 tmp_11;
    
#line 9655 
    u32 __max1_0 = tp->rx_jumbo_pending / 8U;
    
#line 9655 
    u32 __max2_0 = 1U;
    
#line 9655 
    if (__max1_0 > __max2_0) 
#line 9655 
                             tmp_11 = __max1_0; else 
#line 9655 
                                                     tmp_11 = __max2_0;
    
#line 9655 
    tmp_12 = tmp_11;
  }
  
#line 9655 
  host_rep_thresh = tmp_12;
  {
    u32 tmp_13;
    
#line 9657 
    u32 _min1_1 = bdcache_maxcnt / 2U;
    
#line 9657 
    u32 _min2_1 = host_rep_thresh;
    
#line 9657 
    if (_min1_1 < _min2_1) 
#line 9657 
                           tmp_13 = _min1_1; else 
#line 9657 
                                                  tmp_13 = _min2_1;
    
#line 9657 
    tmp_14 = tmp_13;
  }
  
#line 9657 
  val = tmp_14;
  
#line 9658 
  (*(tp->write32))(tp,11292U,val);
  
#line 9660 
  tmp_15 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9660 
  if (tmp_15 != 0) 
#line 9661 
                   (*(tp->write32))(tp,11524U,bdcache_maxcnt); else ;
  return_label: 
#line 9662 
                return;
}


#line 9664  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static u32 calc_crc(unsigned char *buf, int len)
{
  u32 __retres;
  u32 reg;
  u32 tmp;
  int j;
  int k;
  
#line 9670 
  reg = 4294967295U;
  
#line 9672 
  j = 0;
  
#line 9672 
  goto ldv_58073;
  ldv_58072: 
#line 9673 
  ;
  
#line 9673 
  reg = (unsigned int)*(buf + j) ^ reg;
  
#line 9675 
  k = 0;
  
#line 9675 
  goto ldv_58070;
  ldv_58069: 
#line 9676 
  ;
  
#line 9676 
  tmp = reg & 1U;
  
#line 9678 
  reg >>= 1;
  
#line 9680 
  if (tmp != 0U) 
#line 9681 
                 reg ^= 3988292384U; else ;
  
#line 9675 
  k += 1;
  ldv_58070: 
#line 9676 
  ;
  
#line 9675 
  if (k <= 7) 
#line 9677 
              goto ldv_58069; else 
#line 9680 
                                   goto ldv_58071;
  ldv_58071: 
#line 9681 
  ;
  
#line 9672 
  j += 1;
  ldv_58073: 
#line 9673 
  ;
  
#line 9672 
  if (j < len) 
#line 9674 
               goto ldv_58072; else 
#line 9677 
                                    goto ldv_58074;
  ldv_58074: 
#line 9678 
  ;
  
#line 9685 
  __retres = ~ reg;
  
#line 9685 
  return __retres;
}


#line 9688  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_set_multi(struct tg3 *tp, unsigned int accept_all)
{
  unsigned int tmp;
  unsigned int tmp_0;
  unsigned int tmp_1;
  unsigned int tmp_2;
  
#line 9691 
  if (accept_all != 0U) 
#line 9691 
                        tmp = 4294967295U; else 
#line 9691 
                                                tmp = 0U;
  
#line 9691 
  ;
  
#line 9691 
  (*(tp->write32))(tp,1136U,tmp);
  
#line 9692 
  if (accept_all != 0U) 
#line 9692 
                        tmp_0 = 4294967295U; else 
#line 9692 
                                                  tmp_0 = 0U;
  
#line 9692 
  ;
  
#line 9692 
  (*(tp->write32))(tp,1140U,tmp_0);
  
#line 9693 
  if (accept_all != 0U) 
#line 9693 
                        tmp_1 = 4294967295U; else 
#line 9693 
                                                  tmp_1 = 0U;
  
#line 9693 
  ;
  
#line 9693 
  (*(tp->write32))(tp,1144U,tmp_1);
  
#line 9694 
  if (accept_all != 0U) 
#line 9694 
                        tmp_2 = 4294967295U; else 
#line 9694 
                                                  tmp_2 = 0U;
  
#line 9694 
  ;
  
#line 9694 
  (*(tp->write32))(tp,1148U,tmp_2);
  
#line 9695 
  return;
}


#line 9697  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void __tg3_set_rx_mode(struct net_device *dev)
{
  u32 rx_mode;
  int tmp_7;
  int tmp_6;
  
#line 9699 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 9702 
  rx_mode = tp->rx_mode & 4294966015U;
  
#line 9713 
  if ((dev->flags & 256U) != 0U) 
#line 9715 
                                 rx_mode |= 256U;
  else 
    
#line 9716 
    if ((dev->flags & 512U) != 0U) 
#line 9718 
                                   tg3_set_multi(tp,1U);
    else 
      
#line 9719 
      if (dev->mc.count == 0) 
#line 9721 
                              tg3_set_multi(tp,0U);
      else {
        struct netdev_hw_addr *ha;
        u32 regidx;
        u32 bit;
        u32 crc;
        struct netdev_hw_addr *tmp_0;
        struct netdev_hw_addr *tmp_1;
        
#line 9725 
        u32 mc_filter[4U] = {0U};
        {
          
#line 9730 
          struct list_head const *__mptr = (struct list_head const *)dev->mc.list.next;
          
#line 9730 
          tmp_0 = (struct netdev_hw_addr *)__mptr;
        }
        
#line 9730 
        ha = tmp_0;
        
#line 9730 
        goto ldv_58094;
        ldv_58093: 
#line 9731 
        ;
        
#line 9731 
        crc = calc_crc((unsigned char *)(& ha->addr),6);
        
#line 9732 
        bit = ~ crc & 127U;
        
#line 9733 
        regidx = (bit >> 5) & 3U;
        
#line 9734 
        bit &= 31U;
        
#line 9735 
        mc_filter[regidx] |= (unsigned int)(1 << bit);
        {
          
#line 9730 
          struct list_head const *__mptr_0 = (struct list_head const *)ha->list.next;
          
#line 9730 
          tmp_1 = (struct netdev_hw_addr *)__mptr_0;
        }
        
#line 9730 
        ha = tmp_1;
        ldv_58094: 
#line 9732 
        ;
        
#line 9730 
        if (& ha->list != & dev->mc.list) 
#line 9732 
                                          goto ldv_58093; else 
#line 9735 
                                                               goto ldv_58095;
        ldv_58095: 
#line 9736 
        ;
        
#line 9738 
        (*(tp->write32))(tp,1136U,mc_filter[0]);
        
#line 9739 
        (*(tp->write32))(tp,1140U,mc_filter[1]);
        
#line 9740 
        (*(tp->write32))(tp,1144U,mc_filter[2]);
        
#line 9741 
        (*(tp->write32))(tp,1148U,mc_filter[3]);
      }
  
#line 9744 
  tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 9744 
  if (tmp_6 != 0) 
#line 9744 
                  tmp_7 = 2; else 
#line 9744 
                                  tmp_7 = 3;
  
#line 9744 
  ;
  
#line 9744 
  if (dev->uc.count > tmp_7) 
#line 9745 
                             rx_mode |= 256U;
  else 
    
#line 9746 
    if ((dev->flags & 256U) == 0U) {
      struct netdev_hw_addr *ha_0;
      struct netdev_hw_addr *tmp_2;
      int tmp_4;
      int tmp_3;
      struct netdev_hw_addr *tmp_5;
      
#line 9748 
      int i = 0;
      {
        
#line 9751 
        struct list_head const *__mptr_1 = (struct list_head const *)dev->uc.list.next;
        
#line 9751 
        tmp_2 = (struct netdev_hw_addr *)__mptr_1;
      }
      
#line 9751 
      ha_0 = tmp_2;
      
#line 9751 
      goto ldv_58103;
      ldv_58102: 
#line 9752 
      ;
      
#line 9752 
      tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
      
#line 9752 
      if (tmp_3 != 0) 
#line 9752 
                      tmp_4 = 2; else 
#line 9752 
                                      tmp_4 = 1;
      
#line 9752 
      ;
      
#line 9752 
      ;
      
#line 9752 
      ;
      
#line 9752 
      __tg3_set_one_mac_addr(tp,(u8 *)(& ha_0->addr),tmp_4 + i);
      
#line 9754 
      i += 1;
      {
        
#line 9751 
        struct list_head const *__mptr_2 = (struct list_head const *)ha_0->list.next;
        
#line 9751 
        tmp_5 = (struct netdev_hw_addr *)__mptr_2;
      }
      
#line 9751 
      ha_0 = tmp_5;
      ldv_58103: 
#line 9753 
      ;
      
#line 9751 
      if (& ha_0->list != & dev->uc.list) 
#line 9753 
                                          goto ldv_58102; else 
#line 9756 
                                                               goto ldv_58104;
      ldv_58104: 
#line 9757 
      ;
    }
    else ;
  
#line 9758 
  if (tp->rx_mode != rx_mode) {
    
#line 9759 
    tp->rx_mode = rx_mode;
    
#line 9760 
    _tw32_flush(tp,1128U,rx_mode,0U);
    
#line 9761 
    __const_udelay(42950UL);
  }
  else ;
  
#line 9764 
  return;
}


#line 9765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rss_init_dflt_indir_tbl(struct tg3 *tp, u32 qcnt)
{
  int i;
  u32 tmp;
  
#line 9769 
  i = 0;
  
#line 9769 
  goto ldv_58111;
  ldv_58110: 
#line 9770 
  ;
  
#line 9770 
  tmp = ethtool_rxfh_indir_default((unsigned int)i,qcnt);
  
#line 9770 
  tp->rss_ind_tbl[i] = (unsigned char)tmp;
  
#line 9769 
  i += 1;
  ldv_58111: 
#line 9770 
  ;
  
#line 9769 
  if (i <= 127) 
#line 9771 
                goto ldv_58110; else 
#line 9774 
                                     goto ldv_58112;
  ldv_58112: 
#line 9775 
  ;
  
#line 9776 
  return;
}


#line 9773  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rss_check_indir_tbl(struct tg3 *tp)
{
  int i;
  int tmp;
  
#line 9777 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 9777 
  if (tmp == 0) 
#line 9778 
                goto return_label; else ;
  
#line 9780 
  if (tp->rxq_cnt == 1U) {
    
#line 9781 
    memset((void *)(& tp->rss_ind_tbl[0]),0,128UL);
    
#line 9782 
    goto return_label;
  }
  else ;
  
#line 9786 
  i = 0;
  
#line 9786 
  goto ldv_58119;
  ldv_58118: 
#line 9787 
  ;
  
#line 9787 
  if ((unsigned int)tp->rss_ind_tbl[i] >= tp->rxq_cnt) 
#line 9788 
                                                       goto ldv_58117; else ;
  
#line 9786 
  i += 1;
  ldv_58119: 
#line 9787 
  ;
  
#line 9786 
  if (i <= 127) 
#line 9788 
                goto ldv_58118; else 
#line 9791 
                                     goto ldv_58117;
  ldv_58117: 
#line 9792 
  ;
  
#line 9791 
  if (i != 128) 
#line 9792 
                tg3_rss_init_dflt_indir_tbl(tp,tp->rxq_cnt); else ;
  return_label: 
#line 9793 
                return;
}


#line 9795  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_rss_write_indir_tbl(struct tg3 *tp)
{
  
#line 9797 
  int i = 0;
  
#line 9798 
  u32 reg = 1584U;
  
#line 9800 
  goto ldv_58130;
  ldv_58129: 
#line 9801 
  ;
  {
    
#line 9801 
    u32 val = (unsigned int)tp->rss_ind_tbl[i];
    
#line 9802 
    i += 1;
    
#line 9803 
    goto ldv_58127;
    ldv_58126: 
#line 9804 
    ;
    
#line 9804 
    val <<= 4;
    
#line 9805 
    val = (unsigned int)tp->rss_ind_tbl[i] | val;
    
#line 9803 
    i += 1;
    ldv_58127: 
#line 9804 
    ;
    
#line 9803 
    if (((unsigned int)i & 7U) != 0U) 
#line 9805 
                                      goto ldv_58126; else 
#line 9808 
                                                           goto ldv_58128;
    ldv_58128: 
#line 9809 
    ;
    
#line 9807 
    (*(tp->write32))(tp,reg,val);
    
#line 9808 
    reg += 4U;
  }
  ldv_58130: 
#line 9810 
  ;
  
#line 9800 
  if (i <= 127) 
#line 9802 
                goto ldv_58129; else 
#line 9805 
                                     goto ldv_58131;
  ldv_58131: 
#line 9806 
  ;
  
#line 9807 
  return;
}


#line 9812  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static u32 tg3_lso_rd_dma_workaround_bit(struct tg3 *tp)
{
  u32 __retres;
  
#line 9814 
  if (tp->pci_chip_rev_id >> 12 == 22297U) {
    
#line 9815 
    __retres = 33554432U;
    
#line 9815 
    goto return_label;
  }
  else {
    
#line 9817 
    __retres = 2097152U;
    
#line 9817 
    goto return_label;
  }
  return_label: 
#line 9814 
                return __retres;
}


#line 9821  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_reset_hw(struct tg3 *tp, bool reset_phy)
{
  int __retres;
  u32 val;
  u32 rdmac_mode;
  int i;
  int err;
  int limit;
  int tmp;
  int tmp_4;
  int tmp_6;
  int tmp_8;
  int tmp_10;
  int tmp_13;
  int tmp_14;
  int tmp_16;
  u32 tmp_17;
  int tmp_19;
  int tmp_20;
  int tmp_31;
  int tmp_36;
  int tmp_37;
  int tmp_40;
  int tmp_44;
  u32 tmp_45;
  int tmp_46;
  int tmp_47;
  int tmp_48;
  int tmp_49;
  int tmp_52;
  int tmp_54;
  int tmp_55;
  int tmp_59;
  int tmp_60;
  int tmp_65;
  int tmp_66;
  int tmp_67;
  int tmp_70;
  int tmp_71;
  int tmp_72;
  int tmp_74;
  int tmp_75;
  int tmp_76;
  int tmp_77;
  int tmp_81;
  int tmp_82;
  int tmp_84;
  int tmp_85;
  
#line 9825 
  struct tg3_rx_prodring_set *tpr = & tp->napi[0].prodring;
  
#line 9827 
  tg3_disable_ints(tp);
  
#line 9829 
  tg3_stop_fw(tp);
  
#line 9831 
  tg3_write_sig_pre_reset(tp,1);
  
#line 9833 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
  
#line 9833 
  if (tmp != 0) 
#line 9834 
                tg3_abort_hw(tp,(_Bool)1); else ;
  
#line 9836 
  if ((tp->phy_flags & 1048576U) != 0U && (tp->phy_flags & 8U) == 0U) {
    
#line 9838 
    tg3_phy_pull_config(tp);
    
#line 9839 
    tg3_eee_pull_config(tp,(struct ethtool_eee *)0);
    
#line 9840 
    tp->phy_flags |= 8U;
  }
  else ;
  
#line 9844 
  if ((tp->phy_flags & 262144U) != 0U) 
#line 9845 
                                       tg3_setup_eee(tp); else ;
  
#line 9847 
  if ((int)reset_phy != 0) 
#line 9848 
                           tg3_phy_reset(tp); else ;
  
#line 9850 
  err = tg3_chip_reset(tp);
  
#line 9851 
  if (err != 0) {
    
#line 9852 
    __retres = err;
    
#line 9852 
    goto return_label;
  }
  else ;
  
#line 9854 
  tg3_write_sig_legacy(tp,1);
  
#line 9856 
  if (tp->pci_chip_rev_id >> 8 == 358464U) {
    
#line 9857 
    val = (*(tp->read32))(tp,13824U);
    
#line 9858 
    val &= 4294965759U;
    
#line 9859 
    (*(tp->write32))(tp,13824U,val);
    
#line 9861 
    val = (*(tp->read32))(tp,13828U);
    
#line 9862 
    val &= 4292935679U;
    
#line 9863 
    val |= 1245184U;
    
#line 9864 
    (*(tp->write32))(tp,13828U,val);
    
#line 9866 
    val = (*(tp->read32))(tp,13840U);
    
#line 9867 
    val &= 4292935679U;
    
#line 9868 
    val |= 1245184U;
    
#line 9869 
    (*(tp->write32))(tp,13840U,val);
    
#line 9871 
    val = (*(tp->read32))(tp,13852U);
    
#line 9872 
    val &= 4292935679U;
    
#line 9873 
    val |= 1245184U;
    
#line 9874 
    (*(tp->write32))(tp,13852U,val);
  }
  else ;
  
#line 9877 
  if (tp->pci_chip_rev_id >> 12 == 358272U) {
    u32 tmp_0;
    u32 tmp_1;
    u32 tmp_2;
    
#line 9878 
    tmp_0 = (*(tp->read32))(tp,32040U);
    
#line 9878 
    val = tmp_0 & 4294902015U;
    
#line 9879 
    val |= 16842496U;
    
#line 9881 
    (*(tp->write32))(tp,32040U,val);
    
#line 9883 
    tmp_1 = (*(tp->read32))(tp,32368U);
    
#line 9883 
    val = tmp_1 & 4294967264U;
    
#line 9884 
    (*(tp->write32))(tp,32368U,val | 12U);
    
#line 9886 
    (*(tp->write32))(tp,272U,4294967295U);
    
#line 9888 
    tmp_2 = (*(tp->read32))(tp,32084U);
    
#line 9888 
    val = tmp_2 & 4294967287U;
    
#line 9889 
    (*(tp->write32))(tp,32084U,val | 128U);
  }
  else ;
  
#line 9892 
  tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_L1PLLPD_EN,(unsigned long *)(& tp->tg3_flags));
  
#line 9892 
  if (tmp_4 != 0) {
    u32 tmp_3;
    
#line 9893 
    tmp_3 = (*(tp->read32))(tp,26624U);
    
#line 9893 
    u32 grc_mode = tmp_3;
    
#line 9896 
    val = grc_mode & 1606418431U;
    
#line 9897 
    (*(tp->write32))(tp,26624U,val | 4194304U);
    
#line 9899 
    val = (*(tp->read32))(tp,31748U);
    
#line 9900 
    (*(tp->write32))(tp,31748U,val | 4096U);
    
#line 9903 
    (*(tp->write32))(tp,26624U,grc_mode);
  }
  else ;
  
#line 9906 
  tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
  
#line 9906 
  if (tmp_6 != 0) {
    
#line 9907 
    if (tp->pci_chip_rev_id == 1467502592U) {
      u32 tmp_5;
      
#line 9908 
      tmp_5 = (*(tp->read32))(tp,26624U);
      
#line 9908 
      u32 grc_mode_0 = tmp_5;
      
#line 9911 
      val = grc_mode_0 & 1606418431U;
      
#line 9912 
      (*(tp->write32))(tp,26624U,val | 4194304U);
      
#line 9914 
      val = (*(tp->read32))(tp,31764U);
      
#line 9916 
      (*(tp->write32))(tp,31764U,val | 2147483648U);
      
#line 9919 
      (*(tp->write32))(tp,26624U,grc_mode_0);
    }
    else ;
    
#line 9922 
    if (tp->pci_chip_rev_id >> 8 != 5731920U) {
      u32 grc_mode_1;
      
#line 9926 
      val = (*(tp->read32))(tp,13928U);
      
#line 9927 
      val |= 262144U;
      
#line 9928 
      (*(tp->write32))(tp,13928U,val);
      
#line 9930 
      grc_mode_1 = (*(tp->read32))(tp,26624U);
      
#line 9933 
      val = grc_mode_1 & 1606418431U;
      
#line 9934 
      (*(tp->write32))(tp,26624U,val | 536870912U);
      
#line 9936 
      val = (*(tp->read32))(tp,31756U);
      
#line 9938 
      val &= 4294967040U;
      
#line 9939 
      (*(tp->write32))(tp,31756U,val | 44U);
      
#line 9942 
      (*(tp->write32))(tp,26624U,grc_mode_1);
    }
    else ;
    
#line 9945 
    val = (*(tp->read32))(tp,13828U);
    
#line 9946 
    val &= 4292935679U;
    
#line 9947 
    val |= 1245184U;
    
#line 9948 
    (*(tp->write32))(tp,13828U,val);
  }
  else ;
  
#line 9956 
  tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
  
#line 9956 
  if (tmp_8 == 0) {
    int tmp_7;
    
#line 9957 
    tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
    
#line 9957 
    if (tmp_7 == 0) 
#line 9958 
                    tp->pci_clock_ctrl |= 2147483648U; else ;
    
#line 9959 
    _tw32_flush(tp,116U,tp->pci_clock_ctrl,0U);
  }
  else ;
  
#line 9962 
  if (tp->pci_chip_rev_id == 8192U) {
    int tmp_9;
    
#line 9962 
    tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
    
#line 9962 
    if (tmp_9 != 0) {
      
#line 9964 
      val = (*(tp->read32))(tp,112U);
      
#line 9965 
      val |= 8192U;
      
#line 9966 
      (*(tp->write32))(tp,112U,val);
    }
    else ;
  }
  else ;
  
#line 9969 
  tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 9969 
  if (tmp_10 != 0) {
    
#line 9973 
    val = (*(tp->read32))(tp,112U);
    
#line 9974 
    val |= 458752U;
    
#line 9977 
    (*(tp->write32))(tp,112U,val);
  }
  else ;
  
#line 9980 
  if (tp->pci_chip_rev_id >> 8 == 33U) {
    
#line 9982 
    val = (*(tp->read32))(tp,100U);
    
#line 9983 
    val |= 872415232U;
    
#line 9984 
    (*(tp->write32))(tp,100U,val);
  }
  else ;
  
#line 9992 
  err = tg3_init_rings(tp);
  
#line 9993 
  if (err != 0) {
    
#line 9994 
    __retres = err;
    
#line 9994 
    goto return_label;
  }
  else ;
  
#line 9996 
  tmp_13 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 9996 
  if (tmp_13 != 0) {
    u32 tmp_11;
    int tmp_12;
    
#line 9997 
    tmp_11 = (*(tp->read32))(tp,108U);
    
#line 9997 
    val = tmp_11 & 4294967294U;
    
#line 9999 
    if (tp->pci_chip_rev_id == 1467502592U) 
#line 10000 
                                            val &= 4294966399U; else ;
    
#line 10001 
    tmp_12 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 10001 
    if (tmp_12 == 0) {
      
#line 10001 
      if (tp->pci_chip_rev_id >> 12 != 22295U) {
        
#line 10002 
        if (tp->pci_chip_rev_id >> 12 != 22370U) 
#line 10004 
                                                 val |= 128U; else ;
      }
      else ;
    }
    else ;
    
#line 10005 
    (*(tp->write32))(tp,108U,tp->dma_rwctrl | val);
  }
  else 
    
#line 10006 
    if (tp->pci_chip_rev_id >> 12 != 22404U && tp->pci_chip_rev_id >> 12 != 22369U) 
      
#line 10011 
      (*(tp->write32))(tp,108U,tp->dma_rwctrl); else ;
  
#line 10014 
  tp->grc_mode &= 3748528127U;
  
#line 10018 
  tp->grc_mode |= 131072U;
  
#line 10026 
  tp->grc_mode |= 1048576U;
  
#line 10028 
  val = 67174400U;
  
#line 10029 
  if (tp->rxptpctl != 0U) 
#line 10030 
                          (*(tp->write32))(tp,1736U,tp->rxptpctl | 67108864U); else ;
  
#line 10033 
  tmp_14 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 10033 
  if (tmp_14 != 0) 
#line 10034 
                   val |= 524288U; else ;
  
#line 10036 
  (*(tp->write32))(tp,26624U,tp->grc_mode | val);
  
#line 10039 
  val = (*(tp->read32))(tp,26628U);
  
#line 10040 
  val &= 4294967040U;
  
#line 10041 
  val |= 130U;
  
#line 10042 
  (*(tp->write32))(tp,26628U,val);
  
#line 10045 
  tmp_16 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10045 
  if (tmp_16 != 0) ;
  else 
    
#line 10047 
    if (tp->pci_chip_rev_id >> 12 != 3U) {
      
#line 10048 
      (*(tp->write32))(tp,17416U,32768U);
      
#line 10049 
      if (tp->pci_chip_rev_id >> 12 == 2U) 
#line 10050 
                                           (*(tp->write32))(tp,17420U,65536U); else 
                                                                    
#line 10052 
                                                                    (*(tp->write32))(tp,17420U,98304U);
      
#line 10053 
      (*(tp->write32))(tp,17452U,8192U);
      
#line 10054 
      (*(tp->write32))(tp,17456U,8192U);
    }
    else {
      int tmp_15;
      
#line 10055 
      tmp_15 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 10055 
      if (tmp_15 != 0) {
        int fw_len;
        
#line 10058 
        fw_len = (int)tp->fw_len;
        
#line 10059 
        fw_len = (fw_len + 127) & -128;
        
#line 10060 
        (*(tp->write32))(tp,17416U,(unsigned int)(fw_len + 65536));
        
#line 10062 
        (*(tp->write32))(tp,17420U,(unsigned int)(54784 - fw_len));
      }
      else ;
    }
  
#line 10066 
  if ((tp->dev)->mtu <= 1500U) {
    
#line 10067 
    (*(tp->write32))(tp,17424U,tp->bufmgr_config.mbuf_read_dma_low_water);
    
#line 10069 
    (*(tp->write32))(tp,17428U,tp->bufmgr_config.mbuf_mac_rx_low_water);
    
#line 10071 
    (*(tp->write32))(tp,17432U,tp->bufmgr_config.mbuf_high_water);
  }
  else {
    
#line 10074 
    (*(tp->write32))(tp,17424U,tp->bufmgr_config.mbuf_read_dma_low_water_jumbo);
    
#line 10076 
    (*(tp->write32))(tp,17428U,tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo);
    
#line 10078 
    (*(tp->write32))(tp,17432U,tp->bufmgr_config.mbuf_high_water_jumbo);
  }
  
#line 10081 
  (*(tp->write32))(tp,17460U,tp->bufmgr_config.dma_low_water);
  
#line 10083 
  (*(tp->write32))(tp,17464U,tp->bufmgr_config.dma_high_water);
  
#line 10086 
  val = 6U;
  
#line 10087 
  if (tp->pci_chip_rev_id >> 12 == 22297U) 
#line 10088 
                                           val |= 2147483648U; else ;
  
#line 10089 
  if (((tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22370U) || tp->pci_chip_rev_id == 91328512U) || tp->pci_chip_rev_id == 91357184U) 
    
#line 10093 
    val |= 16U; else ;
  
#line 10094 
  (*(tp->write32))(tp,17408U,val);
  
#line 10095 
  i = 0;
  
#line 10095 
  goto ldv_58151;
  ldv_58150: 
#line 10096 
  ;
  
#line 10096 
  tmp_17 = (*(tp->read32))(tp,17408U);
  
#line 10096 
  if ((tmp_17 & 2U) != 0U) 
#line 10097 
                           goto ldv_58149; else ;
  
#line 10098 
  __const_udelay(42950UL);
  
#line 10095 
  i += 1;
  ldv_58151: 
#line 10096 
  ;
  
#line 10095 
  if (i <= 1999) 
#line 10097 
                 goto ldv_58150; else 
#line 10100 
                                      goto ldv_58149;
  ldv_58149: 
#line 10101 
  ;
  
#line 10100 
  if (i > 1999) {
    
#line 10101 
    netdev_err((struct net_device const *)tp->dev,"%s cannot enable BUFMGR\n","tg3_reset_hw");
    
#line 10102 
    __retres = -19;
    
#line 10102 
    goto return_label;
  }
  else ;
  
#line 10105 
  if (tp->pci_chip_rev_id == 49153U) {
    u32 tmp_18;
    
#line 10106 
    tmp_18 = (*(tp->read32))(tp,3104U);
    
#line 10106 
    ;
    
#line 10106 
    (*(tp->write32))(tp,3104U,(tmp_18 & 4294967292U) | 2U);
  }
  else ;
  
#line 10108 
  tg3_setup_rxbd_thresholds(tp);
  
#line 10127 
  (*(tp->write32))(tp,9296U,(unsigned int)(tpr->rx_std_mapping >> 32));
  
#line 10129 
  (*(tp->write32))(tp,9300U,(unsigned int)tpr->rx_std_mapping);
  
#line 10131 
  tmp_19 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10131 
  if (tmp_19 == 0) 
#line 10132 
                   (*(tp->write32))(tp,9308U,24576U); else ;
  
#line 10136 
  tmp_20 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10136 
  if (tmp_20 == 0) 
#line 10137 
                   (*(tp->write32))(tp,9320U,2U); else ;
  
#line 10143 
  if (tp->pci_chip_rev_id == 91328512U) 
#line 10143 
                                        goto _LOR;
  else {
    int tmp_29;
    
#line 10143 
    tmp_29 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 10143 
    if (tmp_29 != 0) {
      int tmp_30;
      
#line 10144 
      tmp_30 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
      
#line 10144 
      if (tmp_30 == 0) {
        _LOR: {
                int tmp_25;
                int tmp_28;
                
#line 10146 
                tmp_25 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
                
#line 10146 
                if (tmp_25 != 0) {
                  int tmp_22;
                  int tmp_21;
                  int tmp_23;
                  
#line 10147 
                  (*(tp->write32))(tp,9280U,(unsigned int)(tpr->rx_jmb_mapping >> 32));
                  
#line 10149 
                  (*(tp->write32))(tp,9284U,(unsigned int)tpr->rx_jmb_mapping);
                  
#line 10151 
                  tmp_21 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
                  
#line 10151 
                  if (tmp_21 != 0) 
#line 10151 
                                   tmp_22 = 67108864; else 
#line 10151 
                                                           tmp_22 = 16777216;
                  
#line 10151 
                  val = (unsigned int)tmp_22;
                  
#line 10153 
                  (*(tp->write32))(tp,9288U,val | 1U);
                  
#line 10155 
                  tmp_23 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_JUMBO_BDFLAG,(unsigned long *)(& tp->tg3_flags));
                  
#line 10155 
                  if (tmp_23 == 0) 
#line 10158 
                                   (*(tp->write32))(tp,9292U,28672U);
                  else {
                    int tmp_24;
                    
#line 10155 
                    tmp_24 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
                    
#line 10155 
                    if (tmp_24 != 0) 
#line 10158 
                                     (*(tp->write32))(tp,9292U,28672U);
                    else 
                      
#line 10156 
                      if (tp->pci_chip_rev_id >> 12 == 22370U) 
#line 10158 
                                                               (*(tp->write32))(tp,9292U,28672U); else ;
                  }
                }
                else 
#line 10161 
                     (*(tp->write32))(tp,9288U,2U);
                
#line 10165 
                tmp_28 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
                
#line 10165 
                if (tmp_28 != 0) {
                  int tmp_27;
                  int tmp_26;
                  
#line 10166 
                  tmp_26 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
                  
#line 10166 
                  if (tmp_26 != 0) 
#line 10166 
                                   tmp_27 = 2048; else 
#line 10166 
                                                       tmp_27 = 512;
                  
#line 10166 
                  val = (unsigned int)tmp_27;
                  
#line 10167 
                  val <<= 16;
                  
#line 10168 
                  val |= 6144U;
                }
                else 
#line 10170 
                     val = 100663296U;
              }
      }
      else 
#line 10172 
           val = 33554432U;
    }
    else 
#line 10172 
         val = 33554432U;
  }
  
#line 10174 
  (*(tp->write32))(tp,9304U,val);
  
#line 10176 
  tpr->rx_std_prod_idx = tp->rx_pending;
  
#line 10177 
  (*(tp->write32_rx_mbox))(tp,620U,tpr->rx_std_prod_idx);
  
#line 10179 
  tmp_31 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 10179 
  if (tmp_31 != 0) 
#line 10179 
                   tpr->rx_jmb_prod_idx = tp->rx_jumbo_pending; else 
                                                                  
#line 10179 
                                                                  tpr->rx_jmb_prod_idx = 0U;
  
#line 10181 
  (*(tp->write32_rx_mbox))(tp,628U,tpr->rx_jmb_prod_idx);
  
#line 10183 
  tg3_rings_reset(tp);
  
#line 10186 
  __tg3_set_mac_addr(tp,(_Bool)0);
  
#line 10189 
  (*(tp->write32))(tp,1084U,(tp->dev)->mtu + 22U);
  
#line 10195 
  val = 9760U;
  
#line 10199 
  if (tp->pci_chip_rev_id >> 12 == 22304U || tp->pci_chip_rev_id >> 12 == 22370U) {
    u32 tmp_32;
    
#line 10201 
    tmp_32 = (*(tp->read32))(tp,1124U);
    
#line 10203 
    val = (tmp_32 & 4294901760U) | val;
  }
  else ;
  
#line 10205 
  (*(tp->write32))(tp,1124U,val);
  
#line 10208 
  (*(tp->write32))(tp,1280U,8U);
  
#line 10209 
  (*(tp->write32))(tp,8208U,385U);
  
#line 10214 
  rdmac_mode = 1022U;
  
#line 10220 
  if (tp->pci_chip_rev_id >> 12 == 22295U) 
#line 10221 
                                           rdmac_mode |= 16777216U; else ;
  
#line 10223 
  if ((tp->pci_chip_rev_id >> 12) + 4294944892U <= 1U || tp->pci_chip_rev_id >> 12 == 358272U) 
    
#line 10226 
    rdmac_mode |= 14336U; else ;
  
#line 10230 
  if (tp->pci_chip_rev_id >> 12 == 3U && tp->pci_chip_rev_id != 12288U) {
    int tmp_35;
    
#line 10232 
    tmp_35 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 10232 
    if (tmp_35 != 0) {
      
#line 10232 
      if (tp->pci_chip_rev_id >> 12 == 3U) 
#line 10234 
                                           rdmac_mode |= 131072U; else 
                                                                    
#line 10232 
                                                                    goto _LAND;
    }
    else {
      u32 tmp_33;
      _LAND: 
#line 10235 
      tmp_33 = (*(tp->read32))(tp,112U);
      
#line 10235 
      if ((tmp_33 & 8U) == 0U) {
        int tmp_34;
        
#line 10235 
        tmp_34 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_5788,(unsigned long *)(& tp->tg3_flags));
        
#line 10235 
        if (tmp_34 == 0) 
#line 10237 
                         rdmac_mode |= 196608U; else ;
      }
      else ;
    }
  }
  else ;
  
#line 10241 
  tmp_36 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
  
#line 10241 
  if (tmp_36 != 0) 
#line 10242 
                   rdmac_mode |= 196608U; else ;
  
#line 10244 
  if (tp->pci_chip_rev_id >> 12 == 358246U) {
    
#line 10245 
    tp->dma_limit = 0U;
    
#line 10246 
    if ((tp->dev)->mtu <= 1500U) {
      
#line 10247 
      rdmac_mode |= 8388608U;
      
#line 10248 
      tp->dma_limit = 2048U;
    }
    else ;
  }
  else ;
  
#line 10252 
  tmp_37 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
  
#line 10252 
  if (tmp_37 != 0) 
#line 10255 
                   rdmac_mode |= 134217728U;
  else {
    int tmp_38;
    
#line 10252 
    tmp_38 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
    
#line 10252 
    if (tmp_38 != 0) 
#line 10255 
                     rdmac_mode |= 134217728U;
    else {
      int tmp_39;
      
#line 10253 
      tmp_39 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
      
#line 10253 
      if (tmp_39 != 0) 
#line 10255 
                       rdmac_mode |= 134217728U; else ;
    }
  }
  
#line 10257 
  tmp_40 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10257 
  if (tmp_40 != 0) 
#line 10260 
                   rdmac_mode |= 268435456U;
  else 
    
#line 10257 
    if (tp->pci_chip_rev_id >> 12 == 22405U) 
#line 10260 
                                             rdmac_mode |= 268435456U;
    else 
      
#line 10258 
      if (tp->pci_chip_rev_id >> 12 == 358272U) 
#line 10260 
                                                rdmac_mode |= 268435456U; else ;
  
#line 10262 
  if (tp->pci_chip_rev_id >> 12 == 22304U || tp->pci_chip_rev_id >> 12 == 22370U) {
    u32 tmp_41;
    
#line 10264 
    tmp_41 = (*(tp->read32))(tp,18432U);
    
#line 10264 
    rdmac_mode = (tmp_41 & 536870912U) | rdmac_mode;
  }
  else ;
  
#line 10266 
  if (((tp->pci_chip_rev_id >> 12 == 22369U || tp->pci_chip_rev_id >> 12 == 22404U) || tp->pci_chip_rev_id >> 12 == 22405U) || tp->pci_chip_rev_id >> 12 == 358272U) 
    
#line 10266 
    goto _LOR_0;
  else {
    int tmp_42;
    
#line 10269 
    tmp_42 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 10269 
    if (tmp_42 != 0) {
      _LOR_0: {
                u32 tgtreg;
                
#line 10273 
                if (tp->pci_chip_rev_id >> 12 == 22370U) 
#line 10274 
                                                         tgtreg = 18576U; else 
                                                                    
#line 10276 
                                                                    tgtreg = 18688U;
                
#line 10278 
                val = (*(tp->read32))(tp,tgtreg);
                
#line 10279 
                if (tp->pci_chip_rev_id == 91328512U || tp->pci_chip_rev_id >> 12 == 22370U) {
                  
#line 10281 
                  val &= 1048591U;
                  
#line 10284 
                  val |= 671878144U;
                }
                else ;
                
#line 10288 
                (*(tp->write32))(tp,tgtreg,val | 4U);
              }
    }
    else ;
  }
  
#line 10291 
  if ((tp->pci_chip_rev_id >> 12 == 22297U || tp->pci_chip_rev_id >> 12 == 22304U) || tp->pci_chip_rev_id >> 12 == 22370U) {
    u32 tgtreg_0;
    
#line 10296 
    if (tp->pci_chip_rev_id >> 12 == 22370U) 
#line 10297 
                                             tgtreg_0 = 18592U; else 
                                                                  
#line 10299 
                                                                  tgtreg_0 = 18704U;
    
#line 10301 
    val = (*(tp->read32))(tp,tgtreg_0);
    
#line 10302 
    (*(tp->write32))(tp,tgtreg_0,val | 983040U);
  }
  else ;
  
#line 10308 
  tmp_44 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10308 
  if (tmp_44 != 0) {
    
#line 10309 
    val = (*(tp->read32))(tp,8216U);
    
#line 10310 
    val &= 4294705151U;
    
#line 10311 
    (*(tp->write32))(tp,8216U,val);
  }
  else 
    
#line 10312 
    if ((rdmac_mode & 131072U) != 0U) {
      int tmp_43;
      
#line 10312 
      tmp_43 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 10312 
      if (tmp_43 != 0) {
        
#line 10314 
        val = (*(tp->read32))(tp,8216U);
        
#line 10315 
        val &= 4290772991U;
        
#line 10316 
        (*(tp->write32))(tp,8216U,val);
      }
      else 
#line 10318 
           (*(tp->write32))(tp,8216U,16777215U);
    }
    else 
#line 10318 
         (*(tp->write32))(tp,8216U,16777215U);
  
#line 10320 
  (*(tp->write32))(tp,8212U,1U);
  
#line 10321 
  (*(tp->write32))(tp,3084U,16777215U);
  
#line 10322 
  (*(tp->write32))(tp,3080U,3U);
  
#line 10327 
  (*(tp->write32))(tp,15360U,0U);
  
#line 10328 
  i = 0;
  
#line 10328 
  goto ldv_58157;
  ldv_58156: 
#line 10329 
  ;
  
#line 10329 
  tmp_45 = (*(tp->read32))(tp,15360U);
  
#line 10329 
  if ((tmp_45 & 2U) == 0U) 
#line 10330 
                           goto ldv_58155; else ;
  
#line 10331 
  __const_udelay(42950UL);
  
#line 10328 
  i += 1;
  ldv_58157: 
#line 10329 
  ;
  
#line 10328 
  if (i <= 1999) 
#line 10330 
                 goto ldv_58156; else 
#line 10333 
                                      goto ldv_58155;
  ldv_58155: 
#line 10334 
  ;
  
#line 10334 
  __tg3_set_coalesce(tp,& tp->coal);
  
#line 10336 
  tmp_46 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10336 
  if (tmp_46 == 0) {
    
#line 10341 
    (*(tp->write32))(tp,15408U,(unsigned int)(tp->stats_mapping >> 32));
    
#line 10343 
    (*(tp->write32))(tp,15412U,(unsigned int)tp->stats_mapping);
    
#line 10345 
    (*(tp->write32))(tp,15424U,768U);
    
#line 10347 
    (*(tp->write32))(tp,15428U,2816U);
    
#line 10350 
    i = 768;
    
#line 10350 
    goto ldv_58159;
    ldv_58158: 
#line 10351 
    ;
    
#line 10353 
    tg3_write_mem(tp,(unsigned int)i,0U);
    
#line 10354 
    __const_udelay(171800UL);
    
#line 10352 
    i = (int)((unsigned int)i + 4U);
    ldv_58159: 
#line 10353 
    ;
    
#line 10350 
    if (i <= 2895) 
#line 10353 
                   goto ldv_58158; else 
#line 10356 
                                        goto ldv_58160;
    ldv_58160: 
#line 10357 
    ;
  }
  else ;
  
#line 10358 
  (*(tp->write32))(tp,15360U,tp->coalesce_mode | 2U);
  
#line 10360 
  (*(tp->write32))(tp,12288U,6U);
  
#line 10361 
  (*(tp->write32))(tp,8192U,2U);
  
#line 10362 
  tmp_47 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10362 
  if (tmp_47 == 0) 
#line 10363 
                   (*(tp->write32))(tp,13312U,6U); else ;
  
#line 10365 
  if ((tp->phy_flags & 32U) != 0U) {
    
#line 10366 
    tp->phy_flags &= 4294836223U;
    
#line 10368 
    _tw32_flush(tp,1128U,1U,0U);
    
#line 10369 
    __const_udelay(42950UL);
  }
  else ;
  
#line 10372 
  tp->mac_mode |= 14698496U;
  
#line 10375 
  tmp_48 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 10375 
  if (tmp_48 != 0) 
#line 10376 
                   tp->mac_mode |= 402653184U; else ;
  
#line 10377 
  tmp_49 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10377 
  if (tmp_49 == 0) {
    
#line 10377 
    if ((tp->phy_flags & 16U) == 0U) {
      
#line 10378 
      if (tp->pci_chip_rev_id >> 12 != 7U) 
#line 10380 
                                           tp->mac_mode |= 1024U; else ;
    }
    else ;
  }
  else ;
  
#line 10381 
  _tw32_flush(tp,1024U,tp->mac_mode | 36864U,0U);
  
#line 10382 
  __const_udelay(171800UL);
  
#line 10390 
  tmp_52 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_NIC,(unsigned long *)(& tp->tg3_flags));
  
#line 10390 
  if (tmp_52 == 0) {
    u32 gpio_mask;
    u32 tmp_50;
    int tmp_51;
    
#line 10393 
    gpio_mask = 129024U;
    
#line 10397 
    if (tp->pci_chip_rev_id >> 12 == 6U) 
#line 10398 
                                         gpio_mask |= 192U; else ;
    
#line 10401 
    if (tp->pci_chip_rev_id >> 12 == 10U) 
#line 10402 
                                          gpio_mask |= 16U; else ;
    
#line 10404 
    tp->grc_local_ctrl &= ~ gpio_mask;
    
#line 10405 
    tmp_50 = (*(tp->read32))(tp,26632U);
    
#line 10405 
    tp->grc_local_ctrl |= tmp_50 & gpio_mask;
    
#line 10408 
    tmp_51 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags));
    
#line 10408 
    if (tmp_51 != 0) 
#line 10409 
                     tp->grc_local_ctrl |= 36864U; else ;
  }
  else ;
  
#line 10412 
  _tw32_flush(tp,26632U,tp->grc_local_ctrl,0U);
  
#line 10413 
  __const_udelay(429500UL);
  
#line 10415 
  tmp_54 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 10415 
  if (tmp_54 != 0) {
    int tmp_53;
    
#line 10416 
    val = (*(tp->read32))(tp,24576U);
    
#line 10417 
    val |= 2U;
    
#line 10418 
    if (tp->irq_cnt > 1U) 
#line 10419 
                          val |= 128U; else ;
    
#line 10420 
    tmp_53 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_1SHOT_MSI,(unsigned long *)(& tp->tg3_flags));
    
#line 10420 
    if (tmp_53 == 0) 
#line 10421 
                     val |= 32U; else ;
    
#line 10422 
    (*(tp->write32))(tp,24576U,val);
  }
  else ;
  
#line 10425 
  tmp_55 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10425 
  if (tmp_55 == 0) {
    
#line 10426 
    _tw32_flush(tp,25600U,2U,0U);
    
#line 10427 
    __const_udelay(171800UL);
  }
  else ;
  
#line 10430 
  val = 1022U;
  
#line 10436 
  if (tp->pci_chip_rev_id >> 12 == 3U && tp->pci_chip_rev_id != 12288U) {
    int tmp_58;
    
#line 10438 
    tmp_58 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 10438 
    if (tmp_58 != 0) {
      
#line 10438 
      if (tp->pci_chip_rev_id + 4294955007U <= 1U) ; else 
#line 10438 
                                                          goto _LAND_0;
    }
    else {
      u32 tmp_56;
      _LAND_0: 
#line 10442 
      tmp_56 = (*(tp->read32))(tp,112U);
      
#line 10442 
      if ((tmp_56 & 8U) == 0U) {
        int tmp_57;
        
#line 10442 
        tmp_57 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_5788,(unsigned long *)(& tp->tg3_flags));
        
#line 10442 
        if (tmp_57 == 0) 
#line 10444 
                         val |= 1024U; else ;
      }
      else ;
    }
  }
  else ;
  
#line 10449 
  tmp_59 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10449 
  if (tmp_59 != 0) 
#line 10450 
                   val |= 536870912U; else ;
  
#line 10452 
  if (tp->pci_chip_rev_id >> 12 == 22405U) 
#line 10453 
                                           val |= 3221225472U; else ;
  
#line 10455 
  _tw32_flush(tp,19456U,val,0U);
  
#line 10456 
  __const_udelay(171800UL);
  
#line 10458 
  tmp_60 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
  
#line 10458 
  if (tmp_60 != 0) {
    u16 pcix_cmd;
    
#line 10461 
    pci_read_config_word((struct pci_dev const *)tp->pdev,tp->pcix_cap + 2,& pcix_cmd);
    
#line 10463 
    if (tp->pci_chip_rev_id >> 12 == 1U) {
      
#line 10464 
      pcix_cmd = (unsigned short)((unsigned int)pcix_cmd & 65523U);
      
#line 10465 
      pcix_cmd = (unsigned short)((unsigned int)pcix_cmd | 8U);
    }
    else 
      
#line 10466 
      if (tp->pci_chip_rev_id >> 12 == 2U) {
        
#line 10467 
        pcix_cmd = (unsigned short)((unsigned int)pcix_cmd & 65411U);
        
#line 10468 
        pcix_cmd = (unsigned short)((unsigned int)pcix_cmd | 8U);
      }
      else ;
    
#line 10470 
    pci_write_config_word((struct pci_dev const *)tp->pdev,tp->pcix_cap + 2,(unsigned short)((int)pcix_cmd));
  }
  else ;
  
#line 10474 
  _tw32_flush(tp,18432U,rdmac_mode,0U);
  
#line 10475 
  __const_udelay(171800UL);
  
#line 10477 
  if (tp->pci_chip_rev_id >> 12 == 22297U || tp->pci_chip_rev_id >> 12 == 22304U) {
    u32 tmp_61;
    int tmp_63;
    int tmp_62;
    
#line 10479 
    i = 0;
    
#line 10479 
    goto ldv_58165;
    ldv_58164: 
#line 10480 
    ;
    
#line 10480 
    tmp_61 = (*(tp->read32))(tp,(unsigned int)((i << 2) + 19424));
    
#line 10480 
    tmp_62 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 10480 
    if (tmp_62 != 0) 
#line 10480 
                     tmp_63 = 9000; else 
#line 10480 
                                         tmp_63 = 1500;
    
#line 10480 
    if (tmp_61 > (unsigned int)tmp_63) 
#line 10481 
                                       goto ldv_58163; else ;
    
#line 10479 
    i += 1;
    ldv_58165: 
#line 10480 
    ;
    
#line 10479 
    if (i <= 3) 
#line 10481 
                goto ldv_58164; else 
#line 10484 
                                     goto ldv_58163;
    ldv_58163: 
#line 10485 
    ;
    
#line 10483 
    if (i <= 3) {
      u32 tmp_64;
      
#line 10484 
      val = (*(tp->read32))(tp,18704U);
      
#line 10485 
      tmp_64 = tg3_lso_rd_dma_workaround_bit(tp);
      
#line 10485 
      val = tmp_64 | val;
      
#line 10486 
      (*(tp->write32))(tp,18704U,val);
      
#line 10487 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5719_5720_RDMA_BUG,(unsigned long *)(& tp->tg3_flags));
    }
    else ;
  }
  else ;
  
#line 10491 
  (*(tp->write32))(tp,10240U,6U);
  
#line 10492 
  tmp_65 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10492 
  if (tmp_65 == 0) 
#line 10493 
                   (*(tp->write32))(tp,14336U,2U); else ;
  
#line 10495 
  if (tp->pci_chip_rev_id >> 12 == 22369U) 
#line 10496 
                                           (*(tp->write32))(tp,4096U,18U); else 
                                                                    
#line 10499 
                                                                    (*(tp->write32))(tp,4096U,2U);
  
#line 10501 
  (*(tp->write32))(tp,7168U,6U);
  
#line 10502 
  (*(tp->write32))(tp,11264U,6U);
  
#line 10503 
  val = 18U;
  
#line 10504 
  tmp_66 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 10504 
  if (tmp_66 != 0) 
#line 10505 
                   val |= 65536U; else ;
  
#line 10506 
  (*(tp->write32))(tp,9216U,val);
  
#line 10507 
  (*(tp->write32))(tp,3072U,2U);
  
#line 10508 
  tmp_67 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
  
#line 10508 
  if (tmp_67 != 0) 
#line 10511 
                   (*(tp->write32))(tp,3072U,10U);
  else {
    int tmp_68;
    
#line 10508 
    tmp_68 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
    
#line 10508 
    if (tmp_68 != 0) 
#line 10511 
                     (*(tp->write32))(tp,3072U,10U);
    else {
      int tmp_69;
      
#line 10509 
      tmp_69 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
      
#line 10509 
      if (tmp_69 != 0) 
#line 10511 
                       (*(tp->write32))(tp,3072U,10U); else ;
    }
  }
  
#line 10512 
  val = 6U;
  
#line 10513 
  tmp_70 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
  
#line 10513 
  if (tmp_70 != 0) 
#line 10514 
                   val |= 32U; else ;
  
#line 10515 
  (*(tp->write32))(tp,6144U,val);
  
#line 10516 
  (*(tp->write32))(tp,5120U,6U);
  
#line 10518 
  if (tp->pci_chip_rev_id == 0U) {
    
#line 10519 
    err = tg3_load_5701_a0_firmware_fix(tp);
    
#line 10520 
    if (err != 0) {
      
#line 10521 
      __retres = err;
      
#line 10521 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 10524 
  if (tp->pci_chip_rev_id >> 12 == 358246U) 
#line 10528 
                                            tg3_load_57766_firmware(tp); else ;
  
#line 10531 
  tmp_71 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 10531 
  if (tmp_71 != 0) {
    
#line 10532 
    err = tg3_load_tso_firmware(tp);
    
#line 10533 
    if (err != 0) {
      
#line 10534 
      __retres = err;
      
#line 10534 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 10537 
  tp->tx_mode = 2U;
  
#line 10539 
  tmp_72 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10539 
  if (tmp_72 != 0) 
#line 10541 
                   tp->tx_mode |= 256U;
  else 
    
#line 10539 
    if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 10541 
                                          tp->tx_mode |= 256U; else ;
  
#line 10543 
  if (tp->pci_chip_rev_id >> 12 == 22304U || tp->pci_chip_rev_id >> 12 == 22370U) {
    u32 tmp_73;
    
#line 10545 
    val = 12582912U;
    
#line 10546 
    tp->tx_mode &= ~ val;
    
#line 10547 
    tmp_73 = (*(tp->read32))(tp,1116U);
    
#line 10547 
    tp->tx_mode |= tmp_73 & val;
  }
  else ;
  
#line 10550 
  _tw32_flush(tp,1116U,tp->tx_mode,0U);
  
#line 10551 
  __const_udelay(429500UL);
  
#line 10553 
  tmp_74 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 10553 
  if (tmp_74 != 0) {
    u32 rss_key[10U];
    
#line 10556 
    tg3_rss_write_indir_tbl(tp);
    
#line 10558 
    netdev_rss_key_fill((void *)(& rss_key),40UL);
    
#line 10560 
    i = 0;
    
#line 10560 
    goto ldv_58168;
    ldv_58167: 
#line 10561 
    ;
    
#line 10561 
    (*(tp->write32))(tp,(unsigned int)((i + 412) * 4),rss_key[i]);
    
#line 10560 
    i += 1;
    ldv_58168: 
#line 10561 
    ;
    
#line 10560 
    if (i <= 9) 
#line 10562 
                goto ldv_58167; else 
#line 10565 
                                     goto ldv_58169;
    ldv_58169: 
#line 10566 
    ;
  }
  else ;
  
#line 10564 
  tp->rx_mode = 2U;
  
#line 10565 
  tmp_75 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10565 
  if (tmp_75 != 0) 
#line 10566 
                   tp->rx_mode |= 16777216U; else ;
  
#line 10568 
  if (tp->pci_chip_rev_id >> 12 == 22370U) 
#line 10569 
                                           tp->rx_mode |= 33554432U; else ;
  
#line 10571 
  tmp_76 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 10571 
  if (tmp_76 != 0) 
#line 10572 
                   tp->rx_mode |= 16711680U; else ;
  
#line 10579 
  _tw32_flush(tp,1128U,tp->rx_mode,0U);
  
#line 10580 
  __const_udelay(42950UL);
  
#line 10582 
  (*(tp->write32))(tp,1036U,tp->led_ctrl);
  
#line 10584 
  (*(tp->write32))(tp,1104U,1U);
  
#line 10585 
  if ((tp->phy_flags & 16U) != 0U) {
    
#line 10586 
    _tw32_flush(tp,1128U,1U,0U);
    
#line 10587 
    __const_udelay(42950UL);
  }
  else ;
  
#line 10589 
  _tw32_flush(tp,1128U,tp->rx_mode,0U);
  
#line 10590 
  __const_udelay(42950UL);
  
#line 10592 
  if ((tp->phy_flags & 16U) != 0U) {
    
#line 10593 
    if (tp->pci_chip_rev_id >> 12 == 2U && (tp->phy_flags & 65536U) == 0U) {
      
#line 10597 
      val = (*(tp->read32))(tp,1424U);
      
#line 10598 
      val &= 4294963200U;
      
#line 10599 
      val |= 2176U;
      
#line 10600 
      (*(tp->write32))(tp,1424U,val);
    }
    else ;
    
#line 10602 
    if (tp->pci_chip_rev_id == 4097U) 
#line 10603 
                                      (*(tp->write32))(tp,1424U,6381568U); else ;
  }
  else ;
  
#line 10609 
  tmp_77 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
  
#line 10609 
  if (tmp_77 != 0) 
#line 10610 
                   val = 1U; else 
#line 10612 
                                  val = 2U;
  
#line 10613 
  _tw32_flush(tp,1284U,val,0U);
  
#line 10615 
  if (tp->pci_chip_rev_id >> 12 == 2U && (tp->phy_flags & 16U) != 0U) 
    
#line 10618 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_HW_AUTONEG,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 10621 
  if ((tp->phy_flags & 32U) != 0U && tp->pci_chip_rev_id >> 12 == 9U) {
    u32 tmp_78;
    
#line 10625 
    tmp_78 = (*(tp->read32))(tp,1456U);
    
#line 10626 
    (*(tp->write32))(tp,1456U,tmp_78 | 1024U);
    
#line 10627 
    tp->grc_local_ctrl &= 4294967263U;
    
#line 10628 
    tp->grc_local_ctrl |= 16U;
    
#line 10629 
    (*(tp->write32))(tp,26632U,tp->grc_local_ctrl);
  }
  else ;
  
#line 10632 
  tmp_81 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 10632 
  if (tmp_81 == 0) {
    
#line 10633 
    if ((tp->phy_flags & 1U) != 0U) 
#line 10634 
                                    tp->phy_flags &= 4294967294U; else ;
    
#line 10636 
    err = tg3_setup_phy(tp,(_Bool)0);
    
#line 10637 
    if (err != 0) {
      
#line 10638 
      __retres = err;
      
#line 10638 
      goto return_label;
    }
    else ;
    
#line 10640 
    if ((tp->phy_flags & 16U) == 0U && (tp->phy_flags & 64U) == 0U) {
      u32 tmp_79;
      int tmp_80;
      
#line 10645 
      tmp_80 = tg3_readphy(tp,30,& tmp_79);
      
#line 10645 
      if (tmp_80 == 0) {
        
#line 10646 
        tg3_writephy(tp,30,tmp_79 | 32768U);
        
#line 10648 
        tg3_readphy(tp,20,& tmp_79);
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 10653 
  __tg3_set_rx_mode(tp->dev);
  
#line 10656 
  (*(tp->write32))(tp,1152U,1107296256U);
  
#line 10657 
  (*(tp->write32))(tp,1156U,2147483647U);
  
#line 10658 
  (*(tp->write32))(tp,1160U,100663300U);
  
#line 10659 
  (*(tp->write32))(tp,1164U,2147483647U);
  
#line 10661 
  tmp_82 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10661 
  if (tmp_82 != 0) {
    int tmp_83;
    
#line 10661 
    tmp_83 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 10661 
    if (tmp_83 == 0) 
#line 10662 
                     limit = 8; else 
#line 10664 
                                     limit = 16;
  }
  else 
#line 10664 
       limit = 16;
  
#line 10665 
  tmp_84 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 10665 
  if (tmp_84 != 0) 
#line 10666 
                   limit += -4; else ;
  
#line 10667 
  switch (limit) {
    case 16: 
#line 10668 
    ;
    
#line 10669 
    (*(tp->write32))(tp,1272U,0U);
    
#line 10669 
    (*(tp->write32))(tp,1276U,0U);
    case 15: 
#line 10670 
    ;
    
#line 10671 
    (*(tp->write32))(tp,1264U,0U);
    
#line 10671 
    (*(tp->write32))(tp,1268U,0U);
    case 14: 
#line 10672 
    ;
    
#line 10673 
    (*(tp->write32))(tp,1256U,0U);
    
#line 10673 
    (*(tp->write32))(tp,1260U,0U);
    case 13: 
#line 10674 
    ;
    
#line 10675 
    (*(tp->write32))(tp,1248U,0U);
    
#line 10675 
    (*(tp->write32))(tp,1252U,0U);
    case 12: 
#line 10676 
    ;
    
#line 10677 
    (*(tp->write32))(tp,1240U,0U);
    
#line 10677 
    (*(tp->write32))(tp,1244U,0U);
    case 11: 
#line 10678 
    ;
    
#line 10679 
    (*(tp->write32))(tp,1232U,0U);
    
#line 10679 
    (*(tp->write32))(tp,1236U,0U);
    case 10: 
#line 10680 
    ;
    
#line 10681 
    (*(tp->write32))(tp,1224U,0U);
    
#line 10681 
    (*(tp->write32))(tp,1228U,0U);
    case 9: 
#line 10682 
    ;
    
#line 10683 
    (*(tp->write32))(tp,1216U,0U);
    
#line 10683 
    (*(tp->write32))(tp,1220U,0U);
    case 8: 
#line 10684 
    ;
    
#line 10685 
    (*(tp->write32))(tp,1208U,0U);
    
#line 10685 
    (*(tp->write32))(tp,1212U,0U);
    case 7: 
#line 10686 
    ;
    
#line 10687 
    (*(tp->write32))(tp,1200U,0U);
    
#line 10687 
    (*(tp->write32))(tp,1204U,0U);
    case 6: 
#line 10688 
    ;
    
#line 10689 
    (*(tp->write32))(tp,1192U,0U);
    
#line 10689 
    (*(tp->write32))(tp,1196U,0U);
    case 5: 
#line 10690 
    ;
    
#line 10691 
    (*(tp->write32))(tp,1184U,0U);
    
#line 10691 
    (*(tp->write32))(tp,1188U,0U);
    case 4: 
#line 10692 
    ;
    case 3: 
#line 10694 
    ;
    case 2: 
#line 10696 
    ;
    case 1: 
#line 10697 
    ;
    default: 
#line 10699 
    ;
    
#line 10700 
    goto ldv_58189;
  }
  ldv_58189: 
#line 10703 
  ;
  
#line 10703 
  tmp_85 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 10703 
  if (tmp_85 != 0) 
#line 10705 
                   tg3_ape_write32(tp,16916U,0U); else ;
  
#line 10708 
  tg3_write_sig_post_reset(tp,1);
  
#line 10710 
  __retres = 0;
  return_label: 
#line 10710 
                return __retres;
}


#line 10716  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_init_hw(struct tg3 *tp, bool reset_phy)
{
  int tmp;
  
#line 10722 
  tg3_enable_register_access(tp);
  
#line 10723 
  tg3_poll_fw(tp);
  
#line 10725 
  tg3_switch_clocks(tp);
  
#line 10727 
  (*(tp->write32))(tp,124U,0U);
  
#line 10729 
  tmp = tg3_reset_hw(tp,(_Bool)((bool)((int)reset_phy) != 0));
  
#line 10729 
  return tmp;
}


#line 10732  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_sd_scan_scratchpad(struct tg3 *tp, struct tg3_ocir *ocir)
{
  int i;
  
#line 10736 
  i = 0;
  
#line 10736 
  goto ldv_58202;
  ldv_58201: 
#line 10737 
  ;
  {
    
#line 10737 
    u32 off = (unsigned int)((unsigned long)i) * 64U;
    
#line 10737 
    u32 len = 64U;
    
#line 10739 
    tg3_ape_scratchpad_read(tp,(u32 *)ocir,off,len);
    
#line 10740 
    off += len;
    
#line 10742 
    if (ocir->signature != 1381188431U || ((int)ocir->version_flags & 1) == 0) 
      
#line 10744 
      memset((void *)ocir,0,64UL); else ;
  }
  
#line 10736 
  i += 1;
  
#line 10736 
  ocir += 1;
  ldv_58202: 
#line 10737 
  ;
  
#line 10736 
  if (i <= 2) 
#line 10738 
              goto ldv_58201; else 
#line 10741 
                                   goto ldv_58203;
  ldv_58203: 
#line 10742 
  ;
  
#line 10743 
  return;
}


#line 10749  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static ssize_t tg3_show_temp(struct device *dev, struct device_attribute *devattr, char *buf)
{
  ssize_t __retres;
  struct sensor_device_attribute *tmp;
  u32 temperature;
  int tmp_1;
  {
    
#line 10752 
    struct device_attribute const *__mptr = (struct device_attribute const *)devattr;
    
#line 10752 
    tmp = (struct sensor_device_attribute *)__mptr;
  }
  
#line 10752 
  struct sensor_device_attribute *attr = tmp;
  
#line 10753 
  struct tg3 *tp = dev_get_drvdata((struct device const *)dev);
  
#line 10756 
  ldv_spin_lock_bh_105(& tp->lock);
  
#line 10757 
  tg3_ape_scratchpad_read(tp,& temperature,(unsigned int)attr->index,4U);
  
#line 10759 
  ldv_spin_unlock_bh_106(& tp->lock);
  
#line 10760 
  tmp_1 = sprintf(buf,"%u\n",temperature * 1000U);
  
#line 10760 
  __retres = (long)tmp_1;
  
#line 10760 
  return __retres;
}


#line 10764  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct sensor_device_attribute sensor_dev_attr_temp1_input = {.dev_attr = {.attr = {.name = "temp1_input", .mode = (unsigned short)292U, .ignore_lockdep = (_Bool)0, .key = (struct lock_class_key *)0, .skey = {.subkeys = {{.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}}}}, .show = & tg3_show_temp, .store = (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0}, .index = 212};

#line 10766  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct sensor_device_attribute sensor_dev_attr_temp1_crit = {.dev_attr = {.attr = {.name = "temp1_crit", .mode = (unsigned short)292U, .ignore_lockdep = (_Bool)0, .key = (struct lock_class_key *)0, .skey = {.subkeys = {{.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}}}}, .show = & tg3_show_temp, .store = (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0}, .index = 200};

#line 10768  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct sensor_device_attribute sensor_dev_attr_temp1_max = {.dev_attr = {.attr = {.name = "temp1_max", .mode = (unsigned short)292U, .ignore_lockdep = (_Bool)0, .key = (struct lock_class_key *)0, .skey = {.subkeys = {{.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}, {.__one_byte = (char)0}}}}, .show = & tg3_show_temp, .store = (ssize_t (*)(struct device *, struct device_attribute *, char const *, size_t ))0}, .index = 204};

#line 10771  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct attribute *tg3_attrs[4U] = {& sensor_dev_attr_temp1_input.dev_attr.attr, & sensor_dev_attr_temp1_crit.dev_attr.attr, & sensor_dev_attr_temp1_max.dev_attr.attr, (struct attribute *)0};

#line 10777  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct attribute_group const tg3_group = {.name = (char const *)0, .is_visible = (umode_t (*)(struct kobject *, struct attribute *, int ))0, .attrs = (struct attribute **)(& tg3_attrs), .bin_attrs = (struct bin_attribute **)0};

#line 10777  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct attribute_group const *tg3_groups[2U] = {& tg3_group, (struct attribute_group const *)0};

#line 10779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_hwmon_close(struct tg3 *tp)
{
  
#line 10781 
  if (tp->hwmon_dev != (struct device *)0) {
    
#line 10782 
    hwmon_device_unregister(tp->hwmon_dev);
    
#line 10783 
    tp->hwmon_dev = (struct device *)0;
  }
  else ;
  
#line 10785 
  return;
}


#line 10787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_hwmon_open(struct tg3 *tp)
{
  int i;
  struct tg3_ocir ocirs[3U];
  bool tmp;
  
#line 10790 
  u32 size = 0U;
  
#line 10791 
  struct pci_dev *pdev = tp->pdev;
  
#line 10794 
  tg3_sd_scan_scratchpad(tp,(struct tg3_ocir *)(& ocirs));
  
#line 10796 
  i = 0;
  
#line 10796 
  goto ldv_58286;
  ldv_58285: 
#line 10797 
  ;
  
#line 10797 
  if ((unsigned int)ocirs[i].src_data_length == 0U) 
#line 10798 
                                                    goto ldv_58284; else ;
  
#line 10800 
  size = (unsigned int)ocirs[i].src_hdr_length + size;
  
#line 10801 
  size = (unsigned int)ocirs[i].src_data_length + size;
  ldv_58284: 
#line 10802 
  ;
  
#line 10796 
  i += 1;
  ldv_58286: 
#line 10797 
  ;
  
#line 10796 
  if (i <= 2) 
#line 10798 
              goto ldv_58285; else 
#line 10801 
                                   goto ldv_58287;
  ldv_58287: 
#line 10802 
  ;
  
#line 10804 
  if (size == 0U) 
#line 10805 
                  goto return_label; else ;
  
#line 10807 
  tp->hwmon_dev = hwmon_device_register_with_groups(& pdev->dev,"tg3",(void *)tp,(struct attribute_group const **)(& tg3_groups));
  
#line 10809 
  tmp = IS_ERR((void const *)tp->hwmon_dev);
  
#line 10809 
  if ((int)tmp != 0) {
    
#line 10810 
    tp->hwmon_dev = (struct device *)0;
    
#line 10811 
    dev_err((struct device const *)(& pdev->dev),"Cannot register hwmon device, aborting\n");
  }
  else ;
  return_label: 
#line 10813 
                return;
}


#line 10823  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_periodic_fetch_stats(struct tg3 *tp)
{
  int tmp_13;
  
#line 10825 
  struct tg3_hw_stats *sp = tp->hw_stats;
  
#line 10827 
  if (! tp->link_up) 
#line 10828 
                     goto return_label; else ;
  {
    u32 tmp;
    
#line 10830 
    tmp = (*(tp->read32))(tp,2048U);
    
#line 10830 
    u32 __val = tmp;
    
#line 10830 
    sp->tx_octets.low += __val;
    
#line 10830 
    if (sp->tx_octets.low < __val) 
#line 10830 
                                   sp->tx_octets.high += 1U; else ;
  }
  {
    u32 tmp_0;
    
#line 10831 
    tmp_0 = (*(tp->read32))(tp,2056U);
    
#line 10831 
    u32 __val_0 = tmp_0;
    
#line 10831 
    sp->tx_collisions.low += __val_0;
    
#line 10831 
    if (sp->tx_collisions.low < __val_0) 
#line 10831 
                                         sp->tx_collisions.high += 1U; else ;
  }
  {
    u32 tmp_1;
    
#line 10832 
    tmp_1 = (*(tp->read32))(tp,2060U);
    
#line 10832 
    u32 __val_1 = tmp_1;
    
#line 10832 
    sp->tx_xon_sent.low += __val_1;
    
#line 10832 
    if (sp->tx_xon_sent.low < __val_1) 
#line 10832 
                                       sp->tx_xon_sent.high += 1U; else ;
  }
  {
    u32 tmp_2;
    
#line 10833 
    tmp_2 = (*(tp->read32))(tp,2064U);
    
#line 10833 
    u32 __val_2 = tmp_2;
    
#line 10833 
    sp->tx_xoff_sent.low += __val_2;
    
#line 10833 
    if (sp->tx_xoff_sent.low < __val_2) 
#line 10833 
                                        sp->tx_xoff_sent.high += 1U; else ;
  }
  {
    u32 tmp_3;
    
#line 10834 
    tmp_3 = (*(tp->read32))(tp,2072U);
    
#line 10834 
    u32 __val_3 = tmp_3;
    
#line 10834 
    sp->tx_mac_errors.low += __val_3;
    
#line 10834 
    if (sp->tx_mac_errors.low < __val_3) 
#line 10834 
                                         sp->tx_mac_errors.high += 1U; else ;
  }
  {
    u32 tmp_4;
    
#line 10835 
    tmp_4 = (*(tp->read32))(tp,2076U);
    
#line 10835 
    u32 __val_4 = tmp_4;
    
#line 10835 
    sp->tx_single_collisions.low += __val_4;
    
#line 10835 
    if (sp->tx_single_collisions.low < __val_4) 
#line 10835 
                                                sp->tx_single_collisions.high += 1U; else ;
  }
  {
    u32 tmp_5;
    
#line 10836 
    tmp_5 = (*(tp->read32))(tp,2080U);
    
#line 10836 
    u32 __val_5 = tmp_5;
    
#line 10836 
    sp->tx_mult_collisions.low += __val_5;
    
#line 10836 
    if (sp->tx_mult_collisions.low < __val_5) 
#line 10836 
                                              sp->tx_mult_collisions.high += 1U; else ;
  }
  {
    u32 tmp_6;
    
#line 10837 
    tmp_6 = (*(tp->read32))(tp,2084U);
    
#line 10837 
    u32 __val_6 = tmp_6;
    
#line 10837 
    sp->tx_deferred.low += __val_6;
    
#line 10837 
    if (sp->tx_deferred.low < __val_6) 
#line 10837 
                                       sp->tx_deferred.high += 1U; else ;
  }
  {
    u32 tmp_7;
    
#line 10838 
    tmp_7 = (*(tp->read32))(tp,2092U);
    
#line 10838 
    u32 __val_7 = tmp_7;
    
#line 10838 
    sp->tx_excessive_collisions.low += __val_7;
    
#line 10838 
    if (sp->tx_excessive_collisions.low < __val_7) 
#line 10838 
                                                   sp->tx_excessive_collisions.high += 1U; else ;
  }
  {
    u32 tmp_8;
    
#line 10839 
    tmp_8 = (*(tp->read32))(tp,2096U);
    
#line 10839 
    u32 __val_8 = tmp_8;
    
#line 10839 
    sp->tx_late_collisions.low += __val_8;
    
#line 10839 
    if (sp->tx_late_collisions.low < __val_8) 
#line 10839 
                                              sp->tx_late_collisions.high += 1U; else ;
  }
  {
    u32 tmp_9;
    
#line 10840 
    tmp_9 = (*(tp->read32))(tp,2156U);
    
#line 10840 
    u32 __val_9 = tmp_9;
    
#line 10840 
    sp->tx_ucast_packets.low += __val_9;
    
#line 10840 
    if (sp->tx_ucast_packets.low < __val_9) 
#line 10840 
                                            sp->tx_ucast_packets.high += 1U; else ;
  }
  {
    u32 tmp_10;
    
#line 10841 
    tmp_10 = (*(tp->read32))(tp,2160U);
    
#line 10841 
    u32 __val_10 = tmp_10;
    
#line 10841 
    sp->tx_mcast_packets.low += __val_10;
    
#line 10841 
    if (sp->tx_mcast_packets.low < __val_10) 
#line 10841 
                                             sp->tx_mcast_packets.high += 1U; else ;
  }
  {
    u32 tmp_11;
    
#line 10842 
    tmp_11 = (*(tp->read32))(tp,2164U);
    
#line 10842 
    u32 __val_11 = tmp_11;
    
#line 10842 
    sp->tx_bcast_packets.low += __val_11;
    
#line 10842 
    if (sp->tx_bcast_packets.low < __val_11) 
#line 10842 
                                             sp->tx_bcast_packets.high += 1U; else ;
  }
  
#line 10843 
  tmp_13 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5719_5720_RDMA_BUG,(unsigned long *)(& tp->tg3_flags));
  
#line 10843 
  if ((long)(tmp_13 != 0) != 0L) {
    
#line 10843 
    if ((long)((sp->tx_ucast_packets.low + sp->tx_mcast_packets.low) + sp->tx_bcast_packets.low > 4U) != 0L) {
      u32 val;
      u32 tmp_12;
      
#line 10848 
      val = (*(tp->read32))(tp,18704U);
      
#line 10849 
      tmp_12 = tg3_lso_rd_dma_workaround_bit(tp);
      
#line 10849 
      val = ~ tmp_12 & val;
      
#line 10850 
      (*(tp->write32))(tp,18704U,val);
      
#line 10851 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5719_5720_RDMA_BUG,(unsigned long *)(& tp->tg3_flags));
    }
    else ;
  }
  else ;
  {
    u32 tmp_14;
    
#line 10854 
    tmp_14 = (*(tp->read32))(tp,2176U);
    
#line 10854 
    u32 __val_12 = tmp_14;
    
#line 10854 
    sp->rx_octets.low += __val_12;
    
#line 10854 
    if (sp->rx_octets.low < __val_12) 
#line 10854 
                                      sp->rx_octets.high += 1U; else ;
  }
  {
    u32 tmp_15;
    
#line 10855 
    tmp_15 = (*(tp->read32))(tp,2184U);
    
#line 10855 
    u32 __val_13 = tmp_15;
    
#line 10855 
    sp->rx_fragments.low += __val_13;
    
#line 10855 
    if (sp->rx_fragments.low < __val_13) 
#line 10855 
                                         sp->rx_fragments.high += 1U; else ;
  }
  {
    u32 tmp_16;
    
#line 10856 
    tmp_16 = (*(tp->read32))(tp,2188U);
    
#line 10856 
    u32 __val_14 = tmp_16;
    
#line 10856 
    sp->rx_ucast_packets.low += __val_14;
    
#line 10856 
    if (sp->rx_ucast_packets.low < __val_14) 
#line 10856 
                                             sp->rx_ucast_packets.high += 1U; else ;
  }
  {
    u32 tmp_17;
    
#line 10857 
    tmp_17 = (*(tp->read32))(tp,2192U);
    
#line 10857 
    u32 __val_15 = tmp_17;
    
#line 10857 
    sp->rx_mcast_packets.low += __val_15;
    
#line 10857 
    if (sp->rx_mcast_packets.low < __val_15) 
#line 10857 
                                             sp->rx_mcast_packets.high += 1U; else ;
  }
  {
    u32 tmp_18;
    
#line 10858 
    tmp_18 = (*(tp->read32))(tp,2196U);
    
#line 10858 
    u32 __val_16 = tmp_18;
    
#line 10858 
    sp->rx_bcast_packets.low += __val_16;
    
#line 10858 
    if (sp->rx_bcast_packets.low < __val_16) 
#line 10858 
                                             sp->rx_bcast_packets.high += 1U; else ;
  }
  {
    u32 tmp_19;
    
#line 10859 
    tmp_19 = (*(tp->read32))(tp,2200U);
    
#line 10859 
    u32 __val_17 = tmp_19;
    
#line 10859 
    sp->rx_fcs_errors.low += __val_17;
    
#line 10859 
    if (sp->rx_fcs_errors.low < __val_17) 
#line 10859 
                                          sp->rx_fcs_errors.high += 1U; else ;
  }
  {
    u32 tmp_20;
    
#line 10860 
    tmp_20 = (*(tp->read32))(tp,2204U);
    
#line 10860 
    u32 __val_18 = tmp_20;
    
#line 10860 
    sp->rx_align_errors.low += __val_18;
    
#line 10860 
    if (sp->rx_align_errors.low < __val_18) 
#line 10860 
                                            sp->rx_align_errors.high += 1U; else ;
  }
  {
    u32 tmp_21;
    
#line 10861 
    tmp_21 = (*(tp->read32))(tp,2208U);
    
#line 10861 
    u32 __val_19 = tmp_21;
    
#line 10861 
    sp->rx_xon_pause_rcvd.low += __val_19;
    
#line 10861 
    if (sp->rx_xon_pause_rcvd.low < __val_19) 
#line 10861 
                                              sp->rx_xon_pause_rcvd.high += 1U; else ;
  }
  {
    u32 tmp_22;
    
#line 10862 
    tmp_22 = (*(tp->read32))(tp,2212U);
    
#line 10862 
    u32 __val_20 = tmp_22;
    
#line 10862 
    sp->rx_xoff_pause_rcvd.low += __val_20;
    
#line 10862 
    if (sp->rx_xoff_pause_rcvd.low < __val_20) 
#line 10862 
                                               sp->rx_xoff_pause_rcvd.high += 1U; else ;
  }
  {
    u32 tmp_23;
    
#line 10863 
    tmp_23 = (*(tp->read32))(tp,2216U);
    
#line 10863 
    u32 __val_21 = tmp_23;
    
#line 10863 
    sp->rx_mac_ctrl_rcvd.low += __val_21;
    
#line 10863 
    if (sp->rx_mac_ctrl_rcvd.low < __val_21) 
#line 10863 
                                             sp->rx_mac_ctrl_rcvd.high += 1U; else ;
  }
  {
    u32 tmp_24;
    
#line 10864 
    tmp_24 = (*(tp->read32))(tp,2220U);
    
#line 10864 
    u32 __val_22 = tmp_24;
    
#line 10864 
    sp->rx_xoff_entered.low += __val_22;
    
#line 10864 
    if (sp->rx_xoff_entered.low < __val_22) 
#line 10864 
                                            sp->rx_xoff_entered.high += 1U; else ;
  }
  {
    u32 tmp_25;
    
#line 10865 
    tmp_25 = (*(tp->read32))(tp,2224U);
    
#line 10865 
    u32 __val_23 = tmp_25;
    
#line 10865 
    sp->rx_frame_too_long_errors.low += __val_23;
    
#line 10865 
    if (sp->rx_frame_too_long_errors.low < __val_23) 
#line 10865 
                                                     sp->rx_frame_too_long_errors.high += 1U; else ;
  }
  {
    u32 tmp_26;
    
#line 10866 
    tmp_26 = (*(tp->read32))(tp,2228U);
    
#line 10866 
    u32 __val_24 = tmp_26;
    
#line 10866 
    sp->rx_jabbers.low += __val_24;
    
#line 10866 
    if (sp->rx_jabbers.low < __val_24) 
#line 10866 
                                       sp->rx_jabbers.high += 1U; else ;
  }
  {
    u32 tmp_27;
    
#line 10867 
    tmp_27 = (*(tp->read32))(tp,2232U);
    
#line 10867 
    u32 __val_25 = tmp_27;
    
#line 10867 
    sp->rx_undersize_packets.low += __val_25;
    
#line 10867 
    if (sp->rx_undersize_packets.low < __val_25) 
#line 10867 
                                                 sp->rx_undersize_packets.high += 1U; else ;
  }
  {
    u32 tmp_28;
    
#line 10869 
    tmp_28 = (*(tp->read32))(tp,8780U);
    
#line 10869 
    u32 __val_26 = tmp_28;
    
#line 10869 
    sp->rxbds_empty.low += __val_26;
    
#line 10869 
    if (sp->rxbds_empty.low < __val_26) 
#line 10869 
                                        sp->rxbds_empty.high += 1U; else ;
  }
  
#line 10870 
  if (((tp->pci_chip_rev_id >> 12 != 22295U && tp->pci_chip_rev_id >> 12 != 22370U) && tp->pci_chip_rev_id != 91328512U) && tp->pci_chip_rev_id != 91357184U) {
    u32 tmp_29;
    
#line 10874 
    tmp_29 = (*(tp->read32))(tp,8784U);
    
#line 10874 
    u32 __val_27 = tmp_29;
    
#line 10874 
    sp->rx_discards.low += __val_27;
    
#line 10874 
    if (sp->rx_discards.low < __val_27) 
#line 10874 
                                        sp->rx_discards.high += 1U; else ;
  }
  else {
    u32 tmp_30;
    
#line 10876 
    tmp_30 = (*(tp->read32))(tp,15432U);
    
#line 10876 
    u32 val_0 = tmp_30;
    
#line 10877 
    val_0 = (val_0 >> 6) & 1U;
    
#line 10878 
    if (val_0 != 0U) {
      
#line 10879 
      (*(tp->write32))(tp,15432U,64U);
      
#line 10880 
      sp->rx_discards.low += val_0;
      
#line 10881 
      if (sp->rx_discards.low < val_0) 
#line 10882 
                                       sp->rx_discards.high += 1U; else ;
    }
    else ;
    
#line 10884 
    sp->mbuf_lwm_thresh_hit = sp->rx_discards;
  }
  {
    u32 tmp_31;
    
#line 10886 
    tmp_31 = (*(tp->read32))(tp,8788U);
    
#line 10886 
    u32 __val_28 = tmp_31;
    
#line 10886 
    sp->rx_errors.low += __val_28;
    
#line 10886 
    if (sp->rx_errors.low < __val_28) 
#line 10886 
                                      sp->rx_errors.high += 1U; else ;
  }
  return_label: 
#line 10888 
                return;
}


#line 10889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_chk_missed_msi(struct tg3 *tp)
{
  u32 i;
  
#line 10893 
  i = 0U;
  
#line 10893 
  goto ldv_58330;
  ldv_58329: 
#line 10894 
  ;
  {
    unsigned int tmp;
    
#line 10894 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 10896 
    tmp = tg3_has_work(tnapi);
    
#line 10896 
    if (tmp != 0U) {
      
#line 10897 
      if (tnapi->last_rx_cons == tnapi->rx_rcb_ptr && tnapi->last_tx_cons == tnapi->tx_cons) {
        
#line 10899 
        if (tnapi->chk_msi_cnt == 0U) {
          
#line 10900 
          tnapi->chk_msi_cnt += 1U;
          
#line 10901 
          goto return_label;
        }
        else ;
        
#line 10903 
        tg3_msi(0,(void *)tnapi);
      }
      else ;
    }
    else ;
    
#line 10906 
    tnapi->chk_msi_cnt = 0U;
    
#line 10907 
    tnapi->last_rx_cons = tnapi->rx_rcb_ptr;
    
#line 10908 
    tnapi->last_tx_cons = tnapi->tx_cons;
  }
  
#line 10893 
  i += 1U;
  ldv_58330: 
#line 10894 
  ;
  
#line 10893 
  if (tp->irq_cnt > i) 
#line 10895 
                       goto ldv_58329; else 
#line 10898 
                                            goto ldv_58331;
  ldv_58331: 
#line 10899 
  ;
  return_label: 
#line 10900 
                return;
}


#line 10912  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_timer(unsigned long __opaque)
{
  int tmp_1;
  int tmp_3;
  
#line 10914 
  struct tg3 *tp = (struct tg3 *)__opaque;
  
#line 10916 
  ldv_spin_lock_107(& tp->lock);
  
#line 10918 
  if (tp->irq_sync != 0U) 
#line 10918 
                          goto _LOR;
  else {
    int tmp;
    
#line 10918 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_RESET_TASK_PENDING,(unsigned long *)(& tp->tg3_flags));
    
#line 10918 
    if (tmp != 0) {
      _LOR: {
              
#line 10919 
              ldv_spin_unlock_108(& tp->lock);
              
#line 10920 
              goto restart_timer;
            }
    }
    else ;
  }
  
#line 10923 
  if (tp->pci_chip_rev_id >> 12 == 22295U) 
#line 10925 
                                           tg3_chk_missed_msi(tp);
  else {
    int tmp_0;
    
#line 10923 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 10923 
    if (tmp_0 != 0) 
#line 10925 
                    tg3_chk_missed_msi(tp); else ;
  }
  
#line 10927 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLUSH_POSTED_WRITES,(unsigned long *)(& tp->tg3_flags));
  
#line 10927 
  if (tmp_1 != 0) 
#line 10929 
                  (*(tp->read32))(tp,15360U); else ;
  
#line 10932 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags));
  
#line 10932 
  if (tmp_3 == 0) {
    u32 tmp_2;
    
#line 10937 
    if (((tp->napi[0].hw_status)->status & 1U) != 0U) 
#line 10938 
                                                      (*(tp->write32))(tp,26632U,tp->grc_local_ctrl | 4U); else 
                                                                    
#line 10941 
                                                                    (*(tp->write32))(tp,15360U,tp->coalesce_mode | 10U);
    
#line 10945 
    tmp_2 = (*(tp->read32))(tp,19456U);
    
#line 10945 
    if ((tmp_2 & 2U) == 0U) {
      
#line 10946 
      ldv_spin_unlock_109(& tp->lock);
      
#line 10947 
      tg3_reset_task_schedule(tp);
      
#line 10948 
      goto restart_timer;
    }
    else ;
  }
  else ;
  
#line 10953 
  tp->timer_counter = (u16)((int)tp->timer_counter - 1);
  
#line 10953 
  if ((unsigned int)tp->timer_counter == 0U) {
    int tmp_4;
    int tmp_10;
    
#line 10954 
    tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 10954 
    if (tmp_4 != 0) 
#line 10955 
                    tg3_periodic_fetch_stats(tp); else ;
    
#line 10957 
    if (tp->setlpicnt != 0U) {
      
#line 10957 
      tp->setlpicnt -= 1U;
      
#line 10957 
      if (tp->setlpicnt == 0U) 
#line 10958 
                               tg3_phy_eee_enable(tp); else ;
    }
    else ;
    
#line 10960 
    tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_LINKCHG_REG,(unsigned long *)(& tp->tg3_flags));
    
#line 10960 
    if (tmp_10 != 0) {
      u32 mac_stat;
      int phy_event;
      
#line 10964 
      mac_stat = (*(tp->read32))(tp,1028U);
      
#line 10966 
      phy_event = 0;
      
#line 10967 
      if ((tp->phy_flags & 4U) != 0U) {
        
#line 10968 
        if ((mac_stat & 8388608U) != 0U) 
#line 10969 
                                         phy_event = 1; else ;
      }
      else 
        
#line 10970 
        if ((mac_stat & 4096U) != 0U) 
#line 10971 
                                      phy_event = 1; else ;
      
#line 10973 
      if (phy_event != 0) 
#line 10974 
                          tg3_setup_phy(tp,(_Bool)0); else ;
    }
    else {
      int tmp_9;
      
#line 10975 
      tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_POLL_SERDES,(unsigned long *)(& tp->tg3_flags));
      
#line 10975 
      if (tmp_9 != 0) {
        u32 tmp_5;
        
#line 10976 
        tmp_5 = (*(tp->read32))(tp,1028U);
        
#line 10976 
        u32 mac_stat_0 = tmp_5;
        
#line 10977 
        int need_setup = 0;
        
#line 10979 
        if ((int)tp->link_up != 0 && (mac_stat_0 & 4096U) != 0U) 
#line 10981 
                                                                 need_setup = 1; else ;
        
#line 10983 
        if (! tp->link_up && (mac_stat_0 & 3U) != 0U) 
#line 10986 
                                                      need_setup = 1; else ;
        
#line 10988 
        if (need_setup != 0) {
          
#line 10989 
          if (tp->serdes_counter == 0U) {
            
#line 10990 
            _tw32_flush(tp,1024U,tp->mac_mode & 4294967283U,0U);
            
#line 10993 
            __const_udelay(171800UL);
            
#line 10994 
            _tw32_flush(tp,1024U,tp->mac_mode,0U);
            
#line 10995 
            __const_udelay(171800UL);
          }
          else ;
          
#line 10997 
          tg3_setup_phy(tp,(_Bool)0);
        }
        else ;
      }
      else 
        
#line 10999 
        if ((tp->phy_flags & 32U) != 0U) {
          int tmp_8;
          
#line 10999 
          tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
          
#line 10999 
          if (tmp_8 != 0) 
#line 11001 
                          tg3_serdes_parallel_detect(tp); else 
#line 10999 
                                                               goto _LAND;
        }
        else {
          int tmp_7;
          _LAND: 
#line 11002 
          tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_POLL_CPMU_LINK,(unsigned long *)(& tp->tg3_flags));
          
#line 11002 
          if (tmp_7 != 0) {
            u32 tmp_6;
            
#line 11003 
            tmp_6 = (*(tp->read32))(tp,13868U);
            
#line 11003 
            u32 cpmu = tmp_6;
            
#line 11004 
            bool link_up = (_Bool)((cpmu & 1572864U) != 1572864U);
            
#line 11007 
            if ((int)tp->link_up != (int)link_up) 
#line 11008 
                                                  tg3_setup_phy(tp,(_Bool)0); else ;
          }
          else ;
        }
    }
    
#line 11011 
    tp->timer_counter = tp->timer_multiplier;
  }
  else ;
  
#line 11031 
  tp->asf_counter = (u16)((int)tp->asf_counter - 1);
  
#line 11031 
  if ((unsigned int)tp->asf_counter == 0U) {
    int tmp_11;
    
#line 11032 
    tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
    
#line 11032 
    if (tmp_11 != 0) {
      int tmp_12;
      
#line 11032 
      tmp_12 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
      
#line 11032 
      if (tmp_12 == 0) {
        
#line 11033 
        tg3_wait_for_event_ack(tp);
        
#line 11035 
        tg3_write_mem(tp,2936U,14U);
        
#line 11037 
        tg3_write_mem(tp,2940U,4U);
        
#line 11038 
        tg3_write_mem(tp,2944U,5U);
        
#line 11041 
        tg3_generate_fw_event(tp);
      }
      else ;
    }
    else ;
    
#line 11043 
    tp->asf_counter = tp->asf_multiplier;
  }
  else ;
  
#line 11046 
  ldv_spin_unlock_110(& tp->lock);
  restart_timer: 
#line 11048 
  ;
  
#line 11049 
  tp->timer.expires = (unsigned long)tp->timer_offset + jiffies;
  
#line 11050 
  add_timer(& tp->timer);
  
#line 11051 
  return;
}


#line 11053  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_timer_init(struct tg3 *tp)
{
  int tmp;
  
#line 11055 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags));
  
#line 11055 
  if (tmp != 0) 
    
#line 11055 
    if (tp->pci_chip_rev_id >> 12 != 22295U) {
      int tmp_0;
      
#line 11056 
      tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
      
#line 11056 
      if (tmp_0 == 0) 
#line 11058 
                      tp->timer_offset = 250U; else 
#line 11060 
                                                    tp->timer_offset = 25U;
    }
    else 
#line 11060 
         tp->timer_offset = 25U;
  else 
#line 11060 
       tp->timer_offset = 25U;
  
#line 11062 
  if ((long)(tp->timer_offset > 250U) != 0L) {
    
#line 11064 
    ldv_inline_asm();
    
#line 11062 
    ;
  }
  else ;
  
#line 11064 
  tp->timer_multiplier = (unsigned short)(250U / tp->timer_offset);
  
#line 11065 
  tp->asf_multiplier = (unsigned short)((unsigned int)((unsigned short)(250U / tp->timer_offset)) * 2U);
  {
    struct lock_class_key __key;
    
#line 11068 
    init_timer_key(& tp->timer,0U,"(&tp->timer)",& __key);
  }
  
#line 11069 
  tp->timer.data = (unsigned long)tp;
  
#line 11070 
  tp->timer.function = & tg3_timer;
  
#line 11071 
  return;
}


#line 11073  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_timer_start(struct tg3 *tp)
{
  
#line 11075 
  tp->asf_counter = tp->asf_multiplier;
  
#line 11076 
  tp->timer_counter = tp->timer_multiplier;
  
#line 11078 
  tp->timer.expires = (unsigned long)tp->timer_offset + jiffies;
  
#line 11079 
  add_timer(& tp->timer);
  
#line 11080 
  return;
}


#line 11082  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_timer_stop(struct tg3 *tp)
{
  
#line 11084 
  ldv_del_timer_sync_111(& tp->timer);
  
#line 11085 
  return;
}


#line 11090  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_restart_hw(struct tg3 *tp, bool reset_phy)
{
  int err;
  
#line 11096 
  err = tg3_init_hw(tp,(_Bool)((bool)((int)reset_phy) != 0));
  
#line 11097 
  if (err != 0) {
    
#line 11098 
    netdev_err((struct net_device const *)tp->dev,"Failed to re-initialize device, aborting\n");
    
#line 11100 
    tg3_halt(tp,0,(_Bool)1);
    
#line 11101 
    tg3_full_unlock(tp);
    
#line 11102 
    tg3_timer_stop(tp);
    
#line 11103 
    tp->irq_sync = 0U;
    
#line 11104 
    tg3_napi_enable(tp);
    
#line 11105 
    dev_close(tp->dev);
    
#line 11106 
    tg3_full_lock(tp,0);
  }
  else ;
  
#line 11108 
  return err;
}


#line 11111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_reset_task(struct work_struct *work)
{
  struct tg3 *tmp;
  int err;
  int tmp_1;
  bool tmp_0;
  int tmp_2;
  {
    
#line 11113 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 11113 
    tmp = (struct tg3 *)__mptr + 18446744073709546840U;
  }
  
#line 11113 
  struct tg3 *tp = tmp;
  
#line 11116 
  rtnl_lock();
  
#line 11117 
  tg3_full_lock(tp,0);
  
#line 11119 
  tmp_0 = netif_running((struct net_device const *)tp->dev);
  
#line 11119 
  if (tmp_0) 
#line 11119 
             tmp_1 = 0; else 
#line 11119 
                             tmp_1 = 1;
  
#line 11119 
  if (tmp_1) {
    
#line 11120 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_RESET_TASK_PENDING,(unsigned long *)(& tp->tg3_flags));
    
#line 11121 
    tg3_full_unlock(tp);
    
#line 11122 
    rtnl_unlock();
    
#line 11123 
    goto return_label;
  }
  else ;
  
#line 11126 
  tg3_full_unlock(tp);
  
#line 11128 
  tg3_phy_stop(tp);
  
#line 11130 
  tg3_netif_stop(tp);
  
#line 11132 
  tg3_full_lock(tp,1);
  
#line 11134 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TX_RECOVERY_PENDING,(unsigned long *)(& tp->tg3_flags));
  
#line 11134 
  if (tmp_2 != 0) {
    
#line 11135 
    tp->write32_tx_mbox = & tg3_write32_tx_mbox;
    
#line 11136 
    tp->write32_rx_mbox = & tg3_write_flush_reg32;
    
#line 11137 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_MBOX_WRITE_REORDER,(unsigned long *)(& tp->tg3_flags));
    
#line 11138 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TX_RECOVERY_PENDING,(unsigned long *)(& tp->tg3_flags));
  }
  else ;
  
#line 11141 
  tg3_halt(tp,0,(_Bool)0);
  
#line 11142 
  err = tg3_init_hw(tp,(_Bool)1);
  
#line 11143 
  if (err != 0) 
#line 11144 
                goto out; else ;
  
#line 11146 
  tg3_netif_start(tp);
  out: 
#line 11148 
  ;
  
#line 11149 
  tg3_full_unlock(tp);
  
#line 11151 
  if (err == 0) 
#line 11152 
                tg3_phy_start(tp); else ;
  
#line 11154 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_RESET_TASK_PENDING,(unsigned long *)(& tp->tg3_flags));
  
#line 11155 
  rtnl_unlock();
  return_label: 
#line 11156 
                return;
}


#line 11158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_request_irq(struct tg3 *tp, int irq_num)
{
  irqreturn_t (*fn)(int , void *);
  unsigned long flags;
  char *name;
  int tmp_1;
  int tmp_3;
  
#line 11163 
  struct tg3_napi *tnapi = & tp->napi[irq_num];
  
#line 11165 
  if (tp->irq_cnt == 1U) 
#line 11166 
                         name = (char *)(& (tp->dev)->name);
  else {
    
#line 11168 
    name = & tnapi->irq_lbl[0];
    
#line 11169 
    if (tnapi->tx_buffers != (struct tg3_tx_ring_info *)0 && tnapi->rx_rcb != (struct tg3_rx_buffer_desc *)0) 
      
#line 11170 
      snprintf(name,16UL,"%s-txrx-%d",(char *)(& (tp->dev)->name),irq_num);
    else 
      
#line 11172 
      if (tnapi->tx_buffers != (struct tg3_tx_ring_info *)0) 
#line 11173 
                                                             snprintf(name,16UL,"%s-tx-%d",(char *)(& (tp->dev)->name),irq_num);
      else 
        
#line 11175 
        if (tnapi->rx_rcb != (struct tg3_rx_buffer_desc *)0) 
#line 11176 
                                                             snprintf(name,16UL,"%s-rx-%d",(char *)(& (tp->dev)->name),irq_num); else 
                                                                    
#line 11179 
                                                                    snprintf(name,16UL,"%s-%d",(char *)(& (tp->dev)->name),irq_num);
    
#line 11181 
    *(name + 15U) = (char)0;
  }
  
#line 11184 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
  
#line 11184 
  if (tmp_1 != 0) 
#line 11184 
                  goto _LOR;
  else {
    int tmp_2;
    
#line 11184 
    tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSIX,(unsigned long *)(& tp->tg3_flags));
    
#line 11184 
    if (tmp_2 != 0) {
      _LOR: {
              int tmp;
              
#line 11185 
              fn = & tg3_msi;
              
#line 11186 
              tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_1SHOT_MSI,(unsigned long *)(& tp->tg3_flags));
              
#line 11186 
              if (tmp != 0) 
#line 11187 
                            fn = & tg3_msi_1shot; else ;
              
#line 11188 
              flags = 0UL;
            }
    }
    else {
      int tmp_0;
      
#line 11190 
      fn = & tg3_interrupt;
      
#line 11191 
      tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags));
      
#line 11191 
      if (tmp_0 != 0) 
#line 11192 
                      fn = & tg3_interrupt_tagged; else ;
      
#line 11193 
      flags = 128UL;
    }
  }
  
#line 11196 
  tmp_3 = ldv_request_irq_112(tnapi->irq_vec,fn,flags,(char const *)name,(void *)tnapi);
  
#line 11196 
  return tmp_3;
}


#line 11199  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_test_interrupt(struct tg3 *tp)
{
  int __retres;
  int err;
  int i;
  u32 val;
  int tmp_0;
  bool tmp;
  int tmp_2;
  
#line 11201 
  struct tg3_napi *tnapi = & tp->napi[0];
  
#line 11202 
  struct net_device *dev = tp->dev;
  
#line 11203 
  int intr_ok = 0;
  
#line 11206 
  tmp = netif_running((struct net_device const *)dev);
  
#line 11206 
  if (tmp) 
#line 11206 
           tmp_0 = 0; else 
#line 11206 
                           tmp_0 = 1;
  
#line 11206 
  if (tmp_0) {
    
#line 11207 
    __retres = -19;
    
#line 11207 
    goto return_label;
  }
  else ;
  
#line 11209 
  tg3_disable_ints(tp);
  
#line 11211 
  ldv_free_irq_113(tnapi->irq_vec,(void *)tnapi);
  
#line 11217 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 11217 
  if (tmp_2 != 0) {
    u32 tmp_1;
    
#line 11218 
    tmp_1 = (*(tp->read32))(tp,24576U);
    
#line 11218 
    val = tmp_1 | 32U;
    
#line 11219 
    (*(tp->write32))(tp,24576U,val);
  }
  else ;
  
#line 11222 
  err = ldv_request_irq_114(tnapi->irq_vec,& tg3_test_isr,128UL,(char const *)(& dev->name),(void *)tnapi);
  
#line 11224 
  if (err != 0) {
    
#line 11225 
    __retres = err;
    
#line 11225 
    goto return_label;
  }
  else ;
  
#line 11227 
  (tnapi->hw_status)->status &= 4294967294U;
  
#line 11228 
  tg3_enable_ints(tp);
  
#line 11230 
  _tw32_flush(tp,15360U,(tp->coalesce_mode | tnapi->coal_now) | 2U,0U);
  
#line 11233 
  i = 0;
  
#line 11233 
  goto ldv_58387;
  ldv_58386: 
#line 11234 
  ;
  {
    u32 int_mbox;
    u32 misc_host_ctrl;
    int tmp_3;
    
#line 11236 
    int_mbox = (*(tp->read32_mbox))(tp,tnapi->int_mbox);
    
#line 11237 
    misc_host_ctrl = (*(tp->read32))(tp,104U);
    
#line 11239 
    if (int_mbox != 0U || (misc_host_ctrl & 2U) != 0U) {
      
#line 11241 
      intr_ok = 1;
      
#line 11242 
      goto ldv_58385;
    }
    else ;
    
#line 11245 
    tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 11245 
    if (tmp_3 != 0) {
      
#line 11245 
      if ((tnapi->hw_status)->status_tag != tnapi->last_tag) 
#line 11247 
                                                             tw32_mailbox_flush(tp,tnapi->int_mbox,tnapi->last_tag << 24); else ;
    }
    else ;
    
#line 11249 
    msleep(10U);
  }
  
#line 11233 
  i += 1;
  ldv_58387: 
#line 11234 
  ;
  
#line 11233 
  if (i <= 4) 
#line 11235 
              goto ldv_58386; else 
#line 11238 
                                   goto ldv_58385;
  ldv_58385: 
#line 11239 
  ;
  
#line 11252 
  tg3_disable_ints(tp);
  
#line 11254 
  ldv_free_irq_115(tnapi->irq_vec,(void *)tnapi);
  
#line 11256 
  err = tg3_request_irq(tp,0);
  
#line 11258 
  if (err != 0) {
    
#line 11259 
    __retres = err;
    
#line 11259 
    goto return_label;
  }
  else ;
  
#line 11261 
  if (intr_ok != 0) {
    int tmp_5;
    
#line 11263 
    tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 11263 
    if (tmp_5 != 0) {
      int tmp_6;
      
#line 11263 
      tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_1SHOT_MSI,(unsigned long *)(& tp->tg3_flags));
      
#line 11263 
      if (tmp_6 != 0) {
        u32 tmp_4;
        
#line 11264 
        tmp_4 = (*(tp->read32))(tp,24576U);
        
#line 11264 
        val = tmp_4 & 4294967263U;
        
#line 11265 
        (*(tp->write32))(tp,24576U,val);
      }
      else ;
    }
    else ;
    
#line 11267 
    __retres = 0;
    
#line 11267 
    goto return_label;
  }
  else ;
  
#line 11270 
  __retres = -5;
  return_label: 
#line 11270 
                return __retres;
}


#line 11276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_test_msi(struct tg3 *tp)
{
  int __retres;
  int err;
  u16 pci_cmd;
  int tmp;
  
#line 11281 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
  
#line 11281 
  if (tmp == 0) {
    
#line 11282 
    __retres = 0;
    
#line 11282 
    goto return_label;
  }
  else ;
  
#line 11287 
  pci_read_config_word((struct pci_dev const *)tp->pdev,4,& pci_cmd);
  
#line 11288 
  pci_write_config_word((struct pci_dev const *)tp->pdev,4,(unsigned short)((int)pci_cmd & 65279));
  
#line 11291 
  err = tg3_test_interrupt(tp);
  
#line 11293 
  pci_write_config_word((struct pci_dev const *)tp->pdev,4,(unsigned short)((int)pci_cmd));
  
#line 11295 
  if (err == 0) {
    
#line 11296 
    __retres = 0;
    
#line 11296 
    goto return_label;
  }
  else ;
  
#line 11299 
  if (err != -5) {
    
#line 11300 
    __retres = err;
    
#line 11300 
    goto return_label;
  }
  else ;
  
#line 11303 
  netdev_warn((struct net_device const *)tp->dev,"No interrupt was generated using MSI. Switching ");
  
#line 11307 
  ldv_free_irq_116(tp->napi[0].irq_vec,(void *)(& tp->napi[0]));
  
#line 11309 
  pci_disable_msi(tp->pdev);
  
#line 11311 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
  
#line 11312 
  tp->napi[0].irq_vec = (tp->pdev)->irq;
  
#line 11314 
  err = tg3_request_irq(tp,0);
  
#line 11315 
  if (err != 0) {
    
#line 11316 
    __retres = err;
    
#line 11316 
    goto return_label;
  }
  else ;
  
#line 11321 
  tg3_full_lock(tp,1);
  
#line 11323 
  tg3_halt(tp,0,(_Bool)1);
  
#line 11324 
  err = tg3_init_hw(tp,(_Bool)1);
  
#line 11326 
  tg3_full_unlock(tp);
  
#line 11328 
  if (err != 0) 
#line 11329 
                ldv_free_irq_117(tp->napi[0].irq_vec,(void *)(& tp->napi[0])); else ;
  
#line 11331 
  __retres = err;
  return_label: 
#line 11331 
                return __retres;
}


#line 11334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_request_firmware(struct tg3 *tp)
{
  int __retres;
  struct tg3_firmware_hdr const *fw_hdr;
  int tmp;
  
#line 11338 
  tmp = request_firmware(& tp->fw,tp->fw_needed,& (tp->pdev)->dev);
  
#line 11338 
  if (tmp != 0) {
    
#line 11339 
    netdev_err((struct net_device const *)tp->dev,"Failed to load firmware \"%s\"\n",tp->fw_needed);
    
#line 11341 
    __retres = -2;
    
#line 11341 
    goto return_label;
  }
  else ;
  
#line 11344 
  fw_hdr = (struct tg3_firmware_hdr const *)(tp->fw)->data;
  
#line 11351 
  if (0 != 0) 
#line 11351 
              tp->fw_len = (((fw_hdr->len << 24) | ((fw_hdr->len << 8) & 16711680U)) | ((fw_hdr->len >> 8) & 65280U)) | (fw_hdr->len >> 24); else 
                                                                    
#line 11351 
                                                                    tp->fw_len = __fswab32(fw_hdr->len);
  
#line 11352 
  if ((unsigned long)tp->fw_len < (tp->fw)->size + 18446744073709551604UL) {
    
#line 11353 
    netdev_err((struct net_device const *)tp->dev,"bogus length %d in \"%s\"\n",tp->fw_len,tp->fw_needed);
    
#line 11355 
    release_firmware(tp->fw);
    
#line 11356 
    tp->fw = (struct firmware const *)0;
    
#line 11357 
    __retres = -22;
    
#line 11357 
    goto return_label;
  }
  else ;
  
#line 11361 
  tp->fw_needed = (char const *)0;
  
#line 11362 
  __retres = 0;
  return_label: 
#line 11362 
                return __retres;
}


#line 11365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_irq_count(struct tg3 *tp)
{
  u32 tmp_0;
  {
    u32 tmp;
    
#line 11367 
    u32 _max1 = tp->rxq_cnt;
    
#line 11367 
    u32 _max2 = tp->txq_cnt;
    
#line 11367 
    if (_max1 > _max2) 
#line 11367 
                       tmp = _max1; else 
#line 11367 
                                         tmp = _max2;
    
#line 11367 
    tmp_0 = tmp;
  }
  
#line 11367 
  u32 irq_cnt = tmp_0;
  
#line 11369 
  if (irq_cnt > 1U) {
    unsigned int tmp_2;
    {
      unsigned int tmp_1;
      
#line 11375 
      unsigned int __min1 = irq_cnt + 1U;
      
#line 11375 
      unsigned int __min2 = tp->irq_max;
      
#line 11375 
      if (__min1 < __min2) 
#line 11375 
                           tmp_1 = __min1; else 
#line 11375 
                                                tmp_1 = __min2;
      
#line 11375 
      tmp_2 = tmp_1;
    }
    
#line 11375 
    irq_cnt = tmp_2;
  }
  else ;
  
#line 11378 
  return irq_cnt;
}


#line 11381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_enable_msix(struct tg3 *tp)
{
  bool __retres;
  int i;
  int rc;
  struct msix_entry msix_ent[5U];
  int tmp_4;
  
#line 11386 
  tp->txq_cnt = tp->txq_req;
  
#line 11387 
  tp->rxq_cnt = tp->rxq_req;
  
#line 11388 
  if (tp->rxq_cnt == 0U) {
    int tmp;
    
#line 11389 
    tmp = netif_get_num_default_rss_queues();
    
#line 11389 
    tp->rxq_cnt = (unsigned int)tmp;
  }
  else ;
  
#line 11390 
  if (tp->rxq_cnt > tp->rxq_max) 
#line 11391 
                                 tp->rxq_cnt = tp->rxq_max; else ;
  
#line 11397 
  if (tp->txq_req == 0U) 
#line 11398 
                         tp->txq_cnt = 1U; else ;
  
#line 11400 
  tp->irq_cnt = tg3_irq_count(tp);
  
#line 11402 
  i = 0;
  
#line 11402 
  goto ldv_58414;
  ldv_58413: 
#line 11403 
  ;
  
#line 11403 
  msix_ent[i].entry = (unsigned short)i;
  
#line 11404 
  msix_ent[i].vector = 0U;
  
#line 11402 
  i += 1;
  ldv_58414: 
#line 11403 
  ;
  
#line 11402 
  if (tp->irq_max > (unsigned int)i) 
#line 11404 
                                     goto ldv_58413; else 
#line 11407 
                                                          goto ldv_58415;
  ldv_58415: 
#line 11408 
  ;
  
#line 11407 
  rc = pci_enable_msix_range(tp->pdev,(struct msix_entry *)(& msix_ent),1,(int)tp->irq_cnt);
  
#line 11408 
  if (rc < 0) {
    
#line 11409 
    __retres = (_Bool)0;
    
#line 11409 
    goto return_label;
  }
  else 
    
#line 11410 
    if (tp->irq_cnt > (unsigned int)rc) {
      int tmp_1;
      
#line 11411 
      netdev_notice((struct net_device const *)tp->dev,"Requested %d MSI-X vectors, received %d\n",tp->irq_cnt,rc);
      
#line 11413 
      tp->irq_cnt = (unsigned int)rc;
      {
        int tmp_0;
        
#line 11414 
        int _max1 = rc + -1;
        
#line 11414 
        int _max2 = 1;
        
#line 11414 
        if (_max1 > _max2) 
#line 11414 
                           tmp_0 = _max1; else 
#line 11414 
                                               tmp_0 = _max2;
        
#line 11414 
        tmp_1 = tmp_0;
      }
      
#line 11414 
      tp->rxq_cnt = (unsigned int)tmp_1;
      
#line 11415 
      if (tp->txq_cnt != 0U) {
        u32 tmp_3;
        {
          u32 tmp_2;
          
#line 11416 
          u32 _min1 = tp->rxq_cnt;
          
#line 11416 
          u32 _min2 = tp->txq_max;
          
#line 11416 
          if (_min1 < _min2) 
#line 11416 
                             tmp_2 = _min1; else 
#line 11416 
                                                 tmp_2 = _min2;
          
#line 11416 
          tmp_3 = tmp_2;
        }
        
#line 11416 
        tp->txq_cnt = tmp_3;
      }
      else ;
    }
    else ;
  
#line 11419 
  i = 0;
  
#line 11419 
  goto ldv_58423;
  ldv_58422: 
#line 11420 
  ;
  
#line 11420 
  tp->napi[i].irq_vec = msix_ent[i].vector;
  
#line 11419 
  i += 1;
  ldv_58423: 
#line 11420 
  ;
  
#line 11419 
  if (tp->irq_max > (unsigned int)i) 
#line 11421 
                                     goto ldv_58422; else 
#line 11424 
                                                          goto ldv_58424;
  ldv_58424: 
#line 11425 
  ;
  
#line 11422 
  tmp_4 = netif_set_real_num_rx_queues(tp->dev,tp->rxq_cnt);
  
#line 11422 
  if (tmp_4 != 0) {
    
#line 11423 
    pci_disable_msix(tp->pdev);
    
#line 11424 
    __retres = (_Bool)0;
    
#line 11424 
    goto return_label;
  }
  else ;
  
#line 11427 
  if (tp->irq_cnt == 1U) {
    
#line 11428 
    __retres = (_Bool)1;
    
#line 11428 
    goto return_label;
  }
  else ;
  
#line 11430 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 11432 
  if (tp->txq_cnt > 1U) 
#line 11433 
                        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 11435 
  netif_set_real_num_tx_queues(tp->dev,tp->txq_cnt);
  
#line 11437 
  __retres = (_Bool)1;
  return_label: 
#line 11437 
                return __retres;
}


#line 11440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ints_init(struct tg3 *tp)
{
  int tmp;
  int tmp_4;
  int tmp_9;
  int tmp_11;
  
#line 11442 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSI,(unsigned long *)(& tp->tg3_flags));
  
#line 11442 
  if (tmp != 0) 
#line 11442 
                goto _LOR;
  else {
    int tmp_0;
    
#line 11442 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
    
#line 11442 
    if (tmp_0 != 0) {
      int tmp_1;
      _LOR: 
#line 11442 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags));
      
#line 11442 
      if (tmp_1 == 0) {
        
#line 11447 
        netdev_warn((struct net_device const *)tp->dev,"MSI without TAGGED_STATUS? Not using MSI\n");
        
#line 11449 
        goto defcfg;
      }
      else ;
    }
    else ;
  }
  
#line 11452 
  tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 11452 
  if (tmp_4 != 0) {
    bool tmp_5;
    
#line 11452 
    tmp_5 = tg3_enable_msix(tp);
    
#line 11452 
    if ((int)tmp_5 != 0) 
#line 11453 
                         _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USING_MSIX,(unsigned long *)(& tp->tg3_flags)); else 
                                                                    
#line 11452 
                                                                    goto _LAND;
  }
  else {
    int tmp_2;
    _LAND: 
#line 11454 
    tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSI,(unsigned long *)(& tp->tg3_flags));
    
#line 11454 
    if (tmp_2 != 0) {
      int tmp_3;
      
#line 11454 
      tmp_3 = pci_enable_msi_exact(tp->pdev,1);
      
#line 11454 
      if (tmp_3 == 0) 
#line 11455 
                      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags)); else ;
    }
    else ;
  }
  
#line 11457 
  tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
  
#line 11457 
  if (tmp_9 != 0) 
#line 11457 
                  goto _LOR_0;
  else {
    int tmp_10;
    
#line 11457 
    tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSIX,(unsigned long *)(& tp->tg3_flags));
    
#line 11457 
    if (tmp_10 != 0) {
      _LOR_0: {
                u32 tmp_6;
                int tmp_7;
                int tmp_8;
                
#line 11458 
                tmp_6 = (*(tp->read32))(tp,24576U);
                
#line 11458 
                u32 msi_mode = tmp_6;
                
#line 11459 
                tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSIX,(unsigned long *)(& tp->tg3_flags));
                
#line 11459 
                if (tmp_7 != 0) {
                  
#line 11459 
                  if (tp->irq_cnt > 1U) 
#line 11460 
                                        msi_mode |= 128U; else ;
                }
                else ;
                
#line 11461 
                tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_1SHOT_MSI,(unsigned long *)(& tp->tg3_flags));
                
#line 11461 
                if (tmp_8 == 0) 
#line 11462 
                                msi_mode |= 32U; else ;
                
#line 11463 
                (*(tp->write32))(tp,24576U,msi_mode | 2U);
              }
    }
    else ;
  }
  defcfg: 
#line 11465 
  ;
  
#line 11466 
  tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 11466 
  if (tmp_11 == 0) {
    
#line 11467 
    tp->irq_cnt = 1U;
    
#line 11468 
    tp->napi[0].irq_vec = (tp->pdev)->irq;
  }
  else ;
  
#line 11471 
  if (tp->irq_cnt == 1U) {
    
#line 11472 
    tp->txq_cnt = 1U;
    
#line 11473 
    tp->rxq_cnt = 1U;
    
#line 11474 
    netif_set_real_num_tx_queues(tp->dev,1U);
    
#line 11475 
    netif_set_real_num_rx_queues(tp->dev,1U);
  }
  else ;
  
#line 11477 
  return;
}


#line 11479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_ints_fini(struct tg3 *tp)
{
  int tmp_0;
  
#line 11481 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 11481 
  if (tmp_0 != 0) 
#line 11482 
                  pci_disable_msix(tp->pdev);
  else {
    int tmp;
    
#line 11483 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
    
#line 11483 
    if (tmp != 0) 
#line 11484 
                  pci_disable_msi(tp->pdev); else ;
  }
  
#line 11485 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
  
#line 11486 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USING_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 11487 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 11488 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
  
#line 11489 
  return;
}


#line 11491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_start(struct tg3 *tp, bool reset_phy, bool test_irq, bool init)
{
  int __retres;
  int i;
  int err;
  
#line 11494 
  struct net_device *dev = tp->dev;
  
#line 11501 
  tg3_ints_init(tp);
  
#line 11503 
  tg3_rss_check_indir_tbl(tp);
  
#line 11508 
  err = tg3_alloc_consistent(tp);
  
#line 11509 
  if (err != 0) 
#line 11510 
                goto out_ints_fini; else ;
  
#line 11512 
  tg3_napi_init(tp);
  
#line 11514 
  tg3_napi_enable(tp);
  
#line 11516 
  i = 0;
  
#line 11516 
  goto ldv_58449;
  ldv_58448: 
#line 11517 
  ;
  {
    
#line 11517 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 11518 
    err = tg3_request_irq(tp,i);
    
#line 11519 
    if (err != 0) {
      
#line 11520 
      i -= 1;
      
#line 11520 
      goto ldv_58445;
      ldv_58444: 
#line 11521 
      ;
      
#line 11521 
      tnapi = & tp->napi[i];
      
#line 11522 
      ldv_free_irq_118(tnapi->irq_vec,(void *)tnapi);
      
#line 11520 
      i -= 1;
      ldv_58445: 
#line 11521 
      ;
      
#line 11520 
      if (i >= 0) 
#line 11522 
                  goto ldv_58444; else 
#line 11525 
                                       goto ldv_58446;
      ldv_58446: 
#line 11526 
      ;
      
#line 11524 
      goto out_napi_fini;
    }
    else ;
  }
  
#line 11516 
  i += 1;
  ldv_58449: 
#line 11517 
  ;
  
#line 11516 
  if (tp->irq_cnt > (unsigned int)i) 
#line 11518 
                                     goto ldv_58448; else 
#line 11521 
                                                          goto ldv_58450;
  ldv_58450: 
#line 11522 
  ;
  
#line 11528 
  tg3_full_lock(tp,0);
  
#line 11530 
  if ((int)init != 0) 
#line 11531 
                      tg3_ape_driver_state_change(tp,1); else ;
  
#line 11533 
  err = tg3_init_hw(tp,(_Bool)((bool)((int)reset_phy) != 0));
  
#line 11534 
  if (err != 0) {
    
#line 11535 
    tg3_halt(tp,0,(_Bool)1);
    
#line 11536 
    tg3_free_rings(tp);
  }
  else ;
  
#line 11539 
  tg3_full_unlock(tp);
  
#line 11541 
  if (err != 0) 
#line 11542 
                goto out_free_irq; else ;
  
#line 11544 
  if ((int)test_irq != 0) {
    int tmp_2;
    
#line 11544 
    tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
    
#line 11544 
    if (tmp_2 != 0) {
      int tmp_0;
      
#line 11545 
      err = tg3_test_msi(tp);
      
#line 11547 
      if (err != 0) {
        
#line 11548 
        tg3_full_lock(tp,0);
        
#line 11549 
        tg3_halt(tp,0,(_Bool)1);
        
#line 11550 
        tg3_free_rings(tp);
        
#line 11551 
        tg3_full_unlock(tp);
        
#line 11553 
        goto out_napi_fini;
      }
      else ;
      
#line 11556 
      tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 11556 
      if (tmp_0 == 0) {
        int tmp_1;
        
#line 11556 
        tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USING_MSI,(unsigned long *)(& tp->tg3_flags));
        
#line 11556 
        if (tmp_1 != 0) {
          u32 tmp;
          
#line 11557 
          tmp = (*(tp->read32))(tp,31748U);
          
#line 11557 
          u32 val = tmp;
          
#line 11559 
          (*(tp->write32))(tp,31748U,val | 536870912U);
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 11564 
  tg3_phy_start(tp);
  
#line 11566 
  tg3_hwmon_open(tp);
  
#line 11568 
  tg3_full_lock(tp,0);
  
#line 11570 
  tg3_timer_start(tp);
  
#line 11571 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
  
#line 11572 
  tg3_enable_ints(tp);
  
#line 11574 
  tg3_ptp_resume(tp);
  
#line 11576 
  tg3_full_unlock(tp);
  
#line 11578 
  netif_tx_start_all_queues(dev);
  
#line 11584 
  if ((dev->features & 68719476736ULL) != 0ULL) 
#line 11585 
                                                tg3_set_loopback(dev,dev->features); else ;
  
#line 11587 
  __retres = 0;
  
#line 11587 
  goto return_label;
  out_free_irq: 
#line 11589 
  ;
  
#line 11590 
  i = (int)(tp->irq_cnt + 4294967295U);
  
#line 11590 
  goto ldv_58455;
  ldv_58454: 
#line 11591 
  ;
  {
    
#line 11591 
    struct tg3_napi *tnapi_0 = & tp->napi[i];
    
#line 11592 
    ldv_free_irq_119(tnapi_0->irq_vec,(void *)tnapi_0);
  }
  
#line 11590 
  i -= 1;
  ldv_58455: 
#line 11591 
  ;
  
#line 11590 
  if (i >= 0) 
#line 11592 
              goto ldv_58454; else 
#line 11595 
                                   goto ldv_58456;
  ldv_58456: 
#line 11596 
  ;
  out_napi_fini: 
#line 11595 
  ;
  
#line 11596 
  tg3_napi_disable(tp);
  
#line 11597 
  tg3_napi_fini(tp);
  
#line 11598 
  tg3_free_consistent(tp);
  out_ints_fini: 
#line 11600 
  ;
  
#line 11601 
  tg3_ints_fini(tp);
  
#line 11603 
  __retres = err;
  return_label: 
#line 11603 
                return __retres;
}


#line 11606  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_stop(struct tg3 *tp)
{
  int i;
  
#line 11610 
  tg3_reset_task_cancel(tp);
  
#line 11611 
  tg3_netif_stop(tp);
  
#line 11613 
  tg3_timer_stop(tp);
  
#line 11615 
  tg3_hwmon_close(tp);
  
#line 11617 
  tg3_phy_stop(tp);
  
#line 11619 
  tg3_full_lock(tp,1);
  
#line 11621 
  tg3_disable_ints(tp);
  
#line 11623 
  tg3_halt(tp,0,(_Bool)1);
  
#line 11624 
  tg3_free_rings(tp);
  
#line 11625 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
  
#line 11627 
  tg3_full_unlock(tp);
  
#line 11629 
  i = (int)(tp->irq_cnt + 4294967295U);
  
#line 11629 
  goto ldv_58463;
  ldv_58462: 
#line 11630 
  ;
  {
    
#line 11630 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 11631 
    ldv_free_irq_120(tnapi->irq_vec,(void *)tnapi);
  }
  
#line 11629 
  i -= 1;
  ldv_58463: 
#line 11630 
  ;
  
#line 11629 
  if (i >= 0) 
#line 11631 
              goto ldv_58462; else 
#line 11634 
                                   goto ldv_58464;
  ldv_58464: 
#line 11635 
  ;
  
#line 11634 
  tg3_ints_fini(tp);
  
#line 11636 
  tg3_napi_fini(tp);
  
#line 11638 
  tg3_free_consistent(tp);
  
#line 11639 
  return;
}


#line 11641  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_open(struct net_device *dev)
{
  int __retres;
  int err;
  
#line 11643 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 11646 
  if ((int)tp->pcierr_recovery != 0) {
    
#line 11647 
    netdev_err((struct net_device const *)dev,"Failed to open device. PCI error recovery ");
    
#line 11649 
    __retres = -11;
    
#line 11649 
    goto return_label;
  }
  else ;
  
#line 11652 
  if (tp->fw_needed != (char const *)0) {
    
#line 11653 
    err = tg3_request_firmware(tp);
    
#line 11654 
    if (tp->pci_chip_rev_id >> 12 == 358246U) {
      
#line 11655 
      if (err != 0) {
        
#line 11656 
        netdev_warn((struct net_device const *)tp->dev,"EEE capability disabled\n");
        
#line 11657 
        tp->phy_flags &= 4294705151U;
      }
      else 
        
#line 11658 
        if ((tp->phy_flags & 262144U) == 0U) {
          
#line 11659 
          netdev_warn((struct net_device const *)tp->dev,"EEE capability restored\n");
          
#line 11660 
          tp->phy_flags |= 262144U;
        }
        else ;
    }
    else 
      
#line 11662 
      if (tp->pci_chip_rev_id == 0U) {
        
#line 11663 
        if (err != 0) {
          
#line 11664 
          __retres = err;
          
#line 11664 
          goto return_label;
        }
        else ;
      }
      else 
        
#line 11665 
        if (err != 0) {
          
#line 11666 
          netdev_warn((struct net_device const *)tp->dev,"TSO capability disabled\n");
          
#line 11667 
          _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
        }
        else {
          int tmp_0;
          
#line 11668 
          tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
          
#line 11668 
          if (tmp_0 == 0) {
            
#line 11669 
            netdev_notice((struct net_device const *)tp->dev,"TSO capability restored\n");
            
#line 11670 
            _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
          }
          else ;
        }
  }
  else ;
  
#line 11674 
  tg3_carrier_off(tp);
  
#line 11676 
  err = tg3_power_up(tp);
  
#line 11677 
  if (err != 0) {
    
#line 11678 
    __retres = err;
    
#line 11678 
    goto return_label;
  }
  else ;
  
#line 11680 
  tg3_full_lock(tp,0);
  
#line 11682 
  tg3_disable_ints(tp);
  
#line 11683 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
  
#line 11685 
  tg3_full_unlock(tp);
  
#line 11687 
  err = tg3_start(tp,(_Bool)((tp->phy_flags & 1048576U) == 0U),(_Bool)1,(_Bool)1);
  
#line 11690 
  if (err != 0) {
    
#line 11691 
    tg3_frob_aux_power(tp,(_Bool)0);
    
#line 11692 
    pci_set_power_state(tp->pdev,3);
  }
  else ;
  
#line 11695 
  __retres = err;
  return_label: 
#line 11695 
                return __retres;
}


#line 11698  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_close(struct net_device *dev)
{
  int __retres;
  bool tmp_0;
  
#line 11700 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 11702 
  if ((int)tp->pcierr_recovery != 0) {
    
#line 11703 
    netdev_err((struct net_device const *)dev,"Failed to close device. PCI error recovery ");
    
#line 11705 
    __retres = -11;
    
#line 11705 
    goto return_label;
  }
  else ;
  
#line 11708 
  tg3_stop(tp);
  
#line 11711 
  memset((void *)(& tp->net_stats_prev),0,184UL);
  
#line 11712 
  memset((void *)(& tp->estats_prev),0,576UL);
  
#line 11714 
  tmp_0 = pci_device_is_present(tp->pdev);
  
#line 11714 
  if ((int)tmp_0 != 0) {
    
#line 11715 
    tg3_power_down_prepare(tp);
    
#line 11717 
    tg3_carrier_off(tp);
  }
  else ;
  
#line 11719 
  __retres = 0;
  return_label: 
#line 11719 
                return __retres;
}


#line 11722  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static u64 get_stat64(tg3_stat64_t *val)
{
  u64 __retres;
  
#line 11724 
  __retres = ((unsigned long long)val->high << 32) | (unsigned long long)val->low;
  
#line 11724 
  return __retres;
}


#line 11727  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u64 tg3_calc_crc_errors(struct tg3 *tp)
{
  u64 __retres;
  u64 tmp_0;
  
#line 11729 
  struct tg3_hw_stats *hw_stats = tp->hw_stats;
  
#line 11731 
  if ((tp->phy_flags & 16U) == 0U && (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U)) {
    u32 val;
    int tmp;
    
#line 11736 
    tmp = tg3_readphy(tp,30,& val);
    
#line 11736 
    if (tmp == 0) {
      
#line 11737 
      tg3_writephy(tp,30,val | 32768U);
      
#line 11739 
      tg3_readphy(tp,20,& val);
    }
    else 
#line 11741 
         val = 0U;
    
#line 11743 
    tp->__anonCompField_tg3_119.phy_crc_errors += (unsigned long)val;
    
#line 11745 
    __retres = (unsigned long long)tp->__anonCompField_tg3_119.phy_crc_errors;
    
#line 11745 
    goto return_label;
  }
  else ;
  
#line 11748 
  tmp_0 = get_stat64(& hw_stats->rx_fcs_errors);
  
#line 11748 
  __retres = tmp_0;
  return_label: 
#line 11748 
                return __retres;
}


#line 11755  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_estats(struct tg3 *tp, struct tg3_ethtool_stats *estats)
{
  u64 tmp;
  u64 tmp_0;
  u64 tmp_1;
  u64 tmp_2;
  u64 tmp_3;
  u64 tmp_4;
  u64 tmp_5;
  u64 tmp_6;
  u64 tmp_7;
  u64 tmp_8;
  u64 tmp_9;
  u64 tmp_10;
  u64 tmp_11;
  u64 tmp_12;
  u64 tmp_13;
  u64 tmp_14;
  u64 tmp_15;
  u64 tmp_16;
  u64 tmp_17;
  u64 tmp_18;
  u64 tmp_19;
  u64 tmp_20;
  u64 tmp_21;
  u64 tmp_22;
  u64 tmp_23;
  u64 tmp_24;
  u64 tmp_25;
  u64 tmp_26;
  u64 tmp_27;
  u64 tmp_28;
  u64 tmp_29;
  u64 tmp_30;
  u64 tmp_31;
  u64 tmp_32;
  u64 tmp_33;
  u64 tmp_34;
  u64 tmp_35;
  u64 tmp_36;
  u64 tmp_37;
  u64 tmp_38;
  u64 tmp_39;
  u64 tmp_40;
  u64 tmp_41;
  u64 tmp_42;
  u64 tmp_43;
  u64 tmp_44;
  u64 tmp_45;
  u64 tmp_46;
  u64 tmp_47;
  u64 tmp_48;
  u64 tmp_49;
  u64 tmp_50;
  u64 tmp_51;
  u64 tmp_52;
  u64 tmp_53;
  u64 tmp_54;
  u64 tmp_55;
  u64 tmp_56;
  u64 tmp_57;
  u64 tmp_58;
  u64 tmp_59;
  u64 tmp_60;
  u64 tmp_61;
  u64 tmp_62;
  u64 tmp_63;
  u64 tmp_64;
  u64 tmp_65;
  u64 tmp_66;
  u64 tmp_67;
  u64 tmp_68;
  u64 tmp_69;
  u64 tmp_70;
  
#line 11757 
  struct tg3_ethtool_stats *old_estats = & tp->estats_prev;
  
#line 11758 
  struct tg3_hw_stats *hw_stats = tp->hw_stats;
  
#line 11760 
  tmp = get_stat64(& hw_stats->rx_octets);
  
#line 11760 
  estats->rx_octets = old_estats->rx_octets + tmp;
  
#line 11761 
  tmp_0 = get_stat64(& hw_stats->rx_fragments);
  
#line 11761 
  estats->rx_fragments = old_estats->rx_fragments + tmp_0;
  
#line 11762 
  tmp_1 = get_stat64(& hw_stats->rx_ucast_packets);
  
#line 11762 
  estats->rx_ucast_packets = old_estats->rx_ucast_packets + tmp_1;
  
#line 11763 
  tmp_2 = get_stat64(& hw_stats->rx_mcast_packets);
  
#line 11763 
  estats->rx_mcast_packets = old_estats->rx_mcast_packets + tmp_2;
  
#line 11764 
  tmp_3 = get_stat64(& hw_stats->rx_bcast_packets);
  
#line 11764 
  estats->rx_bcast_packets = old_estats->rx_bcast_packets + tmp_3;
  
#line 11765 
  tmp_4 = get_stat64(& hw_stats->rx_fcs_errors);
  
#line 11765 
  estats->rx_fcs_errors = old_estats->rx_fcs_errors + tmp_4;
  
#line 11766 
  tmp_5 = get_stat64(& hw_stats->rx_align_errors);
  
#line 11766 
  estats->rx_align_errors = old_estats->rx_align_errors + tmp_5;
  
#line 11767 
  tmp_6 = get_stat64(& hw_stats->rx_xon_pause_rcvd);
  
#line 11767 
  estats->rx_xon_pause_rcvd = old_estats->rx_xon_pause_rcvd + tmp_6;
  
#line 11768 
  tmp_7 = get_stat64(& hw_stats->rx_xoff_pause_rcvd);
  
#line 11768 
  estats->rx_xoff_pause_rcvd = old_estats->rx_xoff_pause_rcvd + tmp_7;
  
#line 11769 
  tmp_8 = get_stat64(& hw_stats->rx_mac_ctrl_rcvd);
  
#line 11769 
  estats->rx_mac_ctrl_rcvd = old_estats->rx_mac_ctrl_rcvd + tmp_8;
  
#line 11770 
  tmp_9 = get_stat64(& hw_stats->rx_xoff_entered);
  
#line 11770 
  estats->rx_xoff_entered = old_estats->rx_xoff_entered + tmp_9;
  
#line 11771 
  tmp_10 = get_stat64(& hw_stats->rx_frame_too_long_errors);
  
#line 11771 
  estats->rx_frame_too_long_errors = old_estats->rx_frame_too_long_errors + tmp_10;
  
#line 11772 
  tmp_11 = get_stat64(& hw_stats->rx_jabbers);
  
#line 11772 
  estats->rx_jabbers = old_estats->rx_jabbers + tmp_11;
  
#line 11773 
  tmp_12 = get_stat64(& hw_stats->rx_undersize_packets);
  
#line 11773 
  estats->rx_undersize_packets = old_estats->rx_undersize_packets + tmp_12;
  
#line 11774 
  tmp_13 = get_stat64(& hw_stats->rx_in_length_errors);
  
#line 11774 
  estats->rx_in_length_errors = old_estats->rx_in_length_errors + tmp_13;
  
#line 11775 
  tmp_14 = get_stat64(& hw_stats->rx_out_length_errors);
  
#line 11775 
  estats->rx_out_length_errors = old_estats->rx_out_length_errors + tmp_14;
  
#line 11776 
  tmp_15 = get_stat64(& hw_stats->rx_64_or_less_octet_packets);
  
#line 11776 
  estats->rx_64_or_less_octet_packets = old_estats->rx_64_or_less_octet_packets + tmp_15;
  
#line 11777 
  tmp_16 = get_stat64(& hw_stats->rx_65_to_127_octet_packets);
  
#line 11777 
  estats->rx_65_to_127_octet_packets = old_estats->rx_65_to_127_octet_packets + tmp_16;
  
#line 11778 
  tmp_17 = get_stat64(& hw_stats->rx_128_to_255_octet_packets);
  
#line 11778 
  estats->rx_128_to_255_octet_packets = old_estats->rx_128_to_255_octet_packets + tmp_17;
  
#line 11779 
  tmp_18 = get_stat64(& hw_stats->rx_256_to_511_octet_packets);
  
#line 11779 
  estats->rx_256_to_511_octet_packets = old_estats->rx_256_to_511_octet_packets + tmp_18;
  
#line 11780 
  tmp_19 = get_stat64(& hw_stats->rx_512_to_1023_octet_packets);
  
#line 11780 
  estats->rx_512_to_1023_octet_packets = old_estats->rx_512_to_1023_octet_packets + tmp_19;
  
#line 11781 
  tmp_20 = get_stat64(& hw_stats->rx_1024_to_1522_octet_packets);
  
#line 11781 
  estats->rx_1024_to_1522_octet_packets = old_estats->rx_1024_to_1522_octet_packets + tmp_20;
  
#line 11782 
  tmp_21 = get_stat64(& hw_stats->rx_1523_to_2047_octet_packets);
  
#line 11782 
  estats->rx_1523_to_2047_octet_packets = old_estats->rx_1523_to_2047_octet_packets + tmp_21;
  
#line 11783 
  tmp_22 = get_stat64(& hw_stats->rx_2048_to_4095_octet_packets);
  
#line 11783 
  estats->rx_2048_to_4095_octet_packets = old_estats->rx_2048_to_4095_octet_packets + tmp_22;
  
#line 11784 
  tmp_23 = get_stat64(& hw_stats->rx_4096_to_8191_octet_packets);
  
#line 11784 
  estats->rx_4096_to_8191_octet_packets = old_estats->rx_4096_to_8191_octet_packets + tmp_23;
  
#line 11785 
  tmp_24 = get_stat64(& hw_stats->rx_8192_to_9022_octet_packets);
  
#line 11785 
  estats->rx_8192_to_9022_octet_packets = old_estats->rx_8192_to_9022_octet_packets + tmp_24;
  
#line 11787 
  tmp_25 = get_stat64(& hw_stats->tx_octets);
  
#line 11787 
  estats->tx_octets = old_estats->tx_octets + tmp_25;
  
#line 11788 
  tmp_26 = get_stat64(& hw_stats->tx_collisions);
  
#line 11788 
  estats->tx_collisions = old_estats->tx_collisions + tmp_26;
  
#line 11789 
  tmp_27 = get_stat64(& hw_stats->tx_xon_sent);
  
#line 11789 
  estats->tx_xon_sent = old_estats->tx_xon_sent + tmp_27;
  
#line 11790 
  tmp_28 = get_stat64(& hw_stats->tx_xoff_sent);
  
#line 11790 
  estats->tx_xoff_sent = old_estats->tx_xoff_sent + tmp_28;
  
#line 11791 
  tmp_29 = get_stat64(& hw_stats->tx_flow_control);
  
#line 11791 
  estats->tx_flow_control = old_estats->tx_flow_control + tmp_29;
  
#line 11792 
  tmp_30 = get_stat64(& hw_stats->tx_mac_errors);
  
#line 11792 
  estats->tx_mac_errors = old_estats->tx_mac_errors + tmp_30;
  
#line 11793 
  tmp_31 = get_stat64(& hw_stats->tx_single_collisions);
  
#line 11793 
  estats->tx_single_collisions = old_estats->tx_single_collisions + tmp_31;
  
#line 11794 
  tmp_32 = get_stat64(& hw_stats->tx_mult_collisions);
  
#line 11794 
  estats->tx_mult_collisions = old_estats->tx_mult_collisions + tmp_32;
  
#line 11795 
  tmp_33 = get_stat64(& hw_stats->tx_deferred);
  
#line 11795 
  estats->tx_deferred = old_estats->tx_deferred + tmp_33;
  
#line 11796 
  tmp_34 = get_stat64(& hw_stats->tx_excessive_collisions);
  
#line 11796 
  estats->tx_excessive_collisions = old_estats->tx_excessive_collisions + tmp_34;
  
#line 11797 
  tmp_35 = get_stat64(& hw_stats->tx_late_collisions);
  
#line 11797 
  estats->tx_late_collisions = old_estats->tx_late_collisions + tmp_35;
  
#line 11798 
  tmp_36 = get_stat64(& hw_stats->tx_collide_2times);
  
#line 11798 
  estats->tx_collide_2times = old_estats->tx_collide_2times + tmp_36;
  
#line 11799 
  tmp_37 = get_stat64(& hw_stats->tx_collide_3times);
  
#line 11799 
  estats->tx_collide_3times = old_estats->tx_collide_3times + tmp_37;
  
#line 11800 
  tmp_38 = get_stat64(& hw_stats->tx_collide_4times);
  
#line 11800 
  estats->tx_collide_4times = old_estats->tx_collide_4times + tmp_38;
  
#line 11801 
  tmp_39 = get_stat64(& hw_stats->tx_collide_5times);
  
#line 11801 
  estats->tx_collide_5times = old_estats->tx_collide_5times + tmp_39;
  
#line 11802 
  tmp_40 = get_stat64(& hw_stats->tx_collide_6times);
  
#line 11802 
  estats->tx_collide_6times = old_estats->tx_collide_6times + tmp_40;
  
#line 11803 
  tmp_41 = get_stat64(& hw_stats->tx_collide_7times);
  
#line 11803 
  estats->tx_collide_7times = old_estats->tx_collide_7times + tmp_41;
  
#line 11804 
  tmp_42 = get_stat64(& hw_stats->tx_collide_8times);
  
#line 11804 
  estats->tx_collide_8times = old_estats->tx_collide_8times + tmp_42;
  
#line 11805 
  tmp_43 = get_stat64(& hw_stats->tx_collide_9times);
  
#line 11805 
  estats->tx_collide_9times = old_estats->tx_collide_9times + tmp_43;
  
#line 11806 
  tmp_44 = get_stat64(& hw_stats->tx_collide_10times);
  
#line 11806 
  estats->tx_collide_10times = old_estats->tx_collide_10times + tmp_44;
  
#line 11807 
  tmp_45 = get_stat64(& hw_stats->tx_collide_11times);
  
#line 11807 
  estats->tx_collide_11times = old_estats->tx_collide_11times + tmp_45;
  
#line 11808 
  tmp_46 = get_stat64(& hw_stats->tx_collide_12times);
  
#line 11808 
  estats->tx_collide_12times = old_estats->tx_collide_12times + tmp_46;
  
#line 11809 
  tmp_47 = get_stat64(& hw_stats->tx_collide_13times);
  
#line 11809 
  estats->tx_collide_13times = old_estats->tx_collide_13times + tmp_47;
  
#line 11810 
  tmp_48 = get_stat64(& hw_stats->tx_collide_14times);
  
#line 11810 
  estats->tx_collide_14times = old_estats->tx_collide_14times + tmp_48;
  
#line 11811 
  tmp_49 = get_stat64(& hw_stats->tx_collide_15times);
  
#line 11811 
  estats->tx_collide_15times = old_estats->tx_collide_15times + tmp_49;
  
#line 11812 
  tmp_50 = get_stat64(& hw_stats->tx_ucast_packets);
  
#line 11812 
  estats->tx_ucast_packets = old_estats->tx_ucast_packets + tmp_50;
  
#line 11813 
  tmp_51 = get_stat64(& hw_stats->tx_mcast_packets);
  
#line 11813 
  estats->tx_mcast_packets = old_estats->tx_mcast_packets + tmp_51;
  
#line 11814 
  tmp_52 = get_stat64(& hw_stats->tx_bcast_packets);
  
#line 11814 
  estats->tx_bcast_packets = old_estats->tx_bcast_packets + tmp_52;
  
#line 11815 
  tmp_53 = get_stat64(& hw_stats->tx_carrier_sense_errors);
  
#line 11815 
  estats->tx_carrier_sense_errors = old_estats->tx_carrier_sense_errors + tmp_53;
  
#line 11816 
  tmp_54 = get_stat64(& hw_stats->tx_discards);
  
#line 11816 
  estats->tx_discards = old_estats->tx_discards + tmp_54;
  
#line 11817 
  tmp_55 = get_stat64(& hw_stats->tx_errors);
  
#line 11817 
  estats->tx_errors = old_estats->tx_errors + tmp_55;
  
#line 11819 
  tmp_56 = get_stat64(& hw_stats->dma_writeq_full);
  
#line 11819 
  estats->dma_writeq_full = old_estats->dma_writeq_full + tmp_56;
  
#line 11820 
  tmp_57 = get_stat64(& hw_stats->dma_write_prioq_full);
  
#line 11820 
  estats->dma_write_prioq_full = old_estats->dma_write_prioq_full + tmp_57;
  
#line 11821 
  tmp_58 = get_stat64(& hw_stats->rxbds_empty);
  
#line 11821 
  estats->rxbds_empty = old_estats->rxbds_empty + tmp_58;
  
#line 11822 
  tmp_59 = get_stat64(& hw_stats->rx_discards);
  
#line 11822 
  estats->rx_discards = old_estats->rx_discards + tmp_59;
  
#line 11823 
  tmp_60 = get_stat64(& hw_stats->rx_errors);
  
#line 11823 
  estats->rx_errors = old_estats->rx_errors + tmp_60;
  
#line 11824 
  tmp_61 = get_stat64(& hw_stats->rx_threshold_hit);
  
#line 11824 
  estats->rx_threshold_hit = old_estats->rx_threshold_hit + tmp_61;
  
#line 11826 
  tmp_62 = get_stat64(& hw_stats->dma_readq_full);
  
#line 11826 
  estats->dma_readq_full = old_estats->dma_readq_full + tmp_62;
  
#line 11827 
  tmp_63 = get_stat64(& hw_stats->dma_read_prioq_full);
  
#line 11827 
  estats->dma_read_prioq_full = old_estats->dma_read_prioq_full + tmp_63;
  
#line 11828 
  tmp_64 = get_stat64(& hw_stats->tx_comp_queue_full);
  
#line 11828 
  estats->tx_comp_queue_full = old_estats->tx_comp_queue_full + tmp_64;
  
#line 11830 
  tmp_65 = get_stat64(& hw_stats->ring_set_send_prod_index);
  
#line 11830 
  estats->ring_set_send_prod_index = old_estats->ring_set_send_prod_index + tmp_65;
  
#line 11831 
  tmp_66 = get_stat64(& hw_stats->ring_status_update);
  
#line 11831 
  estats->ring_status_update = old_estats->ring_status_update + tmp_66;
  
#line 11832 
  tmp_67 = get_stat64(& hw_stats->nic_irqs);
  
#line 11832 
  estats->nic_irqs = old_estats->nic_irqs + tmp_67;
  
#line 11833 
  tmp_68 = get_stat64(& hw_stats->nic_avoided_irqs);
  
#line 11833 
  estats->nic_avoided_irqs = old_estats->nic_avoided_irqs + tmp_68;
  
#line 11834 
  tmp_69 = get_stat64(& hw_stats->nic_tx_threshold_hit);
  
#line 11834 
  estats->nic_tx_threshold_hit = old_estats->nic_tx_threshold_hit + tmp_69;
  
#line 11836 
  tmp_70 = get_stat64(& hw_stats->mbuf_lwm_thresh_hit);
  
#line 11836 
  estats->mbuf_lwm_thresh_hit = old_estats->mbuf_lwm_thresh_hit + tmp_70;
  
#line 11837 
  return;
}


#line 11839  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_nstats(struct tg3 *tp, struct rtnl_link_stats64 *stats)
{
  u64 tmp;
  u64 tmp_0;
  u64 tmp_1;
  u64 tmp_2;
  u64 tmp_3;
  u64 tmp_4;
  u64 tmp_5;
  u64 tmp_6;
  u64 tmp_7;
  u64 tmp_8;
  u64 tmp_9;
  u64 tmp_10;
  u64 tmp_11;
  u64 tmp_12;
  u64 tmp_13;
  u64 tmp_14;
  u64 tmp_15;
  u64 tmp_16;
  u64 tmp_17;
  u64 tmp_18;
  u64 tmp_19;
  u64 tmp_20;
  
#line 11841 
  struct rtnl_link_stats64 *old_stats = & tp->net_stats_prev;
  
#line 11842 
  struct tg3_hw_stats *hw_stats = tp->hw_stats;
  
#line 11845 
  tmp = get_stat64(& hw_stats->rx_ucast_packets);
  
#line 11846 
  tmp_0 = get_stat64(& hw_stats->rx_mcast_packets);
  
#line 11847 
  tmp_1 = get_stat64(& hw_stats->rx_bcast_packets);
  
#line 11844 
  stats->rx_packets = ((old_stats->rx_packets + tmp) + tmp_0) + tmp_1;
  
#line 11850 
  tmp_2 = get_stat64(& hw_stats->tx_ucast_packets);
  
#line 11851 
  tmp_3 = get_stat64(& hw_stats->tx_mcast_packets);
  
#line 11852 
  tmp_4 = get_stat64(& hw_stats->tx_bcast_packets);
  
#line 11849 
  stats->tx_packets = ((old_stats->tx_packets + tmp_2) + tmp_3) + tmp_4;
  
#line 11855 
  tmp_5 = get_stat64(& hw_stats->rx_octets);
  
#line 11854 
  stats->rx_bytes = old_stats->rx_bytes + tmp_5;
  
#line 11857 
  tmp_6 = get_stat64(& hw_stats->tx_octets);
  
#line 11856 
  stats->tx_bytes = old_stats->tx_bytes + tmp_6;
  
#line 11860 
  tmp_7 = get_stat64(& hw_stats->rx_errors);
  
#line 11859 
  stats->rx_errors = old_stats->rx_errors + tmp_7;
  
#line 11862 
  tmp_8 = get_stat64(& hw_stats->tx_errors);
  
#line 11863 
  tmp_9 = get_stat64(& hw_stats->tx_mac_errors);
  
#line 11864 
  tmp_10 = get_stat64(& hw_stats->tx_carrier_sense_errors);
  
#line 11865 
  tmp_11 = get_stat64(& hw_stats->tx_discards);
  
#line 11861 
  stats->tx_errors = (((old_stats->tx_errors + tmp_8) + tmp_9) + tmp_10) + tmp_11;
  
#line 11868 
  tmp_12 = get_stat64(& hw_stats->rx_mcast_packets);
  
#line 11867 
  stats->multicast = old_stats->multicast + tmp_12;
  
#line 11870 
  tmp_13 = get_stat64(& hw_stats->tx_collisions);
  
#line 11869 
  stats->collisions = old_stats->collisions + tmp_13;
  
#line 11873 
  tmp_14 = get_stat64(& hw_stats->rx_frame_too_long_errors);
  
#line 11874 
  tmp_15 = get_stat64(& hw_stats->rx_undersize_packets);
  
#line 11872 
  stats->rx_length_errors = (old_stats->rx_length_errors + tmp_14) + tmp_15;
  
#line 11877 
  tmp_16 = get_stat64(& hw_stats->rx_align_errors);
  
#line 11876 
  stats->rx_frame_errors = old_stats->rx_frame_errors + tmp_16;
  
#line 11879 
  tmp_17 = get_stat64(& hw_stats->tx_discards);
  
#line 11878 
  stats->tx_aborted_errors = old_stats->tx_aborted_errors + tmp_17;
  
#line 11881 
  tmp_18 = get_stat64(& hw_stats->tx_carrier_sense_errors);
  
#line 11880 
  stats->tx_carrier_errors = old_stats->tx_carrier_errors + tmp_18;
  
#line 11884 
  tmp_19 = tg3_calc_crc_errors(tp);
  
#line 11883 
  stats->rx_crc_errors = old_stats->rx_crc_errors + tmp_19;
  
#line 11887 
  tmp_20 = get_stat64(& hw_stats->rx_discards);
  
#line 11886 
  stats->rx_missed_errors = old_stats->rx_missed_errors + tmp_20;
  
#line 11889 
  stats->rx_dropped = (unsigned long long)tp->rx_dropped;
  
#line 11890 
  stats->tx_dropped = (unsigned long long)tp->tx_dropped;
  
#line 11891 
  return;
}


#line 11893  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_regs_len(struct net_device *dev)
{
  int __retres;
  
#line 11895 
  __retres = 32768;
  
#line 11895 
  return __retres;
}


#line 11898  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *_p)
{
  
#line 11901 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 11903 
  regs->version = 0U;
  
#line 11905 
  memset(_p,0,32768UL);
  
#line 11907 
  if ((tp->phy_flags & 1U) != 0U) 
#line 11908 
                                  goto return_label; else ;
  
#line 11910 
  tg3_full_lock(tp,0);
  
#line 11912 
  tg3_dump_legacy_regs(tp,(u32 *)_p);
  
#line 11914 
  tg3_full_unlock(tp);
  return_label: 
#line 11915 
                return;
}


#line 11917  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_eeprom_len(struct net_device *dev)
{
  int __retres;
  
#line 11919 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 11921 
  __retres = (int)tp->nvram_size;
  
#line 11921 
  return __retres;
}


#line 11924  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)
{
  int __retres;
  int ret;
  u8 *pd;
  u32 i;
  u32 offset;
  u32 len;
  u32 b_offset;
  u32 b_count;
  __be32 val;
  int tmp_0;
  int tmp_1;
  bool tmp_4;
  
#line 11926 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 11927 
  int cpmu_restore = 0;
  
#line 11929 
  u32 cpmu_val = 0U;
  
#line 11932 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 11932 
  if (tmp_0 != 0) {
    
#line 11933 
    __retres = -22;
    
#line 11933 
    goto return_label;
  }
  else ;
  
#line 11935 
  offset = eeprom->offset;
  
#line 11936 
  len = eeprom->len;
  
#line 11937 
  eeprom->len = 0U;
  
#line 11939 
  eeprom->magic = 1721324970U;
  
#line 11942 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
  
#line 11942 
  if (tmp_1 != 0) {
    
#line 11943 
    cpmu_val = (*(tp->read32))(tp,13824U);
    
#line 11944 
    if ((cpmu_val & 1536U) != 0U) {
      
#line 11946 
      (*(tp->write32))(tp,13824U,cpmu_val & 4294965759U);
      
#line 11949 
      cpmu_restore = 1;
    }
    else ;
  }
  else ;
  
#line 11952 
  tg3_override_clk(tp);
  
#line 11954 
  if ((offset & 3U) != 0U) {
    
#line 11956 
    b_offset = offset & 3U;
    
#line 11957 
    b_count = 4U - b_offset;
    
#line 11958 
    if (b_count > len) 
#line 11960 
                       b_count = len; else ;
    
#line 11962 
    ret = tg3_nvram_read_be32(tp,offset - b_offset,& val);
    
#line 11963 
    if (ret != 0) 
#line 11964 
                  goto eeprom_done; else ;
    
#line 11965 
    memcpy((void *)data,(void const *)(& val) + b_offset,(unsigned long)b_count);
    
#line 11966 
    len -= b_count;
    
#line 11967 
    offset += b_count;
    
#line 11968 
    eeprom->len += b_count;
  }
  else ;
  
#line 11972 
  pd = data + eeprom->len;
  
#line 11973 
  i = 0U;
  
#line 11973 
  goto ldv_58526;
  ldv_58525: 
#line 11974 
  ;
  
#line 11974 
  ret = tg3_nvram_read_be32(tp,offset + i,& val);
  
#line 11975 
  if (ret != 0) {
    
#line 11976 
    if (i != 0U) 
#line 11977 
                 i += 4294967292U; else ;
    
#line 11978 
    eeprom->len += i;
    
#line 11979 
    goto eeprom_done;
  }
  else ;
  
#line 11981 
  memcpy((void *)(pd + i),(void const *)(& val),4UL);
  
#line 11982 
  tmp_4 = need_resched();
  
#line 11982 
  if ((int)tmp_4 != 0) {
    int tmp_3;
    struct task_struct *tmp_2;
    
#line 11983 
    tmp_2 = get_current();
    
#line 11983 
    tmp_3 = signal_pending(tmp_2);
    
#line 11983 
    if (tmp_3 != 0) {
      
#line 11984 
      eeprom->len += i;
      
#line 11985 
      ret = -4;
      
#line 11986 
      goto eeprom_done;
    }
    else ;
    
#line 11988 
    ___might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c",11988,0);
    
#line 11988 
    _cond_resched();
  }
  else ;
  
#line 11973 
  i += 4U;
  ldv_58526: 
#line 11974 
  ;
  
#line 11973 
  if ((len & 4294967292U) > i) 
#line 11975 
                               goto ldv_58525; else 
#line 11978 
                                                    goto ldv_58527;
  ldv_58527: 
#line 11979 
  ;
  
#line 11991 
  eeprom->len += i;
  
#line 11993 
  if ((len & 3U) != 0U) {
    
#line 11995 
    pd = data + eeprom->len;
    
#line 11996 
    b_count = len & 3U;
    
#line 11997 
    b_offset = (offset + len) - b_count;
    
#line 11998 
    ret = tg3_nvram_read_be32(tp,b_offset,& val);
    
#line 11999 
    if (ret != 0) 
#line 12000 
                  goto eeprom_done; else ;
    
#line 12001 
    memcpy((void *)pd,(void const *)(& val),(unsigned long)b_count);
    
#line 12002 
    eeprom->len += b_count;
  }
  else ;
  
#line 12004 
  ret = 0;
  eeprom_done: 
#line 12006 
  ;
  
#line 12008 
  tg3_restore_clk(tp);
  
#line 12009 
  if (cpmu_restore != 0) 
#line 12010 
                         (*(tp->write32))(tp,13824U,cpmu_val); else ;
  
#line 12012 
  __retres = ret;
  return_label: 
#line 12012 
                return __retres;
}


#line 12015  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)
{
  int __retres;
  int ret;
  u32 offset;
  u32 len;
  u32 b_offset;
  u32 odd_len;
  u8 *buf;
  __be32 start;
  __be32 end;
  int tmp_0;
  
#line 12017 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12023 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 12023 
  if (tmp_0 != 0) {
    
#line 12025 
    __retres = -22;
    
#line 12025 
    goto return_label;
  }
  else 
    
#line 12023 
    if (eeprom->magic != 1721324970U) {
      
#line 12025 
      __retres = -22;
      
#line 12025 
      goto return_label;
    }
    else ;
  
#line 12027 
  offset = eeprom->offset;
  
#line 12028 
  len = eeprom->len;
  
#line 12030 
  b_offset = offset & 3U;
  
#line 12030 
  if (b_offset != 0U) {
    
#line 12032 
    ret = tg3_nvram_read_be32(tp,offset - b_offset,& start);
    
#line 12033 
    if (ret != 0) {
      
#line 12034 
      __retres = ret;
      
#line 12034 
      goto return_label;
    }
    else ;
    
#line 12035 
    len += b_offset;
    
#line 12036 
    offset &= 4294967292U;
    
#line 12037 
    if (len <= 3U) 
#line 12038 
                   len = 4U; else ;
  }
  else ;
  
#line 12041 
  odd_len = 0U;
  
#line 12042 
  if ((len & 3U) != 0U) {
    
#line 12044 
    odd_len = 1U;
    
#line 12045 
    len = (len + 3U) & 4294967292U;
    
#line 12046 
    ret = tg3_nvram_read_be32(tp,(offset + len) + 4294967292U,& end);
    
#line 12047 
    if (ret != 0) {
      
#line 12048 
      __retres = ret;
      
#line 12048 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 12051 
  buf = data;
  
#line 12052 
  if (b_offset != 0U || odd_len != 0U) {
    
#line 12053 
    buf = (u8 *)kmalloc((unsigned long)len,208U);
    
#line 12054 
    if (buf == (u8 *)0U) {
      
#line 12055 
      __retres = -12;
      
#line 12055 
      goto return_label;
    }
    else ;
    
#line 12056 
    if (b_offset != 0U) 
#line 12057 
                        memcpy((void *)buf,(void const *)(& start),4UL); else ;
    
#line 12058 
    if (odd_len != 0U) 
#line 12059 
                       memcpy((void *)(buf + ((unsigned long)len + 18446744073709551612U)),(void const *)(& end),4UL); else ;
    
#line 12060 
    memcpy((void *)(buf + b_offset),(void const *)data,(unsigned long)eeprom->len);
  }
  else ;
  
#line 12063 
  ret = tg3_nvram_write_block(tp,offset,len,buf);
  
#line 12065 
  if (buf != data) 
#line 12066 
                   kfree((void const *)buf); else ;
  
#line 12068 
  __retres = ret;
  return_label: 
#line 12068 
                return __retres;
}


#line 12071  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
{
  int __retres;
  int tmp_1;
  int tmp_2;
  bool tmp_3;
  
#line 12073 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12075 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 12075 
  if (tmp_1 != 0) {
    struct phy_device *phydev;
    int tmp_0;
    
#line 12077 
    if ((tp->phy_flags & 2U) == 0U) {
      
#line 12078 
      __retres = -11;
      
#line 12078 
      goto return_label;
    }
    else ;
    
#line 12079 
    phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
    
#line 12080 
    tmp_0 = phy_ethtool_gset(phydev,cmd);
    
#line 12080 
    __retres = tmp_0;
    
#line 12080 
    goto return_label;
  }
  else ;
  
#line 12083 
  cmd->supported = 64U;
  
#line 12085 
  if ((tp->phy_flags & 128U) == 0U) 
#line 12086 
                                    cmd->supported |= 48U; else ;
  
#line 12089 
  if ((tp->phy_flags & 48U) == 0U) {
    
#line 12090 
    cmd->supported |= 143U;
    
#line 12095 
    cmd->port = (unsigned char)0U;
  }
  else {
    
#line 12097 
    cmd->supported |= 1024U;
    
#line 12098 
    cmd->port = (unsigned char)3U;
  }
  
#line 12101 
  cmd->advertising = tp->link_config.advertising;
  
#line 12102 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags));
  
#line 12102 
  if (tmp_2 != 0) {
    
#line 12103 
    if (((int)tp->link_config.flowctrl & 2) != 0) 
      
#line 12104 
      if (((int)tp->link_config.flowctrl & 1) != 0) 
#line 12105 
                                                    cmd->advertising |= 8192U; else 
                                                                    
#line 12107 
                                                                    cmd->advertising |= 24576U;
    else 
      
#line 12110 
      if (((int)tp->link_config.flowctrl & 1) != 0) 
#line 12111 
                                                    cmd->advertising |= 16384U; else ;
  }
  else ;
  
#line 12114 
  tmp_3 = netif_running((struct net_device const *)dev);
  
#line 12114 
  if ((int)tmp_3 != 0) {
    
#line 12114 
    if ((int)tp->link_up != 0) {
      
#line 12115 
      ethtool_cmd_speed_set(cmd,(unsigned int)tp->link_config.active_speed);
      
#line 12116 
      cmd->duplex = tp->link_config.active_duplex;
      
#line 12117 
      cmd->lp_advertising = tp->link_config.rmt_adv;
      
#line 12118 
      if ((tp->phy_flags & 48U) == 0U) 
        
#line 12119 
        if ((tp->phy_flags & 2097152U) != 0U) 
#line 12120 
                                              cmd->eth_tp_mdix = (unsigned char)2U; else 
                                                                    
#line 12122 
                                                                    cmd->eth_tp_mdix = (unsigned char)1U;
      else ;
    }
    else 
#line 12114 
         goto _LAND;
  }
  else {
    _LAND: {
             
#line 12125 
             ethtool_cmd_speed_set(cmd,4294967295U);
             
#line 12126 
             cmd->duplex = (unsigned char)255U;
             
#line 12127 
             cmd->eth_tp_mdix = (unsigned char)0U;
           }
  }
  
#line 12129 
  cmd->phy_address = tp->phy_addr;
  
#line 12130 
  cmd->transceiver = (unsigned char)0U;
  
#line 12131 
  cmd->autoneg = tp->link_config.autoneg;
  
#line 12132 
  cmd->maxtxpkt = 0U;
  
#line 12133 
  cmd->maxrxpkt = 0U;
  
#line 12134 
  __retres = 0;
  return_label: 
#line 12134 
                return __retres;
}


#line 12137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
{
  int __retres;
  int tmp_2;
  bool tmp_3;
  
#line 12139 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12140 
  u32 speed = ethtool_cmd_speed((struct ethtool_cmd const *)cmd);
  
#line 12142 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 12142 
  if (tmp_2 != 0) {
    struct phy_device *phydev;
    int tmp_1;
    
#line 12144 
    if ((tp->phy_flags & 2U) == 0U) {
      
#line 12145 
      __retres = -11;
      
#line 12145 
      goto return_label;
    }
    else ;
    
#line 12146 
    phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
    
#line 12147 
    tmp_1 = phy_ethtool_sset(phydev,cmd);
    
#line 12147 
    __retres = tmp_1;
    
#line 12147 
    goto return_label;
  }
  else ;
  
#line 12150 
  if ((unsigned int)cmd->autoneg > 1U) {
    
#line 12152 
    __retres = -22;
    
#line 12152 
    goto return_label;
  }
  else ;
  
#line 12154 
  if (((unsigned int)cmd->autoneg == 0U && (unsigned int)cmd->duplex != 1U) && (unsigned int)cmd->duplex != 0U) {
    
#line 12157 
    __retres = -22;
    
#line 12157 
    goto return_label;
  }
  else ;
  
#line 12159 
  if ((unsigned int)cmd->autoneg == 1U) {
    
#line 12160 
    u32 mask = 24640U;
    
#line 12164 
    if ((tp->phy_flags & 128U) == 0U) 
#line 12165 
                                      mask |= 48U; else ;
    
#line 12168 
    if ((tp->phy_flags & 48U) == 0U) 
#line 12169 
                                     mask |= 143U; else 
#line 12175 
                                                        mask |= 1024U;
    
#line 12177 
    if ((cmd->advertising & ~ mask) != 0U) {
      
#line 12178 
      __retres = -22;
      
#line 12178 
      goto return_label;
    }
    else ;
    
#line 12180 
    mask &= 63U;
    
#line 12187 
    cmd->advertising &= mask;
  }
  else 
    
#line 12189 
    if ((tp->phy_flags & 48U) != 0U) {
      
#line 12190 
      if (speed != 1000U) {
        
#line 12191 
        __retres = -22;
        
#line 12191 
        goto return_label;
      }
      else ;
      
#line 12193 
      if ((unsigned int)cmd->duplex != 1U) {
        
#line 12194 
        __retres = -22;
        
#line 12194 
        goto return_label;
      }
      else ;
    }
    else 
      
#line 12196 
      if (speed != 100U && speed != 10U) {
        
#line 12198 
        __retres = -22;
        
#line 12198 
        goto return_label;
      }
      else ;
  
#line 12202 
  tg3_full_lock(tp,0);
  
#line 12204 
  tp->link_config.autoneg = cmd->autoneg;
  
#line 12205 
  if ((unsigned int)cmd->autoneg == 1U) {
    
#line 12206 
    tp->link_config.advertising = cmd->advertising | 64U;
    
#line 12208 
    tp->link_config.speed = (unsigned short)65535U;
    
#line 12209 
    tp->link_config.duplex = (unsigned char)255U;
  }
  else {
    
#line 12211 
    tp->link_config.advertising = 0U;
    
#line 12212 
    tp->link_config.speed = (unsigned short)speed;
    
#line 12213 
    tp->link_config.duplex = cmd->duplex;
  }
  
#line 12216 
  tp->phy_flags |= 8U;
  
#line 12218 
  tg3_warn_mgmt_link_flap(tp);
  
#line 12220 
  tmp_3 = netif_running((struct net_device const *)dev);
  
#line 12220 
  if ((int)tmp_3 != 0) 
#line 12221 
                       tg3_setup_phy(tp,(_Bool)1); else ;
  
#line 12223 
  tg3_full_unlock(tp);
  
#line 12225 
  __retres = 0;
  return_label: 
#line 12225 
                return __retres;
}


#line 12228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
  char const *tmp_0;
  
#line 12230 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12232 
  strlcpy((char *)(& info->driver),"tg3",32UL);
  
#line 12233 
  strlcpy((char *)(& info->version),"3",32UL);
  
#line 12234 
  strlcpy((char *)(& info->fw_version),(char const *)(& tp->fw_ver),32UL);
  
#line 12235 
  tmp_0 = pci_name((struct pci_dev const *)tp->pdev);
  
#line 12235 
  ;
  
#line 12235 
  strlcpy((char *)(& info->bus_info),tmp_0,32UL);
  
#line 12236 
  return;
}


#line 12238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
{
  int tmp_0;
  int tmp_2;
  
#line 12240 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12242 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 12242 
  if (tmp_0 != 0) {
    bool tmp_1;
    
#line 12242 
    tmp_1 = device_can_wakeup(& (tp->pdev)->dev);
    
#line 12242 
    if ((int)tmp_1 != 0) 
#line 12243 
                         wol->supported = 32U; else 
#line 12245 
                                                    wol->supported = 0U;
  }
  else 
#line 12245 
       wol->supported = 0U;
  
#line 12246 
  wol->wolopts = 0U;
  
#line 12247 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 12247 
  if (tmp_2 != 0) {
    bool tmp_3;
    
#line 12247 
    tmp_3 = device_can_wakeup(& (tp->pdev)->dev);
    
#line 12247 
    if ((int)tmp_3 != 0) 
#line 12248 
                         wol->wolopts = 32U; else ;
  }
  else ;
  
#line 12249 
  memset((void *)(& wol->sopass),0,6UL);
  
#line 12250 
  return;
}


#line 12252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
{
  int __retres;
  bool tmp_3;
  
#line 12254 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12255 
  struct device *dp = & (tp->pdev)->dev;
  
#line 12257 
  if ((wol->wolopts & 4294967263U) != 0U) {
    
#line 12258 
    __retres = -22;
    
#line 12258 
    goto return_label;
  }
  else ;
  
#line 12259 
  if ((wol->wolopts & 32U) != 0U) {
    int tmp_0;
    
#line 12259 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_CAP,(unsigned long *)(& tp->tg3_flags));
    
#line 12259 
    if (tmp_0 == 0) {
      
#line 12261 
      __retres = -22;
      
#line 12261 
      goto return_label;
    }
    else {
      int tmp_2;
      bool tmp_1;
      
#line 12260 
      tmp_1 = device_can_wakeup(dp);
      
#line 12260 
      if (tmp_1) 
#line 12260 
                 tmp_2 = 0; else 
#line 12260 
                                 tmp_2 = 1;
      
#line 12260 
      if (tmp_2) {
        
#line 12261 
        __retres = -22;
        
#line 12261 
        goto return_label;
      }
      else ;
    }
  }
  else ;
  
#line 12263 
  device_set_wakeup_enable(dp,(_Bool)((wol->wolopts & 32U) != 0U));
  
#line 12265 
  tmp_3 = device_may_wakeup(dp);
  
#line 12265 
  if ((int)tmp_3 != 0) 
#line 12266 
                       _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags)); else 
                                                                    
#line 12268 
                                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 12270 
  __retres = 0;
  return_label: 
#line 12270 
                return __retres;
}


#line 12273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_get_msglevel(struct net_device *dev)
{
  u32 __retres;
  
#line 12275 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12276 
  __retres = tp->msg_enable;
  
#line 12276 
  return __retres;
}


#line 12279  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_set_msglevel(struct net_device *dev, u32 value)
{
  
#line 12281 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12282 
  tp->msg_enable = value;
  
#line 12283 
  return;
}


#line 12285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_nway_reset(struct net_device *dev)
{
  int __retres;
  int r;
  int tmp_1;
  bool tmp_0;
  int tmp_3;
  
#line 12287 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12290 
  tmp_0 = netif_running((struct net_device const *)dev);
  
#line 12290 
  if (tmp_0) 
#line 12290 
             tmp_1 = 0; else 
#line 12290 
                             tmp_1 = 1;
  
#line 12290 
  if (tmp_1) {
    
#line 12291 
    __retres = -11;
    
#line 12291 
    goto return_label;
  }
  else ;
  
#line 12293 
  if ((tp->phy_flags & 16U) != 0U) {
    
#line 12294 
    __retres = -22;
    
#line 12294 
    goto return_label;
  }
  else ;
  
#line 12296 
  tg3_warn_mgmt_link_flap(tp);
  
#line 12298 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 12298 
  if (tmp_3 != 0) {
    
#line 12299 
    if ((tp->phy_flags & 2U) == 0U) {
      
#line 12300 
      __retres = -11;
      
#line 12300 
      goto return_label;
    }
    else ;
    
#line 12301 
    r = phy_start_aneg((tp->mdio_bus)->phy_map[(int)tp->phy_addr]);
  }
  else {
    u32 bmcr;
    int tmp_2;
    
#line 12305 
    ldv_spin_lock_bh_121(& tp->lock);
    
#line 12306 
    r = -22;
    
#line 12307 
    tg3_readphy(tp,0,& bmcr);
    
#line 12308 
    tmp_2 = tg3_readphy(tp,0,& bmcr);
    
#line 12308 
    if (tmp_2 == 0) {
      
#line 12308 
      if ((bmcr & 4096U) != 0U || (tp->phy_flags & 131072U) != 0U) {
        
#line 12311 
        tg3_writephy(tp,0,bmcr | 4608U);
        
#line 12313 
        r = 0;
      }
      else ;
    }
    else ;
    
#line 12315 
    ldv_spin_unlock_bh_122(& tp->lock);
  }
  
#line 12318 
  __retres = r;
  return_label: 
#line 12318 
                return __retres;
}


#line 12321  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)
{
  int tmp_0;
  int tmp_1;
  
#line 12323 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12325 
  ering->rx_max_pending = tp->rx_std_ring_mask;
  
#line 12326 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 12326 
  if (tmp_0 != 0) 
#line 12327 
                  ering->rx_jumbo_max_pending = tp->rx_jmb_ring_mask; else 
                                                                    
#line 12329 
                                                                    ering->rx_jumbo_max_pending = 0U;
  
#line 12331 
  ering->tx_max_pending = 511U;
  
#line 12333 
  ering->rx_pending = tp->rx_pending;
  
#line 12334 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 12334 
  if (tmp_1 != 0) 
#line 12335 
                  ering->rx_jumbo_pending = tp->rx_jumbo_pending; else 
                                                                    
#line 12337 
                                                                    ering->rx_jumbo_pending = 0U;
  
#line 12339 
  ering->tx_pending = tp->napi[0].tx_pending;
  
#line 12340 
  return;
}


#line 12342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)
{
  int __retres;
  int i;
  bool tmp_1;
  int tmp_2;
  int tmp_3;
  bool tmp_4;
  
#line 12344 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12345 
  int irq_sync = 0;
  
#line 12345 
  int err = 0;
  
#line 12347 
  if (((ering->rx_pending > tp->rx_std_ring_mask || ering->rx_jumbo_pending > tp->rx_jmb_ring_mask) || ering->tx_pending > 511U) || ering->tx_pending <= 17U) {
    
#line 12353 
    __retres = -22;
    
#line 12353 
    goto return_label;
  }
  else {
    int tmp_0;
    
#line 12350 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_BUG,(unsigned long *)(& tp->tg3_flags));
    
#line 12350 
    if (tmp_0 != 0) {
      
#line 12351 
      if (ering->tx_pending <= 51U) {
        
#line 12353 
        __retres = -22;
        
#line 12353 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  
#line 12355 
  tmp_1 = netif_running((struct net_device const *)dev);
  
#line 12355 
  if ((int)tmp_1 != 0) {
    
#line 12356 
    tg3_phy_stop(tp);
    
#line 12357 
    tg3_netif_stop(tp);
    
#line 12358 
    irq_sync = 1;
  }
  else ;
  
#line 12361 
  tg3_full_lock(tp,irq_sync);
  
#line 12363 
  tp->rx_pending = ering->rx_pending;
  
#line 12365 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MAX_RXPEND_64,(unsigned long *)(& tp->tg3_flags));
  
#line 12365 
  if (tmp_2 != 0) {
    
#line 12365 
    if (tp->rx_pending > 63U) 
#line 12367 
                              tp->rx_pending = 63U; else ;
  }
  else ;
  
#line 12369 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 12369 
  if (tmp_3 != 0) 
#line 12370 
                  tp->rx_jumbo_pending = ering->rx_jumbo_pending; else ;
  
#line 12372 
  i = 0;
  
#line 12372 
  goto ldv_58601;
  ldv_58600: 
#line 12373 
  ;
  
#line 12373 
  tp->napi[i].tx_pending = ering->tx_pending;
  
#line 12372 
  i += 1;
  ldv_58601: 
#line 12373 
  ;
  
#line 12372 
  if (tp->irq_max > (unsigned int)i) 
#line 12374 
                                     goto ldv_58600; else 
#line 12377 
                                                          goto ldv_58602;
  ldv_58602: 
#line 12378 
  ;
  
#line 12375 
  tmp_4 = netif_running((struct net_device const *)dev);
  
#line 12375 
  if ((int)tmp_4 != 0) {
    
#line 12376 
    tg3_halt(tp,0,(_Bool)1);
    
#line 12377 
    err = tg3_restart_hw(tp,(_Bool)0);
    
#line 12378 
    if (err == 0) 
#line 12379 
                  tg3_netif_start(tp); else ;
  }
  else ;
  
#line 12382 
  tg3_full_unlock(tp);
  
#line 12384 
  if (irq_sync != 0 && err == 0) 
#line 12385 
                                 tg3_phy_start(tp); else ;
  
#line 12387 
  __retres = err;
  return_label: 
#line 12387 
                return __retres;
}


#line 12390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)
{
  int tmp_0;
  
#line 12392 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12394 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags));
  
#line 12394 
  epause->autoneg = (unsigned int)(tmp_0 != 0);
  
#line 12396 
  if (((int)tp->link_config.flowctrl & 2) != 0) 
#line 12397 
                                                epause->rx_pause = 1U; else 
                                                                    
#line 12399 
                                                                    epause->rx_pause = 0U;
  
#line 12401 
  if (((int)tp->link_config.flowctrl & 1) != 0) 
#line 12402 
                                                epause->tx_pause = 1U; else 
                                                                    
#line 12404 
                                                                    epause->tx_pause = 0U;
  
#line 12405 
  return;
}


#line 12407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)
{
  int __retres;
  int tmp_3;
  
#line 12409 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12410 
  int err = 0;
  
#line 12412 
  if ((unsigned int)tp->link_config.autoneg == 1U) 
#line 12413 
                                                   tg3_warn_mgmt_link_flap(tp); else ;
  
#line 12415 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 12415 
  if (tmp_3 != 0) {
    u32 newadv;
    struct phy_device *phydev;
    
#line 12419 
    phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
    
#line 12421 
    if ((phydev->supported & 8192U) == 0U || ((phydev->supported & 16384U) == 0U && epause->rx_pause != epause->tx_pause)) {
      
#line 12424 
      __retres = -22;
      
#line 12424 
      goto return_label;
    }
    else ;
    
#line 12426 
    tp->link_config.flowctrl = (unsigned char)0U;
    
#line 12427 
    if (epause->rx_pause != 0U) {
      
#line 12428 
      tp->link_config.flowctrl = (unsigned char)((unsigned int)tp->link_config.flowctrl | 2U);
      
#line 12430 
      if (epause->tx_pause != 0U) {
        
#line 12431 
        tp->link_config.flowctrl = (unsigned char)((unsigned int)tp->link_config.flowctrl | 1U);
        
#line 12432 
        newadv = 8192U;
      }
      else 
#line 12434 
           newadv = 24576U;
    }
    else 
      
#line 12436 
      if (epause->tx_pause != 0U) {
        
#line 12437 
        tp->link_config.flowctrl = (unsigned char)((unsigned int)tp->link_config.flowctrl | 1U);
        
#line 12438 
        newadv = 16384U;
      }
      else 
#line 12440 
           newadv = 0U;
    
#line 12442 
    if (epause->autoneg != 0U) 
#line 12443 
                               _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags)); else 
                                                                    
#line 12445 
                                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags));
    
#line 12447 
    if ((tp->phy_flags & 2U) != 0U) {
      
#line 12448 
      u32 oldadv = phydev->advertising & 24576U;
      
#line 12450 
      if (oldadv != newadv) {
        
#line 12451 
        phydev->advertising &= 4294942719U;
        
#line 12454 
        phydev->advertising |= newadv;
        
#line 12455 
        if (phydev->autoneg != 0) {
          int tmp_0;
          
#line 12464 
          tmp_0 = phy_start_aneg(phydev);
          
#line 12464 
          __retres = tmp_0;
          
#line 12464 
          goto return_label;
        }
        else ;
      }
      else ;
      
#line 12468 
      if (epause->autoneg == 0U) 
#line 12469 
                                 tg3_setup_flow_control(tp,0U,0U); else ;
    }
    else {
      
#line 12471 
      tp->link_config.advertising &= 4294942719U;
      
#line 12474 
      tp->link_config.advertising |= newadv;
    }
  }
  else {
    bool tmp_1;
    bool tmp_2;
    
#line 12477 
    int irq_sync = 0;
    
#line 12479 
    tmp_1 = netif_running((struct net_device const *)dev);
    
#line 12479 
    if ((int)tmp_1 != 0) {
      
#line 12480 
      tg3_netif_stop(tp);
      
#line 12481 
      irq_sync = 1;
    }
    else ;
    
#line 12484 
    tg3_full_lock(tp,irq_sync);
    
#line 12486 
    if (epause->autoneg != 0U) 
#line 12487 
                               _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags)); else 
                                                                    
#line 12489 
                                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags));
    
#line 12490 
    if (epause->rx_pause != 0U) 
#line 12491 
                                tp->link_config.flowctrl = (unsigned char)((unsigned int)tp->link_config.flowctrl | 2U); else 
                                                                    
#line 12493 
                                                                    tp->link_config.flowctrl = (unsigned char)((unsigned int)tp->link_config.flowctrl & 253U);
    
#line 12494 
    if (epause->tx_pause != 0U) 
#line 12495 
                                tp->link_config.flowctrl = (unsigned char)((unsigned int)tp->link_config.flowctrl | 1U); else 
                                                                    
#line 12497 
                                                                    tp->link_config.flowctrl = (unsigned char)((unsigned int)tp->link_config.flowctrl & 254U);
    
#line 12499 
    tmp_2 = netif_running((struct net_device const *)dev);
    
#line 12499 
    if ((int)tmp_2 != 0) {
      
#line 12500 
      tg3_halt(tp,0,(_Bool)1);
      
#line 12501 
      err = tg3_restart_hw(tp,(_Bool)0);
      
#line 12502 
      if (err == 0) 
#line 12503 
                    tg3_netif_start(tp); else ;
    }
    else ;
    
#line 12506 
    tg3_full_unlock(tp);
  }
  
#line 12509 
  tp->phy_flags |= 8U;
  
#line 12511 
  __retres = err;
  return_label: 
#line 12511 
                return __retres;
}


#line 12514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_sset_count(struct net_device *dev, int sset)
{
  int __retres;
  
#line 12516 
  switch (sset) {
    case 0: 
#line 12517 
    ;
    
#line 12518 
    __retres = 8;
    
#line 12518 
    goto return_label;
    case 1: 
#line 12519 
    ;
    
#line 12520 
    __retres = 72;
    
#line 12520 
    goto return_label;
    default: 
#line 12521 
    ;
    
#line 12522 
    __retres = -95;
    
#line 12522 
    goto return_label;
  }
  return_label: 
#line 12516 
                return __retres;
}


#line 12526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info, u32 *rules)
{
  int __retres;
  int tmp_0;
  
#line 12529 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12531 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 12531 
  if (tmp_0 == 0) {
    
#line 12532 
    __retres = -95;
    
#line 12532 
    goto return_label;
  }
  else ;
  
#line 12534 
  switch (info->cmd) {
    bool tmp_2;
    case (__u32)45: 
#line 12535 
    ;
    
#line 12536 
    tmp_2 = netif_running((struct net_device const *)tp->dev);
    
#line 12536 
    if ((int)tmp_2 != 0) 
#line 12537 
                         info->data = (unsigned long long)tp->rxq_cnt;
    else {
      unsigned int tmp_1;
      
#line 12539 
      tmp_1 = cpumask_weight(cpu_online_mask);
      
#line 12539 
      info->data = (unsigned long long)tmp_1;
      
#line 12540 
      if (info->data > 4ULL) 
#line 12541 
                             info->data = 4ULL; else ;
    }
    
#line 12547 
    info->data += 18446744073709551615ULL;
    
#line 12548 
    __retres = 0;
    
#line 12548 
    goto return_label;
    default: 
#line 12550 
    ;
    
#line 12551 
    __retres = -95;
    
#line 12551 
    goto return_label;
  }
  return_label: 
#line 12534 
                return __retres;
}


#line 12555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_get_rxfh_indir_size(struct net_device *dev)
{
  int tmp_0;
  
#line 12557 
  u32 size = 0U;
  
#line 12558 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12560 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 12560 
  if (tmp_0 != 0) 
#line 12561 
                  size = 128U; else ;
  
#line 12563 
  return size;
}


#line 12566  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_rxfh(struct net_device *dev, u32 *indir, u8 *key, u8 *hfunc)
{
  int __retres;
  int i;
  
#line 12568 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12571 
  if (hfunc != (u8 *)0U) 
#line 12572 
                         *hfunc = (unsigned char)1U; else ;
  
#line 12573 
  if (indir == (u32 *)0U) {
    
#line 12574 
    __retres = 0;
    
#line 12574 
    goto return_label;
  }
  else ;
  
#line 12576 
  i = 0;
  
#line 12576 
  goto ldv_58653;
  ldv_58652: 
#line 12577 
  ;
  
#line 12577 
  *(indir + i) = (unsigned int)tp->rss_ind_tbl[i];
  
#line 12576 
  i += 1;
  ldv_58653: 
#line 12577 
  ;
  
#line 12576 
  if (i <= 127) 
#line 12578 
                goto ldv_58652; else 
#line 12581 
                                     goto ldv_58654;
  ldv_58654: 
#line 12582 
  ;
  
#line 12579 
  __retres = 0;
  return_label: 
#line 12579 
                return __retres;
}


#line 12582  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_rxfh(struct net_device *dev, u32 const *indir, u8 const *key, u8 const hfunc)
{
  int __retres;
  size_t i;
  int tmp_1;
  bool tmp_0;
  
#line 12585 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12591 
  if (key != (u8 const *)0U || (unsigned int)hfunc > 1U) {
    
#line 12593 
    __retres = -95;
    
#line 12593 
    goto return_label;
  }
  else ;
  
#line 12595 
  if (indir == (u32 const *)0U) {
    
#line 12596 
    __retres = 0;
    
#line 12596 
    goto return_label;
  }
  else ;
  
#line 12598 
  i = 0UL;
  
#line 12598 
  goto ldv_58664;
  ldv_58663: 
#line 12599 
  ;
  
#line 12599 
  tp->rss_ind_tbl[i] = (unsigned char)*(indir + i);
  
#line 12598 
  i += 1UL;
  ldv_58664: 
#line 12599 
  ;
  
#line 12598 
  if (i <= 127UL) 
#line 12600 
                  goto ldv_58663; else 
#line 12603 
                                       goto ldv_58665;
  ldv_58665: 
#line 12604 
  ;
  
#line 12601 
  tmp_0 = netif_running((struct net_device const *)dev);
  
#line 12601 
  if (tmp_0) 
#line 12601 
             tmp_1 = 0; else 
#line 12601 
                             tmp_1 = 1;
  
#line 12601 
  if (tmp_1) {
    
#line 12602 
    __retres = 0;
    
#line 12602 
    goto return_label;
  }
  else {
    int tmp_2;
    
#line 12601 
    tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
    
#line 12601 
    if (tmp_2 == 0) {
      
#line 12602 
      __retres = 0;
      
#line 12602 
      goto return_label;
    }
    else ;
  }
  
#line 12607 
  tg3_full_lock(tp,0);
  
#line 12608 
  tg3_rss_write_indir_tbl(tp);
  
#line 12609 
  tg3_full_unlock(tp);
  
#line 12611 
  __retres = 0;
  return_label: 
#line 12611 
                return __retres;
}


#line 12614  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_channels(struct net_device *dev, struct ethtool_channels *channel)
{
  int tmp_0;
  bool tmp_5;
  
#line 12617 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12618 
  tmp_0 = netif_get_num_default_rss_queues();
  
#line 12618 
  u32 deflt_qs = (unsigned int)tmp_0;
  
#line 12620 
  channel->max_rx = tp->rxq_max;
  
#line 12621 
  channel->max_tx = tp->txq_max;
  
#line 12623 
  tmp_5 = netif_running((struct net_device const *)dev);
  
#line 12623 
  if ((int)tmp_5 != 0) {
    
#line 12624 
    channel->rx_count = tp->rxq_cnt;
    
#line 12625 
    channel->tx_count = tp->txq_cnt;
  }
  else {
    
#line 12627 
    if (tp->rxq_req != 0U) 
#line 12628 
                           channel->rx_count = tp->rxq_req;
    else {
      u32 tmp_2;
      {
        u32 tmp_1;
        
#line 12630 
        u32 _min1 = deflt_qs;
        
#line 12630 
        u32 _min2 = tp->rxq_max;
        
#line 12630 
        if (_min1 < _min2) 
#line 12630 
                           tmp_1 = _min1; else 
#line 12630 
                                               tmp_1 = _min2;
        
#line 12630 
        tmp_2 = tmp_1;
      }
      
#line 12630 
      channel->rx_count = tmp_2;
    }
    
#line 12632 
    if (tp->txq_req != 0U) 
#line 12633 
                           channel->tx_count = tp->txq_req;
    else {
      u32 tmp_4;
      {
        u32 tmp_3;
        
#line 12635 
        u32 _min1_0 = deflt_qs;
        
#line 12635 
        u32 _min2_0 = tp->txq_max;
        
#line 12635 
        if (_min1_0 < _min2_0) 
#line 12635 
                               tmp_3 = _min1_0; else 
#line 12635 
                                                     tmp_3 = _min2_0;
        
#line 12635 
        tmp_4 = tmp_3;
      }
      
#line 12635 
      channel->tx_count = tmp_4;
    }
  }
  
#line 12638 
  return;
}


#line 12639  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_channels(struct net_device *dev, struct ethtool_channels *channel)
{
  int __retres;
  int tmp_0;
  int tmp_2;
  bool tmp_1;
  
#line 12642 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12644 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
  
#line 12644 
  if (tmp_0 == 0) {
    
#line 12645 
    __retres = -95;
    
#line 12645 
    goto return_label;
  }
  else ;
  
#line 12647 
  if (channel->rx_count > tp->rxq_max || channel->tx_count > tp->txq_max) {
    
#line 12649 
    __retres = -22;
    
#line 12649 
    goto return_label;
  }
  else ;
  
#line 12651 
  tp->rxq_req = channel->rx_count;
  
#line 12652 
  tp->txq_req = channel->tx_count;
  
#line 12654 
  tmp_1 = netif_running((struct net_device const *)dev);
  
#line 12654 
  if (tmp_1) 
#line 12654 
             tmp_2 = 0; else 
#line 12654 
                             tmp_2 = 1;
  
#line 12654 
  if (tmp_2) {
    
#line 12655 
    __retres = 0;
    
#line 12655 
    goto return_label;
  }
  else ;
  
#line 12657 
  tg3_stop(tp);
  
#line 12659 
  tg3_carrier_off(tp);
  
#line 12661 
  tg3_start(tp,(_Bool)1,(_Bool)0,(_Bool)0);
  
#line 12663 
  __retres = 0;
  return_label: 
#line 12663 
                return __retres;
}


#line 12666  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_strings(struct net_device *dev, u32 stringset, u8 *buf)
{
  
#line 12668 
  switch (stringset) {
    case (u32)1: 
#line 12669 
    ;
    
#line 12670 
    memcpy((void *)buf,(void const *)(& ethtool_stats_keys),2304UL);
    
#line 12671 
    goto ldv_58689;
    case (u32)0: 
#line 12672 
    ;
    
#line 12673 
    memcpy((void *)buf,(void const *)(& ethtool_test_keys),256UL);
    
#line 12674 
    goto ldv_58689;
    default: 
#line 12675 
    ;
    {
      
#line 12676 
      int __ret_warn_on = 1;
      
#line 12676 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 12676 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c",12676); else ;
      
#line 12676 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 12677 
    goto ldv_58689;
  }
  ldv_58689: 
#line 12679 
  ;
  
#line 12680 
  return;
}


#line 12681  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_phys_id(struct net_device *dev, enum ethtool_phys_id_state state)
{
  int __retres;
  int tmp_1;
  bool tmp_0;
  
#line 12684 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12686 
  tmp_0 = netif_running((struct net_device const *)tp->dev);
  
#line 12686 
  if (tmp_0) 
#line 12686 
             tmp_1 = 0; else 
#line 12686 
                             tmp_1 = 1;
  
#line 12686 
  if (tmp_1) {
    
#line 12687 
    __retres = -11;
    
#line 12687 
    goto return_label;
  }
  else ;
  
#line 12689 
  switch ((unsigned int)state) {
    case (unsigned int)1: 
#line 12690 
    ;
    
#line 12691 
    __retres = 1;
    
#line 12691 
    goto return_label;
    case (unsigned int)2: 
#line 12693 
    ;
    
#line 12694 
    (*(tp->write32))(tp,1036U,127U);
    
#line 12701 
    goto ldv_58701;
    case (unsigned int)3: 
#line 12703 
    ;
    
#line 12704 
    (*(tp->write32))(tp,1036U,17U);
    
#line 12706 
    goto ldv_58701;
    case (unsigned int)0: 
#line 12708 
    ;
    
#line 12709 
    (*(tp->write32))(tp,1036U,tp->led_ctrl);
    
#line 12710 
    goto ldv_58701;
  }
  ldv_58701: 
#line 12713 
  ;
  
#line 12713 
  __retres = 0;
  return_label: 
#line 12713 
                return __retres;
}


#line 12716  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *estats, u64 *tmp_stats)
{
  
#line 12719 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 12721 
  if (tp->hw_stats != (struct tg3_hw_stats *)0) 
#line 12722 
                                                tg3_get_estats(tp,(struct tg3_ethtool_stats *)tmp_stats); else 
                                                                    
#line 12724 
                                                                    memset((void *)tmp_stats,0,576UL);
  
#line 12725 
  return;
}


#line 12727  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static __be32 *tg3_vpd_readblock(struct tg3 *tp, u32 *vpdlen)
{
  __be32 *__retres;
  int i;
  __be32 *buf;
  u32 magic;
  u32 val;
  int tmp;
  
#line 12731 
  u32 offset = 0U;
  
#line 12731 
  u32 len = 0U;
  
#line 12734 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 12734 
  if (tmp != 0) {
    
#line 12735 
    __retres = (__be32 *)0U;
    
#line 12735 
    goto return_label;
  }
  else {
    int tmp_0;
    
#line 12734 
    tmp_0 = tg3_nvram_read(tp,0U,& magic);
    
#line 12734 
    if (tmp_0 != 0) {
      
#line 12735 
      __retres = (__be32 *)0U;
      
#line 12735 
      goto return_label;
    }
    else ;
  }
  
#line 12737 
  if (magic == 1721324970U) {
    int tmp_1;
    
#line 12738 
    offset = 24U;
    
#line 12738 
    goto ldv_58722;
    ldv_58721: 
#line 12739 
    ;
    
#line 12741 
    tmp_1 = tg3_nvram_read(tp,offset,& val);
    
#line 12741 
    if (tmp_1 != 0) {
      
#line 12742 
      __retres = (__be32 *)0U;
      
#line 12742 
      goto return_label;
    }
    else ;
    
#line 12744 
    if (val >> 24 == 20U) 
#line 12746 
                          goto ldv_58720; else ;
    
#line 12740 
    offset += 12U;
    ldv_58722: 
#line 12741 
    ;
    
#line 12738 
    if (offset <= 119U) 
#line 12741 
                        goto ldv_58721; else 
#line 12744 
                                             goto ldv_58720;
    ldv_58720: 
#line 12745 
    ;
    
#line 12749 
    if (offset != 120U) {
      int tmp_2;
      
#line 12750 
      len = (val & 4194303U) * 4U;
      
#line 12751 
      tmp_2 = tg3_nvram_read(tp,offset + 4U,& offset);
      
#line 12751 
      if (tmp_2 != 0) {
        
#line 12752 
        __retres = (__be32 *)0U;
        
#line 12752 
        goto return_label;
      }
      else ;
      
#line 12754 
      offset = tg3_nvram_logical_addr(tp,offset);
    }
    else ;
  }
  else ;
  
#line 12758 
  if (offset == 0U || len == 0U) {
    
#line 12759 
    offset = 256U;
    
#line 12760 
    len = 256U;
  }
  else ;
  
#line 12763 
  buf = (__be32 *)kmalloc((unsigned long)len,208U);
  
#line 12764 
  if (buf == (__be32 *)0U) {
    
#line 12765 
    __retres = (__be32 *)0U;
    
#line 12765 
    goto return_label;
  }
  else ;
  
#line 12767 
  if (magic == 1721324970U) {
    int tmp_4;
    
#line 12768 
    i = 0;
    
#line 12768 
    goto ldv_58725;
    ldv_58724: 
#line 12769 
    ;
    
#line 12773 
    tmp_4 = tg3_nvram_read_be32(tp,offset + (unsigned int)i,buf + i / 4);
    
#line 12773 
    if (tmp_4 != 0) 
#line 12774 
                    goto error; else ;
    
#line 12768 
    i += 4;
    ldv_58725: 
#line 12769 
    ;
    
#line 12768 
    if ((unsigned int)i < len) 
#line 12770 
                               goto ldv_58724; else 
#line 12773 
                                                    goto ldv_58726;
    ldv_58726: 
#line 12774 
    ;
  }
  else {
    u8 *ptr;
    ssize_t cnt;
    
#line 12779 
    unsigned int pos = 0U;
    
#line 12781 
    ptr = (u8 *)buf;
    
#line 12782 
    i = 0;
    
#line 12782 
    goto ldv_58731;
    ldv_58730: 
#line 12783 
    ;
    
#line 12783 
    cnt = pci_read_vpd(tp->pdev,(long long)pos,(unsigned long)(len - pos),(void *)ptr);
    
#line 12785 
    if (cnt == -110L || cnt == -4L) 
#line 12786 
                                    cnt = 0L;
    else 
      
#line 12787 
      if (cnt < 0L) 
#line 12788 
                    goto error; else ;
    
#line 12782 
    i += 1;
    
#line 12782 
    pos = (unsigned int)cnt + pos;
    
#line 12782 
    ptr += cnt;
    ldv_58731: 
#line 12783 
    ;
    
#line 12782 
    if (pos < len && i <= 2) 
#line 12784 
                             goto ldv_58730; else 
#line 12787 
                                                  goto ldv_58732;
    ldv_58732: 
#line 12788 
    ;
    
#line 12790 
    if (pos != len) 
#line 12791 
                    goto error; else ;
  }
  
#line 12794 
  *vpdlen = len;
  
#line 12796 
  __retres = buf;
  
#line 12796 
  goto return_label;
  error: 
#line 12798 
  ;
  
#line 12799 
  kfree((void const *)buf);
  
#line 12800 
  __retres = (__be32 *)0U;
  return_label: 
#line 12800 
                return __retres;
}


#line 12813  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_test_nvram(struct tg3 *tp)
{
  int __retres;
  u32 csum;
  u32 magic;
  u32 len;
  __be32 *buf;
  int i;
  int j;
  int k;
  int size;
  int tmp;
  int tmp_0;
  
#line 12817 
  int err = 0;
  
#line 12819 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 12819 
  if (tmp != 0) {
    
#line 12820 
    __retres = 0;
    
#line 12820 
    goto return_label;
  }
  else ;
  
#line 12822 
  tmp_0 = tg3_nvram_read(tp,0U,& magic);
  
#line 12822 
  if (tmp_0 != 0) {
    
#line 12823 
    __retres = -5;
    
#line 12823 
    goto return_label;
  }
  else ;
  
#line 12825 
  if (magic == 1721324970U) 
#line 12826 
                            size = 256;
  else 
    
#line 12827 
    if ((magic & 4278190080U) == 2768240640U) 
      
#line 12828 
      if ((magic & 14680064U) == 2097152U) {
        
#line 12830 
        switch (magic & 2031616U) {
          case (unsigned int)0: 
#line 12831 
          ;
          
#line 12832 
          size = 20;
          
#line 12833 
          goto ldv_58746;
          case (unsigned int)131072: 
#line 12834 
          ;
          
#line 12835 
          size = 24;
          
#line 12836 
          goto ldv_58746;
          case (unsigned int)196608: 
#line 12837 
          ;
          
#line 12838 
          size = 28;
          
#line 12839 
          goto ldv_58746;
          case (unsigned int)262144: 
#line 12840 
          ;
          
#line 12841 
          size = 32;
          
#line 12842 
          goto ldv_58746;
          case (unsigned int)327680: 
#line 12843 
          ;
          
#line 12844 
          size = 36;
          
#line 12845 
          goto ldv_58746;
          case (unsigned int)393216: 
#line 12846 
          ;
          
#line 12847 
          size = 80;
          
#line 12848 
          goto ldv_58746;
          default: 
#line 12849 
          ;
          
#line 12850 
          __retres = -5;
          
#line 12850 
          goto return_label;
        }
        ldv_58746: 
#line 12852 
        ;
      }
      else {
        
#line 12853 
        __retres = 0;
        
#line 12853 
        goto return_label;
      }
    else 
      
#line 12854 
      if ((magic & 65535U) == 43981U) 
#line 12855 
                                      size = 32;
      else {
        
#line 12857 
        __retres = -5;
        
#line 12857 
        goto return_label;
      }
  
#line 12859 
  buf = (__be32 *)kmalloc((unsigned long)size,208U);
  
#line 12860 
  if (buf == (__be32 *)0U) {
    
#line 12861 
    __retres = -12;
    
#line 12861 
    goto return_label;
  }
  else ;
  
#line 12863 
  err = -5;
  
#line 12864 
  i = 0;
  
#line 12864 
  j = 0;
  
#line 12864 
  goto ldv_58755;
  ldv_58754: 
#line 12865 
  ;
  
#line 12865 
  err = tg3_nvram_read_be32(tp,(unsigned int)i,buf + j);
  
#line 12866 
  if (err != 0) 
#line 12867 
                goto ldv_58753; else ;
  
#line 12864 
  i += 4;
  
#line 12864 
  j += 1;
  ldv_58755: 
#line 12865 
  ;
  
#line 12864 
  if (i < size) 
#line 12866 
                goto ldv_58754; else 
#line 12869 
                                     goto ldv_58753;
  ldv_58753: 
#line 12870 
  ;
  
#line 12869 
  if (i < size) 
#line 12870 
                goto out; else ;
  
#line 12873 
  if (0 != 0) 
#line 12873 
              magic = (((*buf << 24) | ((*buf << 8) & 16711680U)) | ((*buf >> 8) & 65280U)) | (*buf >> 24); else 
                                                                    
#line 12873 
                                                                    magic = __fswab32(*buf);
  
#line 12874 
  if ((magic & 4278190080U) == 2768240640U) {
    
#line 12876 
    u8 *buf8 = (u8 *)buf;
    
#line 12876 
    u8 csum8 = (unsigned char)0U;
    
#line 12878 
    if ((magic & 2031616U) == 131072U) {
      
#line 12881 
      i = 0;
      
#line 12881 
      goto ldv_58760;
      ldv_58759: 
#line 12882 
      ;
      
#line 12882 
      csum8 = (unsigned char)((int)*(buf8 + i) + (int)csum8);
      
#line 12881 
      i += 1;
      ldv_58760: 
#line 12882 
      ;
      
#line 12881 
      if (i <= 15) 
#line 12883 
                   goto ldv_58759; else 
#line 12886 
                                        goto ldv_58761;
      ldv_58761: 
#line 12887 
      ;
      
#line 12883 
      i = 20;
      
#line 12883 
      goto ldv_58763;
      ldv_58762: 
#line 12884 
      ;
      
#line 12884 
      csum8 = (unsigned char)((int)*(buf8 + i) + (int)csum8);
      
#line 12883 
      i += 1;
      ldv_58763: 
#line 12884 
      ;
      
#line 12883 
      if (i < size) 
#line 12885 
                    goto ldv_58762; else 
#line 12888 
                                         goto ldv_58764;
      ldv_58764: 
#line 12889 
      ;
    }
    else {
      
#line 12886 
      i = 0;
      
#line 12886 
      goto ldv_58766;
      ldv_58765: 
#line 12887 
      ;
      
#line 12887 
      csum8 = (unsigned char)((int)*(buf8 + i) + (int)csum8);
      
#line 12886 
      i += 1;
      ldv_58766: 
#line 12887 
      ;
      
#line 12886 
      if (i < size) 
#line 12888 
                    goto ldv_58765; else 
#line 12891 
                                         goto ldv_58767;
      ldv_58767: 
#line 12892 
      ;
    }
    
#line 12890 
    if ((unsigned int)csum8 == 0U) {
      
#line 12891 
      err = 0;
      
#line 12892 
      goto out;
    }
    else ;
    
#line 12895 
    err = -5;
    
#line 12896 
    goto out;
  }
  else ;
  
#line 12899 
  if ((magic & 65535U) == 43981U) {
    u8 data[28U];
    u8 parity[28U];
    int tmp_6;
    
#line 12903 
    u8 *buf8_0 = (u8 *)buf;
    
#line 12906 
    i = 0;
    
#line 12906 
    j = 0;
    
#line 12906 
    k = 0;
    
#line 12906 
    goto ldv_58785;
    ldv_58784: 
#line 12907 
    ;
    
#line 12907 
    if (i == 0 || i == 8) {
      int l;
      u8 msk;
      int tmp_3;
      
#line 12911 
      l = 0;
      
#line 12911 
      msk = (unsigned char)128U;
      
#line 12911 
      goto ldv_58774;
      ldv_58773: 
#line 12912 
      ;
      
#line 12912 
      tmp_3 = k;
      
#line 12912 
      k += 1;
      
#line 12912 
      parity[tmp_3] = (unsigned char)((int)*(buf8_0 + i) & (int)msk);
      
#line 12911 
      l += 1;
      
#line 12911 
      msk = (unsigned char)((int)msk >> 1);
      ldv_58774: 
#line 12912 
      ;
      
#line 12911 
      if (l <= 6) 
#line 12913 
                  goto ldv_58773; else 
#line 12916 
                                       goto ldv_58775;
      ldv_58775: 
#line 12917 
      ;
      
#line 12913 
      i += 1;
    }
    else 
      
#line 12914 
      if (i == 16) {
        int l_0;
        u8 msk_0;
        int tmp_4;
        int tmp_5;
        
#line 12918 
        l_0 = 0;
        
#line 12918 
        msk_0 = (unsigned char)32U;
        
#line 12918 
        goto ldv_58779;
        ldv_58778: 
#line 12919 
        ;
        
#line 12919 
        tmp_4 = k;
        
#line 12919 
        k += 1;
        
#line 12919 
        parity[tmp_4] = (unsigned char)((int)*(buf8_0 + i) & (int)msk_0);
        
#line 12918 
        l_0 += 1;
        
#line 12918 
        msk_0 = (unsigned char)((int)msk_0 >> 1);
        ldv_58779: 
#line 12919 
        ;
        
#line 12918 
        if (l_0 <= 5) 
#line 12920 
                      goto ldv_58778; else 
#line 12923 
                                           goto ldv_58780;
        ldv_58780: 
#line 12924 
        ;
        
#line 12920 
        i += 1;
        
#line 12922 
        l_0 = 0;
        
#line 12922 
        msk_0 = (unsigned char)128U;
        
#line 12922 
        goto ldv_58782;
        ldv_58781: 
#line 12923 
        ;
        
#line 12923 
        tmp_5 = k;
        
#line 12923 
        k += 1;
        
#line 12923 
        parity[tmp_5] = (unsigned char)((int)*(buf8_0 + i) & (int)msk_0);
        
#line 12922 
        l_0 += 1;
        
#line 12922 
        msk_0 = (unsigned char)((int)msk_0 >> 1);
        ldv_58782: 
#line 12923 
        ;
        
#line 12922 
        if (l_0 <= 7) 
#line 12924 
                      goto ldv_58781; else 
#line 12927 
                                           goto ldv_58783;
        ldv_58783: 
#line 12928 
        ;
        
#line 12924 
        i += 1;
      }
      else ;
    
#line 12926 
    tmp_6 = j;
    
#line 12926 
    j += 1;
    
#line 12926 
    data[tmp_6] = *(buf8_0 + i);
    
#line 12906 
    i += 1;
    ldv_58785: 
#line 12907 
    ;
    
#line 12906 
    if (i <= 31) 
#line 12908 
                 goto ldv_58784; else 
#line 12911 
                                      goto ldv_58786;
    ldv_58786: 
#line 12912 
    ;
    
#line 12929 
    err = -5;
    
#line 12930 
    i = 0;
    
#line 12930 
    goto ldv_58789;
    ldv_58788: 
#line 12931 
    ;
    {
      int tmp_8;
      
#line 12931 
      if (0 != 0) 
#line 12931 
                  tmp_8 = (((((((((unsigned long long)data[i] & 1ULL) != 0ULL) + (((unsigned long long)data[i] & 2ULL) != 0ULL)) + (((unsigned long long)data[i] & 4ULL) != 0ULL)) + (((unsigned long long)data[i] & 8ULL) != 0ULL)) + (((unsigned long long)data[i] & 16ULL) != 0ULL)) + (((unsigned long long)data[i] & 32ULL) != 0ULL)) + (((unsigned long long)data[i] & 64ULL) != 0ULL)) + ((int)data[i] < 0);
      else {
        unsigned int tmp_7;
        
#line 12931 
        tmp_7 = __arch_hweight8((unsigned int)data[i]);
        
#line 12931 
        tmp_8 = (int)((unsigned char)tmp_7);
      }
      
#line 12931 
      u8 hw8 = (unsigned char)tmp_8;
      
#line 12933 
      if (((int)hw8 & 1) != 0 && (unsigned int)parity[i] != 0U) 
#line 12934 
                                                                goto out;
      else 
        
#line 12935 
        if (((int)hw8 & 1) == 0 && (unsigned int)parity[i] == 0U) 
#line 12936 
                                                                  goto out; else ;
    }
    
#line 12930 
    i += 1;
    ldv_58789: 
#line 12931 
    ;
    
#line 12930 
    if (i <= 27) 
#line 12932 
                 goto ldv_58788; else 
#line 12935 
                                      goto ldv_58790;
    ldv_58790: 
#line 12936 
    ;
    
#line 12938 
    err = 0;
    
#line 12939 
    goto out;
  }
  else ;
  
#line 12942 
  err = -5;
  
#line 12945 
  csum = calc_crc((unsigned char *)buf,16);
  
#line 12946 
  if (*(buf + 4U) != csum) 
#line 12947 
                           goto out; else ;
  
#line 12950 
  csum = calc_crc((unsigned char *)(buf + 29U),136);
  
#line 12951 
  if (*(buf + 63U) != csum) 
#line 12952 
                            goto out; else ;
  
#line 12954 
  kfree((void const *)buf);
  
#line 12956 
  buf = tg3_vpd_readblock(tp,& len);
  
#line 12957 
  if (buf == (__be32 *)0U) {
    
#line 12958 
    __retres = -12;
    
#line 12958 
    goto return_label;
  }
  else ;
  
#line 12960 
  i = pci_vpd_find_tag((u8 const *)buf,0U,len,(unsigned char)144);
  
#line 12961 
  if (i > 0) {
    u16 tmp_9;
    
#line 12962 
    tmp_9 = pci_vpd_lrdt_size((u8 const *)buf + i);
    
#line 12962 
    j = (int)tmp_9;
    
#line 12963 
    if (j < 0) 
#line 12964 
               goto out; else ;
    
#line 12966 
    if ((unsigned int)((i + 3) + j) > len) 
#line 12967 
                                           goto out; else ;
    
#line 12969 
    i += 3;
    
#line 12970 
    j = pci_vpd_find_info_keyword((u8 const *)buf,(unsigned int)i,(unsigned int)j,"RV");
    
#line 12972 
    if (j > 0) {
      
#line 12973 
      u8 csum8_0 = (unsigned char)0U;
      
#line 12975 
      j += 3;
      
#line 12977 
      i = 0;
      
#line 12977 
      goto ldv_58793;
      ldv_58792: 
#line 12978 
      ;
      
#line 12978 
      csum8_0 = (unsigned char)((int)*((u8 *)buf + i) + (int)csum8_0);
      
#line 12977 
      i += 1;
      ldv_58793: 
#line 12978 
      ;
      
#line 12977 
      if (i <= j) 
#line 12979 
                  goto ldv_58792; else 
#line 12982 
                                       goto ldv_58794;
      ldv_58794: 
#line 12983 
      ;
      
#line 12980 
      if ((unsigned int)csum8_0 != 0U) 
#line 12981 
                                       goto out; else ;
    }
    else ;
  }
  else ;
  
#line 12985 
  err = 0;
  out: 
#line 12987 
  ;
  
#line 12988 
  kfree((void const *)buf);
  
#line 12989 
  __retres = err;
  return_label: 
#line 12989 
                return __retres;
}


#line 12995  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_test_link(struct tg3 *tp)
{
  int __retres;
  int i;
  int max;
  int tmp_0;
  bool tmp;
  unsigned long tmp_1;
  
#line 12999 
  tmp = netif_running((struct net_device const *)tp->dev);
  
#line 12999 
  if (tmp) 
#line 12999 
           tmp_0 = 0; else 
#line 12999 
                           tmp_0 = 1;
  
#line 12999 
  if (tmp_0) {
    
#line 13000 
    __retres = -19;
    
#line 13000 
    goto return_label;
  }
  else ;
  
#line 13002 
  if ((tp->phy_flags & 48U) != 0U) 
#line 13003 
                                   max = 2; else 
#line 13005 
                                                 max = 6;
  
#line 13007 
  i = 0;
  
#line 13007 
  goto ldv_58802;
  ldv_58801: 
#line 13008 
  ;
  
#line 13008 
  if ((int)tp->link_up != 0) {
    
#line 13009 
    __retres = 0;
    
#line 13009 
    goto return_label;
  }
  else ;
  
#line 13011 
  tmp_1 = msleep_interruptible(1000U);
  
#line 13011 
  if (tmp_1 != 0UL) 
#line 13012 
                    goto ldv_58800; else ;
  
#line 13007 
  i += 1;
  ldv_58802: 
#line 13008 
  ;
  
#line 13007 
  if (i < max) 
#line 13009 
               goto ldv_58801; else 
#line 13012 
                                    goto ldv_58800;
  ldv_58800: 
#line 13013 
  ;
  
#line 13015 
  __retres = -5;
  return_label: 
#line 13015 
                return __retres;
}


#line 13019  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_test_registers(struct tg3 *tp)
{
  int __retres;
  int i;
  int is_5705;
  int is_5750;
  u32 offset;
  u32 read_mask;
  u32 write_mask;
  u32 val;
  u32 save_val;
  u32 read_val;
  int tmp_0;
  int tmp_1;
  
#line 13032 
  struct __anonstruct_reg_tbl_399 reg_tbl[61U] = {{.offset = (unsigned short)1024U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 15691660U}, {.offset = (unsigned short)1024U, .flags = (unsigned short)1U, .read_mask = 0U, .write_mask = 32467852U}, {.offset = (unsigned short)1028U, .flags = (unsigned short)2U, .read_mask = 58720519U, .write_mask = 0U}, {.offset = (unsigned short)1028U, .flags = (unsigned short)1U, .read_mask = 58720512U, .write_mask = 0U}, {.offset = (unsigned short)1040U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 65535U}, {.offset = (unsigned short)1044U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)1084U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 65535U}, {.offset = (unsigned short)1116U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 112U}, {.offset = (unsigned short)1124U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 16383U}, {.offset = (unsigned short)1128U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 2044U}, {.offset = (unsigned short)1128U, .flags = (unsigned short)1U, .read_mask = 0U, .write_mask = 2012U}, {.offset = (unsigned short)1136U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)1140U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)1144U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)1148U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)9280U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)9284U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)9288U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 3U}, {.offset = (unsigned short)9292U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)9296U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)9300U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)9304U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294901762U}, {.offset = (unsigned short)9308U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)11288U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)11288U, .flags = (unsigned short)1U, .read_mask = 0U, .write_mask = 1023U}, {.offset = (unsigned short)11292U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15360U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4U}, {.offset = (unsigned short)15360U, .flags = (unsigned short)1U, .read_mask = 0U, .write_mask = 246U}, {.offset = (unsigned short)15368U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15368U, .flags = (unsigned short)1U, .read_mask = 0U, .write_mask = 1023U}, {.offset = (unsigned short)15372U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15372U, .flags = (unsigned short)1U, .read_mask = 0U, .write_mask = 1023U}, {.offset = (unsigned short)15376U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15376U, .flags = (unsigned short)5U, .read_mask = 0U, .write_mask = 255U}, {.offset = (unsigned short)15380U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15380U, .flags = (unsigned short)5U, .read_mask = 0U, .write_mask = 255U}, {.offset = (unsigned short)15384U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15388U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15392U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15392U, .flags = (unsigned short)5U, .read_mask = 0U, .write_mask = 255U}, {.offset = (unsigned short)15396U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15396U, .flags = (unsigned short)5U, .read_mask = 0U, .write_mask = 255U}, {.offset = (unsigned short)15400U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15408U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15412U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15416U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15420U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 4294967295U}, {.offset = (unsigned short)15424U, .flags = (unsigned short)0U, .read_mask = 4294967295U, .write_mask = 0U}, {.offset = (unsigned short)15428U, .flags = (unsigned short)0U, .read_mask = 4294967295U, .write_mask = 0U}, {.offset = (unsigned short)17416U, .flags = (unsigned short)8U, .read_mask = 0U, .write_mask = 8388480U}, {.offset = (unsigned short)17420U, .flags = (unsigned short)8U, .read_mask = 0U, .write_mask = 8388607U}, {.offset = (unsigned short)17424U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 63U}, {.offset = (unsigned short)17428U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 511U}, {.offset = (unsigned short)17432U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 511U}, {.offset = (unsigned short)17452U, .flags = (unsigned short)2U, .read_mask = 4294967295U, .write_mask = 0U}, {.offset = (unsigned short)17456U, .flags = (unsigned short)2U, .read_mask = 4294967295U, .write_mask = 0U}, {.offset = (unsigned short)22636U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 511U}, {.offset = (unsigned short)22644U, .flags = (unsigned short)2U, .read_mask = 0U, .write_mask = 511U}, {.offset = (unsigned short)22660U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 2047U}, {.offset = (unsigned short)22788U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 511U}, {.offset = (unsigned short)65535U, .flags = (unsigned short)0U, .read_mask = 0U, .write_mask = 0U}};
  
#line 13168 
  is_5750 = 0;
  
#line 13168 
  is_5705 = is_5750;
  
#line 13169 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 13169 
  if (tmp_0 != 0) {
    int tmp;
    
#line 13170 
    is_5705 = 1;
    
#line 13171 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 13171 
    if (tmp != 0) 
#line 13172 
                  is_5750 = 1; else ;
  }
  else ;
  
#line 13175 
  i = 0;
  
#line 13175 
  goto ldv_58824;
  ldv_58823: 
#line 13176 
  ;
  
#line 13176 
  if (is_5705 != 0 && ((int)reg_tbl[i].flags & 2) != 0) 
#line 13177 
                                                        goto ldv_58821; else ;
  
#line 13179 
  if (is_5705 == 0 && ((int)reg_tbl[i].flags & 1) != 0) 
#line 13180 
                                                        goto ldv_58821; else ;
  
#line 13182 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_5788,(unsigned long *)(& tp->tg3_flags));
  
#line 13182 
  if (tmp_1 != 0) {
    
#line 13182 
    if (((int)reg_tbl[i].flags & 4) != 0) 
#line 13184 
                                          goto ldv_58821; else ;
  }
  else ;
  
#line 13186 
  if (is_5750 != 0 && ((int)reg_tbl[i].flags & 8) != 0) 
#line 13187 
                                                        goto ldv_58821; else ;
  
#line 13189 
  offset = (unsigned int)reg_tbl[i].offset;
  
#line 13190 
  read_mask = reg_tbl[i].read_mask;
  
#line 13191 
  write_mask = reg_tbl[i].write_mask;
  
#line 13194 
  save_val = (*(tp->read32))(tp,offset);
  
#line 13197 
  read_val = save_val & read_mask;
  
#line 13202 
  (*(tp->write32))(tp,offset,0U);
  
#line 13204 
  val = (*(tp->read32))(tp,offset);
  
#line 13207 
  if ((val & read_mask) != read_val || (val & write_mask) != 0U) 
#line 13208 
                                                                 goto out; else ;
  
#line 13214 
  (*(tp->write32))(tp,offset,read_mask | write_mask);
  
#line 13216 
  val = (*(tp->read32))(tp,offset);
  
#line 13219 
  if ((val & read_mask) != read_val) 
#line 13220 
                                     goto out; else ;
  
#line 13223 
  if ((val & write_mask) != write_mask) 
#line 13224 
                                        goto out; else ;
  
#line 13226 
  (*(tp->write32))(tp,offset,save_val);
  ldv_58821: 
#line 13227 
  ;
  
#line 13175 
  i += 1;
  ldv_58824: 
#line 13176 
  ;
  
#line 13175 
  if ((unsigned int)reg_tbl[i].offset != 65535U) 
#line 13177 
                                                 goto ldv_58823; else 
                                                                   
#line 13180 
                                                                   goto ldv_58825;
  ldv_58825: 
#line 13181 
  ;
  
#line 13229 
  __retres = 0;
  
#line 13229 
  goto return_label;
  out: 
#line 13231 
  ;
  
#line 13232 
  if ((tp->msg_enable & 8192U) != 0U) 
#line 13233 
                                      netdev_err((struct net_device const *)tp->dev,"Register test failed at offset %x\n",offset); else ;
  
#line 13235 
  (*(tp->write32))(tp,offset,save_val);
  
#line 13236 
  __retres = -5;
  return_label: 
#line 13236 
                return __retres;
}


#line 13239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_do_mem_test(struct tg3 *tp, u32 offset, u32 len)
{
  int __retres;
  int i;
  u32 j;
  
#line 13241 
  u32 const test_pattern[3U] = {0U, 4294967295U, 2857739610U};
  
#line 13245 
  i = 0;
  
#line 13245 
  goto ldv_58842;
  ldv_58841: 
#line 13246 
  ;
  
#line 13246 
  j = 0U;
  
#line 13246 
  goto ldv_58839;
  ldv_58838: 
#line 13247 
  ;
  {
    u32 val;
    
#line 13249 
    tg3_write_mem(tp,offset + j,test_pattern[i]);
    
#line 13250 
    tg3_read_mem(tp,offset + j,& val);
    
#line 13251 
    if (test_pattern[i] != val) {
      
#line 13252 
      __retres = -5;
      
#line 13252 
      goto return_label;
    }
    else ;
  }
  
#line 13246 
  j += 4U;
  ldv_58839: 
#line 13247 
  ;
  
#line 13246 
  if (j < len) 
#line 13248 
               goto ldv_58838; else 
#line 13251 
                                    goto ldv_58840;
  ldv_58840: 
#line 13252 
  ;
  
#line 13245 
  i += 1;
  ldv_58842: 
#line 13246 
  ;
  
#line 13245 
  if ((unsigned int)i <= 2U) 
#line 13247 
                             goto ldv_58841; else 
#line 13250 
                                                  goto ldv_58843;
  ldv_58843: 
#line 13251 
  ;
  
#line 13255 
  __retres = 0;
  return_label: 
#line 13255 
                return __retres;
}


#line 13258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_test_memory(struct tg3 *tp)
{
  struct mem_entry *mem_tbl;
  int i;
  int tmp_2;
  
#line 13263 
  struct mem_entry mem_tbl_570x[3U] = {{.offset = 0U, .len = 2896U}, {.offset = 8192U, .len = 114688U}, {.offset = 4294967295U, .len = 0U}};
  
#line 13267 
  struct mem_entry mem_tbl_5705[7U] = {{.offset = 256U, .len = 12U}, {.offset = 512U, .len = 8U}, {.offset = 16384U, .len = 2048U}, {.offset = 24576U, .len = 4096U}, {.offset = 32768U, .len = 8192U}, {.offset = 65536U, .len = 57344U}, {.offset = 4294967295U, .len = 0U}};
  
#line 13275 
  struct mem_entry mem_tbl_5755[6U] = {{.offset = 512U, .len = 8U}, {.offset = 16384U, .len = 2048U}, {.offset = 24576U, .len = 2048U}, {.offset = 32768U, .len = 8192U}, {.offset = 65536U, .len = 49152U}, {.offset = 4294967295U, .len = 0U}};
  
#line 13282 
  struct mem_entry mem_tbl_5906[6U] = {{.offset = 512U, .len = 8U}, {.offset = 16384U, .len = 1024U}, {.offset = 24576U, .len = 1024U}, {.offset = 32768U, .len = 4096U}, {.offset = 65536U, .len = 4096U}, {.offset = 4294967295U, .len = 0U}};
  
#line 13289 
  struct mem_entry mem_tbl_5717[4U] = {{.offset = 512U, .len = 8U}, {.offset = 65536U, .len = 40960U}, {.offset = 131072U, .len = 80896U}, {.offset = 4294967295U, .len = 0U}};
  
#line 13294 
  struct mem_entry mem_tbl_57765[5U] = {{.offset = 512U, .len = 8U}, {.offset = 16384U, .len = 2048U}, {.offset = 24576U, .len = 38912U}, {.offset = 65536U, .len = 40960U}, {.offset = 4294967295U, .len = 0U}};
  
#line 13302 
  int err = 0;
  
#line 13305 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 13305 
  if (tmp_2 != 0) 
#line 13306 
                  mem_tbl = (struct mem_entry *)(& mem_tbl_5717);
  else {
    int tmp_1;
    
#line 13307 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 13307 
    if (tmp_1 != 0) 
#line 13307 
                    goto _LOR;
    else 
      
#line 13307 
      if (tp->pci_chip_rev_id >> 12 == 22370U) _LOR: 
#line 13309 
                                                     mem_tbl = (struct mem_entry *)(& mem_tbl_57765);
      else {
        int tmp_0;
        
#line 13310 
        tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
        
#line 13310 
        if (tmp_0 != 0) 
#line 13311 
                        mem_tbl = (struct mem_entry *)(& mem_tbl_5755);
        else 
          
#line 13312 
          if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 13313 
                                                mem_tbl = (struct mem_entry *)(& mem_tbl_5906);
          else {
            int tmp;
            
#line 13314 
            tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
            
#line 13314 
            if (tmp != 0) 
#line 13315 
                          mem_tbl = (struct mem_entry *)(& mem_tbl_5705); else 
                                                                    
#line 13317 
                                                                    mem_tbl = (struct mem_entry *)(& mem_tbl_570x);
          }
      }
  }
  
#line 13319 
  i = 0;
  
#line 13319 
  goto ldv_58861;
  ldv_58860: 
#line 13320 
  ;
  
#line 13320 
  err = tg3_do_mem_test(tp,(mem_tbl + i)->offset,(mem_tbl + i)->len);
  
#line 13321 
  if (err != 0) 
#line 13322 
                goto ldv_58859; else ;
  
#line 13319 
  i += 1;
  ldv_58861: 
#line 13320 
  ;
  
#line 13319 
  if ((mem_tbl + i)->offset != 4294967295U) 
#line 13321 
                                            goto ldv_58860; else 
#line 13324 
                                                                 goto ldv_58859;
  ldv_58859: 
#line 13325 
  ;
  
#line 13325 
  return err;
}


#line 13334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u8 const tg3_tso_header[54U] = {(unsigned char)8U, (unsigned char)0U, (unsigned char)69U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)64U, (unsigned char)0U, (unsigned char)64U, (unsigned char)6U, (unsigned char)0U, (unsigned char)0U, (unsigned char)10U, (unsigned char)0U, (unsigned char)0U, (unsigned char)1U, (unsigned char)10U, (unsigned char)0U, (unsigned char)0U, (unsigned char)2U, (unsigned char)13U, (unsigned char)0U, (unsigned char)224U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)1U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)2U, (unsigned char)0U, (unsigned char)128U, (unsigned char)16U, (unsigned char)16U, (unsigned char)0U, (unsigned char)20U, (unsigned char)9U, (unsigned char)0U, (unsigned char)0U, (unsigned char)1U, (unsigned char)1U, (unsigned char)8U, (unsigned char)10U, (unsigned char)17U, (unsigned char)17U, (unsigned char)17U, (unsigned char)17U, (unsigned char)17U, (unsigned char)17U, (unsigned char)17U, (unsigned char)17U};

#line 13351  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_run_loopback(struct tg3 *tp, u32 pktsz, bool tso_loopback)
{
  int __retres;
  u32 rx_start_idx;
  u32 rx_idx;
  u32 tx_idx;
  u32 opaque_key;
  u32 desc_idx;
  u32 coal_now;
  u32 data_off;
  u32 val;
  u32 budget;
  struct sk_buff *skb;
  u8 *tx_data;
  u8 *rx_data;
  dma_addr_t map;
  int num_pkts;
  int tx_len;
  int rx_len;
  int i;
  int err;
  struct tg3_rx_buffer_desc *desc;
  struct tg3_napi *tnapi;
  struct tg3_napi *rnapi;
  int tmp_10;
  bool tmp_11;
  u32 tmp_12;
  int tmp_14;
  
#line 13354 
  u32 base_flags = 0U;
  
#line 13354 
  u32 mss = 0U;
  
#line 13362 
  struct tg3_rx_prodring_set *tpr = & tp->napi[0].prodring;
  
#line 13364 
  tnapi = & tp->napi[0];
  
#line 13365 
  rnapi = & tp->napi[0];
  
#line 13366 
  if (tp->irq_cnt > 1U) {
    int tmp;
    int tmp_0;
    
#line 13367 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
    
#line 13367 
    if (tmp != 0) 
#line 13368 
                  rnapi = & tp->napi[1]; else ;
    
#line 13369 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_TSS,(unsigned long *)(& tp->tg3_flags));
    
#line 13369 
    if (tmp_0 != 0) 
#line 13370 
                    tnapi = & tp->napi[1]; else ;
  }
  else ;
  
#line 13372 
  coal_now = tnapi->coal_now | rnapi->coal_now;
  
#line 13374 
  err = -5;
  
#line 13376 
  tx_len = (int)pktsz;
  
#line 13377 
  skb = netdev_alloc_skb(tp->dev,(unsigned int)tx_len);
  
#line 13378 
  if (skb == (struct sk_buff *)0) {
    
#line 13379 
    __retres = -12;
    
#line 13379 
    goto return_label;
  }
  else ;
  
#line 13381 
  tx_data = skb_put(skb,(unsigned int)tx_len);
  
#line 13382 
  memcpy((void *)tx_data,(void const *)(tp->dev)->dev_addr,6UL);
  
#line 13383 
  memset((void *)(tx_data + 6U),0,8UL);
  
#line 13385 
  (*(tp->write32))(tp,1084U,(unsigned int)(tx_len + 4));
  
#line 13387 
  if ((int)tso_loopback != 0) {
    int tmp_3;
    int tmp_8;
    
#line 13388 
    struct iphdr *iph = (struct iphdr *)(tx_data + 14U);
    
#line 13390 
    u32 hdr_len = 52U;
    
#line 13393 
    memcpy((void *)(tx_data + 12U),(void const *)(& tg3_tso_header),54UL);
    
#line 13395 
    mss = 500U;
    
#line 13397 
    val = (unsigned int)tx_len + 4294967230U;
    
#line 13398 
    num_pkts = (int)((val + 499U) / 500U);
    
#line 13401 
    if (0 != 0) 
#line 13401 
                iph->tot_len = (unsigned short)((((int)((unsigned short)mss) + (int)((unsigned short)hdr_len)) << 8) | (((int)((unsigned short)mss) + (int)((unsigned short)hdr_len)) >> 8)); else 
                                                                    
#line 13401 
                                                                    iph->tot_len = __fswab16((unsigned short)((int)((unsigned short)mss) + (int)((unsigned short)hdr_len)));
    
#line 13403 
    base_flags = 768U;
    
#line 13406 
    tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
    
#line 13406 
    if (tmp_3 != 0) 
#line 13406 
                    goto _LOR;
    else {
      int tmp_4;
      
#line 13406 
      tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
      
#line 13406 
      if (tmp_4 != 0) 
#line 13406 
                      goto _LOR;
      else {
        int tmp_5;
        
#line 13407 
        tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
        
#line 13407 
        if (tmp_5 != 0) {
          _LOR: {
                  struct tcphdr *th;
                  
#line 13410 
                  val = 34U;
                  
#line 13411 
                  th = (struct tcphdr *)(tx_data + val);
                  
#line 13412 
                  th->check = (unsigned short)0U;
                }
        }
        else 
#line 13414 
             base_flags |= 1U;
      }
    }
    
#line 13416 
    tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
    
#line 13416 
    if (tmp_8 != 0) {
      
#line 13417 
      mss = ((hdr_len << 12) & 49152U) | mss;
      
#line 13418 
      if ((hdr_len & 16U) != 0U) 
#line 13419 
                                 base_flags |= 16U; else ;
      
#line 13420 
      base_flags = ((hdr_len << 5) & 31744U) | base_flags;
    }
    else {
      int tmp_7;
      
#line 13421 
      tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
      
#line 13421 
      if (tmp_7 != 0) 
#line 13422 
                      mss = (hdr_len << 9) | mss;
      else {
        int tmp_6;
        
#line 13423 
        tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
        
#line 13423 
        if (tmp_6 != 0) 
#line 13423 
                        goto _LOR_0;
        else 
          
#line 13423 
          if (tp->pci_chip_rev_id >> 12 == 3U) _LOR_0: 
#line 13425 
                                                       mss |= 6144U; else 
                                                                    
#line 13427 
                                                                    base_flags |= 12288U;
      }
    }
    
#line 13430 
    data_off = 66U;
  }
  else {
    int tmp_9;
    
#line 13432 
    num_pkts = 1;
    
#line 13433 
    data_off = 14U;
    
#line 13435 
    tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_JUMBO_BDFLAG,(unsigned long *)(& tp->tg3_flags));
    
#line 13435 
    if (tmp_9 != 0) {
      
#line 13435 
      if (tx_len > 1518) 
#line 13437 
                         base_flags |= 8U; else ;
    }
    else ;
  }
  
#line 13440 
  i = (int)data_off;
  
#line 13440 
  goto ldv_58896;
  ldv_58895: 
#line 13441 
  ;
  
#line 13441 
  *(tx_data + i) = (unsigned char)i;
  
#line 13440 
  i += 1;
  ldv_58896: 
#line 13441 
  ;
  
#line 13440 
  if (i < tx_len) 
#line 13442 
                  goto ldv_58895; else 
#line 13445 
                                       goto ldv_58897;
  ldv_58897: 
#line 13446 
  ;
  
#line 13443 
  map = pci_map_single(tp->pdev,(void *)skb->data,(unsigned long)tx_len,1);
  
#line 13444 
  tmp_10 = pci_dma_mapping_error(tp->pdev,map);
  
#line 13444 
  if (tmp_10 != 0) {
    
#line 13445 
    consume_skb(skb);
    
#line 13446 
    __retres = -5;
    
#line 13446 
    goto return_label;
  }
  else ;
  
#line 13449 
  val = tnapi->tx_prod;
  
#line 13450 
  (tnapi->tx_buffers + val)->skb = skb;
  
#line 13451 
  (tnapi->tx_buffers + val)->mapping = map;
  
#line 13453 
  _tw32_flush(tp,15360U,(tp->coalesce_mode | rnapi->coal_now) | 2U,0U);
  
#line 13456 
  __const_udelay(42950UL);
  
#line 13458 
  rx_start_idx = (unsigned int)(rnapi->hw_status)->idx[0].rx_producer;
  
#line 13460 
  budget = tg3_tx_avail(tnapi);
  
#line 13461 
  tmp_11 = tg3_tx_frag_set(tnapi,& val,& budget,map,(unsigned int)tx_len,base_flags | 4U,mss,0U);
  
#line 13461 
  if ((int)tmp_11 != 0) {
    
#line 13463 
    (tnapi->tx_buffers + val)->skb = (struct sk_buff *)0;
    
#line 13464 
    consume_skb(skb);
    
#line 13465 
    __retres = -5;
    
#line 13465 
    goto return_label;
  }
  else ;
  
#line 13468 
  tnapi->tx_prod += 1U;
  
#line 13469 
  ldv_inline_asm();
  
#line 13473 
  (*(tp->write32_tx_mbox))(tp,tnapi->prodmbox,tnapi->tx_prod);
  
#line 13474 
  (*(tp->read32_mbox))(tp,tnapi->prodmbox);
  
#line 13476 
  __const_udelay(42950UL);
  
#line 13479 
  i = 0;
  
#line 13479 
  goto ldv_58900;
  ldv_58899: 
#line 13480 
  ;
  
#line 13480 
  _tw32_flush(tp,15360U,(tp->coalesce_mode | coal_now) | 2U,0U);
  
#line 13483 
  __const_udelay(42950UL);
  
#line 13485 
  tx_idx = (unsigned int)(tnapi->hw_status)->idx[0].tx_consumer;
  
#line 13486 
  rx_idx = (unsigned int)(rnapi->hw_status)->idx[0].rx_producer;
  
#line 13487 
  if (tnapi->tx_prod == tx_idx && rx_start_idx + (unsigned int)num_pkts == rx_idx) 
    
#line 13489 
    goto ldv_58898; else ;
  
#line 13479 
  i += 1;
  ldv_58900: 
#line 13480 
  ;
  
#line 13479 
  if (i <= 34) 
#line 13481 
               goto ldv_58899; else 
#line 13484 
                                    goto ldv_58898;
  ldv_58898: 
#line 13485 
  ;
  
#line 13492 
  tg3_tx_skb_unmap(tnapi,tnapi->tx_prod + 4294967295U,-1);
  
#line 13493 
  consume_skb(skb);
  
#line 13495 
  if (tnapi->tx_prod != tx_idx) 
#line 13496 
                                goto out; else ;
  
#line 13498 
  if (rx_start_idx + (unsigned int)num_pkts != rx_idx) 
#line 13499 
                                                       goto out; else ;
  
#line 13501 
  val = data_off;
  
#line 13502 
  goto ldv_58909;
  ldv_58908: 
#line 13503 
  ;
  
#line 13503 
  tmp_12 = rx_start_idx;
  
#line 13503 
  rx_start_idx += 1U;
  
#line 13503 
  desc = rnapi->rx_rcb + tmp_12;
  
#line 13504 
  desc_idx = desc->opaque & 65535U;
  
#line 13505 
  opaque_key = desc->opaque & 458752U;
  
#line 13507 
  if ((desc->err_vlan & 32440320U) != 0U && desc->err_vlan != 1048576U) 
    
#line 13509 
    goto out; else ;
  
#line 13511 
  rx_len = (int)((desc->idx_len & 65535U) + 4294967292U);
  
#line 13514 
  if (! tso_loopback) {
    
#line 13515 
    if (rx_len != tx_len) 
#line 13516 
                          goto out; else ;
    
#line 13518 
    if (pktsz <= 1532U) {
      
#line 13519 
      if (opaque_key != 65536U) 
#line 13520 
                                goto out; else ;
    }
    else 
      
#line 13522 
      if (opaque_key != 131072U) 
#line 13523 
                                 goto out; else ;
  }
  else 
    
#line 13525 
    if ((desc->type_flags & 8192U) != 0U && (desc->ip_tcp_csum & 65535U) != 65535U) 
      
#line 13528 
      goto out; else ;
  
#line 13531 
  if (opaque_key == 65536U) {
    
#line 13532 
    rx_data = (tpr->rx_std_buffers + desc_idx)->data;
    
#line 13533 
    map = (tpr->rx_std_buffers + desc_idx)->mapping;
  }
  else 
    
#line 13535 
    if (opaque_key == 131072U) {
      
#line 13536 
      rx_data = (tpr->rx_jmb_buffers + desc_idx)->data;
      
#line 13537 
      map = (tpr->rx_jmb_buffers + desc_idx)->mapping;
    }
    else 
#line 13540 
         goto out;
  
#line 13542 
  pci_dma_sync_single_for_cpu(tp->pdev,map,(unsigned long)rx_len,2);
  {
    int tmp_13;
    
#line 13545 
    int _max1 = 32;
    
#line 13545 
    int _max2 = 64;
    
#line 13545 
    if (_max1 > _max2) 
#line 13545 
                       tmp_13 = _max1; else 
#line 13545 
                                            tmp_13 = _max2;
    
#line 13545 
    tmp_14 = tmp_13;
  }
  
#line 13545 
  rx_data += tmp_14;
  
#line 13546 
  i = (int)data_off;
  
#line 13546 
  goto ldv_58906;
  ldv_58905: 
#line 13547 
  ;
  
#line 13547 
  if ((int)*(rx_data + i) != (int)((unsigned char)val)) 
#line 13548 
                                                        goto out; else ;
  
#line 13546 
  i += 1;
  
#line 13546 
  val += 1U;
  ldv_58906: 
#line 13547 
  ;
  
#line 13546 
  if (i < rx_len) 
#line 13548 
                  goto ldv_58905; else 
#line 13551 
                                       goto ldv_58907;
  ldv_58907: 
#line 13552 
  ;
  ldv_58909: 
#line 13553 
  ;
  
#line 13502 
  if (rx_idx != rx_start_idx) 
#line 13504 
                              goto ldv_58908; else 
#line 13507 
                                                   goto ldv_58910;
  ldv_58910: 
#line 13508 
  ;
  
#line 13552 
  err = 0;
  out: 
#line 13555 
  ;
  
#line 13556 
  __retres = err;
  return_label: 
#line 13556 
                return __retres;
}


#line 13567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_test_loopback(struct tg3 *tp, u64 *data, bool do_extlpbk)
{
  u32 eee_cap;
  int tmp_0;
  bool tmp;
  int tmp_1;
  
#line 13569 
  int err = -5;
  
#line 13571 
  u32 jmb_pkt_sz = 9000U;
  
#line 13573 
  if (tp->dma_limit != 0U) 
#line 13574 
                           jmb_pkt_sz = tp->dma_limit + 4294967282U; else ;
  
#line 13576 
  eee_cap = tp->phy_flags & 262144U;
  
#line 13577 
  tp->phy_flags &= 4294705151U;
  
#line 13579 
  tmp = netif_running((struct net_device const *)tp->dev);
  
#line 13579 
  if (tmp) 
#line 13579 
           tmp_0 = 0; else 
#line 13579 
                           tmp_0 = 1;
  
#line 13579 
  if (tmp_0) {
    
#line 13580 
    *(data + 4U) = 7ULL;
    
#line 13581 
    *(data + 5U) = 7ULL;
    
#line 13582 
    if ((int)do_extlpbk != 0) 
#line 13583 
                              *(data + 6U) = 7ULL; else ;
    
#line 13584 
    goto done;
  }
  else ;
  
#line 13587 
  err = tg3_reset_hw(tp,(_Bool)1);
  
#line 13588 
  if (err != 0) {
    
#line 13589 
    *(data + 4U) = 7ULL;
    
#line 13590 
    *(data + 5U) = 7ULL;
    
#line 13591 
    if ((int)do_extlpbk != 0) 
#line 13592 
                              *(data + 6U) = 7ULL; else ;
    
#line 13593 
    goto done;
  }
  else ;
  
#line 13596 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_RSS,(unsigned long *)(& tp->tg3_flags));
  
#line 13596 
  if (tmp_1 != 0) {
    int i;
    
#line 13600 
    i = 1584;
    
#line 13600 
    goto ldv_58922;
    ldv_58921: 
#line 13601 
    ;
    
#line 13602 
    (*(tp->write32))(tp,(unsigned int)i,0U);
    
#line 13601 
    i += 4;
    ldv_58922: 
#line 13602 
    ;
    
#line 13600 
    if (i <= 1711) 
#line 13603 
                   goto ldv_58921; else 
#line 13606 
                                        goto ldv_58923;
    ldv_58923: 
#line 13607 
    ;
  }
  else ;
  
#line 13610 
  if (tp->pci_chip_rev_id >> 12 != 8U) {
    int tmp_5;
    
#line 13610 
    tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
    
#line 13610 
    if (tmp_5 == 0) {
      int tmp_2;
      int tmp_3;
      
#line 13612 
      tg3_mac_loopback(tp,(_Bool)1);
      
#line 13614 
      tmp_2 = tg3_run_loopback(tp,1514U,(_Bool)0);
      
#line 13614 
      if (tmp_2 != 0) 
#line 13615 
                      *(data + 4U) |= 1ULL; else ;
      
#line 13617 
      tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 13617 
      if (tmp_3 != 0) {
        int tmp_4;
        
#line 13617 
        tmp_4 = tg3_run_loopback(tp,jmb_pkt_sz + 14U,(_Bool)0);
        
#line 13617 
        if (tmp_4 != 0) 
#line 13619 
                        *(data + 4U) |= 2ULL; else ;
      }
      else ;
      
#line 13621 
      tg3_mac_loopback(tp,(_Bool)0);
    }
    else ;
  }
  else ;
  
#line 13624 
  if ((tp->phy_flags & 16U) == 0U) {
    int tmp_19;
    
#line 13624 
    tmp_19 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
    
#line 13624 
    if (tmp_19 == 0) {
      int i_0;
      u32 tmp_6;
      int tmp_8;
      int tmp_9;
      int tmp_11;
      
#line 13628 
      tg3_phy_lpbk_set(tp,0U,(_Bool)0);
      
#line 13631 
      i_0 = 0;
      
#line 13631 
      goto ldv_58931;
      ldv_58930: 
#line 13632 
      ;
      
#line 13632 
      tmp_6 = (*(tp->read32))(tp,1120U);
      
#line 13632 
      if ((tmp_6 & 8U) != 0U) 
#line 13633 
                              goto ldv_58925; else ;
      
#line 13634 
      if (1) 
#line 13634 
             __const_udelay(4295000UL);
      else {
        
#line 13634 
        unsigned long __ms = 1UL;
        {
          unsigned long tmp_7;
          
#line 13634 
          goto ldv_58928;
          ldv_58927: 
#line 13635 
          ;
          
#line 13634 
          __const_udelay(4295000UL);
          ldv_58928: 
#line 13636 
          ;
          
#line 13634 
          tmp_7 = __ms;
          
#line 13634 
          __ms -= 1UL;
          
#line 13634 
          ;
          
#line 13634 
          if (tmp_7 != 0UL) 
#line 13636 
                            goto ldv_58927; else 
#line 13639 
                                                 goto ldv_58929;
          ldv_58929: 
#line 13640 
          ;
        }
      }
      
#line 13631 
      i_0 += 1;
      ldv_58931: 
#line 13632 
      ;
      
#line 13631 
      if (i_0 <= 99) 
#line 13633 
                     goto ldv_58930; else 
#line 13636 
                                          goto ldv_58925;
      ldv_58925: 
#line 13637 
      ;
      
#line 13637 
      tmp_8 = tg3_run_loopback(tp,1514U,(_Bool)0);
      
#line 13637 
      if (tmp_8 != 0) 
#line 13638 
                      *(data + 5U) |= 1ULL; else ;
      
#line 13639 
      tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 13639 
      if (tmp_9 != 0) {
        int tmp_10;
        
#line 13639 
        tmp_10 = tg3_run_loopback(tp,1514U,(_Bool)1);
        
#line 13639 
        if (tmp_10 != 0) 
#line 13641 
                         *(data + 5U) |= 4ULL; else ;
      }
      else ;
      
#line 13642 
      tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 13642 
      if (tmp_11 != 0) {
        int tmp_12;
        
#line 13642 
        tmp_12 = tg3_run_loopback(tp,jmb_pkt_sz + 14U,(_Bool)0);
        
#line 13642 
        if (tmp_12 != 0) 
#line 13644 
                         *(data + 5U) |= 2ULL; else ;
      }
      else ;
      
#line 13646 
      if ((int)do_extlpbk != 0) {
        int tmp_14;
        int tmp_15;
        int tmp_17;
        
#line 13647 
        tg3_phy_lpbk_set(tp,0U,(_Bool)1);
        {
          
#line 13653 
          unsigned long __ms_0 = 40UL;
          {
            unsigned long tmp_13;
            
#line 13653 
            goto ldv_58934;
            ldv_58933: 
#line 13654 
            ;
            
#line 13653 
            __const_udelay(4295000UL);
            ldv_58934: 
#line 13655 
            ;
            
#line 13653 
            tmp_13 = __ms_0;
            
#line 13653 
            __ms_0 -= 1UL;
            
#line 13653 
            ;
            
#line 13653 
            if (tmp_13 != 0UL) 
#line 13655 
                               goto ldv_58933; else 
#line 13658 
                                                    goto ldv_58935;
            ldv_58935: 
#line 13659 
            ;
          }
        }
        
#line 13655 
        tmp_14 = tg3_run_loopback(tp,1514U,(_Bool)0);
        
#line 13655 
        if (tmp_14 != 0) 
#line 13656 
                         *(data + 6U) |= 1ULL; else ;
        
#line 13658 
        tmp_15 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
        
#line 13658 
        if (tmp_15 != 0) {
          int tmp_16;
          
#line 13658 
          tmp_16 = tg3_run_loopback(tp,1514U,(_Bool)1);
          
#line 13658 
          if (tmp_16 != 0) 
#line 13660 
                           *(data + 6U) |= 4ULL; else ;
        }
        else ;
        
#line 13662 
        tmp_17 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
        
#line 13662 
        if (tmp_17 != 0) {
          int tmp_18;
          
#line 13662 
          tmp_18 = tg3_run_loopback(tp,jmb_pkt_sz + 14U,(_Bool)0);
          
#line 13662 
          if (tmp_18 != 0) 
#line 13664 
                           *(data + 6U) |= 2ULL; else ;
        }
        else ;
      }
      else ;
      
#line 13669 
      if ((tp->phy_flags & 256U) != 0U) 
#line 13670 
                                        tg3_phy_toggle_apd(tp,(_Bool)1); else ;
    }
    else ;
  }
  else ;
  
#line 13673 
  if (((*(data + 4U) | *(data + 5U)) | *(data + 6U)) != 0ULL) 
#line 13673 
                                                              err = -5; else 
                                                                    
#line 13673 
                                                                    err = 0;
  done: 
#line 13676 
  ;
  
#line 13677 
  tp->phy_flags |= eee_cap;
  
#line 13679 
  return err;
}


#line 13682  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_self_test(struct net_device *dev, struct ethtool_test *etest, u64 *data)
{
  int tmp_1;
  
#line 13685 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 13686 
  bool doextlpbk = (_Bool)((etest->flags & 4U) != 0U);
  
#line 13688 
  if ((tp->phy_flags & 1U) != 0U) {
    int tmp_0;
    
#line 13689 
    tmp_0 = tg3_power_up(tp);
    
#line 13689 
    if (tmp_0 != 0) {
      
#line 13690 
      etest->flags |= 2U;
      
#line 13691 
      memset((void *)data,1,64UL);
      
#line 13692 
      goto return_label;
    }
    else ;
    
#line 13694 
    tg3_ape_driver_state_change(tp,1);
  }
  else ;
  
#line 13697 
  memset((void *)data,0,64UL);
  
#line 13699 
  tmp_1 = tg3_test_nvram(tp);
  
#line 13699 
  if (tmp_1 != 0) {
    
#line 13700 
    etest->flags |= 2U;
    
#line 13701 
    *data = 1ULL;
  }
  else ;
  
#line 13703 
  if (! doextlpbk) {
    int tmp_2;
    
#line 13703 
    tmp_2 = tg3_test_link(tp);
    
#line 13703 
    if (tmp_2 != 0) {
      
#line 13704 
      etest->flags |= 2U;
      
#line 13705 
      *(data + 1U) = 1ULL;
    }
    else ;
  }
  else ;
  
#line 13707 
  if ((etest->flags & 1U) != 0U) {
    int err;
    bool tmp_3;
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    int tmp_8;
    bool tmp_9;
    
#line 13708 
    int err2 = 0;
    
#line 13708 
    int irq_sync = 0;
    
#line 13710 
    tmp_3 = netif_running((struct net_device const *)dev);
    
#line 13710 
    if ((int)tmp_3 != 0) {
      
#line 13711 
      tg3_phy_stop(tp);
      
#line 13712 
      tg3_netif_stop(tp);
      
#line 13713 
      irq_sync = 1;
    }
    else ;
    
#line 13716 
    tg3_full_lock(tp,irq_sync);
    
#line 13717 
    tg3_halt(tp,2,(_Bool)1);
    
#line 13718 
    err = tg3_nvram_lock(tp);
    
#line 13719 
    tg3_halt_cpu(tp,20480U);
    
#line 13720 
    tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 13720 
    if (tmp_4 == 0) 
#line 13721 
                    tg3_halt_cpu(tp,21504U); else ;
    
#line 13722 
    if (err == 0) 
#line 13723 
                  tg3_nvram_unlock(tp); else ;
    
#line 13725 
    if ((tp->phy_flags & 32U) != 0U) 
#line 13726 
                                     tg3_phy_reset(tp); else ;
    
#line 13728 
    tmp_5 = tg3_test_registers(tp);
    
#line 13728 
    if (tmp_5 != 0) {
      
#line 13729 
      etest->flags |= 2U;
      
#line 13730 
      *(data + 2U) = 1ULL;
    }
    else ;
    
#line 13733 
    tmp_6 = tg3_test_memory(tp);
    
#line 13733 
    if (tmp_6 != 0) {
      
#line 13734 
      etest->flags |= 2U;
      
#line 13735 
      *(data + 3U) = 1ULL;
    }
    else ;
    
#line 13738 
    if ((int)doextlpbk != 0) 
#line 13739 
                             etest->flags |= 8U; else ;
    
#line 13741 
    tmp_7 = tg3_test_loopback(tp,data,(_Bool)((bool)((int)doextlpbk) != 0));
    
#line 13741 
    if (tmp_7 != 0) 
#line 13742 
                    etest->flags |= 2U; else ;
    
#line 13744 
    tg3_full_unlock(tp);
    
#line 13746 
    tmp_8 = tg3_test_interrupt(tp);
    
#line 13746 
    if (tmp_8 != 0) {
      
#line 13747 
      etest->flags |= 2U;
      
#line 13748 
      *(data + 7U) = 1ULL;
    }
    else ;
    
#line 13751 
    tg3_full_lock(tp,0);
    
#line 13753 
    tg3_halt(tp,0,(_Bool)1);
    
#line 13754 
    tmp_9 = netif_running((struct net_device const *)dev);
    
#line 13754 
    if ((int)tmp_9 != 0) {
      
#line 13755 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
      
#line 13756 
      err2 = tg3_restart_hw(tp,(_Bool)1);
      
#line 13757 
      if (err2 == 0) 
#line 13758 
                     tg3_netif_start(tp); else ;
    }
    else ;
    
#line 13761 
    tg3_full_unlock(tp);
    
#line 13763 
    if (irq_sync != 0 && err2 == 0) 
#line 13764 
                                    tg3_phy_start(tp); else ;
  }
  else ;
  
#line 13766 
  if ((tp->phy_flags & 1U) != 0U) 
#line 13767 
                                  tg3_power_down_prepare(tp); else ;
  return_label: 
#line 13768 
                return;
}


#line 13771  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_hwtstamp_set(struct net_device *dev, struct ifreq *ifr)
{
  int __retres;
  struct hwtstamp_config stmpconf;
  int tmp_0;
  unsigned long tmp_1;
  bool tmp_2;
  int tmp_4;
  unsigned long tmp_3;
  
#line 13773 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 13776 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 13776 
  if (tmp_0 == 0) {
    
#line 13777 
    __retres = -95;
    
#line 13777 
    goto return_label;
  }
  else ;
  
#line 13779 
  tmp_1 = copy_from_user((void *)(& stmpconf),(void const *)ifr->ifr_ifru.ifru_data,12UL);
  
#line 13779 
  if (tmp_1 != 0UL) {
    
#line 13780 
    __retres = -14;
    
#line 13780 
    goto return_label;
  }
  else ;
  
#line 13782 
  if (stmpconf.flags != 0) {
    
#line 13783 
    __retres = -22;
    
#line 13783 
    goto return_label;
  }
  else ;
  
#line 13785 
  if ((unsigned int)stmpconf.tx_type > 1U) {
    
#line 13787 
    __retres = -34;
    
#line 13787 
    goto return_label;
  }
  else ;
  
#line 13789 
  switch (stmpconf.rx_filter) {
    case 0: 
#line 13790 
    ;
    
#line 13791 
    tp->rxptpctl = 0U;
    
#line 13792 
    goto ldv_58959;
    case 3: 
#line 13793 
    ;
    
#line 13794 
    tp->rxptpctl = 33554435U;
    
#line 13796 
    goto ldv_58959;
    case 4: 
#line 13797 
    ;
    
#line 13798 
    tp->rxptpctl = 33554433U;
    
#line 13800 
    goto ldv_58959;
    case 5: 
#line 13801 
    ;
    
#line 13802 
    tp->rxptpctl = 33554434U;
    
#line 13804 
    goto ldv_58959;
    case 12: 
#line 13805 
    ;
    
#line 13806 
    tp->rxptpctl = 25165839U;
    
#line 13808 
    goto ldv_58959;
    case 9: 
#line 13809 
    ;
    
#line 13810 
    tp->rxptpctl = 8388623U;
    
#line 13812 
    goto ldv_58959;
    case 6: 
#line 13813 
    ;
    
#line 13814 
    tp->rxptpctl = 16777231U;
    
#line 13816 
    goto ldv_58959;
    case 13: 
#line 13817 
    ;
    
#line 13818 
    tp->rxptpctl = 25165825U;
    
#line 13820 
    goto ldv_58959;
    case 10: 
#line 13821 
    ;
    
#line 13822 
    tp->rxptpctl = 8388609U;
    
#line 13824 
    goto ldv_58959;
    case 7: 
#line 13825 
    ;
    
#line 13826 
    tp->rxptpctl = 16777217U;
    
#line 13828 
    goto ldv_58959;
    case 14: 
#line 13829 
    ;
    
#line 13830 
    tp->rxptpctl = 25165826U;
    
#line 13832 
    goto ldv_58959;
    case 11: 
#line 13833 
    ;
    
#line 13834 
    tp->rxptpctl = 8388610U;
    
#line 13836 
    goto ldv_58959;
    case 8: 
#line 13837 
    ;
    
#line 13838 
    tp->rxptpctl = 16777218U;
    
#line 13840 
    goto ldv_58959;
    default: 
#line 13841 
    ;
    
#line 13842 
    __retres = -34;
    
#line 13842 
    goto return_label;
  }
  ldv_58959: 
#line 13845 
  ;
  
#line 13845 
  tmp_2 = netif_running((struct net_device const *)dev);
  
#line 13845 
  if ((int)tmp_2 != 0) {
    
#line 13845 
    if (tp->rxptpctl != 0U) 
#line 13846 
                            (*(tp->write32))(tp,1736U,tp->rxptpctl | 67108864U); else ;
  }
  else ;
  
#line 13849 
  if (stmpconf.tx_type == 1) 
#line 13850 
                             _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TX_TSTAMP_EN,(unsigned long *)(& tp->tg3_flags)); else 
                                                                    
#line 13852 
                                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TX_TSTAMP_EN,(unsigned long *)(& tp->tg3_flags));
  
#line 13855 
  tmp_3 = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)(& stmpconf),12UL);
  
#line 13855 
  if (tmp_3 != 0UL) 
#line 13855 
                    tmp_4 = -14; else 
#line 13855 
                                      tmp_4 = 0;
  
#line 13855 
  __retres = tmp_4;
  return_label: 
#line 13855 
                return __retres;
}


#line 13858  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_hwtstamp_get(struct net_device *dev, struct ifreq *ifr)
{
  int __retres;
  struct hwtstamp_config stmpconf;
  int tmp_0;
  int tmp_1;
  int tmp_4;
  unsigned long tmp_3_0;
  
#line 13860 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 13863 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 13863 
  if (tmp_0 == 0) {
    
#line 13864 
    __retres = -95;
    
#line 13864 
    goto return_label;
  }
  else ;
  
#line 13866 
  stmpconf.flags = 0;
  
#line 13867 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TX_TSTAMP_EN,(unsigned long *)(& tp->tg3_flags));
  
#line 13867 
  stmpconf.tx_type = tmp_1 != 0;
  
#line 13870 
  switch (tp->rxptpctl) {
    case (u32)0: 
#line 13871 
    ;
    
#line 13872 
    stmpconf.rx_filter = 0;
    
#line 13873 
    goto ldv_58980;
    case (u32)33554435: 
#line 13874 
    ;
    
#line 13875 
    stmpconf.rx_filter = 3;
    
#line 13876 
    goto ldv_58980;
    case (u32)33554433: 
#line 13877 
    ;
    
#line 13878 
    stmpconf.rx_filter = 4;
    
#line 13879 
    goto ldv_58980;
    case (u32)33554434: 
#line 13880 
    ;
    
#line 13881 
    stmpconf.rx_filter = 5;
    
#line 13882 
    goto ldv_58980;
    case (u32)25165839: 
#line 13883 
    ;
    
#line 13884 
    stmpconf.rx_filter = 12;
    
#line 13885 
    goto ldv_58980;
    case (u32)8388623: 
#line 13886 
    ;
    
#line 13887 
    stmpconf.rx_filter = 9;
    
#line 13888 
    goto ldv_58980;
    case (u32)16777231: 
#line 13889 
    ;
    
#line 13890 
    stmpconf.rx_filter = 6;
    
#line 13891 
    goto ldv_58980;
    case (u32)25165825: 
#line 13892 
    ;
    
#line 13893 
    stmpconf.rx_filter = 13;
    
#line 13894 
    goto ldv_58980;
    case (u32)8388609: 
#line 13895 
    ;
    
#line 13896 
    stmpconf.rx_filter = 10;
    
#line 13897 
    goto ldv_58980;
    case (u32)16777217: 
#line 13898 
    ;
    
#line 13899 
    stmpconf.rx_filter = 7;
    
#line 13900 
    goto ldv_58980;
    case (u32)25165826: 
#line 13901 
    ;
    
#line 13902 
    stmpconf.rx_filter = 14;
    
#line 13903 
    goto ldv_58980;
    case (u32)8388610: 
#line 13904 
    ;
    
#line 13905 
    stmpconf.rx_filter = 11;
    
#line 13906 
    goto ldv_58980;
    case (u32)16777218: 
#line 13907 
    ;
    
#line 13908 
    stmpconf.rx_filter = 8;
    
#line 13909 
    goto ldv_58980;
    default: 
#line 13910 
    ;
    {
      bool __warned;
      
#line 13911 
      int __ret_warn_once = 1;
      
#line 13911 
      if ((long)(__ret_warn_once != 0) != 0L) {
        int tmp_2;
        {
          
#line 13911 
          int __ret_warn_on = ! __warned;
          
#line 13911 
          if ((long)(__ret_warn_on != 0) != 0L) 
#line 13911 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c",13911); else ;
          
#line 13911 
          tmp_2 = (long)(__ret_warn_on != 0);
        }
        
#line 13911 
        if ((long)tmp_2 != 0L) 
#line 13911 
                               __warned = (_Bool)1; else ;
      }
      else ;
      
#line 13911 
      long tmp_3 = (long)(__ret_warn_once != 0);
    }
    
#line 13912 
    __retres = -34;
    
#line 13912 
    goto return_label;
  }
  ldv_58980: 
#line 13915 
  ;
  
#line 13916 
  tmp_3_0 = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)(& stmpconf),12UL);
  
#line 13916 
  if (tmp_3_0 != 0UL) 
#line 13916 
                      tmp_4 = -14; else 
#line 13916 
                                        tmp_4 = 0;
  
#line 13916 
  __retres = tmp_4;
  return_label: 
#line 13916 
                return __retres;
}


#line 13919  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
  int __retres;
  int err;
  int tmp_2;
  
#line 13921 
  struct mii_ioctl_data *data = if_mii(ifr);
  
#line 13922 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 13925 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 13925 
  if (tmp_2 != 0) {
    struct phy_device *phydev;
    int tmp_1;
    
#line 13927 
    if ((tp->phy_flags & 2U) == 0U) {
      
#line 13928 
      __retres = -11;
      
#line 13928 
      goto return_label;
    }
    else ;
    
#line 13929 
    phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
    
#line 13930 
    tmp_1 = phy_mii_ioctl(phydev,ifr,cmd);
    
#line 13930 
    __retres = tmp_1;
    
#line 13930 
    goto return_label;
  }
  else ;
  
#line 13933 
  switch (cmd) {
    int tmp_6;
    bool tmp_5;
    int tmp_7;
    int tmp_8;
    case 35143: 
#line 13934 
    ;
    
#line 13935 
    data->phy_id = (unsigned short)tp->phy_addr;
    case 35144: 
#line 13938 
    ;
    {
      u32 mii_regval;
      int tmp_4;
      bool tmp_3;
      
#line 13941 
      if ((tp->phy_flags & 16U) != 0U) 
#line 13942 
                                       goto ldv_59011; else ;
      
#line 13944 
      tmp_3 = netif_running((struct net_device const *)dev);
      
#line 13944 
      if (tmp_3) 
#line 13944 
                 tmp_4 = 0; else 
#line 13944 
                                 tmp_4 = 1;
      
#line 13944 
      if (tmp_4) {
        
#line 13945 
        __retres = -11;
        
#line 13945 
        goto return_label;
      }
      else ;
      
#line 13947 
      ldv_spin_lock_bh_123(& tp->lock);
      
#line 13948 
      err = __tg3_readphy(tp,(unsigned int)data->phy_id & 31U,(int)data->reg_num & 31,& mii_regval);
      
#line 13950 
      ldv_spin_unlock_bh_124(& tp->lock);
      
#line 13952 
      data->val_out = (unsigned short)mii_regval;
      
#line 13954 
      __retres = err;
      
#line 13954 
      goto return_label;
    }
    case 35145: 
#line 13957 
    ;
    
#line 13958 
    if ((tp->phy_flags & 16U) != 0U) 
#line 13959 
                                     goto ldv_59011; else ;
    
#line 13961 
    tmp_5 = netif_running((struct net_device const *)dev);
    
#line 13961 
    if (tmp_5) 
#line 13961 
               tmp_6 = 0; else 
#line 13961 
                               tmp_6 = 1;
    
#line 13961 
    if (tmp_6) {
      
#line 13962 
      __retres = -11;
      
#line 13962 
      goto return_label;
    }
    else ;
    
#line 13964 
    ldv_spin_lock_bh_125(& tp->lock);
    
#line 13965 
    err = __tg3_writephy(tp,(unsigned int)data->phy_id & 31U,(int)data->reg_num & 31,(unsigned int)data->val_in);
    
#line 13967 
    ldv_spin_unlock_bh_126(& tp->lock);
    
#line 13969 
    __retres = err;
    
#line 13969 
    goto return_label;
    case 35248: 
#line 13971 
    ;
    
#line 13972 
    tmp_7 = tg3_hwtstamp_set(dev,ifr);
    
#line 13972 
    __retres = tmp_7;
    
#line 13972 
    goto return_label;
    case 35249: 
#line 13974 
    ;
    
#line 13975 
    tmp_8 = tg3_hwtstamp_get(dev,ifr);
    
#line 13975 
    __retres = tmp_8;
    
#line 13975 
    goto return_label;
    default: 
#line 13977 
    ;
    
#line 13979 
    goto ldv_59011;
  }
  ldv_59011: 
#line 13981 
  ;
  
#line 13981 
  __retres = -95;
  return_label: 
#line 13981 
                return __retres;
}


#line 13984  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)
{
  int __retres;
  
#line 13986 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 13988 
  memcpy((void *)ec,(void const *)(& tp->coal),92UL);
  
#line 13989 
  __retres = 0;
  
#line 13989 
  return __retres;
}


#line 13992  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)
{
  int __retres;
  int tmp_0;
  bool tmp_1;
  
#line 13994 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 13995 
  u32 max_rxcoal_tick_int = 0U;
  
#line 13995 
  u32 max_txcoal_tick_int = 0U;
  
#line 13996 
  u32 max_stat_coal_ticks = 0U;
  
#line 13996 
  u32 min_stat_coal_ticks = 0U;
  
#line 13998 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 13998 
  if (tmp_0 == 0) {
    
#line 13999 
    max_rxcoal_tick_int = 1023U;
    
#line 14000 
    max_txcoal_tick_int = 1023U;
    
#line 14001 
    max_stat_coal_ticks = 3600012288U;
    
#line 14002 
    min_stat_coal_ticks = 100U;
  }
  else ;
  
#line 14005 
  if (((((((((ec->rx_coalesce_usecs > 1023U || ec->tx_coalesce_usecs > 1023U) || ec->rx_max_coalesced_frames > 255U) || ec->tx_max_coalesced_frames > 255U) || ec->rx_coalesce_usecs_irq > max_rxcoal_tick_int) || ec->tx_coalesce_usecs_irq > max_txcoal_tick_int) || ec->rx_max_coalesced_frames_irq > 255U) || ec->tx_max_coalesced_frames_irq > 255U) || ec->stats_block_coalesce_usecs > max_stat_coal_ticks) || ec->stats_block_coalesce_usecs < min_stat_coal_ticks) {
    
#line 14015 
    __retres = -22;
    
#line 14015 
    goto return_label;
  }
  else ;
  
#line 14018 
  if (ec->rx_coalesce_usecs == 0U && ec->rx_max_coalesced_frames == 0U) {
    
#line 14020 
    __retres = -22;
    
#line 14020 
    goto return_label;
  }
  else ;
  
#line 14023 
  if (ec->tx_coalesce_usecs == 0U && ec->tx_max_coalesced_frames == 0U) {
    
#line 14025 
    __retres = -22;
    
#line 14025 
    goto return_label;
  }
  else ;
  
#line 14028 
  tp->coal.rx_coalesce_usecs = ec->rx_coalesce_usecs;
  
#line 14029 
  tp->coal.tx_coalesce_usecs = ec->tx_coalesce_usecs;
  
#line 14030 
  tp->coal.rx_max_coalesced_frames = ec->rx_max_coalesced_frames;
  
#line 14031 
  tp->coal.tx_max_coalesced_frames = ec->tx_max_coalesced_frames;
  
#line 14032 
  tp->coal.rx_coalesce_usecs_irq = ec->rx_coalesce_usecs_irq;
  
#line 14033 
  tp->coal.tx_coalesce_usecs_irq = ec->tx_coalesce_usecs_irq;
  
#line 14034 
  tp->coal.rx_max_coalesced_frames_irq = ec->rx_max_coalesced_frames_irq;
  
#line 14035 
  tp->coal.tx_max_coalesced_frames_irq = ec->tx_max_coalesced_frames_irq;
  
#line 14036 
  tp->coal.stats_block_coalesce_usecs = ec->stats_block_coalesce_usecs;
  
#line 14038 
  tmp_1 = netif_running((struct net_device const *)dev);
  
#line 14038 
  if ((int)tmp_1 != 0) {
    
#line 14039 
    tg3_full_lock(tp,0);
    
#line 14040 
    __tg3_set_coalesce(tp,& tp->coal);
    
#line 14041 
    tg3_full_unlock(tp);
  }
  else ;
  
#line 14043 
  __retres = 0;
  return_label: 
#line 14043 
                return __retres;
}


#line 14046  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_set_eee(struct net_device *dev, struct ethtool_eee *edata)
{
  int __retres;
  bool tmp_0;
  
#line 14048 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 14050 
  if ((tp->phy_flags & 262144U) == 0U) {
    
#line 14051 
    netdev_warn((struct net_device const *)tp->dev,"Board does not support EEE!\n");
    
#line 14052 
    __retres = -95;
    
#line 14052 
    goto return_label;
  }
  else ;
  
#line 14055 
  if (edata->advertised != tp->eee.advertised) {
    
#line 14056 
    netdev_warn((struct net_device const *)tp->dev,"Direct manipulation of EEE advertisement is not supported\n");
    
#line 14058 
    __retres = -22;
    
#line 14058 
    goto return_label;
  }
  else ;
  
#line 14061 
  if (edata->tx_lpi_timer > 65535U) {
    
#line 14062 
    netdev_warn((struct net_device const *)tp->dev,"Maximal Tx Lpi timer supported is %#x(u)\n",65535);
    
#line 14065 
    __retres = -22;
    
#line 14065 
    goto return_label;
  }
  else ;
  
#line 14068 
  tp->eee = *edata;
  
#line 14070 
  tp->phy_flags |= 8U;
  
#line 14071 
  tg3_warn_mgmt_link_flap(tp);
  
#line 14073 
  tmp_0 = netif_running((struct net_device const *)tp->dev);
  
#line 14073 
  if ((int)tmp_0 != 0) {
    
#line 14074 
    tg3_full_lock(tp,0);
    
#line 14075 
    tg3_setup_eee(tp);
    
#line 14076 
    tg3_phy_reset(tp);
    
#line 14077 
    tg3_full_unlock(tp);
  }
  else ;
  
#line 14080 
  __retres = 0;
  return_label: 
#line 14080 
                return __retres;
}


#line 14083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_eee(struct net_device *dev, struct ethtool_eee *edata)
{
  int __retres;
  
#line 14085 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 14087 
  if ((tp->phy_flags & 262144U) == 0U) {
    
#line 14088 
    netdev_warn((struct net_device const *)tp->dev,"Board does not support EEE!\n");
    
#line 14090 
    __retres = -95;
    
#line 14090 
    goto return_label;
  }
  else ;
  
#line 14093 
  *edata = tp->eee;
  
#line 14094 
  __retres = 0;
  return_label: 
#line 14094 
                return __retres;
}


#line 14097  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct ethtool_ops const tg3_ethtool_ops = {.get_settings = & tg3_get_settings, .set_settings = & tg3_set_settings, .get_drvinfo = & tg3_get_drvinfo, .get_regs_len = & tg3_get_regs_len, .get_regs = & tg3_get_regs, .get_wol = & tg3_get_wol, .set_wol = & tg3_set_wol, .get_msglevel = & tg3_get_msglevel, .set_msglevel = & tg3_set_msglevel, .nway_reset = & tg3_nway_reset, .get_link = & ethtool_op_get_link, .get_eeprom_len = & tg3_get_eeprom_len, .get_eeprom = & tg3_get_eeprom, .set_eeprom = & tg3_set_eeprom, .get_coalesce = & tg3_get_coalesce, .set_coalesce = & tg3_set_coalesce, .get_ringparam = & tg3_get_ringparam, .set_ringparam = & tg3_set_ringparam, .get_pauseparam = & tg3_get_pauseparam, .set_pauseparam = & tg3_set_pauseparam, .self_test = & tg3_self_test, .get_strings = & tg3_get_strings, .set_phys_id = & tg3_set_phys_id, .get_ethtool_stats = & tg3_get_ethtool_stats, .begin = (int (*)(struct net_device *))0, .complete = (void (*)(struct net_device *))0, .get_priv_flags = (u32 (*)(struct net_device *))0, .set_priv_flags = (int (*)(struct net_device *, u32 ))0, .get_sset_count = & tg3_get_sset_count, .get_rxnfc = & tg3_get_rxnfc, .set_rxnfc = (int (*)(struct net_device *, struct ethtool_rxnfc *))0, .flash_device = (int (*)(struct net_device *, struct ethtool_flash *))0, .reset = (int (*)(struct net_device *, u32 *))0, .get_rxfh_key_size = (u32 (*)(struct net_device *))0, .get_rxfh_indir_size = & tg3_get_rxfh_indir_size, .get_rxfh = & tg3_get_rxfh, .set_rxfh = & tg3_set_rxfh, .get_channels = & tg3_get_channels, .set_channels = & tg3_set_channels, .get_dump_flag = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_dump_data = (int (*)(struct net_device *, struct ethtool_dump *, void *))0, .set_dump = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_ts_info = & tg3_get_ts_info, .get_module_info = (int (*)(struct net_device *, struct ethtool_modinfo *))0, .get_module_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_eee = & tg3_get_eee, .set_eee = & tg3_set_eee, .get_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void *))0, .set_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void const *))0};

#line 14134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct rtnl_link_stats64 *tg3_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
{
  struct rtnl_link_stats64 *__retres;
  
#line 14137 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 14139 
  ldv_spin_lock_bh_127(& tp->lock);
  
#line 14140 
  if (tp->hw_stats == (struct tg3_hw_stats *)0) {
    
#line 14141 
    *stats = tp->net_stats_prev;
    
#line 14142 
    ldv_spin_unlock_bh_128(& tp->lock);
    
#line 14143 
    __retres = stats;
    
#line 14143 
    goto return_label;
  }
  else ;
  
#line 14146 
  tg3_get_nstats(tp,stats);
  
#line 14147 
  ldv_spin_unlock_bh_129(& tp->lock);
  
#line 14149 
  __retres = stats;
  return_label: 
#line 14149 
                return __retres;
}


#line 14152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_set_rx_mode(struct net_device *dev)
{
  int tmp_1;
  bool tmp_0;
  
#line 14154 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 14156 
  tmp_0 = netif_running((struct net_device const *)dev);
  
#line 14156 
  if (tmp_0) 
#line 14156 
             tmp_1 = 0; else 
#line 14156 
                             tmp_1 = 1;
  
#line 14156 
  if (tmp_1) 
#line 14157 
             goto return_label; else ;
  
#line 14159 
  tg3_full_lock(tp,0);
  
#line 14160 
  __tg3_set_rx_mode(dev);
  
#line 14161 
  tg3_full_unlock(tp);
  return_label: 
#line 14162 
                return;
}


#line 14164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static void tg3_set_mtu(struct net_device *dev, struct tg3 *tp, int new_mtu)
{
  
#line 14167 
  dev->mtu = (unsigned int)new_mtu;
  
#line 14169 
  if (new_mtu > 1500) {
    int tmp;
    
#line 14170 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 14170 
    if (tmp != 0) {
      
#line 14171 
      netdev_update_features(dev);
      
#line 14172 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    }
    else 
#line 14174 
         _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
  }
  else {
    int tmp_0;
    
#line 14177 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 14177 
    if (tmp_0 != 0) {
      
#line 14178 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 14179 
      netdev_update_features(dev);
    }
    else ;
    
#line 14181 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags));
  }
  
#line 14183 
  return;
}


#line 14185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_change_mtu(struct net_device *dev, int new_mtu)
{
  int __retres;
  int err;
  int tmp_3;
  bool tmp_2;
  
#line 14187 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 14189 
  bool reset_phy = (_Bool)0;
  
#line 14191 
  if (new_mtu <= 59) {
    
#line 14192 
    __retres = -22;
    
#line 14192 
    goto return_label;
  }
  else {
    int tmp_1;
    int tmp_0;
    
#line 14191 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 14191 
    if (tmp_0 != 0) 
#line 14191 
                    tmp_1 = 9000; else 
#line 14191 
                                       tmp_1 = 1500;
    
#line 14191 
    ;
    
#line 14191 
    if (tmp_1 < new_mtu) {
      
#line 14192 
      __retres = -22;
      
#line 14192 
      goto return_label;
    }
    else ;
  }
  
#line 14194 
  tmp_2 = netif_running((struct net_device const *)dev);
  
#line 14194 
  if (tmp_2) 
#line 14194 
             tmp_3 = 0; else 
#line 14194 
                             tmp_3 = 1;
  
#line 14194 
  if (tmp_3) {
    
#line 14198 
    tg3_set_mtu(dev,tp,new_mtu);
    
#line 14199 
    __retres = 0;
    
#line 14199 
    goto return_label;
  }
  else ;
  
#line 14202 
  tg3_phy_stop(tp);
  
#line 14204 
  tg3_netif_stop(tp);
  
#line 14206 
  tg3_set_mtu(dev,tp,new_mtu);
  
#line 14208 
  tg3_full_lock(tp,1);
  
#line 14210 
  tg3_halt(tp,0,(_Bool)1);
  
#line 14215 
  if (tp->pci_chip_rev_id >> 12 == 358246U) 
#line 14216 
                                            reset_phy = (_Bool)1; else ;
  
#line 14218 
  err = tg3_restart_hw(tp,(_Bool)((bool)((int)reset_phy) != 0));
  
#line 14220 
  if (err == 0) 
#line 14221 
                tg3_netif_start(tp); else ;
  
#line 14223 
  tg3_full_unlock(tp);
  
#line 14225 
  if (err == 0) 
#line 14226 
                tg3_phy_start(tp); else ;
  
#line 14228 
  __retres = err;
  return_label: 
#line 14228 
                return __retres;
}


#line 14231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct net_device_ops const tg3_netdev_ops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & tg3_open, .ndo_stop = & tg3_close, .ndo_start_xmit = & tg3_start_xmit, .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & tg3_set_rx_mode, .ndo_set_mac_address = & tg3_set_mac_addr, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & tg3_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & tg3_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = & tg3_tx_timeout, .ndo_get_stats64 = & tg3_get_stats64, .ndo_get_stats = (struct net_device_stats *(*)(struct net_device *))0, .ndo_vlan_rx_add_vid = (int (*)(struct net_device *, __be16 , u16 ))0, .ndo_vlan_rx_kill_vid = (int (*)(struct net_device *, __be16 , u16 ))0, .ndo_poll_controller = & tg3_poll_controller, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = (int (*)(struct napi_struct *))0, .ndo_set_vf_mac = (int (*)(struct net_device *, int , u8 *))0, .ndo_set_vf_vlan = (int (*)(struct net_device *, int , u16 , u8 ))0, .ndo_set_vf_rate = (int (*)(struct net_device *, int , int , int ))0, .ndo_set_vf_spoofchk = (int (*)(struct net_device *, int , bool ))0, .ndo_get_vf_config = (int (*)(struct net_device *, int , struct ifla_vf_info *))0, .ndo_set_vf_link_state = (int (*)(struct net_device *, int , int ))0, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = (int (*)(struct net_device *, u8 ))0, .ndo_fcoe_enable = (int (*)(struct net_device *))0, .ndo_fcoe_disable = (int (*)(struct net_device *))0, .ndo_fcoe_ddp_setup = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_ddp_done = (int (*)(struct net_device *, u16 ))0, .ndo_fcoe_ddp_target = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = (int (*)(struct net_device *, struct sk_buff const *, u16 , u32 ))0, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = & tg3_fix_features, .ndo_set_features = & tg3_set_features, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ))0, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = (int (*)(struct net_device *, struct netdev_phys_item_id *))0, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_del_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_dfwd_add_station = (void *(*)(struct net_device *, struct net_device *))0, .ndo_dfwd_del_station = (void (*)(struct net_device *, void *))0, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = (netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t ))0, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 14249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_eeprom_size(struct tg3 *tp)
{
  u32 cursize;
  u32 val;
  u32 magic;
  int tmp;
  int tmp_0;
  
#line 14253 
  tp->nvram_size = 65536U;
  
#line 14255 
  tmp = tg3_nvram_read(tp,0U,& magic);
  
#line 14255 
  if (tmp != 0) 
#line 14256 
                goto return_label; else ;
  
#line 14258 
  if ((magic != 1721324970U && (magic & 4278190080U) != 2768240640U) && (magic & 65535U) != 43981U) 
    
#line 14261 
    goto return_label; else ;
  
#line 14268 
  cursize = 16U;
  
#line 14270 
  goto ldv_59071;
  ldv_59070: 
#line 14271 
  ;
  
#line 14271 
  tmp_0 = tg3_nvram_read(tp,cursize,& val);
  
#line 14271 
  if (tmp_0 != 0) 
#line 14272 
                  goto return_label; else ;
  
#line 14274 
  if (val == magic) 
#line 14275 
                    goto ldv_59069; else ;
  
#line 14277 
  cursize <<= 1;
  ldv_59071: 
#line 14278 
  ;
  
#line 14270 
  if (tp->nvram_size > cursize) 
#line 14272 
                                goto ldv_59070; else 
#line 14275 
                                                     goto ldv_59069;
  ldv_59069: 
#line 14276 
  ;
  
#line 14280 
  tp->nvram_size = cursize;
  return_label: 
#line 14281 
                return;
}


#line 14283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_nvram_size(struct tg3 *tp)
{
  u32 val;
  int tmp;
  int tmp_3;
  
#line 14287 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 14287 
  if (tmp != 0) 
#line 14288 
                goto return_label;
  else {
    int tmp_0;
    
#line 14287 
    tmp_0 = tg3_nvram_read(tp,0U,& val);
    
#line 14287 
    if (tmp_0 != 0) 
#line 14288 
                    goto return_label; else ;
  }
  
#line 14291 
  if (val != 1721324970U) {
    
#line 14292 
    tg3_get_eeprom_size(tp);
    
#line 14293 
    goto return_label;
  }
  else ;
  
#line 14296 
  tmp_3 = tg3_nvram_read(tp,240U,& val);
  
#line 14296 
  if (tmp_3 == 0) {
    
#line 14297 
    if (val != 0U) {
      int tmp_2;
      
#line 14309 
      if (0 != 0) 
#line 14309 
                  tmp_2 = (int)((unsigned short)(((int)((unsigned short)val) << 8) | ((int)((unsigned short)val) >> 8))) * 1024;
      else {
        __u16 tmp_1;
        
#line 14309 
        tmp_1 = __fswab16((unsigned short)((int)((unsigned short)val)));
        
#line 14309 
        tmp_2 = (int)tmp_1 * 1024;
      }
      
#line 14309 
      tp->nvram_size = (unsigned int)tmp_2;
      
#line 14310 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 14313 
  tp->nvram_size = 524288U;
  return_label: 
#line 14314 
                return;
}


#line 14316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_nvram_info(struct tg3 *tp)
{
  u32 nvcfg1;
  
#line 14320 
  nvcfg1 = (*(tp->read32))(tp,28692U);
  
#line 14321 
  if ((nvcfg1 & 1U) != 0U) 
#line 14322 
                           _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
  else {
    
#line 14324 
    nvcfg1 &= 2147483647U;
    
#line 14325 
    (*(tp->write32))(tp,28692U,nvcfg1);
  }
  
#line 14328 
  if (tp->pci_chip_rev_id >> 12 == 4U) 
#line 14328 
                                       goto _LOR;
  else {
    int tmp;
    
#line 14328 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 14328 
    if (tmp != 0) {
      _LOR: {
              
#line 14330 
              switch (nvcfg1 & 50331651U) {
                case (unsigned int)33554435: 
#line 14331 
                ;
                
#line 14332 
                tp->nvram_jedecnum = 31U;
                
#line 14333 
                tp->nvram_pagesize = 264U;
                
#line 14334 
                _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
                
#line 14335 
                goto ldv_59081;
                case (unsigned int)3: 
#line 14336 
                ;
                
#line 14337 
                tp->nvram_jedecnum = 31U;
                
#line 14338 
                tp->nvram_pagesize = 256U;
                
#line 14339 
                goto ldv_59081;
                case (unsigned int)33554432: 
#line 14340 
                ;
                
#line 14341 
                tp->nvram_jedecnum = 31U;
                
#line 14342 
                tp->nvram_pagesize = 524288U;
                
#line 14343 
                _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
                
#line 14344 
                goto ldv_59081;
                case (unsigned int)50331649: 
#line 14345 
                ;
                
#line 14346 
                tp->nvram_jedecnum = 32U;
                
#line 14347 
                tp->nvram_pagesize = 256U;
                
#line 14348 
                _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
                
#line 14349 
                goto ldv_59081;
                case (unsigned int)16777219: 
#line 14350 
                ;
                
#line 14351 
                tp->nvram_jedecnum = 79U;
                
#line 14352 
                tp->nvram_pagesize = 256U;
                
#line 14353 
                goto ldv_59081;
                case (unsigned int)1: 
#line 14354 
                ;
                case (unsigned int)33554433: 
#line 14355 
                ;
                
#line 14356 
                tp->nvram_jedecnum = 191U;
                
#line 14357 
                tp->nvram_pagesize = 4098U;
                
#line 14358 
                goto ldv_59081;
              }
              ldv_59081: 
#line 14360 
              ;
            }
    }
    else {
      
#line 14361 
      tp->nvram_jedecnum = 31U;
      
#line 14362 
      tp->nvram_pagesize = 264U;
      
#line 14363 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    }
  }
  
#line 14365 
  return;
}


#line 14367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_nvram_get_pagesize(struct tg3 *tp, u32 nvmcfg1)
{
  
#line 14369 
  switch (nvmcfg1 & 1879048192U) {
    case (unsigned int)0: 
#line 14370 
    ;
    
#line 14371 
    tp->nvram_pagesize = 256U;
    
#line 14372 
    goto ldv_59093;
    case (unsigned int)268435456: 
#line 14373 
    ;
    
#line 14374 
    tp->nvram_pagesize = 512U;
    
#line 14375 
    goto ldv_59093;
    case (unsigned int)536870912: 
#line 14376 
    ;
    
#line 14377 
    tp->nvram_pagesize = 1024U;
    
#line 14378 
    goto ldv_59093;
    case (unsigned int)805306368: 
#line 14379 
    ;
    
#line 14380 
    tp->nvram_pagesize = 2048U;
    
#line 14381 
    goto ldv_59093;
    case (unsigned int)1073741824: 
#line 14382 
    ;
    
#line 14383 
    tp->nvram_pagesize = 4096U;
    
#line 14384 
    goto ldv_59093;
    case (unsigned int)1342177280: 
#line 14385 
    ;
    
#line 14386 
    tp->nvram_pagesize = 264U;
    
#line 14387 
    goto ldv_59093;
    case (unsigned int)1610612736: 
#line 14388 
    ;
    
#line 14389 
    tp->nvram_pagesize = 528U;
    
#line 14390 
    goto ldv_59093;
  }
  ldv_59093: 
#line 14392 
  ;
  
#line 14393 
  return;
}


#line 14394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_5752_nvram_info(struct tg3 *tp)
{
  u32 nvcfg1;
  int tmp;
  
#line 14398 
  nvcfg1 = (*(tp->read32))(tp,28692U);
  
#line 14401 
  if ((nvcfg1 & 134217728U) != 0U) 
#line 14402 
                                   _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PROTECTED_NVRAM,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 14404 
  switch (nvcfg1 & 62914563U) {
    case (unsigned int)0: 
#line 14405 
    ;
    case (unsigned int)33554432: 
#line 14406 
    ;
    
#line 14407 
    tp->nvram_jedecnum = 31U;
    
#line 14408 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14409 
    goto ldv_59106;
    case (unsigned int)33554435: 
#line 14410 
    ;
    
#line 14411 
    tp->nvram_jedecnum = 31U;
    
#line 14412 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14413 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14414 
    goto ldv_59106;
    case (unsigned int)37748736: 
#line 14415 
    ;
    case (unsigned int)37748738: 
#line 14416 
    ;
    case (unsigned int)37748737: 
#line 14417 
    ;
    
#line 14418 
    tp->nvram_jedecnum = 32U;
    
#line 14419 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14420 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14421 
    goto ldv_59106;
  }
  ldv_59106: 
#line 14424 
  ;
  
#line 14424 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
  
#line 14424 
  if (tmp != 0) 
#line 14425 
                tg3_nvram_get_pagesize(tp,nvcfg1);
  else {
    
#line 14428 
    tp->nvram_pagesize = 524288U;
    
#line 14430 
    nvcfg1 &= 2147483647U;
    
#line 14431 
    (*(tp->write32))(tp,28692U,nvcfg1);
  }
  
#line 14433 
  return;
}


#line 14435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_5755_nvram_info(struct tg3 *tp)
{
  u32 nvcfg1;
  
#line 14437 
  u32 protect = 0U;
  
#line 14439 
  nvcfg1 = (*(tp->read32))(tp,28692U);
  
#line 14442 
  if ((nvcfg1 & 134217728U) != 0U) {
    
#line 14443 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PROTECTED_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14444 
    protect = 1U;
  }
  else ;
  
#line 14447 
  nvcfg1 &= 62914563U;
  
#line 14448 
  switch (nvcfg1) {
    case (u32)54525953: 
#line 14449 
    ;
    case (u32)54525954: 
#line 14450 
    ;
    case (u32)54525952: 
#line 14451 
    ;
    case (u32)33554435: 
#line 14452 
    ;
    
#line 14453 
    tp->nvram_jedecnum = 31U;
    
#line 14454 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14455 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14456 
    tp->nvram_pagesize = 264U;
    
#line 14457 
    if (nvcfg1 == 54525953U || nvcfg1 == 33554435U) {
      int tmp;
      
#line 14459 
      if (protect != 0U) 
#line 14459 
                         tmp = 254464; else 
#line 14459 
                                            tmp = 524288;
      
#line 14459 
      tp->nvram_size = (unsigned int)tmp;
    }
    else 
      
#line 14461 
      if (nvcfg1 == 54525954U) {
        int tmp_0;
        
#line 14462 
        if (protect != 0U) 
#line 14462 
                           tmp_0 = 127488; else 
#line 14462 
                                                tmp_0 = 262144;
        
#line 14462 
        tp->nvram_size = (unsigned int)tmp_0;
      }
      else {
        int tmp_1;
        
#line 14465 
        if (protect != 0U) 
#line 14465 
                           tmp_1 = 127488; else 
#line 14465 
                                                tmp_1 = 131072;
        
#line 14465 
        tp->nvram_size = (unsigned int)tmp_1;
      }
    
#line 14467 
    goto ldv_59120;
    case (u32)37748736: 
#line 14468 
    ;
    case (u32)37748738: 
#line 14469 
    ;
    case (u32)37748737: 
#line 14470 
    ;
    
#line 14471 
    tp->nvram_jedecnum = 32U;
    
#line 14472 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14473 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14474 
    tp->nvram_pagesize = 256U;
    
#line 14475 
    if (nvcfg1 == 37748736U) {
      int tmp_2;
      
#line 14477 
      if (protect != 0U) 
#line 14477 
                         tmp_2 = 65536; else 
#line 14477 
                                             tmp_2 = 131072;
      
#line 14476 
      tp->nvram_size = (unsigned int)tmp_2;
    }
    else 
      
#line 14479 
      if (nvcfg1 == 37748738U) {
        int tmp_3;
        
#line 14481 
        if (protect != 0U) 
#line 14481 
                           tmp_3 = 65536; else 
#line 14481 
                                               tmp_3 = 262144;
        
#line 14480 
        tp->nvram_size = (unsigned int)tmp_3;
      }
      else {
        int tmp_4;
        
#line 14485 
        if (protect != 0U) 
#line 14485 
                           tmp_4 = 131072; else 
#line 14485 
                                                tmp_4 = 524288;
        
#line 14484 
        tp->nvram_size = (unsigned int)tmp_4;
      }
    
#line 14487 
    goto ldv_59120;
  }
  ldv_59120: 
#line 14489 
  ;
  
#line 14490 
  return;
}


#line 14491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_5787_nvram_info(struct tg3 *tp)
{
  u32 nvcfg1;
  
#line 14495 
  nvcfg1 = (*(tp->read32))(tp,28692U);
  
#line 14497 
  switch (nvcfg1 & 62914563U) {
    case (unsigned int)50331651: 
#line 14498 
    ;
    case (unsigned int)50331650: 
#line 14499 
    ;
    case (unsigned int)50331648: 
#line 14500 
    ;
    case (unsigned int)33554432: 
#line 14501 
    ;
    
#line 14502 
    tp->nvram_jedecnum = 31U;
    
#line 14503 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14504 
    tp->nvram_pagesize = 524288U;
    
#line 14506 
    nvcfg1 &= 2147483647U;
    
#line 14507 
    (*(tp->write32))(tp,28692U,nvcfg1);
    
#line 14508 
    goto ldv_59132;
    case (unsigned int)33554435: 
#line 14509 
    ;
    case (unsigned int)54525953: 
#line 14510 
    ;
    case (unsigned int)54525954: 
#line 14511 
    ;
    case (unsigned int)54525952: 
#line 14512 
    ;
    
#line 14513 
    tp->nvram_jedecnum = 31U;
    
#line 14514 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14515 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14516 
    tp->nvram_pagesize = 264U;
    
#line 14517 
    goto ldv_59132;
    case (unsigned int)37748736: 
#line 14518 
    ;
    case (unsigned int)37748738: 
#line 14519 
    ;
    case (unsigned int)37748737: 
#line 14520 
    ;
    
#line 14521 
    tp->nvram_jedecnum = 32U;
    
#line 14522 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14523 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14524 
    tp->nvram_pagesize = 256U;
    
#line 14525 
    goto ldv_59132;
  }
  ldv_59132: 
#line 14527 
  ;
  
#line 14528 
  return;
}


#line 14529  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_5761_nvram_info(struct tg3 *tp)
{
  u32 nvcfg1;
  
#line 14531 
  u32 protect = 0U;
  
#line 14533 
  nvcfg1 = (*(tp->read32))(tp,28692U);
  
#line 14536 
  if ((nvcfg1 & 134217728U) != 0U) {
    
#line 14537 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PROTECTED_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14538 
    protect = 1U;
  }
  else ;
  
#line 14541 
  nvcfg1 &= 62914563U;
  
#line 14542 
  switch (nvcfg1) {
    case (u32)3: 
#line 14543 
    ;
    case (u32)0: 
#line 14544 
    ;
    case (u32)2: 
#line 14545 
    ;
    case (u32)1: 
#line 14546 
    ;
    case (u32)8388611: 
#line 14547 
    ;
    case (u32)8388608: 
#line 14548 
    ;
    case (u32)8388610: 
#line 14549 
    ;
    case (u32)8388609: 
#line 14550 
    ;
    
#line 14551 
    tp->nvram_jedecnum = 31U;
    
#line 14552 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14553 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14554 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM_ADDR_TRANS,(unsigned long *)(& tp->tg3_flags));
    
#line 14555 
    tp->nvram_pagesize = 256U;
    
#line 14556 
    goto ldv_59153;
    case (u32)33554433: 
#line 14557 
    ;
    case (u32)33554432: 
#line 14558 
    ;
    case (u32)33554434: 
#line 14559 
    ;
    case (u32)33554435: 
#line 14560 
    ;
    case (u32)41943041: 
#line 14561 
    ;
    case (u32)41943040: 
#line 14562 
    ;
    case (u32)41943042: 
#line 14563 
    ;
    case (u32)41943043: 
#line 14564 
    ;
    
#line 14565 
    tp->nvram_jedecnum = 32U;
    
#line 14566 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14567 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14568 
    tp->nvram_pagesize = 256U;
    
#line 14569 
    goto ldv_59153;
  }
  ldv_59153: 
#line 14572 
  ;
  
#line 14572 
  if (protect != 0U) 
#line 14573 
                     tp->nvram_size = (*(tp->read32))(tp,28720U);
  else {
    
#line 14575 
    switch (nvcfg1) {
      case (u32)1: 
#line 14576 
      ;
      case (u32)8388609: 
#line 14577 
      ;
      case (u32)33554435: 
#line 14578 
      ;
      case (u32)41943043: 
#line 14579 
      ;
      
#line 14580 
      tp->nvram_size = 2097152U;
      
#line 14581 
      goto ldv_59166;
      case (u32)2: 
#line 14582 
      ;
      case (u32)8388610: 
#line 14583 
      ;
      case (u32)33554434: 
#line 14584 
      ;
      case (u32)41943042: 
#line 14585 
      ;
      
#line 14586 
      tp->nvram_size = 1048576U;
      
#line 14587 
      goto ldv_59166;
      case (u32)0: 
#line 14588 
      ;
      case (u32)8388608: 
#line 14589 
      ;
      case (u32)33554432: 
#line 14590 
      ;
      case (u32)41943040: 
#line 14591 
      ;
      
#line 14592 
      tp->nvram_size = 524288U;
      
#line 14593 
      goto ldv_59166;
      case (u32)3: 
#line 14594 
      ;
      case (u32)8388611: 
#line 14595 
      ;
      case (u32)33554433: 
#line 14596 
      ;
      case (u32)41943041: 
#line 14597 
      ;
      
#line 14598 
      tp->nvram_size = 262144U;
      
#line 14599 
      goto ldv_59166;
    }
    ldv_59166: 
#line 14601 
    ;
  }
  
#line 14603 
  return;
}


#line 14604  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_5906_nvram_info(struct tg3 *tp)
{
  
#line 14606 
  tp->nvram_jedecnum = 31U;
  
#line 14607 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
  
#line 14608 
  tp->nvram_pagesize = 524288U;
  
#line 14609 
  return;
}


#line 14611  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_57780_nvram_info(struct tg3 *tp)
{
  u32 nvcfg1;
  
#line 14615 
  nvcfg1 = (*(tp->read32))(tp,28692U);
  
#line 14617 
  switch (nvcfg1 & 62914563U) {
    case (unsigned int)50331650: 
#line 14618 
    ;
    case (unsigned int)33554432: 
#line 14619 
    ;
    
#line 14620 
    tp->nvram_jedecnum = 31U;
    
#line 14621 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14622 
    tp->nvram_pagesize = 524288U;
    
#line 14624 
    nvcfg1 &= 2147483647U;
    
#line 14625 
    (*(tp->write32))(tp,28692U,nvcfg1);
    
#line 14626 
    goto return_label;
    case (unsigned int)33554435: 
#line 14627 
    ;
    case (unsigned int)4194304: 
#line 14628 
    ;
    case (unsigned int)54525952: 
#line 14629 
    ;
    case (unsigned int)4194306: 
#line 14630 
    ;
    case (unsigned int)54525954: 
#line 14631 
    ;
    case (unsigned int)4194305: 
#line 14632 
    ;
    case (unsigned int)54525953: 
#line 14633 
    ;
    
#line 14634 
    tp->nvram_jedecnum = 31U;
    
#line 14635 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14636 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14638 
    switch (nvcfg1 & 62914563U) {
      case (unsigned int)33554435: 
#line 14639 
      ;
      case (unsigned int)4194304: 
#line 14640 
      ;
      case (unsigned int)54525952: 
#line 14641 
      ;
      
#line 14642 
      tp->nvram_size = 131072U;
      
#line 14643 
      goto ldv_59198;
      case (unsigned int)4194306: 
#line 14644 
      ;
      case (unsigned int)54525954: 
#line 14645 
      ;
      
#line 14646 
      tp->nvram_size = 262144U;
      
#line 14647 
      goto ldv_59198;
      case (unsigned int)4194305: 
#line 14648 
      ;
      case (unsigned int)54525953: 
#line 14649 
      ;
      
#line 14650 
      tp->nvram_size = 524288U;
      
#line 14651 
      goto ldv_59198;
    }
    ldv_59198: 
#line 14653 
    ;
    
#line 14653 
    goto ldv_59203;
    case (unsigned int)37748736: 
#line 14654 
    ;
    case (unsigned int)37748738: 
#line 14655 
    ;
    case (unsigned int)37748737: 
#line 14656 
    ;
    
#line 14657 
    tp->nvram_jedecnum = 32U;
    
#line 14658 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14659 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14661 
    switch (nvcfg1 & 62914563U) {
      case (unsigned int)37748736: 
#line 14662 
      ;
      
#line 14663 
      tp->nvram_size = 131072U;
      
#line 14664 
      goto ldv_59208;
      case (unsigned int)37748738: 
#line 14665 
      ;
      
#line 14666 
      tp->nvram_size = 262144U;
      
#line 14667 
      goto ldv_59208;
      case (unsigned int)37748737: 
#line 14668 
      ;
      
#line 14669 
      tp->nvram_size = 524288U;
      
#line 14670 
      goto ldv_59208;
    }
    ldv_59208: 
#line 14672 
    ;
    
#line 14672 
    goto ldv_59203;
    default: 
#line 14673 
    ;
    
#line 14674 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14675 
    goto return_label;
  }
  ldv_59203: 
#line 14678 
  ;
  
#line 14678 
  tg3_nvram_get_pagesize(tp,nvcfg1);
  
#line 14679 
  if (tp->nvram_pagesize != 264U && tp->nvram_pagesize != 528U) 
#line 14680 
                                                                _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM_ADDR_TRANS,(unsigned long *)(& tp->tg3_flags)); else ;
  return_label: 
#line 14681 
                return;
}


#line 14684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_5717_nvram_info(struct tg3 *tp)
{
  u32 nvcfg1;
  
#line 14688 
  nvcfg1 = (*(tp->read32))(tp,28692U);
  
#line 14690 
  switch (nvcfg1 & 62914563U) {
    case (unsigned int)33554433: 
#line 14691 
    ;
    case (unsigned int)33554435: 
#line 14692 
    ;
    
#line 14693 
    tp->nvram_jedecnum = 31U;
    
#line 14694 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14695 
    tp->nvram_pagesize = 524288U;
    
#line 14697 
    nvcfg1 &= 2147483647U;
    
#line 14698 
    (*(tp->write32))(tp,28692U,nvcfg1);
    
#line 14699 
    goto return_label;
    case (unsigned int)16777217: 
#line 14700 
    ;
    case (unsigned int)20971520: 
#line 14701 
    ;
    case (unsigned int)20971521: 
#line 14702 
    ;
    case (unsigned int)16777219: 
#line 14703 
    ;
    case (unsigned int)20971522: 
#line 14704 
    ;
    case (unsigned int)20971523: 
#line 14705 
    ;
    case (unsigned int)54525952: 
#line 14706 
    ;
    
#line 14707 
    tp->nvram_jedecnum = 31U;
    
#line 14708 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14709 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14711 
    switch (nvcfg1 & 62914563U) {
      case (unsigned int)16777219: 
#line 14712 
      ;
      
#line 14714 
      goto ldv_59226;
      case (unsigned int)20971522: 
#line 14715 
      ;
      case (unsigned int)20971523: 
#line 14716 
      ;
      
#line 14717 
      tp->nvram_size = 262144U;
      
#line 14718 
      goto ldv_59226;
      default: 
#line 14719 
      ;
      
#line 14720 
      tp->nvram_size = 131072U;
      
#line 14721 
      goto ldv_59226;
    }
    ldv_59226: 
#line 14723 
    ;
    
#line 14723 
    goto ldv_59230;
    case (unsigned int)33554432: 
#line 14724 
    ;
    case (unsigned int)37748736: 
#line 14725 
    ;
    case (unsigned int)1: 
#line 14726 
    ;
    case (unsigned int)37748737: 
#line 14727 
    ;
    case (unsigned int)33554434: 
#line 14728 
    ;
    case (unsigned int)37748738: 
#line 14729 
    ;
    case (unsigned int)3: 
#line 14730 
    ;
    case (unsigned int)37748739: 
#line 14731 
    ;
    case (unsigned int)54525954: 
#line 14732 
    ;
    case (unsigned int)54525953: 
#line 14733 
    ;
    
#line 14734 
    tp->nvram_jedecnum = 32U;
    
#line 14735 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14736 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14738 
    switch (nvcfg1 & 62914563U) {
      case (unsigned int)33554434: 
#line 14739 
      ;
      case (unsigned int)3: 
#line 14740 
      ;
      
#line 14742 
      goto ldv_59243;
      case (unsigned int)37748738: 
#line 14743 
      ;
      case (unsigned int)37748739: 
#line 14744 
      ;
      
#line 14745 
      tp->nvram_size = 262144U;
      
#line 14746 
      goto ldv_59243;
      default: 
#line 14747 
      ;
      
#line 14748 
      tp->nvram_size = 131072U;
      
#line 14749 
      goto ldv_59243;
    }
    ldv_59243: 
#line 14751 
    ;
    
#line 14751 
    goto ldv_59230;
    default: 
#line 14752 
    ;
    
#line 14753 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14754 
    goto return_label;
  }
  ldv_59230: 
#line 14757 
  ;
  
#line 14757 
  tg3_nvram_get_pagesize(tp,nvcfg1);
  
#line 14758 
  if (tp->nvram_pagesize != 264U && tp->nvram_pagesize != 528U) 
#line 14759 
                                                                _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM_ADDR_TRANS,(unsigned long *)(& tp->tg3_flags)); else ;
  return_label: 
#line 14760 
                return;
}


#line 14762  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_5720_nvram_info(struct tg3 *tp)
{
  u32 nvcfg1;
  u32 nvmpinstrp;
  
#line 14766 
  nvcfg1 = (*(tp->read32))(tp,28692U);
  
#line 14767 
  nvmpinstrp = nvcfg1 & 62914563U;
  
#line 14769 
  if (tp->pci_chip_rev_id >> 12 == 22370U) {
    
#line 14770 
    if ((nvcfg1 & 65011715U) == 0U) {
      
#line 14771 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
      
#line 14772 
      goto return_label;
    }
    else ;
    
#line 14775 
    switch (nvmpinstrp) {
      case (u32)33554433: 
#line 14776 
      ;
      
#line 14777 
      nvmpinstrp = 1U;
      
#line 14778 
      goto ldv_59254;
      case (u32)33554435: 
#line 14779 
      ;
      
#line 14780 
      nvmpinstrp = 3U;
      
#line 14781 
      goto ldv_59254;
      case (u32)50331650: 
#line 14782 
      ;
      
#line 14786 
      nvmpinstrp = 62914561U;
      
#line 14787 
      goto ldv_59254;
    }
    ldv_59254: 
#line 14789 
    ;
  }
  else ;
  
#line 14791 
  switch (nvmpinstrp) {
    case (u32)1: 
#line 14792 
    ;
    case (u32)3: 
#line 14793 
    ;
    
#line 14794 
    tp->nvram_jedecnum = 31U;
    
#line 14795 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14797 
    nvcfg1 &= 2147483647U;
    
#line 14798 
    (*(tp->write32))(tp,28692U,nvcfg1);
    
#line 14799 
    if (nvmpinstrp == 1U) 
#line 14800 
                          tp->nvram_pagesize = 524288U; else 
#line 14802 
                                                             tp->nvram_pagesize = 2048U;
    
#line 14803 
    goto return_label;
    case (u32)16777216: 
#line 14804 
    ;
    case (u32)25165824: 
#line 14805 
    ;
    case (u32)29360128: 
#line 14806 
    ;
    case (u32)16777218: 
#line 14807 
    ;
    case (u32)25165826: 
#line 14808 
    ;
    case (u32)29360130: 
#line 14809 
    ;
    case (u32)16777217: 
#line 14810 
    ;
    case (u32)25165825: 
#line 14811 
    ;
    case (u32)29360129: 
#line 14812 
    ;
    case (u32)16777219: 
#line 14813 
    ;
    case (u32)29360131: 
#line 14814 
    ;
    case (u32)62914560: 
#line 14815 
    ;
    
#line 14816 
    tp->nvram_jedecnum = 31U;
    
#line 14817 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14818 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14820 
    switch (nvmpinstrp) {
      case (u32)16777218: 
#line 14821 
      ;
      case (u32)25165826: 
#line 14822 
      ;
      case (u32)29360130: 
#line 14823 
      ;
      
#line 14824 
      tp->nvram_size = 262144U;
      
#line 14825 
      goto ldv_59274;
      case (u32)16777217: 
#line 14826 
      ;
      case (u32)25165825: 
#line 14827 
      ;
      case (u32)29360129: 
#line 14828 
      ;
      
#line 14829 
      tp->nvram_size = 524288U;
      
#line 14830 
      goto ldv_59274;
      case (u32)16777219: 
#line 14831 
      ;
      case (u32)29360131: 
#line 14832 
      ;
      
#line 14833 
      tp->nvram_size = 1048576U;
      
#line 14834 
      goto ldv_59274;
      default: 
#line 14835 
      ;
      
#line 14836 
      if (tp->pci_chip_rev_id >> 12 != 22370U) 
#line 14837 
                                               tp->nvram_size = 131072U; else ;
      
#line 14838 
      goto ldv_59274;
    }
    ldv_59274: 
#line 14840 
    ;
    
#line 14840 
    goto ldv_59281;
    case (u32)33554432: 
#line 14841 
    ;
    case (u32)50331648: 
#line 14842 
    ;
    case (u32)41943040: 
#line 14843 
    ;
    case (u32)46137344: 
#line 14844 
    ;
    case (u32)33554434: 
#line 14845 
    ;
    case (u32)50331650: 
#line 14846 
    ;
    case (u32)41943042: 
#line 14847 
    ;
    case (u32)46137346: 
#line 14848 
    ;
    case (u32)33554433: 
#line 14849 
    ;
    case (u32)50331649: 
#line 14850 
    ;
    case (u32)41943041: 
#line 14851 
    ;
    case (u32)46137345: 
#line 14852 
    ;
    case (u32)33554435: 
#line 14853 
    ;
    case (u32)50331651: 
#line 14854 
    ;
    case (u32)41943043: 
#line 14855 
    ;
    case (u32)46137347: 
#line 14856 
    ;
    case (u32)62914562: 
#line 14857 
    ;
    case (u32)62914561: 
#line 14858 
    ;
    
#line 14859 
    tp->nvram_jedecnum = 32U;
    
#line 14860 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14861 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLASH,(unsigned long *)(& tp->tg3_flags));
    
#line 14863 
    switch (nvmpinstrp) {
      case (u32)33554434: 
#line 14864 
      ;
      case (u32)50331650: 
#line 14865 
      ;
      case (u32)41943042: 
#line 14866 
      ;
      case (u32)46137346: 
#line 14867 
      ;
      
#line 14868 
      tp->nvram_size = 262144U;
      
#line 14869 
      goto ldv_59304;
      case (u32)33554433: 
#line 14870 
      ;
      case (u32)50331649: 
#line 14871 
      ;
      case (u32)41943041: 
#line 14872 
      ;
      case (u32)46137345: 
#line 14873 
      ;
      
#line 14874 
      tp->nvram_size = 524288U;
      
#line 14875 
      goto ldv_59304;
      case (u32)33554435: 
#line 14876 
      ;
      case (u32)50331651: 
#line 14877 
      ;
      case (u32)41943043: 
#line 14878 
      ;
      case (u32)46137347: 
#line 14879 
      ;
      
#line 14880 
      tp->nvram_size = 1048576U;
      
#line 14881 
      goto ldv_59304;
      default: 
#line 14882 
      ;
      
#line 14883 
      if (tp->pci_chip_rev_id >> 12 != 22370U) 
#line 14884 
                                               tp->nvram_size = 131072U; else ;
      
#line 14885 
      goto ldv_59304;
    }
    ldv_59304: 
#line 14887 
    ;
    
#line 14887 
    goto ldv_59281;
    default: 
#line 14888 
    ;
    
#line 14889 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14890 
    goto return_label;
  }
  ldv_59281: 
#line 14893 
  ;
  
#line 14893 
  tg3_nvram_get_pagesize(tp,nvcfg1);
  
#line 14894 
  if (tp->nvram_pagesize != 264U && tp->nvram_pagesize != 528U) 
#line 14895 
                                                                _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM_ADDR_TRANS,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 14897 
  if (tp->pci_chip_rev_id >> 12 == 22370U) {
    u32 val;
    int tmp;
    
#line 14900 
    tmp = tg3_nvram_read(tp,0U,& val);
    
#line 14900 
    if (tmp != 0) 
#line 14901 
                  goto return_label; else ;
    
#line 14903 
    if (val != 1721324970U && (val & 4278190080U) != 2768240640U) 
#line 14905 
                                                                  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  else ;
  return_label: 
#line 14907 
                return;
}


#line 14910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_nvram_init(struct tg3 *tp)
{
  int tmp;
  u32 tmp_0;
  
#line 14912 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
  
#line 14912 
  if (tmp != 0) {
    
#line 14914 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14915 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14916 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14917 
    goto return_label;
  }
  else ;
  
#line 14920 
  _tw32_flush(tp,26680U,543162368U,0U);
  
#line 14925 
  msleep(1U);
  
#line 14928 
  tmp_0 = (*(tp->read32))(tp,26632U);
  
#line 14928 
  ;
  
#line 14928 
  _tw32_flush(tp,26632U,tmp_0 | 16777216U,0U);
  
#line 14930 
  __const_udelay(429500UL);
  
#line 14932 
  if (tp->pci_chip_rev_id >> 12 != 7U && tp->pci_chip_rev_id >> 12 != 0U) {
    int tmp_1;
    
#line 14934 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14936 
    tmp_1 = tg3_nvram_lock(tp);
    
#line 14936 
    if (tmp_1 != 0) {
      
#line 14937 
      netdev_warn((struct net_device const *)tp->dev,"Cannot get nvram lock, %s failed\n","tg3_nvram_init");
      
#line 14940 
      goto return_label;
    }
    else ;
    
#line 14942 
    tg3_enable_nvram_access(tp);
    
#line 14944 
    tp->nvram_size = 0U;
    
#line 14946 
    if (tp->pci_chip_rev_id >> 12 == 6U) 
#line 14947 
                                         tg3_get_5752_nvram_info(tp);
    else 
      
#line 14948 
      if (tp->pci_chip_rev_id >> 12 == 10U) 
#line 14949 
                                            tg3_get_5755_nvram_info(tp);
      else 
        
#line 14950 
        if ((tp->pci_chip_rev_id >> 12 == 11U || tp->pci_chip_rev_id >> 12 == 22404U) || tp->pci_chip_rev_id >> 12 == 22405U) 
          
#line 14953 
          tg3_get_5787_nvram_info(tp);
        else 
          
#line 14954 
          if (tp->pci_chip_rev_id >> 12 == 22369U) 
#line 14955 
                                                   tg3_get_5761_nvram_info(tp);
          else 
            
#line 14956 
            if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 14957 
                                                  tg3_get_5906_nvram_info(tp);
            else 
              
#line 14958 
              if (tp->pci_chip_rev_id >> 12 == 358272U) 
#line 14958 
                                                        goto _LOR;
              else {
                int tmp_2;
                
#line 14958 
                tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
                
#line 14958 
                if (tmp_2 != 0) _LOR: 
#line 14960 
                                      tg3_get_57780_nvram_info(tp);
                else 
                  
#line 14961 
                  if (tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) 
                    
#line 14963 
                    tg3_get_5717_nvram_info(tp);
                  else 
                    
#line 14964 
                    if (tp->pci_chip_rev_id >> 12 == 22304U || tp->pci_chip_rev_id >> 12 == 22370U) 
                      
#line 14966 
                      tg3_get_5720_nvram_info(tp); else 
#line 14968 
                                                        tg3_get_nvram_info(tp);
              }
    
#line 14970 
    if (tp->nvram_size == 0U) 
#line 14971 
                              tg3_get_nvram_size(tp); else ;
    
#line 14973 
    tg3_disable_nvram_access(tp);
    
#line 14974 
    tg3_nvram_unlock(tp);
  }
  else {
    
#line 14977 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 14978 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_NVRAM_BUFFERED,(unsigned long *)(& tp->tg3_flags));
    
#line 14980 
    tg3_get_eeprom_size(tp);
  }
  return_label: 
#line 14982 
                return;
}


#line 14989  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct subsys_tbl_ent subsys_id_to_phy_id[26U] = {{.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)5700U, .phy_id = 1610645584U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)1U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)2U, .phy_id = 1610678592U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)3U, .phy_id = 0U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)5U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)6U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)7U, .phy_id = 0U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)8U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)32776U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)9U, .phy_id = 1610645856U}, {.subsys_vendor = (unsigned short)5348U, .subsys_devid = (unsigned short)32777U, .phy_id = 1610645856U}, {.subsys_vendor = (unsigned short)4279U, .subsys_devid = (unsigned short)4096U, .phy_id = 1610645584U}, {.subsys_vendor = (unsigned short)4279U, .subsys_devid = (unsigned short)4102U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)4279U, .subsys_devid = (unsigned short)4100U, .phy_id = 0U}, {.subsys_vendor = (unsigned short)4279U, .subsys_devid = (unsigned short)4103U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)4279U, .subsys_devid = (unsigned short)4104U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)4136U, .subsys_devid = (unsigned short)209U, .phy_id = 1610645584U}, {.subsys_vendor = (unsigned short)4136U, .subsys_devid = (unsigned short)262U, .phy_id = 1610645584U}, {.subsys_vendor = (unsigned short)4136U, .subsys_devid = (unsigned short)265U, .phy_id = 1610645616U}, {.subsys_vendor = (unsigned short)4136U, .subsys_devid = (unsigned short)266U, .phy_id = 1610645616U}, {.subsys_vendor = (unsigned short)3601U, .subsys_devid = (unsigned short)124U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)3601U, .subsys_devid = (unsigned short)154U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)3601U, .subsys_devid = (unsigned short)125U, .phy_id = 0U}, {.subsys_vendor = (unsigned short)3601U, .subsys_devid = (unsigned short)133U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)3601U, .subsys_devid = (unsigned short)153U, .phy_id = 1610645776U}, {.subsys_vendor = (unsigned short)4116U, .subsys_devid = (unsigned short)641U, .phy_id = 0U}};

#line 15053  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct subsys_tbl_ent *tg3_lookup_by_subsys(struct tg3 *tp)
{
  struct subsys_tbl_ent *__retres;
  int i;
  
#line 15057 
  i = 0;
  
#line 15057 
  goto ldv_59333;
  ldv_59332: 
#line 15058 
  ;
  
#line 15058 
  if ((int)subsys_id_to_phy_id[i].subsys_vendor == (int)(tp->pdev)->subsystem_vendor && (int)subsys_id_to_phy_id[i].subsys_devid == (int)(tp->pdev)->subsystem_device) {
    
#line 15062 
    __retres = & subsys_id_to_phy_id[i];
    
#line 15062 
    goto return_label;
  }
  else ;
  
#line 15057 
  i += 1;
  ldv_59333: 
#line 15058 
  ;
  
#line 15057 
  if ((unsigned int)i <= 25U) 
#line 15059 
                              goto ldv_59332; else 
#line 15062 
                                                   goto ldv_59334;
  ldv_59334: 
#line 15063 
  ;
  
#line 15064 
  __retres = (struct subsys_tbl_ent *)0;
  return_label: 
#line 15064 
                return __retres;
}


#line 15067  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_get_eeprom_hw_cfg(struct tg3 *tp)
{
  u32 val;
  int tmp_10;
  
#line 15071 
  tp->phy_id = 4294967295U;
  
#line 15072 
  tp->led_ctrl = 2048U;
  
#line 15075 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags));
  
#line 15076 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_WOL_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 15078 
  if (tp->pci_chip_rev_id >> 12 == 12U) {
    u32 tmp;
    
#line 15079 
    tmp = (*(tp->read32))(tp,31748U);
    
#line 15079 
    if ((tmp & 32U) == 0U) {
      
#line 15080 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags));
      
#line 15081 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_IS_NIC,(unsigned long *)(& tp->tg3_flags));
    }
    else ;
    
#line 15083 
    val = (*(tp->read32))(tp,20740U);
    
#line 15084 
    if ((val & 4096U) != 0U) 
#line 15085 
                             _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ASPM_WORKAROUND,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 15086 
    if ((val & 1U) != 0U && (val & 4U) != 0U) {
      
#line 15088 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 15089 
      device_set_wakeup_enable(& (tp->pdev)->dev,(_Bool)1);
    }
    else ;
    
#line 15091 
    goto done;
  }
  else ;
  
#line 15094 
  tg3_read_mem(tp,2900U,& val);
  
#line 15095 
  if (val == 1264940628U) {
    u32 nic_cfg;
    u32 led_cfg;
    u32 nic_phy_id;
    u32 ver;
    u32 eeprom_phy_id;
    int tmp_1;
    int tmp_5;
    int tmp_6;
    int tmp_8;
    
#line 15097 
    u32 cfg2 = 0U;
    
#line 15097 
    u32 cfg4 = 0U;
    
#line 15097 
    u32 cfg5 = 0U;
    
#line 15099 
    int eeprom_phy_serdes = 0;
    
#line 15101 
    tg3_read_mem(tp,2904U,& nic_cfg);
    
#line 15102 
    tp->nic_sram_data_cfg = nic_cfg;
    
#line 15104 
    tg3_read_mem(tp,2908U,& ver);
    
#line 15105 
    ver >>= 16;
    
#line 15106 
    if ((((tp->pci_chip_rev_id >> 12 != 7U && tp->pci_chip_rev_id >> 12 != 0U) && tp->pci_chip_rev_id >> 12 != 1U) && ver != 0U) && ver <= 255U) 
      
#line 15110 
      tg3_read_mem(tp,3384U,& cfg2); else ;
    
#line 15112 
    if (tp->pci_chip_rev_id >> 12 == 22405U) 
#line 15113 
                                             tg3_read_mem(tp,3424U,& cfg4); else ;
    
#line 15115 
    if ((tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) || tp->pci_chip_rev_id >> 12 == 22304U) 
      
#line 15118 
      tg3_read_mem(tp,3596U,& cfg5); else ;
    
#line 15120 
    if ((nic_cfg & 48U) == 32U) 
#line 15122 
                                eeprom_phy_serdes = 1; else ;
    
#line 15124 
    tg3_read_mem(tp,2932U,& nic_phy_id);
    
#line 15125 
    if (nic_phy_id != 0U) {
      
#line 15126 
      u32 id1 = nic_phy_id & 4294901760U;
      
#line 15127 
      u32 id2 = nic_phy_id & 65535U;
      
#line 15129 
      eeprom_phy_id = (id1 >> 16) << 10;
      
#line 15130 
      eeprom_phy_id = ((id2 << 16) & 4227858432U) | eeprom_phy_id;
      
#line 15131 
      eeprom_phy_id = (id2 & 1023U) | eeprom_phy_id;
    }
    else 
#line 15133 
         eeprom_phy_id = 0U;
    
#line 15135 
    tp->phy_id = eeprom_phy_id;
    
#line 15136 
    if (eeprom_phy_serdes != 0) {
      int tmp_0;
      
#line 15137 
      tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 15137 
      if (tmp_0 == 0) 
#line 15138 
                      tp->phy_flags |= 16U; else 
#line 15140 
                                                 tp->phy_flags |= 32U;
    }
    else ;
    
#line 15143 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 15143 
    if (tmp_1 != 0) 
#line 15144 
                    led_cfg = cfg2 & 98316U; else 
#line 15147 
                                                  led_cfg = nic_cfg & 12U;
    
#line 15149 
    switch (led_cfg) {
      int tmp_2;
      default: 
#line 15150 
      ;
      case (u32)4: 
#line 15151 
      ;
      
#line 15152 
      tp->led_ctrl = 2048U;
      
#line 15153 
      goto ldv_59353;
      case (u32)8: 
#line 15155 
      ;
      
#line 15156 
      tp->led_ctrl = 4096U;
      
#line 15157 
      goto ldv_59353;
      case (u32)0: 
#line 15159 
      ;
      
#line 15160 
      tp->led_ctrl = 0U;
      
#line 15165 
      if (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) 
        
#line 15167 
        tp->led_ctrl = 2048U; else ;
      
#line 15169 
      goto ldv_59353;
      case (u32)32768: 
#line 15171 
      ;
      
#line 15172 
      tp->led_ctrl = 16384U;
      
#line 15173 
      if (tp->pci_chip_rev_id + 4294950912U > 1U) 
#line 15175 
                                                  tp->led_ctrl |= 6144U; else ;
      
#line 15178 
      tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 15178 
      if (tmp_2 != 0) 
#line 15180 
                      tp->led_ctrl |= 4294443008U;
      else 
        
#line 15178 
        if (tp->pci_chip_rev_id >> 12 == 22370U) 
#line 15180 
                                                 tp->led_ctrl |= 4294443008U; else ;
      
#line 15183 
      goto ldv_59353;
      case (u32)65536: 
#line 15185 
      ;
      
#line 15186 
      tp->led_ctrl = 8192U;
      
#line 15187 
      goto ldv_59353;
      case (u32)98304: 
#line 15189 
      ;
      
#line 15190 
      tp->led_ctrl = 32768U;
      
#line 15191 
      if (tp->pci_chip_rev_id != 16384U) 
#line 15192 
                                         tp->led_ctrl |= 6144U; else ;
      
#line 15194 
      goto ldv_59353;
    }
    ldv_59353: 
#line 15198 
    ;
    
#line 15198 
    if ((tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) && (unsigned int)(tp->pdev)->subsystem_vendor == 4136U) 
      
#line 15201 
      tp->led_ctrl = 4096U; else ;
    
#line 15203 
    if (tp->pci_chip_rev_id >> 8 == 358464U) 
#line 15204 
                                             tp->led_ctrl = 2048U; else ;
    
#line 15206 
    if ((nic_cfg & 256U) != 0U) {
      
#line 15207 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags));
      
#line 15208 
      if ((unsigned int)(tp->pdev)->subsystem_vendor == 5663U && ((unsigned int)(tp->pdev)->subsystem_device == 8282U || (unsigned int)(tp->pdev)->subsystem_device == 8291U)) 
        
#line 15212 
        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags)); else ;
    }
    else {
      
#line 15214 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags));
      
#line 15215 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_IS_NIC,(unsigned long *)(& tp->tg3_flags));
    }
    
#line 15218 
    if ((nic_cfg & 128U) != 0U) {
      int tmp_3;
      
#line 15219 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
      
#line 15220 
      tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 15220 
      if (tmp_3 != 0) 
#line 15221 
                      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ASF_NEW_HANDSHAKE,(unsigned long *)(& tp->tg3_flags)); else ;
    }
    else ;
    
#line 15224 
    if ((nic_cfg & 2097152U) != 0U) {
      int tmp_4;
      
#line 15224 
      tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 15224 
      if (tmp_4 != 0) 
#line 15226 
                      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags)); else ;
    }
    else ;
    
#line 15228 
    if ((tp->phy_flags & 48U) != 0U && (nic_cfg & 16384U) == 0U) 
#line 15230 
                                                                 _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_WOL_CAP,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 15232 
    tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_CAP,(unsigned long *)(& tp->tg3_flags));
    
#line 15232 
    if (tmp_5 != 0) {
      
#line 15232 
      if ((nic_cfg & 64U) != 0U) {
        
#line 15234 
        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
        
#line 15235 
        device_set_wakeup_enable(& (tp->pdev)->dev,(_Bool)1);
      }
      else ;
    }
    else ;
    
#line 15238 
    if ((cfg2 & 131072U) != 0U) 
#line 15239 
                                tp->phy_flags |= 512U; else ;
    
#line 15243 
    if ((cfg2 & 262144U) != 0U) 
#line 15244 
                                tp->phy_flags |= 65536U; else ;
    
#line 15246 
    tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 15246 
    if (tmp_6 != 0) 
#line 15246 
                    goto _LOR;
    else 
      
#line 15246 
      if (tp->pci_chip_rev_id >> 12 == 22404U && tp->pci_chip_rev_id >> 8 != 358464U) {
        _LOR: 
#line 15248 
        ;
        
#line 15248 
        if ((cfg2 & 16384U) != 0U) 
#line 15250 
                                   tp->phy_flags |= 256U; else ;
      }
      else ;
    
#line 15252 
    tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
    
#line 15252 
    if (tmp_8 != 0) {
      u32 cfg3;
      
#line 15255 
      tg3_read_mem(tp,3388U,& cfg3);
      
#line 15256 
      if (tp->pci_chip_rev_id >> 12 != 22405U) {
        int tmp_7;
        
#line 15256 
        tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
        
#line 15256 
        if (tmp_7 == 0) {
          
#line 15257 
          if ((cfg3 & 2U) != 0U) 
#line 15259 
                                 _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ASPM_WORKAROUND,(unsigned long *)(& tp->tg3_flags)); else ;
        }
        else ;
      }
      else ;
      
#line 15260 
      if ((cfg3 & 4194304U) != 0U) 
#line 15261 
                                   tp->phy_flags |= 1048576U; else ;
      
#line 15262 
      if ((cfg3 & 8388608U) != 0U) 
#line 15263 
                                   tp->phy_flags |= 524288U; else ;
    }
    else ;
    
#line 15266 
    if ((cfg4 & 4U) != 0U) 
#line 15267 
                           _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_RGMII_INBAND_DISABLE,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 15268 
    if ((cfg4 & 8U) != 0U) 
#line 15269 
                           _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_RGMII_EXT_IBND_RX_EN,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 15270 
    if ((cfg4 & 16U) != 0U) 
#line 15271 
                            _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_RGMII_EXT_IBND_TX_EN,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 15273 
    if ((cfg5 & 2U) != 0U) 
#line 15274 
                           tp->phy_flags |= 4194304U; else ;
  }
  else ;
  done: 
#line 15276 
  ;
  
#line 15277 
  tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 15277 
  if (tmp_10 != 0) {
    int tmp_9;
    
#line 15278 
    tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_WOL_ENABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 15278 
    ;
    
#line 15278 
    device_set_wakeup_enable(& (tp->pdev)->dev,(_Bool)(tmp_9 != 0));
  }
  else 
#line 15281 
       device_set_wakeup_capable(& (tp->pdev)->dev,(_Bool)0);
  
#line 15282 
  return;
}


#line 15284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_ape_otp_read(struct tg3 *tp, u32 offset, u32 *val)
{
  int __retres;
  int i;
  int err;
  u32 val2;
  
#line 15287 
  u32 off = offset * 8U;
  
#line 15289 
  err = tg3_nvram_lock(tp);
  
#line 15290 
  if (err != 0) {
    
#line 15291 
    __retres = err;
    
#line 15291 
    goto return_label;
  }
  else ;
  
#line 15293 
  tg3_ape_write32(tp,240U,off | 2147483648U);
  
#line 15294 
  tg3_ape_write32(tp,232U,2097153U);
  
#line 15296 
  tg3_ape_read32(tp,232U);
  
#line 15297 
  __const_udelay(42950UL);
  
#line 15299 
  i = 0;
  
#line 15299 
  goto ldv_59371;
  ldv_59370: 
#line 15300 
  ;
  
#line 15300 
  val2 = tg3_ape_read32(tp,236U);
  
#line 15301 
  if ((val2 & 1U) != 0U) {
    
#line 15302 
    *val = tg3_ape_read32(tp,248U);
    
#line 15303 
    goto ldv_59369;
  }
  else ;
  
#line 15305 
  __const_udelay(42950UL);
  
#line 15299 
  i += 1;
  ldv_59371: 
#line 15300 
  ;
  
#line 15299 
  if (i <= 99) 
#line 15301 
               goto ldv_59370; else 
#line 15304 
                                    goto ldv_59369;
  ldv_59369: 
#line 15305 
  ;
  
#line 15308 
  tg3_ape_write32(tp,232U,0U);
  
#line 15310 
  tg3_nvram_unlock(tp);
  
#line 15311 
  if ((val2 & 1U) != 0U) {
    
#line 15312 
    __retres = 0;
    
#line 15312 
    goto return_label;
  }
  else ;
  
#line 15314 
  __retres = -16;
  return_label: 
#line 15314 
                return __retres;
}


#line 15317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_issue_otp_command(struct tg3 *tp, u32 cmd)
{
  int i;
  u32 val;
  int tmp;
  
#line 15322 
  (*(tp->write32))(tp,29956U,cmd | 1U);
  
#line 15323 
  (*(tp->write32))(tp,29956U,cmd);
  
#line 15326 
  i = 0;
  
#line 15326 
  goto ldv_59380;
  ldv_59379: 
#line 15327 
  ;
  
#line 15327 
  val = (*(tp->read32))(tp,29960U);
  
#line 15328 
  if ((val & 1U) != 0U) 
#line 15329 
                        goto ldv_59378; else ;
  
#line 15330 
  __const_udelay(42950UL);
  
#line 15326 
  i += 1;
  ldv_59380: 
#line 15327 
  ;
  
#line 15326 
  if (i <= 99) 
#line 15328 
               goto ldv_59379; else 
#line 15331 
                                    goto ldv_59378;
  ldv_59378: 
#line 15332 
  ;
  
#line 15333 
  if ((val & 1U) != 0U) 
#line 15333 
                        tmp = 0; else 
#line 15333 
                                      tmp = -16;
  
#line 15333 
  return tmp;
}


#line 15340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_read_otp_phycfg(struct tg3 *tp)
{
  u32 __retres;
  u32 bhalf_otp;
  u32 thalf_otp;
  int tmp;
  int tmp_0;
  int tmp_1;
  
#line 15344 
  (*(tp->write32))(tp,29952U,1U);
  
#line 15346 
  tmp = tg3_issue_otp_command(tp,8U);
  
#line 15346 
  if (tmp != 0) {
    
#line 15347 
    __retres = 0U;
    
#line 15347 
    goto return_label;
  }
  else ;
  
#line 15349 
  (*(tp->write32))(tp,29964U,160U);
  
#line 15351 
  tmp_0 = tg3_issue_otp_command(tp,0U);
  
#line 15351 
  if (tmp_0 != 0) {
    
#line 15352 
    __retres = 0U;
    
#line 15352 
    goto return_label;
  }
  else ;
  
#line 15354 
  thalf_otp = (*(tp->read32))(tp,29972U);
  
#line 15356 
  (*(tp->write32))(tp,29964U,128U);
  
#line 15358 
  tmp_1 = tg3_issue_otp_command(tp,0U);
  
#line 15358 
  if (tmp_1 != 0) {
    
#line 15359 
    __retres = 0U;
    
#line 15359 
    goto return_label;
  }
  else ;
  
#line 15361 
  bhalf_otp = (*(tp->read32))(tp,29972U);
  
#line 15363 
  __retres = (thalf_otp << 16) | (bhalf_otp >> 16);
  return_label: 
#line 15363 
                return __retres;
}


#line 15366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_phy_init_link_config(struct tg3 *tp)
{
  
#line 15368 
  u32 adv = 64U;
  
#line 15370 
  if ((tp->phy_flags & 128U) == 0U) {
    
#line 15371 
    if ((tp->phy_flags & 4194304U) == 0U) 
#line 15372 
                                          adv |= 16U; else ;
    
#line 15373 
    adv |= 32U;
  }
  else ;
  
#line 15376 
  if ((tp->phy_flags & 48U) == 0U) 
#line 15377 
                                   adv |= 143U; else 
#line 15383 
                                                     adv |= 1024U;
  
#line 15385 
  tp->link_config.advertising = adv;
  
#line 15386 
  tp->link_config.speed = (unsigned short)65535U;
  
#line 15387 
  tp->link_config.duplex = (unsigned char)255U;
  
#line 15388 
  tp->link_config.autoneg = (unsigned char)1U;
  
#line 15389 
  tp->link_config.active_speed = (unsigned short)65535U;
  
#line 15390 
  tp->link_config.active_duplex = (unsigned char)255U;
  
#line 15392 
  tp->old_link = -1;
  
#line 15393 
  return;
}


#line 15395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_phy_probe(struct tg3 *tp)
{
  int __retres;
  u32 hw_phy_id_1;
  u32 hw_phy_id_2;
  u32 hw_phy_id;
  u32 hw_phy_id_masked;
  int err;
  int tmp;
  int tmp_0;
  int tmp_2;
  int tmp_5;
  
#line 15402 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PAUSE_AUTONEG,(unsigned long *)(& tp->tg3_flags));
  
#line 15403 
  tp->link_config.flowctrl = (unsigned char)3U;
  
#line 15405 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 15405 
  if (tmp != 0) {
    
#line 15406 
    switch (tp->pci_fn) {
      case 0: 
#line 15407 
      ;
      
#line 15408 
      tp->phy_ape_lock = (unsigned char)0U;
      
#line 15409 
      goto ldv_59399;
      case 1: 
#line 15410 
      ;
      
#line 15411 
      tp->phy_ape_lock = (unsigned char)2U;
      
#line 15412 
      goto ldv_59399;
      case 2: 
#line 15413 
      ;
      
#line 15414 
      tp->phy_ape_lock = (unsigned char)3U;
      
#line 15415 
      goto ldv_59399;
      case 3: 
#line 15416 
      ;
      
#line 15417 
      tp->phy_ape_lock = (unsigned char)5U;
      
#line 15418 
      goto ldv_59399;
    }
    ldv_59399: 
#line 15420 
    ;
  }
  else ;
  
#line 15422 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 15422 
  if (tmp_0 == 0) {
    
#line 15422 
    if ((tp->phy_flags & 48U) == 0U) {
      
#line 15423 
      if ((tp->phy_flags & 128U) == 0U) 
#line 15425 
                                        tp->phy_flags &= 4293394431U; else ;
    }
    else ;
  }
  else ;
  
#line 15428 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
  
#line 15428 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 15429 
    tmp_1 = tg3_phy_init(tp);
    
#line 15429 
    __retres = tmp_1;
    
#line 15429 
    goto return_label;
  }
  else ;
  
#line 15434 
  err = 0;
  
#line 15435 
  tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 15435 
  if (tmp_5 != 0) 
#line 15435 
                  goto _LOR;
  else {
    int tmp_6;
    
#line 15435 
    tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
    
#line 15435 
    if (tmp_6 != 0) {
      _LOR: {
              
#line 15436 
              hw_phy_id_masked = 4294967295U;
              
#line 15436 
              hw_phy_id = hw_phy_id_masked;
            }
    }
    else {
      int tmp_3;
      int tmp_4;
      
#line 15443 
      tmp_3 = tg3_readphy(tp,2,& hw_phy_id_1);
      
#line 15443 
      err = tmp_3 | err;
      
#line 15444 
      tmp_4 = tg3_readphy(tp,3,& hw_phy_id_2);
      
#line 15444 
      err = tmp_4 | err;
      
#line 15446 
      hw_phy_id = (hw_phy_id_1 << 10) & 67107840U;
      
#line 15447 
      hw_phy_id = ((hw_phy_id_2 << 16) & 4227858432U) | hw_phy_id;
      
#line 15448 
      hw_phy_id = (hw_phy_id_2 & 1023U) | hw_phy_id;
      
#line 15450 
      hw_phy_id_masked = hw_phy_id & 4294967280U;
    }
  }
  
#line 15453 
  if (err == 0 && ((((((((((((hw_phy_id_masked == 1610645568U || hw_phy_id_masked == 1610645584U) || (hw_phy_id_masked == 1610645616U || hw_phy_id_masked == 1610645776U)) || (hw_phy_id_masked == 1610645856U || hw_phy_id_masked == 1610645904U)) || (hw_phy_id_masked == 1610645920U || hw_phy_id_masked == 1610645888U)) || (hw_phy_id_masked == 1610645760U || hw_phy_id_masked == 1610646336U)) || (hw_phy_id_masked == 1610646352U || hw_phy_id_masked == 3154447584U)) || (hw_phy_id_masked == 3154447552U || hw_phy_id_masked == 3154448080U)) || (hw_phy_id_masked == 3691031616U || hw_phy_id_masked == 3154448336U)) || (hw_phy_id_masked == 1544391168U || hw_phy_id_masked == 3154448368U)) || (hw_phy_id_masked == 1544391232U || hw_phy_id_masked == 1544391200U)) || (hw_phy_id_masked == 1544391520U || hw_phy_id_masked == 2239772544U)) || hw_phy_id_masked == 1610678592U)) {
    
#line 15454 
    tp->phy_id = hw_phy_id;
    
#line 15455 
    if (hw_phy_id_masked == 1610678592U) 
#line 15456 
                                         tp->phy_flags |= 16U; else 
#line 15458 
                                                                    tp->phy_flags &= 4294967279U;
  }
  else 
    
#line 15460 
    if (tp->phy_id != 4294967295U) ;
    else {
      struct subsys_tbl_ent *p;
      
#line 15470 
      p = tg3_lookup_by_subsys(tp);
      
#line 15471 
      if (p != (struct subsys_tbl_ent *)0) 
#line 15472 
                                           tp->phy_id = p->phy_id;
      else {
        int tmp_7;
        
#line 15473 
        tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
        
#line 15473 
        if (tmp_7 == 0) {
          
#line 15481 
          __retres = -19;
          
#line 15481 
          goto return_label;
        }
        else ;
      }
      
#line 15484 
      if (tp->phy_id == 0U || tp->phy_id == 1610678592U) 
#line 15486 
                                                         tp->phy_flags |= 16U; else ;
    }
  
#line 15490 
  if ((tp->phy_flags & 48U) == 0U && (((((tp->pci_chip_rev_id >> 12 == 22297U || tp->pci_chip_rev_id >> 12 == 22304U) || tp->pci_chip_rev_id >> 12 == 358246U) || tp->pci_chip_rev_id >> 12 == 22370U) || (tp->pci_chip_rev_id >> 12 == 22295U && tp->pci_chip_rev_id != 91320320U)) || (tp->pci_chip_rev_id >> 12 == 358277U && tp->pci_chip_rev_id != 1467502592U))) {
    
#line 15499 
    tp->phy_flags |= 262144U;
    
#line 15501 
    tp->eee.supported = 40U;
    
#line 15503 
    tp->eee.advertised = 40U;
    
#line 15505 
    tp->eee.eee_enabled = 1U;
    
#line 15506 
    tp->eee.tx_lpi_enabled = 1U;
    
#line 15507 
    tp->eee.tx_lpi_timer = 2047U;
  }
  else ;
  
#line 15510 
  tg3_phy_init_link_config(tp);
  
#line 15512 
  if ((tp->phy_flags & 1048576U) == 0U && (tp->phy_flags & 48U) == 0U) {
    int tmp_11;
    
#line 15513 
    tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
    
#line 15513 
    if (tmp_11 == 0) {
      int tmp_12;
      
#line 15514 
      tmp_12 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
      
#line 15514 
      if (tmp_12 == 0) {
        u32 bmsr;
        u32 dummy;
        int tmp_8;
        int tmp_10;
        bool tmp_9;
        
#line 15518 
        tg3_readphy(tp,1,& bmsr);
        
#line 15519 
        tmp_8 = tg3_readphy(tp,1,& bmsr);
        
#line 15519 
        if (tmp_8 == 0) {
          
#line 15519 
          if ((bmsr & 4U) != 0U) 
#line 15521 
                                 goto skip_phy_reset; else ;
        }
        else ;
        
#line 15523 
        err = tg3_phy_reset(tp);
        
#line 15524 
        if (err != 0) {
          
#line 15525 
          __retres = err;
          
#line 15525 
          goto return_label;
        }
        else ;
        
#line 15527 
        tg3_phy_set_wirespeed(tp);
        
#line 15529 
        tmp_9 = tg3_phy_copper_an_config_ok(tp,& dummy);
        
#line 15529 
        if (tmp_9) 
#line 15529 
                   tmp_10 = 0; else 
#line 15529 
                                    tmp_10 = 1;
        
#line 15529 
        if (tmp_10) {
          
#line 15530 
          tg3_phy_autoneg_cfg(tp,tp->link_config.advertising,(unsigned int)tp->link_config.flowctrl);
          
#line 15533 
          tg3_writephy(tp,0,4608U);
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  skip_phy_reset: 
#line 15538 
  ;
  
#line 15539 
  if ((tp->phy_id & 4294967280U) == 1610645584U) {
    
#line 15540 
    err = tg3_init_5401phy_dsp(tp);
    
#line 15541 
    if (err != 0) {
      
#line 15542 
      __retres = err;
      
#line 15542 
      goto return_label;
    }
    else ;
    
#line 15544 
    err = tg3_init_5401phy_dsp(tp);
  }
  else ;
  
#line 15547 
  __retres = err;
  return_label: 
#line 15547 
                return __retres;
}


#line 15550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_vpd(struct tg3 *tp)
{
  u8 *vpd_data;
  unsigned int block_end;
  unsigned int rosize;
  unsigned int len;
  u32 vpdlen;
  int j;
  u16 tmp_0;
  u8 tmp_4;
  
#line 15555 
  int i = 0;
  
#line 15557 
  vpd_data = (u8 *)tg3_vpd_readblock(tp,& vpdlen);
  
#line 15558 
  if (vpd_data == (u8 *)0U) 
#line 15559 
                            goto out_no_vpd; else ;
  
#line 15561 
  i = pci_vpd_find_tag((u8 const *)vpd_data,0U,vpdlen,(unsigned char)144);
  
#line 15562 
  if (i < 0) 
#line 15563 
             goto out_not_found; else ;
  
#line 15565 
  tmp_0 = pci_vpd_lrdt_size((u8 const *)(vpd_data + i));
  
#line 15565 
  rosize = (unsigned int)tmp_0;
  
#line 15566 
  block_end = ((unsigned int)i + rosize) + 3U;
  
#line 15567 
  i += 3;
  
#line 15569 
  if (block_end > vpdlen) 
#line 15570 
                          goto out_not_found; else ;
  
#line 15572 
  j = pci_vpd_find_info_keyword((u8 const *)vpd_data,(unsigned int)i,rosize,"MN");
  
#line 15574 
  if (j > 0) {
    u8 tmp_1;
    u8 tmp_3;
    
#line 15575 
    tmp_1 = pci_vpd_info_field_size((u8 const *)(vpd_data + j));
    
#line 15575 
    len = (unsigned int)tmp_1;
    
#line 15577 
    j += 3;
    
#line 15578 
    if ((unsigned int)j + len > block_end || len != 4U) 
#line 15580 
                                                        goto partno;
    else {
      int tmp_2;
      
#line 15578 
      tmp_2 = memcmp((void const *)(vpd_data + j),(void const *)"1028",4UL);
      
#line 15578 
      if (tmp_2 != 0) 
#line 15580 
                      goto partno; else ;
    }
    
#line 15582 
    j = pci_vpd_find_info_keyword((u8 const *)vpd_data,(unsigned int)i,rosize,"V0");
    
#line 15584 
    if (j < 0) 
#line 15585 
               goto partno; else ;
    
#line 15587 
    tmp_3 = pci_vpd_info_field_size((u8 const *)(vpd_data + j));
    
#line 15587 
    len = (unsigned int)tmp_3;
    
#line 15589 
    j += 3;
    
#line 15590 
    if ((unsigned int)j + len > block_end) 
#line 15591 
                                           goto partno; else ;
    
#line 15593 
    if (len > 31U) 
#line 15594 
                   len = 31U; else ;
    
#line 15595 
    memset((void *)(& tp->fw_ver),0,32UL);
    
#line 15596 
    snprintf((char *)(& tp->fw_ver),32UL,"%.*s bc ",len,vpd_data + j);
  }
  else ;
  partno: 
#line 15600 
  ;
  
#line 15601 
  i = pci_vpd_find_info_keyword((u8 const *)vpd_data,(unsigned int)i,rosize,"PN");
  
#line 15603 
  if (i < 0) 
#line 15604 
             goto out_not_found; else ;
  
#line 15606 
  tmp_4 = pci_vpd_info_field_size((u8 const *)(vpd_data + i));
  
#line 15606 
  len = (unsigned int)tmp_4;
  
#line 15608 
  i += 3;
  
#line 15609 
  if (len > 24U || len + (unsigned int)i > vpdlen) 
#line 15611 
                                                   goto out_not_found; else ;
  
#line 15613 
  memcpy((void *)(& tp->board_part_number),(void const *)(vpd_data + i),(unsigned long)len);
  out_not_found: 
#line 15615 
  ;
  
#line 15616 
  kfree((void const *)vpd_data);
  
#line 15617 
  if ((int)tp->board_part_number[0] != 0) 
#line 15618 
                                          goto return_label; else ;
  out_no_vpd: 
#line 15620 
  ;
  
#line 15621 
  if (tp->pci_chip_rev_id >> 12 == 22295U) {
    
#line 15622 
    if ((unsigned int)(tp->pdev)->device == 5717U || (unsigned int)(tp->pdev)->device == 5733U) 
      
#line 15624 
      strcpy((char *)(& tp->board_part_number),"BCM5717");
    else 
      
#line 15625 
      if ((unsigned int)(tp->pdev)->device == 5718U) 
#line 15626 
                                                     strcpy((char *)(& tp->board_part_number),"BCM5718"); else 
                                                                    
#line 15628 
                                                                    goto nomatch;
  }
  else 
    
#line 15629 
    if (tp->pci_chip_rev_id >> 12 == 358272U) {
      
#line 15630 
      if ((unsigned int)(tp->pdev)->device == 5778U) 
#line 15631 
                                                     strcpy((char *)(& tp->board_part_number),"BCM57780");
      else 
        
#line 15632 
        if ((unsigned int)(tp->pdev)->device == 5776U) 
#line 15633 
                                                       strcpy((char *)(& tp->board_part_number),"BCM57760");
        else 
          
#line 15634 
          if ((unsigned int)(tp->pdev)->device == 5780U) 
#line 15635 
                                                         strcpy((char *)(& tp->board_part_number),"BCM57790");
          else 
            
#line 15636 
            if ((unsigned int)(tp->pdev)->device == 5777U) 
#line 15637 
                                                           strcpy((char *)(& tp->board_part_number),"BCM57788"); else 
                                                                    
#line 15639 
                                                                    goto nomatch;
    }
    else 
      
#line 15640 
      if (tp->pci_chip_rev_id >> 12 == 358277U) {
        
#line 15641 
        if ((unsigned int)(tp->pdev)->device == 5808U) 
#line 15642 
                                                       strcpy((char *)(& tp->board_part_number),"BCM57761");
        else 
          
#line 15643 
          if ((unsigned int)(tp->pdev)->device == 5812U) 
#line 15644 
                                                         strcpy((char *)(& tp->board_part_number),"BCM57765");
          else 
            
#line 15645 
            if ((unsigned int)(tp->pdev)->device == 5809U) 
#line 15646 
                                                           strcpy((char *)(& tp->board_part_number),"BCM57781");
            else 
              
#line 15647 
              if ((unsigned int)(tp->pdev)->device == 5813U) 
#line 15648 
                                                             strcpy((char *)(& tp->board_part_number),"BCM57785");
              else 
                
#line 15649 
                if ((unsigned int)(tp->pdev)->device == 5810U) 
#line 15650 
                                                               strcpy((char *)(& tp->board_part_number),"BCM57791");
                else 
                  
#line 15651 
                  if ((unsigned int)(tp->pdev)->device == 5814U) 
#line 15652 
                                                                 strcpy((char *)(& tp->board_part_number),"BCM57795"); else 
                                                                    
#line 15654 
                                                                    goto nomatch;
      }
      else 
        
#line 15655 
        if (tp->pci_chip_rev_id >> 12 == 358246U) {
          
#line 15656 
          if ((unsigned int)(tp->pdev)->device == 5762U) 
#line 15657 
                                                         strcpy((char *)(& tp->board_part_number),"BCM57762");
          else 
            
#line 15658 
            if ((unsigned int)(tp->pdev)->device == 5766U) 
#line 15659 
                                                           strcpy((char *)(& tp->board_part_number),"BCM57766");
            else 
              
#line 15660 
              if ((unsigned int)(tp->pdev)->device == 5815U) 
#line 15661 
                                                             strcpy((char *)(& tp->board_part_number),"BCM57782");
              else 
                
#line 15662 
                if ((unsigned int)(tp->pdev)->device == 5811U) 
#line 15663 
                                                               strcpy((char *)(& tp->board_part_number),"BCM57786"); else 
                                                                    
#line 15665 
                                                                    goto nomatch;
        }
        else 
          
#line 15666 
          if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 15667 
                                                strcpy((char *)(& tp->board_part_number),"BCM95906");
          else {
            nomatch: 
#line 15669 
            ;
            
#line 15670 
            strcpy((char *)(& tp->board_part_number),"none");
          }
  return_label: 
#line 15672 
                return;
}


#line 15674  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_fw_img_is_valid(struct tg3 *tp, u32 offset)
{
  int __retres;
  u32 val;
  int tmp;
  
#line 15678 
  tmp = tg3_nvram_read(tp,offset,& val);
  
#line 15678 
  if (tmp != 0) {
    
#line 15682 
    __retres = 0;
    
#line 15682 
    goto return_label;
  }
  else 
    
#line 15678 
    if ((val & 4227858432U) != 201326592U) {
      
#line 15682 
      __retres = 0;
      
#line 15682 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 15679 
      tmp_0 = tg3_nvram_read(tp,offset + 4U,& val);
      
#line 15679 
      if (tmp_0 != 0) {
        
#line 15682 
        __retres = 0;
        
#line 15682 
        goto return_label;
      }
      else 
        
#line 15680 
        if (val != 0U) {
          
#line 15682 
          __retres = 0;
          
#line 15682 
          goto return_label;
        }
        else ;
    }
  
#line 15684 
  __retres = 1;
  return_label: 
#line 15684 
                return __retres;
}


#line 15687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_bc_ver(struct tg3 *tp)
{
  u32 val;
  u32 offset;
  u32 start;
  u32 ver_offset;
  int i;
  int dst_off;
  int tmp;
  int tmp_1;
  size_t tmp_3;
  
#line 15691 
  bool newver = (_Bool)0;
  
#line 15693 
  tmp = tg3_nvram_read(tp,12U,& offset);
  
#line 15693 
  if (tmp != 0) 
#line 15695 
                goto return_label;
  else {
    int tmp_0;
    
#line 15693 
    tmp_0 = tg3_nvram_read(tp,4U,& start);
    
#line 15693 
    if (tmp_0 != 0) 
#line 15695 
                    goto return_label; else ;
  }
  
#line 15697 
  offset = tg3_nvram_logical_addr(tp,offset);
  
#line 15699 
  tmp_1 = tg3_nvram_read(tp,offset,& val);
  
#line 15699 
  if (tmp_1 != 0) 
#line 15700 
                  goto return_label; else ;
  
#line 15702 
  if ((val & 4227858432U) == 201326592U) {
    int tmp_2;
    
#line 15703 
    tmp_2 = tg3_nvram_read(tp,offset + 4U,& val);
    
#line 15703 
    if (tmp_2 != 0) 
#line 15704 
                    goto return_label; else ;
    
#line 15706 
    if (val == 0U) 
#line 15707 
                   newver = (_Bool)1; else ;
  }
  else ;
  
#line 15710 
  tmp_3 = strlen((char const *)(& tp->fw_ver));
  
#line 15710 
  dst_off = (int)tmp_3;
  
#line 15712 
  if ((int)newver != 0) {
    
#line 15713 
    if (32 - dst_off <= 15) 
#line 15715 
                            goto return_label;
    else {
      int tmp_4;
      
#line 15713 
      tmp_4 = tg3_nvram_read(tp,offset + 8U,& ver_offset);
      
#line 15713 
      if (tmp_4 != 0) 
#line 15715 
                      goto return_label; else ;
    }
    
#line 15717 
    offset = (offset + ver_offset) - start;
    
#line 15718 
    i = 0;
    
#line 15718 
    goto ldv_59438;
    ldv_59437: 
#line 15719 
    ;
    {
      __be32 v;
      int tmp_5;
      
#line 15720 
      tmp_5 = tg3_nvram_read_be32(tp,offset + (unsigned int)i,& v);
      
#line 15720 
      if (tmp_5 != 0) 
#line 15721 
                      goto return_label; else ;
      
#line 15723 
      memcpy((void *)(& tp->fw_ver) + (dst_off + i),(void const *)(& v),4UL);
    }
    
#line 15718 
    i += 4;
    ldv_59438: 
#line 15719 
    ;
    
#line 15718 
    if (i <= 15) 
#line 15720 
                 goto ldv_59437; else 
#line 15723 
                                      goto ldv_59439;
    ldv_59439: 
#line 15724 
    ;
  }
  else {
    u32 major;
    u32 minor;
    int tmp_6;
    
#line 15728 
    tmp_6 = tg3_nvram_read(tp,148U,& ver_offset);
    
#line 15728 
    if (tmp_6 != 0) 
#line 15729 
                    goto return_label; else ;
    
#line 15731 
    major = (ver_offset >> 8) & 255U;
    
#line 15733 
    minor = ver_offset & 255U;
    
#line 15734 
    snprintf(& tp->fw_ver[dst_off],(unsigned long)(32 - dst_off),"v%d.%02d",major,minor);
  }
  return_label: 
#line 15737 
                return;
}


#line 15739  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_hwsb_ver(struct tg3 *tp)
{
  u32 val;
  u32 major;
  u32 minor;
  int tmp;
  
#line 15744 
  tmp = tg3_nvram_read(tp,4U,& val);
  
#line 15744 
  if (tmp != 0) 
#line 15745 
                goto return_label; else ;
  
#line 15747 
  major = val >> 27;
  
#line 15749 
  minor = (val >> 22) & 31U;
  
#line 15752 
  snprintf(& tp->fw_ver[0],32UL,"sb v%d.%02d",major,minor);
  return_label: 
#line 15753 
                return;
}


#line 15755  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_sb_ver(struct tg3 *tp, u32 val)
{
  u32 offset;
  u32 major;
  u32 minor;
  u32 build;
  size_t tmp;
  int tmp_0;
  size_t tmp_1;
  
#line 15759 
  tmp = strlen((char const *)(& tp->fw_ver));
  
#line 15759 
  ;
  
#line 15759 
  strncat((char *)(& tp->fw_ver),"sb",31UL - tmp);
  
#line 15761 
  if ((val & 14680064U) != 2097152U) 
#line 15762 
                                     goto return_label; else ;
  
#line 15764 
  switch (val & 2031616U) {
    case (unsigned int)0: 
#line 15765 
    ;
    
#line 15766 
    offset = 16U;
    
#line 15767 
    goto ldv_59457;
    case (unsigned int)131072: 
#line 15768 
    ;
    
#line 15769 
    offset = 20U;
    
#line 15770 
    goto ldv_59457;
    case (unsigned int)196608: 
#line 15771 
    ;
    
#line 15772 
    offset = 24U;
    
#line 15773 
    goto ldv_59457;
    case (unsigned int)262144: 
#line 15774 
    ;
    
#line 15775 
    offset = 28U;
    
#line 15776 
    goto ldv_59457;
    case (unsigned int)327680: 
#line 15777 
    ;
    
#line 15778 
    offset = 32U;
    
#line 15779 
    goto ldv_59457;
    case (unsigned int)393216: 
#line 15780 
    ;
    
#line 15781 
    offset = 76U;
    
#line 15782 
    goto ldv_59457;
    default: 
#line 15783 
    ;
    
#line 15784 
    goto return_label;
  }
  ldv_59457: 
#line 15787 
  ;
  
#line 15787 
  tmp_0 = tg3_nvram_read(tp,offset,& val);
  
#line 15787 
  if (tmp_0 != 0) 
#line 15788 
                  goto return_label; else ;
  
#line 15790 
  build = (val >> 11) & 31U;
  
#line 15792 
  major = (val >> 8) & 7U;
  
#line 15794 
  minor = val & 255U;
  
#line 15796 
  if (minor > 99U || build > 26U) 
#line 15797 
                                  goto return_label; else ;
  
#line 15799 
  tmp_1 = strlen((char const *)(& tp->fw_ver));
  
#line 15799 
  offset = (unsigned int)tmp_1;
  
#line 15800 
  snprintf(& tp->fw_ver[offset],(unsigned long)(32U - offset)," v%d.%02d",major,minor);
  
#line 15803 
  if (build != 0U) {
    size_t tmp_2;
    
#line 15804 
    tmp_2 = strlen((char const *)(& tp->fw_ver));
    
#line 15804 
    offset = (unsigned int)tmp_2;
    
#line 15805 
    if (offset <= 30U) 
#line 15806 
                       tp->fw_ver[offset] = (char)(build + 96U); else ;
  }
  else ;
  return_label: 
#line 15808 
                return;
}


#line 15810  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_mgmtfw_ver(struct tg3 *tp)
{
  u32 val;
  u32 offset;
  u32 start;
  int i;
  int vlen;
  int tmp;
  int tmp_1;
  int tmp_2;
  size_t tmp_5;
  int tmp_6;
  int tmp_7;
  
#line 15815 
  offset = 24U;
  
#line 15815 
  goto ldv_59474;
  ldv_59473: 
#line 15816 
  ;
  
#line 15818 
  tmp = tg3_nvram_read(tp,offset,& val);
  
#line 15818 
  if (tmp != 0) 
#line 15819 
                goto return_label; else ;
  
#line 15821 
  if (val >> 24 == 1U) 
#line 15822 
                       goto ldv_59472; else ;
  
#line 15817 
  offset += 12U;
  ldv_59474: 
#line 15818 
  ;
  
#line 15815 
  if (offset <= 119U) 
#line 15818 
                      goto ldv_59473; else 
#line 15821 
                                           goto ldv_59472;
  ldv_59472: 
#line 15822 
  ;
  
#line 15825 
  if (offset == 120U) 
#line 15826 
                      goto return_label; else ;
  
#line 15828 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 15828 
  if (tmp_1 == 0) 
#line 15829 
                  start = 134217728U;
  else {
    int tmp_0;
    
#line 15830 
    tmp_0 = tg3_nvram_read(tp,offset + 4294967292U,& start);
    
#line 15830 
    if (tmp_0 != 0) 
#line 15831 
                    goto return_label; else ;
  }
  
#line 15833 
  tmp_2 = tg3_nvram_read(tp,offset + 4U,& offset);
  
#line 15833 
  if (tmp_2 != 0) 
#line 15836 
                  goto return_label;
  else {
    int tmp_3;
    
#line 15833 
    tmp_3 = tg3_fw_img_is_valid(tp,offset);
    
#line 15833 
    if (tmp_3 == 0) 
#line 15836 
                    goto return_label;
    else {
      int tmp_4;
      
#line 15834 
      tmp_4 = tg3_nvram_read(tp,offset + 8U,& val);
      
#line 15834 
      if (tmp_4 != 0) 
#line 15836 
                      goto return_label; else ;
    }
  }
  
#line 15838 
  offset = (val - start) + offset;
  
#line 15840 
  tmp_5 = strlen((char const *)(& tp->fw_ver));
  
#line 15840 
  vlen = (int)tmp_5;
  
#line 15842 
  tmp_6 = vlen;
  
#line 15842 
  vlen += 1;
  
#line 15842 
  tp->fw_ver[tmp_6] = (char)44;
  
#line 15843 
  tmp_7 = vlen;
  
#line 15843 
  vlen += 1;
  
#line 15843 
  tp->fw_ver[tmp_7] = (char)32;
  
#line 15845 
  i = 0;
  
#line 15845 
  goto ldv_59478;
  ldv_59477: 
#line 15846 
  ;
  {
    __be32 v;
    int tmp_8;
    
#line 15847 
    tmp_8 = tg3_nvram_read_be32(tp,offset,& v);
    
#line 15847 
    if (tmp_8 != 0) 
#line 15848 
                    goto return_label; else ;
    
#line 15850 
    offset += 4U;
    
#line 15852 
    if ((unsigned int)vlen > 28U) {
      
#line 15853 
      memcpy((void *)(& tp->fw_ver[vlen]),(void const *)(& v),(unsigned long)(32 - vlen));
      
#line 15854 
      goto ldv_59476;
    }
    else ;
    
#line 15857 
    memcpy((void *)(& tp->fw_ver[vlen]),(void const *)(& v),4UL);
    
#line 15858 
    vlen = (int)((unsigned int)vlen + 4U);
  }
  
#line 15845 
  i += 1;
  ldv_59478: 
#line 15846 
  ;
  
#line 15845 
  if (i <= 3) 
#line 15847 
              goto ldv_59477; else 
#line 15850 
                                   goto ldv_59476;
  ldv_59476: 
#line 15851 
  ;
  return_label: 
#line 15852 
                return;
}


#line 15862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_probe_ncsi(struct tg3 *tp)
{
  u32 apedata;
  u32 tmp;
  
#line 15866 
  apedata = tg3_ape_read32(tp,16384U);
  
#line 15867 
  if (apedata != 1095779617U) 
#line 15868 
                              goto return_label; else ;
  
#line 15870 
  apedata = tg3_ape_read32(tp,16396U);
  
#line 15871 
  if ((apedata & 256U) == 0U) 
#line 15872 
                              goto return_label; else ;
  
#line 15874 
  tmp = tg3_ape_read32(tp,16400U);
  
#line 15874 
  if ((tmp & 2U) != 0U) 
#line 15875 
                        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_APE_HAS_NCSI,(unsigned long *)(& tp->tg3_flags)); else ;
  return_label: 
#line 15876 
                return;
}


#line 15878  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_dash_ver(struct tg3 *tp)
{
  int vlen;
  u32 apedata;
  char *fwtype;
  int tmp;
  size_t tmp_0;
  
#line 15884 
  apedata = tg3_ape_read32(tp,16408U);
  
#line 15886 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_APE_HAS_NCSI,(unsigned long *)(& tp->tg3_flags));
  
#line 15886 
  if (tmp != 0) 
#line 15887 
                fwtype = (char *)"NCSI";
  else 
    
#line 15888 
    if ((unsigned int)(tp->pdev)->device == 5699U) 
#line 15889 
                                                   fwtype = (char *)"SMASH"; else 
                                                                    
#line 15891 
                                                                    fwtype = (char *)"DASH";
  
#line 15893 
  tmp_0 = strlen((char const *)(& tp->fw_ver));
  
#line 15893 
  vlen = (int)tmp_0;
  
#line 15895 
  snprintf(& tp->fw_ver[vlen],(unsigned long)(32 - vlen)," %s v%d.%d.%d.%d",fwtype,apedata >> 24,(apedata >> 16) & 255U,(apedata >> 8) & 255U,apedata & 255U);
  
#line 15901 
  return;
}


#line 15903  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_otp_ver(struct tg3 *tp)
{
  u32 val;
  u32 val2;
  int tmp_0;
  
#line 15907 
  if (tp->pci_chip_rev_id >> 12 != 22370U) 
#line 15908 
                                           goto return_label; else ;
  
#line 15910 
  tmp_0 = tg3_ape_otp_read(tp,80U,& val);
  
#line 15910 
  if (tmp_0 == 0) {
    int tmp_1;
    
#line 15910 
    tmp_1 = tg3_ape_otp_read(tp,84U,& val2);
    
#line 15910 
    if (tmp_1 == 0) {
      
#line 15911 
      if ((val & 4026531840U) == 2684354560U || (val & 251658240U) == 167772160U) {
        int i;
        int vlen;
        size_t tmp;
        
#line 15913 
        u64 val64 = ((unsigned long long)val << 32) | (unsigned long long)val2;
        
#line 15914 
        u32 ver = 0U;
        
#line 15917 
        i = 0;
        
#line 15917 
        goto ldv_59500;
        ldv_59499: 
#line 15918 
        ;
        
#line 15918 
        if ((val64 & 255ULL) == 0ULL) 
#line 15919 
                                      goto ldv_59498; else ;
        
#line 15920 
        ver = (unsigned int)val64 & 255U;
        
#line 15921 
        val64 >>= 8;
        
#line 15917 
        i += 1;
        ldv_59500: 
#line 15918 
        ;
        
#line 15917 
        if (i <= 6) 
#line 15919 
                    goto ldv_59499; else 
#line 15922 
                                         goto ldv_59498;
        ldv_59498: 
#line 15923 
        ;
        
#line 15923 
        tmp = strlen((char const *)(& tp->fw_ver));
        
#line 15923 
        vlen = (int)tmp;
        
#line 15924 
        snprintf(& tp->fw_ver[vlen],(unsigned long)(32 - vlen)," .%02d",ver);
      }
      else ;
    }
    else ;
  }
  else ;
  return_label: 
#line 15926 
                return;
}


#line 15928  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_read_fw_ver(struct tg3 *tp)
{
  u32 val;
  int tmp;
  int tmp_0;
  int tmp_2;
  
#line 15931 
  bool vpd_vers = (_Bool)0;
  
#line 15933 
  if ((int)tp->fw_ver[0] != 0) 
#line 15934 
                               vpd_vers = (_Bool)1; else ;
  
#line 15936 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
  
#line 15936 
  if (tmp != 0) {
    
#line 15937 
    strcat((char *)(& tp->fw_ver),"sb");
    
#line 15938 
    tg3_read_otp_ver(tp);
    
#line 15939 
    goto return_label;
  }
  else ;
  
#line 15942 
  tmp_0 = tg3_nvram_read(tp,0U,& val);
  
#line 15942 
  if (tmp_0 != 0) 
#line 15943 
                  goto return_label; else ;
  
#line 15945 
  if (val == 1721324970U) 
#line 15946 
                          tg3_read_bc_ver(tp);
  else 
    
#line 15947 
    if ((val & 4278190080U) == 2768240640U) 
#line 15948 
                                            tg3_read_sb_ver(tp,val);
    else 
      
#line 15949 
      if ((val & 65535U) == 43981U) 
#line 15950 
                                    tg3_read_hwsb_ver(tp); else ;
  
#line 15952 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 15952 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 15953 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
    
#line 15953 
    if (tmp_1 != 0) {
      
#line 15954 
      tg3_probe_ncsi(tp);
      
#line 15955 
      if (! vpd_vers) 
#line 15956 
                      tg3_read_dash_ver(tp); else ;
    }
    else 
      
#line 15957 
      if (! vpd_vers) 
#line 15958 
                      tg3_read_mgmtfw_ver(tp); else ;
  }
  else ;
  
#line 15962 
  tp->fw_ver[31] = (char)0;
  return_label: 
#line 15963 
                return;
}


#line 15965  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
__inline static u32 tg3_rx_ret_ring_size(struct tg3 *tp)
{
  u32 __retres;
  int tmp_1;
  
#line 15967 
  tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 15967 
  if (tmp_1 != 0) {
    
#line 15968 
    __retres = 4096U;
    
#line 15968 
    goto return_label;
  }
  else {
    int tmp;
    
#line 15969 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 15969 
    if (tmp != 0) {
      int tmp_0;
      
#line 15969 
      tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
      
#line 15969 
      if (tmp_0 == 0) {
        
#line 15970 
        __retres = 1024U;
        
#line 15970 
        goto return_label;
      }
      else {
        
#line 15972 
        __retres = 512U;
        
#line 15972 
        goto return_label;
      }
    }
    else {
      
#line 15972 
      __retres = 512U;
      
#line 15972 
      goto return_label;
    }
  }
  return_label: 
#line 15967 
                return __retres;
}


#line 15975  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct pci_device_id const tg3_write_reorder_chipsets[4U] = {{.vendor = 4130U, .device = 28684U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 4130U, .device = 29776U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 4358U, .device = 12680U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 15982  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct pci_dev *tg3_find_peer(struct tg3 *tp)
{
  struct pci_dev *__retres;
  struct pci_dev *peer;
  unsigned int func;
  
#line 15985 
  unsigned int devnr = (tp->pdev)->devfn & 4294967288U;
  
#line 15987 
  func = 0U;
  
#line 15987 
  goto ldv_59518;
  ldv_59517: 
#line 15988 
  ;
  
#line 15988 
  peer = pci_get_slot((tp->pdev)->bus,devnr | func);
  
#line 15989 
  if (peer != (struct pci_dev *)0 && tp->pdev != peer) 
#line 15990 
                                                       goto ldv_59516; else ;
  
#line 15991 
  pci_dev_put(peer);
  
#line 15987 
  func += 1U;
  ldv_59518: 
#line 15988 
  ;
  
#line 15987 
  if (func <= 7U) 
#line 15989 
                  goto ldv_59517; else 
#line 15992 
                                       goto ldv_59516;
  ldv_59516: 
#line 15993 
  ;
  
#line 15996 
  if (peer == (struct pci_dev *)0) {
    
#line 15997 
    peer = tp->pdev;
    
#line 15998 
    __retres = peer;
    
#line 15998 
    goto return_label;
  }
  else ;
  
#line 16005 
  pci_dev_put(peer);
  
#line 16007 
  __retres = peer;
  return_label: 
#line 16007 
                return __retres;
}


#line 16010  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_detect_asic_rev(struct tg3 *tp, u32 misc_ctrl_reg)
{
  int tmp;
  
#line 16012 
  tp->pci_chip_rev_id = misc_ctrl_reg >> 16;
  
#line 16013 
  if (tp->pci_chip_rev_id >> 12 == 15U) {
    u32 reg;
    
#line 16019 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
    
#line 16021 
    if (((((((((((unsigned int)(tp->pdev)->device == 5717U || (unsigned int)(tp->pdev)->device == 5733U) || (unsigned int)(tp->pdev)->device == 5718U) || (unsigned int)(tp->pdev)->device == 5719U) || (unsigned int)(tp->pdev)->device == 5727U) || (unsigned int)(tp->pdev)->device == 5763U) || (unsigned int)(tp->pdev)->device == 5698U) || (unsigned int)(tp->pdev)->device == 5767U) || (unsigned int)(tp->pdev)->device == 5699U) || (unsigned int)(tp->pdev)->device == 5875U) || (unsigned int)(tp->pdev)->device == 5697U) 
      
#line 16032 
      reg = 244U;
    else 
      
#line 16033 
      if ((((((((((unsigned int)(tp->pdev)->device == 5809U || (unsigned int)(tp->pdev)->device == 5813U) || (unsigned int)(tp->pdev)->device == 5808U) || (unsigned int)(tp->pdev)->device == 5812U) || (unsigned int)(tp->pdev)->device == 5810U) || (unsigned int)(tp->pdev)->device == 5814U) || (unsigned int)(tp->pdev)->device == 5762U) || (unsigned int)(tp->pdev)->device == 5766U) || (unsigned int)(tp->pdev)->device == 5815U) || (unsigned int)(tp->pdev)->device == 5811U) 
        
#line 16043 
        reg = 252U; else 
#line 16045 
                         reg = 188U;
    
#line 16047 
    pci_read_config_dword((struct pci_dev const *)tp->pdev,(int)reg,& tp->pci_chip_rev_id);
  }
  else ;
  
#line 16053 
  if (tp->pci_chip_rev_id == 20480U) 
#line 16054 
                                     tp->pci_chip_rev_id = 24576U; else ;
  
#line 16056 
  if (tp->pci_chip_rev_id == 91320832U) 
#line 16057 
                                        tp->pci_chip_rev_id = 91357184U; else ;
  
#line 16059 
  if ((tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) || tp->pci_chip_rev_id >> 12 == 22304U) 
    
#line 16062 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16064 
  if (tp->pci_chip_rev_id >> 12 == 358277U || tp->pci_chip_rev_id >> 12 == 358246U) 
    
#line 16066 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16068 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
  
#line 16068 
  if (tmp != 0) 
#line 16070 
                _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  else {
    int tmp_0;
    
#line 16068 
    tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 16068 
    if (tmp_0 != 0) 
#line 16070 
                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
    else 
      
#line 16068 
      if (tp->pci_chip_rev_id >> 12 == 22370U) 
#line 16070 
                                               _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  
#line 16073 
  if (((((tp->pci_chip_rev_id >> 12) + 4294967286U <= 1U || tp->pci_chip_rev_id >> 12 == 22404U) || tp->pci_chip_rev_id >> 12 == 22369U) || tp->pci_chip_rev_id >> 12 == 22405U) || tp->pci_chip_rev_id >> 12 == 358272U) 
    
#line 16080 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
  else {
    int tmp_1;
    
#line 16078 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 16078 
    if (tmp_1 != 0) 
#line 16080 
                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  
#line 16082 
  if ((tp->pci_chip_rev_id >> 12) + 4294967288U <= 1U) 
#line 16084 
                                                       _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16086 
  if ((tp->pci_chip_rev_id >> 12 == 4U || tp->pci_chip_rev_id >> 12 == 6U) || tp->pci_chip_rev_id >> 12 == 12U) 
    
#line 16091 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
  else {
    int tmp_2;
    
#line 16088 
    tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 16088 
    if (tmp_2 != 0) 
#line 16091 
                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
    else {
      int tmp_3;
      
#line 16089 
      tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
      
#line 16089 
      if (tmp_3 != 0) 
#line 16091 
                      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags)); else ;
    }
  }
  
#line 16093 
  if (tp->pci_chip_rev_id >> 12 == 3U) 
#line 16095 
                                       _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  else {
    int tmp_4;
    
#line 16093 
    tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 16093 
    if (tmp_4 != 0) 
#line 16095 
                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  
#line 16096 
  return;
}


#line 16098  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static bool tg3_10_100_only_device(struct tg3 *tp, struct pci_device_id const *ent)
{
  bool __retres;
  u32 tmp;
  
#line 16101 
  tmp = (*(tp->read32))(tp,26628U);
  
#line 16101 
  u32 grc_misc_cfg = tmp & 122880U;
  
#line 16103 
  if ((tp->pci_chip_rev_id >> 12 == 1U && (grc_misc_cfg == 32768U || grc_misc_cfg == 16384U)) || (tp->phy_flags & 64U) != 0U) {
    
#line 16106 
    __retres = (_Bool)1;
    
#line 16106 
    goto return_label;
  }
  else ;
  
#line 16108 
  if ((ent->driver_data & 1UL) != 0UL) 
    
#line 16109 
    if (tp->pci_chip_rev_id >> 12 == 3U) {
      
#line 16110 
      if ((ent->driver_data & 2UL) != 0UL) {
        
#line 16111 
        __retres = (_Bool)1;
        
#line 16111 
        goto return_label;
      }
      else ;
    }
    else {
      
#line 16113 
      __retres = (_Bool)1;
      
#line 16113 
      goto return_label;
    }
  else ;
  
#line 16117 
  __retres = (_Bool)0;
  return_label: 
#line 16117 
                return __retres;
}


#line 16120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_invariants(struct tg3 *tp, struct pci_device_id const *ent)
{
  int __retres;
  u32 misc_ctrl_reg;
  u32 pci_state_reg;
  u32 grc_misc_cfg;
  u32 val;
  u16 pci_cmd;
  int err;
  int tmp;
  int tmp_3;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  bool tmp_17;
  int tmp_18;
  int tmp_22;
  int tmp_24;
  int tmp_26;
  int tmp_30;
  int tmp_31;
  int tmp_33;
  int tmp_39;
  int tmp_41;
  int tmp_45;
  int tmp_46;
  int tmp_47;
  bool tmp_48;
  int tmp_49;
  int tmp_52;
  int tmp_57;
  int tmp_56;
  int tmp_59;
  int tmp_58;
  u32 tmp_60;
  int tmp_62;
  
#line 16135 
  pci_read_config_word((struct pci_dev const *)tp->pdev,4,& pci_cmd);
  
#line 16136 
  pci_cmd = (unsigned short)((unsigned int)pci_cmd & 65519U);
  
#line 16137 
  pci_write_config_word((struct pci_dev const *)tp->pdev,4,(unsigned short)((int)pci_cmd));
  
#line 16144 
  pci_read_config_dword((struct pci_dev const *)tp->pdev,104,& misc_ctrl_reg);
  
#line 16146 
  tp->misc_host_ctrl |= misc_ctrl_reg & 4294901760U;
  
#line 16148 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,104,tp->misc_host_ctrl);
  
#line 16151 
  tg3_detect_asic_rev(tp,misc_ctrl_reg);
  
#line 16170 
  if (tp->pci_chip_rev_id + 4294963199U <= 1U) {
    
#line 16176 
    struct tg3_dev_id ich_chipsets[5U] = {{.vendor = 32902U, .device = 9240U, .rev = 4294967295U}, {.vendor = 32902U, .device = 9256U, .rev = 4294967295U}, {.vendor = 32902U, .device = 9294U, .rev = 10U}, {.vendor = 32902U, .device = 9288U, .rev = 4294967295U}, {.vendor = 0U, .device = 0U, .rev = 0U}};
    
#line 16187 
    struct tg3_dev_id *pci_id = &(ich_chipsets[0]);
    
#line 16188 
    struct pci_dev *bridge = (struct pci_dev *)0;
    
#line 16190 
    goto ldv_59546;
    ldv_59548: 
#line 16191 
    ;
    
#line 16191 
    bridge = pci_get_device(pci_id->vendor,pci_id->device,bridge);
    
#line 16193 
    if (bridge == (struct pci_dev *)0) {
      
#line 16194 
      pci_id += 1;
      
#line 16195 
      goto ldv_59546;
    }
    else ;
    
#line 16197 
    if (pci_id->rev != 4294967295U) {
      
#line 16198 
      if ((unsigned int)bridge->revision > pci_id->rev) 
#line 16199 
                                                        goto ldv_59546; else ;
    }
    else ;
    
#line 16201 
    if (bridge->subordinate != (struct pci_bus *)0 && (int)(bridge->subordinate)->number == (int)((tp->pdev)->bus)->number) {
      
#line 16204 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ICH_WORKAROUND,(unsigned long *)(& tp->tg3_flags));
      
#line 16205 
      pci_dev_put(bridge);
      
#line 16206 
      goto ldv_59547;
    }
    else ;
    ldv_59546: 
#line 16208 
    ;
    
#line 16190 
    if (pci_id->vendor != 0U) 
#line 16192 
                              goto ldv_59548; else 
#line 16195 
                                                   goto ldv_59547;
    ldv_59547: 
#line 16196 
    ;
  }
  else ;
  
#line 16211 
  if (tp->pci_chip_rev_id >> 12 == 0U) {
    
#line 16215 
    struct tg3_dev_id_0 bridge_chipsets[3U] = {{.vendor = 32902U, .device = 809U}, {.vendor = 32902U, .device = 810U}, {.vendor = 0U, .device = 0U}};
    
#line 16220 
    struct tg3_dev_id_0 *pci_id_0 = &(bridge_chipsets[0]);
    
#line 16221 
    struct pci_dev *bridge_0 = (struct pci_dev *)0;
    
#line 16223 
    goto ldv_59555;
    ldv_59557: 
#line 16224 
    ;
    
#line 16224 
    bridge_0 = pci_get_device(pci_id_0->vendor,pci_id_0->device,bridge_0);
    
#line 16227 
    if (bridge_0 == (struct pci_dev *)0) {
      
#line 16228 
      pci_id_0 += 1;
      
#line 16229 
      goto ldv_59555;
    }
    else ;
    
#line 16231 
    if ((bridge_0->subordinate != (struct pci_bus *)0 && (int)(bridge_0->subordinate)->number <= (int)((tp->pdev)->bus)->number) && (bridge_0->subordinate)->busn_res.end >= (unsigned long long)((tp->pdev)->bus)->number) {
      
#line 16236 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_5701_DMA_BUG,(unsigned long *)(& tp->tg3_flags));
      
#line 16237 
      pci_dev_put(bridge_0);
      
#line 16238 
      goto ldv_59556;
    }
    else ;
    ldv_59555: 
#line 16240 
    ;
    
#line 16223 
    if (pci_id_0->vendor != 0U) 
#line 16225 
                                goto ldv_59557; else 
#line 16228 
                                                     goto ldv_59556;
    ldv_59556: 
#line 16229 
    ;
  }
  else ;
  
#line 16249 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
  
#line 16249 
  if (tmp != 0) {
    
#line 16250 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_40BIT_DMA_BUG,(unsigned long *)(& tp->tg3_flags));
    
#line 16251 
    tp->msi_cap = (int)(tp->pdev)->msi_cap;
  }
  else {
    
#line 16253 
    struct pci_dev *bridge_1 = (struct pci_dev *)0;
    ldv_59560: 
#line 16254 
    ;
    
#line 16256 
    bridge_1 = pci_get_device(4454U,259U,bridge_1);
    
#line 16259 
    if (((bridge_1 != (struct pci_dev *)0 && bridge_1->subordinate != (struct pci_bus *)0) && (int)(bridge_1->subordinate)->number <= (int)((tp->pdev)->bus)->number) && (bridge_1->subordinate)->busn_res.end >= (unsigned long long)((tp->pdev)->bus)->number) {
      
#line 16264 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_40BIT_DMA_BUG,(unsigned long *)(& tp->tg3_flags));
      
#line 16265 
      pci_dev_put(bridge_1);
      
#line 16266 
      goto ldv_59559;
    }
    else ;
    
#line 16268 
    if (bridge_1 != (struct pci_dev *)0) 
#line 16270 
                                         goto ldv_59560; else 
#line 16273 
                                                              goto ldv_59559;
    ldv_59559: 
#line 16274 
    ;
  }
  
#line 16271 
  if (tp->pci_chip_rev_id >> 12 == 2U || tp->pci_chip_rev_id >> 12 == 9U) 
    
#line 16273 
    tp->pdev_peer = tg3_find_peer(tp); else ;
  
#line 16276 
  if (tp->pci_chip_rev_id == 91328512U) ;
  else {
    int tmp_2;
    
#line 16278 
    tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 16278 
    if (tmp_2 != 0) 
#line 16279 
                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
    else {
      int tmp_1;
      
#line 16280 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 16280 
      if (tmp_1 != 0) 
#line 16280 
                      goto _LOR;
      else 
        
#line 16280 
        if (tp->pci_chip_rev_id >> 12 == 12U) _LOR: 
#line 16282 
                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
        else {
          int tmp_0;
          
#line 16283 
          tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
          
#line 16283 
          if (tmp_0 != 0) {
            
#line 16284 
            _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
            
#line 16285 
            _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_BUG,(unsigned long *)(& tp->tg3_flags));
            
#line 16286 
            if (tp->pci_chip_rev_id >> 12 == 4U && tp->pci_chip_rev_id > 16897U) 
              
#line 16288 
              _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_BUG,(unsigned long *)(& tp->tg3_flags)); else ;
          }
          else 
            
#line 16289 
            if ((tp->pci_chip_rev_id >> 12 != 7U && tp->pci_chip_rev_id >> 12 != 0U) && tp->pci_chip_rev_id != 12288U) {
              
#line 16292 
              _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FW_TSO,(unsigned long *)(& tp->tg3_flags));
              
#line 16293 
              _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_BUG,(unsigned long *)(& tp->tg3_flags));
              
#line 16294 
              if (tp->pci_chip_rev_id >> 12 == 3U) 
#line 16295 
                                                   tp->fw_needed = "tigon/tg3_tso5.bin"; else 
                                                                    
#line 16297 
                                                                    tp->fw_needed = "tigon/tg3_tso.bin";
            }
            else ;
        }
    }
  }
  
#line 16301 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
  
#line 16301 
  if (tmp_3 != 0) 
#line 16301 
                  goto _LOR_0;
  else {
    int tmp_4;
    
#line 16301 
    tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
    
#line 16301 
    if (tmp_4 != 0) 
#line 16301 
                    goto _LOR_0;
    else {
      int tmp_5;
      
#line 16302 
      tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
      
#line 16302 
      if (tmp_5 != 0) 
#line 16301 
                      goto _LOR_0;
      else {
        int tmp_6;
        
#line 16303 
        tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FW_TSO,(unsigned long *)(& tp->tg3_flags));
        
#line 16303 
        if (tmp_6 != 0) _LOR_0: 
#line 16309 
                                _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
        else {
          
#line 16311 
          _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
          
#line 16312 
          _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_BUG,(unsigned long *)(& tp->tg3_flags));
          
#line 16313 
          tp->fw_needed = (char const *)0;
        }
      }
    }
  }
  
#line 16316 
  if (tp->pci_chip_rev_id == 0U) 
#line 16317 
                                 tp->fw_needed = "tigon/tg3.bin"; else ;
  
#line 16319 
  if (tp->pci_chip_rev_id >> 12 == 358246U) 
#line 16320 
                                            tp->fw_needed = "tigon/tg357766.bin"; else ;
  
#line 16322 
  tp->irq_max = 1U;
  
#line 16324 
  tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5750_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 16324 
  if (tmp_9 != 0) {
    int tmp_7;
    int tmp_8;
    
#line 16325 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSI,(unsigned long *)(& tp->tg3_flags));
    
#line 16326 
    if ((tp->pci_chip_rev_id >> 8) + 4294967232U <= 1U || ((tp->pci_chip_rev_id >> 12 == 9U && tp->pci_chip_rev_id <= 36866U) && tp->pdev_peer == tp->pdev)) 
      
#line 16331 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSI,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 16333 
    tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 16333 
    if (tmp_7 != 0) 
#line 16335 
                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_1SHOT_MSI,(unsigned long *)(& tp->tg3_flags));
    else 
      
#line 16333 
      if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 16335 
                                            _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_1SHOT_MSI,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 16338 
    tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 16338 
    if (tmp_8 != 0) {
      
#line 16339 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
      
#line 16340 
      tp->irq_max = 5U;
    }
    else ;
  }
  else ;
  
#line 16344 
  tp->txq_max = 1U;
  
#line 16345 
  tp->rxq_max = 1U;
  
#line 16346 
  if (tp->irq_max > 1U) {
    
#line 16347 
    tp->rxq_max = 4U;
    
#line 16348 
    tg3_rss_init_dflt_indir_tbl(tp,4U);
    
#line 16350 
    if (tp->pci_chip_rev_id >> 12 == 22297U || tp->pci_chip_rev_id >> 12 == 22304U) 
      
#line 16352 
      tp->txq_max = tp->irq_max + 4294967295U; else ;
  }
  else ;
  
#line 16355 
  tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 16355 
  if (tmp_10 != 0) 
#line 16357 
                   _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_SHORT_DMA_BUG,(unsigned long *)(& tp->tg3_flags));
  else 
    
#line 16355 
    if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 16357 
                                          _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_SHORT_DMA_BUG,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16359 
  if (tp->pci_chip_rev_id >> 12 == 22297U) 
#line 16360 
                                           tp->dma_limit = 4096U; else ;
  
#line 16362 
  if (((tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) || tp->pci_chip_rev_id >> 12 == 22304U) || tp->pci_chip_rev_id >> 12 == 22370U) 
    
#line 16366 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16368 
  tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 16368 
  if (tmp_11 != 0) {
    
#line 16368 
    if (tp->pci_chip_rev_id != 91328512U) 
#line 16370 
                                          _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USE_JUMBO_BDFLAG,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  else ;
  
#line 16372 
  tmp_12 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 16372 
  if (tmp_12 == 0) 
#line 16375 
                   _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  else {
    int tmp_13;
    
#line 16372 
    tmp_13 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 16372 
    if (tmp_13 != 0) 
#line 16375 
                     _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    else {
      int tmp_14;
      
#line 16373 
      tmp_14 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_JUMBO_BDFLAG,(unsigned long *)(& tp->tg3_flags));
      
#line 16373 
      if (tmp_14 != 0) 
#line 16375 
                       _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_JUMBO_CAPABLE,(unsigned long *)(& tp->tg3_flags)); else ;
    }
  }
  
#line 16377 
  pci_read_config_dword((struct pci_dev const *)tp->pdev,112,& pci_state_reg);
  
#line 16380 
  tmp_17 = pci_is_pcie(tp->pdev);
  
#line 16380 
  if ((int)tmp_17 != 0) {
    u16 lnkctl;
    
#line 16383 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
    
#line 16385 
    pcie_capability_read_word(tp->pdev,16,& lnkctl);
    
#line 16386 
    if (((int)lnkctl & 256) != 0) {
      
#line 16387 
      if (tp->pci_chip_rev_id >> 12 == 12U) {
        
#line 16388 
        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
        
#line 16389 
        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
      }
      else ;
      
#line 16391 
      if (((tp->pci_chip_rev_id >> 12 == 22404U || tp->pci_chip_rev_id >> 12 == 22369U) || tp->pci_chip_rev_id == 1467482112U) || tp->pci_chip_rev_id == 1467482113U) 
        
#line 16395 
        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_CLKREQ_BUG,(unsigned long *)(& tp->tg3_flags)); else ;
    }
    else 
      
#line 16396 
      if (tp->pci_chip_rev_id == 91320320U) 
#line 16397 
                                            _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_L1PLLPD_EN,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  else 
    
#line 16399 
    if (tp->pci_chip_rev_id >> 12 == 22405U) 
#line 16404 
                                             _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
    else {
      int tmp_15;
      
#line 16405 
      tmp_15 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 16405 
      if (tmp_15 == 0) 
#line 16405 
                       goto _LOR_1;
      else {
        int tmp_16;
        
#line 16405 
        tmp_16 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
        
#line 16405 
        if (tmp_16 != 0) {
          _LOR_1: {
                    
#line 16407 
                    tp->pcix_cap = pci_find_capability(tp->pdev,7);
                    
#line 16408 
                    if (tp->pcix_cap == 0) {
                      
#line 16409 
                      dev_err((struct device const *)(& (tp->pdev)->dev),"Cannot find PCI-X capability, aborting\n");
                      
#line 16411 
                      __retres = -5;
                      
#line 16411 
                      goto return_label;
                    }
                    else ;
                    
#line 16414 
                    if ((pci_state_reg & 4U) == 0U) 
#line 16415 
                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags)); else ;
                  }
        }
        else ;
      }
    }
  
#line 16424 
  tmp_18 = pci_dev_present((struct pci_device_id const *)(& tg3_write_reorder_chipsets));
  
#line 16424 
  if (tmp_18 != 0) {
    int tmp_19;
    
#line 16424 
    tmp_19 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
    
#line 16424 
    if (tmp_19 == 0) 
#line 16426 
                     _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_MBOX_WRITE_REORDER,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  else ;
  
#line 16428 
  pci_read_config_byte((struct pci_dev const *)tp->pdev,12,& tp->pci_cacheline_sz);
  
#line 16430 
  pci_read_config_byte((struct pci_dev const *)tp->pdev,13,& tp->pci_lat_timer);
  
#line 16432 
  if (tp->pci_chip_rev_id >> 12 == 1U && (unsigned int)tp->pci_lat_timer <= 63U) {
    
#line 16434 
    tp->pci_lat_timer = (unsigned char)64U;
    
#line 16435 
    pci_write_config_byte((struct pci_dev const *)tp->pdev,13,(unsigned char)((int)tp->pci_lat_timer));
  }
  else ;
  
#line 16442 
  if (tp->pci_chip_rev_id >> 8 == 113U) {
    int tmp_20;
    
#line 16446 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TXD_MBOX_HWBUG,(unsigned long *)(& tp->tg3_flags));
    
#line 16453 
    tmp_20 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
    
#line 16453 
    if (tmp_20 != 0) {
      u32 pm_reg;
      
#line 16456 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PCIX_TARGET_HWBUG,(unsigned long *)(& tp->tg3_flags));
      
#line 16462 
      pci_read_config_dword((struct pci_dev const *)tp->pdev,(int)(tp->pdev)->pm_cap + 4,& pm_reg);
      
#line 16465 
      pm_reg &= 4294967292U;
      
#line 16466 
      pm_reg |= 256U;
      
#line 16467 
      pci_write_config_dword((struct pci_dev const *)tp->pdev,(int)(tp->pdev)->pm_cap + 4,pm_reg);
      
#line 16472 
      pci_read_config_word((struct pci_dev const *)tp->pdev,4,& pci_cmd);
      
#line 16473 
      pci_cmd = (unsigned short)((unsigned int)pci_cmd | 320U);
      
#line 16474 
      pci_write_config_word((struct pci_dev const *)tp->pdev,4,(unsigned short)((int)pci_cmd));
    }
    else ;
  }
  else ;
  
#line 16478 
  if ((pci_state_reg & 8U) != 0U) 
#line 16479 
                                  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PCI_HIGH_SPEED,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16480 
  if ((pci_state_reg & 16U) != 0U) 
#line 16481 
                                   _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PCI_32BIT,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16484 
  if (tp->pci_chip_rev_id == 8192U && (pci_state_reg & 8192U) == 0U) {
    
#line 16486 
    pci_state_reg |= 8192U;
    
#line 16487 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,112,pci_state_reg);
  }
  else ;
  
#line 16491 
  tp->read32 = & tg3_read32;
  
#line 16492 
  tp->write32 = & tg3_write32;
  
#line 16493 
  tp->read32_mbox = & tg3_read32;
  
#line 16494 
  tp->write32_mbox = & tg3_write32;
  
#line 16495 
  tp->write32_tx_mbox = & tg3_write32;
  
#line 16496 
  tp->write32_rx_mbox = & tg3_write32;
  
#line 16499 
  tmp_22 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_TARGET_HWBUG,(unsigned long *)(& tp->tg3_flags));
  
#line 16499 
  if (tmp_22 != 0) 
#line 16500 
                   tp->write32 = & tg3_write_indirect_reg32;
  else 
    
#line 16501 
    if (tp->pci_chip_rev_id >> 12 == 0U) 
#line 16511 
                                         tp->write32 = & tg3_write_flush_reg32;
    else {
      int tmp_21;
      
#line 16501 
      tmp_21 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
      
#line 16501 
      if (tmp_21 != 0) {
        
#line 16502 
        if (tp->pci_chip_rev_id == 16384U) 
#line 16511 
                                           tp->write32 = & tg3_write_flush_reg32; else ;
      }
      else ;
    }
  
#line 16514 
  tmp_24 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TXD_MBOX_HWBUG,(unsigned long *)(& tp->tg3_flags));
  
#line 16514 
  if (tmp_24 != 0) 
#line 16514 
                   goto _LOR_2;
  else {
    int tmp_25;
    
#line 16514 
    tmp_25 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MBOX_WRITE_REORDER,(unsigned long *)(& tp->tg3_flags));
    
#line 16514 
    if (tmp_25 != 0) {
      _LOR_2: {
                int tmp_23;
                
#line 16515 
                tp->write32_tx_mbox = & tg3_write32_tx_mbox;
                
#line 16516 
                tmp_23 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_MBOX_WRITE_REORDER,(unsigned long *)(& tp->tg3_flags));
                
#line 16516 
                if (tmp_23 != 0) 
#line 16517 
                                 tp->write32_rx_mbox = & tg3_write_flush_reg32; else ;
              }
    }
    else ;
  }
  
#line 16520 
  tmp_26 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ICH_WORKAROUND,(unsigned long *)(& tp->tg3_flags));
  
#line 16520 
  if (tmp_26 != 0) {
    
#line 16521 
    tp->read32 = & tg3_read_indirect_reg32;
    
#line 16522 
    tp->write32 = & tg3_write_indirect_reg32;
    
#line 16523 
    tp->read32_mbox = & tg3_read_indirect_mbox;
    
#line 16524 
    tp->write32_mbox = & tg3_write_indirect_mbox;
    
#line 16525 
    tp->write32_tx_mbox = & tg3_write_indirect_mbox;
    
#line 16526 
    tp->write32_rx_mbox = & tg3_write_indirect_mbox;
    
#line 16528 
    iounmap((void volatile *)tp->regs);
    
#line 16529 
    tp->regs = (void *)0;
    
#line 16531 
    pci_read_config_word((struct pci_dev const *)tp->pdev,4,& pci_cmd);
    
#line 16532 
    pci_cmd = (unsigned short)((unsigned int)pci_cmd & 65533U);
    
#line 16533 
    pci_write_config_word((struct pci_dev const *)tp->pdev,4,(unsigned short)((int)pci_cmd));
  }
  else ;
  
#line 16535 
  if (tp->pci_chip_rev_id >> 12 == 12U) {
    
#line 16536 
    tp->read32_mbox = & tg3_read32_mbox_5906;
    
#line 16537 
    tp->write32_mbox = & tg3_write32_mbox_5906;
    
#line 16538 
    tp->write32_tx_mbox = & tg3_write32_mbox_5906;
    
#line 16539 
    tp->write32_rx_mbox = & tg3_write32_mbox_5906;
  }
  else ;
  
#line 16542 
  if (tp->write32 == & tg3_write_indirect_reg32) 
#line 16546 
                                                 _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_SRAM_USE_CONFIG,(unsigned long *)(& tp->tg3_flags));
  else {
    int tmp_27;
    
#line 16542 
    tmp_27 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
    
#line 16542 
    if (tmp_27 != 0) {
      
#line 16543 
      if (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) 
        
#line 16546 
        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_SRAM_USE_CONFIG,(unsigned long *)(& tp->tg3_flags)); else ;
    }
    else ;
  }
  
#line 16553 
  val = (*(tp->read32))(tp,16384U);
  
#line 16554 
  (*(tp->write32))(tp,16384U,val | 2U);
  
#line 16556 
  tp->pci_fn = (int)(tp->pdev)->devfn & 3;
  
#line 16557 
  if (tp->pci_chip_rev_id >> 12 == 2U) 
#line 16557 
                                       goto _LOR_3;
  else {
    int tmp_29;
    
#line 16557 
    tmp_29 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 16557 
    if (tmp_29 != 0) {
      _LOR_3: {
                int tmp_28;
                
#line 16559 
                tmp_28 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
                
#line 16559 
                if (tmp_28 != 0) {
                  
#line 16560 
                  pci_read_config_dword((struct pci_dev const *)tp->pdev,tp->pcix_cap + 4,& val);
                  
#line 16563 
                  tp->pci_fn = (int)val & 7;
                }
                else ;
              }
    }
    else 
      
#line 16565 
      if ((tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22297U) || tp->pci_chip_rev_id >> 12 == 22304U) {
        
#line 16568 
        tg3_read_mem(tp,3584U,& val);
        
#line 16569 
        if ((val & 65535U) != 13868U) 
#line 16570 
                                      val = (*(tp->read32))(tp,13868U); else ;
        
#line 16572 
        if (tp->pci_chip_rev_id >> 12 == 22295U) 
#line 16573 
                                                 tp->pci_fn = (int)(val >> 29) & 1; else 
                                                                    
#line 16575 
                                                                    tp->pci_fn = (int)(val >> 30);
      }
      else ;
  }
  
#line 16579 
  tmp_30 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FLUSH_POSTED_WRITES,(unsigned long *)(& tp->tg3_flags));
  
#line 16579 
  if (tmp_30 != 0) {
    
#line 16580 
    tp->write32_tx_mbox = & tg3_write_flush_reg32;
    
#line 16581 
    tp->write32_rx_mbox = & tg3_write_flush_reg32;
  }
  else ;
  
#line 16592 
  tg3_get_eeprom_hw_cfg(tp);
  
#line 16594 
  tmp_31 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_FW_TSO,(unsigned long *)(& tp->tg3_flags));
  
#line 16594 
  if (tmp_31 != 0) {
    int tmp_32;
    
#line 16594 
    tmp_32 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
    
#line 16594 
    if (tmp_32 != 0) {
      
#line 16595 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
      
#line 16596 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TSO_BUG,(unsigned long *)(& tp->tg3_flags));
      
#line 16597 
      tp->fw_needed = (char const *)0;
    }
    else ;
  }
  else ;
  
#line 16600 
  tmp_33 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 16600 
  if (tmp_33 != 0) {
    
#line 16604 
    pci_state_reg |= 458752U;
    
#line 16607 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,112,pci_state_reg);
    
#line 16610 
    tg3_ape_lock_init(tp);
  }
  else ;
  
#line 16618 
  tp->grc_local_ctrl = 16777224U;
  
#line 16619 
  if (tp->pci_chip_rev_id >> 12 == 7U) 
#line 16619 
                                       goto _LOR_4;
  else {
    int tmp_34;
    
#line 16619 
    tmp_34 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_EEPROM_WRITE_PROT,(unsigned long *)(& tp->tg3_flags));
    
#line 16619 
    if (tmp_34 != 0) _LOR_4: 
#line 16621 
                             tp->grc_local_ctrl |= 36864U;
    else 
      
#line 16626 
      if (tp->pci_chip_rev_id >> 12 == 6U) 
#line 16627 
                                           tp->grc_local_ctrl |= 64U; else ;
  }
  
#line 16629 
  if (tp->pci_chip_rev_id >> 12 == 10U || tp->pci_chip_rev_id >> 12 == 358272U) 
    
#line 16632 
    tp->grc_local_ctrl |= 16U;
  else {
    int tmp_35;
    
#line 16630 
    tmp_35 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 16630 
    if (tmp_35 != 0) 
#line 16632 
                     tp->grc_local_ctrl |= 16U; else ;
  }
  
#line 16634 
  if ((unsigned int)(tp->pdev)->device == 5761U || (unsigned int)(tp->pdev)->device == 5768U) {
    int tmp_36;
    
#line 16637 
    tp->grc_local_ctrl |= 16U;
    
#line 16638 
    tmp_36 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_NIC,(unsigned long *)(& tp->tg3_flags));
    
#line 16638 
    if (tmp_36 != 0) 
#line 16640 
                     tp->grc_local_ctrl |= 18432U; else ;
  }
  else ;
  
#line 16644 
  if (tp->pci_chip_rev_id >> 12 == 22370U) {
    u32 tmp_37;
    
#line 16645 
    tmp_37 = (*(tp->read32))(tp,26632U);
    
#line 16646 
    tp->grc_local_ctrl |= tmp_37 & 16U;
  }
  else ;
  
#line 16649 
  tg3_pwrsrc_switch_to_vmain(tp);
  
#line 16654 
  if ((tp->dev)->mtu > 1500U) {
    int tmp_38;
    
#line 16654 
    tmp_38 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 16654 
    if (tmp_38 == 0) 
#line 16655 
                     _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_JUMBO_RING_ENABLE,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  else ;
  
#line 16658 
  if (((tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id == 0U) || tp->pci_chip_rev_id == 256U) || tp->pci_chip_rev_id == 258U) 
    
#line 16662 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_WOL_SPEED_100MB,(unsigned long *)(& tp->tg3_flags)); else 
                                                                    
#line 16664 
                                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_WOL_SPEED_100MB,(unsigned long *)(& tp->tg3_flags));
  
#line 16667 
  if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 16668 
                                        tp->phy_flags |= 64U; else ;
  
#line 16671 
  if (((tp->pci_chip_rev_id >> 12 == 7U || ((tp->pci_chip_rev_id >> 12 == 3U && tp->pci_chip_rev_id != 12288U) && tp->pci_chip_rev_id != 12289U)) || (tp->phy_flags & 64U) != 0U) || (tp->phy_flags & 48U) != 0U) 
    
#line 16677 
    tp->phy_flags |= 1024U; else ;
  
#line 16679 
  if (tp->pci_chip_rev_id >> 8 == 16U || tp->pci_chip_rev_id >> 8 == 32U) 
    
#line 16681 
    tp->phy_flags |= 8192U; else ;
  
#line 16682 
  if (tp->pci_chip_rev_id == 8192U) 
#line 16683 
                                    tp->phy_flags |= 16384U; else ;
  
#line 16685 
  tmp_39 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 16685 
  if (tmp_39 != 0) {
    
#line 16685 
    if ((tp->phy_flags & 64U) == 0U) {
      
#line 16686 
      if (tp->pci_chip_rev_id >> 12 != 22405U) {
        
#line 16687 
        if (tp->pci_chip_rev_id >> 12 != 358272U) {
          int tmp_40;
          
#line 16688 
          tmp_40 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
          
#line 16688 
          if (tmp_40 == 0) 
            
#line 16690 
            if (((tp->pci_chip_rev_id >> 12) + 4294967286U <= 1U || tp->pci_chip_rev_id >> 12 == 22404U) || tp->pci_chip_rev_id >> 12 == 22369U) {
              
#line 16694 
              if ((unsigned int)(tp->pdev)->device != 5748U && (unsigned int)(tp->pdev)->device != 5722U) 
                
#line 16696 
                tp->phy_flags |= 2048U; else ;
              
#line 16697 
              if ((unsigned int)(tp->pdev)->device == 5747U) 
#line 16698 
                                                             tp->phy_flags |= 4096U; else ;
            }
            else 
#line 16700 
                 tp->phy_flags |= 32768U;
          else ;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 16703 
  if (tp->pci_chip_rev_id >> 12 == 22404U && tp->pci_chip_rev_id >> 8 != 358464U) {
    
#line 16705 
    tp->phy_otp = tg3_read_otp_phycfg(tp);
    
#line 16706 
    if (tp->phy_otp == 0U) 
#line 16707 
                           tp->phy_otp = 678172224U; else ;
  }
  else ;
  
#line 16710 
  tmp_41 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
  
#line 16710 
  if (tmp_41 != 0) 
#line 16711 
                   tp->mi_mode = 32768U; else 
#line 16713 
                                              tp->mi_mode = 786432U;
  
#line 16715 
  tp->coalesce_mode = 0U;
  
#line 16716 
  if ((tp->pci_chip_rev_id >> 8) + 4294967184U > 1U) 
#line 16718 
                                                     tp->coalesce_mode |= 256U; else ;
  
#line 16721 
  if (((tp->pci_chip_rev_id >> 12 == 22295U || tp->pci_chip_rev_id >> 12 == 22370U) || tp->pci_chip_rev_id == 91328512U) || tp->pci_chip_rev_id == 91357184U) {
    
#line 16725 
    tp->coalesce_mode |= 4U;
    
#line 16726 
    tp->grc_mode |= 268435456U;
  }
  else ;
  
#line 16729 
  if (tp->pci_chip_rev_id >> 12 == 22405U || tp->pci_chip_rev_id >> 12 == 358272U) 
    
#line 16731 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16733 
  err = tg3_mdio_init(tp);
  
#line 16734 
  if (err != 0) {
    
#line 16735 
    __retres = err;
    
#line 16735 
    goto return_label;
  }
  else ;
  
#line 16738 
  val = (*(tp->read32))(tp,26624U);
  
#line 16739 
  if (tp->pci_chip_rev_id >> 12 == 22304U || tp->pci_chip_rev_id >> 12 == 22370U) 
    
#line 16741 
    val &= 360640U; else 
#line 16747 
                         val &= 65536U;
  
#line 16749 
  (*(tp->write32))(tp,26624U,tp->grc_mode | val);
  
#line 16751 
  tg3_switch_clocks(tp);
  
#line 16754 
  (*(tp->write32))(tp,124U,0U);
  
#line 16757 
  (*(tp->write32))(tp,120U,0U);
  
#line 16759 
  pci_read_config_dword((struct pci_dev const *)tp->pdev,112,& pci_state_reg);
  
#line 16761 
  if ((pci_state_reg & 4U) == 0U) {
    int tmp_43;
    
#line 16761 
    tmp_43 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_TARGET_HWBUG,(unsigned long *)(& tp->tg3_flags));
    
#line 16761 
    if (tmp_43 == 0) {
      
#line 16763 
      if (((tp->pci_chip_rev_id == 0U || tp->pci_chip_rev_id == 256U) || tp->pci_chip_rev_id == 258U) || tp->pci_chip_rev_id == 261U) {
        void *sram_base;
        unsigned int tmp_42;
        
#line 16773 
        sram_base = tp->regs + 33536U;
        
#line 16775 
        writel(0U,(void volatile *)sram_base);
        
#line 16776 
        writel(0U,(void volatile *)(sram_base + 4U));
        
#line 16777 
        writel(4294967295U,(void volatile *)(sram_base + 4U));
        
#line 16778 
        tmp_42 = readl((void const volatile *)sram_base);
        
#line 16778 
        if (tmp_42 != 0U) 
#line 16779 
                          _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PCIX_TARGET_HWBUG,(unsigned long *)(& tp->tg3_flags)); else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 16783 
  __const_udelay(214750UL);
  
#line 16784 
  tg3_nvram_init(tp);
  
#line 16787 
  if (tp->pci_chip_rev_id >> 12 == 358246U) {
    int tmp_44;
    
#line 16787 
    tmp_44 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 16787 
    if (tmp_44 == 0) 
#line 16789 
                     tp->fw_needed = (char const *)0; else ;
  }
  else ;
  
#line 16791 
  grc_misc_cfg = (*(tp->read32))(tp,26628U);
  
#line 16792 
  grc_misc_cfg &= 122880U;
  
#line 16794 
  if (tp->pci_chip_rev_id >> 12 == 3U && (grc_misc_cfg == 65536U || grc_misc_cfg == 98304U)) 
    
#line 16797 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_IS_5788,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 16799 
  tmp_45 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_5788,(unsigned long *)(& tp->tg3_flags));
  
#line 16799 
  if (tmp_45 == 0) {
    
#line 16799 
    if (tp->pci_chip_rev_id >> 12 != 7U) 
#line 16801 
                                         _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  else ;
  
#line 16802 
  tmp_46 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TAGGED_STATUS,(unsigned long *)(& tp->tg3_flags));
  
#line 16802 
  if (tmp_46 != 0) {
    
#line 16803 
    tp->coalesce_mode |= 1536U;
    
#line 16806 
    tp->misc_host_ctrl |= 512U;
    
#line 16807 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,104,tp->misc_host_ctrl);
  }
  else ;
  
#line 16812 
  tmp_47 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 16812 
  if (tmp_47 != 0) 
#line 16813 
                   tp->mac_mode = 402653184U; else 
#line 16815 
                                                   tp->mac_mode = 0U;
  
#line 16817 
  tmp_48 = tg3_10_100_only_device(tp,ent);
  
#line 16817 
  if ((int)tmp_48 != 0) 
#line 16818 
                        tp->phy_flags |= 128U; else ;
  
#line 16820 
  err = tg3_phy_probe(tp);
  
#line 16821 
  if (err != 0) {
    
#line 16822 
    dev_err((struct device const *)(& (tp->pdev)->dev),"phy probe failed, err %d\n",err);
    
#line 16824 
    tg3_mdio_fini(tp);
  }
  else ;
  
#line 16827 
  tg3_read_vpd(tp);
  
#line 16828 
  tg3_read_fw_ver(tp);
  
#line 16830 
  if ((tp->phy_flags & 16U) != 0U) 
#line 16831 
                                   tp->phy_flags &= 4294967291U;
  else 
    
#line 16833 
    if (tp->pci_chip_rev_id >> 12 == 7U) 
#line 16834 
                                         tp->phy_flags |= 4U; else 
#line 16836 
                                                                   tp->phy_flags &= 4294967291U;
  
#line 16843 
  if (tp->pci_chip_rev_id >> 12 == 7U) 
#line 16844 
                                       _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USE_LINKCHG_REG,(unsigned long *)(& tp->tg3_flags)); else 
                                                                    
#line 16846 
                                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USE_LINKCHG_REG,(unsigned long *)(& tp->tg3_flags));
  
#line 16852 
  if (((unsigned int)(tp->pdev)->subsystem_vendor == 4136U && tp->pci_chip_rev_id >> 12 == 0U) && (tp->phy_flags & 16U) == 0U) {
    
#line 16855 
    tp->phy_flags |= 4U;
    
#line 16856 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USE_LINKCHG_REG,(unsigned long *)(& tp->tg3_flags));
  }
  else ;
  
#line 16860 
  if ((tp->phy_flags & 16U) != 0U) 
#line 16861 
                                   _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_POLL_SERDES,(unsigned long *)(& tp->tg3_flags)); else 
                                                                    
#line 16863 
                                                                    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_POLL_SERDES,(unsigned long *)(& tp->tg3_flags));
  
#line 16865 
  tmp_49 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
  
#line 16865 
  if (tmp_49 != 0) {
    int tmp_50;
    
#line 16865 
    tmp_50 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
    
#line 16865 
    if (tmp_50 != 0) 
#line 16866 
                     _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_POLL_CPMU_LINK,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  else ;
  {
    int tmp_51;
    
#line 16868 
    int _max1 = 32;
    
#line 16868 
    int _max2 = 64;
    
#line 16868 
    if (_max1 > _max2) 
#line 16868 
                       tmp_51 = _max1; else 
#line 16868 
                                            tmp_51 = _max2;
    
#line 16868 
    tmp_52 = tmp_51;
  }
  
#line 16868 
  tp->rx_offset = (unsigned int)tmp_52;
  
#line 16869 
  tp->rx_copy_thresh = 256U;
  
#line 16870 
  if (tp->pci_chip_rev_id >> 12 == 0U) {
    int tmp_55;
    
#line 16870 
    tmp_55 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
    
#line 16870 
    if (tmp_55 != 0) {
      int tmp_54;
      {
        int tmp_53;
        
#line 16872 
        int _max1_0 = 32;
        
#line 16872 
        int _max2_0 = 64;
        
#line 16872 
        if (_max1_0 > _max2_0) 
#line 16872 
                               tmp_53 = _max1_0; else 
#line 16872 
                                                      tmp_53 = _max2_0;
        
#line 16872 
        tmp_54 = tmp_53;
      }
      
#line 16872 
      tp->rx_offset = (unsigned int)tmp_54;
    }
    else ;
  }
  else ;
  
#line 16878 
  tmp_56 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 16878 
  if (tmp_56 != 0) 
#line 16878 
                   tmp_57 = 2047; else 
#line 16878 
                                       tmp_57 = 511;
  
#line 16878 
  tp->rx_std_ring_mask = (unsigned int)tmp_57;
  
#line 16879 
  tmp_58 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_LRG_PROD_RING_CAP,(unsigned long *)(& tp->tg3_flags));
  
#line 16879 
  if (tmp_58 != 0) 
#line 16879 
                   tmp_59 = 1023; else 
#line 16879 
                                       tmp_59 = 255;
  
#line 16879 
  tp->rx_jmb_ring_mask = (unsigned int)tmp_59;
  
#line 16880 
  tmp_60 = tg3_rx_ret_ring_size(tp);
  
#line 16880 
  tp->rx_ret_ring_mask = tmp_60 + 4294967295U;
  
#line 16882 
  tp->rx_std_max_post = tp->rx_std_ring_mask + 1U;
  
#line 16887 
  if ((tp->pci_chip_rev_id >> 12 == 4U || tp->pci_chip_rev_id >> 12 == 6U) || tp->pci_chip_rev_id >> 12 == 10U) 
    
#line 16890 
    tp->rx_std_max_post = 8U; else ;
  
#line 16892 
  tmp_62 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ASPM_WORKAROUND,(unsigned long *)(& tp->tg3_flags));
  
#line 16892 
  if (tmp_62 != 0) {
    u32 tmp_61;
    
#line 16893 
    tmp_61 = (*(tp->read32))(tp,32040U);
    
#line 16893 
    tp->pwrmgmt_thresh = tmp_61 & 65280U;
  }
  else ;
  
#line 16896 
  __retres = err;
  return_label: 
#line 16896 
                return __retres;
}


#line 16925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_get_device_address(struct tg3 *tp)
{
  int __retres;
  u32 hi;
  u32 lo;
  u32 mac_offset;
  int err;
  int tmp_0;
  int tmp_10;
  bool tmp_9;
  
#line 16927 
  struct net_device *dev = tp->dev;
  
#line 16929 
  int addr_ok = 0;
  
#line 16937 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
  
#line 16937 
  if (tmp_0 != 0) {
    
#line 16938 
    err = ssb_gige_get_macaddr(tp->pdev,dev->dev_addr);
    
#line 16939 
    if (err == 0) {
      bool tmp;
      
#line 16939 
      tmp = is_valid_ether_addr((u8 const *)dev->dev_addr);
      
#line 16939 
      if ((int)tmp != 0) {
        
#line 16940 
        __retres = 0;
        
#line 16940 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 16943 
  mac_offset = 124U;
  
#line 16944 
  if (tp->pci_chip_rev_id >> 12 == 2U) 
#line 16944 
                                       goto _LOR;
  else {
    int tmp_4;
    
#line 16944 
    tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5780_CLASS,(unsigned long *)(& tp->tg3_flags));
    
#line 16944 
    if (tmp_4 != 0) {
      _LOR: {
              u32 tmp_1;
              int tmp_2;
              
#line 16946 
              tmp_1 = (*(tp->read32))(tp,184U);
              
#line 16946 
              if ((tmp_1 & 4U) != 0U) 
#line 16947 
                                      mac_offset = 204U; else ;
              
#line 16948 
              tmp_2 = tg3_nvram_lock(tp);
              
#line 16948 
              if (tmp_2 != 0) 
#line 16949 
                              _tw32_flush(tp,28672U,1U,0U); else 
#line 16951 
                                                                 tg3_nvram_unlock(tp);
            }
    }
    else {
      int tmp_3;
      
#line 16952 
      tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5717_PLUS,(unsigned long *)(& tp->tg3_flags));
      
#line 16952 
      if (tmp_3 != 0) {
        
#line 16953 
        if ((tp->pci_fn & 1) != 0) 
#line 16954 
                                   mac_offset = 204U; else ;
        
#line 16955 
        if (tp->pci_fn > 1) 
#line 16956 
                            mac_offset += 396U; else ;
      }
      else 
        
#line 16957 
        if (tp->pci_chip_rev_id >> 12 == 12U) 
#line 16958 
                                              mac_offset = 16U; else ;
    }
  }
  
#line 16961 
  tg3_read_mem(tp,3092U,& hi);
  
#line 16962 
  if (hi >> 16 == 18507U) {
    bool tmp_5;
    
#line 16963 
    *(dev->dev_addr) = (unsigned char)(hi >> 8);
    
#line 16964 
    *(dev->dev_addr + 1U) = (unsigned char)hi;
    
#line 16966 
    tg3_read_mem(tp,3096U,& lo);
    
#line 16967 
    *(dev->dev_addr + 2U) = (unsigned char)(lo >> 24);
    
#line 16968 
    *(dev->dev_addr + 3U) = (unsigned char)(lo >> 16);
    
#line 16969 
    *(dev->dev_addr + 4U) = (unsigned char)(lo >> 8);
    
#line 16970 
    *(dev->dev_addr + 5U) = (unsigned char)lo;
    
#line 16973 
    tmp_5 = is_valid_ether_addr((u8 const *)dev->dev_addr);
    
#line 16973 
    addr_ok = (int)tmp_5;
  }
  else ;
  
#line 16975 
  if (addr_ok == 0) {
    int tmp_6;
    
#line 16977 
    tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_NO_NVRAM,(unsigned long *)(& tp->tg3_flags));
    
#line 16977 
    if (tmp_6 == 0) {
      int tmp_7;
      
#line 16977 
      tmp_7 = tg3_nvram_read_be32(tp,mac_offset,& hi);
      
#line 16977 
      if (tmp_7 == 0) {
        int tmp_8;
        
#line 16978 
        tmp_8 = tg3_nvram_read_be32(tp,mac_offset + 4U,& lo);
        
#line 16978 
        if (tmp_8 == 0) {
          
#line 16980 
          memcpy((void *)dev->dev_addr,(void const *)(& hi) + 2U,2UL);
          
#line 16981 
          memcpy((void *)(dev->dev_addr + 2U),(void const *)(& lo),4UL);
        }
        else 
#line 16977 
             goto _LAND_0;
      }
      else 
#line 16977 
           goto _LAND_0;
    }
    else {
      _LAND_0: {
                 
#line 16985 
                 hi = (*(tp->read32))(tp,1040U);
                 
#line 16986 
                 lo = (*(tp->read32))(tp,1044U);
                 
#line 16988 
                 *(dev->dev_addr + 5U) = (unsigned char)lo;
                 
#line 16989 
                 *(dev->dev_addr + 4U) = (unsigned char)(lo >> 8);
                 
#line 16990 
                 *(dev->dev_addr + 3U) = (unsigned char)(lo >> 16);
                 
#line 16991 
                 *(dev->dev_addr + 2U) = (unsigned char)(lo >> 24);
                 
#line 16992 
                 *(dev->dev_addr + 1U) = (unsigned char)hi;
                 
#line 16993 
                 *(dev->dev_addr) = (unsigned char)(hi >> 8);
               }
    }
  }
  else ;
  
#line 16997 
  tmp_9 = is_valid_ether_addr((u8 const *)dev->dev_addr);
  
#line 16997 
  if (tmp_9) 
#line 16997 
             tmp_10 = 0; else 
#line 16997 
                              tmp_10 = 1;
  
#line 16997 
  if (tmp_10) {
    
#line 17002 
    __retres = -22;
    
#line 17002 
    goto return_label;
  }
  else ;
  
#line 17004 
  __retres = 0;
  return_label: 
#line 17004 
                return __retres;
}


#line 17010  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static u32 tg3_calc_dma_bndry(struct tg3 *tp, u32 val)
{
  int cacheline_size;
  u8 byte;
  int goal;
  int tmp_0;
  int tmp_2;
  
#line 17016 
  pci_read_config_byte((struct pci_dev const *)tp->pdev,12,& byte);
  
#line 17017 
  if ((unsigned int)byte == 0U) 
#line 17018 
                                cacheline_size = 1024; else 
#line 17020 
                                                            cacheline_size = (int)byte * 4;
  
#line 17025 
  if (tp->pci_chip_rev_id >> 12 != 7U && tp->pci_chip_rev_id >> 12 != 0U) {
    int tmp;
    
#line 17026 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
    
#line 17026 
    if (tmp == 0) 
#line 17028 
                  goto out; else ;
  }
  else ;
  
#line 17036 
  goal = 0;
  
#line 17040 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 17040 
  if (tmp_0 != 0) {
    
#line 17041 
    val = (unsigned int)(goal == 0);
    
#line 17042 
    goto out;
  }
  else ;
  
#line 17045 
  if (goal == 0) 
#line 17046 
                 goto out; else ;
  
#line 17059 
  tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
  
#line 17059 
  if (tmp_2 != 0) {
    int tmp_3;
    
#line 17059 
    tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
    
#line 17059 
    if (tmp_3 == 0) {
      
#line 17060 
      switch (cacheline_size) {
        case 16: 
#line 17061 
        ;
        case 32: 
#line 17062 
        ;
        case 64: 
#line 17063 
        ;
        case 128: 
#line 17064 
        ;
        
#line 17065 
        if (goal == 1) 
#line 17066 
                       val |= 2304U; else 
#line 17069 
                                          val |= 6912U;
        
#line 17072 
        goto ldv_59591;
        case 256: 
#line 17074 
        ;
        
#line 17075 
        val |= 4608U;
        
#line 17077 
        goto ldv_59591;
        default: 
#line 17079 
        ;
        
#line 17080 
        val |= 6912U;
        
#line 17082 
        goto ldv_59591;
      }
      ldv_59591: 
#line 17084 
      ;
    }
    else 
#line 17059 
         goto _LAND;
  }
  else {
    int tmp_1;
    _LAND: 
#line 17084 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
    
#line 17084 
    if (tmp_1 != 0) {
      
#line 17085 
      switch (cacheline_size) {
        case 16: 
#line 17086 
        ;
        case 32: 
#line 17087 
        ;
        case 64: 
#line 17088 
        ;
        
#line 17089 
        if (goal == 1) {
          
#line 17090 
          val &= 2415919103U;
          
#line 17091 
          val |= 268435456U;
          
#line 17092 
          goto ldv_59597;
        }
        else ;
        case 128: 
#line 17095 
        ;
        default: 
#line 17096 
        ;
        
#line 17097 
        val &= 2415919103U;
        
#line 17098 
        val |= 805306368U;
        
#line 17099 
        goto ldv_59597;
      }
      ldv_59597: 
#line 17101 
      ;
    }
    else {
      
#line 17102 
      switch (cacheline_size) {
        case 16: 
#line 17103 
        ;
        
#line 17104 
        if (goal == 1) {
          
#line 17105 
          val |= 2304U;
          
#line 17107 
          goto ldv_59601;
        }
        else ;
        case 32: 
#line 17110 
        ;
        
#line 17111 
        if (goal == 1) {
          
#line 17112 
          val |= 4608U;
          
#line 17114 
          goto ldv_59601;
        }
        else ;
        case 64: 
#line 17117 
        ;
        
#line 17118 
        if (goal == 1) {
          
#line 17119 
          val |= 6912U;
          
#line 17121 
          goto ldv_59601;
        }
        else ;
        case 128: 
#line 17124 
        ;
        
#line 17125 
        if (goal == 1) {
          
#line 17126 
          val |= 9216U;
          
#line 17128 
          goto ldv_59601;
        }
        else ;
        case 256: 
#line 17131 
        ;
        
#line 17132 
        val |= 11520U;
        
#line 17134 
        goto ldv_59601;
        case 512: 
#line 17135 
        ;
        
#line 17136 
        val |= 13824U;
        
#line 17138 
        goto ldv_59601;
        case 1024: 
#line 17139 
        ;
        default: 
#line 17140 
        ;
        
#line 17141 
        val |= 16128U;
        
#line 17143 
        goto ldv_59601;
      }
      ldv_59601: 
#line 17145 
      ;
    }
  }
  out: 
#line 17147 
  ;
  
#line 17148 
  return val;
}


#line 17151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_do_test_dma(struct tg3 *tp, u32 *buf, dma_addr_t buf_dma, int size, bool to_device)
{
  struct tg3_internal_buffer_desc test_desc;
  u32 sram_dma_descs;
  int i;
  int ret;
  
#line 17158 
  sram_dma_descs = 8192U;
  
#line 17160 
  (*(tp->write32))(tp,23768U,0U);
  
#line 17161 
  (*(tp->write32))(tp,23816U,0U);
  
#line 17162 
  (*(tp->write32))(tp,18436U,0U);
  
#line 17163 
  (*(tp->write32))(tp,19460U,0U);
  
#line 17165 
  (*(tp->write32))(tp,17408U,0U);
  
#line 17166 
  (*(tp->write32))(tp,23552U,0U);
  
#line 17168 
  test_desc.addr_hi = (unsigned int)(buf_dma >> 32);
  
#line 17169 
  test_desc.addr_lo = (unsigned int)buf_dma;
  
#line 17170 
  test_desc.nic_mbuf = 8448U;
  
#line 17171 
  test_desc.len = (unsigned short)size;
  
#line 17185 
  if ((int)to_device != 0) {
    
#line 17186 
    test_desc.cqid_sqid = (unsigned short)3330U;
    
#line 17188 
    _tw32_flush(tp,18432U,2U,0U);
    
#line 17189 
    __const_udelay(171800UL);
  }
  else {
    
#line 17191 
    test_desc.cqid_sqid = (unsigned short)4103U;
    
#line 17193 
    _tw32_flush(tp,19456U,2U,0U);
    
#line 17194 
    __const_udelay(171800UL);
  }
  
#line 17196 
  test_desc.flags = 5U;
  
#line 17198 
  i = 0;
  
#line 17198 
  goto ldv_59622;
  ldv_59621: 
#line 17199 
  ;
  {
    u32 val;
    
#line 17201 
    val = *((u32 *)(& test_desc) + i);
    
#line 17202 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,124,(unsigned int)((unsigned long)i) * 4U + sram_dma_descs);
    
#line 17204 
    pci_write_config_dword((struct pci_dev const *)tp->pdev,132,val);
  }
  
#line 17198 
  i += 1;
  ldv_59622: 
#line 17199 
  ;
  
#line 17198 
  if ((unsigned int)i <= 7U) 
#line 17200 
                             goto ldv_59621; else 
#line 17203 
                                                  goto ldv_59623;
  ldv_59623: 
#line 17204 
  ;
  
#line 17206 
  pci_write_config_dword((struct pci_dev const *)tp->pdev,124,0U);
  
#line 17208 
  if ((int)to_device != 0) 
#line 17209 
                           (*(tp->write32))(tp,23592U,sram_dma_descs); else 
                                                                    
#line 17211 
                                                                    (*(tp->write32))(tp,23672U,sram_dma_descs);
  
#line 17213 
  ret = -19;
  
#line 17214 
  i = 0;
  
#line 17214 
  goto ldv_59627;
  ldv_59626: 
#line 17215 
  ;
  {
    u32 val_0;
    
#line 17217 
    if ((int)to_device != 0) 
#line 17218 
                             val_0 = (*(tp->read32))(tp,23768U); else 
                                                                   
#line 17220 
                                                                   val_0 = (*(tp->read32))(tp,23816U);
    
#line 17221 
    if ((val_0 & 65535U) == sram_dma_descs) {
      
#line 17222 
      ret = 0;
      
#line 17223 
      goto ldv_59625;
    }
    else ;
    
#line 17226 
    __const_udelay(429500UL);
  }
  
#line 17214 
  i += 1;
  ldv_59627: 
#line 17215 
  ;
  
#line 17214 
  if (i <= 39) 
#line 17216 
               goto ldv_59626; else 
#line 17219 
                                    goto ldv_59625;
  ldv_59625: 
#line 17220 
  ;
  
#line 17229 
  return ret;
}


#line 17234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct pci_device_id const tg3_dma_wait_state_chipsets[2U] = {{.vendor = 4203U, .device = 46U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 17239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_test_dma(struct tg3 *tp)
{
  dma_addr_t buf_dma;
  u32 *buf;
  u32 saved_dma_rwctrl;
  int tmp_0;
  int tmp_4;
  int tmp_5;
  
#line 17243 
  int ret = 0;
  
#line 17245 
  buf = (u32 *)dma_alloc_attrs(& (tp->pdev)->dev,8192UL,& buf_dma,208U,(struct dma_attrs *)0);
  
#line 17247 
  if (buf == (u32 *)0U) {
    
#line 17248 
    ret = -12;
    
#line 17249 
    goto out_nofree;
  }
  else ;
  
#line 17252 
  tp->dma_rwctrl = 1979711488U;
  
#line 17255 
  tp->dma_rwctrl = tg3_calc_dma_bndry(tp,tp->dma_rwctrl);
  
#line 17257 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 17257 
  if (tmp_0 != 0) 
#line 17258 
                  goto out; else ;
  
#line 17260 
  tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
  
#line 17260 
  if (tmp_4 != 0) 
#line 17262 
                  tp->dma_rwctrl |= 1572864U;
  else {
    int tmp_3;
    
#line 17263 
    tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
    
#line 17263 
    if (tmp_3 == 0) 
      
#line 17264 
      if ((tp->pci_chip_rev_id >> 12) + 4294967293U <= 1U) 
#line 17266 
                                                           tp->dma_rwctrl |= 4128768U; else 
                                                                    
#line 17268 
                                                                    tp->dma_rwctrl |= 4128783U;
    else 
      
#line 17270 
      if ((tp->pci_chip_rev_id >> 12) + 4294967295U <= 1U) {
        u32 tmp_1;
        int tmp_2;
        
#line 17272 
        tmp_1 = (*(tp->read32))(tp,116U);
        
#line 17272 
        u32 ccval = tmp_1 & 31U;
        
#line 17273 
        u32 read_water = 7U;
        
#line 17279 
        tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_40BIT_DMA_BUG,(unsigned long *)(& tp->tg3_flags));
        
#line 17279 
        if (tmp_2 != 0) {
          
#line 17279 
          if (tp->pci_chip_rev_id >> 12 == 2U) 
#line 17281 
                                               tp->dma_rwctrl |= 32768U; else 
                                                                    
#line 17279 
                                                                    goto _LAND;
        }
        else {
          _LAND: 
#line 17282 
          ;
          
#line 17282 
          if (ccval + 4294967290U <= 1U) 
#line 17283 
                                         tp->dma_rwctrl |= 16384U; else ;
        }
        
#line 17285 
        if (tp->pci_chip_rev_id >> 12 == 1U) 
#line 17286 
                                             read_water = 4U; else ;
        
#line 17288 
        tp->dma_rwctrl = (tp->dma_rwctrl | (read_water << 16)) | 9961472U;
      }
      else 
        
#line 17292 
        if (tp->pci_chip_rev_id >> 12 == 8U) 
#line 17294 
                                             tp->dma_rwctrl |= 1327104U;
        else 
          
#line 17295 
          if (tp->pci_chip_rev_id >> 12 == 9U) 
#line 17297 
                                               tp->dma_rwctrl |= 1343488U; else 
                                                                    
#line 17299 
                                                                    tp->dma_rwctrl |= 1769487U;
  }
  
#line 17302 
  tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ONE_DMA_AT_ONCE,(unsigned long *)(& tp->tg3_flags));
  
#line 17302 
  if (tmp_5 != 0) 
#line 17303 
                  tp->dma_rwctrl |= 16384U; else ;
  
#line 17305 
  if ((tp->pci_chip_rev_id >> 12) + 4294967295U <= 1U) 
#line 17307 
                                                       tp->dma_rwctrl &= 4294967280U; else ;
  
#line 17309 
  if (tp->pci_chip_rev_id >> 12 == 7U || tp->pci_chip_rev_id >> 12 == 0U) {
    
#line 17312 
    tp->dma_rwctrl |= 4194304U;
    
#line 17324 
    tp->dma_rwctrl |= 8388608U;
  }
  else ;
  
#line 17327 
  (*(tp->write32))(tp,108U,tp->dma_rwctrl);
  
#line 17330 
  if (tp->pci_chip_rev_id >> 12 != 7U && tp->pci_chip_rev_id >> 12 != 0U) 
    
#line 17332 
    goto out; else ;
  
#line 17337 
  saved_dma_rwctrl = tp->dma_rwctrl;
  
#line 17338 
  tp->dma_rwctrl &= 4294952959U;
  
#line 17339 
  (*(tp->write32))(tp,108U,tp->dma_rwctrl);
  ldv_59651: 
#line 17340 
  ;
  {
    u32 i;
    
#line 17342 
    u32 *p = buf;
    
#line 17344 
    i = 0U;
    
#line 17344 
    goto ldv_59643;
    ldv_59642: 
#line 17345 
    ;
    
#line 17345 
    *(p + i) = i;
    
#line 17344 
    i += 1U;
    ldv_59643: 
#line 17345 
    ;
    
#line 17344 
    if (i <= 2047U) 
#line 17346 
                    goto ldv_59642; else 
#line 17349 
                                         goto ldv_59644;
    ldv_59644: 
#line 17350 
    ;
    
#line 17348 
    ret = tg3_do_test_dma(tp,buf,buf_dma,8192,(_Bool)1);
    
#line 17349 
    if (ret != 0) {
      
#line 17350 
      dev_err((struct device const *)(& (tp->pdev)->dev),"%s: Buffer write failed. err = %d\n","tg3_test_dma",ret);
      
#line 17353 
      goto ldv_59646;
    }
    else ;
    
#line 17357 
    ret = tg3_do_test_dma(tp,buf,buf_dma,8192,(_Bool)0);
    
#line 17358 
    if (ret != 0) {
      
#line 17359 
      dev_err((struct device const *)(& (tp->pdev)->dev),"%s: Buffer read failed. ","tg3_test_dma",ret);
      
#line 17361 
      goto ldv_59646;
    }
    else ;
    
#line 17365 
    i = 0U;
    
#line 17365 
    goto ldv_59650;
    ldv_59649: 
#line 17366 
    ;
    
#line 17366 
    if (*(p + i) == i) 
#line 17367 
                       goto ldv_59647; else ;
    
#line 17369 
    if ((tp->dma_rwctrl & 14336U) != 2048U) {
      
#line 17371 
      tp->dma_rwctrl &= 4294952959U;
      
#line 17372 
      tp->dma_rwctrl |= 2048U;
      
#line 17373 
      (*(tp->write32))(tp,108U,tp->dma_rwctrl);
      
#line 17374 
      goto ldv_59648;
    }
    else {
      
#line 17376 
      dev_err((struct device const *)(& (tp->pdev)->dev),"%s: Buffer corrupted on read back! ","tg3_test_dma",*(p + i),i);
      
#line 17379 
      ret = -19;
      
#line 17380 
      goto out;
    }
    ldv_59647: 
#line 17382 
    ;
    
#line 17365 
    i += 1U;
    ldv_59650: 
#line 17366 
    ;
    
#line 17365 
    if (i <= 2047U) 
#line 17367 
                    goto ldv_59649; else 
#line 17370 
                                         goto ldv_59648;
    ldv_59648: 
#line 17371 
    ;
    
#line 17384 
    if (i == 2048U) {
      
#line 17386 
      ret = 0;
      
#line 17387 
      goto ldv_59646;
    }
    else ;
  }
  
#line 17341 
  goto ldv_59651;
  ldv_59646: 
#line 17342 
  ;
  
#line 17390 
  if ((tp->dma_rwctrl & 14336U) != 2048U) {
    int tmp_6;
    
#line 17396 
    tmp_6 = pci_dev_present((struct pci_device_id const *)(& tg3_dma_wait_state_chipsets));
    
#line 17396 
    if (tmp_6 != 0) {
      
#line 17397 
      tp->dma_rwctrl &= 4294952959U;
      
#line 17398 
      tp->dma_rwctrl |= 2048U;
    }
    else 
#line 17401 
         tp->dma_rwctrl = saved_dma_rwctrl;
    
#line 17404 
    (*(tp->write32))(tp,108U,tp->dma_rwctrl);
  }
  else ;
  out: 
#line 17407 
  ;
  
#line 17408 
  dma_free_attrs(& (tp->pdev)->dev,8192UL,(void *)buf,buf_dma,(struct dma_attrs *)0);
  out_nofree: 
#line 17409 
  ;
  
#line 17410 
  return ret;
}


#line 17413  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_init_bufmgr_config(struct tg3 *tp)
{
  int tmp_0;
  
#line 17415 
  tmp_0 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_57765_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 17415 
  if (tmp_0 != 0) {
    
#line 17416 
    tp->bufmgr_config.mbuf_read_dma_low_water = 0U;
    
#line 17418 
    tp->bufmgr_config.mbuf_mac_rx_low_water = 42U;
    
#line 17420 
    tp->bufmgr_config.mbuf_high_water = 160U;
    
#line 17423 
    tp->bufmgr_config.mbuf_read_dma_low_water_jumbo = 0U;
    
#line 17425 
    tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo = 126U;
    
#line 17427 
    tp->bufmgr_config.mbuf_high_water_jumbo = 234U;
  }
  else {
    int tmp;
    
#line 17429 
    tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 17429 
    if (tmp != 0) {
      
#line 17430 
      tp->bufmgr_config.mbuf_read_dma_low_water = 0U;
      
#line 17432 
      tp->bufmgr_config.mbuf_mac_rx_low_water = 16U;
      
#line 17434 
      tp->bufmgr_config.mbuf_high_water = 96U;
      
#line 17436 
      if (tp->pci_chip_rev_id >> 12 == 12U) {
        
#line 17437 
        tp->bufmgr_config.mbuf_mac_rx_low_water = 4U;
        
#line 17439 
        tp->bufmgr_config.mbuf_high_water = 16U;
      }
      else ;
      
#line 17443 
      tp->bufmgr_config.mbuf_read_dma_low_water_jumbo = 0U;
      
#line 17445 
      tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo = 75U;
      
#line 17447 
      tp->bufmgr_config.mbuf_high_water_jumbo = 150U;
    }
    else {
      
#line 17450 
      tp->bufmgr_config.mbuf_read_dma_low_water = 80U;
      
#line 17452 
      tp->bufmgr_config.mbuf_mac_rx_low_water = 32U;
      
#line 17454 
      tp->bufmgr_config.mbuf_high_water = 96U;
      
#line 17457 
      tp->bufmgr_config.mbuf_read_dma_low_water_jumbo = 304U;
      
#line 17459 
      tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo = 152U;
      
#line 17461 
      tp->bufmgr_config.mbuf_high_water_jumbo = 380U;
    }
  }
  
#line 17465 
  tp->bufmgr_config.dma_low_water = 5U;
  
#line 17466 
  tp->bufmgr_config.dma_high_water = 10U;
  
#line 17467 
  return;
}


#line 17469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static char *tg3_phy_string(struct tg3 *tp)
{
  char *__retres;
  
#line 17471 
  switch (tp->phy_id & 4294967280U) {
    case (unsigned int)1610645568: 
#line 17472 
    ;
    
#line 17472 
    __retres = (char *)"5400";
    
#line 17472 
    goto return_label;
    case (unsigned int)1610645584: 
#line 17473 
    ;
    
#line 17473 
    __retres = (char *)"5401";
    
#line 17473 
    goto return_label;
    case (unsigned int)1610645616: 
#line 17474 
    ;
    
#line 17474 
    __retres = (char *)"5411";
    
#line 17474 
    goto return_label;
    case (unsigned int)1610645776: 
#line 17475 
    ;
    
#line 17475 
    __retres = (char *)"5701";
    
#line 17475 
    goto return_label;
    case (unsigned int)1610645856: 
#line 17476 
    ;
    
#line 17476 
    __retres = (char *)"5703";
    
#line 17476 
    goto return_label;
    case (unsigned int)1610645904: 
#line 17477 
    ;
    
#line 17477 
    __retres = (char *)"5704";
    
#line 17477 
    goto return_label;
    case (unsigned int)1610645920: 
#line 17478 
    ;
    
#line 17478 
    __retres = (char *)"5705";
    
#line 17478 
    goto return_label;
    case (unsigned int)1610645888: 
#line 17479 
    ;
    
#line 17479 
    __retres = (char *)"5750";
    
#line 17479 
    goto return_label;
    case (unsigned int)1610645760: 
#line 17480 
    ;
    
#line 17480 
    __retres = (char *)"5752";
    
#line 17480 
    goto return_label;
    case (unsigned int)1610646336: 
#line 17481 
    ;
    
#line 17481 
    __retres = (char *)"5714";
    
#line 17481 
    goto return_label;
    case (unsigned int)1610646352: 
#line 17482 
    ;
    
#line 17482 
    __retres = (char *)"5780";
    
#line 17482 
    goto return_label;
    case (unsigned int)(-1140519744): 
#line 17483 
    ;
    
#line 17483 
    __retres = (char *)"5755";
    
#line 17483 
    goto return_label;
    case (unsigned int)(-1140519712): 
#line 17484 
    ;
    
#line 17484 
    __retres = (char *)"5787";
    
#line 17484 
    goto return_label;
    case (unsigned int)(-1140519008): 
#line 17485 
    ;
    
#line 17485 
    __retres = (char *)"5784";
    
#line 17485 
    goto return_label;
    case (unsigned int)(-1140519216): 
#line 17486 
    ;
    
#line 17486 
    __retres = (char *)"5722/5756";
    
#line 17486 
    goto return_label;
    case (unsigned int)(-603935680): 
#line 17487 
    ;
    
#line 17487 
    __retres = (char *)"5906";
    
#line 17487 
    goto return_label;
    case (unsigned int)(-1140518960): 
#line 17488 
    ;
    
#line 17488 
    __retres = (char *)"5761";
    
#line 17488 
    goto return_label;
    case (unsigned int)1544391168: 
#line 17489 
    ;
    
#line 17489 
    __retres = (char *)"5718C";
    
#line 17489 
    goto return_label;
    case (unsigned int)(-1140518928): 
#line 17490 
    ;
    
#line 17490 
    __retres = (char *)"5718S";
    
#line 17490 
    goto return_label;
    case (unsigned int)1544391232: 
#line 17491 
    ;
    
#line 17491 
    __retres = (char *)"57765";
    
#line 17491 
    goto return_label;
    case (unsigned int)1544391200: 
#line 17492 
    ;
    
#line 17492 
    __retres = (char *)"5719C";
    
#line 17492 
    goto return_label;
    case (unsigned int)1544391520: 
#line 17493 
    ;
    
#line 17493 
    __retres = (char *)"5720C";
    
#line 17493 
    goto return_label;
    case (unsigned int)(-2055194752): 
#line 17494 
    ;
    
#line 17494 
    __retres = (char *)"5762C";
    
#line 17494 
    goto return_label;
    case (unsigned int)1610678592: 
#line 17495 
    ;
    
#line 17495 
    __retres = (char *)"8002/serdes";
    
#line 17495 
    goto return_label;
    case (unsigned int)0: 
#line 17496 
    ;
    
#line 17496 
    __retres = (char *)"serdes";
    
#line 17496 
    goto return_label;
    default: 
#line 17497 
    ;
    
#line 17497 
    __retres = (char *)"unknown";
    
#line 17497 
    goto return_label;
  }
  return_label: 
#line 17471 
                return __retres;
}


#line 17501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static char *tg3_bus_string(struct tg3 *tp, char *str)
{
  char *__retres;
  int tmp_3;
  int tmp_4;
  
#line 17503 
  tmp_3 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_EXPRESS,(unsigned long *)(& tp->tg3_flags));
  
#line 17503 
  if (tmp_3 != 0) {
    
#line 17504 
    strcpy(str,"PCI Express");
    
#line 17505 
    __retres = str;
    
#line 17505 
    goto return_label;
  }
  else {
    int tmp_2;
    
#line 17506 
    tmp_2 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCIX_MODE,(unsigned long *)(& tp->tg3_flags));
    
#line 17506 
    if (tmp_2 != 0) {
      u32 tmp;
      
#line 17507 
      tmp = (*(tp->read32))(tp,116U);
      
#line 17507 
      u32 clock_ctrl = tmp & 31U;
      
#line 17509 
      strcpy(str,"PCIX:");
      
#line 17511 
      if (clock_ctrl == 7U) 
#line 17511 
                            goto _LOR;
      else {
        u32 tmp_0;
        
#line 17511 
        tmp_0 = (*(tp->read32))(tp,26628U);
        
#line 17511 
        if ((tmp_0 & 122880U) == 16384U) _LOR: 
#line 17514 
                                               strcat(str,"133MHz");
        else 
          
#line 17515 
          if (clock_ctrl == 0U) 
#line 17516 
                                strcat(str,"33MHz");
          else 
            
#line 17517 
            if (clock_ctrl == 2U) 
#line 17518 
                                  strcat(str,"50MHz");
            else 
              
#line 17519 
              if (clock_ctrl == 4U) 
#line 17520 
                                    strcat(str,"66MHz");
              else 
                
#line 17521 
                if (clock_ctrl == 6U) 
#line 17522 
                                      strcat(str,"100MHz"); else ;
      }
    }
    else {
      int tmp_1;
      
#line 17524 
      strcpy(str,"PCI:");
      
#line 17525 
      tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_HIGH_SPEED,(unsigned long *)(& tp->tg3_flags));
      
#line 17525 
      if (tmp_1 != 0) 
#line 17526 
                      strcat(str,"66MHz"); else 
#line 17528 
                                                strcat(str,"33MHz");
    }
  }
  
#line 17530 
  tmp_4 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PCI_32BIT,(unsigned long *)(& tp->tg3_flags));
  
#line 17530 
  if (tmp_4 != 0) 
#line 17531 
                  strcat(str,":32-bit"); else 
#line 17533 
                                              strcat(str,":64-bit");
  
#line 17534 
  __retres = str;
  return_label: 
#line 17534 
                return __retres;
}


#line 17537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_init_coal(struct tg3 *tp)
{
  int tmp;
  
#line 17539 
  struct ethtool_coalesce *ec = & tp->coal;
  
#line 17541 
  memset((void *)ec,0,92UL);
  
#line 17542 
  ec->cmd = 14U;
  
#line 17543 
  ec->rx_coalesce_usecs = 50U;
  
#line 17544 
  ec->tx_coalesce_usecs = 150U;
  
#line 17545 
  ec->rx_max_coalesced_frames = 5U;
  
#line 17546 
  ec->tx_max_coalesced_frames = 53U;
  
#line 17547 
  ec->rx_coalesce_usecs_irq = 25U;
  
#line 17548 
  ec->tx_coalesce_usecs_irq = 25U;
  
#line 17549 
  ec->rx_max_coalesced_frames_irq = 5U;
  
#line 17550 
  ec->tx_max_coalesced_frames_irq = 5U;
  
#line 17551 
  ec->stats_block_coalesce_usecs = 1000000U;
  
#line 17553 
  if ((tp->coalesce_mode & 1536U) != 0U) {
    
#line 17555 
    ec->rx_coalesce_usecs = 20U;
    
#line 17556 
    ec->rx_coalesce_usecs_irq = 20U;
    
#line 17557 
    ec->tx_coalesce_usecs = 72U;
    
#line 17558 
    ec->tx_coalesce_usecs_irq = 20U;
  }
  else ;
  
#line 17561 
  tmp = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5705_PLUS,(unsigned long *)(& tp->tg3_flags));
  
#line 17561 
  if (tmp != 0) {
    
#line 17562 
    ec->rx_coalesce_usecs_irq = 0U;
    
#line 17563 
    ec->tx_coalesce_usecs_irq = 0U;
    
#line 17564 
    ec->stats_block_coalesce_usecs = 0U;
  }
  else ;
  
#line 17566 
  return;
}


#line 17568  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_init_one(struct pci_dev *pdev, struct pci_device_id const *ent)
{
  int __retres;
  struct net_device *dev;
  struct tg3 *tp;
  int i;
  int err;
  u32 sndmbx;
  u32 rcvmbx;
  u32 intmbx;
  char str[40U];
  u64 dma_mask;
  u64 persist_dma_mask;
  bool tmp_4;
  int tmp_6;
  int tmp_8;
  int tmp_12;
  u32 tmp_18;
  int tmp_21;
  char *tmp_22;
  int tmp_25;
  int tmp_26;
  int tmp_27;
  int tmp_29;
  int tmp_30;
  
#line 17577 
  netdev_features_t features = 0ULL;
  {
    bool __print_once;
    
#line 17579 
    if (! __print_once) {
      
#line 17579 
      __print_once = (_Bool)1;
      
#line 17579 
      printk("\001",(char *)(& version));
    }
    else ;
  }
  
#line 17581 
  err = pci_enable_device(pdev);
  
#line 17582 
  if (err != 0) {
    
#line 17583 
    dev_err((struct device const *)(& pdev->dev),"Cannot enable PCI device, aborting\n");
    
#line 17584 
    __retres = err;
    
#line 17584 
    goto return_label;
  }
  else ;
  
#line 17587 
  err = pci_request_regions(pdev,"tg3");
  
#line 17588 
  if (err != 0) {
    
#line 17589 
    dev_err((struct device const *)(& pdev->dev),"Cannot obtain PCI resources, aborting\n");
    
#line 17590 
    goto err_out_disable_pdev;
  }
  else ;
  
#line 17593 
  pci_set_master(pdev);
  
#line 17595 
  dev = ldv_alloc_etherdev_mqs_130(5056,5U,5U);
  
#line 17596 
  if (dev == (struct net_device *)0) {
    
#line 17597 
    err = -12;
    
#line 17598 
    goto err_out_free_res;
  }
  else ;
  
#line 17601 
  dev->dev.parent = & pdev->dev;
  
#line 17603 
  tp = (struct tg3 *)netdev_priv((struct net_device const *)dev);
  
#line 17604 
  tp->pdev = pdev;
  
#line 17605 
  tp->dev = dev;
  
#line 17606 
  tp->rx_mode = 0U;
  
#line 17607 
  tp->tx_mode = 0U;
  
#line 17608 
  tp->irq_sync = 1U;
  
#line 17609 
  tp->pcierr_recovery = (_Bool)0;
  
#line 17611 
  if (tg3_debug > 0) 
#line 17612 
                     tp->msg_enable = (unsigned int)tg3_debug; else 
#line 17614 
                                                                    tp->msg_enable = 255U;
  
#line 17616 
  tmp_4 = pdev_is_ssb_gige_core(pdev);
  
#line 17616 
  if ((int)tmp_4 != 0) {
    bool tmp_0;
    bool tmp_1;
    bool tmp_2;
    bool tmp_3;
    
#line 17617 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_IS_SSB_CORE,(unsigned long *)(& tp->tg3_flags));
    
#line 17618 
    tmp_0 = pdev_is_ssb_gige_core(pdev);
    
#line 17618 
    if ((int)tmp_0 != 0) 
#line 17619 
                         _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_FLUSH_POSTED_WRITES,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 17620 
    tmp_1 = pdev_is_ssb_gige_core(pdev);
    
#line 17620 
    if ((int)tmp_1 != 0) 
#line 17621 
                         _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ONE_DMA_AT_ONCE,(unsigned long *)(& tp->tg3_flags)); else ;
    
#line 17622 
    tmp_2 = pdev_is_ssb_gige_core(pdev);
    
#line 17622 
    if ((int)tmp_2 != 0) {
      
#line 17623 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
      
#line 17624 
      _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ROBOSWITCH,(unsigned long *)(& tp->tg3_flags));
    }
    else ;
    
#line 17626 
    tmp_3 = pdev_is_ssb_gige_core(pdev);
    
#line 17626 
    if ((int)tmp_3 != 0) 
#line 17627 
                         _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_RGMII_MODE,(unsigned long *)(& tp->tg3_flags)); else ;
  }
  else ;
  
#line 17634 
  tp->misc_host_ctrl = 154U;
  
#line 17646 
  tp->grc_mode = 52U;
  
#line 17651 
  spinlock_check(& tp->lock);
  {
    struct lock_class_key __key;
    
#line 17651 
    __raw_spin_lock_init(& tp->lock.__anonCompField_spinlock_18.rlock,"&(&tp->lock)->rlock",& __key);
  }
  
#line 17652 
  spinlock_check(& tp->indirect_lock);
  {
    struct lock_class_key __key_0;
    
#line 17652 
    __raw_spin_lock_init(& tp->indirect_lock.__anonCompField_spinlock_18.rlock,"&(&tp->indirect_lock)->rlock",& __key_0);
  }
  {
    struct lock_class_key __key_1;
    
#line 17653 
    __init_work(& tp->reset_task,0);
    
#line 17653 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 17653 
    tp->reset_task.data = __constr_expr_37;
    
#line 17653 
    lockdep_init_map(& tp->reset_task.lockdep_map,"(&tp->reset_task)",& __key_1,0);
    
#line 17653 
    INIT_LIST_HEAD(& tp->reset_task.entry);
    
#line 17653 
    tp->reset_task.func = & tg3_reset_task;
  }
  
#line 17655 
  tp->regs = pci_ioremap_bar(pdev,0);
  
#line 17656 
  if (tp->regs == (void *)0) {
    
#line 17657 
    dev_err((struct device const *)(& pdev->dev),"Cannot map device registers, aborting\n");
    
#line 17658 
    err = -12;
    
#line 17659 
    goto err_out_free_dev;
  }
  else ;
  
#line 17662 
  if ((((((((((((((unsigned int)(tp->pdev)->device + 59776U <= 1U || (unsigned int)(tp->pdev)->device == 5768U) || (unsigned int)(tp->pdev)->device == 5769U) || (unsigned int)(tp->pdev)->device == 5717U) || (unsigned int)(tp->pdev)->device == 5733U) || (unsigned int)(tp->pdev)->device == 5718U) || (unsigned int)(tp->pdev)->device == 5719U) || (unsigned int)(tp->pdev)->device == 5727U) || (unsigned int)(tp->pdev)->device == 5763U) || (unsigned int)(tp->pdev)->device == 5698U) || (unsigned int)(tp->pdev)->device == 5767U) || (unsigned int)(tp->pdev)->device == 5699U) || (unsigned int)(tp->pdev)->device == 5875U) || (unsigned int)(tp->pdev)->device == 5697U) {
    
#line 17677 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_ENABLE_APE,(unsigned long *)(& tp->tg3_flags));
    
#line 17678 
    tp->aperegs = pci_ioremap_bar(pdev,2);
    
#line 17679 
    if (tp->aperegs == (void *)0) {
      
#line 17680 
      dev_err((struct device const *)(& pdev->dev),"Cannot map APE registers, aborting\n");
      
#line 17682 
      err = -12;
      
#line 17683 
      goto err_out_iounmap;
    }
    else ;
  }
  else ;
  
#line 17687 
  tp->rx_pending = 200U;
  
#line 17688 
  tp->rx_jumbo_pending = 100U;
  
#line 17690 
  dev->ethtool_ops = & tg3_ethtool_ops;
  
#line 17691 
  dev->watchdog_timeo = 1250;
  
#line 17692 
  dev->netdev_ops = & tg3_netdev_ops;
  
#line 17693 
  dev->irq = (int)pdev->irq;
  
#line 17695 
  err = tg3_get_invariants(tp,ent);
  
#line 17696 
  if (err != 0) {
    
#line 17697 
    dev_err((struct device const *)(& pdev->dev),"Problem fetching invariants of chip, aborting\n");
    
#line 17699 
    goto err_out_apeunmap;
  }
  else ;
  
#line 17708 
  tmp_6 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_IS_5788,(unsigned long *)(& tp->tg3_flags));
  
#line 17708 
  if (tmp_6 != 0) {
    
#line 17709 
    dma_mask = 4294967295ULL;
    
#line 17709 
    persist_dma_mask = dma_mask;
  }
  else {
    int tmp_5;
    
#line 17710 
    tmp_5 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_40BIT_DMA_BUG,(unsigned long *)(& tp->tg3_flags));
    
#line 17710 
    if (tmp_5 != 0) {
      
#line 17711 
      dma_mask = 1099511627775ULL;
      
#line 17711 
      persist_dma_mask = dma_mask;
    }
    else {
      
#line 17716 
      dma_mask = 18446744073709551615ULL;
      
#line 17716 
      persist_dma_mask = dma_mask;
    }
  }
  
#line 17719 
  if (dma_mask > 4294967295ULL) {
    
#line 17720 
    err = pci_set_dma_mask(pdev,dma_mask);
    
#line 17721 
    if (err == 0) {
      
#line 17722 
      features |= 32ULL;
      
#line 17723 
      err = pci_set_consistent_dma_mask(pdev,persist_dma_mask);
      
#line 17725 
      if (err < 0) {
        
#line 17726 
        dev_err((struct device const *)(& pdev->dev),"Unable to obtain 64 bit ");
        
#line 17728 
        goto err_out_apeunmap;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 17732 
  if (err != 0 || dma_mask == 4294967295ULL) {
    
#line 17733 
    err = pci_set_dma_mask(pdev,4294967295ULL);
    
#line 17734 
    if (err != 0) {
      
#line 17735 
      dev_err((struct device const *)(& pdev->dev),"No usable DMA configuration, aborting\n");
      
#line 17737 
      goto err_out_apeunmap;
    }
    else ;
  }
  else ;
  
#line 17741 
  tg3_init_bufmgr_config(tp);
  
#line 17746 
  if (tp->pci_chip_rev_id != 28928U) {
    int tmp_7;
    
#line 17747 
    features |= 17179869187ULL;
    
#line 17749 
    tmp_7 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_5755_PLUS,(unsigned long *)(& tp->tg3_flags));
    
#line 17749 
    if (tmp_7 != 0) 
#line 17750 
                    features |= 16ULL; else ;
  }
  else ;
  
#line 17757 
  tmp_8 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_1,(unsigned long *)(& tp->tg3_flags));
  
#line 17757 
  if (tmp_8 != 0) 
#line 17757 
                  goto _LOR;
  else {
    int tmp_9;
    
#line 17757 
    tmp_9 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
    
#line 17757 
    if (tmp_9 != 0) 
#line 17757 
                    goto _LOR;
    else {
      int tmp_10;
      
#line 17758 
      tmp_10 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
      
#line 17758 
      if (tmp_10 != 0) {
        _LOR: 
#line 17759 
        ;
        
#line 17759 
        if ((features & 2ULL) != 0ULL) 
#line 17761 
                                       features |= 65536ULL; else ;
      }
      else ;
    }
  }
  
#line 17762 
  tmp_12 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_2,(unsigned long *)(& tp->tg3_flags));
  
#line 17762 
  if (tmp_12 != 0) 
#line 17762 
                   goto _LOR_0;
  else {
    int tmp_13;
    
#line 17762 
    tmp_13 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
    
#line 17762 
    if (tmp_13 != 0) {
      _LOR_0: {
                int tmp_11;
                
#line 17763 
                if ((features & 16ULL) != 0ULL) 
#line 17764 
                                                features |= 1048576ULL; else ;
                
#line 17765 
                tmp_11 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_HW_TSO_3,(unsigned long *)(& tp->tg3_flags));
                
#line 17765 
                if (tmp_11 != 0) 
#line 17771 
                                 features |= 524288ULL;
                else 
                  
#line 17765 
                  if (tp->pci_chip_rev_id >> 12 == 22369U) 
#line 17771 
                                                           features |= 524288ULL;
                  else 
                    
#line 17766 
                    if (tp->pci_chip_rev_id >> 12 == 22404U && tp->pci_chip_rev_id >> 8 != 358464U) 
                      
#line 17771 
                      features |= 524288ULL;
                    else 
                      
#line 17768 
                      if (tp->pci_chip_rev_id >> 12 == 22405U) 
#line 17771 
                                                               features |= 524288ULL;
                      else 
                        
#line 17769 
                        if (tp->pci_chip_rev_id >> 12 == 358272U) 
#line 17771 
                                                                  features |= 524288ULL; else ;
              }
    }
    else ;
  }
  
#line 17774 
  dev->features = (dev->features | features) | 384ULL;
  
#line 17776 
  dev->vlan_features |= features;
  
#line 17783 
  if (tp->pci_chip_rev_id >> 12 != 8U) {
    int tmp_14;
    
#line 17783 
    tmp_14 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_CPMU_PRESENT,(unsigned long *)(& tp->tg3_flags));
    
#line 17783 
    if (tmp_14 == 0) 
#line 17786 
                     features |= 68719476736ULL; else ;
  }
  else ;
  
#line 17788 
  dev->hw_features |= features;
  
#line 17789 
  dev->priv_flags |= 131072U;
  
#line 17791 
  if (tp->pci_chip_rev_id == 12289U) {
    int tmp_15;
    
#line 17791 
    tmp_15 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
    
#line 17791 
    if (tmp_15 == 0) {
      u32 tmp_16;
      
#line 17792 
      tmp_16 = (*(tp->read32))(tp,112U);
      
#line 17792 
      if ((tmp_16 & 8U) == 0U) {
        
#line 17794 
        _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_MAX_RXPEND_64,(unsigned long *)(& tp->tg3_flags));
        
#line 17795 
        tp->rx_pending = 63U;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 17798 
  err = tg3_get_device_address(tp);
  
#line 17799 
  if (err != 0) {
    
#line 17800 
    dev_err((struct device const *)(& pdev->dev),"Could not obtain valid ethernet address, aborting\n");
    
#line 17802 
    goto err_out_apeunmap;
  }
  else ;
  
#line 17805 
  intmbx = 516U;
  
#line 17806 
  rcvmbx = 644U;
  
#line 17807 
  sndmbx = 772U;
  
#line 17808 
  i = 0;
  
#line 17808 
  goto ldv_59722;
  ldv_59721: 
#line 17809 
  ;
  {
    int tmp_17;
    
#line 17809 
    struct tg3_napi *tnapi = & tp->napi[i];
    
#line 17811 
    tnapi->tp = tp;
    
#line 17812 
    tnapi->tx_pending = 511U;
    
#line 17814 
    tnapi->int_mbox = intmbx;
    
#line 17815 
    if (i <= 4) 
#line 17816 
                intmbx += 8U; else 
#line 17818 
                                   intmbx += 4U;
    
#line 17820 
    tnapi->consmbox = rcvmbx;
    
#line 17821 
    tnapi->prodmbox = sndmbx;
    
#line 17823 
    if (i != 0) 
#line 17824 
                tnapi->coal_now = (unsigned int)(8192 << (i + -1)); else 
                                                                    
#line 17826 
                                                                    tnapi->coal_now = 8U;
    
#line 17828 
    tmp_17 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_SUPPORT_MSIX,(unsigned long *)(& tp->tg3_flags));
    
#line 17828 
    if (tmp_17 == 0) 
#line 17829 
                     goto ldv_59719; else ;
    
#line 17838 
    if (i == 0) 
#line 17839 
                goto ldv_59720; else ;
    
#line 17841 
    rcvmbx += 8U;
    
#line 17843 
    if ((sndmbx & 4U) != 0U) 
#line 17844 
                             sndmbx += 4294967292U; else 
#line 17846 
                                                         sndmbx += 12U;
  }
  ldv_59720: 
#line 17848 
  ;
  
#line 17808 
  i += 1;
  ldv_59722: 
#line 17809 
  ;
  
#line 17808 
  if (tp->irq_max > (unsigned int)i) 
#line 17810 
                                     goto ldv_59721; else 
#line 17813 
                                                          goto ldv_59719;
  ldv_59719: 
#line 17814 
  ;
  
#line 17854 
  tmp_18 = (*(tp->read32))(tp,15360U);
  
#line 17854 
  if ((tmp_18 & 2U) != 0U) 
#line 17854 
                           goto _LOR_1;
  else {
    u32 tmp_19;
    
#line 17854 
    tmp_19 = (*(tp->read32))(tp,19456U);
    
#line 17854 
    if ((tmp_19 & 2U) != 0U) {
      _LOR_1: {
                
#line 17856 
                tg3_full_lock(tp,0);
                
#line 17857 
                (*(tp->write32))(tp,16384U,2U);
                
#line 17858 
                tg3_halt(tp,0,(_Bool)1);
                
#line 17859 
                tg3_full_unlock(tp);
              }
    }
    else ;
  }
  
#line 17862 
  err = tg3_test_dma(tp);
  
#line 17863 
  if (err != 0) {
    
#line 17864 
    dev_err((struct device const *)(& pdev->dev),"DMA engine test failed, aborting\n");
    
#line 17865 
    goto err_out_apeunmap;
  }
  else ;
  
#line 17868 
  tg3_init_coal(tp);
  
#line 17870 
  pci_set_drvdata(pdev,(void *)dev);
  
#line 17872 
  if ((tp->pci_chip_rev_id >> 12 == 22297U || tp->pci_chip_rev_id >> 12 == 22304U) || tp->pci_chip_rev_id >> 12 == 22370U) 
    
#line 17875 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags)); else ;
  
#line 17877 
  tg3_timer_init(tp);
  
#line 17879 
  tg3_carrier_off(tp);
  
#line 17881 
  err = ldv_register_netdev_131(dev);
  
#line 17882 
  if (err != 0) {
    
#line 17883 
    dev_err((struct device const *)(& pdev->dev),"Cannot register net device, aborting\n");
    
#line 17884 
    goto err_out_apeunmap;
  }
  else ;
  
#line 17887 
  tmp_21 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_PTP_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 17887 
  if (tmp_21 != 0) {
    bool tmp_20;
    
#line 17888 
    tg3_ptp_init(tp);
    
#line 17889 
    tp->ptp_clock = ptp_clock_register(& tp->ptp_info,& (tp->pdev)->dev);
    
#line 17891 
    tmp_20 = IS_ERR((void const *)tp->ptp_clock);
    
#line 17891 
    if ((int)tmp_20 != 0) 
#line 17892 
                          tp->ptp_clock = (struct ptp_clock *)0; else ;
  }
  else ;
  
#line 17895 
  ;
  
#line 17897 
  tmp_22 = tg3_bus_string(tp,(char *)(& str));
  
#line 17895 
  ;
  
#line 17895 
  ;
  
#line 17895 
  ;
  
#line 17895 
  netdev_info((struct net_device const *)dev,"Tigon3 [partno(%s) rev %04x] (%s) MAC address %pM\n",(char *)(& tp->board_part_number),tp->pci_chip_rev_id,tmp_22,dev->dev_addr);
  
#line 17901 
  if ((tp->phy_flags & 2U) != 0U) {
    struct phy_device *phydev;
    char const *tmp_23;
    
#line 17903 
    phydev = (tp->mdio_bus)->phy_map[(int)tp->phy_addr];
    
#line 17906 
    tmp_23 = dev_name((struct device const *)(& phydev->dev));
    
#line 17904 
    ;
    
#line 17904 
    ;
    
#line 17904 
    netdev_info((struct net_device const *)dev,"attached PHY driver [%s] (mii_bus:phy_addr=%s)\n",(phydev->drv)->name,tmp_23);
  }
  else {
    char *ethtype;
    char *tmp_24;
    
#line 17910 
    if ((tp->phy_flags & 128U) != 0U) 
#line 17911 
                                      ethtype = (char *)"10/100Base-TX";
    else 
      
#line 17912 
      if ((tp->phy_flags & 48U) != 0U) 
#line 17913 
                                       ethtype = (char *)"1000Base-SX"; else 
                                                                    
#line 17915 
                                                                    ethtype = (char *)"10/100/1000Base-T";
    
#line 17917 
    ;
    
#line 17917 
    ;
    
#line 17917 
    ;
    
#line 17917 
    tmp_24 = tg3_phy_string(tp);
    
#line 17917 
    ;
    
#line 17917 
    netdev_info((struct net_device const *)dev,"attached PHY is %s (%s Ethernet) ",tmp_24,ethtype,(tp->phy_flags & 1024U) == 0U,(tp->phy_flags & 262144U) != 0U);
  }
  
#line 17928 
  tmp_25 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_TSO_CAPABLE,(unsigned long *)(& tp->tg3_flags));
  
#line 17927 
  tmp_26 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_ENABLE_ASF,(unsigned long *)(& tp->tg3_flags));
  
#line 17924 
  ;
  
#line 17925 
  tmp_27 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_LINKCHG_REG,(unsigned long *)(& tp->tg3_flags));
  
#line 17924 
  ;
  
#line 17924 
  ;
  
#line 17924 
  netdev_info((struct net_device const *)dev,"RXcsums[%d] LinkChgREG[%d] MIirq[%d] ASF[%d] TSOcap[%d]\n",(dev->features & 17179869184ULL) != 0ULL,tmp_27 != 0,(tp->phy_flags & 4U) != 0U,tmp_26 != 0,tmp_25 != 0);
  
#line 17931 
  if (pdev->dma_mask != 4294967295ULL) {
    int tmp_28;
    
#line 17932 
    if (pdev->dma_mask == 1099511627775ULL) 
#line 17932 
                                            tmp_28 = 40; else 
#line 17932 
                                                              tmp_28 = 64;
    
#line 17931 
    tmp_29 = tmp_28;
  }
  else 
#line 17931 
       tmp_29 = 32;
  
#line 17930 
  ;
  
#line 17930 
  ;
  
#line 17930 
  netdev_info((struct net_device const *)dev,"dma_rwctrl[%08x] dma_mask[%d-bit]\n",tp->dma_rwctrl,tmp_29);
  
#line 17935 
  pci_save_state(pdev);
  
#line 17937 
  __retres = 0;
  
#line 17937 
  goto return_label;
  err_out_apeunmap: 
#line 17939 
  ;
  
#line 17940 
  if (tp->aperegs != (void *)0) {
    
#line 17941 
    iounmap((void volatile *)tp->aperegs);
    
#line 17942 
    tp->aperegs = (void *)0;
  }
  else ;
  err_out_iounmap: 
#line 17945 
  ;
  
#line 17946 
  if (tp->regs != (void *)0) {
    
#line 17947 
    iounmap((void volatile *)tp->regs);
    
#line 17948 
    tp->regs = (void *)0;
  }
  else ;
  err_out_free_dev: 
#line 17951 
  ;
  
#line 17952 
  ldv_free_netdev_132(dev);
  err_out_free_res: 
#line 17954 
  ;
  
#line 17955 
  pci_release_regions(pdev);
  err_out_disable_pdev: 
#line 17957 
  ;
  
#line 17958 
  tmp_30 = pci_is_enabled(pdev);
  
#line 17958 
  if (tmp_30 != 0) 
#line 17959 
                   pci_disable_device(pdev); else ;
  
#line 17960 
  __retres = err;
  return_label: 
#line 17960 
                return __retres;
}


#line 17963  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_remove_one(struct pci_dev *pdev)
{
  
#line 17965 
  struct net_device *dev = pci_get_drvdata(pdev);
  
#line 17967 
  if (dev != (struct net_device *)0) {
    int tmp_1;
    
#line 17968 
    struct tg3 *tp = netdev_priv((struct net_device const *)dev);
    
#line 17970 
    tg3_ptp_fini(tp);
    
#line 17972 
    release_firmware(tp->fw);
    
#line 17974 
    tg3_reset_task_cancel(tp);
    
#line 17976 
    tmp_1 = _tg3_flag((enum TG3_FLAGS)TG3_FLAG_USE_PHYLIB,(unsigned long *)(& tp->tg3_flags));
    
#line 17976 
    if (tmp_1 != 0) {
      
#line 17977 
      tg3_phy_fini(tp);
      
#line 17978 
      tg3_mdio_fini(tp);
    }
    else ;
    
#line 17981 
    ldv_unregister_netdev_133(dev);
    
#line 17982 
    if (tp->aperegs != (void *)0) {
      
#line 17983 
      iounmap((void volatile *)tp->aperegs);
      
#line 17984 
      tp->aperegs = (void *)0;
    }
    else ;
    
#line 17986 
    if (tp->regs != (void *)0) {
      
#line 17987 
      iounmap((void volatile *)tp->regs);
      
#line 17988 
      tp->regs = (void *)0;
    }
    else ;
    
#line 17990 
    ldv_free_netdev_134(dev);
    
#line 17991 
    pci_release_regions(pdev);
    
#line 17992 
    pci_disable_device(pdev);
  }
  else ;
  
#line 17994 
  return;
}


#line 17997  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_suspend(struct device *device)
{
  struct pci_dev *tmp;
  int tmp_3;
  bool tmp_2;
  {
    
#line 17999 
    struct device const *__mptr = (struct device const *)device;
    
#line 17999 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 17999 
  struct pci_dev *pdev = tmp;
  
#line 18000 
  struct net_device *dev = pci_get_drvdata(pdev);
  
#line 18001 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 18002 
  int err = 0;
  
#line 18004 
  rtnl_lock();
  
#line 18006 
  tmp_2 = netif_running((struct net_device const *)dev);
  
#line 18006 
  if (tmp_2) 
#line 18006 
             tmp_3 = 0; else 
#line 18006 
                             tmp_3 = 1;
  
#line 18006 
  if (tmp_3) 
#line 18007 
             goto unlock; else ;
  
#line 18009 
  tg3_reset_task_cancel(tp);
  
#line 18010 
  tg3_phy_stop(tp);
  
#line 18011 
  tg3_netif_stop(tp);
  
#line 18013 
  tg3_timer_stop(tp);
  
#line 18015 
  tg3_full_lock(tp,1);
  
#line 18016 
  tg3_disable_ints(tp);
  
#line 18017 
  tg3_full_unlock(tp);
  
#line 18019 
  netif_device_detach(dev);
  
#line 18021 
  tg3_full_lock(tp,0);
  
#line 18022 
  tg3_halt(tp,0,(_Bool)1);
  
#line 18023 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
  
#line 18024 
  tg3_full_unlock(tp);
  
#line 18026 
  err = tg3_power_down_prepare(tp);
  
#line 18027 
  if (err != 0) {
    int err2;
    
#line 18030 
    tg3_full_lock(tp,0);
    
#line 18032 
    _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
    
#line 18033 
    err2 = tg3_restart_hw(tp,(_Bool)1);
    
#line 18034 
    if (err2 != 0) 
#line 18035 
                   goto out; else ;
    
#line 18037 
    tg3_timer_start(tp);
    
#line 18039 
    netif_device_attach(dev);
    
#line 18040 
    tg3_netif_start(tp);
    out: 
#line 18042 
    ;
    
#line 18043 
    tg3_full_unlock(tp);
    
#line 18045 
    if (err2 == 0) 
#line 18046 
                   tg3_phy_start(tp); else ;
  }
  else ;
  unlock: 
#line 18049 
  ;
  
#line 18050 
  rtnl_unlock();
  
#line 18051 
  return err;
}


#line 18054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_resume(struct device *device)
{
  struct pci_dev *tmp;
  int tmp_3;
  bool tmp_2;
  {
    
#line 18056 
    struct device const *__mptr = (struct device const *)device;
    
#line 18056 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 18056 
  struct pci_dev *pdev = tmp;
  
#line 18057 
  struct net_device *dev = pci_get_drvdata(pdev);
  
#line 18058 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 18059 
  int err = 0;
  
#line 18061 
  rtnl_lock();
  
#line 18063 
  tmp_2 = netif_running((struct net_device const *)dev);
  
#line 18063 
  if (tmp_2) 
#line 18063 
             tmp_3 = 0; else 
#line 18063 
                             tmp_3 = 1;
  
#line 18063 
  if (tmp_3) 
#line 18064 
             goto unlock; else ;
  
#line 18066 
  netif_device_attach(dev);
  
#line 18068 
  tg3_full_lock(tp,0);
  
#line 18070 
  tg3_ape_driver_state_change(tp,1);
  
#line 18072 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
  
#line 18073 
  err = tg3_restart_hw(tp,(_Bool)((tp->phy_flags & 1048576U) == 0U));
  
#line 18075 
  if (err != 0) 
#line 18076 
                goto out; else ;
  
#line 18078 
  tg3_timer_start(tp);
  
#line 18080 
  tg3_netif_start(tp);
  out: 
#line 18082 
  ;
  
#line 18083 
  tg3_full_unlock(tp);
  
#line 18085 
  if (err == 0) 
#line 18086 
                tg3_phy_start(tp); else ;
  unlock: 
#line 18088 
  ;
  
#line 18089 
  rtnl_unlock();
  
#line 18090 
  return err;
}


#line 18094  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct dev_pm_ops const tg3_pm_ops = {.prepare = (int (*)(struct device *))0, .complete = (void (*)(struct device *))0, .suspend = & tg3_suspend, .resume = & tg3_resume, .freeze = & tg3_suspend, .thaw = & tg3_resume, .poweroff = & tg3_suspend, .restore = & tg3_resume, .suspend_late = (int (*)(struct device *))0, .resume_early = (int (*)(struct device *))0, .freeze_late = (int (*)(struct device *))0, .thaw_early = (int (*)(struct device *))0, .poweroff_late = (int (*)(struct device *))0, .restore_early = (int (*)(struct device *))0, .suspend_noirq = (int (*)(struct device *))0, .resume_noirq = (int (*)(struct device *))0, .freeze_noirq = (int (*)(struct device *))0, .thaw_noirq = (int (*)(struct device *))0, .poweroff_noirq = (int (*)(struct device *))0, .restore_noirq = (int (*)(struct device *))0, .runtime_suspend = (int (*)(struct device *))0, .runtime_resume = (int (*)(struct device *))0, .runtime_idle = (int (*)(struct device *))0};

#line 18096  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_shutdown(struct pci_dev *pdev)
{
  bool tmp_1;
  
#line 18098 
  struct net_device *dev = pci_get_drvdata(pdev);
  
#line 18099 
  struct tg3 *tp = netdev_priv((struct net_device const *)dev);
  
#line 18101 
  rtnl_lock();
  
#line 18102 
  netif_device_detach(dev);
  
#line 18104 
  tmp_1 = netif_running((struct net_device const *)dev);
  
#line 18104 
  if ((int)tmp_1 != 0) 
#line 18105 
                       dev_close(dev); else ;
  
#line 18107 
  if (system_state == (unsigned int)SYSTEM_POWER_OFF) 
#line 18108 
                                                      tg3_power_down(tp); else ;
  
#line 18110 
  rtnl_unlock();
  
#line 18111 
  return;
}


#line 18121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static pci_ers_result_t tg3_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
{
  
#line 18124 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 18125 
  struct tg3 *tp = netdev_priv((struct net_device const *)netdev);
  
#line 18126 
  pci_ers_result_t err = 3U;
  
#line 18128 
  netdev_info((struct net_device const *)netdev,"PCI I/O error detected\n");
  
#line 18130 
  rtnl_lock();
  
#line 18133 
  if (state == 2U) 
#line 18134 
                   tp->pcierr_recovery = (_Bool)1; else ;
  
#line 18137 
  if (netdev == (struct net_device *)0) 
#line 18138 
                                        goto done;
  else {
    int tmp_2;
    bool tmp_1;
    
#line 18137 
    tmp_1 = netif_running((struct net_device const *)netdev);
    
#line 18137 
    if (tmp_1) 
#line 18137 
               tmp_2 = 0; else 
#line 18137 
                               tmp_2 = 1;
    
#line 18137 
    if (tmp_2) 
#line 18138 
               goto done; else ;
  }
  
#line 18140 
  tg3_phy_stop(tp);
  
#line 18142 
  tg3_netif_stop(tp);
  
#line 18144 
  tg3_timer_stop(tp);
  
#line 18147 
  tg3_reset_task_cancel(tp);
  
#line 18149 
  netif_device_detach(netdev);
  
#line 18152 
  tg3_full_lock(tp,0);
  
#line 18153 
  tg3_halt(tp,0,(_Bool)0);
  
#line 18154 
  tg3_full_unlock(tp);
  done: 
#line 18156 
  ;
  
#line 18157 
  if (state == 3U) {
    
#line 18158 
    if (netdev != (struct net_device *)0) {
      
#line 18159 
      tg3_napi_enable(tp);
      
#line 18160 
      dev_close(netdev);
    }
    else ;
    
#line 18162 
    err = 4U;
  }
  else 
#line 18164 
       pci_disable_device(pdev);
  
#line 18167 
  rtnl_unlock();
  
#line 18169 
  return err;
}


#line 18181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static pci_ers_result_t tg3_io_slot_reset(struct pci_dev *pdev)
{
  int err;
  int tmp_1;
  
#line 18183 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 18184 
  struct tg3 *tp = netdev_priv((struct net_device const *)netdev);
  
#line 18185 
  pci_ers_result_t rc = 4U;
  
#line 18188 
  rtnl_lock();
  
#line 18190 
  tmp_1 = pci_enable_device(pdev);
  
#line 18190 
  if (tmp_1 != 0) {
    
#line 18191 
    dev_err((struct device const *)(& pdev->dev),"Cannot re-enable PCI device after reset.\n");
    
#line 18193 
    goto done;
  }
  else ;
  
#line 18196 
  pci_set_master(pdev);
  
#line 18197 
  pci_restore_state(pdev);
  
#line 18198 
  pci_save_state(pdev);
  
#line 18200 
  if (netdev == (struct net_device *)0) 
#line 18200 
                                        goto _LOR;
  else {
    int tmp_3;
    bool tmp_2;
    
#line 18200 
    tmp_2 = netif_running((struct net_device const *)netdev);
    
#line 18200 
    if (tmp_2) 
#line 18200 
               tmp_3 = 0; else 
#line 18200 
                               tmp_3 = 1;
    
#line 18200 
    if (tmp_3) {
      _LOR: {
              
#line 18201 
              rc = 5U;
              
#line 18202 
              goto done;
            }
    }
    else ;
  }
  
#line 18205 
  err = tg3_power_up(tp);
  
#line 18206 
  if (err != 0) 
#line 18207 
                goto done; else ;
  
#line 18209 
  rc = 5U;
  done: 
#line 18211 
  ;
  
#line 18212 
  if (rc != 5U && netdev != (struct net_device *)0) {
    bool tmp_4;
    
#line 18212 
    tmp_4 = netif_running((struct net_device const *)netdev);
    
#line 18212 
    if ((int)tmp_4 != 0) {
      
#line 18213 
      tg3_napi_enable(tp);
      
#line 18214 
      dev_close(netdev);
    }
    else ;
  }
  else ;
  
#line 18216 
  rtnl_unlock();
  
#line 18218 
  return rc;
}


#line 18228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_io_resume(struct pci_dev *pdev)
{
  int err;
  int tmp_2;
  bool tmp_1;
  
#line 18230 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 18231 
  struct tg3 *tp = netdev_priv((struct net_device const *)netdev);
  
#line 18234 
  rtnl_lock();
  
#line 18236 
  tmp_1 = netif_running((struct net_device const *)netdev);
  
#line 18236 
  if (tmp_1) 
#line 18236 
             tmp_2 = 0; else 
#line 18236 
                             tmp_2 = 1;
  
#line 18236 
  if (tmp_2) 
#line 18237 
             goto done; else ;
  
#line 18239 
  tg3_full_lock(tp,0);
  
#line 18240 
  tg3_ape_driver_state_change(tp,1);
  
#line 18241 
  _tg3_flag_set((enum TG3_FLAGS)TG3_FLAG_INIT_COMPLETE,(unsigned long *)(& tp->tg3_flags));
  
#line 18242 
  err = tg3_restart_hw(tp,(_Bool)1);
  
#line 18243 
  if (err != 0) {
    
#line 18244 
    tg3_full_unlock(tp);
    
#line 18245 
    netdev_err((struct net_device const *)netdev,"Cannot restart hardware after reset.\n");
    
#line 18246 
    goto done;
  }
  else ;
  
#line 18249 
  netif_device_attach(netdev);
  
#line 18251 
  tg3_timer_start(tp);
  
#line 18253 
  tg3_netif_start(tp);
  
#line 18255 
  tg3_full_unlock(tp);
  
#line 18257 
  tg3_phy_start(tp);
  done: 
#line 18259 
  ;
  
#line 18260 
  tp->pcierr_recovery = (_Bool)0;
  
#line 18261 
  rtnl_unlock();
  
#line 18262 
  return;
}


#line 18264  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct pci_error_handlers const tg3_err_handler = {.error_detected = (pci_ers_result_t (*)(struct pci_dev *, enum pci_channel_state ))(& tg3_io_error_detected), .mmio_enabled = (pci_ers_result_t (*)(struct pci_dev *))0, .link_reset = (pci_ers_result_t (*)(struct pci_dev *))0, .slot_reset = & tg3_io_slot_reset, .reset_notify = (void (*)(struct pci_dev *, bool ))0, .resume = & tg3_io_resume};

#line 18270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static struct pci_driver tg3_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = "tg3", .id_table = (struct pci_device_id const *)(& tg3_pci_tbl), .probe = & tg3_init_one, .remove = & tg3_remove_one, .suspend = (int (*)(struct pci_dev *, pm_message_t ))0, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = (int (*)(struct pci_dev *))0, .shutdown = & tg3_shutdown, .sriov_configure = (int (*)(struct pci_dev *, int ))0, .err_handler = & tg3_err_handler, .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = & tg3_pm_ops, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 18280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static int tg3_driver_init(void)
{
  int tmp;
  
#line 18280 
  tmp = ldv___pci_register_driver_135(& tg3_driver,& __this_module,"tg3");
  
#line 18280 
  return tmp;
}


#line 18280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/broadcom/tg3.c"
static void tg3_driver_exit(void)
{
  
#line 18280 
  ldv_pci_unregister_driver_136(& tg3_driver);
  
#line 18281 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int (*ldv_emg_alias_eth_validate_addr_30)(struct net_device *) = & eth_validate_addr;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
struct dev_pm_ops *ldv_emg_alias_tg3_pm_ops_3 = (struct dev_pm_ops *)(& tg3_pm_ops);

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
struct pci_driver *ldv_emg_alias_tg3_driver_2 = & tg3_driver;

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
unsigned int (*ldv_emg_alias_ethtool_op_get_link_26)(struct net_device *) = & ethtool_op_get_link;

#line 62 
void ldv_emg_unregister_netdev(struct net_device *arg0);


#line 63 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 64 
_Bool ldv_emg_schedule_work(struct work_struct *arg0);


#line 65 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 66 
int ldv_emg_register_netdev(struct net_device *arg0);


#line 67 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 68 
int ldv_emg_del_timer_sync(struct timer_list *arg0);


#line 69 
void ldv_emg_free_netdev(struct net_device *arg0);


#line 70 
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);


#line 71 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
unsigned int ldv_emg_wrapper_tg3_get_msglevel_12(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 76 
  tmp = tg3_get_msglevel(arg0);
  
#line 76 
  return tmp;
}


#line 80  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_eeprom_8(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  int tmp;
  
#line 81 
  tmp = tg3_set_eeprom(arg0,arg1,arg2);
  
#line 81 
  return tmp;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_tg3_driver_init(void)
{
  int tmp;
  
#line 86 
  tmp = tg3_driver_init();
  
#line 86 
  return tmp;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_tg3_driver_exit(void)
{
  
#line 90 
  tg3_driver_exit();
  
#line 91 
  return;
}


#line 93  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_rxfh_10(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char arg3)
{
  int tmp;
  
#line 94 
  tmp = tg3_set_rxfh(arg0,(u32 const *)arg1,(u8 const *)arg2,(unsigned char)((int)arg3));
  
#line 94 
  return tmp;
}


#line 98  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_nway_reset_22(struct net_device *arg0)
{
  int tmp;
  
#line 99 
  tmp = tg3_nway_reset(arg0);
  
#line 99 
  return tmp;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_pauseparam_35(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  int tmp;
  
#line 104 
  tmp = tg3_set_pauseparam(arg0,arg1);
  
#line 104 
  return tmp;
}


#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_rxfh_21(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char *arg3)
{
  int tmp;
  
#line 109 
  tmp = tg3_get_rxfh(arg0,arg1,arg2,arg3);
  
#line 109 
  return tmp;
}


#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_eee_9(struct net_device *arg0, struct ethtool_eee *arg1)
{
  int tmp;
  
#line 114 
  tmp = tg3_get_eee(arg0,arg1);
  
#line 114 
  return tmp;
}


#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_coalesce_43(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 119 
  tmp = tg3_set_coalesce(arg0,arg1);
  
#line 119 
  return tmp;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_get_drvinfo_7(struct net_device *arg0, struct ethtool_drvinfo *arg1)
{
  
#line 124 
  tg3_get_drvinfo(arg0,arg1);
  
#line 125 
  return;
}


#line 128  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_get_wol_37(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  
#line 129 
  tg3_get_wol(arg0,arg1);
  
#line 130 
  return;
}


#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_get_regs_39(struct net_device *arg0, struct ethtool_regs *arg1, void *arg2)
{
  
#line 134 
  tg3_get_regs(arg0,arg1,arg2);
  
#line 135 
  return;
}


#line 138  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_self_test_16(struct net_device *arg0, struct ethtool_test *arg1, unsigned long long *arg2)
{
  
#line 139 
  tg3_self_test(arg0,arg1,arg2);
  
#line 140 
  return;
}


#line 143  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_get_ethtool_stats_5(struct net_device *arg0, struct ethtool_stats *arg1, unsigned long long *arg2)
{
  
#line 144 
  tg3_get_ethtool_stats(arg0,arg1,arg2);
  
#line 145 
  return;
}


#line 148  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_coalesce_38(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 149 
  tmp = tg3_get_coalesce(arg0,arg1);
  
#line 149 
  return tmp;
}


#line 153  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_features_31(struct net_device *arg0, unsigned long long arg1)
{
  int tmp;
  
#line 154 
  tmp = tg3_set_features(arg0,arg1);
  
#line 154 
  return tmp;
}


#line 158  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_mac_addr_14(struct net_device *arg0, void *arg1)
{
  int tmp;
  
#line 159 
  tmp = tg3_set_mac_addr(arg0,arg1);
  
#line 159 
  return tmp;
}


#line 163  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_change_mtu_6(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 164 
  tmp = tg3_change_mtu(arg0,arg1);
  
#line 164 
  return tmp;
}


#line 168  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_get_strings_41(struct net_device *arg0, unsigned int arg1, unsigned char *arg2)
{
  
#line 169 
  tg3_get_strings(arg0,arg1,arg2);
  
#line 170 
  return;
}


#line 173  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_open_2(struct net_device *arg0)
{
  int tmp;
  
#line 174 
  tmp = tg3_open(arg0);
  
#line 174 
  return tmp;
}


#line 178  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_poll_controller_45(struct net_device *arg0)
{
  
#line 179 
  tg3_poll_controller(arg0);
  
#line 180 
  return;
}


#line 183  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
enum irqreturn ldv_emg_wrapper_tg3_test_isr_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 184 
  tmp = tg3_test_isr(arg0,arg1);
  
#line 184 
  return tmp;
}


#line 188  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_rxnfc_19(struct net_device *arg0, struct ethtool_rxnfc *arg1, unsigned int *arg2)
{
  int tmp;
  
#line 189 
  tmp = tg3_get_rxnfc(arg0,arg1,arg2);
  
#line 189 
  return tmp;
}


#line 193  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
enum netdev_tx ldv_emg_wrapper_tg3_start_xmit_13(struct sk_buff *arg0, struct net_device *arg1)
{
  enum netdev_tx tmp;
  
#line 194 
  tmp = tg3_start_xmit(arg0,arg1);
  
#line 194 
  return tmp;
}


#line 198  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_shutdown_2(struct pci_dev *arg0)
{
  
#line 199 
  tg3_shutdown(arg0);
  
#line 200 
  return;
}


#line 203  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_set_rx_mode_23(struct net_device *arg0)
{
  
#line 204 
  tg3_set_rx_mode(arg0);
  
#line 205 
  return;
}


#line 208  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_init_one_3(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 209 
  tmp = tg3_init_one(arg0,(struct pci_device_id const *)arg1);
  
#line 209 
  return tmp;
}


#line 213  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_regs_len_42(struct net_device *arg0)
{
  int tmp;
  
#line 214 
  tmp = tg3_get_regs_len(arg0);
  
#line 214 
  return tmp;
}


#line 218  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_eeprom_25(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  int tmp;
  
#line 219 
  tmp = tg3_get_eeprom(arg0,arg1,arg2);
  
#line 219 
  return tmp;
}


#line 223  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_ioctl_17(struct net_device *arg0, struct ifreq *arg1, int arg2)
{
  int tmp;
  
#line 224 
  tmp = tg3_ioctl(arg0,arg1,arg2);
  
#line 224 
  return tmp;
}


#line 228  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_get_ringparam_20(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  
#line 229 
  tg3_get_ringparam(arg0,arg1);
  
#line 230 
  return;
}


#line 233  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_remove_one_4(struct pci_dev *arg0)
{
  
#line 234 
  tg3_remove_one(arg0);
  
#line 235 
  return;
}


#line 238  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_settings_2(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 239 
  tmp = tg3_set_settings(arg0,arg1);
  
#line 239 
  return tmp;
}


#line 243  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
unsigned int ldv_emg_wrapper_tg3_get_rxfh_indir_size_27(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 244 
  tmp = tg3_get_rxfh_indir_size(arg0);
  
#line 244 
  return tmp;
}


#line 248  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_close_2(struct net_device *arg0)
{
  int tmp;
  
#line 249 
  tmp = tg3_close(arg0);
  
#line 249 
  return tmp;
}


#line 253  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_ts_info_28(struct net_device *arg0, struct ethtool_ts_info *arg1)
{
  int tmp;
  
#line 254 
  tmp = tg3_get_ts_info(arg0,arg1);
  
#line 254 
  return tmp;
}


#line 258  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_get_pauseparam_24(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  
#line 259 
  tg3_get_pauseparam(arg0,arg1);
  
#line 260 
  return;
}


#line 263  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_get_channels_29(struct net_device *arg0, struct ethtool_channels *arg1)
{
  
#line 264 
  tg3_get_channels(arg0,arg1);
  
#line 265 
  return;
}


#line 268  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_eee_34(struct net_device *arg0, struct ethtool_eee *arg1)
{
  int tmp;
  
#line 269 
  tmp = tg3_set_eee(arg0,arg1);
  
#line 269 
  return tmp;
}


#line 273  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_eeprom_len_46(struct net_device *arg0)
{
  int tmp;
  
#line 274 
  tmp = tg3_get_eeprom_len(arg0);
  
#line 274 
  return tmp;
}


#line 278  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_wol_18(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  int tmp;
  
#line 279 
  tmp = tg3_set_wol(arg0,arg1);
  
#line 279 
  return tmp;
}


#line 283  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_ringparam_11(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  int tmp;
  
#line 284 
  tmp = tg3_set_ringparam(arg0,arg1);
  
#line 284 
  return tmp;
}


#line 288  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_sset_count_15(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 289 
  tmp = tg3_get_sset_count(arg0,arg1);
  
#line 289 
  return tmp;
}


#line 293  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
unsigned long long ldv_emg_wrapper_tg3_fix_features_32(struct net_device *arg0, unsigned long long arg1)
{
  unsigned long long tmp;
  
#line 294 
  tmp = tg3_fix_features(arg0,arg1);
  
#line 294 
  return tmp;
}


#line 298  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
struct rtnl_link_stats64 *ldv_emg_wrapper_tg3_get_stats64_4(struct net_device *arg0, struct rtnl_link_stats64 *arg1)
{
  struct rtnl_link_stats64 *tmp;
  
#line 299 
  tmp = tg3_get_stats64(arg0,arg1);
  
#line 299 
  return tmp;
}


#line 303  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_resume_4(struct device *arg0)
{
  int tmp;
  
#line 304 
  tmp = tg3_resume(arg0);
  
#line 304 
  return tmp;
}


#line 308  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_suspend_2(struct device *arg0)
{
  int tmp;
  
#line 309 
  tmp = tg3_suspend(arg0);
  
#line 309 
  return tmp;
}


#line 313  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_phys_id_3(struct net_device *arg0, enum ethtool_phys_id_state arg1)
{
  int tmp;
  
#line 314 
  tmp = tg3_set_phys_id(arg0,arg1);
  
#line 314 
  return tmp;
}


#line 318  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_tx_timeout_40(struct net_device *arg0)
{
  
#line 319 
  tg3_tx_timeout(arg0);
  
#line 320 
  return;
}


#line 323  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_get_settings_36(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 324 
  tmp = tg3_get_settings(arg0,arg1);
  
#line 324 
  return tmp;
}


#line 328  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
void ldv_emg_wrapper_tg3_set_msglevel_44(struct net_device *arg0, unsigned int arg1)
{
  
#line 329 
  tg3_set_msglevel(arg0,arg1);
  
#line 330 
  return;
}


#line 333  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
int ldv_emg_wrapper_tg3_set_channels_33(struct net_device *arg0, struct ethtool_channels *arg1)
{
  int tmp;
  
#line 334 
  tmp = tg3_set_channels(arg0,arg1);
  
#line 334 
  return tmp;
}


#line 346  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static long PTR_ERR(void const *ptr)
{
  long tmp;
  
#line 349 
  tmp = ldv_ptr_err(ptr);
  
#line 349 
  return tmp;
}


#line 353  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static bool IS_ERR(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 357 
  ret = ldv_is_err(ptr);
  
#line 358 
  __retres = (_Bool)(ret != 0L);
  
#line 358 
  return __retres;
}


#line 707  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 710 
  tmp = ldv_kmalloc(size,flags);
  
#line 710 
  return tmp;
}


#line 728  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 731 
  tmp = ldv_kzalloc(size,flags);
  
#line 731 
  return tmp;
}


#line 876  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_60(spinlock_t *lock)
{
  
#line 880 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 882 
  spin_lock(lock);
  
#line 883 
  return;
}


#line 919  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_63(spinlock_t *lock)
{
  
#line 923 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 925 
  spin_unlock(lock);
  
#line 926 
  return;
}


#line 1027  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv___ldv_spin_lock_74(spinlock_t *ldv_func_arg1)
{
  
#line 1031 
  ldv_spin_model_lock((char *)"indirect_lock_of_tg3");
  
#line 1033 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1034 
  return;
}


#line 1037  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_irqrestore_75(spinlock_t *lock, unsigned long flags)
{
  
#line 1041 
  ldv_spin_model_unlock((char *)"indirect_lock_of_tg3");
  
#line 1043 
  spin_unlock_irqrestore(lock,flags);
  
#line 1044 
  return;
}


#line 1047  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv___ldv_spin_lock_76(spinlock_t *ldv_func_arg1)
{
  
#line 1051 
  ldv_spin_model_lock((char *)"indirect_lock_of_tg3");
  
#line 1053 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1054 
  return;
}


#line 1057  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_irqrestore_77(spinlock_t *lock, unsigned long flags)
{
  
#line 1061 
  ldv_spin_model_unlock((char *)"indirect_lock_of_tg3");
  
#line 1063 
  spin_unlock_irqrestore(lock,flags);
  
#line 1064 
  return;
}


#line 1067  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv___ldv_spin_lock_78(spinlock_t *ldv_func_arg1)
{
  
#line 1071 
  ldv_spin_model_lock((char *)"indirect_lock_of_tg3");
  
#line 1073 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1074 
  return;
}


#line 1077  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_irqrestore_79(spinlock_t *lock, unsigned long flags)
{
  
#line 1081 
  ldv_spin_model_unlock((char *)"indirect_lock_of_tg3");
  
#line 1083 
  spin_unlock_irqrestore(lock,flags);
  
#line 1084 
  return;
}


#line 1087  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv___ldv_spin_lock_80(spinlock_t *ldv_func_arg1)
{
  
#line 1091 
  ldv_spin_model_lock((char *)"indirect_lock_of_tg3");
  
#line 1093 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1094 
  return;
}


#line 1097  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_irqrestore_81(spinlock_t *lock, unsigned long flags)
{
  
#line 1101 
  ldv_spin_model_unlock((char *)"indirect_lock_of_tg3");
  
#line 1103 
  spin_unlock_irqrestore(lock,flags);
  
#line 1104 
  return;
}


#line 1107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv___ldv_spin_lock_82(spinlock_t *ldv_func_arg1)
{
  
#line 1111 
  ldv_spin_model_lock((char *)"indirect_lock_of_tg3");
  
#line 1113 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1114 
  return;
}


#line 1117  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_irqrestore_83(spinlock_t *lock, unsigned long flags)
{
  
#line 1121 
  ldv_spin_model_unlock((char *)"indirect_lock_of_tg3");
  
#line 1123 
  spin_unlock_irqrestore(lock,flags);
  
#line 1124 
  return;
}


#line 1127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv___ldv_spin_lock_84(spinlock_t *ldv_func_arg1)
{
  
#line 1131 
  ldv_spin_model_lock((char *)"indirect_lock_of_tg3");
  
#line 1133 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1134 
  return;
}


#line 1137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_irqrestore_85(spinlock_t *lock, unsigned long flags)
{
  
#line 1141 
  ldv_spin_model_unlock((char *)"indirect_lock_of_tg3");
  
#line 1143 
  spin_unlock_irqrestore(lock,flags);
  
#line 1144 
  return;
}


#line 1147  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_86(spinlock_t *lock)
{
  
#line 1151 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1153 
  spin_lock_bh(lock);
  
#line 1154 
  return;
}


#line 1157  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_87(spinlock_t *lock)
{
  
#line 1161 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1163 
  spin_unlock_bh(lock);
  
#line 1164 
  return;
}


#line 1167  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_88(spinlock_t *lock)
{
  
#line 1171 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1173 
  spin_lock_bh(lock);
  
#line 1174 
  return;
}


#line 1177  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_89(spinlock_t *lock)
{
  
#line 1181 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1183 
  spin_unlock_bh(lock);
  
#line 1184 
  return;
}


#line 1187  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_90(spinlock_t *lock)
{
  
#line 1191 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1193 
  spin_lock_bh(lock);
  
#line 1194 
  return;
}


#line 1197  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_91(spinlock_t *lock)
{
  
#line 1201 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1203 
  spin_unlock_bh(lock);
  
#line 1204 
  return;
}


#line 1207  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_92(spinlock_t *lock)
{
  
#line 1211 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1213 
  spin_lock(lock);
  
#line 1214 
  return;
}


#line 1217  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_93(spinlock_t *lock)
{
  
#line 1221 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1223 
  spin_unlock(lock);
  
#line 1224 
  return;
}


#line 1227  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static bool ldv_schedule_work_94(struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1231 
  tmp = ldv_emg_schedule_work(work);
  
#line 1231 
  __retres = tmp != 0;
  
#line 1231 
  return __retres;
}


#line 1235  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_95(spinlock_t *lock)
{
  
#line 1239 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1241 
  spin_unlock_bh(lock);
  
#line 1242 
  return;
}


#line 1245  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_96(spinlock_t *lock)
{
  
#line 1249 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1251 
  spin_lock_bh(lock);
  
#line 1252 
  return;
}


#line 1255  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_97(spinlock_t *lock)
{
  
#line 1259 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1261 
  spin_lock_bh(lock);
  
#line 1262 
  return;
}


#line 1265  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_98(spinlock_t *lock)
{
  
#line 1269 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1271 
  spin_unlock_bh(lock);
  
#line 1272 
  return;
}


#line 1275  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_99(spinlock_t *lock)
{
  
#line 1279 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1281 
  spin_lock_bh(lock);
  
#line 1282 
  return;
}


#line 1285  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_100(spinlock_t *lock)
{
  
#line 1289 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1291 
  spin_unlock_bh(lock);
  
#line 1292 
  return;
}


#line 1295  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_101(spinlock_t *lock)
{
  
#line 1299 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1301 
  spin_lock_bh(lock);
  
#line 1302 
  return;
}


#line 1305  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_102(spinlock_t *lock)
{
  
#line 1309 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1311 
  spin_unlock_bh(lock);
  
#line 1312 
  return;
}


#line 1315  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_103(spinlock_t *lock)
{
  
#line 1319 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1321 
  spin_lock_bh(lock);
  
#line 1322 
  return;
}


#line 1325  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_104(spinlock_t *lock)
{
  
#line 1329 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1331 
  spin_unlock_bh(lock);
  
#line 1332 
  return;
}


#line 1335  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_105(spinlock_t *lock)
{
  
#line 1339 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1341 
  spin_lock_bh(lock);
  
#line 1342 
  return;
}


#line 1345  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_106(spinlock_t *lock)
{
  
#line 1349 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1351 
  spin_unlock_bh(lock);
  
#line 1352 
  return;
}


#line 1355  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_107(spinlock_t *lock)
{
  
#line 1359 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1361 
  spin_lock(lock);
  
#line 1362 
  return;
}


#line 1365  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_108(spinlock_t *lock)
{
  
#line 1369 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1371 
  spin_unlock(lock);
  
#line 1372 
  return;
}


#line 1375  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_109(spinlock_t *lock)
{
  
#line 1379 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1381 
  spin_unlock(lock);
  
#line 1382 
  return;
}


#line 1385  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_110(spinlock_t *lock)
{
  
#line 1389 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1391 
  spin_unlock(lock);
  
#line 1392 
  return;
}


#line 1395  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static int ldv_del_timer_sync_111(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1399 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1399 
  return tmp;
}


#line 1403  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static int ldv_request_irq_112(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 1407 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 1407 
  return tmp;
}


#line 1411  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_irq_113(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1415 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1416 
  return;
}


#line 1419  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static int ldv_request_irq_114(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 1423 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 1423 
  return tmp;
}


#line 1427  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_irq_115(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1431 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1432 
  return;
}


#line 1435  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_irq_116(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1439 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1440 
  return;
}


#line 1443  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_irq_117(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1447 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1448 
  return;
}


#line 1451  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_irq_118(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1455 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1456 
  return;
}


#line 1459  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_irq_119(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1463 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1464 
  return;
}


#line 1467  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_irq_120(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 1471 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 1472 
  return;
}


#line 1475  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_121(spinlock_t *lock)
{
  
#line 1479 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1481 
  spin_lock_bh(lock);
  
#line 1482 
  return;
}


#line 1485  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_122(spinlock_t *lock)
{
  
#line 1489 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1491 
  spin_unlock_bh(lock);
  
#line 1492 
  return;
}


#line 1495  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_123(spinlock_t *lock)
{
  
#line 1499 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1501 
  spin_lock_bh(lock);
  
#line 1502 
  return;
}


#line 1505  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_124(spinlock_t *lock)
{
  
#line 1509 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1511 
  spin_unlock_bh(lock);
  
#line 1512 
  return;
}


#line 1515  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_125(spinlock_t *lock)
{
  
#line 1519 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1521 
  spin_lock_bh(lock);
  
#line 1522 
  return;
}


#line 1525  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_126(spinlock_t *lock)
{
  
#line 1529 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1531 
  spin_unlock_bh(lock);
  
#line 1532 
  return;
}


#line 1535  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_lock_bh_127(spinlock_t *lock)
{
  
#line 1539 
  ldv_spin_model_lock((char *)"lock_of_tg3");
  
#line 1541 
  spin_lock_bh(lock);
  
#line 1542 
  return;
}


#line 1545  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_128(spinlock_t *lock)
{
  
#line 1549 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1551 
  spin_unlock_bh(lock);
  
#line 1552 
  return;
}


#line 1555  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_spin_unlock_bh_129(spinlock_t *lock)
{
  
#line 1559 
  ldv_spin_model_unlock((char *)"lock_of_tg3");
  
#line 1561 
  spin_unlock_bh(lock);
  
#line 1562 
  return;
}


#line 1565  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_130(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3)
{
  struct net_device *tmp;
  
#line 1569 
  tmp = ldv_emg_alloc_etherdev_mqs(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 1569 
  return tmp;
}


#line 1573  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static int ldv_register_netdev_131(struct net_device *ldv_func_arg1)
{
  int tmp;
  
#line 1577 
  tmp = ldv_emg_register_netdev(ldv_func_arg1);
  
#line 1577 
  return tmp;
}


#line 1581  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_netdev_132(struct net_device *ldv_func_arg1)
{
  
#line 1585 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 1586 
  return;
}


#line 1589  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_unregister_netdev_133(struct net_device *ldv_func_arg1)
{
  
#line 1593 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 1594 
  return;
}


#line 1597  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_free_netdev_134(struct net_device *ldv_func_arg1)
{
  
#line 1601 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 1602 
  return;
}


#line 1605  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static int ldv___pci_register_driver_135(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 1609 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 1609 
  return tmp;
}


#line 1613  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/weaver/.tmp_tg3.c.aux"
static void ldv_pci_unregister_driver_136(struct pci_driver *ldv_func_arg1)
{
  
#line 1617 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 1618 
  return;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 97 
void ldv_failed_register_netdev(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0);


#line 107 
int main(void);


#line 108 
void ldv_dispatch_instance_deregister_8_1(struct timer_list *arg0);


#line 109 
void ldv_dispatch_irq_deregister_3_1(int arg0);


#line 112 
void *ldv_pci_scenario_14(void *arg0);


#line 113 
void *ldv_random_allocationless_scenario_13(void *arg0);


#line 115 
void ldv_dispatch_deregister_9_1(struct pci_driver *arg0);


#line 116 
void *ldv_initialization_1(void *arg0);


#line 117 
void *ldv_pm_ops_scenario_12(void *arg0);


#line 118 
void *ldv_timer_scenario_16(void *arg0);


#line 119 
void *ldv_interrupt_scenario_15(void *arg0);


#line 121 
void ldv_dispatch_register_10_4(struct net_device *arg0);


#line 124 
void ldv_dispatch_irq_register_11_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 125 
void ldv_dispatch_register_6_3(struct pci_driver *arg0);


#line 130  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_14;

#line 131  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_13;

#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_12;

#line 134  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 138  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_13 *cf_arg_13;
  int tmp;
  
#line 141 
  tmp = ldv_undef_int();
  
#line 141 
  switch (tmp) {
    case 0: 
#line 142 
    ;
    
#line 143 
    ret = pthread_join(ldv_thread_13,(void **)0);
    
#line 144 
    __VERIFIER_assume(ret == 0);
    
#line 145 
    goto ldv_44792;
    default: 
#line 147 
    ;
    
#line 147 
    __VERIFIER_assume(0);
  }
  ldv_44792: 
#line 148 
  ;
  
#line 149 
  return;
}


#line 153  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_del_timer_sync(struct timer_list *arg0)
{
  int __retres;
  struct timer_list *ldv_8_timer_list;
  
#line 159 
  ldv_8_timer_list = arg0;
  
#line 163 
  ldv_dispatch_instance_deregister_8_1(ldv_8_timer_list);
  
#line 164 
  ;
  
#line 164 
  __retres = 0;
  
#line 164 
  return __retres;
}


#line 172  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 175 
  struct pci_driver *ldv_6_pci_driver = ldv_emg_alias_tg3_driver_2;
  
#line 179 
  tmp_0 = ldv_undef_int();
  
#line 179 
  if (tmp_0 != 0) {
    
#line 181 
    ldv_6_pci_driver = arg0;
    
#line 185 
    ldv_dispatch_register_6_3(ldv_6_pci_driver);
    
#line 189 
    __retres = 0;
    
#line 189 
    goto return_label;
  }
  else {
    int tmp;
    
#line 196 
    tmp = ldv_undef_int_negative();
    
#line 196 
    __retres = tmp;
    
#line 196 
    goto return_label;
  }
  return_label: 
#line 179 
                return __retres;
}


#line 206  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 209 
  ldv_initialize();
  
#line 212 
  ldv_initialization_1((void *)0);
  
#line 214 
  __retres = 0;
  
#line 214 
  return __retres;
}


#line 219  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_deregister_8_1(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_del_timer_sync_8 *cf_arg_16;
  int tmp;
  
#line 222 
  tmp = ldv_undef_int();
  
#line 222 
  switch (tmp) {
    case 0: 
#line 223 
    ;
    
#line 224 
    ret = pthread_join(ldv_thread_16,(void **)0);
    
#line 225 
    __VERIFIER_assume(ret == 0);
    
#line 226 
    goto ldv_44813;
    default: 
#line 228 
    ;
    
#line 228 
    __VERIFIER_assume(0);
  }
  ldv_44813: 
#line 229 
  ;
  
#line 230 
  return;
}


#line 234  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_3_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_3 *cf_arg_15;
  int tmp;
  
#line 237 
  tmp = ldv_undef_int();
  
#line 237 
  switch (tmp) {
    case 0: 
#line 238 
    ;
    
#line 239 
    ret = pthread_join(ldv_thread_15,(void **)0);
    
#line 240 
    __VERIFIER_assume(ret == 0);
    
#line 241 
    goto ldv_44821;
    default: 
#line 243 
    ;
    
#line 243 
    __VERIFIER_assume(0);
  }
  ldv_44821: 
#line 244 
  ;
  
#line 245 
  return;
}


#line 249  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  struct net_device *__retres;
  struct net_device *ldv_4_netdev;
  int tmp_0;
  
#line 256 
  tmp_0 = ldv_undef_int();
  
#line 256 
  if (tmp_0 != 0) {
    
#line 258 
    ldv_4_netdev = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    
#line 262 
    __retres = ldv_4_netdev;
    
#line 262 
    goto return_label;
  }
  else {
    
#line 269 
    __retres = (struct net_device *)0;
    
#line 269 
    goto return_label;
  }
  return_label: 
#line 256 
                return __retres;
}


#line 279  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_11_line;
  void *ldv_11_data;
  enum irqreturn (*ldv_11_thread)(int , void *);
  int tmp_0;
  
#line 284 
  enum irqreturn (*ldv_11_callback)(int , void *) = & ldv_emg_wrapper_tg3_test_isr_2;
  
#line 289 
  tmp_0 = ldv_undef_int();
  
#line 289 
  if (tmp_0 != 0) {
    
#line 291 
    ldv_11_line = (int)arg0;
    
#line 292 
    ldv_11_callback = arg1;
    
#line 293 
    ldv_11_thread = (enum irqreturn (*)(int , void *))0;
    
#line 294 
    ldv_11_data = arg4;
    
#line 298 
    ldv_dispatch_irq_register_11_3(ldv_11_line,ldv_11_callback,ldv_11_thread,ldv_11_data);
    
#line 302 
    __retres = 0;
    
#line 302 
    goto return_label;
  }
  else {
    int tmp;
    
#line 309 
    tmp = ldv_undef_int_negative();
    
#line 309 
    __retres = tmp;
    
#line 309 
    goto return_label;
  }
  return_label: 
#line 289 
                return __retres;
}


#line 319  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_14(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_14_resource_1;
  struct pci_device_id *ldv_14_ldv_param_1_2;
  struct pm_message ldv_14_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 324 
  struct pci_driver *ldv_14_container = ldv_emg_alias_tg3_driver_2;
  
#line 325 
  int ldv_14_ret = ldv_undef_int();
  
#line 328 
  struct ldv_struct_pci_scenario_14 *data = (struct ldv_struct_pci_scenario_14 *)arg0;
  
#line 332 
  ldv_14_ret = ldv_undef_int();
  
#line 335 
  if (data != (struct ldv_struct_pci_scenario_14 *)0) {
    
#line 336 
    ldv_14_container = data->arg0;
    
#line 337 
    ldv_free((void *)data);
  }
  else ;
  
#line 348 
  goto ldv_main_14;
  
#line 350 
  __retres = (void *)0;
  
#line 350 
  goto return_label;
  ldv_main_14: 
#line 353 
  ;
  
#line 356 
  tmp_2 = ldv_undef_int();
  
#line 356 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 358 
    ldv_14_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 363 
    ldv_pre_probe();
    
#line 365 
    ldv_14_ret = ldv_emg_wrapper_tg3_init_one_3(ldv_14_resource_1,ldv_14_ldv_param_1_2);
    
#line 367 
    ldv_14_ret = ldv_post_probe(ldv_14_ret);
    
#line 371 
    ldv_free((void *)ldv_14_ldv_param_1_2);
    
#line 374 
    tmp_1 = ldv_undef_int();
    
#line 374 
    if (tmp_1 != 0) {
      
#line 376 
      __VERIFIER_assume(ldv_14_ret == 0);
      
#line 383 
      goto ldv_call_14;
    }
    else {
      
#line 387 
      __VERIFIER_assume(ldv_14_ret != 0);
      
#line 394 
      goto ldv_main_14;
    }
  }
  else {
    
#line 406 
    __retres = (void *)0;
    
#line 406 
    goto return_label;
  }
  
#line 409 
  __retres = (void *)0;
  
#line 409 
  goto return_label;
  ldv_call_14: 
#line 412 
  ;
  
#line 415 
  tmp_3 = ldv_undef_int();
  
#line 415 
  switch (tmp_3) {
    case 1: 
#line 416 
    ;
    
#line 425 
    goto ldv_call_14;
    case 2: 
#line 428 
    ;
    
#line 430 
    if (ldv_14_container->suspend != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 432 
      ldv_14_ret = (*(ldv_14_container->suspend))(ldv_14_resource_1,ldv_14_resource_0);
      
#line 434 
      ldv_14_ret = ldv_filter_err_code(ldv_14_ret);
    }
    else 
#line 436 
         ldv_14_ret = ldv_undef_int();
    
#line 441 
    if (ldv_14_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 443 
      ldv_14_ret = (*(ldv_14_container->suspend_late))(ldv_14_resource_1,ldv_14_resource_0);
      
#line 445 
      ldv_14_ret = ldv_filter_err_code(ldv_14_ret);
    }
    else 
#line 447 
         ldv_14_ret = ldv_undef_int();
    
#line 452 
    if (ldv_14_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 454 
      (*(ldv_14_container->resume_early))(ldv_14_resource_1); else ;
    
#line 459 
    if (ldv_14_container->resume != (int (*)(struct pci_dev *))0) 
#line 461 
                                                                  (*(ldv_14_container->resume))(ldv_14_resource_1); else ;
    
#line 469 
    goto ldv_call_14;
    case 3: 
#line 472 
    ;
    
#line 475 
    ldv_emg_wrapper_tg3_shutdown_2(ldv_14_resource_1);
    
#line 480 
    ldv_emg_wrapper_tg3_remove_one_4(ldv_14_resource_1);
    
#line 487 
    goto ldv_main_14;
    default: 
#line 490 
    ;
    
#line 490 
    __VERIFIER_assume(0);
  }
  
#line 493 
  __retres = (void *)0;
  return_label: 
#line 493 
                return __retres;
}


#line 498  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_random_allocationless_scenario_13(void *arg0)
{
  void *__retres;
  struct ethtool_cmd *ldv_13_ldv_param_1_40;
  unsigned long long *ldv_13_ldv_param_2_17;
  void *ldv_13_ldv_param_1_14;
  struct rtnl_link_stats64 *ldv_13_ldv_param_1_4;
  struct ethtool_coalesce *ldv_13_ldv_param_1_44;
  struct ethtool_pauseparam *ldv_13_ldv_param_1_26;
  unsigned int ldv_13_ldv_param_1_30;
  struct sk_buff *ldv_13_ldv_param_0_13;
  struct ethtool_test *ldv_13_ldv_param_1_16;
  struct ethtool_eeprom *ldv_13_ldv_param_1_28;
  int ldv_13_ldv_param_2_19;
  struct ethtool_channels *ldv_13_ldv_param_1_33;
  struct ethtool_rxnfc *ldv_13_ldv_param_1_21;
  unsigned long long ldv_13_ldv_param_1_35;
  struct ethtool_eee *ldv_13_ldv_param_1_32;
  unsigned int *ldv_13_ldv_param_1_37;
  struct ethtool_channels *ldv_13_ldv_param_1_36;
  void *ldv_13_ldv_param_2_46;
  struct net_device *ldv_13_container;
  unsigned int *ldv_13_ldv_param_2_22;
  unsigned char *ldv_13_ldv_param_3_25;
  unsigned char *ldv_13_ldv_param_2_29;
  enum ethtool_phys_id_state *ldv_13_ldv_param_1_3;
  unsigned char *ldv_13_ldv_param_2_10;
  int ldv_13_ldv_param_1_15;
  unsigned long long ldv_13_ldv_param_1_34;
  unsigned char *ldv_13_ldv_param_2_24;
  struct ethtool_drvinfo *ldv_13_ldv_param_1_8;
  unsigned char *ldv_13_ldv_param_2_42;
  struct ethtool_ts_info *ldv_13_ldv_param_1_47;
  struct ethtool_cmd *ldv_13_ldv_param_1_2;
  struct ethtool_regs *ldv_13_ldv_param_1_45;
  struct ethtool_stats *ldv_13_ldv_param_1_5;
  struct ethtool_eee *ldv_13_ldv_param_1_11;
  struct ethtool_wolinfo *ldv_13_ldv_param_1_43;
  struct ethtool_coalesce *ldv_13_ldv_param_1_48;
  struct ethtool_pauseparam *ldv_13_ldv_param_1_27;
  unsigned int *ldv_13_ldv_param_1_23;
  struct ifreq *ldv_13_ldv_param_1_18;
  struct ethtool_wolinfo *ldv_13_ldv_param_1_20;
  struct ethtool_ringparam *ldv_13_ldv_param_1_12;
  unsigned int ldv_13_ldv_param_1_41;
  int ldv_13_ldv_param_1_7;
  struct ethtool_ringparam *ldv_13_ldv_param_1_31;
  struct ethtool_eeprom *ldv_13_ldv_param_1_9;
  unsigned char ldv_13_ldv_param_3_39;
  unsigned char *ldv_13_ldv_param_2_38;
  unsigned long long *ldv_13_ldv_param_2_6;
  int tmp_37;
  
#line 550 
  struct ldv_struct_random_allocationless_scenario_13 *data = (struct ldv_struct_random_allocationless_scenario_13 *)arg0;
  
#line 555 
  if (data != (struct ldv_struct_random_allocationless_scenario_13 *)0) {
    
#line 556 
    ldv_13_container = data->arg0;
    
#line 557 
    ldv_free((void *)data);
  }
  else ;
  
#line 565 
  goto ldv_call_13;
  
#line 567 
  __retres = (void *)0;
  
#line 567 
  goto return_label;
  ldv_call_13: 
#line 570 
  ;
  
#line 573 
  tmp_37 = ldv_undef_int();
  
#line 573 
  if (tmp_37 != 0) {
    int tmp_0;
    
#line 575 
    ldv_13_ldv_param_1_2 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
    
#line 578 
    tmp_0 = ldv_undef_int();
    
#line 578 
    switch (tmp_0) {
      case 1: 
#line 579 
      ;
      
#line 582 
      ldv_emg_wrapper_tg3_set_settings_2(ldv_13_container,ldv_13_ldv_param_1_2);
      
#line 585 
      goto ldv_44915;
      case 2: 
#line 587 
      ;
      
#line 590 
      ldv_emg_wrapper_tg3_get_eeprom_len_46(ldv_13_container);
      
#line 593 
      goto ldv_44915;
      case 3: 
#line 595 
      ;
      
#line 598 
      ldv_emg_wrapper_tg3_poll_controller_45(ldv_13_container);
      
#line 601 
      goto ldv_44915;
      case 4: 
#line 603 
      ;
      
#line 606 
      ldv_emg_wrapper_tg3_set_rx_mode_23(ldv_13_container);
      
#line 609 
      goto ldv_44915;
      case 5: 
#line 611 
      ;
      
#line 613 
      ldv_13_ldv_param_1_48 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 618 
      ldv_emg_wrapper_tg3_set_coalesce_43(ldv_13_container,ldv_13_ldv_param_1_48);
      
#line 622 
      ldv_free((void *)ldv_13_ldv_param_1_48);
      
#line 625 
      goto ldv_44915;
      case 6: 
#line 627 
      ;
      
#line 630 
      ldv_emg_wrapper_tg3_get_regs_len_42(ldv_13_container);
      
#line 633 
      goto ldv_44915;
      case 7: 
#line 635 
      ;
      
#line 637 
      ldv_13_ldv_param_1_47 = (struct ethtool_ts_info *)ldv_xmalloc_unknown_size(0UL);
      
#line 642 
      ldv_emg_wrapper_tg3_get_ts_info_28(ldv_13_container,ldv_13_ldv_param_1_47);
      
#line 646 
      ldv_free((void *)ldv_13_ldv_param_1_47);
      
#line 649 
      goto ldv_44915;
      case 8: 
#line 651 
      ;
      
#line 654 
      ldv_emg_wrapper_tg3_tx_timeout_40(ldv_13_container);
      
#line 657 
      goto ldv_44915;
      case 9: 
#line 659 
      ;
      
#line 661 
      ldv_13_ldv_param_2_46 = ldv_xmalloc_unknown_size(0UL);
      
#line 662 
      ldv_13_ldv_param_1_45 = (struct ethtool_regs *)ldv_xmalloc_unknown_size(0UL);
      
#line 667 
      ldv_emg_wrapper_tg3_get_regs_39(ldv_13_container,ldv_13_ldv_param_1_45,ldv_13_ldv_param_2_46);
      
#line 671 
      ldv_free(ldv_13_ldv_param_2_46);
      
#line 672 
      ldv_free((void *)ldv_13_ldv_param_1_45);
      
#line 675 
      goto ldv_44915;
      case 10: 
#line 677 
      ;
      
#line 679 
      ldv_13_ldv_param_1_44 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 684 
      ldv_emg_wrapper_tg3_get_coalesce_38(ldv_13_container,ldv_13_ldv_param_1_44);
      
#line 688 
      ldv_free((void *)ldv_13_ldv_param_1_44);
      
#line 691 
      goto ldv_44915;
      case 11: 
#line 693 
      ;
      
#line 695 
      ldv_13_ldv_param_1_43 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 700 
      ldv_emg_wrapper_tg3_get_wol_37(ldv_13_container,ldv_13_ldv_param_1_43);
      
#line 704 
      ldv_free((void *)ldv_13_ldv_param_1_43);
      
#line 707 
      goto ldv_44915;
      case 12: 
#line 709 
      ;
      
#line 711 
      ldv_13_ldv_param_2_42 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 716 
      ldv_emg_wrapper_tg3_get_strings_41(ldv_13_container,ldv_13_ldv_param_1_41,ldv_13_ldv_param_2_42);
      
#line 720 
      ldv_free((void *)ldv_13_ldv_param_2_42);
      
#line 723 
      goto ldv_44915;
      case 13: 
#line 725 
      ;
      
#line 727 
      ldv_13_ldv_param_1_40 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 732 
      ldv_emg_wrapper_tg3_get_settings_36(ldv_13_container,ldv_13_ldv_param_1_40);
      
#line 736 
      ldv_free((void *)ldv_13_ldv_param_1_40);
      
#line 739 
      goto ldv_44915;
      case 14: 
#line 741 
      ;
      
#line 743 
      ldv_13_ldv_param_1_37 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 744 
      ldv_13_ldv_param_2_38 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 749 
      ldv_emg_wrapper_tg3_set_rxfh_10(ldv_13_container,ldv_13_ldv_param_1_37,ldv_13_ldv_param_2_38,(unsigned char)((int)ldv_13_ldv_param_3_39));
      
#line 753 
      ldv_free((void *)ldv_13_ldv_param_1_37);
      
#line 754 
      ldv_free((void *)ldv_13_ldv_param_2_38);
      
#line 757 
      goto ldv_44915;
      case 15: 
#line 759 
      ;
      
#line 761 
      ldv_13_ldv_param_1_36 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
      
#line 766 
      ldv_emg_wrapper_tg3_set_channels_33(ldv_13_container,ldv_13_ldv_param_1_36);
      
#line 770 
      ldv_free((void *)ldv_13_ldv_param_1_36);
      
#line 773 
      goto ldv_44915;
      case 16: 
#line 775 
      ;
      
#line 781 
      ldv_emg_wrapper_tg3_fix_features_32(ldv_13_container,ldv_13_ldv_param_1_35);
      
#line 787 
      goto ldv_44915;
      case 17: 
#line 789 
      ;
      
#line 795 
      ldv_emg_wrapper_tg3_set_features_31(ldv_13_container,ldv_13_ldv_param_1_34);
      
#line 801 
      goto ldv_44915;
      case 18: 
#line 803 
      ;
      
#line 805 
      ldv_13_ldv_param_1_33 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
      
#line 810 
      ldv_emg_wrapper_tg3_get_channels_29(ldv_13_container,ldv_13_ldv_param_1_33);
      
#line 814 
      ldv_free((void *)ldv_13_ldv_param_1_33);
      
#line 817 
      goto ldv_44915;
      case 19: 
#line 819 
      ;
      
#line 821 
      ldv_13_ldv_param_1_32 = (struct ethtool_eee *)ldv_xmalloc_unknown_size(0UL);
      
#line 826 
      ldv_emg_wrapper_tg3_set_eee_34(ldv_13_container,ldv_13_ldv_param_1_32);
      
#line 830 
      ldv_free((void *)ldv_13_ldv_param_1_32);
      
#line 833 
      goto ldv_44915;
      case 20: 
#line 835 
      ;
      
#line 837 
      ldv_13_ldv_param_1_31 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 842 
      ldv_emg_wrapper_tg3_get_ringparam_20(ldv_13_container,ldv_13_ldv_param_1_31);
      
#line 846 
      ldv_free((void *)ldv_13_ldv_param_1_31);
      
#line 849 
      goto ldv_44915;
      case 21: 
#line 851 
      ;
      
#line 857 
      ldv_emg_wrapper_tg3_set_msglevel_44(ldv_13_container,ldv_13_ldv_param_1_30);
      
#line 863 
      goto ldv_44915;
      case 22: 
#line 865 
      ;
      
#line 868 
      ldv_emg_wrapper_tg3_get_rxfh_indir_size_27(ldv_13_container);
      
#line 871 
      goto ldv_44915;
      case 23: 
#line 873 
      ;
      
#line 876 
      (*ldv_emg_alias_ethtool_op_get_link_26)(ldv_13_container);
      
#line 879 
      goto ldv_44915;
      case 24: 
#line 881 
      ;
      
#line 883 
      ldv_13_ldv_param_2_29 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 884 
      ldv_13_ldv_param_1_28 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
      
#line 889 
      ldv_emg_wrapper_tg3_get_eeprom_25(ldv_13_container,ldv_13_ldv_param_1_28,ldv_13_ldv_param_2_29);
      
#line 893 
      ldv_free((void *)ldv_13_ldv_param_2_29);
      
#line 894 
      ldv_free((void *)ldv_13_ldv_param_1_28);
      
#line 897 
      goto ldv_44915;
      case 25: 
#line 899 
      ;
      
#line 901 
      ldv_13_ldv_param_1_27 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 906 
      ldv_emg_wrapper_tg3_get_pauseparam_24(ldv_13_container,ldv_13_ldv_param_1_27);
      
#line 910 
      ldv_free((void *)ldv_13_ldv_param_1_27);
      
#line 913 
      goto ldv_44915;
      case 26: 
#line 915 
      ;
      
#line 917 
      ldv_13_ldv_param_1_26 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 922 
      ldv_emg_wrapper_tg3_set_pauseparam_35(ldv_13_container,ldv_13_ldv_param_1_26);
      
#line 926 
      ldv_free((void *)ldv_13_ldv_param_1_26);
      
#line 929 
      goto ldv_44915;
      case 27: 
#line 931 
      ;
      
#line 934 
      ldv_emg_wrapper_tg3_nway_reset_22(ldv_13_container);
      
#line 937 
      goto ldv_44915;
      case 28: 
#line 939 
      ;
      
#line 941 
      ldv_13_ldv_param_1_23 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 942 
      ldv_13_ldv_param_2_24 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 943 
      ldv_13_ldv_param_3_25 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 948 
      ldv_emg_wrapper_tg3_get_rxfh_21(ldv_13_container,ldv_13_ldv_param_1_23,ldv_13_ldv_param_2_24,ldv_13_ldv_param_3_25);
      
#line 952 
      ldv_free((void *)ldv_13_ldv_param_1_23);
      
#line 953 
      ldv_free((void *)ldv_13_ldv_param_2_24);
      
#line 954 
      ldv_free((void *)ldv_13_ldv_param_3_25);
      
#line 957 
      goto ldv_44915;
      case 29: 
#line 959 
      ;
      
#line 961 
      ldv_13_ldv_param_1_21 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
      
#line 962 
      ldv_13_ldv_param_2_22 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 967 
      ldv_emg_wrapper_tg3_get_rxnfc_19(ldv_13_container,ldv_13_ldv_param_1_21,ldv_13_ldv_param_2_22);
      
#line 971 
      ldv_free((void *)ldv_13_ldv_param_1_21);
      
#line 972 
      ldv_free((void *)ldv_13_ldv_param_2_22);
      
#line 975 
      goto ldv_44915;
      case 30: 
#line 977 
      ;
      
#line 979 
      ldv_13_ldv_param_1_20 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 984 
      ldv_emg_wrapper_tg3_set_wol_18(ldv_13_container,ldv_13_ldv_param_1_20);
      
#line 988 
      ldv_free((void *)ldv_13_ldv_param_1_20);
      
#line 991 
      goto ldv_44915;
      case 31: 
#line 993 
      ;
      
#line 996 
      (*ldv_emg_alias_eth_validate_addr_30)(ldv_13_container);
      
#line 999 
      goto ldv_44915;
      case 32: 
#line 1001 
      ;
      
#line 1003 
      ldv_13_ldv_param_1_18 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
      
#line 1008 
      ldv_emg_wrapper_tg3_ioctl_17(ldv_13_container,ldv_13_ldv_param_1_18,ldv_13_ldv_param_2_19);
      
#line 1012 
      ldv_free((void *)ldv_13_ldv_param_1_18);
      
#line 1015 
      goto ldv_44915;
      case 33: 
#line 1017 
      ;
      
#line 1019 
      ldv_13_ldv_param_1_16 = (struct ethtool_test *)ldv_xmalloc_unknown_size(0UL);
      
#line 1020 
      ldv_13_ldv_param_2_17 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1025 
      ldv_emg_wrapper_tg3_self_test_16(ldv_13_container,ldv_13_ldv_param_1_16,ldv_13_ldv_param_2_17);
      
#line 1029 
      ldv_free((void *)ldv_13_ldv_param_1_16);
      
#line 1030 
      ldv_free((void *)ldv_13_ldv_param_2_17);
      
#line 1033 
      goto ldv_44915;
      case 34: 
#line 1035 
      ;
      
#line 1041 
      ldv_emg_wrapper_tg3_get_sset_count_15(ldv_13_container,ldv_13_ldv_param_1_15);
      
#line 1047 
      goto ldv_44915;
      case 35: 
#line 1049 
      ;
      
#line 1051 
      ldv_13_ldv_param_1_14 = ldv_xmalloc_unknown_size(0UL);
      
#line 1056 
      ldv_emg_wrapper_tg3_set_mac_addr_14(ldv_13_container,ldv_13_ldv_param_1_14);
      
#line 1060 
      ldv_free(ldv_13_ldv_param_1_14);
      
#line 1063 
      goto ldv_44915;
      case 36: 
#line 1065 
      ;
      
#line 1067 
      ldv_13_ldv_param_0_13 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
      
#line 1072 
      ldv_emg_wrapper_tg3_start_xmit_13(ldv_13_ldv_param_0_13,ldv_13_container);
      
#line 1076 
      ldv_free((void *)ldv_13_ldv_param_0_13);
      
#line 1079 
      goto ldv_44915;
      case 37: 
#line 1081 
      ;
      
#line 1084 
      ldv_emg_wrapper_tg3_get_msglevel_12(ldv_13_container);
      
#line 1087 
      goto ldv_44915;
      case 38: 
#line 1089 
      ;
      
#line 1091 
      ldv_13_ldv_param_1_12 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 1096 
      ldv_emg_wrapper_tg3_set_ringparam_11(ldv_13_container,ldv_13_ldv_param_1_12);
      
#line 1100 
      ldv_free((void *)ldv_13_ldv_param_1_12);
      
#line 1103 
      goto ldv_44915;
      case 39: 
#line 1105 
      ;
      
#line 1107 
      ldv_13_ldv_param_1_11 = (struct ethtool_eee *)ldv_xmalloc_unknown_size(0UL);
      
#line 1112 
      ldv_emg_wrapper_tg3_get_eee_9(ldv_13_container,ldv_13_ldv_param_1_11);
      
#line 1116 
      ldv_free((void *)ldv_13_ldv_param_1_11);
      
#line 1119 
      goto ldv_44915;
      case 40: 
#line 1121 
      ;
      
#line 1123 
      ldv_13_ldv_param_1_9 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
      
#line 1124 
      ldv_13_ldv_param_2_10 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1129 
      ldv_emg_wrapper_tg3_set_eeprom_8(ldv_13_container,ldv_13_ldv_param_1_9,ldv_13_ldv_param_2_10);
      
#line 1133 
      ldv_free((void *)ldv_13_ldv_param_1_9);
      
#line 1134 
      ldv_free((void *)ldv_13_ldv_param_2_10);
      
#line 1137 
      goto ldv_44915;
      case 41: 
#line 1139 
      ;
      
#line 1141 
      ldv_13_ldv_param_1_8 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 1146 
      ldv_emg_wrapper_tg3_get_drvinfo_7(ldv_13_container,ldv_13_ldv_param_1_8);
      
#line 1150 
      ldv_free((void *)ldv_13_ldv_param_1_8);
      
#line 1153 
      goto ldv_44915;
      case 42: 
#line 1155 
      ;
      
#line 1161 
      ldv_emg_wrapper_tg3_change_mtu_6(ldv_13_container,ldv_13_ldv_param_1_7);
      
#line 1167 
      goto ldv_44915;
      case 43: 
#line 1169 
      ;
      
#line 1171 
      ldv_13_ldv_param_2_6 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1172 
      ldv_13_ldv_param_1_5 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
      
#line 1177 
      ldv_emg_wrapper_tg3_get_ethtool_stats_5(ldv_13_container,ldv_13_ldv_param_1_5,ldv_13_ldv_param_2_6);
      
#line 1181 
      ldv_free((void *)ldv_13_ldv_param_2_6);
      
#line 1182 
      ldv_free((void *)ldv_13_ldv_param_1_5);
      
#line 1185 
      goto ldv_44915;
      case 44: 
#line 1187 
      ;
      
#line 1189 
      ldv_13_ldv_param_1_4 = (struct rtnl_link_stats64 *)ldv_xmalloc_unknown_size(0UL);
      
#line 1194 
      ldv_emg_wrapper_tg3_get_stats64_4(ldv_13_container,ldv_13_ldv_param_1_4);
      
#line 1198 
      ldv_free((void *)ldv_13_ldv_param_1_4);
      
#line 1201 
      goto ldv_44915;
      case 45: 
#line 1203 
      ;
      
#line 1205 
      ldv_13_ldv_param_1_3 = (enum ethtool_phys_id_state *)ldv_xmalloc_unknown_size(0UL);
      
#line 1210 
      ldv_emg_wrapper_tg3_set_phys_id_3(ldv_13_container,*ldv_13_ldv_param_1_3);
      
#line 1214 
      ldv_free((void *)ldv_13_ldv_param_1_3);
      
#line 1217 
      goto ldv_44915;
      default: 
#line 1219 
      ;
      
#line 1219 
      __VERIFIER_assume(0);
    }
    ldv_44915: 
#line 1222 
    ;
    
#line 1222 
    ldv_free((void *)ldv_13_ldv_param_1_2);
    
#line 1229 
    goto ldv_call_13;
  }
  else {
    
#line 1237 
    __retres = (void *)0;
    
#line 1237 
    goto return_label;
  }
  
#line 1240 
  __retres = (void *)0;
  return_label: 
#line 1240 
                return __retres;
}


#line 1245  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_schedule_work(struct work_struct *arg0)
{
  _Bool __retres;
  struct work_struct *ldv_7_work_struct;
  int tmp;
  
#line 1252 
  tmp = ldv_undef_int();
  
#line 1252 
  if (tmp != 0) {
    
#line 1254 
    ldv_7_work_struct = arg0;
    
#line 1258 
    if (ldv_7_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 1260 
      (*(ldv_7_work_struct->func))(ldv_7_work_struct); else ;
    
#line 1265 
    __retres = (_Bool)1;
    
#line 1265 
    goto return_label;
  }
  else {
    
#line 1272 
    __retres = (_Bool)0;
    
#line 1272 
    goto return_label;
  }
  return_label: 
#line 1252 
                return __retres;
}


#line 1282  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_9_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_14 *cf_arg_14;
  int tmp;
  
#line 1285 
  tmp = ldv_undef_int();
  
#line 1285 
  switch (tmp) {
    case 0: 
#line 1286 
    ;
    
#line 1287 
    ret = pthread_join(ldv_thread_14,(void **)0);
    
#line 1288 
    __VERIFIER_assume(ret == 0);
    
#line 1289 
    goto ldv_44971;
    default: 
#line 1291 
    ;
    
#line 1291 
    __VERIFIER_assume(0);
  }
  ldv_44971: 
#line 1292 
  ;
  
#line 1293 
  return;
}


#line 1297  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 1304 
  ldv_1_ret = ldv_emg_tg3_driver_init();
  
#line 1305 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 1308 
  tmp = ldv_undef_int();
  
#line 1308 
  if (tmp != 0) {
    
#line 1310 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 1314 
    __retres = (void *)0;
    
#line 1314 
    goto return_label;
  }
  else {
    
#line 1318 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 1323 
    ldv_emg_tg3_driver_exit();
    
#line 1327 
    __retres = (void *)0;
    
#line 1327 
    goto return_label;
  }
  
#line 1330 
  __retres = (void *)0;
  return_label: 
#line 1330 
                return __retres;
}


#line 1335  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pm_ops_scenario_12(void *arg0)
{
  void *__retres;
  struct device *ldv_12_device;
  int tmp;
  
#line 1338 
  struct dev_pm_ops *ldv_12_pm_ops = ldv_emg_alias_tg3_pm_ops_3;
  
#line 1349 
  goto ldv_do_12;
  
#line 1351 
  __retres = (void *)0;
  
#line 1351 
  goto return_label;
  ldv_do_12: 
#line 1354 
  ;
  
#line 1357 
  tmp = ldv_undef_int();
  
#line 1357 
  switch (tmp) {
    int tmp_0;
    case 1: 
#line 1358 
    ;
    
#line 1360 
    if (ldv_12_pm_ops->runtime_idle != (int (*)(struct device *))0) 
#line 1362 
                                                                    (*(ldv_12_pm_ops->runtime_idle))(ldv_12_device); else ;
    
#line 1370 
    goto ldv_do_12;
    case 2: 
#line 1373 
    ;
    
#line 1375 
    if (ldv_12_pm_ops->runtime_suspend != (int (*)(struct device *))0) 
      
#line 1377 
      (*(ldv_12_pm_ops->runtime_suspend))(ldv_12_device); else ;
    
#line 1382 
    if (ldv_12_pm_ops->runtime_resume != (int (*)(struct device *))0) 
      
#line 1384 
      (*(ldv_12_pm_ops->runtime_resume))(ldv_12_device); else ;
    
#line 1392 
    goto ldv_do_12;
    case 3: 
#line 1395 
    ;
    
#line 1397 
    if (ldv_12_pm_ops->prepare != (int (*)(struct device *))0) 
#line 1399 
                                                               (*(ldv_12_pm_ops->prepare))(ldv_12_device); else ;
    
#line 1403 
    tmp_0 = ldv_undef_int();
    
#line 1403 
    switch (tmp_0) {
      int tmp_1;
      int tmp_2;
      int tmp_3;
      case 1: 
#line 1404 
      ;
      
#line 1407 
      ldv_emg_wrapper_tg3_suspend_2(ldv_12_device);
      
#line 1410 
      tmp_1 = ldv_undef_int();
      
#line 1410 
      if (tmp_1 != 0) {
        
#line 1412 
        if (ldv_12_pm_ops->suspend_noirq != (int (*)(struct device *))0) 
          
#line 1414 
          (*(ldv_12_pm_ops->suspend_noirq))(ldv_12_device); else ;
        
#line 1419 
        if (ldv_12_pm_ops->resume_noirq != (int (*)(struct device *))0) 
          
#line 1421 
          (*(ldv_12_pm_ops->resume_noirq))(ldv_12_device); else ;
      }
      else {
        
#line 1428 
        if (ldv_12_pm_ops->suspend_late != (int (*)(struct device *))0) 
          
#line 1430 
          (*(ldv_12_pm_ops->suspend_late))(ldv_12_device); else ;
        
#line 1435 
        if (ldv_12_pm_ops->resume_early != (int (*)(struct device *))0) 
          
#line 1437 
          (*(ldv_12_pm_ops->resume_early))(ldv_12_device); else ;
      }
      
#line 1444 
      ldv_emg_wrapper_tg3_resume_4(ldv_12_device);
      
#line 1447 
      goto ldv_44987;
      case 2: 
#line 1449 
      ;
      
#line 1452 
      ldv_emg_wrapper_tg3_suspend_2(ldv_12_device);
      
#line 1455 
      tmp_2 = ldv_undef_int();
      
#line 1455 
      if (tmp_2 != 0) {
        
#line 1457 
        if (ldv_12_pm_ops->freeze_late != (int (*)(struct device *))0) 
          
#line 1459 
          (*(ldv_12_pm_ops->freeze_late))(ldv_12_device); else ;
        
#line 1464 
        if (ldv_12_pm_ops->thaw_early != (int (*)(struct device *))0) 
          
#line 1466 
          (*(ldv_12_pm_ops->thaw_early))(ldv_12_device); else ;
      }
      else {
        
#line 1473 
        if (ldv_12_pm_ops->freeze_noirq != (int (*)(struct device *))0) 
          
#line 1475 
          (*(ldv_12_pm_ops->freeze_noirq))(ldv_12_device); else ;
        
#line 1480 
        if (ldv_12_pm_ops->thaw_noirq != (int (*)(struct device *))0) 
          
#line 1482 
          (*(ldv_12_pm_ops->thaw_noirq))(ldv_12_device); else ;
      }
      
#line 1489 
      ldv_emg_wrapper_tg3_resume_4(ldv_12_device);
      
#line 1492 
      goto ldv_44987;
      case 3: 
#line 1494 
      ;
      
#line 1497 
      ldv_emg_wrapper_tg3_suspend_2(ldv_12_device);
      
#line 1500 
      tmp_3 = ldv_undef_int();
      
#line 1500 
      if (tmp_3 != 0) {
        
#line 1502 
        if (ldv_12_pm_ops->poweroff_late != (int (*)(struct device *))0) 
          
#line 1504 
          (*(ldv_12_pm_ops->poweroff_late))(ldv_12_device); else ;
        
#line 1509 
        if (ldv_12_pm_ops->restore_early != (int (*)(struct device *))0) 
          
#line 1511 
          (*(ldv_12_pm_ops->restore_early))(ldv_12_device); else ;
      }
      else {
        
#line 1518 
        if (ldv_12_pm_ops->poweroff_noirq != (int (*)(struct device *))0) 
          
#line 1520 
          (*(ldv_12_pm_ops->poweroff_noirq))(ldv_12_device); else ;
        
#line 1525 
        if (ldv_12_pm_ops->restore_noirq != (int (*)(struct device *))0) 
          
#line 1527 
          (*(ldv_12_pm_ops->restore_noirq))(ldv_12_device); else ;
      }
      
#line 1534 
      ldv_emg_wrapper_tg3_resume_4(ldv_12_device);
      
#line 1537 
      goto ldv_44987;
      default: 
#line 1539 
      ;
      
#line 1539 
      __VERIFIER_assume(0);
    }
    ldv_44987: 
#line 1542 
    ;
    
#line 1542 
    if (ldv_12_pm_ops->complete != (void (*)(struct device *))0) 
#line 1544 
                                                                 (*(ldv_12_pm_ops->complete))(ldv_12_device); else ;
    
#line 1552 
    goto ldv_do_12;
    case 4: 
#line 1555 
    ;
    
#line 1561 
    __retres = (void *)0;
    
#line 1561 
    goto return_label;
    default: 
#line 1564 
    ;
    
#line 1564 
    __VERIFIER_assume(0);
  }
  
#line 1567 
  __retres = (void *)0;
  return_label: 
#line 1567 
                return __retres;
}


#line 1572  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_timer_scenario_16(void *arg0)
{
  void *__retres;
  struct timer_list *ldv_16_container;
  
#line 1582 
  if (ldv_16_container->function != (void (*)(unsigned long ))0) {
    
#line 1584 
    ldv_switch_to_interrupt_context();
    
#line 1586 
    (*(ldv_16_container->function))(ldv_16_container->data);
    
#line 1588 
    ldv_switch_to_process_context();
  }
  else ;
  
#line 1597 
  __retres = (void *)0;
  
#line 1597 
  goto return_label;
  
#line 1599 
  __retres = (void *)0;
  return_label: 
#line 1599 
                return __retres;
}


#line 1604  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_15(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_15_ret_val;
  int ldv_15_line;
  void *ldv_15_data;
  enum irqreturn (*ldv_15_thread)(int , void *);
  int tmp;
  
#line 1610 
  enum irqreturn (*ldv_15_callback)(int , void *) = & ldv_emg_wrapper_tg3_test_isr_2;
  
#line 1613 
  struct ldv_struct_interrupt_scenario_15 *data = (struct ldv_struct_interrupt_scenario_15 *)arg0;
  
#line 1618 
  if (data != (struct ldv_struct_interrupt_scenario_15 *)0) {
    
#line 1619 
    ldv_15_line = data->arg0;
    
#line 1620 
    ldv_15_callback = data->arg1;
    
#line 1621 
    ldv_15_thread = data->arg2;
    
#line 1622 
    ldv_15_data = data->arg3;
    
#line 1623 
    ldv_free((void *)data);
  }
  else ;
  
#line 1629 
  ldv_switch_to_interrupt_context();
  
#line 1631 
  ldv_15_ret_val = ldv_emg_wrapper_tg3_test_isr_2(ldv_15_line,ldv_15_data);
  
#line 1633 
  ldv_switch_to_process_context();
  
#line 1636 
  tmp = ldv_undef_int();
  
#line 1636 
  if (tmp != 0) {
    
#line 1638 
    __VERIFIER_assume(ldv_15_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 1642 
    if (ldv_15_thread != (enum irqreturn (*)(int , void *))0) 
#line 1644 
                                                              (*ldv_15_thread)(ldv_15_line,ldv_15_data); else ;
  }
  else 
#line 1651 
       __VERIFIER_assume(ldv_15_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 1660 
  __retres = (void *)0;
  
#line 1660 
  goto return_label;
  
#line 1662 
  __retres = (void *)0;
  return_label: 
#line 1662 
                return __retres;
}


#line 1667  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 1670 
  struct pci_driver *ldv_9_pci_driver = ldv_emg_alias_tg3_driver_2;
  
#line 1673 
  ldv_9_pci_driver = arg0;
  
#line 1677 
  ldv_dispatch_deregister_9_1(ldv_9_pci_driver);
  
#line 1681 
  goto return_label;
  return_label: 
#line 1683 
                return;
}


#line 1688  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_10_4(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_13 *cf_arg_13;
  int tmp;
  
#line 1691 
  tmp = ldv_undef_int();
  
#line 1691 
  switch (tmp) {
    case 0: 
#line 1692 
    ;
    
#line 1693 
    cf_arg_13 = (struct ldv_struct_random_allocationless_scenario_13 *)ldv_xmalloc(16UL);
    
#line 1694 
    cf_arg_13->arg0 = arg0;
    
#line 1695 
    ret = pthread_create(& ldv_thread_13,(pthread_attr_t const *)0,& ldv_random_allocationless_scenario_13,(void *)cf_arg_13);
    
#line 1696 
    __VERIFIER_assume(ret == 0);
    
#line 1697 
    goto ldv_45020;
    default: 
#line 1699 
    ;
    
#line 1699 
    __VERIFIER_assume(0);
  }
  ldv_45020: 
#line 1700 
  ;
  
#line 1701 
  return;
}


#line 1705  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_unregister_netdev(struct net_device *arg0)
{
  struct net_device *ldv_5_netdev;
  
#line 1711 
  ldv_5_netdev = arg0;
  
#line 1716 
  ldv_emg_wrapper_tg3_close_2(ldv_5_netdev);
  
#line 1720 
  ldv_dispatch_deregister_5_1(ldv_5_netdev);
  
#line 1724 
  goto return_label;
  return_label: 
#line 1726 
                return;
}


#line 1731  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_3_line;
  
#line 1737 
  ldv_3_line = (int)arg0;
  
#line 1741 
  ldv_dispatch_irq_deregister_3_1(ldv_3_line);
  
#line 1745 
  goto return_label;
  return_label: 
#line 1747 
                return;
}


#line 1752  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_11_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_15 *cf_arg_15;
  int tmp;
  
#line 1755 
  tmp = ldv_undef_int();
  
#line 1755 
  switch (tmp) {
    case 0: 
#line 1756 
    ;
    
#line 1757 
    cf_arg_15 = (struct ldv_struct_interrupt_scenario_15 *)ldv_xmalloc(32UL);
    
#line 1758 
    cf_arg_15->arg0 = arg0;
    
#line 1759 
    cf_arg_15->arg1 = arg1;
    
#line 1760 
    cf_arg_15->arg2 = arg2;
    
#line 1761 
    cf_arg_15->arg3 = arg3;
    
#line 1762 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_interrupt_scenario_15,(void *)cf_arg_15);
    
#line 1763 
    __VERIFIER_assume(ret == 0);
    
#line 1764 
    goto ldv_45044;
    default: 
#line 1766 
    ;
    
#line 1766 
    __VERIFIER_assume(0);
  }
  ldv_45044: 
#line 1767 
  ;
  
#line 1768 
  return;
}


#line 1772  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_6_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_14 *cf_arg_14;
  int tmp;
  
#line 1775 
  tmp = ldv_undef_int();
  
#line 1775 
  switch (tmp) {
    case 0: 
#line 1776 
    ;
    
#line 1777 
    cf_arg_14 = (struct ldv_struct_pci_scenario_14 *)ldv_xmalloc(16UL);
    
#line 1778 
    cf_arg_14->arg0 = arg0;
    
#line 1779 
    ret = pthread_create(& ldv_thread_14,(pthread_attr_t const *)0,& ldv_pci_scenario_14,(void *)cf_arg_14);
    
#line 1780 
    __VERIFIER_assume(ret == 0);
    
#line 1781 
    goto ldv_45052;
    default: 
#line 1783 
    ;
    
#line 1783 
    __VERIFIER_assume(0);
  }
  ldv_45052: 
#line 1784 
  ;
  
#line 1785 
  return;
}


#line 1789  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_netdev(struct net_device *arg0)
{
  struct net_device *ldv_2_netdev;
  
#line 1795 
  ldv_2_netdev = arg0;
  
#line 1796 
  ldv_free((void *)ldv_2_netdev);
  
#line 1800 
  goto return_label;
  return_label: 
#line 1802 
                return;
}


#line 1807  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/broadcom/tg3.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_register_netdev(struct net_device *arg0)
{
  int __retres;
  struct net_device *ldv_10_netdev;
  int tmp_3;
  
#line 1811 
  int ldv_10_ret = ldv_undef_int();
  
#line 1814 
  ldv_10_ret = ldv_undef_int();
  
#line 1817 
  tmp_3 = ldv_undef_int();
  
#line 1817 
  if (tmp_3 != 0) {
    int tmp_1;
    
#line 1819 
    ldv_10_netdev = arg0;
    
#line 1824 
    ldv_10_ret = ldv_emg_wrapper_tg3_open_2(ldv_10_netdev);
    
#line 1827 
    tmp_1 = ldv_undef_int();
    
#line 1827 
    if (tmp_1 != 0) {
      
#line 1829 
      __VERIFIER_assume(ldv_10_ret == 0);
      
#line 1833 
      ldv_dispatch_register_10_4(ldv_10_netdev);
      
#line 1837 
      __retres = 0;
      
#line 1837 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 1844 
      __VERIFIER_assume(ldv_10_ret != 0);
      
#line 1845 
      ldv_failed_register_netdev();
      
#line 1846 
      tmp_0 = ldv_undef_int_negative();
      
#line 1846 
      __retres = tmp_0;
      
#line 1846 
      goto return_label;
    }
  }
  else {
    int tmp_2;
    
#line 1854 
    ldv_failed_register_netdev();
    
#line 1855 
    tmp_2 = ldv_undef_int_negative();
    
#line 1855 
    __retres = tmp_2;
    
#line 1855 
    goto return_label;
  }
  return_label: 
#line 1817 
                return __retres;
}


