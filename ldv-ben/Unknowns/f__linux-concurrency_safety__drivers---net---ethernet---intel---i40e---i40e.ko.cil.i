/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __le16;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u64 __le64;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
struct module;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104 
struct pollfd;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/paravirt.h"
struct static_key;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
typedef int pao_T__;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 59 
struct static_key_mod;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
   struct jump_entry *entries ;
   struct static_key_mod *next ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct hlist_bl_node;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_53 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_52 {
   struct __anonstruct_53 __anonCompField___anonunion_52_19 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_52 __anonCompField_lockref_20 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct path;

#line 51 
struct vfsmount;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_55 {
   u32 hash ;
   u32 len ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_54 {
   struct __anonstruct_55 __anonCompField___anonunion_54_21 ;
   u64 hash_len ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_54 __anonCompField_qstr_22 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct inode;

#line 90 
struct dentry_operations;

#line 90 
struct super_block;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_56 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_56 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_59 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_59 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_60 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_60 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_61 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_61 nodemask_t;

#line 520 
struct mem_cgroup;

#line 520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 189 
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_63 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_62 {
   struct __anonstruct_63 __anonCompField___anonunion_62_23 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_62 __anonCompField_radix_tree_node_24 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 97 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 104 
struct pid_namespace;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 209 
struct rw_semaphore;

#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 44 
struct vm_area_struct;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mpspec.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_132 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_131 {
   struct __anonstruct_132 __anonCompField___anonunion_131_25 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_131 __anonCompField_ctl_table_header_26 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_133 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_133 mm_context_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct block_device;

#line 32 
struct cgroup_subsys_state;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 64 
struct iovec;

#line 65 
struct kiocb;

#line 66 
struct kobject;

#line 67 
struct pipe_inode_info;

#line 68 
struct poll_table_struct;

#line 69 
struct kstatfs;

#line 70 
struct cred;

#line 71 
struct swap_info_struct;

#line 72 
struct iov_iter;

#line 73 
struct vm_fault;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_161 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_161 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_162 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_162 __anonCompField_kqid_38 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526 
struct address_space;

#line 527 
struct writeback_control;

#line 528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_165 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_166 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_167 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_165 __anonCompField_inode_39 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_166 __anonCompField_inode_40 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_167 __anonCompField_inode_41 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_168 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_168 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 947 
struct net;

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19 
struct fasync_struct;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_170 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_169 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_170 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_169 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1061 
struct files_struct;

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct file_system_type;

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 2251 
struct kmem_cache;

#line 3043  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_176 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_177 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_175 {
   struct __anonstruct_176 __anonCompField___anonunion_175_44 ;
   struct __anonstruct_177 __anonCompField___anonunion_175_45 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_175 __anonCompField_uprobe_task_46 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_178 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_180 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_184 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_183 {
   atomic_t _mapcount ;
   struct __anonstruct_184 __anonCompField___anonunion_183_49 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_182 {
   union __anonunion_183 __anonCompField___anonstruct_182_50 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_181 {
   unsigned long counters ;
   struct __anonstruct_182 __anonCompField___anonunion_181_51 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_179 {
   union __anonunion_180 __anonCompField___anonstruct_179_48 ;
   union __anonunion_181 __anonCompField___anonstruct_179_52 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_186 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_187 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_185 {
   struct list_head lru ;
   struct __anonstruct_186 __anonCompField___anonunion_185_54 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_187 __anonCompField___anonunion_185_55 ;
   pgtable_t pmd_huge_pte ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_188 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_178 __anonCompField_page_47 ;
   struct __anonstruct_179 __anonCompField_page_53 ;
   union __anonunion_185 __anonCompField_page_56 ;
   union __anonunion_188 __anonCompField_page_57 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_189 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct vm_operations_struct;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_189 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_191 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_191 __anonCompField_iov_iter_58 ;
   unsigned long nr_segs ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
enum ldv_16932 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_16932 socket_state;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct sock;

#line 93 
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_192 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_192 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_194 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_195 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_196 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_197 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_199 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_198 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_199 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_200 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_201 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_193 {
   int _pad[28U] ;
   struct __anonstruct__kill_194 _kill ;
   struct __anonstruct__timer_195 _timer ;
   struct __anonstruct__rt_196 _rt ;
   struct __anonstruct__sigchld_197 _sigchld ;
   struct __anonstruct__sigfault_198 _sigfault ;
   struct __anonstruct__sigpoll_200 _sigpoll ;
   struct __anonstruct__sigsys_201 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_193 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_204 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_205 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_207 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_206 {
   struct keyring_index_key index_key ;
   struct __anonstruct_207 __anonCompField___anonunion_206_61 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_208 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_210 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_209 {
   union __anonunion_payload_210 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_204 __anonCompField_key_59 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_205 __anonCompField_key_60 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_206 __anonCompField_key_62 ;
   union __anonunion_type_data_208 type_data ;
   union __anonunion_209 __anonCompField_key_63 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
union __anonunion_211 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_211 __anonCompField_idr_layer_64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 327 
struct cgroup;

#line 328 
struct cgroup_root;

#line 329 
struct cgroup_subsys;

#line 330 
struct cgroup_taskset;

#line 331 
struct kernfs_node;

#line 332 
struct kernfs_ops;

#line 333 
struct kernfs_open_file;

#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270 
struct kernfs_root;

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 134 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct reclaim_state;

#line 846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1172 
struct uts_namespace;

#line 1173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 176 
struct kernfs_open_node;

#line 177 
struct kernfs_iattrs;

#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_230 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_230 __anonCompField_kernfs_node_68 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 477 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject_ns.h"
struct bin_attribute;

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject_ns.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 67 
struct pinctrl;

#line 68 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dma_map_ops;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203 
struct of_device_id;

#line 203 
struct acpi_device_id;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 1283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_231 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_231 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_24280 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_236 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_237 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_24280 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_236 __anonCompField_nf_bridge_info_72 ;
   union __anonunion_237 __anonCompField_nf_bridge_info_73 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_240 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_239 {
   u64 v64 ;
   struct __anonstruct_240 __anonCompField___anonunion_239_74 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_239 __anonCompField_skb_mstamp_75 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_243 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_242 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_243 __anonCompField___anonstruct_242_76 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_241 {
   struct __anonstruct_242 __anonCompField___anonunion_241_77 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_245 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_244 {
   __wsum csum ;
   struct __anonstruct_245 __anonCompField___anonunion_244_79 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_246 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_247 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_248 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_241 __anonCompField_sk_buff_78 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_244 __anonCompField_sk_buff_80 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_246 __anonCompField_sk_buff_81 ;
   __u32 secmark ;
   union __anonunion_247 __anonCompField_sk_buff_82 ;
   union __anonunion_248 __anonCompField_sk_buff_83 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 767 
struct rtable;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqhandler.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 398  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irq.h"
struct proc_dir_entry;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
struct hlist_nulls_node;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_258 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_258 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_259 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_259 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_260 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_260 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_261 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_261 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_262 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_262 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_263 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_263 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_264 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_264 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_265 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_265 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_266 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_267 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_266 ifr_ifrn ;
   union __anonunion_ifr_ifru_267 ifr_ifru ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct inet_peer_base;

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_291 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_291 possible_net_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct of_phandle_args {
   struct device_node *np ;
   int args_count ;
   uint32_t args[16U] ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_28008 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_28008 phy_interface_t;

#line 126 
enum ldv_28061 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28061 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct xfrm_policy;

#line 98 
struct xfrm_state;

#line 114 
struct request_sock;

#line 1628 
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_304 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_305 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct inet6_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_306 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_304 adj_list ;
   struct __anonstruct_all_adj_list_305 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_306 __anonCompField_net_device_93 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/cacheflush.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) dst_reg : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
};

#line 273 
struct bpf_prog_aux;

#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
union __anonunion_317 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff const *, struct bpf_insn const *) ;
   union __anonunion_317 __anonCompField_bpf_prog_98 ;
};

#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   int maxtype ;
   struct nla_policy const *policy ;
   int (*validate)(struct nlattr **, struct nlattr **) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device const *) ;
   int (*fill_info)(struct sk_buff *, struct net_device const *) ;
   size_t (*get_xstats_size)(struct net_device const *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device const *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy const *slave_policy ;
   int (*slave_validate)(struct nlattr **, struct nlattr **) ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **) ;
   size_t (*get_slave_size)(struct net_device const *, struct net_device const *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device const *, struct net_device const *) ;
   struct net *(*get_link_net)(struct net_device const *) ;
};

#line 171 
struct neigh_table;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   void (*neigh_cleanup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};

#line 129 
struct neigh_ops;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops const *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const *, struct net_device const *, __u32 *) ;
   bool (*key_eq)(struct neighbour const *, void const *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};

#line 519 
struct dn_route;

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
union __anonunion_328 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_328 __anonCompField_dst_entry_99 ;
};

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_socket_lock_t_329 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_329 socket_lock_t;

#line 124 
struct proto;

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u32 __portpair;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u64 __addrpair;

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_331 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_330 {
   __addrpair skc_addrpair ;
   struct __anonstruct_331 __anonCompField___anonunion_330_100 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_332 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_334 {
   __be16 skc_dport ;
   __u16 skc_num ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_333 {
   __portpair skc_portpair ;
   struct __anonstruct_334 __anonCompField___anonunion_333_103 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_335 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_336 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock_common {
   union __anonunion_330 __anonCompField_sock_common_101 ;
   union __anonunion_332 __anonCompField_sock_common_102 ;
   union __anonunion_333 __anonCompField_sock_common_104 ;
   unsigned short skc_family ;
   unsigned char volatile skc_state ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) skc_reuse : 4 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_reuseport : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_ipv6only : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_335 __anonCompField_sock_common_105 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_336 __anonCompField_sock_common_106 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};

#line 219 
struct cg_proto;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_sk_backlog_337 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_337 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) sk_shutdown : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_tx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_rx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) sk_userlocks : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) sk_protocol : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred const *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
};

#line 914 
struct request_sock_ops;

#line 915 
struct timewait_sock_ops;

#line 916 
struct inet_hashinfo;

#line 917 
struct raw_hashinfo;

#line 932 
struct udp_table;

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_h_340 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   void (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   void (*clear_sk)(struct sock *, int ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock const *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_340 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup *, struct cgroup_subsys *) ;
   void (*destroy_cgroup)(struct mem_cgroup *) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup *) ;
};

#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock const *) ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cookie_ts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops const *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};

#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
union __anonunion_362 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_362 __anonCompField_inetpeer_addr_base_108 ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_363 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct __anonstruct_365 {
   atomic_t rid ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_364 {
   struct __anonstruct_365 __anonCompField___anonunion_364_110 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_363 __anonCompField_inet_peer_109 ;
   union __anonunion_364 __anonCompField_inet_peer_111 ;
   __u32 dtime ;
   atomic_t refcnt ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct uncached_list;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};

#line 317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/route.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   struct hlist_nulls_head head ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_listen_hashbucket listening_hash[32U] ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/udp.h"
struct udp_hslot {
   struct hlist_nulls_head head ;
   int count ;
   spinlock_t lock ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/udp.h"
struct udp_table {
   struct udp_hslot *hash ;
   struct udp_hslot *hash2 ;
   unsigned int mask ;
   unsigned int log ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct kernel_param;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_375 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_375 __anonCompField_kernel_param_115 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_382 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_382 __anonCompField_pci_dev_116 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmapool.h"
struct dma_pool;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/aer.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tracepoint.h"
struct tracepoint {
   char const *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tracepoint.h"
struct trace_enum_map {
   char const *system ;
   char const *enum_string ;
   unsigned long enum_value ;
};

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/trace/events/iommu.h"
struct iommu_domain;

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iommu.h"
struct iommu_domain_geometry {
   dma_addr_t aperture_start ;
   dma_addr_t aperture_end ;
   bool force_aperture ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iommu.h"
struct iommu_domain {
   unsigned int type ;
   struct iommu_ops const *ops ;
   int (*handler)(struct iommu_domain *, struct device *, unsigned long , int , void *) ;
   void *handler_token ;
   struct iommu_domain_geometry geometry ;
};

#line 85 
enum iommu_cap {
    IOMMU_CAP_CACHE_COHERENCY = 0,
    IOMMU_CAP_INTR_REMAP = 1,
    IOMMU_CAP_NOEXEC = 2
};

#line 91 
enum iommu_attr {
    DOMAIN_ATTR_GEOMETRY = 0,
    DOMAIN_ATTR_PAGING = 1,
    DOMAIN_ATTR_WINDOWS = 2,
    DOMAIN_ATTR_FSL_PAMU_STASH = 3,
    DOMAIN_ATTR_FSL_PAMU_ENABLE = 4,
    DOMAIN_ATTR_FSL_PAMUV1 = 5,
    DOMAIN_ATTR_NESTING = 6,
    DOMAIN_ATTR_MAX = 7
};

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iommu.h"
struct iommu_ops {
   bool (*capable)(enum iommu_cap ) ;
   struct iommu_domain *(*domain_alloc)(unsigned int ) ;
   void (*domain_free)(struct iommu_domain *) ;
   int (*attach_dev)(struct iommu_domain *, struct device *) ;
   void (*detach_dev)(struct iommu_domain *, struct device *) ;
   int (*map)(struct iommu_domain *, unsigned long , phys_addr_t , size_t , int ) ;
   size_t (*unmap)(struct iommu_domain *, unsigned long , size_t ) ;
   size_t (*map_sg)(struct iommu_domain *, unsigned long , struct scatterlist *, unsigned int , int ) ;
   phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t ) ;
   int (*add_device)(struct device *) ;
   void (*remove_device)(struct device *) ;
   int (*device_group)(struct device *, unsigned int *) ;
   int (*domain_get_attr)(struct iommu_domain *, enum iommu_attr , void *) ;
   int (*domain_set_attr)(struct iommu_domain *, enum iommu_attr , void *) ;
   void (*get_dm_regions)(struct device *, struct list_head *) ;
   void (*put_dm_regions)(struct device *, struct list_head *) ;
   int (*domain_window_enable)(struct iommu_domain *, u32 , phys_addr_t , u64 , int ) ;
   void (*domain_window_disable)(struct iommu_domain *, u32 ) ;
   int (*domain_set_windows)(struct iommu_domain *, u32 ) ;
   u32 (*domain_get_windows)(struct iommu_domain *) ;
   int (*of_xlate)(struct device *, struct of_phandle_args *) ;
   unsigned long pgsize_bitmap ;
   void *priv ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/pps.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations const *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pps_kernel.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};

#line 83 
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_pin_desc {
   char name[64U] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5U] ;
};

#line 134 
enum ldv_38529 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
union __anonunion_424 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ptp_clock.h"
struct ptp_clock_request {
   enum ldv_38529 type ;
   union __anonunion_424 __anonCompField_ptp_clock_request_118 ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int n_pins ;
   int pps ;
   struct ptp_pin_desc *pin_config ;
   int (*adjfreq)(struct ptp_clock_info *, s32 ) ;
   int (*adjtime)(struct ptp_clock_info *, s64 ) ;
   int (*gettime64)(struct ptp_clock_info *, struct timespec *) ;
   int (*settime64)(struct ptp_clock_info *, struct timespec const *) ;
   int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int ) ;
   int (*verify)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ) ;
};

#line 113 
struct ptp_clock;

#line 190 
enum i40e_status_code {
    I40E_SUCCESS = 0,
    I40E_ERR_NVM = -1,
    I40E_ERR_NVM_CHECKSUM = -2,
    I40E_ERR_PHY = -3,
    I40E_ERR_CONFIG = -4,
    I40E_ERR_PARAM = -5,
    I40E_ERR_MAC_TYPE = -6,
    I40E_ERR_UNKNOWN_PHY = -7,
    I40E_ERR_LINK_SETUP = -8,
    I40E_ERR_ADAPTER_STOPPED = -9,
    I40E_ERR_INVALID_MAC_ADDR = -10,
    I40E_ERR_DEVICE_NOT_SUPPORTED = -11,
    I40E_ERR_MASTER_REQUESTS_PENDING = -12,
    I40E_ERR_INVALID_LINK_SETTINGS = -13,
    I40E_ERR_AUTONEG_NOT_COMPLETE = -14,
    I40E_ERR_RESET_FAILED = -15,
    I40E_ERR_SWFW_SYNC = -16,
    I40E_ERR_NO_AVAILABLE_VSI = -17,
    I40E_ERR_NO_MEMORY = -18,
    I40E_ERR_BAD_PTR = -19,
    I40E_ERR_RING_FULL = -20,
    I40E_ERR_INVALID_PD_ID = -21,
    I40E_ERR_INVALID_QP_ID = -22,
    I40E_ERR_INVALID_CQ_ID = -23,
    I40E_ERR_INVALID_CEQ_ID = -24,
    I40E_ERR_INVALID_AEQ_ID = -25,
    I40E_ERR_INVALID_SIZE = -26,
    I40E_ERR_INVALID_ARP_INDEX = -27,
    I40E_ERR_INVALID_FPM_FUNC_ID = -28,
    I40E_ERR_QP_INVALID_MSG_SIZE = -29,
    I40E_ERR_QP_TOOMANY_WRS_POSTED = -30,
    I40E_ERR_INVALID_FRAG_COUNT = -31,
    I40E_ERR_QUEUE_EMPTY = -32,
    I40E_ERR_INVALID_ALIGNMENT = -33,
    I40E_ERR_FLUSHED_QUEUE = -34,
    I40E_ERR_INVALID_PUSH_PAGE_INDEX = -35,
    I40E_ERR_INVALID_IMM_DATA_SIZE = -36,
    I40E_ERR_TIMEOUT = -37,
    I40E_ERR_OPCODE_MISMATCH = -38,
    I40E_ERR_CQP_COMPL_ERROR = -39,
    I40E_ERR_INVALID_VF_ID = -40,
    I40E_ERR_INVALID_HMCFN_ID = -41,
    I40E_ERR_BACKING_PAGE_ERROR = -42,
    I40E_ERR_NO_PBLCHUNKS_AVAILABLE = -43,
    I40E_ERR_INVALID_PBLE_INDEX = -44,
    I40E_ERR_INVALID_SD_INDEX = -45,
    I40E_ERR_INVALID_PAGE_DESC_INDEX = -46,
    I40E_ERR_INVALID_SD_TYPE = -47,
    I40E_ERR_MEMCPY_FAILED = -48,
    I40E_ERR_INVALID_HMC_OBJ_INDEX = -49,
    I40E_ERR_INVALID_HMC_OBJ_COUNT = -50,
    I40E_ERR_INVALID_SRQ_ARM_LIMIT = -51,
    I40E_ERR_SRQ_ENABLED = -52,
    I40E_ERR_ADMIN_QUEUE_ERROR = -53,
    I40E_ERR_ADMIN_QUEUE_TIMEOUT = -54,
    I40E_ERR_BUF_TOO_SHORT = -55,
    I40E_ERR_ADMIN_QUEUE_FULL = -56,
    I40E_ERR_ADMIN_QUEUE_NO_WORK = -57,
    I40E_ERR_BAD_IWARP_CQE = -58,
    I40E_ERR_NVM_BLANK_MODE = -59,
    I40E_ERR_NOT_IMPLEMENTED = -60,
    I40E_ERR_PE_DOORBELL_NOT_ENABLED = -61,
    I40E_ERR_DIAG_TEST_FAILED = -62,
    I40E_ERR_NOT_READY = -63,
    I40E_NOT_SUPPORTED = -64,
    I40E_ERR_FIRMWARE_API_VERSION = -65
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/io-64-nonatomic-lo-hi.h"
struct i40e_dma_mem {
   void *va ;
   dma_addr_t pa ;
   u32 size ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
struct i40e_virt_mem {
   void *va ;
   u32 size ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
typedef enum i40e_status_code i40e_status;

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
struct __anonstruct_internal_427 {
   __le32 param0 ;
   __le32 param1 ;
   __le32 param2 ;
   __le32 param3 ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
struct __anonstruct_external_428 {
   __le32 param0 ;
   __le32 param1 ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
union __anonunion_params_426 {
   struct __anonstruct_internal_427 internal ;
   struct __anonstruct_external_428 external ;
   u8 raw[16U] ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
struct i40e_aq_desc {
   __le16 flags ;
   __le16 opcode ;
   __le16 datalen ;
   __le16 retval ;
   __le32 cookie_high ;
   __le32 cookie_low ;
   union __anonunion_params_426 params ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
enum i40e_admin_queue_err {
    I40E_AQ_RC_OK = 0,
    I40E_AQ_RC_EPERM = 1,
    I40E_AQ_RC_ENOENT = 2,
    I40E_AQ_RC_ESRCH = 3,
    I40E_AQ_RC_EINTR = 4,
    I40E_AQ_RC_EIO = 5,
    I40E_AQ_RC_ENXIO = 6,
    I40E_AQ_RC_E2BIG = 7,
    I40E_AQ_RC_EAGAIN = 8,
    I40E_AQ_RC_ENOMEM = 9,
    I40E_AQ_RC_EACCES = 10,
    I40E_AQ_RC_EFAULT = 11,
    I40E_AQ_RC_EBUSY = 12,
    I40E_AQ_RC_EEXIST = 13,
    I40E_AQ_RC_EINVAL = 14,
    I40E_AQ_RC_ENOTTY = 15,
    I40E_AQ_RC_ENOSPC = 16,
    I40E_AQ_RC_ENOSYS = 17,
    I40E_AQ_RC_ERANGE = 18,
    I40E_AQ_RC_EFLUSHED = 19,
    I40E_AQ_RC_BAD_ADDR = 20,
    I40E_AQ_RC_EMODE = 21,
    I40E_AQ_RC_EFBIG = 22
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_vsi_properties_data {
   __le16 valid_sections ;
   __le16 switch_id ;
   u8 sw_reserved[2U] ;
   u8 sec_flags ;
   u8 sec_reserved ;
   __le16 pvid ;
   __le16 fcoe_pvid ;
   u8 port_vlan_flags ;
   u8 pvlan_reserved[3U] ;
   __le32 ingress_table ;
   __le32 egress_table ;
   __le16 cas_pv_tag ;
   u8 cas_pv_flags ;
   u8 cas_pv_reserved ;
   __le16 mapping_flags ;
   __le16 queue_mapping[16U] ;
   __le16 tc_mapping[8U] ;
   u8 queueing_opt_flags ;
   u8 queueing_opt_reserved[3U] ;
   u8 up_enable_bits ;
   u8 sched_reserved ;
   __le32 outer_up_table ;
   u8 cmd_reserved[8U] ;
   __le16 qs_handle[8U] ;
   __le16 stat_counter_idx ;
   __le16 sched_id ;
   u8 resp_reserved[12U] ;
};

#line 1495  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_port_ets_config_resp {
   u8 reserved[4U] ;
   u8 tc_valid_bits ;
   u8 reserved1 ;
   u8 tc_strict_priority_bits ;
   u8 reserved2 ;
   u8 tc_bw_share_credits[8U] ;
   __le16 tc_bw_limits[8U] ;
   __le16 tc_bw_max[2U] ;
   u8 reserved3[32U] ;
};

#line 1560 
enum i40e_aq_phy_type {
    I40E_PHY_TYPE_SGMII = 0,
    I40E_PHY_TYPE_1000BASE_KX = 1,
    I40E_PHY_TYPE_10GBASE_KX4 = 2,
    I40E_PHY_TYPE_10GBASE_KR = 3,
    I40E_PHY_TYPE_40GBASE_KR4 = 4,
    I40E_PHY_TYPE_XAUI = 5,
    I40E_PHY_TYPE_XFI = 6,
    I40E_PHY_TYPE_SFI = 7,
    I40E_PHY_TYPE_XLAUI = 8,
    I40E_PHY_TYPE_XLPPI = 9,
    I40E_PHY_TYPE_40GBASE_CR4_CU = 10,
    I40E_PHY_TYPE_10GBASE_CR1_CU = 11,
    I40E_PHY_TYPE_10GBASE_AOC = 12,
    I40E_PHY_TYPE_40GBASE_AOC = 13,
    I40E_PHY_TYPE_100BASE_TX = 17,
    I40E_PHY_TYPE_1000BASE_T = 18,
    I40E_PHY_TYPE_10GBASE_T = 19,
    I40E_PHY_TYPE_10GBASE_SR = 20,
    I40E_PHY_TYPE_10GBASE_LR = 21,
    I40E_PHY_TYPE_10GBASE_SFPP_CU = 22,
    I40E_PHY_TYPE_10GBASE_CR1 = 23,
    I40E_PHY_TYPE_40GBASE_CR4 = 24,
    I40E_PHY_TYPE_40GBASE_SR4 = 25,
    I40E_PHY_TYPE_40GBASE_LR4 = 26,
    I40E_PHY_TYPE_1000BASE_SX = 27,
    I40E_PHY_TYPE_1000BASE_LX = 28,
    I40E_PHY_TYPE_1000BASE_T_OPTICAL = 29,
    I40E_PHY_TYPE_20GBASE_KR2 = 30,
    I40E_PHY_TYPE_MAX = 31
};

#line 1592 
enum i40e_aq_link_speed {
    I40E_LINK_SPEED_UNKNOWN = 0,
    I40E_LINK_SPEED_100MB = 2,
    I40E_LINK_SPEED_1GB = 4,
    I40E_LINK_SPEED_10GB = 8,
    I40E_LINK_SPEED_40GB = 16,
    I40E_LINK_SPEED_20GB = 32
};

#line 2338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
union __anonunion_r_432 {
   struct i40e_dma_mem *asq_bi ;
   struct i40e_dma_mem *arq_bi ;
};

#line 2338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_adminq_ring {
   struct i40e_virt_mem dma_head ;
   struct i40e_dma_mem desc_buf ;
   struct i40e_virt_mem cmd_buf ;
   union __anonunion_r_432 r ;
   u16 count ;
   u16 rx_buf_len ;
   u16 next_to_use ;
   u16 next_to_clean ;
   u32 head ;
   u32 tail ;
   u32 len ;
   u32 bah ;
   u32 bal ;
};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
struct i40e_asq_cmd_details {
   void *callback ;
   u64 cookie ;
   u16 flags_ena ;
   u16 flags_dis ;
   bool async ;
   bool postpone ;
};

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
struct i40e_adminq_info {
   struct i40e_adminq_ring arq ;
   struct i40e_adminq_ring asq ;
   u32 asq_cmd_timeout ;
   u16 num_arq_entries ;
   u16 num_asq_entries ;
   u16 arq_buf_size ;
   u16 asq_buf_size ;
   u16 fw_maj_ver ;
   u16 fw_min_ver ;
   u32 fw_build ;
   u16 api_maj_ver ;
   u16 api_min_ver ;
   bool nvm_release_on_done ;
   struct mutex asq_mutex ;
   struct mutex arq_mutex ;
   enum i40e_admin_queue_err asq_last_status ;
   enum i40e_admin_queue_err arq_last_status ;
};

#line 155 
struct i40e_hw;

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
struct i40e_hmc_obj_info {
   u64 base ;
   u32 max_cnt ;
   u32 cnt ;
   u64 size ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
enum i40e_sd_entry_type {
    I40E_SD_TYPE_INVALID = 0,
    I40E_SD_TYPE_PAGED = 1,
    I40E_SD_TYPE_DIRECT = 2
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_bp {
   enum i40e_sd_entry_type entry_type ;
   struct i40e_dma_mem addr ;
   u32 sd_pd_index ;
   u32 ref_cnt ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_pd_entry {
   struct i40e_hmc_bp bp ;
   u32 sd_index ;
   bool valid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_pd_table {
   struct i40e_dma_mem pd_page_addr ;
   struct i40e_hmc_pd_entry *pd_entry ;
   struct i40e_virt_mem pd_entry_virt_mem ;
   u32 ref_cnt ;
   u32 sd_index ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
union __anonunion_u_434 {
   struct i40e_hmc_pd_table pd_table ;
   struct i40e_hmc_bp bp ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_sd_entry {
   enum i40e_sd_entry_type entry_type ;
   bool valid ;
   union __anonunion_u_434 u ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_sd_table {
   struct i40e_virt_mem addr ;
   u32 sd_cnt ;
   u32 ref_cnt ;
   struct i40e_hmc_sd_entry *sd_entry ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_info {
   u32 signature ;
   u8 hmc_fn_id ;
   u16 first_sd_index ;
   struct i40e_hmc_obj_info *hmc_obj ;
   struct i40e_virt_mem hmc_obj_virt_mem ;
   struct i40e_hmc_sd_table sd_table ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_mac_type {
    I40E_MAC_UNKNOWN = 0,
    I40E_MAC_X710 = 1,
    I40E_MAC_XL710 = 2,
    I40E_MAC_VF = 3,
    I40E_MAC_GENERIC = 4
};

#line 101 
enum i40e_media_type {
    I40E_MEDIA_TYPE_UNKNOWN = 0,
    I40E_MEDIA_TYPE_FIBER = 1,
    I40E_MEDIA_TYPE_BASET = 2,
    I40E_MEDIA_TYPE_BACKPLANE = 3,
    I40E_MEDIA_TYPE_CX4 = 4,
    I40E_MEDIA_TYPE_DA = 5,
    I40E_MEDIA_TYPE_VIRTUAL = 6
};

#line 111 
enum i40e_fc_mode {
    I40E_FC_NONE = 0,
    I40E_FC_RX_PAUSE = 1,
    I40E_FC_TX_PAUSE = 2,
    I40E_FC_FULL = 3,
    I40E_FC_PFC = 4,
    I40E_FC_DEFAULT = 5
};

#line 128 
enum i40e_vsi_type {
    I40E_VSI_MAIN = 0,
    I40E_VSI_VMDQ1 = 1,
    I40E_VSI_VMDQ2 = 2,
    I40E_VSI_CTRL = 3,
    I40E_VSI_FCOE = 4,
    I40E_VSI_MIRROR = 5,
    I40E_VSI_SRIOV = 6,
    I40E_VSI_FDIR = 7,
    I40E_VSI_TYPE_UNKNOWN = 8
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_link_status {
   enum i40e_aq_phy_type phy_type ;
   enum i40e_aq_link_speed link_speed ;
   u8 link_info ;
   u8 an_info ;
   u8 ext_info ;
   u8 loopback ;
   bool lse_enable ;
   u16 max_frame_size ;
   bool crc_enable ;
   u8 pacing ;
   u8 requested_speeds ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_phy_info {
   struct i40e_link_status link_info ;
   struct i40e_link_status link_info_old ;
   u32 autoneg_advertised ;
   u32 phy_id ;
   u32 module_type ;
   bool get_link_info ;
   enum i40e_media_type media_type ;
};

#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_hw_capabilities {
   u32 switch_mode ;
   u32 management_mode ;
   u32 npar_enable ;
   u32 os2bmc ;
   u32 valid_functions ;
   bool sr_iov_1_1 ;
   bool vmdq ;
   bool evb_802_1_qbg ;
   bool evb_802_1_qbh ;
   bool dcb ;
   bool fcoe ;
   bool iscsi ;
   bool mfp_mode_1 ;
   bool mgmt_cem ;
   bool ieee_1588 ;
   bool iwarp ;
   bool fd ;
   u32 fd_filters_guaranteed ;
   u32 fd_filters_best_effort ;
   bool rss ;
   u32 rss_table_size ;
   u32 rss_table_entry_width ;
   bool led[30U] ;
   bool sdp[30U] ;
   u32 nvm_image_type ;
   u32 num_flow_director_filters ;
   u32 num_vfs ;
   u32 vf_base_id ;
   u32 num_vsis ;
   u32 num_rx_qp ;
   u32 num_tx_qp ;
   u32 base_queue ;
   u32 num_msix_vectors ;
   u32 num_msix_vectors_vf ;
   u32 led_pin_num ;
   u32 sdp_pin_num ;
   u32 mdio_port_num ;
   u32 mdio_port_mode ;
   u8 rx_buf_chain_len ;
   u32 enabled_tcmap ;
   u32 maxtc ;
   u64 wr_csr_prot ;
};

#line 247  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_mac_info {
   enum i40e_mac_type type ;
   u8 addr[6U] ;
   u8 perm_addr[6U] ;
   u8 san_addr[6U] ;
   u8 port_addr[6U] ;
   u16 max_fcoeq ;
};

#line 260 
enum i40e_aq_resource_access_type {
    I40E_RESOURCE_READ = 1,
    I40E_RESOURCE_WRITE = 2
};

#line 265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_nvm_info {
   u64 hw_semaphore_timeout ;
   u32 timeout ;
   u16 sr_size ;
   bool blank_nvm_mode ;
   u16 version ;
   u32 eetrack ;
};

#line 290 
enum i40e_nvmupd_state {
    I40E_NVMUPD_STATE_INIT = 0,
    I40E_NVMUPD_STATE_READING = 1,
    I40E_NVMUPD_STATE_WRITING = 2
};

#line 329 
enum i40e_bus_type {
    i40e_bus_type_unknown = 0,
    i40e_bus_type_pci = 1,
    i40e_bus_type_pcix = 2,
    i40e_bus_type_pci_express = 3,
    i40e_bus_type_reserved = 4
};

#line 337 
enum i40e_bus_speed {
    i40e_bus_speed_unknown = 0,
    i40e_bus_speed_33 = 33,
    i40e_bus_speed_66 = 66,
    i40e_bus_speed_100 = 100,
    i40e_bus_speed_120 = 120,
    i40e_bus_speed_133 = 133,
    i40e_bus_speed_2500 = 2500,
    i40e_bus_speed_5000 = 5000,
    i40e_bus_speed_8000 = 8000,
    i40e_bus_speed_reserved = 8001
};

#line 350 
enum i40e_bus_width {
    i40e_bus_width_unknown = 0,
    i40e_bus_width_pcie_x1 = 1,
    i40e_bus_width_pcie_x2 = 2,
    i40e_bus_width_pcie_x4 = 4,
    i40e_bus_width_pcie_x8 = 8,
    i40e_bus_width_32 = 32,
    i40e_bus_width_64 = 64,
    i40e_bus_width_reserved = 65
};

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_bus_info {
   enum i40e_bus_speed speed ;
   enum i40e_bus_width width ;
   enum i40e_bus_type type ;
   u16 func ;
   u16 device ;
   u16 lan_id ;
};

#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_fc_info {
   enum i40e_fc_mode current_mode ;
   enum i40e_fc_mode requested_mode ;
};

#line 381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_dcb_ets_config {
   u8 willing ;
   u8 cbs ;
   u8 maxtcs ;
   u8 prioritytable[8U] ;
   u8 tcbwtable[8U] ;
   u8 tsatable[8U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_dcb_pfc_config {
   u8 willing ;
   u8 mbc ;
   u8 pfccap ;
   u8 pfcenable ;
};

#line 413  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_dcb_app_priority_table {
   u8 priority ;
   u8 selector ;
   u16 protocolid ;
};

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_dcbx_config {
   u8 dcbx_mode ;
   u32 numapps ;
   struct i40e_dcb_ets_config etscfg ;
   struct i40e_dcb_ets_config etsrec ;
   struct i40e_dcb_pfc_config pfc ;
   struct i40e_dcb_app_priority_table app[32U] ;
};

#line 431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_hw {
   u8 *hw_addr ;
   void *back ;
   struct i40e_phy_info phy ;
   struct i40e_mac_info mac ;
   struct i40e_bus_info bus ;
   struct i40e_nvm_info nvm ;
   struct i40e_fc_info fc ;
   u16 device_id ;
   u16 vendor_id ;
   u16 subsystem_device_id ;
   u16 subsystem_vendor_id ;
   u8 revision_id ;
   u8 port ;
   bool adapter_stopped ;
   struct i40e_hw_capabilities dev_caps ;
   struct i40e_hw_capabilities func_caps ;
   u16 fdir_shared_filter_count ;
   u8 pf_id ;
   u16 main_vsi_seid ;
   u16 partition_id ;
   u16 num_partitions ;
   u16 num_ports ;
   u16 numa_node ;
   struct i40e_adminq_info aq ;
   enum i40e_nvmupd_state nvmupd_state ;
   struct i40e_hmc_info hmc ;
   u16 dcbx_status ;
   struct i40e_dcbx_config local_dcbx_config ;
   struct i40e_dcbx_config remote_dcbx_config ;
   u32 debug_mask ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_read_442 {
   __le64 pkt_addr ;
   __le64 hdr_addr ;
   __le64 rsvd1 ;
   __le64 rsvd2 ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
union __anonunion_mirr_fcoe_446 {
   __le16 mirroring_status ;
   __le16 fcoe_ctx_id ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_lo_dword_445 {
   union __anonunion_mirr_fcoe_446 mirr_fcoe ;
   __le16 l2tag1 ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
union __anonunion_hi_dword_447 {
   __le32 rss ;
   __le32 fcoe_param ;
   __le32 fd_id ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_qword0_444 {
   struct __anonstruct_lo_dword_445 lo_dword ;
   union __anonunion_hi_dword_447 hi_dword ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_qword1_448 {
   __le64 status_error_len ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_qword2_449 {
   __le16 ext_status ;
   __le16 rsvd ;
   __le16 l2tag2_1 ;
   __le16 l2tag2_2 ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
union __anonunion_lo_dword_451 {
   __le32 flex_bytes_lo ;
   __le32 pe_status ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
union __anonunion_hi_dword_452 {
   __le32 flex_bytes_hi ;
   __le32 fd_id ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_qword3_450 {
   union __anonunion_lo_dword_451 lo_dword ;
   union __anonunion_hi_dword_452 hi_dword ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_wb_443 {
   struct __anonstruct_qword0_444 qword0 ;
   struct __anonstruct_qword1_448 qword1 ;
   struct __anonstruct_qword2_449 qword2 ;
   struct __anonstruct_qword3_450 qword3 ;
};

#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
union i40e_32byte_rx_desc {
   struct __anonstruct_read_442 read ;
   struct __anonstruct_wb_443 wb ;
};

#line 776  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_tx_desc {
   __le64 buffer_addr ;
   __le64 cmd_type_offset_bsz ;
};

#line 1055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_eth_stats {
   u64 rx_bytes ;
   u64 rx_unicast ;
   u64 rx_multicast ;
   u64 rx_broadcast ;
   u64 rx_discards ;
   u64 rx_unknown_protocol ;
   u64 tx_bytes ;
   u64 tx_unicast ;
   u64 tx_multicast ;
   u64 tx_broadcast ;
   u64 tx_discards ;
   u64 tx_errors ;
};

#line 1071  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_fcoe_stats {
   u64 rx_fcoe_packets ;
   u64 rx_fcoe_dwords ;
   u64 rx_fcoe_dropped ;
   u64 tx_fcoe_packets ;
   u64 tx_fcoe_dwords ;
   u64 fcoe_bad_fccrc ;
   u64 fcoe_last_error ;
   u64 fcoe_ddp_count ;
};

#line 1084  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_hw_port_stats {
   struct i40e_eth_stats eth ;
   u64 tx_dropped_link_down ;
   u64 crc_errors ;
   u64 illegal_bytes ;
   u64 error_bytes ;
   u64 mac_local_faults ;
   u64 mac_remote_faults ;
   u64 rx_length_errors ;
   u64 link_xon_rx ;
   u64 link_xoff_rx ;
   u64 priority_xon_rx[8U] ;
   u64 priority_xoff_rx[8U] ;
   u64 link_xon_tx ;
   u64 link_xoff_tx ;
   u64 priority_xon_tx[8U] ;
   u64 priority_xoff_tx[8U] ;
   u64 priority_xon_2_xoff[8U] ;
   u64 rx_size_64 ;
   u64 rx_size_127 ;
   u64 rx_size_255 ;
   u64 rx_size_511 ;
   u64 rx_size_1023 ;
   u64 rx_size_1522 ;
   u64 rx_size_big ;
   u64 rx_undersize ;
   u64 rx_fragments ;
   u64 rx_oversize ;
   u64 rx_jabber ;
   u64 tx_size_64 ;
   u64 tx_size_127 ;
   u64 tx_size_255 ;
   u64 tx_size_511 ;
   u64 tx_size_1023 ;
   u64 tx_size_1522 ;
   u64 tx_size_big ;
   u64 mac_short_packet_dropped ;
   u64 checksum_error ;
   u64 fd_atr_match ;
   u64 fd_sb_match ;
   u64 fd_atr_tunnel_match ;
   u32 tx_lpi_status ;
   u32 rx_lpi_status ;
   u64 tx_lpi_count ;
   u64 rx_lpi_count ;
};

#line 1275 
enum i40e_switch_element_types {
    I40E_SWITCH_ELEMENT_TYPE_MAC = 1,
    I40E_SWITCH_ELEMENT_TYPE_PF = 2,
    I40E_SWITCH_ELEMENT_TYPE_VF = 3,
    I40E_SWITCH_ELEMENT_TYPE_EMP = 4,
    I40E_SWITCH_ELEMENT_TYPE_BMC = 6,
    I40E_SWITCH_ELEMENT_TYPE_PE = 16,
    I40E_SWITCH_ELEMENT_TYPE_VEB = 17,
    I40E_SWITCH_ELEMENT_TYPE_PA = 18,
    I40E_SWITCH_ELEMENT_TYPE_VSI = 19
};

#line 1302 
enum i40e_hash_filter_size {
    I40E_HASH_FILTER_SIZE_1K = 0,
    I40E_HASH_FILTER_SIZE_2K = 1,
    I40E_HASH_FILTER_SIZE_4K = 2,
    I40E_HASH_FILTER_SIZE_8K = 3,
    I40E_HASH_FILTER_SIZE_16K = 4,
    I40E_HASH_FILTER_SIZE_32K = 5,
    I40E_HASH_FILTER_SIZE_64K = 6,
    I40E_HASH_FILTER_SIZE_128K = 7,
    I40E_HASH_FILTER_SIZE_256K = 8,
    I40E_HASH_FILTER_SIZE_512K = 9,
    I40E_HASH_FILTER_SIZE_1M = 10
};

#line 1316 
enum i40e_dma_cntx_size {
    I40E_DMA_CNTX_SIZE_512 = 0,
    I40E_DMA_CNTX_SIZE_1K = 1,
    I40E_DMA_CNTX_SIZE_2K = 2,
    I40E_DMA_CNTX_SIZE_4K = 3,
    I40E_DMA_CNTX_SIZE_8K = 4,
    I40E_DMA_CNTX_SIZE_16K = 5,
    I40E_DMA_CNTX_SIZE_32K = 6,
    I40E_DMA_CNTX_SIZE_64K = 7,
    I40E_DMA_CNTX_SIZE_128K = 8,
    I40E_DMA_CNTX_SIZE_256K = 9
};

#line 1329 
enum i40e_hash_lut_size {
    I40E_HASH_LUT_SIZE_128 = 0,
    I40E_HASH_LUT_SIZE_512 = 1
};

#line 1334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_filter_control_settings {
   enum i40e_hash_filter_size pe_filt_num ;
   enum i40e_dma_cntx_size pe_cntx_num ;
   enum i40e_hash_filter_size fcoe_filt_num ;
   enum i40e_dma_cntx_size fcoe_cntx_num ;
   enum i40e_hash_lut_size hash_lut_size ;
   bool enable_fdir ;
   bool enable_ethtype ;
   bool enable_macvlan ;
};

#line 1379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_control_filter_stats {
   u16 mac_etype_used ;
   u16 etype_used ;
   u16 mac_etype_free ;
   u16 etype_free ;
};

#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_ether_addr {
   u8 addr[6U] ;
   u8 pad[2U] ;
};

#line 317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
struct i40e_fcoe_ddp {
   int len ;
   u16 xid ;
   u16 firstoff ;
   u16 lastsize ;
   u16 list_len ;
   u8 fcerr ;
   u8 prerr ;
   unsigned long flags ;
   unsigned int sgc ;
   struct scatterlist *sgl ;
   dma_addr_t udp ;
   u64 *udl ;
   struct dma_pool *pool ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.h"
struct i40e_fcoe_ddp_pool {
   struct dma_pool *pool ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.h"
struct i40e_fcoe {
   unsigned long mode ;
   atomic_t refcnt ;
   struct i40e_fcoe_ddp_pool *ddp_pool ;
   struct i40e_fcoe_ddp ddp[2048U] ;
};

#line 148 
struct i40e_pf;

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.h"
struct i40e_vf {
   struct i40e_pf *pf ;
   u16 vf_id ;
   enum i40e_switch_element_types parent_type ;
   u16 stag ;
   struct i40e_virtchnl_ether_addr default_lan_addr ;
   struct i40e_virtchnl_ether_addr default_fcoe_addr ;
   u16 port_vlan_id ;
   bool pf_set_mac ;
   u8 lan_vsi_idx ;
   u8 lan_vsi_id ;
   u8 num_queue_pairs ;
   u64 num_mdd_events ;
   u64 num_invalid_msgs ;
   u64 num_valid_msgs ;
   unsigned long vf_caps ;
   unsigned long vf_states ;
   unsigned int tx_rate ;
   bool link_forced ;
   bool link_up ;
   bool spoofchk ;
};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
union __anonunion_455 {
   struct sk_buff *skb ;
   void *raw_buf ;
};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
struct i40e_tx_buffer {
   struct i40e_tx_desc *next_to_watch ;
   union __anonunion_455 __anonCompField_i40e_tx_buffer_120 ;
   unsigned int bytecount ;
   unsigned short gso_segs ;
   dma_addr_t dma ;
   __u32 len ;
   u32 tx_flags ;
};

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_rx_buffer {
   struct sk_buff *skb ;
   void *hdr_buf ;
   dma_addr_t dma ;
   struct page *page ;
   dma_addr_t page_dma ;
   unsigned int page_offset ;
};

#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_queue_stats {
   u64 packets ;
   u64 bytes ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_tx_queue_stats {
   u64 restart_queue ;
   u64 tx_busy ;
   u64 tx_done_old ;
};

#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_rx_queue_stats {
   u64 non_eop_descs ;
   u64 alloc_page_failed ;
   u64 alloc_buff_failed ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
union __anonunion_456 {
   struct i40e_tx_buffer *tx_bi ;
   struct i40e_rx_buffer *rx_bi ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
union __anonunion_457 {
   struct i40e_tx_queue_stats tx_stats ;
   struct i40e_rx_queue_stats rx_stats ;
};

#line 195 
struct i40e_vsi;

#line 195 
struct i40e_q_vector;

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_ring {
   struct i40e_ring *next ;
   void *desc ;
   struct device *dev ;
   struct net_device *netdev ;
   union __anonunion_456 __anonCompField_i40e_ring_121 ;
   unsigned long state ;
   u16 queue_index ;
   u8 dcb_tc ;
   u8 *tail ;
   u16 count ;
   u16 reg_idx ;
   u16 rx_hdr_len ;
   u16 rx_buf_len ;
   u8 dtype ;
   u8 hsplit ;
   u16 next_to_use ;
   u16 next_to_clean ;
   u8 atr_sample_rate ;
   u8 atr_count ;
   unsigned long last_rx_timestamp ;
   bool ring_active ;
   bool arm_wb ;
   struct i40e_queue_stats stats ;
   struct u64_stats_sync syncp ;
   union __anonunion_457 __anonCompField_i40e_ring_122 ;
   unsigned int size ;
   dma_addr_t dma ;
   struct i40e_vsi *vsi ;
   struct i40e_q_vector *q_vector ;
   struct callback_head rcu ;
};

#line 272 
enum i40e_latency_range {
    I40E_LOWEST_LATENCY = 0,
    I40E_LOW_LATENCY = 1,
    I40E_BULK_LATENCY = 2
};

#line 278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_ring_container {
   struct i40e_ring *ring ;
   unsigned int total_bytes ;
   unsigned int total_packets ;
   u16 count ;
   enum i40e_latency_range latency_range ;
   u16 itr ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
enum i40e_interrupt_policy {
    I40E_INTERRUPT_BEST_CASE = 0,
    I40E_INTERRUPT_MEDIUM = 1,
    I40E_INTERRUPT_LOWEST = 2
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
struct i40e_lump_tracking {
   u16 num_entries ;
   u16 search_hint ;
   u16 list[0U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_fdir_filter {
   struct hlist_node fdir_node ;
   u8 flow_type ;
   u8 ip4_proto ;
   __be32 dst_ip[4U] ;
   __be32 src_ip[4U] ;
   __be16 src_port ;
   __be16 dst_port ;
   __be32 sctp_v_tag ;
   u16 q_index ;
   u8 flex_off ;
   u8 pctype ;
   u16 dest_vsi ;
   u8 dest_ctl ;
   u8 fd_status ;
   u16 cnt_index ;
   u32 fd_id ;
};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_tc_info {
   u16 qoffset ;
   u16 qcount ;
   u8 netdev_tc ;
};

#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_tc_configuration {
   u8 numtc ;
   u8 enabled_tc ;
   struct i40e_tc_info tc_info[8U] ;
};

#line 237 
struct i40e_veb;

#line 237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_pf {
   struct pci_dev *pdev ;
   struct i40e_hw hw ;
   unsigned long state ;
   unsigned long link_check_timeout ;
   struct msix_entry *msix_entries ;
   bool fc_autoneg_status ;
   u16 eeprom_version ;
   u16 num_vmdq_vsis ;
   u16 num_vmdq_qps ;
   u16 num_vmdq_msix ;
   u16 num_req_vfs ;
   u16 num_vf_qps ;
   u16 num_fcoe_qps ;
   u16 num_fcoe_msix ;
   u16 num_lan_qps ;
   u16 num_lan_msix ;
   int queues_left ;
   u16 rss_size ;
   u16 rss_size_max ;
   u16 fdir_pf_filter_count ;
   u16 num_alloc_vsi ;
   u8 atr_sample_rate ;
   bool wol_en ;
   struct hlist_head fdir_filter_list ;
   u16 fdir_pf_active_filters ;
   unsigned long fd_flush_timestamp ;
   u32 fd_flush_cnt ;
   u32 fd_add_err ;
   u32 fd_atr_cnt ;
   u32 fd_tcp_rule ;
   __be16 vxlan_ports[16U] ;
   u16 pending_vxlan_bitmap ;
   enum i40e_interrupt_policy int_policy ;
   u16 rx_itr_default ;
   u16 tx_itr_default ;
   u32 msg_enable ;
   char int_name[25U] ;
   u16 adminq_work_limit ;
   unsigned long service_timer_period ;
   unsigned long service_timer_previous ;
   struct timer_list service_timer ;
   struct work_struct service_task ;
   u64 flags ;
   u64 auto_disable_flags ;
   struct i40e_fcoe fcoe ;
   bool stat_offsets_loaded ;
   struct i40e_hw_port_stats stats ;
   struct i40e_hw_port_stats stats_offsets ;
   u32 tx_timeout_count ;
   u32 tx_timeout_recovery_level ;
   unsigned long tx_timeout_last_recovery ;
   u32 tx_sluggish_count ;
   u32 hw_csum_rx_error ;
   u32 led_status ;
   u16 corer_count ;
   u16 globr_count ;
   u16 empr_count ;
   u16 pfr_count ;
   u16 sw_int_count ;
   struct mutex switch_mutex ;
   u16 lan_vsi ;
   u16 lan_veb ;
   u16 next_vsi ;
   struct i40e_vsi **vsi ;
   struct i40e_veb *veb[16U] ;
   struct i40e_lump_tracking *qp_pile ;
   struct i40e_lump_tracking *irq_pile ;
   u16 pf_seid ;
   u16 main_vsi_seid ;
   u16 mac_seid ;
   struct kobject *switch_kobj ;
   struct dentry *i40e_dbg_pf ;
   u16 instance ;
   struct i40e_vf *vf ;
   int num_alloc_vfs ;
   u32 vf_aq_requests ;
   u16 dcbx_cap ;
   u32 fcoe_hmc_filt_num ;
   u32 fcoe_hmc_cntx_num ;
   struct i40e_filter_control_settings filter_settings ;
   struct ptp_clock *ptp_clock ;
   struct ptp_clock_info ptp_caps ;
   struct sk_buff *ptp_tx_skb ;
   struct hwtstamp_config tstamp_config ;
   unsigned long last_rx_ptp_check ;
   spinlock_t tmreg_lock ;
   u64 ptp_base_adj ;
   u32 tx_hwtstamp_timeouts ;
   u32 rx_hwtstamp_cleared ;
   bool ptp_tx ;
   bool ptp_rx ;
   u16 rss_table_size ;
   u32 npar_max_bw ;
   u32 npar_min_bw ;
};

#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_mac_filter {
   struct list_head list ;
   u8 macaddr[6U] ;
   s16 vlan ;
   u8 counter ;
   bool is_vf ;
   bool is_netdev ;
   bool changed ;
   bool is_laa ;
};

#line 414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_veb {
   struct i40e_pf *pf ;
   u16 idx ;
   u16 veb_idx ;
   u16 seid ;
   u16 uplink_seid ;
   u16 stats_idx ;
   u8 enabled_tc ;
   u16 bridge_mode ;
   u16 flags ;
   u16 bw_limit ;
   u8 bw_max_quanta ;
   bool is_abs_credits ;
   u8 bw_tc_share_credits[8U] ;
   u16 bw_tc_limit_credits[8U] ;
   u8 bw_tc_max_quanta[8U] ;
   struct kobject *kobj ;
   bool stat_offsets_loaded ;
   struct i40e_eth_stats stats ;
   struct i40e_eth_stats stats_offsets ;
};

#line 436  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_vsi {
   struct net_device *netdev ;
   unsigned long active_vlans[64U] ;
   bool netdev_registered ;
   bool stat_offsets_loaded ;
   u32 current_netdev_flags ;
   unsigned long state ;
   unsigned long flags ;
   struct list_head mac_filter_list ;
   struct rtnl_link_stats64 net_stats ;
   struct rtnl_link_stats64 net_stats_offsets ;
   struct i40e_eth_stats eth_stats ;
   struct i40e_eth_stats eth_stats_offsets ;
   struct i40e_fcoe_stats fcoe_stats ;
   struct i40e_fcoe_stats fcoe_stats_offsets ;
   bool fcoe_stat_offsets_loaded ;
   u32 tx_restart ;
   u32 tx_busy ;
   u32 rx_buf_failed ;
   u32 rx_page_failed ;
   struct i40e_ring **rx_rings ;
   struct i40e_ring **tx_rings ;
   u16 work_limit ;
   u16 rx_itr_setting ;
   u16 tx_itr_setting ;
   u16 rss_table_size ;
   u16 rss_size ;
   u16 max_frame ;
   u16 rx_hdr_len ;
   u16 rx_buf_len ;
   u8 dtype ;
   struct i40e_q_vector **q_vectors ;
   int num_q_vectors ;
   int base_vector ;
   bool irqs_ready ;
   u16 seid ;
   u16 id ;
   u16 uplink_seid ;
   u16 base_queue ;
   u16 alloc_queue_pairs ;
   u16 req_queue_pairs ;
   u16 num_queue_pairs ;
   u16 num_desc ;
   enum i40e_vsi_type type ;
   u16 vf_id ;
   struct i40e_tc_configuration tc_config ;
   struct i40e_aqc_vsi_properties_data info ;
   u16 bw_limit ;
   u8 bw_max_quanta ;
   u8 bw_ets_share_credits[8U] ;
   u16 bw_ets_limit_credits[8U] ;
   u8 bw_ets_max_quanta[8U] ;
   struct i40e_pf *back ;
   u16 idx ;
   u16 veb_idx ;
   struct kobject *kobj ;
   irqreturn_t (*irq_handler)(int , void *) ;
   struct ethtool_rxnfc rxnfc ;
};

#line 535  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_q_vector {
   struct i40e_vsi *vsi ;
   u16 v_idx ;
   u16 reg_idx ;
   struct napi_struct napi ;
   struct i40e_ring_container rx ;
   struct i40e_ring_container tx ;
   u8 num_ringpairs ;
   cpumask_t affinity_mask ;
   struct callback_head rcu ;
   char name[25U] ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
enum tk_offsets {
    TK_OFFS_REAL = 0,
    TK_OFFS_BOOT = 1,
    TK_OFFS_TAI = 2,
    TK_OFFS_MAX = 3
};

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct;

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_page_671 {
   struct page *p ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_671 page ;
   __u32 page_offset ;
   __u32 size ;
};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};

#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};

#line 2893  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct _ddebug {
   char const *modname ;
   char const *function ;
   char const *filename ;
   char const *format ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))) lineno : 18 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) flags : 8 ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11492 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
enum i40e_admin_queue_opc {
    i40e_aqc_opc_get_version = 1,
    i40e_aqc_opc_driver_version = 2,
    i40e_aqc_opc_queue_shutdown = 3,
    i40e_aqc_opc_set_pf_context = 4,
    i40e_aqc_opc_request_resource = 8,
    i40e_aqc_opc_release_resource = 9,
    i40e_aqc_opc_list_func_capabilities = 10,
    i40e_aqc_opc_list_dev_capabilities = 11,
    i40e_aqc_opc_set_cppm_configuration = 259,
    i40e_aqc_opc_set_arp_proxy_entry = 260,
    i40e_aqc_opc_set_ns_proxy_entry = 261,
    i40e_aqc_opc_mng_laa = 262,
    i40e_aqc_opc_mac_address_read = 263,
    i40e_aqc_opc_mac_address_write = 264,
    i40e_aqc_opc_clear_pxe_mode = 272,
    i40e_aqc_opc_get_switch_config = 512,
    i40e_aqc_opc_add_statistics = 513,
    i40e_aqc_opc_remove_statistics = 514,
    i40e_aqc_opc_set_port_parameters = 515,
    i40e_aqc_opc_get_switch_resource_alloc = 516,
    i40e_aqc_opc_add_vsi = 528,
    i40e_aqc_opc_update_vsi_parameters = 529,
    i40e_aqc_opc_get_vsi_parameters = 530,
    i40e_aqc_opc_add_pv = 544,
    i40e_aqc_opc_update_pv_parameters = 545,
    i40e_aqc_opc_get_pv_parameters = 546,
    i40e_aqc_opc_add_veb = 560,
    i40e_aqc_opc_update_veb_parameters = 561,
    i40e_aqc_opc_get_veb_parameters = 562,
    i40e_aqc_opc_delete_element = 579,
    i40e_aqc_opc_add_macvlan = 592,
    i40e_aqc_opc_remove_macvlan = 593,
    i40e_aqc_opc_add_vlan = 594,
    i40e_aqc_opc_remove_vlan = 595,
    i40e_aqc_opc_set_vsi_promiscuous_modes = 596,
    i40e_aqc_opc_add_tag = 597,
    i40e_aqc_opc_remove_tag = 598,
    i40e_aqc_opc_add_multicast_etag = 599,
    i40e_aqc_opc_remove_multicast_etag = 600,
    i40e_aqc_opc_update_tag = 601,
    i40e_aqc_opc_add_control_packet_filter = 602,
    i40e_aqc_opc_remove_control_packet_filter = 603,
    i40e_aqc_opc_add_cloud_filters = 604,
    i40e_aqc_opc_remove_cloud_filters = 605,
    i40e_aqc_opc_add_mirror_rule = 608,
    i40e_aqc_opc_delete_mirror_rule = 609,
    i40e_aqc_opc_dcb_ignore_pfc = 769,
    i40e_aqc_opc_dcb_updated = 770,
    i40e_aqc_opc_configure_vsi_bw_limit = 1024,
    i40e_aqc_opc_configure_vsi_ets_sla_bw_limit = 1030,
    i40e_aqc_opc_configure_vsi_tc_bw = 1031,
    i40e_aqc_opc_query_vsi_bw_config = 1032,
    i40e_aqc_opc_query_vsi_ets_sla_config = 1034,
    i40e_aqc_opc_configure_switching_comp_bw_limit = 1040,
    i40e_aqc_opc_enable_switching_comp_ets = 1043,
    i40e_aqc_opc_modify_switching_comp_ets = 1044,
    i40e_aqc_opc_disable_switching_comp_ets = 1045,
    i40e_aqc_opc_configure_switching_comp_ets_bw_limit = 1046,
    i40e_aqc_opc_configure_switching_comp_bw_config = 1047,
    i40e_aqc_opc_query_switching_comp_ets_config = 1048,
    i40e_aqc_opc_query_port_ets_config = 1049,
    i40e_aqc_opc_query_switching_comp_bw_config = 1050,
    i40e_aqc_opc_suspend_port_tx = 1051,
    i40e_aqc_opc_resume_port_tx = 1052,
    i40e_aqc_opc_configure_partition_bw = 1053,
    i40e_aqc_opc_query_hmc_resource_profile = 1280,
    i40e_aqc_opc_set_hmc_resource_profile = 1281,
    i40e_aqc_opc_get_phy_abilities = 1536,
    i40e_aqc_opc_set_phy_config = 1537,
    i40e_aqc_opc_set_mac_config = 1539,
    i40e_aqc_opc_set_link_restart_an = 1541,
    i40e_aqc_opc_get_link_status = 1543,
    i40e_aqc_opc_set_phy_int_mask = 1555,
    i40e_aqc_opc_get_local_advt_reg = 1556,
    i40e_aqc_opc_set_local_advt_reg = 1557,
    i40e_aqc_opc_get_partner_advt = 1558,
    i40e_aqc_opc_set_lb_modes = 1560,
    i40e_aqc_opc_get_phy_wol_caps = 1569,
    i40e_aqc_opc_set_phy_debug = 1570,
    i40e_aqc_opc_upload_ext_phy_fm = 1573,
    i40e_aqc_opc_nvm_read = 1793,
    i40e_aqc_opc_nvm_erase = 1794,
    i40e_aqc_opc_nvm_update = 1795,
    i40e_aqc_opc_nvm_config_read = 1796,
    i40e_aqc_opc_nvm_config_write = 1797,
    i40e_aqc_opc_send_msg_to_pf = 2049,
    i40e_aqc_opc_send_msg_to_vf = 2050,
    i40e_aqc_opc_send_msg_to_peer = 2051,
    i40e_aqc_opc_alternate_write = 2304,
    i40e_aqc_opc_alternate_write_indirect = 2305,
    i40e_aqc_opc_alternate_read = 2306,
    i40e_aqc_opc_alternate_read_indirect = 2307,
    i40e_aqc_opc_alternate_write_done = 2308,
    i40e_aqc_opc_alternate_set_mode = 2309,
    i40e_aqc_opc_alternate_clear_port = 2310,
    i40e_aqc_opc_lldp_get_mib = 2560,
    i40e_aqc_opc_lldp_update_mib = 2561,
    i40e_aqc_opc_lldp_add_tlv = 2562,
    i40e_aqc_opc_lldp_update_tlv = 2563,
    i40e_aqc_opc_lldp_delete_tlv = 2564,
    i40e_aqc_opc_lldp_stop = 2565,
    i40e_aqc_opc_lldp_start = 2566,
    i40e_aqc_opc_get_cee_dcb_cfg = 2567,
    i40e_aqc_opc_lldp_set_local_mib = 2568,
    i40e_aqc_opc_lldp_stop_start_spec_agent = 2569,
    i40e_aqc_opc_add_udp_tunnel = 2816,
    i40e_aqc_opc_del_udp_tunnel = 2817,
    i40e_aqc_opc_tunnel_key_structure = 2832,
    i40e_aqc_opc_event_lan_overflow = 4097,
    i40e_aqc_opc_oem_parameter_change = 65024,
    i40e_aqc_opc_oem_device_status_change = 65025,
    i40e_aqc_opc_oem_ocsd_initialize = 65026,
    i40e_aqc_opc_oem_ocbb_initialize = 65027,
    i40e_aqc_opc_debug_get_deviceid = 65280,
    i40e_aqc_opc_debug_set_mode = 65281,
    i40e_aqc_opc_debug_read_reg = 65283,
    i40e_aqc_opc_debug_write_reg = 65284,
    i40e_aqc_opc_debug_modify_reg = 65287,
    i40e_aqc_opc_debug_dump_internals = 65288
};

#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_list_capabilities_element_resp {
   __le16 id ;
   u8 major_rev ;
   u8 minor_rev ;
   __le32 number ;
   __le32 logical_id ;
   __le32 phys_id ;
   u8 reserved[16U] ;
};

#line 568  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_switch_config_header_resp {
   __le16 num_reported ;
   __le16 num_total ;
   u8 reserved[12U] ;
};

#line 579  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_switch_config_element_resp {
   u8 element_type ;
   u8 revision ;
   __le16 seid ;
   __le16 uplink_seid ;
   __le16 downlink_seid ;
   u8 reserved[3U] ;
   u8 connection_type ;
   __le16 scheduler_id ;
   __le16 element_info ;
};

#line 606  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_switch_config_resp {
   struct i40e_aqc_get_switch_config_header_resp header ;
   struct i40e_aqc_switch_config_element_resp element[1U] ;
};

#line 964  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_macvlan_element_data {
   u8 mac_addr[6U] ;
   __le16 vlan_tag ;
   __le16 flags ;
   __le16 queue_number ;
   u8 match_method ;
   u8 reserved1[3U] ;
};

#line 996  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_remove_macvlan_element_data {
   u8 mac_addr[6U] ;
   __le16 vlan_tag ;
   u8 flags ;
   u8 reserved[3U] ;
   u8 error_code ;
   u8 reply_reserved[3U] ;
};

#line 1386  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_vsi_tc_bw_data {
   u8 tc_valid_bits ;
   u8 reserved[3U] ;
   u8 tc_bw_credits[8U] ;
   u8 reserved1[4U] ;
   __le16 qs_handles[8U] ;
};

#line 1399  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_vsi_bw_config_resp {
   u8 tc_valid_bits ;
   u8 tc_suspended_bits ;
   u8 reserved[14U] ;
   __le16 qs_handles[8U] ;
   u8 reserved1[4U] ;
   __le16 port_bw_limit ;
   u8 reserved2[2U] ;
   u8 max_bw ;
   u8 reserved3[23U] ;
};

#line 1414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_vsi_ets_sla_config_resp {
   u8 tc_valid_bits ;
   u8 reserved[3U] ;
   u8 share_credits[8U] ;
   __le16 credits[8U] ;
   __le16 tc_bw_max[2U] ;
};

#line 1469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_switching_comp_bw_config_data {
   u8 tc_valid_bits ;
   u8 reserved[2U] ;
   u8 absolute_credits ;
   u8 tc_bw_share_credits[8U] ;
   u8 reserved1[20U] ;
};

#line 1483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_switching_comp_ets_config_resp {
   u8 tc_valid_bits ;
   u8 reserved[35U] ;
   __le16 port_bw_limit ;
   u8 reserved1[2U] ;
   u8 tc_bw_max ;
   u8 reserved2[23U] ;
};

#line 1512  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_switching_comp_bw_config_resp {
   u8 tc_valid_bits ;
   u8 reserved[2U] ;
   u8 absolute_credits_enable ;
   u8 tc_bw_share_credits[8U] ;
   __le16 tc_bw_limits[8U] ;
   __le16 tc_bw_max[2U] ;
};

#line 1528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_partition_bw_data {
   __le16 pf_valid_bits ;
   u8 min_bw[16U] ;
   u8 max_bw[16U] ;
};

#line 1601  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_module_desc {
   u8 oui[3U] ;
   u8 reserved1 ;
   u8 part_number[16U] ;
   u8 revision[4U] ;
   u8 reserved2[8U] ;
};

#line 1627  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aq_get_phy_abilities_resp {
   __le32 phy_type ;
   u8 link_speed ;
   u8 abilities ;
   __le16 eee_capability ;
   __le32 eeer_val ;
   u8 d3_lpan ;
   u8 reserved[3U] ;
   u8 phy_id[4U] ;
   u8 module_type[3U] ;
   u8 qualified_module_count ;
   struct i40e_aqc_module_desc qualified_module[16U] ;
};

#line 1710  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_link_status {
   __le16 command_flags ;
   u8 phy_type ;
   u8 link_speed ;
   u8 link_info ;
   u8 an_info ;
   u8 ext_info ;
   u8 loopback ;
   __le16 max_frame_size ;
   u8 config ;
   u8 reserved[5U] ;
};

#line 1953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lan_overflow {
   __le32 prtdcb_rupto ;
   __le32 otx_ctl ;
   u8 reserved[8U] ;
};

#line 1966  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_get_mib {
   u8 type ;
   u8 reserved1 ;
   __le16 local_len ;
   __le16 remote_len ;
   u8 reserved2[2U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
struct i40e_arq_event_info {
   struct i40e_aq_desc desc ;
   u16 msg_len ;
   u16 buf_len ;
   u8 *msg_buf ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_obj_rxq {
   u16 head ;
   u16 cpuid ;
   u64 base ;
   u16 qlen ;
   u16 dbuff ;
   u16 hbuff ;
   u8 dtype ;
   u8 dsize ;
   u8 crcstrip ;
   u8 fc_ena ;
   u8 l2tsel ;
   u8 hsplit_0 ;
   u8 hsplit_1 ;
   u8 showiv ;
   u32 rxmax ;
   u8 tphrdesc_ena ;
   u8 tphwdesc_ena ;
   u8 tphdata_ena ;
   u8 tphhead_ena ;
   u16 lrxqthresh ;
   u8 prefena ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
struct i40e_hmc_obj_txq {
   u16 head ;
   u8 new_context ;
   u64 base ;
   u8 fc_ena ;
   u8 timesync_ena ;
   u8 fd_ena ;
   u8 alt_vlan_ena ;
   u16 thead_wb ;
   u8 cpuid ;
   u8 head_wb_ena ;
   u16 qlen ;
   u8 tphrdesc_ena ;
   u8 tphrpacket_ena ;
   u8 tphwdesc_ena ;
   u64 head_wb_addr ;
   u32 crc ;
   u16 rdylist ;
   u8 rdylist_act ;
};

#line 132 
enum i40e_hmc_model {
    I40E_HMC_MODEL_DIRECT_PREFERRED = 0,
    I40E_HMC_MODEL_DIRECT_ONLY = 1,
    I40E_HMC_MODEL_PAGED_ONLY = 2,
    I40E_HMC_MODEL_UNKNOWN = 3
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_driver_version {
   u8 major_version ;
   u8 minor_version ;
   u8 build_version ;
   u8 subbuild_version ;
   u8 driver_string[32U] ;
};

#line 990  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_vsi_context {
   u16 seid ;
   u16 uplink_seid ;
   u16 vsi_number ;
   u16 vsis_allocated ;
   u16 vsis_unallocated ;
   u16 flags ;
   u8 pf_num ;
   u8 vf_num ;
   u8 connection_type ;
   struct i40e_aqc_vsi_properties_data info ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_netdev_priv {
   struct i40e_vsi *vsi ;
};

#line 1685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
union __anonunion___u_1373 {
   struct list_head *__val ;
   char __c[1U] ;
};

#line 1685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
union __anonunion___u_1375 {
   struct list_head *__val ;
   char __c[1U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
enum i40e_hmc_obj_rx_hsplit_0 {
    I40E_HMC_OBJ_RX_HSPLIT_0_NO_SPLIT = 0,
    I40E_HMC_OBJ_RX_HSPLIT_0_SPLIT_L2 = 1,
    I40E_HMC_OBJ_RX_HSPLIT_0_SPLIT_IP = 2,
    I40E_HMC_OBJ_RX_HSPLIT_0_SPLIT_TCP_UDP = 4,
    I40E_HMC_OBJ_RX_HSPLIT_0_SPLIT_SCTP = 8
};

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_queue_type {
    I40E_QUEUE_TYPE_RX = 0,
    I40E_QUEUE_TYPE_TX = 1,
    I40E_QUEUE_TYPE_PE_CEQ = 2,
    I40E_QUEUE_TYPE_UNKNOWN = 3
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_alloc.h"
enum i40e_virtchnl_ops {
    I40E_VIRTCHNL_OP_UNKNOWN = 0,
    I40E_VIRTCHNL_OP_VERSION = 1,
    I40E_VIRTCHNL_OP_RESET_VF = 2,
    I40E_VIRTCHNL_OP_GET_VF_RESOURCES = 3,
    I40E_VIRTCHNL_OP_CONFIG_TX_QUEUE = 4,
    I40E_VIRTCHNL_OP_CONFIG_RX_QUEUE = 5,
    I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES = 6,
    I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP = 7,
    I40E_VIRTCHNL_OP_ENABLE_QUEUES = 8,
    I40E_VIRTCHNL_OP_DISABLE_QUEUES = 9,
    I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS = 10,
    I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS = 11,
    I40E_VIRTCHNL_OP_ADD_VLAN = 12,
    I40E_VIRTCHNL_OP_DEL_VLAN = 13,
    I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE = 14,
    I40E_VIRTCHNL_OP_GET_STATS = 15,
    I40E_VIRTCHNL_OP_FCOE = 16,
    I40E_VIRTCHNL_OP_EVENT = 17,
    I40E_VIRTCHNL_OP_CONFIG_RSS = 18
};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_version_info {
   u32 major ;
   u32 minor ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_vsi_resource {
   u16 vsi_id ;
   u16 num_queue_pairs ;
   enum i40e_vsi_type vsi_type ;
   u16 qset_handle ;
   u8 default_mac_addr[6U] ;
};

#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_vf_resource {
   u16 num_vsis ;
   u16 num_queue_pairs ;
   u16 max_vectors ;
   u16 max_mtu ;
   u32 vf_offload_flags ;
   u32 max_fcoe_contexts ;
   u32 max_fcoe_filters ;
   struct i40e_virtchnl_vsi_resource vsi_res[1U] ;
};

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_txq_info {
   u16 vsi_id ;
   u16 queue_id ;
   u16 ring_len ;
   u16 headwb_enabled ;
   u64 dma_ring_addr ;
   u64 dma_headwb_addr ;
};

#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_rxq_info {
   u16 vsi_id ;
   u16 queue_id ;
   u32 ring_len ;
   u16 hdr_size ;
   u16 splithdr_enabled ;
   u32 databuffer_size ;
   u32 max_pkt_size ;
   u64 dma_ring_addr ;
   enum i40e_hmc_obj_rx_hsplit_0 rx_split_pos ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_queue_pair_info {
   struct i40e_virtchnl_txq_info txq ;
   struct i40e_virtchnl_rxq_info rxq ;
};

#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_vsi_queue_config_info {
   u16 vsi_id ;
   u16 num_queue_pairs ;
   struct i40e_virtchnl_queue_pair_info qpair[1U] ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_vector_map {
   u16 vsi_id ;
   u16 vector_id ;
   u16 rxq_map ;
   u16 txq_map ;
   u16 rxitr_idx ;
   u16 txitr_idx ;
};

#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_irq_map_info {
   u16 num_vectors ;
   struct i40e_virtchnl_vector_map vecmap[1U] ;
};

#line 237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_queue_select {
   u16 vsi_id ;
   u16 pad ;
   u32 rx_queues ;
   u32 tx_queues ;
};

#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_ether_addr_list {
   u16 vsi_id ;
   u16 num_elements ;
   struct i40e_virtchnl_ether_addr list[1U] ;
};

#line 275  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_vlan_filter_list {
   u16 vsi_id ;
   u16 num_elements ;
   u16 vlan_id[1U] ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_promisc_info {
   u16 vsi_id ;
   u16 flags ;
};

#line 305 
enum i40e_virtchnl_event_codes {
    I40E_VIRTCHNL_EVENT_UNKNOWN = 0,
    I40E_VIRTCHNL_EVENT_LINK_CHANGE = 1,
    I40E_VIRTCHNL_EVENT_RESET_IMPENDING = 2,
    I40E_VIRTCHNL_EVENT_PF_DRIVER_CLOSE = 3
};

#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct __anonstruct_link_event_1829 {
   enum i40e_aq_link_speed link_speed ;
   bool link_status ;
};

#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
union __anonunion_event_data_1828 {
   struct __anonstruct_link_event_1829 link_event ;
};

#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl.h"
struct i40e_virtchnl_pf_event {
   enum i40e_virtchnl_event_codes event ;
   union __anonunion_event_data_1828 event_data ;
   int severity ;
};

#line 1657  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aq_set_phy_config {
   __le32 phy_type ;
   u8 link_speed ;
   u8 abilities ;
   __le16 eee_capability ;
   __le32 eeer ;
   u8 low_power_ctrl ;
   u8 reserved[3U] ;
};

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_nvm_access {
   u32 command ;
   u32 config ;
   u32 offset ;
   u32 data_size ;
   u8 data[1U] ;
};

#line 767  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_diag_reg_test_info {
   u32 offset ;
   u32 mask ;
   u32 elements ;
   u32 stride ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_diag.h"
struct i40e_stats {
   char stat_string[32U] ;
   int sizeof_stat ;
   int stat_offset ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __sum16;

#line 890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct iphdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ihl : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) priority : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) res1 : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) doff : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) fin : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syn : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rst : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) psh : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ack : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) urg : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ece : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};

#line 410  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
struct udphdr {
   __be16 source ;
   __be16 dest ;
   __be16 len ;
   __sum16 check ;
};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};

#line 656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_rx_ptype_decoded {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) ptype : 8 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) known : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) outer_ip : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) outer_ip_ver : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) outer_frag : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tunnel_type : 3 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) tunnel_end_prot : 2 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) tunnel_end_frag : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) inner_prot : 4 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) payload_layer : 3 ;
};

#line 849  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_tx_context_desc {
   __le32 tunneling_params ;
   __le16 l2tag2 ;
   __le16 rsvd ;
   __le64 type_cmd_tso_mss ;
};

#line 894  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_filter_program_desc {
   __le32 qindex_flex_ptype_vsi ;
   __le32 rsvd ;
   __le32 dtype_cmd_cntindex ;
   __le32 fd_id ;
};

#line 1931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
union __anonunion_hdr_3223 {
   unsigned char *network ;
   struct iphdr *ipv4 ;
   struct ipv6hdr *ipv6 ;
};

#line 256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_aq_resources_ids {
    I40E_NVM_RESOURCE_ID = 1
};

#line 274 
enum i40e_nvmupd_cmd {
    I40E_NVMUPD_INVALID = 0,
    I40E_NVMUPD_READ_CON = 1,
    I40E_NVMUPD_READ_SNT = 2,
    I40E_NVMUPD_READ_LCB = 3,
    I40E_NVMUPD_READ_SA = 4,
    I40E_NVMUPD_WRITE_ERA = 5,
    I40E_NVMUPD_WRITE_CON = 6,
    I40E_NVMUPD_WRITE_SNT = 7,
    I40E_NVMUPD_WRITE_LCB = 8,
    I40E_NVMUPD_WRITE_SA = 9,
    I40E_NVMUPD_CSUM_CON = 10,
    I40E_NVMUPD_CSUM_SA = 11,
    I40E_NVMUPD_CSUM_LCB = 12
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void *) ;
   void *info ;
   unsigned int flags ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
struct bio_set;

#line 45 
struct bio;

#line 46 
struct bio_integrity_payload;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio *, int );

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
union __anonunion_4242 {
   struct bio_integrity_payload *bi_integrity ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion_4242 __anonCompField_bio_79 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct hd_geometry;

#line 1571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device_operations;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};

#line 162 
struct disk_events;

#line 163 
struct timer_rand_state;

#line 163 
struct blk_integrity;

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk *, umode_t *) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations const *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/backing-dev-defs.h"
typedef int congested_fn(void *, int );

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/backing-dev-defs.h"
union __anonunion_4261 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion_4261 __anonCompField_bdi_writeback_91 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/backing-dev-defs.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t , void *);

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mempool.h"
typedef void mempool_free_t(void *, void *);

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mempool.h"
typedef struct mempool_s mempool_t;

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mempool.h"
union __anonunion_4262 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mempool.h"
union __anonunion_4263 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion_4262 __anonCompField_io_cq_92 ;
   union __anonunion_4263 __anonCompField_io_cq_93 ;
   unsigned int flags ;
};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};

#line 326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};

#line 541  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};

#line 662  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device *) ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bsg.h"
struct elevator_queue;

#line 23 
struct blk_trace;

#line 24 
struct request;

#line 26 
struct bsg_job;

#line 27 
struct blkcg_gq;

#line 28 
struct blk_flush_queue;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request *, int );

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
union __anonunion_4264 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};

#line 75 
struct blk_mq_ctx;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
union __anonunion_4265 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
union __anonunion_4266 {
   struct rb_node rb_node ;
   void *completion_data ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct __anonstruct_elv_4268 {
   struct io_cq *icq ;
   void *priv[2U] ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct __anonstruct_flush_4269 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
union __anonunion_4267 {
   struct __anonstruct_elv_4268 elv ;
   struct __anonstruct_flush_4269 flush ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion_4264 __anonCompField_request_94 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion_4265 __anonCompField_request_95 ;
   union __anonunion_4266 __anonCompField_request_96 ;
   union __anonunion_4267 __anonCompField_request_97 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hashtable.h"
struct elevator_type;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue *, struct request **, struct bio *);

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue *, struct request *, struct request *);

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue *, struct request *, int );

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue *, struct request *, struct bio *);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue *, struct request *, struct bio *);

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue *, int );

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue *, struct request *);

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue *, struct request *);

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue *, struct request *);

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue *, int );

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq *);

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue *, struct request *, struct bio *, gfp_t );

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request *);

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue *, struct request *);

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue *, struct request *);

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue *, struct elevator_type *);

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue *);

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
typedef void elevator_registered_fn(struct request_queue *);

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue *, char *) ;
   ssize_t (*store)(struct elevator_queue *, char const *, size_t ) ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};

#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) registered : 1 ;
   struct hlist_head hash[64U] ;
};

#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue *);

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue *, struct bio *);

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue *, struct request *);

#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue *, struct request *);

#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};

#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue *, struct bvec_merge_data *, struct bio_vec *);

#line 224  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef void softirq_done_fn(struct request *);

#line 225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request *);

#line 226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue *);

#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job *);

#line 228 
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request *);

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};

#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};

#line 285 
struct blk_mq_ops;

#line 285 
struct blk_mq_hw_ctx;

#line 285 
struct throtl_data;

#line 285 
struct blk_mq_tag_set;

#line 285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};

#line 1020  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};

#line 1398  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const *disk_name ;
};

#line 1427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter *);

#line 1428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const *name ;
   struct kobject kobj ;
};

#line 1482  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device *, fmode_t ) ;
   void (*release)(struct gendisk *, fmode_t ) ;
   int (*rw_page)(struct block_device *, sector_t , struct page *, int ) ;
   int (*ioctl)(struct block_device *, fmode_t , unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct block_device *, fmode_t , unsigned int , unsigned long ) ;
   long (*direct_access)(struct block_device *, sector_t , void **, unsigned long *, long ) ;
   unsigned int (*check_events)(struct gendisk *, unsigned int ) ;
   int (*media_changed)(struct gendisk *) ;
   void (*unlock_native_capacity)(struct gendisk *) ;
   int (*revalidate_disk)(struct gendisk *) ;
   int (*getgeo)(struct block_device *, struct hd_geometry *) ;
   void (*swap_slot_free_notify)(struct block_device *, unsigned long ) ;
   struct module *owner ;
};

#line 351  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/scsi/scsi_cmnd.h"
struct fc_frame_header {
   __u8 fh_r_ctl ;
   __u8 fh_d_id[3U] ;
   __u8 fh_cs_ctl ;
   __u8 fh_s_id[3U] ;
   __u8 fh_type ;
   __u8 fh_f_ctl[3U] ;
   __u8 fh_seq_id ;
   __u8 fh_df_ctl ;
   __be16 fh_seq_cnt ;
   __be16 fh_ox_id ;
   __be16 fh_rx_id ;
   __be32 fh_parm_offset ;
};

#line 279  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/scsi/fc/fc_fip.h"
struct fcoe_hdr {
   __u8 fcoe_ver ;
   __u8 fcoe_resvd[12U] ;
   __u8 fcoe_sof ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/scsi/fc/fc_fcoe.h"
struct fcoe_crc_eof {
   __le32 fcoe_crc32 ;
   __u8 fcoe_eof ;
   __u8 fcoe_resvd[3U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/transport_class.h"
struct blk_mq_tags;

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/transport_class.h"
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void *, unsigned long , unsigned int ) ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
struct blk_align_bitmap;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
   struct blk_align_bitmap *map ;
};

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
struct __anonstruct_4282 {
   spinlock_t lock ;
   struct list_head dispatch ;
};

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct_4282 __anonCompField_blk_mq_hw_ctx_98 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
typedef int queue_rq_fn(struct blk_mq_hw_ctx *, struct blk_mq_queue_data const *);

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue *, int const );

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request *, bool );

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx *, void *, unsigned int );

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx *, unsigned int );

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
typedef int init_request_fn(void *, struct request *, unsigned int , unsigned int , unsigned int );

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
typedef void exit_request_fn(void *, struct request *, unsigned int , unsigned int );

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};

#line 1159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_fcoe_ddp_context_desc {
   __le64 rsvd ;
   __le64 type_cmd_foff_lsize ;
};

#line 1207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_fcoe_queue_context_desc {
   __le64 dmaindx_fbase ;
   __le64 flen_tph ;
};

#line 1234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_fcoe_filter_context_desc {
   __le32 param ;
   __le16 seqn ;
   __le16 rsvd_dmaindx ;
   __le64 flags_rsvd_lanq ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
enum i40e_hmc_lan_rsrc_type {
    I40E_HMC_LAN_FULL = 0,
    I40E_HMC_LAN_TX = 1,
    I40E_HMC_LAN_RX = 2,
    I40E_HMC_FCOE_CTX = 3,
    I40E_HMC_FCOE_FILT = 4,
    I40E_HMC_LAN_MAX = 5
};

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
struct i40e_hmc_lan_create_obj_info {
   struct i40e_hmc_info *hmc_info ;
   u32 rsrc_type ;
   u32 start_idx ;
   u32 count ;
   enum i40e_sd_entry_type entry_type ;
   u64 direct_mode_sz ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
struct i40e_hmc_lan_delete_obj_info {
   struct i40e_hmc_info *hmc_info ;
   u32 rsrc_type ;
   u32 start_idx ;
   u32 count ;
};

#line 682  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
struct i40e_context_ele {
   u16 offset ;
   u16 size_of ;
   u16 width ;
   u16 lsb ;
};

#line 2051  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_cee_dcb_cfg_v1_resp {
   u8 reserved1 ;
   u8 oper_num_tc ;
   u8 oper_prio_tc[4U] ;
   u8 reserved2 ;
   u8 oper_tc_bw[8U] ;
   u8 oper_pfc_en ;
   u8 reserved3 ;
   __le16 oper_app_prio ;
   u8 reserved4 ;
   __le16 tlv_status ;
};

#line 2083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_cee_dcb_cfg_resp {
   u8 oper_num_tc ;
   u8 oper_prio_tc[4U] ;
   u8 oper_tc_bw[8U] ;
   u8 oper_pfc_en ;
   __le16 oper_app_prio ;
   __le32 tlv_status ;
   u8 reserved[12U] ;
};

#line 1394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_lldp_variables {
   u16 length ;
   u16 adminstatus ;
   u16 msgfasttx ;
   u16 msgtxinterval ;
   u16 txparams ;
   u16 timers ;
   u16 crc8 ;
};

#line 307  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
struct i40e_lldp_org_tlv {
   __be16 typelength ;
   __be32 ouisubtype ;
   u8 tlvinfo[1U] ;
};

#line 1554  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
enum i40e_aq_hmc_profile {
    I40E_HMC_PROFILE_DEFAULT = 1,
    I40E_HMC_PROFILE_FAVOR_VF = 2,
    I40E_HMC_PROFILE_EQUAL = 3
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_debug_mask {
    I40E_DEBUG_INIT = 1,
    I40E_DEBUG_RELEASE = 2,
    I40E_DEBUG_LINK = 16,
    I40E_DEBUG_PHY = 32,
    I40E_DEBUG_HMC = 64,
    I40E_DEBUG_NVM = 128,
    I40E_DEBUG_LAN = 256,
    I40E_DEBUG_FLOW = 512,
    I40E_DEBUG_DCB = 1024,
    I40E_DEBUG_DIAG = 2048,
    I40E_DEBUG_FD = 4096,
    I40E_DEBUG_AQ_MESSAGE = 16777216,
    I40E_DEBUG_AQ_DESCRIPTOR = 33554432,
    I40E_DEBUG_AQ_DESC_BUFFER = 67108864,
    I40E_DEBUG_AQ_COMMAND = 100663296,
    I40E_DEBUG_AQ = 251658240,
    I40E_DEBUG_USER = 4026531840,
    I40E_DEBUG_ALL = 4294967295
};

#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_version {
   __le32 rom_ver ;
   __le32 fw_build ;
   __le16 fw_major ;
   __le16 fw_minor ;
   __le16 api_major ;
   __le16 api_minor ;
};

#line 326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_driver_version {
   u8 driver_major_ver ;
   u8 driver_minor_ver ;
   u8 driver_build_ver ;
   u8 driver_subbuild_ver ;
   u8 reserved[4U] ;
   __le32 address_high ;
   __le32 address_low ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_queue_shutdown {
   __le32 driver_unloading ;
   u8 reserved[12U] ;
};

#line 356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_request_resource {
   __le16 resource_id ;
   __le16 access_type ;
   __le32 timeout ;
   __le32 resource_number ;
   u8 reserved[4U] ;
};

#line 376  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_list_capabilites {
   u8 command_flags ;
   u8 pf_index ;
   u8 reserved[2U] ;
   __le32 count ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_mac_address_read {
   __le16 command_flags ;
   u8 reserved[6U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_mac_address_read_data {
   u8 pf_lan_mac[6U] ;
   u8 pf_san_mac[6U] ;
   u8 port_mac[6U] ;
   u8 pf_wol_mac[6U] ;
};

#line 530  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_mac_address_write {
   __le16 command_flags ;
   __le16 mac_sah ;
   __le32 mac_sal ;
   u8 reserved[8U] ;
};

#line 544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_clear_pxe {
   u8 rx_cnt ;
   u8 reserved[15U] ;
};

#line 554  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_switch_seid {
   __le16 seid ;
   u8 reserved[6U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_get_update_vsi {
   __le16 uplink_seid ;
   u8 connection_type ;
   u8 reserved1 ;
   u8 vf_id ;
   u8 reserved2 ;
   __le16 vsi_flags ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 717  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_get_update_vsi_completion {
   __le16 seid ;
   __le16 vsi_number ;
   __le16 vsi_used ;
   __le16 vsi_free ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 895  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_veb {
   __le16 uplink_seid ;
   __le16 downlink_seid ;
   __le16 veb_flags ;
   u8 enable_tcs ;
   u8 reserved[9U] ;
};

#line 913  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_veb_completion {
   u8 reserved[6U] ;
   __le16 switch_seid ;
   __le16 veb_seid ;
   __le16 statistic_index ;
   __le16 vebs_used ;
   __le16 vebs_free ;
};

#line 929  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_veb_parameters_completion {
   __le16 seid ;
   __le16 switch_id ;
   __le16 veb_flags ;
   __le16 statistic_index ;
   __le16 vebs_used ;
   __le16 vebs_free ;
   u8 reserved[4U] ;
};

#line 944  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_macvlan {
   __le16 num_addresses ;
   __le16 seid[3U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 1057  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_vsi_promiscuous_modes {
   __le16 promiscuous_flags ;
   __le16 valid_flags ;
   __le16 seid ;
   __le16 vlan_tag ;
   u8 reserved[8U] ;
};

#line 1164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_remove_control_packet_filter {
   u8 mac[6U] ;
   __le16 etype ;
   __le16 flags ;
   __le16 seid ;
   __le16 queue ;
   u8 reserved[2U] ;
};

#line 1188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_remove_control_packet_filter_completion {
   __le16 mac_etype_used ;
   __le16 etype_used ;
   __le16 mac_etype_free ;
   __le16 etype_free ;
   u8 reserved[8U] ;
};

#line 1336  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_tx_sched_ind {
   __le16 vsi_seid ;
   u8 reserved[6U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 1357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_vsi_bw_limit {
   __le16 vsi_seid ;
   u8 reserved[2U] ;
   __le16 credit ;
   u8 reserved1[2U] ;
   u8 max_credit ;
   u8 reserved2[7U] ;
};

#line 1439  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_switching_comp_ets_data {
   u8 reserved[4U] ;
   u8 tc_valid_bits ;
   u8 seepage ;
   u8 tc_strict_priority_flags ;
   u8 reserved1[17U] ;
   u8 tc_bw_share_credits[8U] ;
   u8 reserved2[96U] ;
};

#line 1543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aq_get_set_hmc_resource_profile {
   u8 pm_profile ;
   u8 pe_vf_enabled ;
   u8 reserved[14U] ;
};

#line 1700  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_link_restart_an {
   u8 command ;
   u8 reserved[15U] ;
};

#line 1757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_phy_int_mask {
   u8 reserved[8U] ;
   __le16 event_mask ;
   u8 reserved1[6U] ;
};

#line 1820  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_nvm_update {
   u8 command_flags ;
   u8 module_pointer ;
   __le16 length ;
   __le32 offset ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 1889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_pf_vf_message {
   __le32 id ;
   u8 reserved[4U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 1902  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_alternate_write {
   __le32 address0 ;
   __le32 data0 ;
   __le32 address1 ;
   __le32 data1 ;
};

#line 1990  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_update_mib {
   u8 command ;
   u8 reserved[7U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};

#line 2031  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_stop {
   u8 command ;
   u8 reserved[15U] ;
};

#line 2041  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_start {
   u8 command ;
   u8 reserved[15U] ;
};

#line 2137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_udp_tunnel {
   __le16 udp_port ;
   u8 reserved0[3U] ;
   u8 protocol_type ;
   u8 reserved1[10U] ;
};

#line 2162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_remove_udp_tunnel {
   u8 reserved[2U] ;
   u8 index ;
   u8 reserved2[13U] ;
};

#line 2171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_del_udp_tunnel_completion {
   __le16 udp_port ;
   u8 index ;
   u8 multiple_pfs ;
   u8 total_filters_used ;
   u8 reserved1[11U] ;
};

#line 2271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_debug_reg_read_write {
   __le32 reserved ;
   __le32 address ;
   __le32 value_high ;
   __le32 value_low ;
};

#line 2303  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_debug_dump_internals {
   u8 cluster_id ;
   u8 table_id ;
   __le16 data_size ;
   __le32 idx ;
   __le32 address_high ;
   __le32 address_low ;
};

#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
enum i40e_memory_type {
    i40e_mem_arq_buf = 0,
    i40e_mem_asq_buf = 1,
    i40e_mem_atq_buf = 2,
    i40e_mem_arq_ring = 3,
    i40e_mem_atq_ring = 4,
    i40e_mem_pd = 5,
    i40e_mem_bp = 6,
    i40e_mem_bp_jumbo = 7,
    i40e_mem_reserved = 8
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct ldv_struct_character_driver_scenario_17 {
   struct file_operations *arg0 ;
   int signal_pending ;
};

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_free_irq_6 {
   int arg0 ;
   int signal_pending ;
};

#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_16 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_14 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 40  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_random_allocationless_scenario_18 {
   struct net_device *arg0 ;
   int signal_pending ;
};

#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_timer_scenario_15 {
   struct timer_list *arg0 ;
   int signal_pending ;
};

#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/fvtp/.tmp_i40e_debugfs.c"
void ldv_inline_asm(void);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 431 
void print_hex_dump(char const *, char const *, int, int, int, void const *, size_t, bool);


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_fault(char const *, int);


#line 363 
int kstrtol_from_user(char const *, size_t, unsigned int, long *);


#line 405 
int snprintf(char *, size_t, char const * , ...);


#line 418 
int sscanf(char const *, char const * , ...);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 56 
void *memset(void *, int, size_t);


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
int strncmp(char const *, char const *, __kernel_size_t);


#line 50 
char *strchr(char const *, int);


#line 121 
void *kmemdup(void const *, size_t, gfp_t);


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val)
{
  int tmp;
  
#line 72 
  if (0 != 0 && (val == 1 || val == -1)) 
#line 72 
                                         tmp = val; else 
#line 72 
                                                         tmp = 0;
  
#line 72 
  int const pao_ID__ = tmp;
  
#line 72 
  switch (4UL) {
    case (unsigned long)1: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)2: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)4: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)8: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    default: 
#line 72 
    ;
    
#line 72 
    __bad_percpu_size();
  }
  ldv_6377: 
#line 72 
  ;
  
#line 74 
  return;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val)
{
  int tmp;
  
#line 77 
  if (0 != 0 && (- val == 1 || - val == -1)) 
#line 77 
                                             tmp = - val; else 
#line 77 
                                                               tmp = 0;
  
#line 77 
  int const pao_ID__ = tmp;
  
#line 77 
  switch (4UL) {
    case (unsigned long)1: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)2: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)4: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)8: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    default: 
#line 77 
    ;
    
#line 77 
    __bad_percpu_size();
  }
  ldv_6389: 
#line 77 
  ;
  
#line 79 
  return;
}


#line 333  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lock_acquire(struct lockdep_map *, unsigned int, int, int, int, struct lockdep_map *, unsigned long);


#line 337 
void lock_release(struct lockdep_map *, int, unsigned long);


#line 545 
void lockdep_rcu_suspicious(char const *, int const, char const *);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static void ldv_mutex_lock_73(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_76(struct mutex *ldv_func_arg1);


#line 47 
void ldv_mutex_model_lock(struct mutex *, char *);


#line 49 
void ldv_mutex_model_unlock(struct mutex *, char *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void)
{
  
#line 270 
  __preempt_count_add(1);
  
#line 271 
  ldv_inline_asm();
  
#line 272 
  return;
}


#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void)
{
  
#line 275 
  ldv_inline_asm();
  
#line 275 
  __preempt_count_sub(1);
  
#line 276 
  return;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcutree.h"
bool rcu_is_watching(void);


#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map)
{
  __here_0: 
#line 449 
  ;
  
#line 449 
  ;
  
#line 449 
  lock_acquire(map,0U,0,2,0,(struct lockdep_map *)0,(unsigned long)((void *)0));
  
#line 451 
  return;
}


#line 452  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map)
{
  __here_0: 
#line 454 
  ;
  
#line 454 
  ;
  
#line 454 
  lock_release(map,1,(unsigned long)((void *)0));
  
#line 456 
  return;
}


#line 457 
extern struct lockdep_map rcu_lock_map;


#line 461 
int debug_lockdep_rcu_enabled(void);


#line 843  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_read_lock(void)
{
  
#line 845 
  __rcu_read_lock();
  
#line 847 
  rcu_lock_acquire(& rcu_lock_map);
  {
    bool __warned;
    int tmp;
    
#line 848 
    tmp = debug_lockdep_rcu_enabled();
    
#line 848 
    if (tmp != 0) {
      
#line 848 
      if (! __warned) {
        int tmp_1;
        bool tmp_0;
        
#line 848 
        tmp_0 = rcu_is_watching();
        
#line 848 
        if (tmp_0) 
#line 848 
                   tmp_1 = 0; else 
#line 848 
                                   tmp_1 = 1;
        
#line 848 
        if (tmp_1) {
          
#line 848 
          __warned = (_Bool)1;
          
#line 848 
          lockdep_rcu_suspicious("include/linux/rcupdate.h",849,"rcu_read_lock() used illegally while idle");
        }
        else ;
      }
      else ;
    }
    else ;
  }
  
#line 851 
  return;
}


#line 897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void)
{
  {
    bool __warned;
    int tmp;
    
#line 899 
    tmp = debug_lockdep_rcu_enabled();
    
#line 899 
    if (tmp != 0) {
      
#line 899 
      if (! __warned) {
        int tmp_1;
        bool tmp_0;
        
#line 899 
        tmp_0 = rcu_is_watching();
        
#line 899 
        if (tmp_0) 
#line 899 
                   tmp_1 = 0; else 
#line 899 
                                   tmp_1 = 1;
        
#line 899 
        if (tmp_1) {
          
#line 899 
          __warned = (_Bool)1;
          
#line 899 
          lockdep_rcu_suspicious("include/linux/rcupdate.h",900,"rcu_read_unlock() used illegally while idle");
        }
        else ;
      }
      else ;
    }
    else ;
  }
  
#line 902 
  __rcu_read_unlock();
  
#line 903 
  rcu_lock_release(& rcu_lock_map);
  
#line 904 
  return;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_74(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_75(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_77(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1);


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile *addr)
{
  unsigned int ret;
  
#line 59 
  ldv_inline_asm();
  
#line 58 
  return ret;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void volatile *addr)
{
  
#line 68 
  ldv_inline_asm();
  
#line 69 
  return;
}


#line 2812  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
int simple_open(struct inode *, struct file *);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_79(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_80(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 62 
static struct dentry *ldv_debugfs_create_file_81(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 70 
struct dentry *debugfs_create_dir(char const *, struct dentry *);


#line 81 
void debugfs_remove_recursive(struct dentry *);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 652 
unsigned long _copy_to_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 664 
void copy_to_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 677 
void __copy_to_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void const *from, unsigned long n)
{
  
#line 730 
  int sz = -1;
  
#line 732 
  __might_fault("./arch/x86/include/asm/uaccess.h",732);
  
#line 735 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 736 
                                                                    n = _copy_to_user(to,from,(unsigned int)n);
  else 
    
#line 737 
    if (0 != 0) 
#line 738 
                copy_to_user_overflow(); else 
#line 740 
                                              __copy_to_user_overflow();
  
#line 742 
  return n;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 1062 
char const *dev_driver_string(struct device const *);


#line 1089 
void _dev_info(struct device const *, char const * , ...);


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __napi_schedule(struct napi_struct *);


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n)
{
  bool __retres;
  int tmp;
  
#line 396 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& n->state));
  
#line 396 
  __retres = (_Bool)(tmp != 0);
  
#line 396 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n)
{
  bool __retres;
  int tmp_2;
  int tmp_0;
  bool tmp;
  
#line 410 
  tmp = napi_disable_pending(n);
  
#line 410 
  if (tmp) 
#line 410 
           tmp_0 = 0; else 
#line 410 
                           tmp_0 = 1;
  
#line 410 
  if (tmp_0) {
    int tmp_1;
    
#line 410 
    tmp_1 = test_and_set_bit(0L,(unsigned long volatile *)(& n->state));
    
#line 410 
    if (tmp_1 == 0) 
#line 410 
                    tmp_2 = 1; else 
#line 410 
                                    tmp_2 = 0;
  }
  else 
#line 410 
       tmp_2 = 0;
  
#line 410 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 410 
  return __retres;
}


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n)
{
  bool tmp;
  
#line 423 
  tmp = napi_schedule_prep(n);
  
#line 423 
  if ((int)tmp != 0) 
#line 424 
                     __napi_schedule(n); else ;
  
#line 425 
  return;
}


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
void rtnl_unlock(void);


#line 29 
int rtnl_trylock(void);


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static char const *pci_name(struct pci_dev const *pdev)
{
  char const *tmp;
  
#line 1486 
  tmp = dev_name(& pdev->dev);
  
#line 1486 
  return tmp;
}


#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
i40e_status i40e_asq_send_command(struct i40e_hw *hw, struct i40e_aq_desc *desc, void *buff, u16 buff_size, struct i40e_asq_cmd_details *cmd_details);


#line 155 
i40e_status i40e_aq_read_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, void *data, bool last_command, struct i40e_asq_cmd_details *cmd_details);


#line 170 
i40e_status i40e_aq_get_lldp_mib(struct i40e_hw *hw, u8 bridge_type, u8 mib_type, void *buff, u16 buff_size, u16 *local_len, u16 *remote_len, struct i40e_asq_cmd_details *cmd_details);


#line 174 
i40e_status i40e_aq_cfg_lldp_mib_change_event(struct i40e_hw *hw, bool enable_update, struct i40e_asq_cmd_details *cmd_details);


#line 177 
i40e_status i40e_aq_stop_lldp(struct i40e_hw *hw, bool shutdown_agent, struct i40e_asq_cmd_details *cmd_details);


#line 179 
i40e_status i40e_aq_start_lldp(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details);


#line 231 
i40e_status i40e_aq_query_port_ets_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_port_ets_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);


#line 266 
i40e_status i40e_acquire_nvm(struct i40e_hw *hw, enum i40e_aq_resource_access_type access);


#line 268 
void i40e_release_nvm(struct i40e_hw *hw);


#line 301 
i40e_status i40e_aq_add_rem_control_packet_filter(struct i40e_hw *hw, u8 *mac_addr, u16 ethtype, u16 flags, u16 vsi_seid, u16 queue, bool is_add, struct i40e_control_filter_stats *stats, struct i40e_asq_cmd_details *cmd_details);


#line 306 
i40e_status i40e_aq_debug_dump(struct i40e_hw *hw, u8 cluster_id, u8 table_id, u32 start_index, u16 buff_size, void *buff, u16 *ret_buff_size, u8 *ret_next_table, u32 *ret_next_index, struct i40e_asq_cmd_details *cmd_details);


#line 629  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
char const i40e_driver_name[5U];


#line 631 
void i40e_do_reset_safe(struct i40e_pf *pf, u32 reset_flags);


#line 636 
struct rtnl_link_stats64 *i40e_get_vsi_stats_struct(struct i40e_vsi *vsi);


#line 637 
int i40e_fetch_switch_configuration(struct i40e_pf *pf, bool printconfig);


#line 640 
int i40e_program_fdir_filter(struct i40e_fdir_filter *fdir_data, u8 *raw_packet, struct i40e_pf *pf, bool add);


#line 645 
u32 i40e_get_current_fd_count(struct i40e_pf *pf);


#line 651 
struct i40e_mac_filter *i40e_add_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan, bool is_vf, bool is_netdev);


#line 654 
void i40e_del_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan, bool is_vf, bool is_netdev);


#line 656 
int i40e_sync_vsi_filters(struct i40e_vsi *vsi);


#line 657 
struct i40e_vsi *i40e_vsi_setup(struct i40e_pf *pf, u8 type, u16 uplink_seid, u32 param1);


#line 659 
int i40e_vsi_release(struct i40e_vsi *vsi);


#line 669 
struct i40e_veb *i40e_veb_setup(struct i40e_pf *pf, u16 flags, u16 uplink_seid, u16 vsi_seid, u8 enabled_tc);


#line 671 
void i40e_veb_release(struct i40e_veb *veb);


#line 674 
i40e_status i40e_vsi_add_pvid(struct i40e_vsi *vsi, u16 vid);


#line 675 
void i40e_vsi_remove_pvid(struct i40e_vsi *vsi);


#line 676 
void i40e_vsi_reset_stats(struct i40e_vsi *vsi);


#line 677 
void i40e_pf_reset_stats(struct i40e_pf *pf);


#line 679 
void i40e_dbg_pf_init(struct i40e_pf *pf);


#line 680 
void i40e_dbg_pf_exit(struct i40e_pf *pf);


#line 681 
void i40e_dbg_init(void);


#line 682 
void i40e_dbg_exit(void);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct dentry *i40e_dbg_root;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct i40e_vsi *i40e_dbg_find_vsi(struct i40e_pf *pf, int seid)
{
  struct i40e_vsi *__retres;
  int i;
  
#line 45 
  if (seid < 0) 
#line 46 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"%d: bad seid\n",seid);
  else {
    
#line 48 
    i = 0;
    
#line 48 
    goto ldv_61576;
    ldv_61575: 
#line 49 
    ;
    
#line 49 
    if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + i))->seid == seid) {
      
#line 50 
      __retres = *(pf->vsi + i);
      
#line 50 
      goto return_label;
    }
    else ;
    
#line 48 
    i += 1;
    ldv_61576: 
#line 49 
    ;
    
#line 48 
    if ((int)pf->num_alloc_vsi > i) 
#line 50 
                                    goto ldv_61575; else 
#line 53 
                                                         goto ldv_61577;
    ldv_61577: 
#line 54 
    ;
  }
  
#line 52 
  __retres = (struct i40e_vsi *)0;
  return_label: 
#line 52 
                return __retres;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct i40e_veb *i40e_dbg_find_veb(struct i40e_pf *pf, int seid)
{
  struct i40e_veb *__retres;
  int i;
  
#line 64 
  if ((unsigned int)seid + 4294967008U > 16U) 
#line 66 
                                              _dev_info((struct device const *)(& (pf->pdev)->dev),"%d: bad seid\n",seid);
  else {
    
#line 68 
    i = 0;
    
#line 68 
    goto ldv_61584;
    ldv_61583: 
#line 69 
    ;
    
#line 69 
    if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == seid) {
      
#line 70 
      __retres = pf->veb[i];
      
#line 70 
      goto return_label;
    }
    else ;
    
#line 68 
    i += 1;
    ldv_61584: 
#line 69 
    ;
    
#line 68 
    if (i <= 15) 
#line 70 
                 goto ldv_61583; else 
#line 73 
                                      goto ldv_61585;
    ldv_61585: 
#line 74 
    ;
  }
  
#line 71 
  __retres = (struct i40e_veb *)0;
  return_label: 
#line 71 
                return __retres;
}


#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static char *i40e_dbg_dump_buf;

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_dump_data_len;

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_dump_buffer_len;

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_dump_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int bytes_not_copied;
  int len;
  int tmp_0;
  unsigned long tmp_1;
  
#line 99 
  if (*ppos >= (long long)i40e_dbg_dump_data_len || i40e_dbg_dump_buf == (char *)0) {
    
#line 100 
    __retres = 0L;
    
#line 100 
    goto return_label;
  }
  else ;
  {
    int tmp;
    
#line 103 
    int __min1 = (int)count;
    
#line 103 
    int __min2 = (int)((loff_t)i40e_dbg_dump_data_len - *ppos);
    
#line 103 
    if (__min1 < __min2) 
#line 103 
                         tmp = __min1; else 
#line 103 
                                            tmp = __min2;
    
#line 103 
    tmp_0 = tmp;
  }
  
#line 103 
  len = tmp_0;
  
#line 105 
  tmp_1 = copy_to_user((void *)buffer,(void const *)(i40e_dbg_dump_buf + *ppos),(unsigned long)len);
  
#line 105 
  bytes_not_copied = (int)tmp_1;
  
#line 106 
  if (bytes_not_copied < 0) {
    
#line 107 
    __retres = (long)bytes_not_copied;
    
#line 107 
    goto return_label;
  }
  else ;
  
#line 109 
  *ppos += (long long)len;
  
#line 110 
  __retres = (long)len;
  return_label: 
#line 110 
                return __retres;
}


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static int i40e_dbg_prep_dump_buf(struct i40e_pf *pf, int buflen)
{
  int __retres;
  
#line 123 
  if (i40e_dbg_dump_buffer_len != 0L && (long)buflen > i40e_dbg_dump_buffer_len) {
    
#line 124 
    kfree((void const *)i40e_dbg_dump_buf);
    
#line 125 
    i40e_dbg_dump_buffer_len = 0L;
    
#line 126 
    i40e_dbg_dump_buf = (char *)0;
  }
  else ;
  
#line 130 
  if (i40e_dbg_dump_buf == (char *)0) {
    
#line 131 
    i40e_dbg_dump_buf = (char *)kzalloc((unsigned long)buflen,208U);
    
#line 132 
    if (i40e_dbg_dump_buf != (char *)0) 
#line 133 
                                        i40e_dbg_dump_buffer_len = (long)buflen; else ;
  }
  else ;
  
#line 136 
  __retres = (int)i40e_dbg_dump_buffer_len;
  
#line 136 
  return __retres;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_dump_write(struct file *filp, char const *buffer, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int i;
  int ret;
  int len;
  u8 *p;
  
#line 152 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  
#line 153 
  bool seid_found = (_Bool)0;
  
#line 154 
  long seid = -1L;
  
#line 155 
  int buflen = 0;
  
#line 161 
  if (*ppos != 0LL) {
    
#line 162 
    __retres = 0L;
    
#line 162 
    goto return_label;
  }
  else ;
  
#line 165 
  ret = kstrtol_from_user(buffer,count,0U,& seid);
  
#line 167 
  if (ret != 0) 
#line 168 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"bad seid value\n");
  else 
    
#line 169 
    if (seid == 0L) {
      
#line 170 
      seid_found = (_Bool)1;
      
#line 172 
      kfree((void const *)i40e_dbg_dump_buf);
      
#line 173 
      i40e_dbg_dump_buffer_len = 0L;
      
#line 174 
      i40e_dbg_dump_data_len = 0L;
      
#line 175 
      i40e_dbg_dump_buf = (char *)0;
      
#line 176 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"debug buffer freed\n");
    }
    else 
      
#line 178 
      if ((long)pf->pf_seid == seid || seid == 1L) {
        int tmp;
        
#line 179 
        seid_found = (_Bool)1;
        
#line 181 
        buflen = 135240;
        
#line 182 
        buflen = (int)((unsigned long)((int)pf->hw.aq.num_arq_entries + (int)pf->hw.aq.num_asq_entries) * (unsigned long)32U + (unsigned long)buflen);
        
#line 185 
        tmp = i40e_dbg_prep_dump_buf(pf,buflen);
        
#line 185 
        if (tmp != 0) {
          
#line 186 
          p = (u8 *)i40e_dbg_dump_buf;
          
#line 188 
          len = 135240;
          
#line 189 
          memcpy((void *)p,(void const *)pf,(unsigned long)len);
          
#line 190 
          p += len;
          
#line 192 
          len = (int)((unsigned int)pf->hw.aq.num_asq_entries * 32U);
          
#line 194 
          memcpy((void *)p,(void const *)pf->hw.aq.asq.desc_buf.va,(unsigned long)len);
          
#line 195 
          p += len;
          
#line 197 
          len = (int)((unsigned int)pf->hw.aq.num_arq_entries * 32U);
          
#line 199 
          memcpy((void *)p,(void const *)pf->hw.aq.arq.desc_buf.va,(unsigned long)len);
          
#line 200 
          p += len;
          
#line 202 
          i40e_dbg_dump_data_len = (long)buflen;
          
#line 203 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"PF seid %ld dumped %d bytes\n",seid,(int)i40e_dbg_dump_data_len);
        }
        else ;
      }
      else 
        
#line 207 
        if (seid > 511L) {
          struct i40e_mac_filter *f;
          struct i40e_mac_filter *tmp_0;
          struct i40e_mac_filter *tmp_1;
          int tmp_4;
          
#line 208 
          struct i40e_vsi *vsi = (struct i40e_vsi *)0;
          
#line 210 
          int filter_count = 0;
          
#line 212 
          ldv_mutex_lock_73(& pf->switch_mutex);
          
#line 213 
          vsi = i40e_dbg_find_vsi(pf,(int)seid);
          
#line 214 
          if (vsi == (struct i40e_vsi *)0) {
            
#line 215 
            ldv_mutex_unlock_74(& pf->switch_mutex);
            
#line 216 
            goto write_exit;
          }
          else ;
          
#line 219 
          buflen = 4096;
          
#line 220 
          buflen = (int)((unsigned long)vsi->num_q_vectors * (unsigned long)4096U + (unsigned long)buflen);
          
#line 221 
          buflen = (int)((unsigned int)vsi->num_queue_pairs * 8192U + (unsigned int)buflen);
          
#line 222 
          buflen = (int)((unsigned int)vsi->num_queue_pairs * 40U + (unsigned int)buflen);
          
#line 223 
          buflen = (int)((unsigned int)vsi->num_queue_pairs * 48U + (unsigned int)buflen);
          {
            
#line 224 
            struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
            
#line 224 
            tmp_0 = (struct i40e_mac_filter *)__mptr;
          }
          
#line 224 
          f = tmp_0;
          
#line 224 
          goto ldv_61627;
          ldv_61626: 
#line 225 
          ;
          
#line 225 
          filter_count += 1;
          {
            
#line 224 
            struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
            
#line 224 
            tmp_1 = (struct i40e_mac_filter *)__mptr_0;
          }
          
#line 224 
          f = tmp_1;
          ldv_61627: 
#line 226 
          ;
          
#line 224 
          if (& f->list != & vsi->mac_filter_list) 
#line 226 
                                                   goto ldv_61626; else 
                                                                    
#line 229 
                                                                    goto ldv_61628;
          ldv_61628: 
#line 230 
          ;
          
#line 226 
          buflen = (int)((unsigned long)filter_count * (unsigned long)32U + (unsigned long)buflen);
          
#line 228 
          tmp_4 = i40e_dbg_prep_dump_buf(pf,buflen);
          
#line 228 
          if (tmp_4 != 0) {
            struct i40e_mac_filter *tmp_2;
            struct i40e_mac_filter *tmp_3;
            
#line 229 
            p = (u8 *)i40e_dbg_dump_buf;
            
#line 230 
            seid_found = (_Bool)1;
            
#line 232 
            len = 4096;
            
#line 233 
            memcpy((void *)p,(void const *)vsi,(unsigned long)len);
            
#line 234 
            p += len;
            
#line 236 
            if (vsi->num_q_vectors != 0) {
              
#line 237 
              len = (int)((unsigned long)vsi->num_q_vectors * (unsigned long)4096U);
              
#line 239 
              memcpy((void *)p,(void const *)vsi->q_vectors,(unsigned long)len);
              
#line 240 
              p += len;
            }
            else ;
            
#line 243 
            if ((unsigned int)vsi->num_queue_pairs != 0U) {
              
#line 244 
              len = (int)((unsigned int)vsi->num_queue_pairs * 4096U);
              
#line 246 
              memcpy((void *)p,(void const *)vsi->tx_rings,(unsigned long)len);
              
#line 247 
              p += len;
              
#line 248 
              memcpy((void *)p,(void const *)vsi->rx_rings,(unsigned long)len);
              
#line 249 
              p += len;
            }
            else ;
            
#line 252 
            if (*(vsi->tx_rings) != (struct i40e_ring *)0) {
              
#line 253 
              len = 40;
              
#line 254 
              i = 0;
              
#line 254 
              goto ldv_61630;
              ldv_61629: 
#line 255 
              ;
              
#line 255 
              memcpy((void *)p,(void const *)(*(vsi->tx_rings + i))->__anonCompField_i40e_ring_121.tx_bi,(unsigned long)len);
              
#line 256 
              p += len;
              
#line 254 
              i += 1;
              ldv_61630: 
#line 255 
              ;
              
#line 254 
              if ((int)vsi->num_queue_pairs > i) 
#line 256 
                                                 goto ldv_61629; else 
                                                                   
#line 259 
                                                                   goto ldv_61631;
              ldv_61631: 
#line 260 
              ;
              
#line 258 
              len = 48;
              
#line 259 
              i = 0;
              
#line 259 
              goto ldv_61633;
              ldv_61632: 
#line 260 
              ;
              
#line 260 
              memcpy((void *)p,(void const *)(*(vsi->rx_rings + i))->__anonCompField_i40e_ring_121.rx_bi,(unsigned long)len);
              
#line 261 
              p += len;
              
#line 259 
              i += 1;
              ldv_61633: 
#line 260 
              ;
              
#line 259 
              if ((int)vsi->num_queue_pairs > i) 
#line 261 
                                                 goto ldv_61632; else 
                                                                   
#line 264 
                                                                   goto ldv_61634;
              ldv_61634: 
#line 265 
              ;
            }
            else ;
            
#line 266 
            len = 32;
            {
              
#line 267 
              struct list_head const *__mptr_1 = (struct list_head const *)vsi->mac_filter_list.next;
              
#line 267 
              tmp_2 = (struct i40e_mac_filter *)__mptr_1;
            }
            
#line 267 
            f = tmp_2;
            
#line 267 
            goto ldv_61640;
            ldv_61639: 
#line 268 
            ;
            
#line 268 
            memcpy((void *)p,(void const *)f,(unsigned long)len);
            
#line 269 
            p += len;
            {
              
#line 267 
              struct list_head const *__mptr_2 = (struct list_head const *)f->list.next;
              
#line 267 
              tmp_3 = (struct i40e_mac_filter *)__mptr_2;
            }
            
#line 267 
            f = tmp_3;
            ldv_61640: 
#line 269 
            ;
            
#line 267 
            if (& f->list != & vsi->mac_filter_list) 
#line 269 
                                                     goto ldv_61639; else 
                                                                    
#line 272 
                                                                    goto ldv_61641;
            ldv_61641: 
#line 273 
            ;
            
#line 272 
            i40e_dbg_dump_data_len = (long)buflen;
            
#line 273 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"VSI seid %ld dumped %d bytes\n",seid,(int)i40e_dbg_dump_data_len);
          }
          else ;
          
#line 277 
          ldv_mutex_unlock_75(& pf->switch_mutex);
        }
        else 
          
#line 278 
          if (seid > 287L) {
            int tmp_5;
            
#line 279 
            struct i40e_veb *veb = (struct i40e_veb *)0;
            
#line 281 
            ldv_mutex_lock_76(& pf->switch_mutex);
            
#line 282 
            veb = i40e_dbg_find_veb(pf,(int)seid);
            
#line 283 
            if (veb == (struct i40e_veb *)0) {
              
#line 284 
              ldv_mutex_unlock_77(& pf->switch_mutex);
              
#line 285 
              goto write_exit;
            }
            else ;
            
#line 288 
            buflen = 272;
            
#line 289 
            tmp_5 = i40e_dbg_prep_dump_buf(pf,buflen);
            
#line 289 
            if (tmp_5 != 0) {
              
#line 290 
              seid_found = (_Bool)1;
              
#line 291 
              memcpy((void *)i40e_dbg_dump_buf,(void const *)veb,(unsigned long)buflen);
              
#line 292 
              i40e_dbg_dump_data_len = (long)buflen;
              
#line 293 
              _dev_info((struct device const *)(& (pf->pdev)->dev),"VEB seid %ld dumped %d bytes\n",seid,(int)i40e_dbg_dump_data_len);
            }
            else ;
            
#line 297 
            ldv_mutex_unlock_78(& pf->switch_mutex);
          }
          else ;
  write_exit: 
#line 300 
  ;
  
#line 301 
  if (! seid_found) 
#line 302 
                    _dev_info((struct device const *)(& (pf->pdev)->dev),"unknown seid %ld\n",seid); else ;
  
#line 304 
  __retres = (long)count;
  return_label: 
#line 304 
                return __retres;
}


#line 307  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct file_operations const i40e_dbg_dump_fops = {.owner = & __this_module, .llseek = (loff_t (*)(struct file *, loff_t , int ))0, .read = & i40e_dbg_dump_read, .write = & i40e_dbg_dump_write, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 321  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static char i40e_dbg_command_buf[256U] = {(char)'\000'};

#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_command_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int bytes_not_copied;
  char *buf;
  int len;
  unsigned long tmp_0;
  
#line 333 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  
#line 335 
  int buf_size = 256;
  
#line 340 
  if (*ppos != 0LL) {
    
#line 341 
    __retres = 0L;
    
#line 341 
    goto return_label;
  }
  else ;
  
#line 342 
  if ((unsigned long)buf_size > count) {
    
#line 343 
    __retres = -28L;
    
#line 343 
    goto return_label;
  }
  else ;
  
#line 345 
  buf = (char *)kzalloc((unsigned long)buf_size,208U);
  
#line 346 
  if (buf == (char *)0) {
    
#line 347 
    __retres = -28L;
    
#line 347 
    goto return_label;
  }
  else ;
  
#line 349 
  len = snprintf(buf,(unsigned long)buf_size,"%s: %s\n",(char *)(& ((*(pf->vsi + (int)pf->lan_vsi))->netdev)->name),(char *)(& i40e_dbg_command_buf));
  
#line 353 
  tmp_0 = copy_to_user((void *)buffer,(void const *)buf,(unsigned long)len);
  
#line 353 
  bytes_not_copied = (int)tmp_0;
  
#line 354 
  kfree((void const *)buf);
  
#line 356 
  if (bytes_not_copied < 0) {
    
#line 357 
    __retres = (long)bytes_not_copied;
    
#line 357 
    goto return_label;
  }
  else ;
  
#line 359 
  *ppos = (long long)len;
  
#line 360 
  __retres = (long)len;
  return_label: 
#line 360 
                return __retres;
}


#line 368  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_vsi_seid(struct i40e_pf *pf, int seid)
{
  struct rtnl_link_stats64 *nstat;
  struct i40e_mac_filter *f;
  struct i40e_vsi *vsi;
  int i;
  struct i40e_mac_filter *tmp;
  struct i40e_mac_filter *tmp_0;
  char *tmp_3;
  char *tmp_4;
  
#line 375 
  vsi = i40e_dbg_find_vsi(pf,seid);
  
#line 376 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 377 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"dump %d: seid not found\n",seid);
    
#line 379 
    goto return_label;
  }
  else ;
  
#line 381 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"vsi seid %d\n",seid);
  
#line 382 
  if (vsi->netdev != (struct net_device *)0) 
#line 383 
                                             _dev_info((struct device const *)(& (pf->pdev)->dev),"    netdev: name = %s\n",(char *)(& (vsi->netdev)->name)); else ;
  
#line 386 
  if (& vsi->active_vlans != (unsigned long (*)[64U])0) 
#line 387 
                                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"    vlgrp: & = %p\n",(unsigned long *)(& vsi->active_vlans)); else ;
  
#line 389 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    netdev_registered = %i, current_netdev_flags = 0x%04x, state = %li flags = 0x%08lx\n",(int)vsi->netdev_registered,vsi->current_netdev_flags,vsi->state,vsi->flags);
  
#line 393 
  if (*(pf->vsi + (int)pf->lan_vsi) == vsi) 
#line 394 
                                            _dev_info((struct device const *)(& (pf->pdev)->dev),"MAC address: %pM SAN MAC: %pM Port MAC: %pM\n",(u8 *)(& pf->hw.mac.addr),(u8 *)(& pf->hw.mac.san_addr),(u8 *)(& pf->hw.mac.port_addr)); else ;
  {
    
#line 398 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 398 
    tmp = (struct i40e_mac_filter *)__mptr;
  }
  
#line 398 
  f = tmp;
  
#line 398 
  goto ldv_61669;
  ldv_61668: 
#line 399 
  ;
  
#line 399 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    mac_filter_list: %pM vid=%d, is_netdev=%d is_vf=%d counter=%d\n",(u8 *)(& f->macaddr),(int)f->vlan,(int)f->is_netdev,(int)f->is_vf,(int)f->counter);
  {
    
#line 398 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 398 
    tmp_0 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 398 
  f = tmp_0;
  ldv_61669: 
#line 400 
  ;
  
#line 398 
  if (& f->list != & vsi->mac_filter_list) 
#line 400 
                                           goto ldv_61668; else 
#line 403 
                                                                goto ldv_61670;
  ldv_61670: 
#line 404 
  ;
  
#line 404 
  nstat = i40e_get_vsi_stats_struct(vsi);
  
#line 405 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats: rx_packets = %lu, rx_bytes = %lu, rx_errors = %lu, rx_dropped = %lu\n",(unsigned long)nstat->rx_packets,(unsigned long)nstat->rx_bytes,(unsigned long)nstat->rx_errors,(unsigned long)nstat->rx_dropped);
  
#line 411 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats: tx_packets = %lu, tx_bytes = %lu, tx_errors = %lu, tx_dropped = %lu\n",(unsigned long)nstat->tx_packets,(unsigned long)nstat->tx_bytes,(unsigned long)nstat->tx_errors,(unsigned long)nstat->tx_dropped);
  
#line 417 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats: multicast = %lu, collisions = %lu\n",(unsigned long)nstat->multicast,(unsigned long)nstat->collisions);
  
#line 421 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats: rx_length_errors = %lu, rx_over_errors = %lu, rx_crc_errors = %lu\n",(unsigned long)nstat->rx_length_errors,(unsigned long)nstat->rx_over_errors,(unsigned long)nstat->rx_crc_errors);
  
#line 426 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats: rx_frame_errors = %lu, rx_fifo_errors = %lu, rx_missed_errors = %lu\n",(unsigned long)nstat->rx_frame_errors,(unsigned long)nstat->rx_fifo_errors,(unsigned long)nstat->rx_missed_errors);
  
#line 431 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats: tx_aborted_errors = %lu, tx_carrier_errors = %lu, tx_fifo_errors = %lu\n",(unsigned long)nstat->tx_aborted_errors,(unsigned long)nstat->tx_carrier_errors,(unsigned long)nstat->tx_fifo_errors);
  
#line 436 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats: tx_heartbeat_errors = %lu, tx_window_errors = %lu\n",(unsigned long)nstat->tx_heartbeat_errors,(unsigned long)nstat->tx_window_errors);
  
#line 440 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats: rx_compressed = %lu, tx_compressed = %lu\n",(unsigned long)nstat->rx_compressed,(unsigned long)nstat->tx_compressed);
  
#line 444 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats_offsets: rx_packets = %lu, rx_bytes = %lu, rx_errors = %lu, rx_dropped = %lu\n",(unsigned long)vsi->net_stats_offsets.rx_packets,(unsigned long)vsi->net_stats_offsets.rx_bytes,(unsigned long)vsi->net_stats_offsets.rx_errors,(unsigned long)vsi->net_stats_offsets.rx_dropped);
  
#line 450 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats_offsets: tx_packets = %lu, tx_bytes = %lu, tx_errors = %lu, tx_dropped = %lu\n",(unsigned long)vsi->net_stats_offsets.tx_packets,(unsigned long)vsi->net_stats_offsets.tx_bytes,(unsigned long)vsi->net_stats_offsets.tx_errors,(unsigned long)vsi->net_stats_offsets.tx_dropped);
  
#line 456 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats_offsets: multicast = %lu, collisions = %lu\n",(unsigned long)vsi->net_stats_offsets.multicast,(unsigned long)vsi->net_stats_offsets.collisions);
  
#line 460 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats_offsets: rx_length_errors = %lu, rx_over_errors = %lu, rx_crc_errors = %lu\n",(unsigned long)vsi->net_stats_offsets.rx_length_errors,(unsigned long)vsi->net_stats_offsets.rx_over_errors,(unsigned long)vsi->net_stats_offsets.rx_crc_errors);
  
#line 465 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats_offsets: rx_frame_errors = %lu, rx_fifo_errors = %lu, rx_missed_errors = %lu\n",(unsigned long)vsi->net_stats_offsets.rx_frame_errors,(unsigned long)vsi->net_stats_offsets.rx_fifo_errors,(unsigned long)vsi->net_stats_offsets.rx_missed_errors);
  
#line 470 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats_offsets: tx_aborted_errors = %lu, tx_carrier_errors = %lu, tx_fifo_errors = %lu\n",(unsigned long)vsi->net_stats_offsets.tx_aborted_errors,(unsigned long)vsi->net_stats_offsets.tx_carrier_errors,(unsigned long)vsi->net_stats_offsets.tx_fifo_errors);
  
#line 475 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats_offsets: tx_heartbeat_errors = %lu, tx_window_errors = %lu\n",(unsigned long)vsi->net_stats_offsets.tx_heartbeat_errors,(unsigned long)vsi->net_stats_offsets.tx_window_errors);
  
#line 479 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    net_stats_offsets: rx_compressed = %lu, tx_compressed = %lu\n",(unsigned long)vsi->net_stats_offsets.rx_compressed,(unsigned long)vsi->net_stats_offsets.tx_compressed);
  
#line 483 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_restart = %d, tx_busy = %d, rx_buf_failed = %d, rx_page_failed = %d\n",vsi->tx_restart,vsi->tx_busy,vsi->rx_buf_failed,vsi->rx_page_failed);
  
#line 487 
  rcu_read_lock();
  
#line 488 
  i = 0;
  
#line 488 
  goto ldv_61676;
  ldv_61675: 
#line 489 
  ;
  {
    struct i40e_ring * volatile *tmp_1;
    {
      
#line 489 
      struct i40e_ring *__var = (struct i40e_ring *)0;
      
#line 489 
      tmp_1 = (struct i40e_ring * volatile *)(vsi->rx_rings + i);
    }
    
#line 489 
    struct i40e_ring *rx_ring = *tmp_1;
    
#line 490 
    if (rx_ring == (struct i40e_ring *)0) 
#line 491 
                                          goto ldv_61674; else ;
    
#line 493 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: desc = %p\n",i,rx_ring->desc);
    
#line 496 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: dev = %p, netdev = %p, rx_bi = %p\n",i,rx_ring->dev,rx_ring->netdev,rx_ring->__anonCompField_i40e_ring_121.rx_bi);
    
#line 501 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: state = %li, queue_index = %d, reg_idx = %d\n",i,rx_ring->state,(int)rx_ring->queue_index,(int)rx_ring->reg_idx);
    
#line 506 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: rx_hdr_len = %d, rx_buf_len = %d, dtype = %d\n",i,(int)rx_ring->rx_hdr_len,(int)rx_ring->rx_buf_len,(int)rx_ring->dtype);
    
#line 511 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: hsplit = %d, next_to_use = %d, next_to_clean = %d, ring_active = %i\n",i,(int)rx_ring->hsplit,(int)rx_ring->next_to_use,(int)rx_ring->next_to_clean,(int)rx_ring->ring_active);
    
#line 517 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: rx_stats: packets = %lld, bytes = %lld, non_eop_descs = %lld\n",i,rx_ring->stats.packets,rx_ring->stats.bytes,rx_ring->__anonCompField_i40e_ring_122.rx_stats.non_eop_descs);
    
#line 522 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: rx_stats: alloc_page_failed = %lld, alloc_buff_failed = %lld\n",i,rx_ring->__anonCompField_i40e_ring_122.rx_stats.alloc_page_failed,rx_ring->__anonCompField_i40e_ring_122.rx_stats.alloc_buff_failed);
    
#line 527 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: size = %i, dma = 0x%08lx\n",i,rx_ring->size,(unsigned long)rx_ring->dma);
    
#line 531 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_rings[%i]: vsi = %p, q_vector = %p\n",i,rx_ring->vsi,rx_ring->q_vector);
  }
  ldv_61674: 
#line 533 
  ;
  
#line 488 
  i += 1;
  ldv_61676: 
#line 489 
  ;
  
#line 488 
  if ((int)vsi->num_queue_pairs > i) 
#line 490 
                                     goto ldv_61675; else 
#line 493 
                                                          goto ldv_61677;
  ldv_61677: 
#line 494 
  ;
  
#line 536 
  i = 0;
  
#line 536 
  goto ldv_61683;
  ldv_61682: 
#line 537 
  ;
  {
    struct i40e_ring * volatile *tmp_2;
    {
      
#line 537 
      struct i40e_ring *__var_0 = (struct i40e_ring *)0;
      
#line 537 
      tmp_2 = (struct i40e_ring * volatile *)(vsi->tx_rings + i);
    }
    
#line 537 
    struct i40e_ring *tx_ring = *tmp_2;
    
#line 538 
    if (tx_ring == (struct i40e_ring *)0) 
#line 539 
                                          goto ldv_61681; else ;
    
#line 541 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: desc = %p\n",i,tx_ring->desc);
    
#line 544 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: dev = %p, netdev = %p, tx_bi = %p\n",i,tx_ring->dev,tx_ring->netdev,tx_ring->__anonCompField_i40e_ring_121.tx_bi);
    
#line 549 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: state = %li, queue_index = %d, reg_idx = %d\n",i,tx_ring->state,(int)tx_ring->queue_index,(int)tx_ring->reg_idx);
    
#line 554 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: dtype = %d\n",i,(int)tx_ring->dtype);
    
#line 557 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: hsplit = %d, next_to_use = %d, next_to_clean = %d, ring_active = %i\n",i,(int)tx_ring->hsplit,(int)tx_ring->next_to_use,(int)tx_ring->next_to_clean,(int)tx_ring->ring_active);
    
#line 563 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: tx_stats: packets = %lld, bytes = %lld, restart_queue = %lld\n",i,tx_ring->stats.packets,tx_ring->stats.bytes,tx_ring->__anonCompField_i40e_ring_122.tx_stats.restart_queue);
    
#line 568 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: tx_stats: tx_busy = %lld, tx_done_old = %lld\n",i,tx_ring->__anonCompField_i40e_ring_122.tx_stats.tx_busy,tx_ring->__anonCompField_i40e_ring_122.tx_stats.tx_done_old);
    
#line 573 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: size = %i, dma = 0x%08lx\n",i,tx_ring->size,(unsigned long)tx_ring->dma);
    
#line 577 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: vsi = %p, q_vector = %p\n",i,tx_ring->vsi,tx_ring->q_vector);
    
#line 581 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_rings[%i]: DCB tc = %d\n",i,(int)tx_ring->dcb_tc);
  }
  ldv_61681: 
#line 583 
  ;
  
#line 536 
  i += 1;
  ldv_61683: 
#line 537 
  ;
  
#line 536 
  if ((int)vsi->num_queue_pairs > i) 
#line 538 
                                     goto ldv_61682; else 
#line 541 
                                                          goto ldv_61684;
  ldv_61684: 
#line 542 
  ;
  
#line 585 
  rcu_read_unlock();
  
#line 586 
  if ((int)vsi->tx_itr_setting < 0) 
#line 586 
                                    tmp_3 = (char *)"dynamic"; else 
#line 586 
                                                                    tmp_3 = (char *)"fixed";
  
#line 586 
  ;
  
#line 586 
  if ((int)vsi->rx_itr_setting < 0) 
#line 586 
                                    tmp_4 = (char *)"dynamic"; else 
#line 586 
                                                                    tmp_4 = (char *)"fixed";
  
#line 586 
  ;
  
#line 586 
  ;
  
#line 586 
  ;
  
#line 586 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    work_limit = %d, rx_itr_setting = %d (%s), tx_itr_setting = %d (%s)\n",(int)vsi->work_limit,(int)vsi->rx_itr_setting,tmp_4,(int)vsi->tx_itr_setting,tmp_3);
  
#line 592 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    max_frame = %d, rx_hdr_len = %d, rx_buf_len = %d dtype = %d\n",(int)vsi->max_frame,(int)vsi->rx_hdr_len,(int)vsi->rx_buf_len,(int)vsi->dtype);
  
#line 595 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    num_q_vectors = %i, base_vector = %i\n",vsi->num_q_vectors,vsi->base_vector);
  
#line 598 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    seid = %d, id = %d, uplink_seid = %d\n",(int)vsi->seid,(int)vsi->id,(int)vsi->uplink_seid);
  
#line 601 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    base_queue = %d, num_queue_pairs = %d, num_desc = %d\n",(int)vsi->base_queue,(int)vsi->num_queue_pairs,(int)vsi->num_desc);
  
#line 604 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    type = %i\n",(unsigned int)vsi->type);
  
#line 605 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: valid_sections = 0x%04x, switch_id = 0x%04x\n",(int)vsi->info.valid_sections,(int)vsi->info.switch_id);
  
#line 608 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: sw_reserved[] = 0x%02x 0x%02x\n",(int)vsi->info.sw_reserved[0],(int)vsi->info.sw_reserved[1]);
  
#line 611 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: sec_flags = 0x%02x, sec_reserved = 0x%02x\n",(int)vsi->info.sec_flags,(int)vsi->info.sec_reserved);
  
#line 614 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: pvid = 0x%04x, fcoe_pvid = 0x%04x, port_vlan_flags = 0x%02x\n",(int)vsi->info.pvid,(int)vsi->info.fcoe_pvid,(int)vsi->info.port_vlan_flags);
  
#line 618 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: pvlan_reserved[] = 0x%02x 0x%02x 0x%02x\n",(int)vsi->info.pvlan_reserved[0],(int)vsi->info.pvlan_reserved[1],(int)vsi->info.pvlan_reserved[2]);
  
#line 622 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: ingress_table = 0x%08x, egress_table = 0x%08x\n",vsi->info.ingress_table,vsi->info.egress_table);
  
#line 625 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: cas_pv_stag = 0x%04x, cas_pv_flags= 0x%02x, cas_pv_reserved = 0x%02x\n",(int)vsi->info.cas_pv_tag,(int)vsi->info.cas_pv_flags,(int)vsi->info.cas_pv_reserved);
  
#line 629 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: queue_mapping[0..7 ] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",(int)vsi->info.queue_mapping[0],(int)vsi->info.queue_mapping[1],(int)vsi->info.queue_mapping[2],(int)vsi->info.queue_mapping[3],(int)vsi->info.queue_mapping[4],(int)vsi->info.queue_mapping[5],(int)vsi->info.queue_mapping[6],(int)vsi->info.queue_mapping[7]);
  
#line 635 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: queue_mapping[8..15] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",(int)vsi->info.queue_mapping[8],(int)vsi->info.queue_mapping[9],(int)vsi->info.queue_mapping[10],(int)vsi->info.queue_mapping[11],(int)vsi->info.queue_mapping[12],(int)vsi->info.queue_mapping[13],(int)vsi->info.queue_mapping[14],(int)vsi->info.queue_mapping[15]);
  
#line 641 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: tc_mapping[] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",(int)vsi->info.tc_mapping[0],(int)vsi->info.tc_mapping[1],(int)vsi->info.tc_mapping[2],(int)vsi->info.tc_mapping[3],(int)vsi->info.tc_mapping[4],(int)vsi->info.tc_mapping[5],(int)vsi->info.tc_mapping[6],(int)vsi->info.tc_mapping[7]);
  
#line 647 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: queueing_opt_flags = 0x%02x  queueing_opt_reserved[0..2] = 0x%02x 0x%02x 0x%02x\n",(int)vsi->info.queueing_opt_flags,(int)vsi->info.queueing_opt_reserved[0],(int)vsi->info.queueing_opt_reserved[1],(int)vsi->info.queueing_opt_reserved[2]);
  
#line 653 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: up_enable_bits = 0x%02x\n",(int)vsi->info.up_enable_bits);
  
#line 656 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: sched_reserved = 0x%02x, outer_up_table = 0x%04x\n",(int)vsi->info.sched_reserved,vsi->info.outer_up_table);
  
#line 659 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: cmd_reserved[] = 0x%02x 0x%02x 0x%02x 0x0%02x 0x%02x 0x%02x 0x%02x 0x0%02x\n",(int)vsi->info.cmd_reserved[0],(int)vsi->info.cmd_reserved[1],(int)vsi->info.cmd_reserved[2],(int)vsi->info.cmd_reserved[3],(int)vsi->info.cmd_reserved[4],(int)vsi->info.cmd_reserved[5],(int)vsi->info.cmd_reserved[6],(int)vsi->info.cmd_reserved[7]);
  
#line 665 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: qs_handle[] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",(int)vsi->info.qs_handle[0],(int)vsi->info.qs_handle[1],(int)vsi->info.qs_handle[2],(int)vsi->info.qs_handle[3],(int)vsi->info.qs_handle[4],(int)vsi->info.qs_handle[5],(int)vsi->info.qs_handle[6],(int)vsi->info.qs_handle[7]);
  
#line 671 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: stat_counter_idx = 0x%04x, sched_id = 0x%04x\n",(int)vsi->info.stat_counter_idx,(int)vsi->info.sched_id);
  
#line 674 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    info: resp_reserved[] = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",(int)vsi->info.resp_reserved[0],(int)vsi->info.resp_reserved[1],(int)vsi->info.resp_reserved[2],(int)vsi->info.resp_reserved[3],(int)vsi->info.resp_reserved[4],(int)vsi->info.resp_reserved[5],(int)vsi->info.resp_reserved[6],(int)vsi->info.resp_reserved[7],(int)vsi->info.resp_reserved[8],(int)vsi->info.resp_reserved[9],(int)vsi->info.resp_reserved[10],(int)vsi->info.resp_reserved[11]);
  
#line 682 
  if (vsi->back != (struct i40e_pf *)0) 
#line 683 
                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"    PF = %p\n",vsi->back); else ;
  
#line 684 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    idx = %d\n",(int)vsi->idx);
  
#line 685 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    tc_config: numtc = %d, enabled_tc = 0x%x\n",(int)vsi->tc_config.numtc,(int)vsi->tc_config.enabled_tc);
  
#line 688 
  i = 0;
  
#line 688 
  goto ldv_61686;
  ldv_61685: 
#line 689 
  ;
  
#line 689 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    tc_config: tc = %d, qoffset = %d, qcount = %d, netdev_tc = %d\n",i,(int)vsi->tc_config.tc_info[i].qoffset,(int)vsi->tc_config.tc_info[i].qcount,(int)vsi->tc_config.tc_info[i].netdev_tc);
  
#line 688 
  i += 1;
  ldv_61686: 
#line 689 
  ;
  
#line 688 
  if (i <= 7) 
#line 690 
              goto ldv_61685; else 
#line 693 
                                   goto ldv_61687;
  ldv_61687: 
#line 694 
  ;
  
#line 695 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    bw: bw_limit = %d, bw_max_quanta = %d\n",(int)vsi->bw_limit,(int)vsi->bw_max_quanta);
  
#line 698 
  i = 0;
  
#line 698 
  goto ldv_61689;
  ldv_61688: 
#line 699 
  ;
  
#line 699 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    bw[%d]: ets_share_credits = %d, ets_limit_credits = %d, max_quanta = %d\n",i,(int)vsi->bw_ets_share_credits[i],(int)vsi->bw_ets_limit_credits[i],(int)vsi->bw_ets_max_quanta[i]);
  
#line 698 
  i += 1;
  ldv_61689: 
#line 699 
  ;
  
#line 698 
  if (i <= 7) 
#line 700 
              goto ldv_61688; else 
#line 703 
                                   goto ldv_61690;
  ldv_61690: 
#line 704 
  ;
  
#line 706 
  if (vsi->type == (unsigned int)I40E_VSI_FCOE) {
    
#line 707 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    fcoe_stats: rx_packets = %llu, rx_dwords = %llu, rx_dropped = %llu\n",vsi->fcoe_stats.rx_fcoe_packets,vsi->fcoe_stats.rx_fcoe_dwords,vsi->fcoe_stats.rx_fcoe_dropped);
    
#line 712 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    fcoe_stats: tx_packets = %llu, tx_dwords = %llu\n",vsi->fcoe_stats.tx_fcoe_packets,vsi->fcoe_stats.tx_fcoe_dwords);
    
#line 716 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    fcoe_stats: bad_crc = %llu, last_error = %llu\n",vsi->fcoe_stats.fcoe_bad_fccrc,vsi->fcoe_stats.fcoe_last_error);
    
#line 720 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"    fcoe_stats: ddp_count = %llu\n",vsi->fcoe_stats.fcoe_ddp_count);
  }
  else ;
  return_label: 
#line 722 
                return;
}


#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_aq_desc(struct i40e_pf *pf)
{
  struct i40e_adminq_ring *ring;
  char hdr[32U];
  int i;
  char const *tmp;
  char const *tmp_0;
  
#line 733 
  struct i40e_hw *hw = & pf->hw;
  
#line 738 
  tmp = dev_name((struct device const *)(& (pf->pdev)->dev));
  
#line 737 
  tmp_0 = dev_driver_string((struct device const *)(& (pf->pdev)->dev));
  
#line 737 
  snprintf((char *)(& hdr),32UL,"%s %s:         ",tmp_0,tmp);
  
#line 742 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"AdminQ Tx Ring\n");
  
#line 743 
  ring = & hw->aq.asq;
  
#line 744 
  i = 0;
  
#line 744 
  goto ldv_61700;
  ldv_61699: 
#line 745 
  ;
  {
    
#line 745 
    struct i40e_aq_desc *d = (struct i40e_aq_desc *)ring->desc_buf.va + i;
    
#line 746 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"   at[%02d] flags=0x%04x op=0x%04x dlen=0x%04x ret=0x%04x cookie_h=0x%08x cookie_l=0x%08x\n",i,(int)d->flags,(int)d->opcode,(int)d->datalen,(int)d->retval,d->cookie_high,d->cookie_low);
    
#line 750 
    print_hex_dump("\001",(char const *)(& hdr),0,16,1,(void const *)(& d->params.raw),16UL,(_Bool)0);
  }
  
#line 744 
  i += 1;
  ldv_61700: 
#line 745 
  ;
  
#line 744 
  if ((int)ring->count > i) 
#line 746 
                            goto ldv_61699; else 
#line 749 
                                                 goto ldv_61701;
  ldv_61701: 
#line 750 
  ;
  
#line 754 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"AdminQ Rx Ring\n");
  
#line 755 
  ring = & hw->aq.arq;
  
#line 756 
  i = 0;
  
#line 756 
  goto ldv_61704;
  ldv_61703: 
#line 757 
  ;
  {
    
#line 757 
    struct i40e_aq_desc *d_0 = (struct i40e_aq_desc *)ring->desc_buf.va + i;
    
#line 758 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"   ar[%02d] flags=0x%04x op=0x%04x dlen=0x%04x ret=0x%04x cookie_h=0x%08x cookie_l=0x%08x\n",i,(int)d_0->flags,(int)d_0->opcode,(int)d_0->datalen,(int)d_0->retval,d_0->cookie_high,d_0->cookie_low);
    
#line 762 
    print_hex_dump("\001",(char const *)(& hdr),0,16,1,(void const *)(& d_0->params.raw),16UL,(_Bool)0);
  }
  
#line 756 
  i += 1;
  ldv_61704: 
#line 757 
  ;
  
#line 756 
  if ((int)ring->count > i) 
#line 758 
                            goto ldv_61703; else 
#line 761 
                                                 goto ldv_61705;
  ldv_61705: 
#line 762 
  ;
  
#line 763 
  return;
}


#line 776  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_desc(int cnt, int vsi_seid, int ring_id, int desc_n, struct i40e_pf *pf, bool is_rx_ring)
{
  struct i40e_tx_desc *txd;
  union i40e_32byte_rx_desc *rxd;
  struct i40e_ring *ring;
  struct i40e_vsi *vsi;
  int i;
  void *tmp_0;
  struct i40e_ring *tmp;
  
#line 785 
  vsi = i40e_dbg_find_vsi(pf,vsi_seid);
  
#line 786 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 787 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"vsi %d not found\n",vsi_seid);
    
#line 788 
    goto return_label;
  }
  else ;
  
#line 790 
  if ((int)vsi->num_queue_pairs <= ring_id || ring_id < 0) {
    
#line 791 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ring %d not found\n",ring_id);
    
#line 792 
    goto return_label;
  }
  else ;
  
#line 794 
  if (vsi->tx_rings == (struct i40e_ring **)0 || (*(vsi->tx_rings))->desc == (void *)0) {
    
#line 795 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"descriptor rings have not been allocated for vsi %d\n",vsi_seid);
    
#line 798 
    goto return_label;
  }
  else ;
  
#line 802 
  if ((int)is_rx_ring != 0) 
#line 802 
                            tmp = *(vsi->rx_rings + ring_id); else 
#line 802 
                                                                   tmp = *(vsi->tx_rings + ring_id);
  
#line 801 
  tmp_0 = kmemdup((void const *)tmp,4096UL,208U);
  
#line 801 
  ring = (struct i40e_ring *)tmp_0;
  
#line 804 
  if (ring == (struct i40e_ring *)0) 
#line 805 
                                     goto return_label; else ;
  
#line 807 
  if (cnt == 2) {
    char *tmp_1;
    
#line 808 
    ;
    
#line 808 
    if ((int)is_rx_ring != 0) 
#line 808 
                              tmp_1 = (char *)"rx"; else 
#line 808 
                                                         tmp_1 = (char *)"tx";
    
#line 808 
    ;
    
#line 808 
    ;
    
#line 808 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"vsi = %02i %s ring = %02i\n",vsi_seid,tmp_1,ring_id);
    
#line 810 
    i = 0;
    
#line 810 
    goto ldv_61720;
    ldv_61719: 
#line 811 
    ;
    
#line 811 
    if (! is_rx_ring) {
      
#line 812 
      txd = (struct i40e_tx_desc *)ring->desc + i;
      
#line 813 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"   d[%03i] = 0x%016llx 0x%016llx\n",i,txd->buffer_addr,txd->cmd_type_offset_bsz);
    }
    else {
      
#line 825 
      constant_test_bit(5L,(unsigned long const volatile *)(& ring->state));
      
#line 825 
      rxd = (union i40e_32byte_rx_desc *)ring->desc + i;
      
#line 826 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"   d[%03i] = 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n",i,rxd->read.pkt_addr,rxd->read.hdr_addr,rxd->read.rsvd1,rxd->read.rsvd2);
    }
    
#line 810 
    i += 1;
    ldv_61720: 
#line 811 
    ;
    
#line 810 
    if ((int)ring->count > i) 
#line 812 
                              goto ldv_61719; else 
#line 815 
                                                   goto ldv_61721;
    ldv_61721: 
#line 816 
    ;
  }
  else 
    
#line 833 
    if (cnt == 3) {
      
#line 834 
      if ((int)ring->count <= desc_n || desc_n < 0) {
        
#line 835 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"descriptor %d not found\n",desc_n);
        
#line 837 
        goto out;
      }
      else ;
      
#line 839 
      if (! is_rx_ring) {
        
#line 840 
        txd = (struct i40e_tx_desc *)ring->desc + desc_n;
        
#line 841 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"vsi = %02i tx ring = %02i d[%03i] = 0x%016llx 0x%016llx\n",vsi_seid,ring_id,desc_n,txd->buffer_addr,txd->cmd_type_offset_bsz);
      }
      else {
        
#line 853 
        constant_test_bit(5L,(unsigned long const volatile *)(& ring->state));
        
#line 853 
        rxd = (union i40e_32byte_rx_desc *)ring->desc + desc_n;
        
#line 854 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"vsi = %02i rx ring = %02i d[%03i] = 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n",vsi_seid,ring_id,desc_n,rxd->read.pkt_addr,rxd->read.hdr_addr,rxd->read.rsvd1,rxd->read.rsvd2);
      }
    }
    else 
#line 861 
         _dev_info((struct device const *)(& (pf->pdev)->dev),"dump desc rx/tx <vsi_seid> <ring_id> [<desc_n>]\n");
  out: 
#line 864 
  ;
  
#line 865 
  kfree((void const *)ring);
  return_label: 
#line 866 
                return;
}


#line 872  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_vsi_no_seid(struct i40e_pf *pf)
{
  int i;
  
#line 876 
  i = 0;
  
#line 876 
  goto ldv_61728;
  ldv_61727: 
#line 877 
  ;
  
#line 877 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0) 
#line 878 
                                              _dev_info((struct device const *)(& (pf->pdev)->dev),"dump vsi[%d]: %d\n",i,(int)(*(pf->vsi + i))->seid); else ;
  
#line 876 
  i += 1;
  ldv_61728: 
#line 877 
  ;
  
#line 876 
  if ((int)pf->num_alloc_vsi > i) 
#line 878 
                                  goto ldv_61727; else 
#line 881 
                                                       goto ldv_61729;
  ldv_61729: 
#line 882 
  ;
  
#line 883 
  return;
}


#line 887  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_eth_stats(struct i40e_pf *pf, struct i40e_eth_stats *estats)
{
  
#line 890 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"  ethstats:\n");
  
#line 891 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_bytes = \t%lld \trx_unicast = \t\t%lld \trx_multicast = \t%lld\n",estats->rx_bytes,estats->rx_unicast,estats->rx_multicast);
  
#line 894 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_broadcast = \t%lld \trx_discards = \t\t%lld\n",estats->rx_broadcast,estats->rx_discards);
  
#line 897 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    rx_unknown_protocol = \t%lld \ttx_bytes = \t%lld\n",estats->rx_unknown_protocol,estats->tx_bytes);
  
#line 900 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_unicast = \t%lld \ttx_multicast = \t\t%lld \ttx_broadcast = \t%lld\n",estats->tx_unicast,estats->tx_multicast,estats->tx_broadcast);
  
#line 903 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"    tx_discards = \t%lld \ttx_errors = \t\t%lld\n",estats->tx_discards,estats->tx_errors);
  
#line 904 
  return;
}


#line 913  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_veb_seid(struct i40e_pf *pf, int seid)
{
  struct i40e_veb *veb;
  char *tmp;
  
#line 917 
  if ((unsigned int)seid + 4294967008U > 15U) {
    
#line 919 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%d: bad seid\n",seid);
    
#line 920 
    goto return_label;
  }
  else ;
  
#line 923 
  veb = i40e_dbg_find_veb(pf,seid);
  
#line 924 
  if (veb == (struct i40e_veb *)0) {
    
#line 925 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"can\'t find veb %d\n",seid);
    
#line 926 
    goto return_label;
  }
  else ;
  
#line 928 
  if ((unsigned int)veb->bridge_mode == 1U) 
#line 928 
                                            tmp = (char *)"VEPA"; else 
                                                                    
#line 928 
                                                                    tmp = (char *)"VEB";
  
#line 928 
  ;
  
#line 928 
  ;
  
#line 928 
  ;
  
#line 928 
  ;
  
#line 928 
  ;
  
#line 928 
  ;
  
#line 928 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"veb idx=%d,%d stats_ic=%d  seid=%d uplink=%d mode=%s\n",(int)veb->idx,(int)veb->veb_idx,(int)veb->stats_idx,(int)veb->seid,(int)veb->uplink_seid,tmp);
  
#line 933 
  i40e_dbg_dump_eth_stats(pf,& veb->stats);
  return_label: 
#line 934 
                return;
}


#line 940  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_veb_all(struct i40e_pf *pf)
{
  struct i40e_veb *veb;
  int i;
  
#line 945 
  i = 0;
  
#line 945 
  goto ldv_61745;
  ldv_61744: 
#line 946 
  ;
  
#line 946 
  veb = pf->veb[i];
  
#line 947 
  if (veb != (struct i40e_veb *)0) 
#line 948 
                                   i40e_dbg_dump_veb_seid(pf,(int)veb->seid); else ;
  
#line 945 
  i += 1;
  ldv_61745: 
#line 946 
  ;
  
#line 945 
  if (i <= 15) 
#line 947 
               goto ldv_61744; else 
#line 950 
                                    goto ldv_61746;
  ldv_61746: 
#line 951 
  ;
  
#line 952 
  return;
}


#line 958  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_cmd_fd_ctrl(struct i40e_pf *pf, u64 flag, bool enable)
{
  
#line 960 
  if ((int)enable != 0) 
#line 961 
                        pf->flags |= flag;
  else {
    
#line 963 
    pf->flags &= ~ flag;
    
#line 964 
    pf->auto_disable_flags |= flag;
  }
  
#line 966 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"requesting a PF reset\n");
  
#line 967 
  i40e_do_reset_safe(pf,4096U);
  
#line 968 
  return;
}


#line 978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_command_write(struct file *filp, char const *buffer, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  char *cmd_buf;
  char *cmd_buf_tmp;
  int bytes_not_copied;
  struct i40e_vsi *vsi;
  int vsi_seid;
  int veb_seid;
  int cnt;
  unsigned long tmp_0;
  int tmp_76;
  
#line 982 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  
#line 991 
  if (*ppos != 0LL) {
    
#line 992 
    __retres = 0L;
    
#line 992 
    goto return_label;
  }
  else ;
  
#line 994 
  cmd_buf = (char *)kzalloc(count + 1UL,208U);
  
#line 995 
  if (cmd_buf == (char *)0) {
    
#line 996 
    __retres = (long)count;
    
#line 996 
    goto return_label;
  }
  else ;
  
#line 997 
  tmp_0 = copy_from_user((void *)cmd_buf,(void const *)buffer,count);
  
#line 997 
  bytes_not_copied = (int)tmp_0;
  
#line 998 
  if (bytes_not_copied < 0) {
    
#line 999 
    kfree((void const *)cmd_buf);
    
#line 1000 
    __retres = (long)bytes_not_copied;
    
#line 1000 
    goto return_label;
  }
  else ;
  
#line 1002 
  if (bytes_not_copied > 0) 
#line 1003 
                            count -= (unsigned long)bytes_not_copied; else ;
  
#line 1004 
  *(cmd_buf + count) = (char)0;
  
#line 1006 
  cmd_buf_tmp = strchr((char const *)cmd_buf,10);
  
#line 1007 
  if (cmd_buf_tmp != (char *)0) {
    
#line 1008 
    *cmd_buf_tmp = (char)0;
    
#line 1009 
    count = (unsigned long)(((long)cmd_buf_tmp - (long)cmd_buf) + 1L);
  }
  else ;
  
#line 1012 
  tmp_76 = strncmp((char const *)cmd_buf,"add vsi",7UL);
  
#line 1012 
  if (tmp_76 == 0) {
    
#line 1013 
    vsi_seid = -1;
    
#line 1014 
    cnt = sscanf((char const *)(cmd_buf + 7U),"%i",& vsi_seid);
    
#line 1015 
    if (cnt == 0) 
#line 1017 
                  vsi_seid = (int)(*(pf->vsi + (int)pf->lan_vsi))->seid;
    else 
      
#line 1018 
      if (vsi_seid < 0) {
        
#line 1019 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"add VSI %d: bad vsi seid\n",vsi_seid);
        
#line 1021 
        goto command_write_done;
      }
      else ;
    
#line 1027 
    if ((pf->flags & 1099511627776ULL) == 0ULL) {
      
#line 1028 
      pf->flags |= 1099511627776ULL;
      
#line 1029 
      i40e_do_reset_safe(pf,4096U);
    }
    else ;
    
#line 1033 
    vsi = i40e_vsi_setup(pf,(unsigned char)2,(unsigned short)((int)((unsigned short)vsi_seid)),0U);
    
#line 1034 
    if (vsi != (struct i40e_vsi *)0) 
#line 1035 
                                     _dev_info((struct device const *)(& (pf->pdev)->dev),"added VSI %d to relay %d\n",(int)vsi->seid,(int)vsi->uplink_seid); else 
                                                                    
#line 1038 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"\'%s\' failed\n",cmd_buf);
  }
  else {
    int tmp_75;
    
#line 1040 
    tmp_75 = strncmp((char const *)cmd_buf,"del vsi",7UL);
    
#line 1040 
    if (tmp_75 == 0) {
      
#line 1041 
      sscanf((char const *)(cmd_buf + 7U),"%i",& vsi_seid);
      
#line 1042 
      vsi = i40e_dbg_find_vsi(pf,vsi_seid);
      
#line 1043 
      if (vsi == (struct i40e_vsi *)0) {
        
#line 1044 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"del VSI %d: seid not found\n",vsi_seid);
        
#line 1046 
        goto command_write_done;
      }
      else ;
      
#line 1049 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"deleting VSI %d\n",vsi_seid);
      
#line 1050 
      i40e_vsi_release(vsi);
    }
    else {
      int tmp_74;
      
#line 1052 
      tmp_74 = strncmp((char const *)cmd_buf,"add relay",9UL);
      
#line 1052 
      if (tmp_74 == 0) {
        struct i40e_veb *veb;
        int uplink_seid;
        int i;
        
#line 1056 
        cnt = sscanf((char const *)(cmd_buf + 9U),"%i %i",& uplink_seid,& vsi_seid);
        
#line 1057 
        if (cnt != 2) {
          
#line 1058 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"add relay: bad command string, cnt=%d\n",cnt);
          
#line 1061 
          goto command_write_done;
        }
        else 
          
#line 1062 
          if (uplink_seid < 0) {
            
#line 1063 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"add relay %d: bad uplink seid\n",uplink_seid);
            
#line 1066 
            goto command_write_done;
          }
          else ;
        
#line 1069 
        vsi = i40e_dbg_find_vsi(pf,vsi_seid);
        
#line 1070 
        if (vsi == (struct i40e_vsi *)0) {
          
#line 1071 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"add relay: VSI %d not found\n",vsi_seid);
          
#line 1073 
          goto command_write_done;
        }
        else ;
        
#line 1076 
        i = 0;
        
#line 1076 
        goto ldv_61772;
        ldv_61771: 
#line 1077 
        ;
        
#line 1077 
        if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == uplink_seid) 
          
#line 1078 
          goto ldv_61770; else ;
        
#line 1076 
        i += 1;
        ldv_61772: 
#line 1077 
        ;
        
#line 1076 
        if (i <= 15) 
#line 1078 
                     goto ldv_61771; else 
#line 1081 
                                          goto ldv_61770;
        ldv_61770: 
#line 1082 
        ;
        
#line 1079 
        if ((i > 15 && uplink_seid != 0) && (int)pf->mac_seid != uplink_seid) {
          
#line 1081 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"add relay: relay uplink %d not found\n",uplink_seid);
          
#line 1084 
          goto command_write_done;
        }
        else ;
        
#line 1087 
        veb = i40e_veb_setup(pf,(unsigned short)0,(unsigned short)((int)((unsigned short)uplink_seid)),(unsigned short)((int)((unsigned short)vsi_seid)),(unsigned char)((int)vsi->tc_config.enabled_tc));
        
#line 1089 
        if (veb != (struct i40e_veb *)0) 
#line 1090 
                                         _dev_info((struct device const *)(& (pf->pdev)->dev),"added relay %d\n",(int)veb->seid); else 
                                                                    
#line 1092 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"add relay failed\n");
      }
      else {
        int tmp_73;
        
#line 1094 
        tmp_73 = strncmp((char const *)cmd_buf,"del relay",9UL);
        
#line 1094 
        if (tmp_73 == 0) {
          int i_0;
          
#line 1096 
          cnt = sscanf((char const *)(cmd_buf + 9U),"%i",& veb_seid);
          
#line 1097 
          if (cnt != 1) {
            
#line 1098 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"del relay: bad command string, cnt=%d\n",cnt);
            
#line 1101 
            goto command_write_done;
          }
          else 
            
#line 1102 
            if (veb_seid < 0) {
              
#line 1103 
              _dev_info((struct device const *)(& (pf->pdev)->dev),"del relay %d: bad relay seid\n",veb_seid);
              
#line 1105 
              goto command_write_done;
            }
            else ;
          
#line 1109 
          i_0 = 0;
          
#line 1109 
          goto ldv_61776;
          ldv_61775: 
#line 1110 
          ;
          
#line 1110 
          if (pf->veb[i_0] != (struct i40e_veb *)0 && (int)(pf->veb[i_0])->seid == veb_seid) 
            
#line 1111 
            goto ldv_61774; else ;
          
#line 1109 
          i_0 += 1;
          ldv_61776: 
#line 1110 
          ;
          
#line 1109 
          if (i_0 <= 15) 
#line 1111 
                         goto ldv_61775; else 
#line 1114 
                                              goto ldv_61774;
          ldv_61774: 
#line 1115 
          ;
          
#line 1112 
          if (i_0 > 15) {
            
#line 1113 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"del relay: relay %d not found\n",veb_seid);
            
#line 1115 
            goto command_write_done;
          }
          else ;
          
#line 1118 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"deleting relay %d\n",veb_seid);
          
#line 1119 
          i40e_veb_release(pf->veb[i_0]);
        }
        else {
          int tmp_72;
          
#line 1121 
          tmp_72 = strncmp((char const *)cmd_buf,"add macaddr",11UL);
          
#line 1121 
          if (tmp_72 == 0) {
            struct i40e_mac_filter *f;
            u8 ma[6U];
            int ret;
            
#line 1123 
            int vlan = 0;
            
#line 1127 
            cnt = sscanf((char const *)(cmd_buf + 11U),"%i %hhx:%hhx:%hhx:%hhx:%hhx:%hhx %i",& vsi_seid,&(ma[0]),& ma[1],& ma[2],& ma[3],& ma[4],& ma[5],& vlan);
            
#line 1132 
            if (cnt == 7) 
#line 1133 
                          vlan = 0;
            else 
              
#line 1134 
              if (cnt != 8) {
                
#line 1135 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"add macaddr: bad command string, cnt=%d\n",cnt);
                
#line 1138 
                goto command_write_done;
              }
              else ;
            
#line 1141 
            vsi = i40e_dbg_find_vsi(pf,vsi_seid);
            
#line 1142 
            if (vsi == (struct i40e_vsi *)0) {
              
#line 1143 
              _dev_info((struct device const *)(& (pf->pdev)->dev),"add macaddr: VSI %d not found\n",vsi_seid);
              
#line 1145 
              goto command_write_done;
            }
            else ;
            
#line 1148 
            f = i40e_add_filter(vsi,(u8 *)(& ma),(short)((int)((short)vlan)),(_Bool)0,(_Bool)0);
            
#line 1149 
            ret = i40e_sync_vsi_filters(vsi);
            
#line 1150 
            if (f != (struct i40e_mac_filter *)0 && ret == 0) 
#line 1151 
                                                              _dev_info((struct device const *)(& (pf->pdev)->dev),"add macaddr: %pM vlan=%d added to VSI %d\n",(u8 *)(& ma),vlan,vsi_seid); else 
                                                                    
#line 1155 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"add macaddr: %pM vlan=%d to VSI %d failed, f=%p ret=%d\n",(u8 *)(& ma),vlan,vsi_seid,f,ret);
          }
          else {
            int tmp_71;
            
#line 1159 
            tmp_71 = strncmp((char const *)cmd_buf,"del macaddr",11UL);
            
#line 1159 
            if (tmp_71 == 0) {
              u8 ma_0[6U];
              int ret_0;
              
#line 1160 
              int vlan_0 = 0;
              
#line 1164 
              cnt = sscanf((char const *)(cmd_buf + 11U),"%i %hhx:%hhx:%hhx:%hhx:%hhx:%hhx %i",& vsi_seid,&(ma_0[0]),& ma_0[1],& ma_0[2],& ma_0[3],& ma_0[4],& ma_0[5],& vlan_0);
              
#line 1169 
              if (cnt == 7) 
#line 1170 
                            vlan_0 = 0;
              else 
                
#line 1171 
                if (cnt != 8) {
                  
#line 1172 
                  _dev_info((struct device const *)(& (pf->pdev)->dev),"del macaddr: bad command string, cnt=%d\n",cnt);
                  
#line 1175 
                  goto command_write_done;
                }
                else ;
              
#line 1178 
              vsi = i40e_dbg_find_vsi(pf,vsi_seid);
              
#line 1179 
              if (vsi == (struct i40e_vsi *)0) {
                
#line 1180 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"del macaddr: VSI %d not found\n",vsi_seid);
                
#line 1182 
                goto command_write_done;
              }
              else ;
              
#line 1185 
              i40e_del_filter(vsi,(u8 *)(& ma_0),(short)((int)((short)vlan_0)),(_Bool)0,(_Bool)0);
              
#line 1186 
              ret_0 = i40e_sync_vsi_filters(vsi);
              
#line 1187 
              if (ret_0 == 0) 
#line 1188 
                              _dev_info((struct device const *)(& (pf->pdev)->dev),"del macaddr: %pM vlan=%d removed from VSI %d\n",(u8 *)(& ma_0),vlan_0,vsi_seid); else 
                                                                    
#line 1192 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"del macaddr: %pM vlan=%d from VSI %d failed, ret=%d\n",(u8 *)(& ma_0),vlan_0,vsi_seid,ret_0);
            }
            else {
              int tmp_70;
              
#line 1196 
              tmp_70 = strncmp((char const *)cmd_buf,"add pvid",8UL);
              
#line 1196 
              if (tmp_70 == 0) {
                i40e_status ret_1;
                u16 vid;
                unsigned int v;
                
#line 1201 
                cnt = sscanf((char const *)(cmd_buf + 8U),"%i %u",& vsi_seid,& v);
                
#line 1202 
                if (cnt != 2) {
                  
#line 1203 
                  _dev_info((struct device const *)(& (pf->pdev)->dev),"add pvid: bad command string, cnt=%d\n",cnt);
                  
#line 1205 
                  goto command_write_done;
                }
                else ;
                
#line 1208 
                vsi = i40e_dbg_find_vsi(pf,vsi_seid);
                
#line 1209 
                if (vsi == (struct i40e_vsi *)0) {
                  
#line 1210 
                  _dev_info((struct device const *)(& (pf->pdev)->dev),"add pvid: VSI %d not found\n",vsi_seid);
                  
#line 1212 
                  goto command_write_done;
                }
                else ;
                
#line 1215 
                vid = (unsigned short)v;
                
#line 1216 
                ret_1 = i40e_vsi_add_pvid(vsi,(unsigned short)((int)vid));
                
#line 1217 
                if (ret_1 == I40E_SUCCESS) 
#line 1218 
                                           _dev_info((struct device const *)(& (pf->pdev)->dev),"add pvid: %d added to VSI %d\n",(int)vid,vsi_seid); else 
                                                                    
#line 1222 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"add pvid: %d to VSI %d failed, ret=%d\n",(int)vid,vsi_seid,(int)ret_1);
              }
              else {
                int tmp_69;
                
#line 1226 
                tmp_69 = strncmp((char const *)cmd_buf,"del pvid",8UL);
                
#line 1226 
                if (tmp_69 == 0) {
                  
#line 1228 
                  cnt = sscanf((char const *)(cmd_buf + 8U),"%i",& vsi_seid);
                  
#line 1229 
                  if (cnt != 1) {
                    
#line 1230 
                    _dev_info((struct device const *)(& (pf->pdev)->dev),"del pvid: bad command string, cnt=%d\n",cnt);
                    
#line 1233 
                    goto command_write_done;
                  }
                  else ;
                  
#line 1236 
                  vsi = i40e_dbg_find_vsi(pf,vsi_seid);
                  
#line 1237 
                  if (vsi == (struct i40e_vsi *)0) {
                    
#line 1238 
                    _dev_info((struct device const *)(& (pf->pdev)->dev),"del pvid: VSI %d not found\n",vsi_seid);
                    
#line 1240 
                    goto command_write_done;
                  }
                  else ;
                  
#line 1243 
                  i40e_vsi_remove_pvid(vsi);
                  
#line 1244 
                  _dev_info((struct device const *)(& (pf->pdev)->dev),"del pvid: removed from VSI %d\n",vsi_seid);
                }
                else {
                  int tmp_68;
                  
#line 1247 
                  tmp_68 = strncmp((char const *)cmd_buf,"dump",4UL);
                  
#line 1247 
                  if (tmp_68 == 0) {
                    int tmp_14;
                    
#line 1248 
                    tmp_14 = strncmp((char const *)(cmd_buf + 5U),"switch",6UL);
                    
#line 1248 
                    if (tmp_14 == 0) 
#line 1249 
                                     i40e_fetch_switch_configuration(pf,(_Bool)1);
                    else {
                      int tmp_13;
                      
#line 1250 
                      tmp_13 = strncmp((char const *)(cmd_buf + 5U),"vsi",3UL);
                      
#line 1250 
                      if (tmp_13 == 0) {
                        
#line 1251 
                        cnt = sscanf((char const *)(cmd_buf + 8U),"%i",& vsi_seid);
                        
#line 1252 
                        if (cnt > 0) 
#line 1253 
                                     i40e_dbg_dump_vsi_seid(pf,vsi_seid); else 
                                                                    
#line 1255 
                                                                    i40e_dbg_dump_vsi_no_seid(pf);
                      }
                      else {
                        int tmp_12;
                        
#line 1256 
                        tmp_12 = strncmp((char const *)(cmd_buf + 5U),"veb",3UL);
                        
#line 1256 
                        if (tmp_12 == 0) {
                          
#line 1257 
                          cnt = sscanf((char const *)(cmd_buf + 8U),"%i",& vsi_seid);
                          
#line 1258 
                          if (cnt > 0) 
#line 1259 
                                       i40e_dbg_dump_veb_seid(pf,vsi_seid); else 
                                                                    
#line 1261 
                                                                    i40e_dbg_dump_veb_all(pf);
                        }
                        else {
                          int tmp_11;
                          
#line 1262 
                          tmp_11 = strncmp((char const *)(cmd_buf + 5U),"desc",4UL);
                          
#line 1262 
                          if (tmp_11 == 0) {
                            int ring_id;
                            int desc_n;
                            int tmp_3;
                            
#line 1264 
                            tmp_3 = strncmp((char const *)(cmd_buf + 10U),"rx",2UL);
                            
#line 1264 
                            if (tmp_3 == 0) {
                              
#line 1265 
                              cnt = sscanf((char const *)(cmd_buf + 12U),"%i %i %i",& vsi_seid,& ring_id,& desc_n);
                              
#line 1267 
                              i40e_dbg_dump_desc(cnt,vsi_seid,ring_id,desc_n,pf,(_Bool)1);
                            }
                            else {
                              int tmp_2;
                              
#line 1269 
                              tmp_2 = strncmp((char const *)(cmd_buf + 10U),"tx",2UL);
                              
#line 1269 
                              if (tmp_2 == 0) {
                                
#line 1271 
                                cnt = sscanf((char const *)(cmd_buf + 12U),"%i %i %i",& vsi_seid,& ring_id,& desc_n);
                                
#line 1273 
                                i40e_dbg_dump_desc(cnt,vsi_seid,ring_id,desc_n,pf,(_Bool)0);
                              }
                              else {
                                int tmp_1;
                                
#line 1275 
                                tmp_1 = strncmp((char const *)(cmd_buf + 10U),"aq",2UL);
                                
#line 1275 
                                if (tmp_1 == 0) 
#line 1276 
                                                i40e_dbg_dump_aq_desc(pf);
                                else {
                                  
#line 1278 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump desc tx <vsi_seid> <ring_id> [<desc_n>]\n");
                                  
#line 1280 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump desc rx <vsi_seid> <ring_id> [<desc_n>]\n");
                                  
#line 1282 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump desc aq\n");
                                }
                              }
                            }
                          }
                          else {
                            int tmp_10;
                            
#line 1284 
                            tmp_10 = strncmp((char const *)(cmd_buf + 5U),"reset stats",11UL);
                            
#line 1284 
                            if (tmp_10 == 0) {
                              
#line 1285 
                              _dev_info((struct device const *)(& (pf->pdev)->dev),"core reset count: %d\n",(int)pf->corer_count);
                              
#line 1287 
                              _dev_info((struct device const *)(& (pf->pdev)->dev),"global reset count: %d\n",(int)pf->globr_count);
                              
#line 1289 
                              _dev_info((struct device const *)(& (pf->pdev)->dev),"emp reset count: %d\n",(int)pf->empr_count);
                              
#line 1291 
                              _dev_info((struct device const *)(& (pf->pdev)->dev),"pf reset count: %d\n",(int)pf->pfr_count);
                              
#line 1293 
                              _dev_info((struct device const *)(& (pf->pdev)->dev),"pf tx sluggish count: %d\n",pf->tx_sluggish_count);
                            }
                            else {
                              int tmp_9;
                              
#line 1296 
                              tmp_9 = strncmp((char const *)(cmd_buf + 5U),"port",4UL);
                              
#line 1296 
                              if (tmp_9 == 0) {
                                struct i40e_aqc_query_port_ets_config_resp *bw_data;
                                int i_1;
                                int ret_2;
                                i40e_status tmp_5;
                                
#line 1298 
                                struct i40e_dcbx_config *cfg = & pf->hw.local_dcbx_config;
                                
#line 1300 
                                struct i40e_dcbx_config *r_cfg = & pf->hw.remote_dcbx_config;
                                
#line 1304 
                                bw_data = (struct i40e_aqc_query_port_ets_config_resp *)kzalloc(68UL,208U);
                                
#line 1307 
                                if (bw_data == (struct i40e_aqc_query_port_ets_config_resp *)0) {
                                  
#line 1308 
                                  ret_2 = -12;
                                  
#line 1309 
                                  goto command_write_done;
                                }
                                else ;
                                
#line 1312 
                                tmp_5 = i40e_aq_query_port_ets_config(& pf->hw,(unsigned short)((int)pf->mac_seid),bw_data,(struct i40e_asq_cmd_details *)0);
                                
#line 1312 
                                ret_2 = (int)tmp_5;
                                
#line 1315 
                                if (ret_2 != 0) {
                                  
#line 1316 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"Query Port ETS Config AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                  
#line 1319 
                                  kfree((void const *)bw_data);
                                  
#line 1320 
                                  bw_data = (struct i40e_aqc_query_port_ets_config_resp *)0;
                                  
#line 1321 
                                  goto command_write_done;
                                }
                                else ;
                                
#line 1323 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port bw: tc_valid=0x%x tc_strict_prio=0x%x, tc_bw_max=0x%04x,0x%04x\n",(int)bw_data->tc_valid_bits,(int)bw_data->tc_strict_priority_bits,(int)bw_data->tc_bw_max[0],(int)bw_data->tc_bw_max[1]);
                                
#line 1329 
                                i_1 = 0;
                                
#line 1329 
                                goto ldv_61795;
                                ldv_61794: 
#line 1330 
                                ;
                                
#line 1330 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port bw: tc_bw_share=%d tc_bw_limit=%d\n",(int)bw_data->tc_bw_share_credits[i_1],(int)bw_data->tc_bw_limits[i_1]);
                                
#line 1329 
                                i_1 += 1;
                                ldv_61795: 
#line 1330 
                                ;
                                
#line 1329 
                                if (i_1 <= 7) 
#line 1331 
                                              goto ldv_61794; else 
#line 1334 
                                                                   goto ldv_61796;
                                ldv_61796: 
#line 1335 
                                ;
                                
#line 1335 
                                kfree((void const *)bw_data);
                                
#line 1336 
                                bw_data = (struct i40e_aqc_query_port_ets_config_resp *)0;
                                
#line 1338 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port dcbx_mode=%d\n",(int)cfg->dcbx_mode);
                                
#line 1340 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port ets_cfg: willing=%d cbs=%d, maxtcs=%d\n",(int)cfg->etscfg.willing,(int)cfg->etscfg.cbs,(int)cfg->etscfg.maxtcs);
                                
#line 1344 
                                i_1 = 0;
                                
#line 1344 
                                goto ldv_61798;
                                ldv_61797: 
#line 1345 
                                ;
                                
#line 1345 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port ets_cfg: %d prio_tc=%d tcbw=%d tctsa=%d\n",i_1,(int)cfg->etscfg.prioritytable[i_1],(int)cfg->etscfg.tcbwtable[i_1],(int)cfg->etscfg.tsatable[i_1]);
                                
#line 1344 
                                i_1 += 1;
                                ldv_61798: 
#line 1345 
                                ;
                                
#line 1344 
                                if (i_1 <= 7) 
#line 1346 
                                              goto ldv_61797; else 
#line 1349 
                                                                   goto ldv_61799;
                                ldv_61799: 
#line 1350 
                                ;
                                
#line 1350 
                                i_1 = 0;
                                
#line 1350 
                                goto ldv_61801;
                                ldv_61800: 
#line 1351 
                                ;
                                
#line 1351 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port ets_rec: %d prio_tc=%d tcbw=%d tctsa=%d\n",i_1,(int)cfg->etsrec.prioritytable[i_1],(int)cfg->etsrec.tcbwtable[i_1],(int)cfg->etsrec.tsatable[i_1]);
                                
#line 1350 
                                i_1 += 1;
                                ldv_61801: 
#line 1351 
                                ;
                                
#line 1350 
                                if (i_1 <= 7) 
#line 1352 
                                              goto ldv_61800; else 
#line 1355 
                                                                   goto ldv_61802;
                                ldv_61802: 
#line 1356 
                                ;
                                
#line 1356 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port pfc_cfg: willing=%d mbc=%d, pfccap=%d pfcenable=0x%x\n",(int)cfg->pfc.willing,(int)cfg->pfc.mbc,(int)cfg->pfc.pfccap,(int)cfg->pfc.pfcenable);
                                
#line 1360 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port app_table: num_apps=%d\n",cfg->numapps);
                                
#line 1362 
                                i_1 = 0;
                                
#line 1362 
                                goto ldv_61804;
                                ldv_61803: 
#line 1363 
                                ;
                                
#line 1363 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"port app_table: %d prio=%d selector=%d protocol=0x%x\n",i_1,(int)cfg->app[i_1].priority,(int)cfg->app[i_1].selector,(int)cfg->app[i_1].protocolid);
                                
#line 1362 
                                i_1 += 1;
                                ldv_61804: 
#line 1363 
                                ;
                                
#line 1362 
                                if (cfg->numapps > (unsigned int)i_1) 
                                  
#line 1364 
                                  goto ldv_61803; else 
#line 1367 
                                                       goto ldv_61805;
                                ldv_61805: 
#line 1368 
                                ;
                                
#line 1369 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"remote port ets_cfg: willing=%d cbs=%d, maxtcs=%d\n",(int)r_cfg->etscfg.willing,(int)r_cfg->etscfg.cbs,(int)r_cfg->etscfg.maxtcs);
                                
#line 1373 
                                i_1 = 0;
                                
#line 1373 
                                goto ldv_61807;
                                ldv_61806: 
#line 1374 
                                ;
                                
#line 1374 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"remote port ets_cfg: %d prio_tc=%d tcbw=%d tctsa=%d\n",i_1,(int)r_cfg->etscfg.prioritytable[i_1],(int)r_cfg->etscfg.tcbwtable[i_1],(int)r_cfg->etscfg.tsatable[i_1]);
                                
#line 1373 
                                i_1 += 1;
                                ldv_61807: 
#line 1374 
                                ;
                                
#line 1373 
                                if (i_1 <= 7) 
#line 1375 
                                              goto ldv_61806; else 
#line 1378 
                                                                   goto ldv_61808;
                                ldv_61808: 
#line 1379 
                                ;
                                
#line 1379 
                                i_1 = 0;
                                
#line 1379 
                                goto ldv_61810;
                                ldv_61809: 
#line 1380 
                                ;
                                
#line 1380 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"remote port ets_rec: %d prio_tc=%d tcbw=%d tctsa=%d\n",i_1,(int)r_cfg->etsrec.prioritytable[i_1],(int)r_cfg->etsrec.tcbwtable[i_1],(int)r_cfg->etsrec.tsatable[i_1]);
                                
#line 1379 
                                i_1 += 1;
                                ldv_61810: 
#line 1380 
                                ;
                                
#line 1379 
                                if (i_1 <= 7) 
#line 1381 
                                              goto ldv_61809; else 
#line 1384 
                                                                   goto ldv_61811;
                                ldv_61811: 
#line 1385 
                                ;
                                
#line 1385 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"remote port pfc_cfg: willing=%d mbc=%d, pfccap=%d pfcenable=0x%x\n",(int)r_cfg->pfc.willing,(int)r_cfg->pfc.mbc,(int)r_cfg->pfc.pfccap,(int)r_cfg->pfc.pfcenable);
                                
#line 1391 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"remote port app_table: num_apps=%d\n",r_cfg->numapps);
                                
#line 1394 
                                i_1 = 0;
                                
#line 1394 
                                goto ldv_61813;
                                ldv_61812: 
#line 1395 
                                ;
                                
#line 1395 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"remote port app_table: %d prio=%d selector=%d protocol=0x%x\n",i_1,(int)r_cfg->app[i_1].priority,(int)r_cfg->app[i_1].selector,(int)r_cfg->app[i_1].protocolid);
                                
#line 1394 
                                i_1 += 1;
                                ldv_61813: 
#line 1395 
                                ;
                                
#line 1394 
                                if (r_cfg->numapps > (unsigned int)i_1) 
                                  
#line 1396 
                                  goto ldv_61812; else 
#line 1399 
                                                       goto ldv_61814;
                                ldv_61814: 
#line 1400 
                                ;
                              }
                              else {
                                int tmp_8;
                                
#line 1400 
                                tmp_8 = strncmp((char const *)(cmd_buf + 5U),"debug fwdata",12UL);
                                
#line 1400 
                                if (tmp_8 == 0) {
                                  int cluster_id;
                                  int table_id;
                                  int index;
                                  int ret_3;
                                  u32 next_index;
                                  u8 next_table;
                                  u8 *buff;
                                  u16 rlen;
                                  i40e_status tmp_7;
                                  
#line 1403 
                                  u16 buff_len = (unsigned short)4096U;
                                  
#line 1409 
                                  cnt = sscanf((char const *)(cmd_buf + 18U),"%i %i %i",& cluster_id,& table_id,& index);
                                  
#line 1411 
                                  if (cnt != 3) {
                                    
#line 1412 
                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"dump debug fwdata <cluster_id> <table_id> <index>\n");
                                    
#line 1414 
                                    goto command_write_done;
                                  }
                                  else ;
                                  
#line 1417 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ debug dump fwdata params %x %x %x %x\n",cluster_id,table_id,index,(int)buff_len);
                                  
#line 1420 
                                  buff = (u8 *)kzalloc((unsigned long)buff_len,208U);
                                  
#line 1421 
                                  if (buff == (u8 *)0U) 
#line 1422 
                                                        goto command_write_done; else ;
                                  
#line 1424 
                                  tmp_7 = i40e_aq_debug_dump(& pf->hw,(unsigned char)((int)((unsigned char)cluster_id)),(unsigned char)((int)((unsigned char)table_id)),(unsigned int)index,(unsigned short)((int)buff_len),(void *)buff,& rlen,& next_table,& next_index,(struct i40e_asq_cmd_details *)0);
                                  
#line 1424 
                                  ret_3 = (int)tmp_7;
                                  
#line 1428 
                                  if (ret_3 != 0) {
                                    
#line 1429 
                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"debug dump fwdata AQ Failed %d 0x%x\n",ret_3,(unsigned int)pf->hw.aq.asq_last_status);
                                    
#line 1432 
                                    kfree((void const *)buff);
                                    
#line 1433 
                                    buff = (u8 *)0U;
                                    
#line 1434 
                                    goto command_write_done;
                                  }
                                  else ;
                                  
#line 1436 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ debug dump fwdata rlen=0x%x next_table=0x%x next_index=0x%x\n",(int)rlen,(int)next_table,next_index);
                                  
#line 1439 
                                  print_hex_dump("\001","AQ buffer WB: ",2,16,1,(void const *)buff,(unsigned long)rlen,(_Bool)1);
                                  
#line 1442 
                                  kfree((void const *)buff);
                                  
#line 1443 
                                  buff = (u8 *)0U;
                                }
                                else {
                                  
#line 1445 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump desc tx <vsi_seid> <ring_id> [<desc_n>], dump desc rx <vsi_seid> <ring_id> [<desc_n>],\n");
                                  
#line 1447 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump switch\n");
                                  
#line 1448 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump vsi [seid]\n");
                                  
#line 1449 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump reset stats\n");
                                  
#line 1450 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump port\n");
                                  
#line 1451 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"dump debug fwdata <cluster_id> <table_id> <index>\n");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  else {
                    int tmp_67;
                    
#line 1455 
                    tmp_67 = strncmp((char const *)cmd_buf,"msg_enable",10UL);
                    
#line 1455 
                    if (tmp_67 == 0) {
                      u32 level;
                      
#line 1457 
                      cnt = sscanf((char const *)(cmd_buf + 10U),"%i",& level);
                      
#line 1458 
                      if (cnt != 0) {
                        
#line 1459 
                        if ((level & 4026531840U) != 0U) {
                          
#line 1460 
                          pf->hw.debug_mask = level;
                          
#line 1461 
                          _dev_info((struct device const *)(& (pf->pdev)->dev),"set hw.debug_mask = 0x%08x\n",pf->hw.debug_mask);
                        }
                        else ;
                        
#line 1465 
                        pf->msg_enable = level;
                        
#line 1466 
                        _dev_info((struct device const *)(& (pf->pdev)->dev),"set msg_enable = 0x%08x\n",pf->msg_enable);
                      }
                      else 
#line 1469 
                           _dev_info((struct device const *)(& (pf->pdev)->dev),"msg_enable = 0x%08x\n",pf->msg_enable);
                    }
                    else {
                      int tmp_66;
                      
#line 1472 
                      tmp_66 = strncmp((char const *)cmd_buf,"pfr",3UL);
                      
#line 1472 
                      if (tmp_66 == 0) {
                        
#line 1473 
                        _dev_info((struct device const *)(& (pf->pdev)->dev),"debugfs: forcing PFR\n");
                        
#line 1474 
                        i40e_do_reset_safe(pf,4096U);
                      }
                      else {
                        int tmp_65;
                        
#line 1476 
                        tmp_65 = strncmp((char const *)cmd_buf,"corer",5UL);
                        
#line 1476 
                        if (tmp_65 == 0) {
                          
#line 1477 
                          _dev_info((struct device const *)(& (pf->pdev)->dev),"debugfs: forcing CoreR\n");
                          
#line 1478 
                          i40e_do_reset_safe(pf,8192U);
                        }
                        else {
                          int tmp_64;
                          
#line 1480 
                          tmp_64 = strncmp((char const *)cmd_buf,"globr",5UL);
                          
#line 1480 
                          if (tmp_64 == 0) {
                            
#line 1481 
                            _dev_info((struct device const *)(& (pf->pdev)->dev),"debugfs: forcing GlobR\n");
                            
#line 1482 
                            i40e_do_reset_safe(pf,16384U);
                          }
                          else {
                            int tmp_63;
                            
#line 1484 
                            tmp_63 = strncmp((char const *)cmd_buf,"empr",4UL);
                            
#line 1484 
                            if (tmp_63 == 0) {
                              
#line 1485 
                              _dev_info((struct device const *)(& (pf->pdev)->dev),"debugfs: forcing EMPR\n");
                              
#line 1486 
                              i40e_do_reset_safe(pf,32768U);
                            }
                            else {
                              int tmp_62;
                              
#line 1488 
                              tmp_62 = strncmp((char const *)cmd_buf,"read",4UL);
                              
#line 1488 
                              if (tmp_62 == 0) {
                                u32 address;
                                u32 value;
                                
#line 1491 
                                cnt = sscanf((char const *)(cmd_buf + 4U),"%i",& address);
                                
#line 1492 
                                if (cnt != 1) {
                                  
#line 1493 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"read <reg>\n");
                                  
#line 1494 
                                  goto command_write_done;
                                }
                                else ;
                                
#line 1498 
                                if (address > 8388607U) {
                                  
#line 1499 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"read reg address 0x%08x too large\n",address);
                                  
#line 1501 
                                  goto command_write_done;
                                }
                                else ;
                                
#line 1504 
                                value = readl((void const volatile *)(pf->hw.hw_addr + address));
                                
#line 1505 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"read: 0x%08x = 0x%08x\n",address,value);
                              }
                              else {
                                int tmp_61;
                                
#line 1508 
                                tmp_61 = strncmp((char const *)cmd_buf,"write",5UL);
                                
#line 1508 
                                if (tmp_61 == 0) {
                                  u32 address_0;
                                  u32 value_0;
                                  
#line 1510 
                                  cnt = sscanf((char const *)(cmd_buf + 5U),"%i %i",& address_0,& value_0);
                                  
#line 1511 
                                  if (cnt != 2) {
                                    
#line 1512 
                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"write <reg> <value>\n");
                                    
#line 1513 
                                    goto command_write_done;
                                  }
                                  else ;
                                  
#line 1517 
                                  if (address_0 > 8388607U) {
                                    
#line 1518 
                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"write reg address 0x%08x too large\n",address_0);
                                    
#line 1520 
                                    goto command_write_done;
                                  }
                                  else ;
                                  
#line 1522 
                                  writel(value_0,(void volatile *)(pf->hw.hw_addr + address_0));
                                  
#line 1523 
                                  value_0 = readl((void const volatile *)(pf->hw.hw_addr + address_0));
                                  
#line 1524 
                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"write: 0x%08x = 0x%08x\n",address_0,value_0);
                                }
                                else {
                                  int tmp_60;
                                  
#line 1526 
                                  tmp_60 = strncmp((char const *)cmd_buf,"clear_stats",11UL);
                                  
#line 1526 
                                  if (tmp_60 == 0) {
                                    int tmp_16;
                                    
#line 1527 
                                    tmp_16 = strncmp((char const *)(cmd_buf + 12U),"vsi",3UL);
                                    
#line 1527 
                                    if (tmp_16 == 0) {
                                      
#line 1528 
                                      cnt = sscanf((char const *)(cmd_buf + 15U),"%i",& vsi_seid);
                                      
#line 1529 
                                      if (cnt == 0) {
                                        int i_2;
                                        
#line 1531 
                                        i_2 = 0;
                                        
#line 1531 
                                        goto ldv_61831;
                                        ldv_61830: 
#line 1532 
                                        ;
                                        
#line 1532 
                                        i40e_vsi_reset_stats(*(pf->vsi + i_2));
                                        
#line 1531 
                                        i_2 += 1;
                                        ldv_61831: 
#line 1532 
                                        ;
                                        
#line 1531 
                                        if ((int)pf->num_alloc_vsi > i_2) 
                                          
#line 1533 
                                          goto ldv_61830; else 
#line 1536 
                                                               goto ldv_61832;
                                        ldv_61832: 
#line 1537 
                                        ;
                                        
#line 1533 
                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"vsi clear stats called for all vsi\'s\n");
                                      }
                                      else 
                                        
#line 1534 
                                        if (cnt == 1) {
                                          
#line 1535 
                                          vsi = i40e_dbg_find_vsi(pf,vsi_seid);
                                          
#line 1536 
                                          if (vsi == (struct i40e_vsi *)0) {
                                            
#line 1537 
                                            _dev_info((struct device const *)(& (pf->pdev)->dev),"clear_stats vsi: bad vsi %d\n",vsi_seid);
                                            
#line 1540 
                                            goto command_write_done;
                                          }
                                          else ;
                                          
#line 1542 
                                          i40e_vsi_reset_stats(vsi);
                                          
#line 1543 
                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"vsi clear stats called for vsi %d\n",vsi_seid);
                                        }
                                        else 
#line 1547 
                                             _dev_info((struct device const *)(& (pf->pdev)->dev),"clear_stats vsi [seid]\n");
                                    }
                                    else {
                                      int tmp_15;
                                      
#line 1549 
                                      tmp_15 = strncmp((char const *)(cmd_buf + 12U),"port",4UL);
                                      
#line 1549 
                                      if (tmp_15 == 0) 
                                        
#line 1550 
                                        if ((unsigned int)pf->hw.partition_id == 1U) {
                                          
#line 1551 
                                          i40e_pf_reset_stats(pf);
                                          
#line 1552 
                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"port stats cleared\n");
                                        }
                                        else 
#line 1554 
                                             _dev_info((struct device const *)(& (pf->pdev)->dev),"clear port stats not allowed on this port partition\n");
                                      else 
#line 1557 
                                           _dev_info((struct device const *)(& (pf->pdev)->dev),"clear_stats vsi [seid] or clear_stats port\n");
                                    }
                                  }
                                  else {
                                    int tmp_59;
                                    
#line 1559 
                                    tmp_59 = strncmp((char const *)cmd_buf,"send aq_cmd",11UL);
                                    
#line 1559 
                                    if (tmp_59 == 0) {
                                      struct i40e_aq_desc *desc;
                                      i40e_status ret_4;
                                      
#line 1563 
                                      desc = (struct i40e_aq_desc *)kzalloc(32UL,208U);
                                      
#line 1564 
                                      if (desc == (struct i40e_aq_desc *)0) 
                                        
#line 1565 
                                        goto command_write_done; else ;
                                      
#line 1566 
                                      cnt = sscanf((char const *)(cmd_buf + 11U),"%hi %hi %hi %hi %i %i %i %i %i %i",& desc->flags,& desc->opcode,& desc->datalen,& desc->retval,& desc->cookie_high,& desc->cookie_low,& desc->params.internal.param0,& desc->params.internal.param1,& desc->params.internal.param2,& desc->params.internal.param3);
                                      
#line 1575 
                                      if (cnt != 10) {
                                        
#line 1576 
                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"send aq_cmd: bad command string, cnt=%d\n",cnt);
                                        
#line 1579 
                                        kfree((void const *)desc);
                                        
#line 1580 
                                        desc = (struct i40e_aq_desc *)0;
                                        
#line 1581 
                                        goto command_write_done;
                                      }
                                      else ;
                                      
#line 1583 
                                      ret_4 = i40e_asq_send_command(& pf->hw,desc,(void *)0,(unsigned short)0,(struct i40e_asq_cmd_details *)0);
                                      
#line 1584 
                                      if (ret_4 == I40E_SUCCESS) 
#line 1585 
                                                                 _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ command sent Status : Success\n");
                                      else 
                                        
#line 1586 
                                        if (ret_4 == I40E_ERR_ADMIN_QUEUE_ERROR) 
                                          
#line 1587 
                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ command send failed Opcode %x AQ Error: %d\n",(int)desc->opcode,(unsigned int)pf->hw.aq.asq_last_status); else 
                                                                    
#line 1591 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ command send failed Opcode %x Status: %d\n",(int)desc->opcode,(int)ret_4);
                                      
#line 1595 
                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ desc WB 0x%04x 0x%04x 0x%04x 0x%04x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",(int)desc->flags,(int)desc->opcode,(int)desc->datalen,(int)desc->retval,desc->cookie_high,desc->cookie_low,desc->params.internal.param0,desc->params.internal.param1,desc->params.internal.param2,desc->params.internal.param3);
                                      
#line 1603 
                                      kfree((void const *)desc);
                                      
#line 1604 
                                      desc = (struct i40e_aq_desc *)0;
                                    }
                                    else {
                                      int tmp_58;
                                      
#line 1605 
                                      tmp_58 = strncmp((char const *)cmd_buf,"send indirect aq_cmd",20UL);
                                      
#line 1605 
                                      if (tmp_58 == 0) {
                                        struct i40e_aq_desc *desc_0;
                                        i40e_status ret_5;
                                        u16 buffer_len;
                                        u8 *buff_0;
                                        
#line 1611 
                                        desc_0 = (struct i40e_aq_desc *)kzalloc(32UL,208U);
                                        
#line 1612 
                                        if (desc_0 == (struct i40e_aq_desc *)0) 
                                          
#line 1613 
                                          goto command_write_done; else ;
                                        
#line 1614 
                                        cnt = sscanf((char const *)(cmd_buf + 20U),"%hi %hi %hi %hi %i %i %i %i %i %i %hi",& desc_0->flags,& desc_0->opcode,& desc_0->datalen,& desc_0->retval,& desc_0->cookie_high,& desc_0->cookie_low,& desc_0->params.internal.param0,& desc_0->params.internal.param1,& desc_0->params.internal.param2,& desc_0->params.internal.param3,& buffer_len);
                                        
#line 1624 
                                        if (cnt != 11) {
                                          
#line 1625 
                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"send indirect aq_cmd: bad command string, cnt=%d\n",cnt);
                                          
#line 1628 
                                          kfree((void const *)desc_0);
                                          
#line 1629 
                                          desc_0 = (struct i40e_aq_desc *)0;
                                          
#line 1630 
                                          goto command_write_done;
                                        }
                                        else ;
                                        
#line 1633 
                                        if ((unsigned int)buffer_len == 0U) 
                                          
#line 1634 
                                          buffer_len = (unsigned short)1280U; else ;
                                        
#line 1636 
                                        buff_0 = (u8 *)kzalloc((unsigned long)buffer_len,208U);
                                        
#line 1637 
                                        if (buff_0 == (u8 *)0U) {
                                          
#line 1638 
                                          kfree((void const *)desc_0);
                                          
#line 1639 
                                          desc_0 = (struct i40e_aq_desc *)0;
                                          
#line 1640 
                                          goto command_write_done;
                                        }
                                        else ;
                                        
#line 1642 
                                        desc_0->flags = (unsigned short)((unsigned int)desc_0->flags | 4096U);
                                        
#line 1643 
                                        ret_5 = i40e_asq_send_command(& pf->hw,desc_0,(void *)buff_0,(unsigned short)((int)buffer_len),(struct i40e_asq_cmd_details *)0);
                                        
#line 1645 
                                        if (ret_5 == I40E_SUCCESS) 
#line 1646 
                                                                   _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ command sent Status : Success\n");
                                        else 
                                          
#line 1647 
                                          if (ret_5 == I40E_ERR_ADMIN_QUEUE_ERROR) 
                                            
#line 1648 
                                            _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ command send failed Opcode %x AQ Error: %d\n",(int)desc_0->opcode,(unsigned int)pf->hw.aq.asq_last_status); else 
                                                                    
#line 1652 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ command send failed Opcode %x Status: %d\n",(int)desc_0->opcode,(int)ret_5);
                                        
#line 1656 
                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ desc WB 0x%04x 0x%04x 0x%04x 0x%04x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",(int)desc_0->flags,(int)desc_0->opcode,(int)desc_0->datalen,(int)desc_0->retval,desc_0->cookie_high,desc_0->cookie_low,desc_0->params.internal.param0,desc_0->params.internal.param1,desc_0->params.internal.param2,desc_0->params.internal.param3);
                                        
#line 1664 
                                        print_hex_dump("\001","AQ buffer WB: ",2,16,1,(void const *)buff_0,(unsigned long)buffer_len,(_Bool)1);
                                        
#line 1667 
                                        kfree((void const *)buff_0);
                                        
#line 1668 
                                        buff_0 = (u8 *)0U;
                                        
#line 1669 
                                        kfree((void const *)desc_0);
                                        
#line 1670 
                                        desc_0 = (struct i40e_aq_desc *)0;
                                      }
                                      else {
                                        int tmp_56;
                                        
#line 1671 
                                        tmp_56 = strncmp((char const *)cmd_buf,"add fd_filter",13UL);
                                        
#line 1671 
                                        if (tmp_56 == 0) 
#line 1671 
                                                         goto _LOR;
                                        else {
                                          int tmp_57;
                                          
#line 1671 
                                          tmp_57 = strncmp((char const *)cmd_buf,"rem fd_filter",13UL);
                                          
#line 1671 
                                          if (tmp_57 == 0) {
                                            _LOR: {
                                                    struct i40e_fdir_filter fd_data;
                                                    u16 packet_len;
                                                    u16 i_3;
                                                    char *asc_packet;
                                                    u8 *raw_packet;
                                                    int ret_6;
                                                    int tmp_20;
                                                    int tmp_24;
                                                    
#line 1674 
                                                    u16 j = (unsigned short)0U;
                                                    
#line 1677 
                                                    bool add = (_Bool)0;
                                                    
#line 1680 
                                                    if ((pf->flags & 2097152ULL) == 0ULL) 
                                                      
#line 1681 
                                                      goto command_write_done; else ;
                                                    
#line 1683 
                                                    tmp_20 = strncmp((char const *)cmd_buf,"add",3UL);
                                                    
#line 1683 
                                                    if (tmp_20 == 0) 
                                                      
#line 1684 
                                                      add = (_Bool)1; else ;
                                                    
#line 1686 
                                                    if ((int)add != 0 && (pf->auto_disable_flags & 2097152ULL) != 0ULL) 
                                                      
#line 1687 
                                                      goto command_write_done; else ;
                                                    
#line 1689 
                                                    asc_packet = (char *)kzalloc(512UL,208U);
                                                    
#line 1691 
                                                    if (asc_packet == (char *)0) 
                                                      
#line 1692 
                                                      goto command_write_done; else ;
                                                    
#line 1694 
                                                    raw_packet = (u8 *)kzalloc(512UL,208U);
                                                    
#line 1697 
                                                    if (raw_packet == (u8 *)0U) {
                                                      
#line 1698 
                                                      kfree((void const *)asc_packet);
                                                      
#line 1699 
                                                      asc_packet = (char *)0;
                                                      
#line 1700 
                                                      goto command_write_done;
                                                    }
                                                    else ;
                                                    
#line 1703 
                                                    cnt = sscanf((char const *)(cmd_buf + 13U),"%hx %2hhx %2hhx %hx %2hhx %2hhx %hx %x %hd %511s",& fd_data.q_index,& fd_data.flex_off,& fd_data.pctype,& fd_data.dest_vsi,& fd_data.dest_ctl,& fd_data.fd_status,& fd_data.cnt_index,& fd_data.fd_id,& packet_len,asc_packet);
                                                    
#line 1710 
                                                    if (cnt != 10) {
                                                      
#line 1711 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"program fd_filter: bad command string, cnt=%d\n",cnt);
                                                      
#line 1714 
                                                      kfree((void const *)asc_packet);
                                                      
#line 1715 
                                                      asc_packet = (char *)0;
                                                      
#line 1716 
                                                      kfree((void const *)raw_packet);
                                                      
#line 1717 
                                                      goto command_write_done;
                                                    }
                                                    else ;
                                                    
#line 1721 
                                                    if ((unsigned int)packet_len == 0U) 
                                                      
#line 1722 
                                                      packet_len = (unsigned short)512U; else ;
                                                    {
                                                      int tmp_23;
                                                      
#line 1725 
                                                      u16 __min1 = packet_len;
                                                      
#line 1725 
                                                      u16 __min2 = (unsigned short)512U;
                                                      
#line 1725 
                                                      if ((int)__min1 < (int)__min2) 
                                                        
#line 1725 
                                                        tmp_23 = (int)__min1; else 
                                                                    
#line 1725 
                                                                    tmp_23 = (int)__min2;
                                                      
#line 1725 
                                                      tmp_24 = tmp_23;
                                                    }
                                                    
#line 1725 
                                                    packet_len = (unsigned short)tmp_24;
                                                    
#line 1728 
                                                    i_3 = (unsigned short)0U;
                                                    
#line 1728 
                                                    goto ldv_61851;
                                                    ldv_61850: 
#line 1729 
                                                    ;
                                                    
#line 1729 
                                                    sscanf((char const *)(asc_packet + (int)j),"%2hhx ",raw_packet + (int)i_3);
                                                    
#line 1731 
                                                    j = (unsigned short)((unsigned int)j + 3U);
                                                    
#line 1728 
                                                    i_3 = (u16)((int)i_3 + 1);
                                                    ldv_61851: 
#line 1729 
                                                    ;
                                                    
#line 1728 
                                                    if ((int)i_3 < (int)packet_len) 
                                                      
#line 1730 
                                                      goto ldv_61850; else 
                                                                    
#line 1733 
                                                                    goto ldv_61852;
                                                    ldv_61852: 
#line 1734 
                                                    ;
                                                    
#line 1733 
                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"FD raw packet dump\n");
                                                    
#line 1734 
                                                    print_hex_dump("\001","FD raw packet: ",2,16,1,(void const *)raw_packet,(unsigned long)packet_len,(_Bool)1);
                                                    
#line 1737 
                                                    ret_6 = i40e_program_fdir_filter(& fd_data,raw_packet,pf,(_Bool)((bool)((int)add) != 0));
                                                    
#line 1738 
                                                    if (ret_6 == 0) 
#line 1739 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"Filter command send Status : Success\n"); else 
                                                                    
#line 1741 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"Filter command send failed %d\n",ret_6);
                                                    
#line 1744 
                                                    kfree((void const *)raw_packet);
                                                    
#line 1745 
                                                    raw_packet = (u8 *)0U;
                                                    
#line 1746 
                                                    kfree((void const *)asc_packet);
                                                    
#line 1747 
                                                    asc_packet = (char *)0;
                                                  }
                                          }
                                          else {
                                            int tmp_55;
                                            
#line 1748 
                                            tmp_55 = strncmp((char const *)cmd_buf,"fd-atr off",10UL);
                                            
#line 1748 
                                            if (tmp_55 == 0) 
#line 1749 
                                                             i40e_dbg_cmd_fd_ctrl(pf,4194304ULL,(_Bool)0);
                                            else {
                                              int tmp_54;
                                              
#line 1750 
                                              tmp_54 = strncmp((char const *)cmd_buf,"fd-atr on",9UL);
                                              
#line 1750 
                                              if (tmp_54 == 0) 
#line 1751 
                                                               i40e_dbg_cmd_fd_ctrl(pf,4194304ULL,(_Bool)1);
                                              else {
                                                int tmp_53;
                                                
#line 1752 
                                                tmp_53 = strncmp((char const *)cmd_buf,"fd current cnt",14UL);
                                                
#line 1752 
                                                if (tmp_53 == 0) {
                                                  u32 tmp_25;
                                                  
#line 1753 
                                                  tmp_25 = i40e_get_current_fd_count(pf);
                                                  
#line 1753 
                                                  ;
                                                  
#line 1753 
                                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"FD current total filter count for this interface: %d\n",tmp_25);
                                                }
                                                else {
                                                  int tmp_52;
                                                  
#line 1755 
                                                  tmp_52 = strncmp((char const *)cmd_buf,"lldp",4UL);
                                                  
#line 1755 
                                                  if (tmp_52 == 0) {
                                                    int tmp_41;
                                                    
#line 1756 
                                                    tmp_41 = strncmp((char const *)(cmd_buf + 5U),"stop",4UL);
                                                    
#line 1756 
                                                    if (tmp_41 == 0) {
                                                      int ret_7;
                                                      i40e_status tmp_26;
                                                      i40e_status tmp_27;
                                                      
#line 1758 
                                                      tmp_26 = i40e_aq_stop_lldp(& pf->hw,(_Bool)0,(struct i40e_asq_cmd_details *)0);
                                                      
#line 1758 
                                                      ret_7 = (int)tmp_26;
                                                      
#line 1759 
                                                      if (ret_7 != 0) {
                                                        
#line 1760 
                                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"Stop LLDP AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                                        
#line 1763 
                                                        goto command_write_done;
                                                      }
                                                      else ;
                                                      
#line 1765 
                                                      tmp_27 = i40e_aq_add_rem_control_packet_filter(& pf->hw,(u8 *)(& pf->hw.mac.addr),(unsigned short)35020,(unsigned short)0,(unsigned short)((int)(*(pf->vsi + (int)pf->lan_vsi))->seid),(unsigned short)0,(_Bool)1,(struct i40e_control_filter_stats *)0,(struct i40e_asq_cmd_details *)0);
                                                      
#line 1765 
                                                      ret_7 = (int)tmp_27;
                                                      
#line 1770 
                                                      if (ret_7 != 0) {
                                                        
#line 1771 
                                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: Add Control Packet Filter AQ command failed =0x%x\n","i40e_dbg_command_write",(unsigned int)pf->hw.aq.asq_last_status);
                                                        
#line 1774 
                                                        goto command_write_done;
                                                      }
                                                      else ;
                                                      
#line 1777 
                                                      pf->dcbx_cap = (unsigned short)9U;
                                                    }
                                                    else {
                                                      int tmp_40;
                                                      
#line 1780 
                                                      tmp_40 = strncmp((char const *)(cmd_buf + 5U),"start",5UL);
                                                      
#line 1780 
                                                      if (tmp_40 == 0) {
                                                        int ret_8;
                                                        i40e_status tmp_28;
                                                        i40e_status tmp_29;
                                                        
#line 1782 
                                                        tmp_28 = i40e_aq_add_rem_control_packet_filter(& pf->hw,(u8 *)(& pf->hw.mac.addr),(unsigned short)35020,(unsigned short)0,(unsigned short)((int)(*(pf->vsi + (int)pf->lan_vsi))->seid),(unsigned short)0,(_Bool)0,(struct i40e_control_filter_stats *)0,(struct i40e_asq_cmd_details *)0);
                                                        
#line 1782 
                                                        ret_8 = (int)tmp_28;
                                                        
#line 1787 
                                                        if (ret_8 != 0) 
                                                          
#line 1788 
                                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: Remove Control Packet Filter AQ command failed =0x%x\n","i40e_dbg_command_write",(unsigned int)pf->hw.aq.asq_last_status); else ;
                                                        
#line 1794 
                                                        tmp_29 = i40e_aq_start_lldp(& pf->hw,(struct i40e_asq_cmd_details *)0);
                                                        
#line 1794 
                                                        ret_8 = (int)tmp_29;
                                                        
#line 1795 
                                                        if (ret_8 != 0) {
                                                          
#line 1796 
                                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"Start LLDP AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                                          
#line 1799 
                                                          goto command_write_done;
                                                        }
                                                        else ;
                                                        
#line 1802 
                                                        pf->dcbx_cap = (unsigned short)10U;
                                                      }
                                                      else {
                                                        int tmp_39;
                                                        
#line 1805 
                                                        tmp_39 = strncmp((char const *)(cmd_buf + 5U),"get local",9UL);
                                                        
#line 1805 
                                                        if (tmp_39 == 0) {
                                                          u16 llen;
                                                          u16 rlen_0;
                                                          int ret_9;
                                                          u8 *buff_1;
                                                          i40e_status tmp_31;
                                                          
#line 1810 
                                                          buff_1 = (u8 *)kzalloc(1500UL,208U);
                                                          
#line 1811 
                                                          if (buff_1 == (u8 *)0U) 
                                                            
#line 1812 
                                                            goto command_write_done; else ;
                                                          
#line 1814 
                                                          tmp_31 = i40e_aq_get_lldp_mib(& pf->hw,(unsigned char)0,(unsigned char)0,(void *)buff_1,(unsigned short)1500,& llen,& rlen_0,(struct i40e_asq_cmd_details *)0);
                                                          
#line 1814 
                                                          ret_9 = (int)tmp_31;
                                                          
#line 1818 
                                                          if (ret_9 != 0) {
                                                            
#line 1819 
                                                            _dev_info((struct device const *)(& (pf->pdev)->dev),"Get LLDP MIB (local) AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                                            
#line 1822 
                                                            kfree((void const *)buff_1);
                                                            
#line 1823 
                                                            buff_1 = (u8 *)0U;
                                                            
#line 1824 
                                                            goto command_write_done;
                                                          }
                                                          else ;
                                                          
#line 1826 
                                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"LLDP MIB (local)\n");
                                                          
#line 1827 
                                                          print_hex_dump("\001","LLDP MIB (local): ",2,16,1,(void const *)buff_1,1500UL,(_Bool)1);
                                                          
#line 1830 
                                                          kfree((void const *)buff_1);
                                                          
#line 1831 
                                                          buff_1 = (u8 *)0U;
                                                        }
                                                        else {
                                                          int tmp_38;
                                                          
#line 1832 
                                                          tmp_38 = strncmp((char const *)(cmd_buf + 5U),"get remote",10UL);
                                                          
#line 1832 
                                                          if (tmp_38 == 0) {
                                                            u16 llen_0;
                                                            u16 rlen_1;
                                                            int ret_10;
                                                            u8 *buff_2;
                                                            i40e_status tmp_33;
                                                            
#line 1836 
                                                            buff_2 = (u8 *)kzalloc(1500UL,208U);
                                                            
#line 1837 
                                                            if (buff_2 == (u8 *)0U) 
                                                              
#line 1838 
                                                              goto command_write_done; else ;
                                                            
#line 1840 
                                                            tmp_33 = i40e_aq_get_lldp_mib(& pf->hw,(unsigned char)0,(unsigned char)1,(void *)buff_2,(unsigned short)1500,& llen_0,& rlen_1,(struct i40e_asq_cmd_details *)0);
                                                            
#line 1840 
                                                            ret_10 = (int)tmp_33;
                                                            
#line 1845 
                                                            if (ret_10 != 0) {
                                                              
#line 1846 
                                                              _dev_info((struct device const *)(& (pf->pdev)->dev),"Get LLDP MIB (remote) AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                                              
#line 1849 
                                                              kfree((void const *)buff_2);
                                                              
#line 1850 
                                                              buff_2 = (u8 *)0U;
                                                              
#line 1851 
                                                              goto command_write_done;
                                                            }
                                                            else ;
                                                            
#line 1853 
                                                            _dev_info((struct device const *)(& (pf->pdev)->dev),"LLDP MIB (remote)\n");
                                                            
#line 1854 
                                                            print_hex_dump("\001","LLDP MIB (remote): ",2,16,1,(void const *)buff_2,1500UL,(_Bool)1);
                                                            
#line 1857 
                                                            kfree((void const *)buff_2);
                                                            
#line 1858 
                                                            buff_2 = (u8 *)0U;
                                                          }
                                                          else {
                                                            int tmp_37;
                                                            
#line 1859 
                                                            tmp_37 = strncmp((char const *)(cmd_buf + 5U),"event on",8UL);
                                                            
#line 1859 
                                                            if (tmp_37 == 0) {
                                                              int ret_11;
                                                              i40e_status tmp_34;
                                                              
#line 1861 
                                                              tmp_34 = i40e_aq_cfg_lldp_mib_change_event(& pf->hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
                                                              
#line 1861 
                                                              ret_11 = (int)tmp_34;
                                                              
#line 1863 
                                                              if (ret_11 != 0) {
                                                                
#line 1864 
                                                                _dev_info((struct device const *)(& (pf->pdev)->dev),"Config LLDP MIB Change Event (on) AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                                                
#line 1867 
                                                                goto command_write_done;
                                                              }
                                                              else ;
                                                            }
                                                            else {
                                                              int tmp_36;
                                                              
#line 1869 
                                                              tmp_36 = strncmp((char const *)(cmd_buf + 5U),"event off",9UL);
                                                              
#line 1869 
                                                              if (tmp_36 == 0) {
                                                                int ret_12;
                                                                i40e_status tmp_35;
                                                                
#line 1871 
                                                                tmp_35 = i40e_aq_cfg_lldp_mib_change_event(& pf->hw,(_Bool)0,(struct i40e_asq_cmd_details *)0);
                                                                
#line 1871 
                                                                ret_12 = (int)tmp_35;
                                                                
#line 1873 
                                                                if (ret_12 != 0) {
                                                                  
#line 1874 
                                                                  _dev_info((struct device const *)(& (pf->pdev)->dev),"Config LLDP MIB Change Event (off) AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                                                  
#line 1877 
                                                                  goto command_write_done;
                                                                }
                                                                else ;
                                                              }
                                                              else ;
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                  else {
                                                    int tmp_51;
                                                    
#line 1880 
                                                    tmp_51 = strncmp((char const *)cmd_buf,"nvm read",8UL);
                                                    
#line 1880 
                                                    if (tmp_51 == 0) {
                                                      u16 buffer_len_0;
                                                      u16 bytes;
                                                      u16 module;
                                                      u32 offset;
                                                      u16 *buff_3;
                                                      int ret_13;
                                                      int tmp_43;
                                                      int tmp_47;
                                                      i40e_status tmp_49;
                                                      i40e_status tmp_50;
                                                      
#line 1887 
                                                      cnt = sscanf((char const *)(cmd_buf + 8U),"%hx %x %hx",& module,& offset,& buffer_len_0);
                                                      
#line 1889 
                                                      if (cnt == 0) {
                                                        
#line 1890 
                                                        module = (unsigned short)0U;
                                                        
#line 1891 
                                                        offset = 0U;
                                                        
#line 1892 
                                                        buffer_len_0 = (unsigned short)0U;
                                                      }
                                                      else 
                                                        
#line 1893 
                                                        if (cnt == 1) {
                                                          
#line 1894 
                                                          offset = 0U;
                                                          
#line 1895 
                                                          buffer_len_0 = (unsigned short)0U;
                                                        }
                                                        else 
                                                          
#line 1896 
                                                          if (cnt == 2) 
                                                            
#line 1897 
                                                            buffer_len_0 = (unsigned short)0U;
                                                          else 
                                                            
#line 1898 
                                                            if (cnt > 3) {
                                                              
#line 1899 
                                                              _dev_info((struct device const *)(& (pf->pdev)->dev),"nvm read: bad command string, cnt=%d\n",cnt);
                                                              
#line 1901 
                                                              goto command_write_done;
                                                            }
                                                            else ;
                                                      {
                                                        int tmp_42;
                                                        
#line 1905 
                                                        u16 __min1_0 = buffer_len_0;
                                                        
#line 1905 
                                                        u16 __min2_0 = (unsigned short)2048U;
                                                        
#line 1905 
                                                        if ((int)__min1_0 < (int)__min2_0) 
                                                          
#line 1905 
                                                          tmp_42 = (int)__min1_0; else 
                                                                    
#line 1905 
                                                                    tmp_42 = (int)__min2_0;
                                                        
#line 1905 
                                                        tmp_43 = tmp_42;
                                                      }
                                                      
#line 1905 
                                                      buffer_len_0 = (unsigned short)tmp_43;
                                                      
#line 1907 
                                                      bytes = (unsigned short)((unsigned int)buffer_len_0 * 2U);
                                                      {
                                                        int tmp_45;
                                                        int tmp_46;
                                                        {
                                                          int tmp_44;
                                                          
#line 1910 
                                                          u16 _max1 = bytes;
                                                          
#line 1910 
                                                          unsigned short _max2 = (unsigned short)1024U;
                                                          
#line 1910 
                                                          if ((int)_max1 > (int)_max2) 
                                                            
#line 1910 
                                                            tmp_44 = (int)_max1; else 
                                                                    
#line 1910 
                                                                    tmp_44 = (int)_max2;
                                                          
#line 1910 
                                                          tmp_45 = tmp_44;
                                                        }
                                                        
#line 1910 
                                                        unsigned short _min1 = (unsigned short)tmp_45;
                                                        
#line 1910 
                                                        unsigned short _min2 = (unsigned short)4096U;
                                                        
#line 1910 
                                                        if ((int)_min1 < (int)_min2) 
                                                          
#line 1910 
                                                          tmp_46 = (int)_min1; else 
                                                                    
#line 1910 
                                                                    tmp_46 = (int)_min2;
                                                        
#line 1910 
                                                        tmp_47 = tmp_46;
                                                      }
                                                      
#line 1910 
                                                      bytes = (unsigned short)tmp_47;
                                                      
#line 1911 
                                                      buff_3 = (u16 *)kzalloc((unsigned long)bytes,208U);
                                                      
#line 1912 
                                                      if (buff_3 == (u16 *)0U) 
                                                        
#line 1913 
                                                        goto command_write_done; else ;
                                                      
#line 1915 
                                                      tmp_49 = i40e_acquire_nvm(& pf->hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
                                                      
#line 1915 
                                                      ret_13 = (int)tmp_49;
                                                      
#line 1916 
                                                      if (ret_13 != 0) {
                                                        
#line 1917 
                                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"Failed Acquiring NVM resource for read err=%d status=0x%x\n",ret_13,(unsigned int)pf->hw.aq.asq_last_status);
                                                        
#line 1920 
                                                        kfree((void const *)buff_3);
                                                        
#line 1921 
                                                        goto command_write_done;
                                                      }
                                                      else ;
                                                      
#line 1924 
                                                      tmp_50 = i40e_aq_read_nvm(& pf->hw,(unsigned char)((int)((unsigned char)module)),offset * 2U,(unsigned short)((int)bytes),(void *)buff_3,(_Bool)1,(struct i40e_asq_cmd_details *)0);
                                                      
#line 1924 
                                                      ret_13 = (int)tmp_50;
                                                      
#line 1926 
                                                      i40e_release_nvm(& pf->hw);
                                                      
#line 1927 
                                                      if (ret_13 != 0) 
                                                        
#line 1928 
                                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"Read NVM AQ failed err=%d status=0x%x\n",ret_13,(unsigned int)pf->hw.aq.asq_last_status);
                                                      else {
                                                        
#line 1932 
                                                        _dev_info((struct device const *)(& (pf->pdev)->dev),"Read NVM module=0x%x offset=0x%x words=%d\n",(int)module,offset,(int)buffer_len_0);
                                                        
#line 1935 
                                                        if ((unsigned int)bytes != 0U) 
                                                          
#line 1936 
                                                          print_hex_dump("\001","NVM Dump: ",2,16,2,(void const *)buff_3,(unsigned long)bytes,(_Bool)1); else ;
                                                      }
                                                      
#line 1940 
                                                      kfree((void const *)buff_3);
                                                      
#line 1941 
                                                      buff_3 = (u16 *)0U;
                                                    }
                                                    else {
                                                      
#line 1943 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"unknown command \'%s\'\n",cmd_buf);
                                                      
#line 1944 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"available commands\n");
                                                      
#line 1945 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  add vsi [relay_seid]\n");
                                                      
#line 1946 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  del vsi [vsi_seid]\n");
                                                      
#line 1947 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  add relay <uplink_seid> <vsi_seid>\n");
                                                      
#line 1948 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  del relay <relay_seid>\n");
                                                      
#line 1949 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  add macaddr <vsi_seid> <aa:bb:cc:dd:ee:ff> [vlan]\n");
                                                      
#line 1950 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  del macaddr <vsi_seid> <aa:bb:cc:dd:ee:ff> [vlan]\n");
                                                      
#line 1951 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  add pvid <vsi_seid> <vid>\n");
                                                      
#line 1952 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  del pvid <vsi_seid>\n");
                                                      
#line 1953 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  dump switch\n");
                                                      
#line 1954 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  dump vsi [seid]\n");
                                                      
#line 1955 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  dump desc tx <vsi_seid> <ring_id> [<desc_n>]\n");
                                                      
#line 1956 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  dump desc rx <vsi_seid> <ring_id> [<desc_n>]\n");
                                                      
#line 1957 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  dump desc aq\n");
                                                      
#line 1958 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  dump reset stats\n");
                                                      
#line 1959 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  dump debug fwdata <cluster_id> <table_id> <index>\n");
                                                      
#line 1960 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  msg_enable [level]\n");
                                                      
#line 1961 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  read <reg>\n");
                                                      
#line 1962 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  write <reg> <value>\n");
                                                      
#line 1963 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  clear_stats vsi [seid]\n");
                                                      
#line 1964 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  clear_stats port\n");
                                                      
#line 1965 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  pfr\n");
                                                      
#line 1966 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  corer\n");
                                                      
#line 1967 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  globr\n");
                                                      
#line 1968 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  send aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3>\n");
                                                      
#line 1969 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  send indirect aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3> <buffer_len>\n");
                                                      
#line 1970 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  add fd_filter <dest q_index> <flex_off> <pctype> <dest_vsi> <dest_ctl> <fd_status> <cnt_index> <fd_id> <packet_len> <packet>\n");
                                                      
#line 1971 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  rem fd_filter <dest q_index> <flex_off> <pctype> <dest_vsi> <dest_ctl> <fd_status> <cnt_index> <fd_id> <packet_len> <packet>\n");
                                                      
#line 1972 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  fd-atr off\n");
                                                      
#line 1973 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  fd-atr on\n");
                                                      
#line 1974 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  fd current cnt");
                                                      
#line 1975 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  lldp start\n");
                                                      
#line 1976 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  lldp stop\n");
                                                      
#line 1977 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  lldp get local\n");
                                                      
#line 1978 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  lldp get remote\n");
                                                      
#line 1979 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  lldp event on\n");
                                                      
#line 1980 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  lldp event off\n");
                                                      
#line 1981 
                                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"  nvm read [module] [word_offset] [word_count]\n");
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  command_write_done: 
#line 1984 
  ;
  
#line 1985 
  kfree((void const *)cmd_buf);
  
#line 1986 
  cmd_buf = (char *)0;
  
#line 1987 
  __retres = (long)count;
  return_label: 
#line 1987 
                return __retres;
}


#line 1990  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct file_operations const i40e_dbg_command_fops = {.owner = & __this_module, .llseek = (loff_t (*)(struct file *, loff_t , int ))0, .read = & i40e_dbg_command_read, .write = & i40e_dbg_command_write, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 2002  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static char i40e_dbg_netdev_ops_buf[256U] = {(char)'\000'};

#line 2011  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_netdev_ops_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int bytes_not_copied;
  char *buf;
  int len;
  unsigned long tmp_0;
  
#line 2014 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  
#line 2016 
  int buf_size = 256;
  
#line 2021 
  if (*ppos != 0LL) {
    
#line 2022 
    __retres = 0L;
    
#line 2022 
    goto return_label;
  }
  else ;
  
#line 2023 
  if ((unsigned long)buf_size > count) {
    
#line 2024 
    __retres = -28L;
    
#line 2024 
    goto return_label;
  }
  else ;
  
#line 2026 
  buf = (char *)kzalloc((unsigned long)buf_size,208U);
  
#line 2027 
  if (buf == (char *)0) {
    
#line 2028 
    __retres = -28L;
    
#line 2028 
    goto return_label;
  }
  else ;
  
#line 2030 
  len = snprintf(buf,(unsigned long)buf_size,"%s: %s\n",(char *)(& ((*(pf->vsi + (int)pf->lan_vsi))->netdev)->name),(char *)(& i40e_dbg_netdev_ops_buf));
  
#line 2034 
  tmp_0 = copy_to_user((void *)buffer,(void const *)buf,(unsigned long)len);
  
#line 2034 
  bytes_not_copied = (int)tmp_0;
  
#line 2035 
  kfree((void const *)buf);
  
#line 2037 
  if (bytes_not_copied < 0) {
    
#line 2038 
    __retres = (long)bytes_not_copied;
    
#line 2038 
    goto return_label;
  }
  else ;
  
#line 2040 
  *ppos = (long long)len;
  
#line 2041 
  __retres = (long)len;
  return_label: 
#line 2041 
                return __retres;
}


#line 2051  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_netdev_ops_write(struct file *filp, char const *buffer, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  int bytes_not_copied;
  struct i40e_vsi *vsi;
  char *buf_tmp;
  int vsi_seid;
  int i;
  int cnt;
  unsigned long tmp;
  int tmp_7;
  
#line 2055 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  
#line 2063 
  if (*ppos != 0LL) {
    
#line 2064 
    __retres = 0L;
    
#line 2064 
    goto return_label;
  }
  else ;
  
#line 2065 
  if (count > 255UL) {
    
#line 2066 
    __retres = -28L;
    
#line 2066 
    goto return_label;
  }
  else ;
  
#line 2068 
  memset((void *)(& i40e_dbg_netdev_ops_buf),0,256UL);
  
#line 2069 
  tmp = copy_from_user((void *)(& i40e_dbg_netdev_ops_buf),(void const *)buffer,count);
  
#line 2069 
  bytes_not_copied = (int)tmp;
  
#line 2071 
  if (bytes_not_copied < 0) {
    
#line 2072 
    __retres = (long)bytes_not_copied;
    
#line 2072 
    goto return_label;
  }
  else 
    
#line 2073 
    if (bytes_not_copied > 0) 
#line 2074 
                              count -= (unsigned long)bytes_not_copied; else ;
  
#line 2075 
  i40e_dbg_netdev_ops_buf[count] = (char)0;
  
#line 2077 
  buf_tmp = strchr((char const *)(& i40e_dbg_netdev_ops_buf),10);
  
#line 2078 
  if (buf_tmp != (char *)0) {
    
#line 2079 
    *buf_tmp = (char)0;
    
#line 2080 
    count = (unsigned long)((long)buf_tmp + (1L - (long)(& i40e_dbg_netdev_ops_buf)));
  }
  else ;
  
#line 2083 
  tmp_7 = strncmp((char const *)(& i40e_dbg_netdev_ops_buf),"tx_timeout",10UL);
  
#line 2083 
  if (tmp_7 == 0) {
    
#line 2084 
    cnt = sscanf((char const *)(& i40e_dbg_netdev_ops_buf[11]),"%i",& vsi_seid);
    
#line 2085 
    if (cnt != 1) {
      
#line 2086 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"tx_timeout <vsi_seid>\n");
      
#line 2087 
      goto netdev_ops_write_done;
    }
    else ;
    
#line 2089 
    vsi = i40e_dbg_find_vsi(pf,vsi_seid);
    
#line 2090 
    if (vsi == (struct i40e_vsi *)0) 
#line 2091 
                                     _dev_info((struct device const *)(& (pf->pdev)->dev),"tx_timeout: VSI %d not found\n",vsi_seid);
    else 
      
#line 2093 
      if (vsi->netdev == (struct net_device *)0) 
#line 2094 
                                                 _dev_info((struct device const *)(& (pf->pdev)->dev),"tx_timeout: no netdev for VSI %d\n",vsi_seid);
      else {
        int tmp_1;
        
#line 2096 
        tmp_1 = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
        
#line 2096 
        if (tmp_1 != 0) 
#line 2097 
                        _dev_info((struct device const *)(& (pf->pdev)->dev),"tx_timeout: VSI %d not UP\n",vsi_seid);
        else {
          int tmp_0;
          
#line 2099 
          tmp_0 = rtnl_trylock();
          
#line 2099 
          if (tmp_0 != 0) {
            
#line 2100 
            (*(((vsi->netdev)->netdev_ops)->ndo_tx_timeout))(vsi->netdev);
            
#line 2101 
            rtnl_unlock();
            
#line 2102 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"tx_timeout called\n");
          }
          else 
#line 2104 
               _dev_info((struct device const *)(& (pf->pdev)->dev),"Could not acquire RTNL - please try again\n");
        }
      }
  }
  else {
    int tmp_6;
    
#line 2106 
    tmp_6 = strncmp((char const *)(& i40e_dbg_netdev_ops_buf),"change_mtu",10UL);
    
#line 2106 
    if (tmp_6 == 0) {
      int mtu;
      
#line 2108 
      cnt = sscanf((char const *)(& i40e_dbg_netdev_ops_buf[11]),"%i %i",& vsi_seid,& mtu);
      
#line 2110 
      if (cnt != 2) {
        
#line 2111 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"change_mtu <vsi_seid> <mtu>\n");
        
#line 2112 
        goto netdev_ops_write_done;
      }
      else ;
      
#line 2114 
      vsi = i40e_dbg_find_vsi(pf,vsi_seid);
      
#line 2115 
      if (vsi == (struct i40e_vsi *)0) 
#line 2116 
                                       _dev_info((struct device const *)(& (pf->pdev)->dev),"change_mtu: VSI %d not found\n",vsi_seid);
      else 
        
#line 2118 
        if (vsi->netdev == (struct net_device *)0) 
#line 2119 
                                                   _dev_info((struct device const *)(& (pf->pdev)->dev),"change_mtu: no netdev for VSI %d\n",vsi_seid);
        else {
          int tmp_2;
          
#line 2121 
          tmp_2 = rtnl_trylock();
          
#line 2121 
          if (tmp_2 != 0) {
            
#line 2122 
            (*(((vsi->netdev)->netdev_ops)->ndo_change_mtu))(vsi->netdev,mtu);
            
#line 2124 
            rtnl_unlock();
            
#line 2125 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"change_mtu called\n");
          }
          else 
#line 2127 
               _dev_info((struct device const *)(& (pf->pdev)->dev),"Could not acquire RTNL - please try again\n");
        }
    }
    else {
      int tmp_5;
      
#line 2130 
      tmp_5 = strncmp((char const *)(& i40e_dbg_netdev_ops_buf),"set_rx_mode",11UL);
      
#line 2130 
      if (tmp_5 == 0) {
        
#line 2131 
        cnt = sscanf((char const *)(& i40e_dbg_netdev_ops_buf[11]),"%i",& vsi_seid);
        
#line 2132 
        if (cnt != 1) {
          
#line 2133 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"set_rx_mode <vsi_seid>\n");
          
#line 2134 
          goto netdev_ops_write_done;
        }
        else ;
        
#line 2136 
        vsi = i40e_dbg_find_vsi(pf,vsi_seid);
        
#line 2137 
        if (vsi == (struct i40e_vsi *)0) 
#line 2138 
                                         _dev_info((struct device const *)(& (pf->pdev)->dev),"set_rx_mode: VSI %d not found\n",vsi_seid);
        else 
          
#line 2140 
          if (vsi->netdev == (struct net_device *)0) 
#line 2141 
                                                     _dev_info((struct device const *)(& (pf->pdev)->dev),"set_rx_mode: no netdev for VSI %d\n",vsi_seid);
          else {
            int tmp_3;
            
#line 2143 
            tmp_3 = rtnl_trylock();
            
#line 2143 
            if (tmp_3 != 0) {
              
#line 2144 
              (*(((vsi->netdev)->netdev_ops)->ndo_set_rx_mode))(vsi->netdev);
              
#line 2145 
              rtnl_unlock();
              
#line 2146 
              _dev_info((struct device const *)(& (pf->pdev)->dev),"set_rx_mode called\n");
            }
            else 
#line 2148 
                 _dev_info((struct device const *)(& (pf->pdev)->dev),"Could not acquire RTNL - please try again\n");
          }
      }
      else {
        int tmp_4;
        
#line 2151 
        tmp_4 = strncmp((char const *)(& i40e_dbg_netdev_ops_buf),"napi",4UL);
        
#line 2151 
        if (tmp_4 == 0) {
          
#line 2152 
          cnt = sscanf((char const *)(& i40e_dbg_netdev_ops_buf[4]),"%i",& vsi_seid);
          
#line 2153 
          if (cnt != 1) {
            
#line 2154 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"napi <vsi_seid>\n");
            
#line 2155 
            goto netdev_ops_write_done;
          }
          else ;
          
#line 2157 
          vsi = i40e_dbg_find_vsi(pf,vsi_seid);
          
#line 2158 
          if (vsi == (struct i40e_vsi *)0) 
#line 2159 
                                           _dev_info((struct device const *)(& (pf->pdev)->dev),"napi: VSI %d not found\n",vsi_seid);
          else 
            
#line 2161 
            if (vsi->netdev == (struct net_device *)0) 
#line 2162 
                                                       _dev_info((struct device const *)(& (pf->pdev)->dev),"napi: no netdev for VSI %d\n",vsi_seid);
            else {
              
#line 2165 
              i = 0;
              
#line 2165 
              goto ldv_61913;
              ldv_61912: 
#line 2166 
              ;
              
#line 2166 
              napi_schedule(& (*(vsi->q_vectors + i))->napi);
              
#line 2165 
              i += 1;
              ldv_61913: 
#line 2166 
              ;
              
#line 2165 
              if (vsi->num_q_vectors > i) 
#line 2167 
                                          goto ldv_61912; else 
#line 2170 
                                                               goto ldv_61914;
              ldv_61914: 
#line 2171 
              ;
              
#line 2167 
              _dev_info((struct device const *)(& (pf->pdev)->dev),"napi called\n");
            }
        }
        else {
          
#line 2170 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"unknown command \'%s\'\n",(char *)(& i40e_dbg_netdev_ops_buf));
          
#line 2172 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"available commands\n");
          
#line 2173 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"  tx_timeout <vsi_seid>\n");
          
#line 2174 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"  change_mtu <vsi_seid> <mtu>\n");
          
#line 2175 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"  set_rx_mode <vsi_seid>\n");
          
#line 2176 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"  napi <vsi_seid>\n");
        }
      }
    }
  }
  netdev_ops_write_done: 
#line 2178 
  ;
  
#line 2179 
  __retres = (long)count;
  return_label: 
#line 2179 
                return __retres;
}


#line 2182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct file_operations const i40e_dbg_netdev_ops_fops = {.owner = & __this_module, .llseek = (loff_t (*)(struct file *, loff_t , int ))0, .read = & i40e_dbg_netdev_ops_read, .write = & i40e_dbg_netdev_ops_write, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 2193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
void i40e_dbg_pf_init(struct i40e_pf *pf)
{
  struct dentry *pfile;
  
#line 2196 
  char const *name = pci_name((struct pci_dev const *)pf->pdev);
  
#line 2197 
  struct device const *dev = (struct device const *)(& (pf->pdev)->dev);
  
#line 2199 
  pf->i40e_dbg_pf = debugfs_create_dir(name,i40e_dbg_root);
  
#line 2200 
  if (pf->i40e_dbg_pf == (struct dentry *)0) 
#line 2201 
                                             goto return_label; else ;
  
#line 2203 
  pfile = ldv_debugfs_create_file_79("command",(unsigned short)384,pf->i40e_dbg_pf,(void *)pf,& i40e_dbg_command_fops);
  
#line 2205 
  if (pfile == (struct dentry *)0) 
#line 2206 
                                   goto create_failed; else ;
  
#line 2208 
  pfile = ldv_debugfs_create_file_80("dump",(unsigned short)384,pf->i40e_dbg_pf,(void *)pf,& i40e_dbg_dump_fops);
  
#line 2210 
  if (pfile == (struct dentry *)0) 
#line 2211 
                                   goto create_failed; else ;
  
#line 2213 
  pfile = ldv_debugfs_create_file_81("netdev_ops",(unsigned short)384,pf->i40e_dbg_pf,(void *)pf,& i40e_dbg_netdev_ops_fops);
  
#line 2215 
  if (pfile == (struct dentry *)0) 
#line 2216 
                                   goto create_failed; else ;
  
#line 2218 
  goto return_label;
  create_failed: 
#line 2220 
  ;
  
#line 2221 
  _dev_info(dev,"debugfs dir/file for %s failed\n",name);
  
#line 2222 
  debugfs_remove_recursive(pf->i40e_dbg_pf);
  return_label: 
#line 2223 
                return;
}


#line 2230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
void i40e_dbg_pf_exit(struct i40e_pf *pf)
{
  
#line 2232 
  debugfs_remove_recursive(pf->i40e_dbg_pf);
  
#line 2233 
  pf->i40e_dbg_pf = (struct dentry *)0;
  
#line 2235 
  kfree((void const *)i40e_dbg_dump_buf);
  
#line 2236 
  i40e_dbg_dump_buf = (char *)0;
  
#line 2237 
  return;
}


#line 2242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
void i40e_dbg_init(void)
{
  
#line 2244 
  i40e_dbg_root = debugfs_create_dir((char const *)(& i40e_driver_name),(struct dentry *)0);
  
#line 2245 
  if (i40e_dbg_root == (struct dentry *)0) 
#line 2246 
                                           printk("\001"); else ;
  
#line 2247 
  return;
}


#line 2252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
void i40e_dbg_exit(void)
{
  
#line 2254 
  debugfs_remove_recursive(i40e_dbg_root);
  
#line 2255 
  i40e_dbg_root = (struct dentry *)0;
  
#line 2256 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
struct file_operations *ldv_emg_alias_i40e_dbg_dump_fops_2 = (struct file_operations *)(& i40e_dbg_dump_fops);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
struct file_operations *ldv_emg_alias_i40e_dbg_command_fops_2 = (struct file_operations *)(& i40e_dbg_command_fops);

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
struct file_operations *ldv_emg_alias_i40e_dbg_netdev_ops_fops_2 = (struct file_operations *)(& i40e_dbg_netdev_ops_fops);

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
int (*ldv_emg_alias_simple_open_5)(struct inode *, struct file *) = & simple_open;

#line 65 
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4);


#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
long ldv_emg_wrapper_i40e_dbg_netdev_ops_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 78 
  tmp = i40e_dbg_netdev_ops_read(arg0,arg1,arg2,arg3);
  
#line 78 
  return tmp;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
long ldv_emg_wrapper_i40e_dbg_dump_write_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 83 
  tmp = i40e_dbg_dump_write(arg0,(char const *)arg1,arg2,arg3);
  
#line 83 
  return tmp;
}


#line 87  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
long ldv_emg_wrapper_i40e_dbg_netdev_ops_write_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 88 
  tmp = i40e_dbg_netdev_ops_write(arg0,(char const *)arg1,arg2,arg3);
  
#line 88 
  return tmp;
}


#line 92  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
long ldv_emg_wrapper_i40e_dbg_command_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 93 
  tmp = i40e_dbg_command_read(arg0,arg1,arg2,arg3);
  
#line 93 
  return tmp;
}


#line 97  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
long ldv_emg_wrapper_i40e_dbg_command_write_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 98 
  tmp = i40e_dbg_command_write(arg0,(char const *)arg1,arg2,arg3);
  
#line 98 
  return tmp;
}


#line 102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
long ldv_emg_wrapper_i40e_dbg_dump_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 103 
  tmp = i40e_dbg_dump_read(arg0,arg1,arg2,arg3);
  
#line 103 
  return tmp;
}


#line 537  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 540 
  tmp = ldv_kzalloc(size,flags);
  
#line 540 
  return tmp;
}


#line 788  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static void ldv_mutex_lock_73(struct mutex *ldv_func_arg1)
{
  
#line 792 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 793 
  return;
}


#line 796  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static void ldv_mutex_unlock_74(struct mutex *ldv_func_arg1)
{
  
#line 800 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 801 
  return;
}


#line 804  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static void ldv_mutex_unlock_75(struct mutex *ldv_func_arg1)
{
  
#line 808 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 809 
  return;
}


#line 812  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static void ldv_mutex_lock_76(struct mutex *ldv_func_arg1)
{
  
#line 816 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 817 
  return;
}


#line 820  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static void ldv_mutex_unlock_77(struct mutex *ldv_func_arg1)
{
  
#line 824 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 825 
  return;
}


#line 828  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1)
{
  
#line 832 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 833 
  return;
}


#line 836  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_79(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 840 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 840 
  return tmp;
}


#line 844  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_80(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 848 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 848 
  return tmp;
}


#line 852  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_debugfs.c.aux"
static struct dentry *ldv_debugfs_create_file_81(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 856 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 856 
  return tmp;
}


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr, unsigned long volatile *addr)
{
  
#line 112 
  if (0 != 0) 
#line 114 
              ldv_inline_asm(); else 
#line 117 
                                     ldv_inline_asm();
  
#line 118 
  return;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void clear_bit_unlock(long nr, unsigned long volatile *addr)
{
  
#line 133 
  ldv_inline_asm();
  
#line 134 
  clear_bit(nr,addr);
  
#line 135 
  return;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
char *strncpy(char *, char const *, __kernel_size_t);


#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
  u64 __retres;
  
#line 20 
  *remainder = (unsigned int)(dividend % (unsigned long long)divisor);
  
#line 21 
  __retres = dividend / (unsigned long long)divisor;
  
#line 21 
  return __retres;
}


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/math64.h"
__inline static u64 div_u64(u64 dividend, u32 divisor)
{
  u32 remainder;
  u64 tmp;
  
#line 100 
  tmp = div_u64_rem(dividend,divisor,& remainder);
  
#line 100 
  return tmp;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR(void const *ptr);


#line 41 
static bool IS_ERR(void const *ptr);


#line 50 
static bool IS_ERR_OR_NULL(void const *ptr);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 448 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 449 
  return;
}


#line 478 
static void ldv_spin_unlock_irqrestore_74(spinlock_t *lock, unsigned long flags);


#line 482 
static void ldv_spin_unlock_irqrestore_76(spinlock_t *lock, unsigned long flags);


#line 486 
static void ldv_spin_unlock_irqrestore_78(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_73(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_75(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_77(spinlock_t *ldv_func_arg1);


#line 86 
void ldv_spin_model_lock(char *);


#line 87 
void ldv_spin_model_unlock(char *);


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 28 
long ldv_is_err_or_null(void const *ptr);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
void set_normalized_timespec(struct timespec *, time_t, s64);


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static struct timespec timespec_add(struct timespec lhs, struct timespec rhs)
{
  struct timespec ts_delta;
  
#line 72 
  set_normalized_timespec(& ts_delta,lhs.tv_sec + rhs.tv_sec,(long long)(lhs.tv_nsec + rhs.tv_nsec));
  
#line 74 
  return ts_delta;
}


#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec const *ts)
{
  s64 __retres;
  
#line 193 
  __retres = (long long)ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
  
#line 193 
  return __retres;
}


#line 215 
struct timespec ns_to_timespec(s64 const);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns)
{
  
#line 285 
  ktime_t const ktime_zero = {.tv64 = 0LL};
  
#line 287 
  ktime_t __constr_expr_17 = {.tv64 = (long long)((unsigned long long)ktime_zero.tv64 + ns)};
  
#line 287 
  return __constr_expr_17;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
ktime_t ktime_get_with_offset(enum tk_offsets);


#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timekeeping.h"
__inline static ktime_t ktime_get_real(void)
{
  ktime_t tmp;
  
#line 172 
  tmp = ktime_get_with_offset((enum tk_offsets)TK_OFFS_REAL);
  
#line 172 
  return tmp;
}


#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
void dev_err(struct device const *, char const * , ...);


#line 1085 
void dev_warn(struct device const *, char const * , ...);


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 978 
  __retres = skb->head + skb->end;
  
#line 978 
  return __retres;
}


#line 1000  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
  struct skb_shared_hwtstamps *__retres;
  unsigned char *tmp;
  
#line 1002 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1002 
  __retres = & ((struct skb_shared_info *)tmp)->hwtstamps;
  
#line 1002 
  return __retres;
}


#line 2911 
void skb_tstamp_tx(struct sk_buff *, struct skb_shared_hwtstamps *);


#line 2900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);


#line 2931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  
#line 2933 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2934 
  return;
}


#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
struct ptp_clock *ptp_clock_register(struct ptp_clock_info *, struct device *);


#line 133 
int ptp_clock_unregister(struct ptp_clock *);


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
i40e_status i40e_aq_get_link_info(struct i40e_hw *hw, bool enable_lse, struct i40e_link_status *link, struct i40e_asq_cmd_details *cmd_details);


#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
void i40e_ptp_rx_hang(struct i40e_vsi *vsi);


#line 749 
void i40e_ptp_tx_hwtstamp(struct i40e_pf *pf);


#line 750 
void i40e_ptp_rx_hwtstamp(struct i40e_pf *pf, struct sk_buff *skb, u8 index);


#line 751 
void i40e_ptp_set_increment(struct i40e_pf *pf);


#line 752 
int i40e_ptp_set_ts_config(struct i40e_pf *pf, struct ifreq *ifr);


#line 753 
int i40e_ptp_get_ts_config(struct i40e_pf *pf, struct ifreq *ifr);


#line 754 
void i40e_ptp_init(struct i40e_pf *pf);


#line 755 
void i40e_ptp_stop(struct i40e_pf *pf);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static void i40e_ptp_read(struct i40e_pf *pf, struct timespec *ts)
{
  u32 hi;
  u32 lo;
  u64 ns;
  
#line 62 
  struct i40e_hw *hw = & pf->hw;
  
#line 67 
  lo = readl((void const volatile *)(hw->hw_addr + 1982720U));
  
#line 68 
  hi = readl((void const volatile *)(hw->hw_addr + 1982752U));
  
#line 70 
  ns = ((unsigned long long)hi << 32) | (unsigned long long)lo;
  
#line 72 
  *ts = ns_to_timespec((long long)ns);
  
#line 73 
  return;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static void i40e_ptp_write(struct i40e_pf *pf, struct timespec const *ts)
{
  s64 tmp;
  
#line 86 
  struct i40e_hw *hw = & pf->hw;
  
#line 87 
  tmp = timespec_to_ns(ts);
  
#line 87 
  u64 ns = (unsigned long long)tmp;
  
#line 92 
  writel((unsigned int)ns,(void volatile *)(hw->hw_addr + 1982720U));
  
#line 93 
  writel((unsigned int)(ns >> 32),(void volatile *)(hw->hw_addr + 1982752U));
  
#line 94 
  return;
}


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static void i40e_ptp_convert_to_hwtstamp(struct skb_shared_hwtstamps *hwtstamps, u64 timestamp)
{
  
#line 108 
  memset((void *)hwtstamps,0,8UL);
  
#line 110 
  hwtstamps->hwtstamp = ns_to_ktime(timestamp);
  
#line 111 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
{
  int __retres;
  struct i40e_pf *tmp;
  u64 adj;
  u64 freq;
  u64 diff;
  u64 volatile *tmp_0;
  {
    
#line 123 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 123 
    tmp = (struct i40e_pf *)__mptr + 18446744073709416616U;
  }
  
#line 123 
  struct i40e_pf *pf = tmp;
  
#line 124 
  struct i40e_hw *hw = & pf->hw;
  
#line 126 
  int neg_adj = 0;
  
#line 128 
  if (ppb < 0) {
    
#line 129 
    neg_adj = 1;
    
#line 130 
    ppb = - ppb;
  }
  else ;
  
#line 132 
  ldv_inline_asm();
  {
    
#line 134 
    u64 __var = 0ULL;
    
#line 134 
    tmp_0 = (u64 volatile *)(& pf->ptp_base_adj);
  }
  
#line 134 
  adj = *tmp_0;
  
#line 136 
  freq = adj;
  
#line 137 
  freq = (unsigned long long)ppb * freq;
  
#line 138 
  diff = div_u64(freq,1000000000U);
  
#line 140 
  if (neg_adj != 0) 
#line 141 
                    adj -= diff; else 
#line 143 
                                      adj += diff;
  
#line 145 
  writel((unsigned int)adj,(void volatile *)(hw->hw_addr + 1982528U));
  
#line 146 
  writel((unsigned int)(adj >> 32),(void volatile *)(hw->hw_addr + 1982560U));
  
#line 148 
  __retres = 0;
  
#line 148 
  return __retres;
}


#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
  int __retres;
  struct i40e_pf *tmp;
  struct timespec now;
  unsigned long flags;
  {
    
#line 161 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 161 
    tmp = (struct i40e_pf *)__mptr + 18446744073709416616U;
  }
  
#line 161 
  struct i40e_pf *pf = tmp;
  
#line 162 
  struct timespec then = ns_to_timespec(delta);
  
#line 165 
  ldv___ldv_spin_lock_73(& pf->tmreg_lock);
  
#line 167 
  i40e_ptp_read(pf,& now);
  
#line 168 
  now = timespec_add(now,then);
  
#line 169 
  i40e_ptp_write(pf,(struct timespec const *)(& now));
  
#line 171 
  ldv_spin_unlock_irqrestore_74(& pf->tmreg_lock,flags);
  
#line 173 
  __retres = 0;
  
#line 173 
  return __retres;
}


#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)
{
  int __retres;
  struct i40e_pf *tmp;
  unsigned long flags;
  {
    
#line 186 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 186 
    tmp = (struct i40e_pf *)__mptr + 18446744073709416616U;
  }
  
#line 186 
  struct i40e_pf *pf = tmp;
  
#line 189 
  ldv___ldv_spin_lock_75(& pf->tmreg_lock);
  
#line 190 
  i40e_ptp_read(pf,ts);
  
#line 191 
  ldv_spin_unlock_irqrestore_76(& pf->tmreg_lock,flags);
  
#line 193 
  __retres = 0;
  
#line 193 
  return __retres;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_settime(struct ptp_clock_info *ptp, struct timespec const *ts)
{
  int __retres;
  struct i40e_pf *tmp;
  unsigned long flags;
  {
    
#line 207 
    struct ptp_clock_info const *__mptr = (struct ptp_clock_info const *)ptp;
    
#line 207 
    tmp = (struct i40e_pf *)__mptr + 18446744073709416616U;
  }
  
#line 207 
  struct i40e_pf *pf = tmp;
  
#line 210 
  ldv___ldv_spin_lock_77(& pf->tmreg_lock);
  
#line 211 
  i40e_ptp_write(pf,ts);
  
#line 212 
  ldv_spin_unlock_irqrestore_78(& pf->tmreg_lock,flags);
  
#line 214 
  __retres = 0;
  
#line 214 
  return __retres;
}


#line 226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_feature_enable(struct ptp_clock_info *ptp, struct ptp_clock_request *rq, int on)
{
  int __retres;
  
#line 229 
  __retres = -95;
  
#line 229 
  return __retres;
}


#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_rx_hang(struct i40e_vsi *vsi)
{
  struct i40e_ring *rx_ring;
  unsigned long rx_event;
  u32 prttsyn_stat;
  int n;
  int tmp;
  int tmp_1;
  
#line 243 
  struct i40e_pf *pf = vsi->back;
  
#line 244 
  struct i40e_hw *hw = & pf->hw;
  
#line 255 
  if ((pf->flags & 33554432ULL) == 0ULL || ! pf->ptp_rx) 
#line 256 
                                                         goto return_label; else ;
  
#line 258 
  prttsyn_stat = readl((void const volatile *)(hw->hw_addr + 545088U));
  
#line 264 
  if ((prttsyn_stat & 85U) == 0U) {
    
#line 272 
    pf->last_rx_ptp_check = jiffies;
    
#line 273 
    goto return_label;
  }
  else ;
  
#line 277 
  rx_event = pf->last_rx_ptp_check;
  
#line 278 
  n = 0;
  
#line 278 
  goto ldv_61495;
  ldv_61494: 
#line 279 
  ;
  
#line 279 
  rx_ring = *(vsi->rx_rings + n);
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
#line 280 
    tmp = 1;
  }
  
#line 280 
  if (tmp != 0) {
    int tmp_0;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 280 
      tmp_0 = 1;
    }
    
#line 280 
    if (tmp_0 != 0) {
      
#line 280 
      if ((long)(rx_event - rx_ring->last_rx_timestamp) < 0L) 
#line 281 
                                                              rx_event = rx_ring->last_rx_timestamp; else ;
    }
    else ;
  }
  else ;
  
#line 278 
  n += 1;
  ldv_61495: 
#line 279 
  ;
  
#line 278 
  if ((int)vsi->num_queue_pairs > n) 
#line 280 
                                     goto ldv_61494; else 
#line 283 
                                                          goto ldv_61496;
  ldv_61496: 
#line 284 
  ;
  {
    unsigned long __dummy_1;
    unsigned long volatile __dummy2_1;
    
#line 285 
    tmp_1 = 1;
  }
  
#line 285 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_2;
      unsigned long __dummy2_2;
      
#line 285 
      tmp_2 = 1;
    }
    
#line 285 
    if (tmp_2 != 0) {
      
#line 285 
      if ((long)((rx_event - jiffies) + 1250UL) < 0L) {
        
#line 286 
        readl((void const volatile *)(hw->hw_addr + 544832U));
        
#line 287 
        readl((void const volatile *)(hw->hw_addr + 544864U));
        
#line 288 
        readl((void const volatile *)(hw->hw_addr + 544896U));
        
#line 289 
        readl((void const volatile *)(hw->hw_addr + 544928U));
        
#line 290 
        pf->last_rx_ptp_check = jiffies;
        
#line 291 
        pf->rx_hwtstamp_cleared += 1U;
        
#line 292 
        dev_warn((struct device const *)(& ((vsi->back)->pdev)->dev),"%s: clearing Rx timestamp hang\n","i40e_ptp_rx_hang");
      }
      else ;
    }
    else ;
  }
  else ;
  return_label: 
#line 296 
                return;
}


#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_tx_hwtstamp(struct i40e_pf *pf)
{
  struct skb_shared_hwtstamps shhwtstamps;
  u32 hi;
  u32 lo;
  u64 ns;
  
#line 309 
  struct i40e_hw *hw = & pf->hw;
  
#line 313 
  if ((pf->flags & 33554432ULL) == 0ULL || ! pf->ptp_tx) 
#line 314 
                                                         goto return_label; else ;
  
#line 317 
  if (pf->ptp_tx_skb == (struct sk_buff *)0) 
#line 318 
                                             goto return_label; else ;
  
#line 320 
  lo = readl((void const volatile *)(hw->hw_addr + 1982912U));
  
#line 321 
  hi = readl((void const volatile *)(hw->hw_addr + 1982944U));
  
#line 323 
  ns = ((unsigned long long)hi << 32) | (unsigned long long)lo;
  
#line 325 
  i40e_ptp_convert_to_hwtstamp(& shhwtstamps,ns);
  
#line 326 
  skb_tstamp_tx(pf->ptp_tx_skb,& shhwtstamps);
  
#line 327 
  dev_kfree_skb_any(pf->ptp_tx_skb);
  
#line 328 
  pf->ptp_tx_skb = (struct sk_buff *)0;
  
#line 329 
  clear_bit_unlock(19L,(unsigned long volatile *)(& pf->state));
  return_label: 
#line 330 
                return;
}


#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_rx_hwtstamp(struct i40e_pf *pf, struct sk_buff *skb, u8 index)
{
  u32 prttsyn_stat;
  u32 hi;
  u32 lo;
  struct i40e_hw *hw;
  u64 ns;
  struct skb_shared_hwtstamps *tmp;
  
#line 353 
  if ((pf->flags & 33554432ULL) == 0ULL || ! pf->ptp_rx) 
#line 354 
                                                         goto return_label; else ;
  
#line 356 
  hw = & pf->hw;
  
#line 358 
  prttsyn_stat = readl((void const volatile *)(hw->hw_addr + 545088U));
  
#line 360 
  if (((unsigned int)(1 << (int)index) & prttsyn_stat) == 0U) 
#line 361 
                                                              goto return_label; else ;
  
#line 363 
  lo = readl((void const volatile *)(hw->hw_addr + ((int)index + 17030) * 32));
  
#line 364 
  hi = readl((void const volatile *)(hw->hw_addr + ((int)index + 17026) * 32));
  
#line 366 
  ns = ((unsigned long long)hi << 32) | (unsigned long long)lo;
  
#line 368 
  ;
  
#line 368 
  tmp = skb_hwtstamps(skb);
  
#line 368 
  i40e_ptp_convert_to_hwtstamp(tmp,ns);
  return_label: 
#line 369 
                return;
}


#line 379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_set_increment(struct i40e_pf *pf)
{
  struct i40e_link_status *hw_link_info;
  u64 incval;
  u64 volatile *tmp;
  
#line 382 
  struct i40e_hw *hw = & pf->hw;
  
#line 385 
  hw_link_info = & hw->phy.link_info;
  
#line 387 
  i40e_aq_get_link_info(& pf->hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
  
#line 389 
  switch ((unsigned int)hw_link_info->link_speed) {
    case (unsigned int)8: 
#line 390 
    ;
    
#line 391 
    incval = 13743895347ULL;
    
#line 392 
    goto ldv_61529;
    case (unsigned int)4: 
#line 393 
    ;
    
#line 394 
    incval = 137438953472ULL;
    
#line 395 
    goto ldv_61529;
    case (unsigned int)2: 
#line 396 
    ;
    {
      int warn_once;
      
#line 400 
      if (warn_once == 0) {
        
#line 401 
        dev_warn((struct device const *)(& (pf->pdev)->dev),"1588 functionality is not supported at 100 Mbps. Stopping the PHC.\n");
        
#line 403 
        warn_once += 1;
      }
      else ;
      
#line 405 
      incval = 0ULL;
      
#line 406 
      goto ldv_61529;
    }
    case (unsigned int)16: 
#line 408 
    ;
    default: 
#line 409 
    ;
    
#line 410 
    incval = 6871947673ULL;
    
#line 411 
    goto ldv_61529;
  }
  ldv_61529: 
#line 418 
  ;
  
#line 418 
  writel((unsigned int)incval,(void volatile *)(hw->hw_addr + 1982528U));
  
#line 419 
  writel((unsigned int)(incval >> 32),(void volatile *)(hw->hw_addr + 1982560U));
  {
    
#line 422 
    u64 __var = 0ULL;
    
#line 422 
    tmp = (u64 volatile *)(& pf->ptp_base_adj);
  }
  
#line 422 
  *tmp = incval;
  
#line 423 
  ldv_inline_asm();
  
#line 424 
  return;
}


#line 435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
int i40e_ptp_get_ts_config(struct i40e_pf *pf, struct ifreq *ifr)
{
  int __retres;
  int tmp_0;
  unsigned long tmp;
  
#line 437 
  struct hwtstamp_config *config = & pf->tstamp_config;
  
#line 439 
  if ((pf->flags & 33554432ULL) == 0ULL) {
    
#line 440 
    __retres = -95;
    
#line 440 
    goto return_label;
  }
  else ;
  
#line 443 
  tmp = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)config,12UL);
  
#line 443 
  if (tmp != 0UL) 
#line 443 
                  tmp_0 = -14; else 
#line 443 
                                    tmp_0 = 0;
  
#line 443 
  __retres = tmp_0;
  return_label: 
#line 443 
                return __retres;
}


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_set_timestamp_mode(struct i40e_pf *pf, struct hwtstamp_config *config)
{
  int __retres;
  u32 tsyntype;
  u32 regval;
  
#line 461 
  struct i40e_hw *hw = & pf->hw;
  
#line 465 
  if (config->flags != 0) {
    
#line 466 
    __retres = -22;
    
#line 466 
    goto return_label;
  }
  else ;
  
#line 468 
  switch (config->tx_type) {
    case 0: 
#line 469 
    ;
    
#line 470 
    pf->ptp_tx = (_Bool)0;
    
#line 471 
    goto ldv_61550;
    case 1: 
#line 472 
    ;
    
#line 473 
    pf->ptp_tx = (_Bool)1;
    
#line 474 
    goto ldv_61550;
    default: 
#line 475 
    ;
    
#line 476 
    __retres = -34;
    
#line 476 
    goto return_label;
  }
  ldv_61550: 
#line 479 
  ;
  
#line 479 
  switch (config->rx_filter) {
    case 0: 
#line 480 
    ;
    
#line 481 
    pf->ptp_rx = (_Bool)0;
    
#line 487 
    tsyntype = 16777216U;
    
#line 488 
    goto ldv_61554;
    case 4: 
#line 489 
    ;
    case 5: 
#line 490 
    ;
    case 3: 
#line 491 
    ;
    
#line 492 
    pf->ptp_rx = (_Bool)1;
    
#line 493 
    tsyntype = 218104063U;
    
#line 496 
    config->rx_filter = 3;
    
#line 497 
    goto ldv_61554;
    case 12: 
#line 498 
    ;
    case 9: 
#line 499 
    ;
    case 6: 
#line 500 
    ;
    case 13: 
#line 501 
    ;
    case 10: 
#line 502 
    ;
    case 7: 
#line 503 
    ;
    case 14: 
#line 504 
    ;
    case 11: 
#line 505 
    ;
    case 8: 
#line 506 
    ;
    
#line 507 
    pf->ptp_rx = (_Bool)1;
    
#line 508 
    tsyntype = 235864064U;
    
#line 511 
    config->rx_filter = 12;
    
#line 512 
    goto ldv_61554;
    case 1: 
#line 513 
    ;
    default: 
#line 514 
    ;
    
#line 515 
    __retres = -34;
    
#line 515 
    goto return_label;
  }
  ldv_61554: 
#line 519 
  ;
  
#line 519 
  readl((void const volatile *)(hw->hw_addr + 1983008U));
  
#line 520 
  readl((void const volatile *)(hw->hw_addr + 1982944U));
  
#line 521 
  readl((void const volatile *)(hw->hw_addr + 544832U));
  
#line 522 
  readl((void const volatile *)(hw->hw_addr + 544864U));
  
#line 523 
  readl((void const volatile *)(hw->hw_addr + 544896U));
  
#line 524 
  readl((void const volatile *)(hw->hw_addr + 544928U));
  
#line 527 
  regval = readl((void const volatile *)(hw->hw_addr + 1982976U));
  
#line 528 
  if ((int)pf->ptp_tx != 0) 
#line 529 
                            regval |= 2U; else 
#line 531 
                                               regval &= 4294967293U;
  
#line 532 
  writel(regval,(void volatile *)(hw->hw_addr + 1982976U));
  
#line 534 
  regval = readl((void const volatile *)(hw->hw_addr + 231424U));
  
#line 535 
  if ((int)pf->ptp_tx != 0) 
#line 536 
                            regval |= 8388608U; else 
#line 538 
                                                     regval &= 4286578687U;
  
#line 539 
  writel(regval,(void volatile *)(hw->hw_addr + 231424U));
  
#line 547 
  regval = readl((void const volatile *)(hw->hw_addr + 544800U));
  
#line 549 
  regval &= 2147483648U;
  
#line 551 
  regval |= tsyntype;
  
#line 552 
  writel(regval,(void volatile *)(hw->hw_addr + 544800U));
  
#line 554 
  __retres = 0;
  return_label: 
#line 554 
                return __retres;
}


#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
int i40e_ptp_set_ts_config(struct i40e_pf *pf, struct ifreq *ifr)
{
  int __retres;
  struct hwtstamp_config config;
  int err;
  unsigned long tmp;
  int tmp_1;
  unsigned long tmp_0;
  
#line 576 
  if ((pf->flags & 33554432ULL) == 0ULL) {
    
#line 577 
    __retres = -95;
    
#line 577 
    goto return_label;
  }
  else ;
  
#line 579 
  tmp = copy_from_user((void *)(& config),(void const *)ifr->ifr_ifru.ifru_data,12UL);
  
#line 579 
  if (tmp != 0UL) {
    
#line 580 
    __retres = -14;
    
#line 580 
    goto return_label;
  }
  else ;
  
#line 582 
  err = i40e_ptp_set_timestamp_mode(pf,& config);
  
#line 583 
  if (err != 0) {
    
#line 584 
    __retres = err;
    
#line 584 
    goto return_label;
  }
  else ;
  
#line 587 
  pf->tstamp_config = config;
  
#line 590 
  tmp_0 = copy_to_user(ifr->ifr_ifru.ifru_data,(void const *)(& config),12UL);
  
#line 590 
  if (tmp_0 != 0UL) 
#line 590 
                    tmp_1 = -14; else 
#line 590 
                                      tmp_1 = 0;
  
#line 590 
  __retres = tmp_1;
  return_label: 
#line 590 
                return __retres;
}


#line 603  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static long i40e_ptp_create_clock(struct i40e_pf *pf)
{
  long __retres;
  int tmp_0;
  bool tmp;
  bool tmp_2;
  
#line 606 
  tmp = IS_ERR_OR_NULL((void const *)pf->ptp_clock);
  
#line 606 
  if (tmp) 
#line 606 
           tmp_0 = 0; else 
#line 606 
                           tmp_0 = 1;
  
#line 606 
  if (tmp_0) {
    
#line 607 
    __retres = 0L;
    
#line 607 
    goto return_label;
  }
  else ;
  
#line 609 
  strncpy((char *)(& pf->ptp_caps.name),(char const *)(& i40e_driver_name),16UL);
  
#line 610 
  pf->ptp_caps.owner = & __this_module;
  
#line 611 
  pf->ptp_caps.max_adj = 999999999;
  
#line 612 
  pf->ptp_caps.n_ext_ts = 0;
  
#line 613 
  pf->ptp_caps.pps = 0;
  
#line 614 
  pf->ptp_caps.adjfreq = & i40e_ptp_adjfreq;
  
#line 615 
  pf->ptp_caps.adjtime = & i40e_ptp_adjtime;
  
#line 616 
  pf->ptp_caps.gettime64 = & i40e_ptp_gettime;
  
#line 617 
  pf->ptp_caps.settime64 = & i40e_ptp_settime;
  
#line 618 
  pf->ptp_caps.enable = & i40e_ptp_feature_enable;
  
#line 621 
  pf->ptp_clock = ptp_clock_register(& pf->ptp_caps,& (pf->pdev)->dev);
  
#line 622 
  tmp_2 = IS_ERR((void const *)pf->ptp_clock);
  
#line 622 
  if ((int)tmp_2 != 0) {
    long tmp_1;
    
#line 623 
    tmp_1 = PTR_ERR((void const *)pf->ptp_clock);
    
#line 623 
    __retres = tmp_1;
    
#line 623 
    goto return_label;
  }
  else ;
  
#line 630 
  pf->tstamp_config.rx_filter = 0;
  
#line 631 
  pf->tstamp_config.tx_type = 0;
  
#line 633 
  __retres = 0L;
  return_label: 
#line 633 
                return __retres;
}


#line 644  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_init(struct i40e_pf *pf)
{
  u32 pf_id;
  long err;
  unsigned int tmp;
  
#line 646 
  struct net_device *netdev = (*(pf->vsi + (int)pf->lan_vsi))->netdev;
  
#line 647 
  struct i40e_hw *hw = & pf->hw;
  
#line 654 
  tmp = readl((void const volatile *)(hw->hw_addr + 1982976U));
  
#line 654 
  pf_id = (tmp >> 8) & 15U;
  
#line 656 
  if ((unsigned int)hw->pf_id != pf_id) {
    
#line 657 
    pf->flags &= 18446744073675997183ULL;
    
#line 658 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: PTP not supported on %s\n","i40e_ptp_init",(char *)(& netdev->name));
    
#line 661 
    goto return_label;
  }
  else ;
  
#line 667 
  spinlock_check(& pf->tmreg_lock);
  {
    struct lock_class_key __key;
    
#line 667 
    __raw_spin_lock_init(& pf->tmreg_lock.__anonCompField_spinlock_18.rlock,"&(&pf->tmreg_lock)->rlock",& __key);
  }
  
#line 670 
  err = i40e_ptp_create_clock(pf);
  
#line 671 
  if (err != 0L) {
    
#line 672 
    pf->ptp_clock = (struct ptp_clock *)0;
    
#line 673 
    dev_err((struct device const *)(& (pf->pdev)->dev),"%s: ptp_clock_register failed\n","i40e_ptp_init");
  }
  else {
    struct timespec ts;
    u32 regval;
    ktime_t tmp_0;
    
#line 679 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: added PHC on %s\n","i40e_ptp_init",(char *)(& netdev->name));
    
#line 681 
    pf->flags |= 33554432ULL;
    
#line 684 
    regval = readl((void const volatile *)(hw->hw_addr + 1982976U));
    
#line 685 
    regval |= 2147483648U;
    
#line 686 
    writel(regval,(void volatile *)(hw->hw_addr + 1982976U));
    
#line 687 
    regval = readl((void const volatile *)(hw->hw_addr + 544800U));
    
#line 688 
    regval |= 2147483648U;
    
#line 689 
    writel(regval,(void volatile *)(hw->hw_addr + 544800U));
    
#line 692 
    i40e_ptp_set_increment(pf);
    
#line 695 
    i40e_ptp_set_timestamp_mode(pf,& pf->tstamp_config);
    
#line 698 
    tmp_0 = ktime_get_real();
    
#line 698 
    ts = ns_to_timespec(tmp_0.tv64);
    
#line 699 
    i40e_ptp_settime(& pf->ptp_caps,(struct timespec const *)(& ts));
  }
  return_label: 
#line 701 
                return;
}


#line 710  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_stop(struct i40e_pf *pf)
{
  
#line 712 
  pf->flags &= 18446744073675997183ULL;
  
#line 713 
  pf->ptp_tx = (_Bool)0;
  
#line 714 
  pf->ptp_rx = (_Bool)0;
  
#line 716 
  if (pf->ptp_tx_skb != (struct sk_buff *)0) {
    
#line 717 
    dev_kfree_skb_any(pf->ptp_tx_skb);
    
#line 718 
    pf->ptp_tx_skb = (struct sk_buff *)0;
    
#line 719 
    clear_bit_unlock(19L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 722 
  if (pf->ptp_clock != (struct ptp_clock *)0) {
    
#line 723 
    ptp_clock_unregister(pf->ptp_clock);
    
#line 724 
    pf->ptp_clock = (struct ptp_clock *)0;
    
#line 725 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: removed PHC on %s\n","i40e_ptp_stop",(char *)(& ((*(pf->vsi + (int)pf->lan_vsi))->netdev)->name));
  }
  else ;
  
#line 727 
  return;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static long PTR_ERR(void const *ptr)
{
  long tmp;
  
#line 79 
  tmp = ldv_ptr_err(ptr);
  
#line 79 
  return tmp;
}


#line 83  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static bool IS_ERR(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 87 
  ret = ldv_is_err(ptr);
  
#line 88 
  __retres = (_Bool)(ret != 0L);
  
#line 88 
  return __retres;
}


#line 92  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static bool IS_ERR_OR_NULL(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 96 
  ret = ldv_is_err_or_null(ptr);
  
#line 97 
  __retres = (_Bool)(ret != 0L);
  
#line 97 
  return __retres;
}


#line 749  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static void ldv___ldv_spin_lock_73(spinlock_t *ldv_func_arg1)
{
  
#line 753 
  ldv_spin_model_lock((char *)"tmreg_lock_of_i40e_pf");
  
#line 755 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 756 
  return;
}


#line 759  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static void ldv_spin_unlock_irqrestore_74(spinlock_t *lock, unsigned long flags)
{
  
#line 763 
  ldv_spin_model_unlock((char *)"tmreg_lock_of_i40e_pf");
  
#line 765 
  spin_unlock_irqrestore(lock,flags);
  
#line 766 
  return;
}


#line 769  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static void ldv___ldv_spin_lock_75(spinlock_t *ldv_func_arg1)
{
  
#line 773 
  ldv_spin_model_lock((char *)"tmreg_lock_of_i40e_pf");
  
#line 775 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 776 
  return;
}


#line 779  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static void ldv_spin_unlock_irqrestore_76(spinlock_t *lock, unsigned long flags)
{
  
#line 783 
  ldv_spin_model_unlock((char *)"tmreg_lock_of_i40e_pf");
  
#line 785 
  spin_unlock_irqrestore(lock,flags);
  
#line 786 
  return;
}


#line 789  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static void ldv___ldv_spin_lock_77(spinlock_t *ldv_func_arg1)
{
  
#line 793 
  ldv_spin_model_lock((char *)"tmreg_lock_of_i40e_pf");
  
#line 795 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 796 
  return;
}


#line 799  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ptp.c.aux"
static void ldv_spin_unlock_irqrestore_78(spinlock_t *lock, unsigned long flags)
{
  
#line 803 
  ldv_spin_model_unlock((char *)"tmreg_lock_of_i40e_pf");
  
#line 805 
  spin_unlock_irqrestore(lock,flags);
  
#line 806 
  return;
}

unsigned short __builtin_bswap16(unsigned short);

void *__builtin_memcpy(void *, void const *, unsigned long);

void __builtin_unreachable(void);


#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compiler.h"
__inline static void __read_once_size(void const volatile *p, void *res, int size)
{
  
#line 203 
  switch (size) {
    case 1: 
#line 204 
    ;
    
#line 204 
    *((__u8 *)res) = *((__u8 volatile *)p);
    
#line 204 
    goto ldv_1185;
    case 2: 
#line 205 
    ;
    
#line 205 
    *((__u16 *)res) = *((__u16 volatile *)p);
    
#line 205 
    goto ldv_1185;
    case 4: 
#line 206 
    ;
    
#line 206 
    *((__u32 *)res) = *((__u32 volatile *)p);
    
#line 206 
    goto ldv_1185;
    case 8: 
#line 207 
    ;
    
#line 207 
    *((__u64 *)res) = *((__u64 volatile *)p);
    
#line 207 
    goto ldv_1185;
    default: 
#line 208 
    ;
    
#line 209 
    ldv_inline_asm();
    
#line 210 
    __builtin_memcpy(res,(void const *)p,(unsigned long)size);
    
#line 211 
    ldv_inline_asm();
  }
  ldv_1185: 
#line 213 
  ;
  
#line 214 
  return;
}


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bitops/find.h"
unsigned long find_next_bit(unsigned long const *, unsigned long, unsigned long);


#line 42 
unsigned long find_first_bit(unsigned long const *, unsigned long);


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned long __arch_hweight64(__u64 w)
{
  
#line 47 
  unsigned long res = 0UL;
  
#line 48 
  ldv_inline_asm();
  
#line 58 
  return res;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val)
{
  __u16 tmp;
  
#line 49 
  tmp = __builtin_bswap16((unsigned short)((int)val));
  
#line 49 
  return tmp;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitops.h"
__inline static unsigned long hweight_long(unsigned long w)
{
  unsigned long tmp_0;
  
#line 80 
  if (0 != 0) 
#line 80 
              tmp_0 = (unsigned long)((((unsigned int)((((((((((unsigned long long)w & 1ULL) != 0ULL) + (((unsigned long long)w & 2ULL) != 0ULL)) + (((unsigned long long)w & 4ULL) != 0ULL)) + (((unsigned long long)w & 8ULL) != 0ULL)) + (((unsigned long long)w & 16ULL) != 0ULL)) + (((unsigned long long)w & 32ULL) != 0ULL)) + (((unsigned long long)w & 64ULL) != 0ULL)) + (((unsigned long long)w & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 8) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 8) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 8) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(w >> 16) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 16) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 16) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 24) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 24) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 24) & 128ULL) != 0ULL)))) + (((unsigned int)((((((((((unsigned long long)(w >> 32) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 32) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 32) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 40) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 40) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 40) & 128ULL) != 0ULL))) + ((unsigned int)((((((((((unsigned long long)(w >> 48) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 48) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 48) & 128ULL) != 0ULL)) + (unsigned int)((((((((((unsigned long long)(w >> 56) & 1ULL) != 0ULL) + (((unsigned long long)(w >> 56) & 2ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 4ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 8ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 16ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 32ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 64ULL) != 0ULL)) + (((unsigned long long)(w >> 56) & 128ULL) != 0ULL))))); else 
                                                                    
#line 80 
                                                                    tmp_0 = __arch_hweight64((unsigned long long)w);
  
#line 80 
  return tmp_0;
}


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
void __dynamic_dev_dbg(struct _ddebug *, struct device const *, char const * , ...);


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int sprintf(char *, char const * , ...);


#line 474 
extern enum system_states system_state;


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 48 
void __list_add(struct list_head *, struct list_head *, struct list_head *);


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add(struct list_head *new, struct list_head *head)
{
  
#line 63 
  __list_add(new,head,head->next);
  
#line 64 
  return;
}


#line 113 
void list_del(struct list_head *);


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_empty(struct list_head const *head)
{
  int __retres;
  
#line 189 
  __retres = (struct list_head const *)head->next == head;
  
#line 189 
  return __retres;
}


#line 614  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n)
{
  
#line 616 
  struct hlist_node *next = n->next;
  
#line 617 
  struct hlist_node **pprev = n->pprev;
  
#line 618 
  *pprev = next;
  
#line 619 
  if (next != (struct hlist_node *)0) 
#line 620 
                                      next->pprev = pprev; else ;
  
#line 621 
  return;
}


#line 623  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n)
{
  
#line 625 
  __hlist_del(n);
  
#line 626 
  n->next = (struct hlist_node *)(-2401263026317557504);
  
#line 627 
  n->pprev = (struct hlist_node **)(-2401263026316508672);
  
#line 628 
  return;
}


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-defs.h"
void __bad_size_call_parameter(void);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
int memcmp(void const *, void const *, size_t);


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
size_t strlcpy(char *, char const *, size_t);


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
int __bitmap_weight(unsigned long const *, unsigned int);


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst, unsigned int nbits)
{
  
#line 183 
  if (0 != 0 && nbits <= 64U) 
#line 184 
                              *dst = 0UL;
  else {
    
#line 186 
    unsigned int len = (unsigned int)(((unsigned long)nbits + 63UL) / 64UL) * 8U;
    
#line 187 
    memset((void *)dst,0,(unsigned long)len);
  }
  
#line 189 
  return;
}


#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const *src, unsigned int nbits)
{
  int __retres;
  int tmp_0;
  
#line 300 
  if (0 != 0 && nbits <= 64U) {
    unsigned long tmp;
    
#line 301 
    tmp = hweight_long(*src & (18446744073709551615UL >> (- nbits & 63U)));
    
#line 301 
    __retres = (int)tmp;
    
#line 301 
    goto return_label;
  }
  else ;
  
#line 302 
  tmp_0 = __bitmap_weight(src,nbits);
  
#line 302 
  __retres = tmp_0;
  return_label: 
#line 302 
                return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
extern int nr_cpu_ids;


#line 89 
extern struct cpumask const * const cpu_online_mask;


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu)
{
  {
    bool __warned;
    
#line 117 
    int __ret_warn_once = cpu >= (unsigned int)nr_cpu_ids;
    
#line 117 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 117 
        int __ret_warn_on = ! __warned;
        
#line 117 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 117 
                                              warn_slowpath_null("include/linux/cpumask.h",117); else ;
        
#line 117 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 117 
      if ((long)tmp != 0L) 
#line 117 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 117 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 119 
  return cpu;
}


#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
  unsigned int tmp;
  
#line 272 
  ;
  
#line 272 
  tmp = cpumask_check(cpu);
  
#line 272 
  clear_bit((long)tmp,(unsigned long volatile *)(& dstp->bits));
  
#line 273 
  return;
}


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask const *srcp)
{
  unsigned int __retres;
  int tmp;
  
#line 476 
  tmp = bitmap_weight((unsigned long const *)(& srcp->bits),(unsigned int)nr_cpu_ids);
  
#line 476 
  __retres = (unsigned int)tmp;
  
#line 476 
  return __retres;
}


#line 657 
bool alloc_cpumask_var(cpumask_var_t **, gfp_t);


#line 661 
void free_cpumask_var(cpumask_var_t);


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  int __retres;
  int tmp;
  {
    int pfo_ret__;
    
#line 22 
    switch (4UL) {
      case (unsigned long)1: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)2: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)4: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)8: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      default: 
#line 22 
      ;
      
#line 22 
      __bad_percpu_size();
    }
    ldv_6320: 
#line 22 
    ;
    
#line 22 
    tmp = pfo_ret__;
  }
  
#line 22 
  __retres = tmp & 2147483647;
  
#line 22 
  return __retres;
}


#line 7  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
void __local_bh_disable_ip(unsigned long, unsigned int);


#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_disable(void)
{
  __here_0: 
#line 18 
  ;
  
#line 18 
  __local_bh_disable_ip((unsigned long)((void *)0),512U);
  
#line 20 
  return;
}


#line 22 
void __local_bh_enable_ip(unsigned long, unsigned int);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_enable(void)
{
  __here_0: 
#line 31 
  ;
  
#line 31 
  __local_bh_enable_ip((unsigned long)((void *)0),512U);
  
#line 33 
  return;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_60(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_63(spinlock_t *lock);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_lock_82(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_84(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_95(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_97(struct mutex *ldv_func_arg1);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcutree.h"
void kfree_call_rcu(struct callback_head *, void (*)(struct callback_head *));


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
void __mutex_init(struct mutex *, char const *, struct lock_class_key *);


#line 193 
static void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_85(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1);


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 173 
static int ldv_mod_timer_81(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 177 
static int ldv_mod_timer_99(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_100(struct timer_list *ldv_func_arg1);


#line 236 
static int ldv_del_timer_sync_101(struct timer_list *ldv_func_arg1);


#line 240 
static int ldv_del_timer_sync_102(struct timer_list *ldv_func_arg1);


#line 252 
unsigned long round_jiffies(unsigned long);


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void __init_work(struct work_struct *, int);


#line 444 
bool cancel_work_sync(struct work_struct *);


#line 560 
static bool ldv_schedule_work_73(struct work_struct *work);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
void get_random_bytes(void *, int);


#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile *addr)
{
  unsigned long ret;
  
#line 91 
  ldv_inline_asm();
  
#line 90 
  return ret;
}


#line 181 
void *ioremap_nocache(resource_size_t, unsigned long);


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset, unsigned long size)
{
  void *tmp;
  
#line 192 
  tmp = ioremap_nocache(offset,size);
  
#line 192 
  return tmp;
}


#line 195 
void iounmap(void volatile *);


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_0(size_t size, gfp_t flags);


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm_wakeup.h"
int device_set_wakeup_enable(struct device *, bool);


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 131 
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, struct dma_attrs *);


#line 136 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, struct dma_attrs *);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
  
#line 118 
  int rc = dma_set_mask(dev,mask);
  
#line 119 
  if (rc == 0) 
#line 120 
               dma_set_coherent_mask(dev,mask); else ;
  
#line 121 
  return rc;
}


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag)
{
  
#line 186 
  void *ret = dma_alloc_attrs(dev,size,dma_handle,flag | 32768U,(struct dma_attrs *)0);
  
#line 188 
  return ret;
}


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
void synchronize_irq(unsigned int);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
void msleep(unsigned int);


#line 48 
void usleep_range(unsigned long, unsigned long);


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_irq(struct u64_stats_sync const *syncp)
{
  unsigned int __retres;
  
#line 131 
  __retres = 0U;
  
#line 131 
  return __retres;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_irq(struct u64_stats_sync const *syncp, unsigned int start)
{
  bool __retres;
  
#line 144 
  __retres = (_Bool)0;
  
#line 144 
  return __retres;
}


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_74(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 145 
static int ldv_request_irq_76(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 149 
static int ldv_request_irq_77(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 153 
static int ldv_request_irq_86(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 165 
static void ldv_free_irq_75(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 169 
static void ldv_free_irq_78(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 173 
static void ldv_free_irq_79(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 177 
static void ldv_free_irq_80(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 263 
int irq_set_affinity_hint(unsigned int, struct cpumask const *);


#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void napi_disable(struct napi_struct *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  int tmp;
  
#line 507 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& n->state));
  
#line 507 
  if ((long)(tmp == 0) != 0L) {
    
#line 509 
    ldv_inline_asm();
    
#line 507 
    ;
  }
  else ;
  
#line 509 
  ldv_inline_asm();
  
#line 509 
  clear_bit(0L,(unsigned long volatile *)(& n->state));
  
#line 510 
  return;
}


#line 1777  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netdev_set_prio_tc_map(struct net_device *dev, u8 prio, u8 tc)
{
  int __retres;
  
#line 1779 
  if ((int)dev->num_tc <= (int)tc) {
    
#line 1780 
    __retres = -22;
    
#line 1780 
    goto return_label;
  }
  else ;
  
#line 1782 
  dev->prio_tc_map[(int)prio & 15] = (unsigned char)((unsigned int)tc & 15U);
  
#line 1783 
  __retres = 0;
  return_label: 
#line 1783 
                return __retres;
}


#line 1787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_reset_tc(struct net_device *dev)
{
  
#line 1789 
  dev->num_tc = (unsigned char)0U;
  
#line 1790 
  memset((void *)(& dev->tc_to_txq),0,64UL);
  
#line 1791 
  memset((void *)(& dev->prio_tc_map),0,16UL);
  
#line 1792 
  return;
}


#line 1795  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netdev_set_tc_queue(struct net_device *dev, u8 tc, u16 count, u16 offset)
{
  int __retres;
  
#line 1797 
  if ((int)dev->num_tc <= (int)tc) {
    
#line 1798 
    __retres = -22;
    
#line 1798 
    goto return_label;
  }
  else ;
  
#line 1800 
  dev->tc_to_txq[(int)tc].count = count;
  
#line 1801 
  dev->tc_to_txq[(int)tc].offset = offset;
  
#line 1802 
  __retres = 0;
  return_label: 
#line 1802 
                return __retres;
}


#line 1806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static int netdev_set_num_tc(struct net_device *dev, u8 num_tc)
{
  int __retres;
  
#line 1808 
  if ((unsigned int)num_tc > 16U) {
    
#line 1809 
    __retres = -22;
    
#line 1809 
    goto return_label;
  }
  else ;
  
#line 1811 
  dev->num_tc = num_tc;
  
#line 1812 
  __retres = 0;
  return_label: 
#line 1812 
                return __retres;
}


#line 1822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev, unsigned int index)
{
  struct netdev_queue *__retres;
  
#line 1825 
  __retres = dev->_tx + index;
  
#line 1825 
  return __retres;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device const *dev)
{
  void *__retres;
  
#line 1882 
  __retres = (void *)dev + 3008U;
  
#line 1882 
  return __retres;
}


#line 1911 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);


#line 1920 
void netif_napi_del(struct napi_struct *);


#line 2205 
static void ldv_free_netdev_89(struct net_device *ldv_func_arg1);


#line 2209 
static void ldv_free_netdev_91(struct net_device *ldv_func_arg1);


#line 2213 
static void ldv_free_netdev_94(struct net_device *ldv_func_arg1);


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  
#line 2517 
  clear_bit(0L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2518 
  return;
}


#line 2531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2535 
  i = 0U;
  
#line 2535 
  goto ldv_42356;
  ldv_42355: 
#line 2536 
  ;
  {
    
#line 2536 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2537 
    netif_tx_start_queue(txq);
  }
  
#line 2535 
  i += 1U;
  ldv_42356: 
#line 2536 
  ;
  
#line 2535 
  if (dev->num_tx_queues > i) 
#line 2537 
                              goto ldv_42355; else 
#line 2540 
                                                   goto ldv_42357;
  ldv_42357: 
#line 2541 
  ;
  
#line 2542 
  return;
}


#line 2541 
void netif_tx_wake_queue(struct netdev_queue *);


#line 2555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev)
{
  unsigned int i;
  
#line 2559 
  i = 0U;
  
#line 2559 
  goto ldv_42369;
  ldv_42368: 
#line 2560 
  ;
  {
    
#line 2560 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 2561 
    netif_tx_wake_queue(txq);
  }
  
#line 2559 
  i += 1U;
  ldv_42369: 
#line 2560 
  ;
  
#line 2559 
  if (dev->num_tx_queues > i) 
#line 2561 
                              goto ldv_42368; else 
#line 2564 
                                                   goto ldv_42370;
  ldv_42370: 
#line 2565 
  ;
  
#line 2566 
  return;
}


#line 2582 
void netif_tx_stop_all_queues(struct net_device *);


#line 2769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 2771 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev->state));
  
#line 2771 
  __retres = (_Bool)(tmp != 0);
  
#line 2771 
  return __retres;
}


#line 2832 
int netif_set_xps_queue(struct net_device *, struct cpumask const *, u16);


#line 2867 
int netif_set_real_num_tx_queues(struct net_device *, unsigned int);


#line 2870 
int netif_set_real_num_rx_queues(struct net_device *, unsigned int);


#line 3038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 3040 
  tmp = constant_test_bit(2L,(unsigned long const volatile *)(& dev->state));
  
#line 3040 
  __retres = (_Bool)(tmp == 0);
  
#line 3040 
  return __retres;
}


#line 3047 
void netif_carrier_on(struct net_device *);


#line 3049 
void netif_carrier_off(struct net_device *);


#line 3159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
{
  u32 __retres;
  
#line 3162 
  if ((unsigned int)debug_value > 31U) {
    
#line 3163 
    __retres = (unsigned int)default_msg_enable_bits;
    
#line 3163 
    goto return_label;
  }
  else ;
  
#line 3164 
  if (debug_value == 0) {
    
#line 3165 
    __retres = 0U;
    
#line 3165 
    goto return_label;
  }
  else ;
  
#line 3167 
  __retres = (unsigned int)((1 << debug_value) + -1);
  return_label: 
#line 3167 
                return __retres;
}


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_60(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_63(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3287 
  local_bh_disable();
  {
    int pscr_ret__;
    {
      
#line 3288 
      void const *__vpp_verify = (void const *)0;
      
#line 3288 
      void const *tmp = __vpp_verify;
    }
    
#line 3288 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3288 
      ;
      {
        int pfo_ret__;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42930;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42930;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42930;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42930;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_42930: 
#line 3288 
        ;
        
#line 3288 
        tmp_0 = pfo_ret__;
      }
      
#line 3288 
      pscr_ret__ = tmp_0;
      
#line 3288 
      goto ldv_42936;
      case (unsigned long)2: 
#line 3288 
      ;
      {
        int pfo_ret___0;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42940;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42940;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42940;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42940;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_42940: 
#line 3288 
        ;
        
#line 3288 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3288 
      pscr_ret__ = tmp_0_0;
      
#line 3288 
      goto ldv_42936;
      case (unsigned long)4: 
#line 3288 
      ;
      {
        int pfo_ret___1;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42949;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42949;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42949;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42949;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_42949: 
#line 3288 
        ;
        
#line 3288 
        tmp_1 = pfo_ret___1;
      }
      
#line 3288 
      pscr_ret__ = tmp_1;
      
#line 3288 
      goto ldv_42936;
      case (unsigned long)8: 
#line 3288 
      ;
      {
        int pfo_ret___2;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42958;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42958;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42958;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_42958;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_42958: 
#line 3288 
        ;
        
#line 3288 
        tmp_2 = pfo_ret___2;
      }
      
#line 3288 
      pscr_ret__ = tmp_2;
      
#line 3288 
      goto ldv_42936;
      default: 
#line 3288 
      ;
      
#line 3288 
      __bad_size_call_parameter();
      
#line 3288 
      goto ldv_42936;
    }
    ldv_42936: 
#line 3288 
    ;
    
#line 3288 
    tmp_3 = pscr_ret__;
  }
  
#line 3288 
  cpu = tmp_3;
  
#line 3289 
  i = 0U;
  
#line 3289 
  goto ldv_42968;
  ldv_42967: 
#line 3290 
  ;
  {
    
#line 3290 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3292 
    __netif_tx_lock(txq,cpu);
    
#line 3293 
    netif_tx_start_queue(txq);
    
#line 3294 
    __netif_tx_unlock(txq);
  }
  
#line 3289 
  i += 1U;
  ldv_42968: 
#line 3290 
  ;
  
#line 3289 
  if (dev->num_tx_queues > i) 
#line 3291 
                              goto ldv_42967; else 
#line 3294 
                                                   goto ldv_42969;
  ldv_42969: 
#line 3295 
  ;
  
#line 3296 
  local_bh_enable();
  
#line 3297 
  return;
}


#line 3355 
static int ldv_register_netdev_92(struct net_device *ldv_func_arg1);


#line 3360 
static void ldv_unregister_netdev_88(struct net_device *ldv_func_arg1);


#line 3364 
static void ldv_unregister_netdev_90(struct net_device *ldv_func_arg1);


#line 3368 
static void ldv_unregister_netdev_93(struct net_device *ldv_func_arg1);


#line 3397 
int dev_uc_add_excl(struct net_device *, unsigned char const *);


#line 3424 
int dev_mc_add_excl(struct net_device *, unsigned char const *);


#line 3549 
void netdev_rss_key_fill(void *, size_t);


#line 3828 
void netdev_err(struct net_device const *, char const * , ...);


#line 3830 
void netdev_warn(struct net_device const *, char const * , ...);


#line 3834 
void netdev_info(struct net_device const *, char const * , ...);


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
void rtnl_lock(void);


#line 751  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
extern struct bus_type pci_bus_type;


#line 859 
int pci_bus_read_config_byte(struct pci_bus *, unsigned int, int, u8 *);


#line 883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev const *dev, int where, u8 *val)
{
  int tmp;
  
#line 885 
  tmp = pci_bus_read_config_byte(dev->bus,dev->devfn,where,val);
  
#line 885 
  return tmp;
}


#line 910 
int pcie_capability_read_word(struct pci_dev *, int, u16 *);


#line 953 
int pci_enable_device_mem(struct pci_dev *);


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1013 
int pci_select_bars(struct pci_dev *, unsigned long);


#line 1026 
int pci_save_state(struct pci_dev *);


#line 1027 
void pci_restore_state(struct pci_dev *);


#line 1040 
int pci_set_power_state(struct pci_dev *, pci_power_t);


#line 1046 
int pci_wake_from_d3(struct pci_dev *, bool);


#line 1100 
int pci_request_selected_regions(struct pci_dev *, int, char const *);


#line 1102 
void pci_release_selected_regions(struct pci_dev *, int);


#line 1146 
static int ldv___pci_register_driver_103(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_104(struct pci_driver *ldv_func_arg1);


#line 1212 
void pci_disable_msi(struct pci_dev *);


#line 1216 
void pci_disable_msix(struct pci_dev *);


#line 1219 
int pci_enable_msi_range(struct pci_dev *, int, int);


#line 1220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev, int nvec)
{
  int __retres;
  
#line 1222 
  int rc = pci_enable_msi_range(dev,nvec,nvec);
  
#line 1223 
  if (rc < 0) {
    
#line 1224 
    __retres = rc;
    
#line 1224 
    goto return_label;
  }
  else ;
  
#line 1225 
  __retres = 0;
  return_label: 
#line 1225 
                return __retres;
}


#line 1227 
int pci_enable_msix_range(struct pci_dev *, struct msix_entry *, int, int);


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 1674 
int pci_num_vf(struct pci_dev *);


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/aer.h"
int pci_enable_pcie_error_reporting(struct pci_dev *);


#line 43 
int pci_disable_pcie_error_reporting(struct pci_dev *);


#line 44 
int pci_cleanup_aer_uncorrect_error_status(struct pci_dev *);


#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/iommu.h"
bool iommu_present(struct bus_type *);


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
int eth_validate_addr(struct net_device *);


#line 53 
static struct net_device *ldv_alloc_etherdev_mqs_87(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3);


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
static u8 const eth_reserved_addr_base[6U] = {(unsigned char)1U, (unsigned char)128U, (unsigned char)194U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_link_local_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 73 
  __be16 *a = (__be16 *)addr;
  
#line 74 
  __be16 const *b = (__be16 const *)(& eth_reserved_addr_base);
  
#line 75 
  __be16 const m = (unsigned short)61695U;
  
#line 79 
  __retres = (_Bool)(((*((u32 const *)addr) ^ *((u32 const *)b)) | ((unsigned int)((int)*(a + 2U) ^ (int)*(b + 2U)) & 61695U)) == 0U);
  
#line 79 
  return __retres;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 96 
  __retres = (_Bool)((*((u32 const *)addr) | (unsigned int)*((u16 const *)(addr + 4U))) == 0U);
  
#line 96 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_unicast_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_0;
  bool tmp;
  
#line 172 
  tmp = is_multicast_ether_addr(addr);
  
#line 172 
  if ((int)tmp != 0) 
#line 172 
                     tmp_0 = 0; else 
#line 172 
                                     tmp_0 = 1;
  
#line 172 
  __retres = (_Bool)(tmp_0 != 0);
  
#line 172 
  return __retres;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_3;
  int tmp_0;
  bool tmp;
  
#line 190 
  tmp = is_multicast_ether_addr(addr);
  
#line 190 
  if (tmp) 
#line 190 
           tmp_0 = 0; else 
#line 190 
                           tmp_0 = 1;
  
#line 190 
  if (tmp_0) {
    int tmp_2;
    bool tmp_1;
    
#line 190 
    tmp_1 = is_zero_ether_addr(addr);
    
#line 190 
    if (tmp_1) 
#line 190 
               tmp_2 = 0; else 
#line 190 
                               tmp_2 = 1;
    
#line 190 
    if (tmp_2) 
#line 190 
               tmp_3 = 1; else 
#line 190 
                               tmp_3 = 0;
  }
  else 
#line 190 
       tmp_3 = 0;
  
#line 190 
  __retres = (_Bool)(tmp_3 != 0);
  
#line 190 
  return __retres;
}


#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void eth_random_addr(u8 *addr)
{
  
#line 220 
  get_random_bytes((void *)addr,6);
  
#line 221 
  *addr = (unsigned char)((unsigned int)*addr & 254U);
  
#line 222 
  *addr = (unsigned char)((unsigned int)*addr | 2U);
  
#line 223 
  return;
}


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst, u8 const *src)
{
  
#line 274 
  *((u32 *)dst) = *((u32 const *)src);
  
#line 275 
  *((u16 *)(dst + 4U)) = *((u16 const *)(src + 4U));
  
#line 276 
  return;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const *addr1, u8 const *addr2)
{
  bool __retres;
  
#line 313 
  u32 fold = (*((u32 const *)addr1) ^ *((u32 const *)addr2)) | (unsigned int)((int)*((u16 const *)(addr1 + 4U)) ^ (int)*((u16 const *)(addr2 + 4U)));
  
#line 316 
  __retres = (_Bool)(fold == 0U);
  
#line 316 
  return __retres;
}


#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
i40e_status i40e_init_lan_hmc(struct i40e_hw *hw, u32 txq_num, u32 rxq_num, u32 fcoe_cntx_num, u32 fcoe_filt_num);


#line 166 
i40e_status i40e_configure_lan_hmc(struct i40e_hw *hw, enum i40e_hmc_model model);


#line 168 
i40e_status i40e_shutdown_lan_hmc(struct i40e_hw *hw);


#line 170 
i40e_status i40e_clear_lan_tx_queue_context(struct i40e_hw *hw, u16 queue);


#line 172 
i40e_status i40e_set_lan_tx_queue_context(struct i40e_hw *hw, u16 queue, struct i40e_hmc_obj_txq *s);


#line 175 
i40e_status i40e_clear_lan_rx_queue_context(struct i40e_hw *hw, u16 queue);


#line 177 
i40e_status i40e_set_lan_rx_queue_context(struct i40e_hw *hw, u16 queue, struct i40e_hmc_obj_rxq *s);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_alloc.h"
i40e_status i40e_allocate_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem, u64 size, u32 alignment);


#line 50 
i40e_status i40e_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem);


#line 52 
i40e_status i40e_allocate_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem, u32 size);


#line 55 
i40e_status i40e_free_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem);


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
i40e_status i40e_init_adminq(struct i40e_hw *hw);


#line 43 
i40e_status i40e_shutdown_adminq(struct i40e_hw *hw);


#line 45 
i40e_status i40e_clean_arq_element(struct i40e_hw *hw, struct i40e_arq_event_info *e, u16 *pending);


#line 59 
bool i40e_check_asq_alive(struct i40e_hw *hw);


#line 82 
enum i40e_status_code i40e_aq_get_phy_capabilities(struct i40e_hw *hw, bool qualified_modules, bool report_init, struct i40e_aq_get_phy_abilities_resp *abilities, struct i40e_asq_cmd_details *cmd_details);


#line 89 
enum i40e_status_code i40e_set_fc(struct i40e_hw *hw, u8 *aq_failures, bool atomic_restart);


#line 91 
i40e_status i40e_aq_set_phy_int_mask(struct i40e_hw *hw, u16 mask, struct i40e_asq_cmd_details *cmd_details);


#line 95 
i40e_status i40e_aq_set_link_restart_an(struct i40e_hw *hw, bool enable_link, struct i40e_asq_cmd_details *cmd_details);


#line 104 
i40e_status i40e_aq_send_driver_version(struct i40e_hw *hw, struct i40e_driver_version *dv, struct i40e_asq_cmd_details *cmd_details);


#line 107 
i40e_status i40e_aq_add_vsi(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details);


#line 110 
i40e_status i40e_aq_set_vsi_broadcast(struct i40e_hw *hw, u16 seid, bool set_filter, struct i40e_asq_cmd_details *cmd_details);


#line 113 
i40e_status i40e_aq_set_vsi_unicast_promiscuous(struct i40e_hw *hw, u16 seid, bool set, struct i40e_asq_cmd_details *cmd_details);


#line 115 
i40e_status i40e_aq_set_vsi_multicast_promiscuous(struct i40e_hw *hw, u16 seid, bool set, struct i40e_asq_cmd_details *cmd_details);


#line 117 
i40e_status i40e_aq_get_vsi_params(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details);


#line 120 
i40e_status i40e_aq_update_vsi_params(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details);


#line 123 
i40e_status i40e_aq_add_veb(struct i40e_hw *hw, u16 uplink_seid, u16 downlink_seid, u8 enabled_tc, bool default_port, bool enable_l2_filtering, u16 *veb_seid, struct i40e_asq_cmd_details *cmd_details);


#line 128 
i40e_status i40e_aq_get_veb_parameters(struct i40e_hw *hw, u16 veb_seid, u16 *switch_id, bool *floating, u16 *statistic_index, u16 *vebs_used, u16 *vebs_free, struct i40e_asq_cmd_details *cmd_details);


#line 133 
i40e_status i40e_aq_add_macvlan(struct i40e_hw *hw, u16 seid, struct i40e_aqc_add_macvlan_element_data *mv_list, u16 count, struct i40e_asq_cmd_details *cmd_details);


#line 136 
i40e_status i40e_aq_remove_macvlan(struct i40e_hw *hw, u16 seid, struct i40e_aqc_remove_macvlan_element_data *mv_list, u16 count, struct i40e_asq_cmd_details *cmd_details);


#line 142 
i40e_status i40e_aq_get_switch_config(struct i40e_hw *hw, struct i40e_aqc_get_switch_config_resp *buf, u16 buf_size, u16 *start_seid, struct i40e_asq_cmd_details *cmd_details);


#line 162 
i40e_status i40e_aq_discover_capabilities(struct i40e_hw *hw, void *buff, u16 buff_size, u16 *data_size, enum i40e_admin_queue_opc list_type_opc, struct i40e_asq_cmd_details *cmd_details);


#line 166 
i40e_status i40e_aq_update_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, void *data, bool last_command, struct i40e_asq_cmd_details *cmd_details);


#line 184 
i40e_status i40e_aq_add_udp_tunnel(struct i40e_hw *hw, u16 udp_port, u8 protocol_index, u8 *filter_index, struct i40e_asq_cmd_details *cmd_details);


#line 188 
i40e_status i40e_aq_del_udp_tunnel(struct i40e_hw *hw, u8 index, struct i40e_asq_cmd_details *cmd_details);


#line 190 
i40e_status i40e_aq_delete_element(struct i40e_hw *hw, u16 seid, struct i40e_asq_cmd_details *cmd_details);


#line 192 
i40e_status i40e_aq_mac_address_write(struct i40e_hw *hw, u16 flags, u8 *mac_addr, struct i40e_asq_cmd_details *cmd_details);


#line 207 
i40e_status i40e_aq_config_vsi_tc_bw(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_vsi_tc_bw_data *bw_data, struct i40e_asq_cmd_details *cmd_details);


#line 215 
i40e_status i40e_aq_config_switch_comp_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_switching_comp_bw_config_data *bw_data, struct i40e_asq_cmd_details *cmd_details);


#line 219 
i40e_status i40e_aq_query_vsi_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_vsi_bw_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);


#line 223 
i40e_status i40e_aq_query_vsi_ets_sla_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_vsi_ets_sla_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);


#line 227 
i40e_status i40e_aq_query_switch_comp_ets_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_switching_comp_ets_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);


#line 235 
i40e_status i40e_aq_query_switch_comp_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_switching_comp_bw_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);


#line 239 
i40e_status i40e_aq_resume_port_tx(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details);


#line 244 
i40e_status i40e_init_shared_code(struct i40e_hw *hw);


#line 245 
i40e_status i40e_pf_reset(struct i40e_hw *hw);


#line 246 
void i40e_clear_hw(struct i40e_hw *hw);


#line 247 
void i40e_clear_pxe_mode(struct i40e_hw *hw);


#line 248 
bool i40e_get_link_status(struct i40e_hw *hw);


#line 249 
i40e_status i40e_get_mac_addr(struct i40e_hw *hw, u8 *mac_addr);


#line 250 
i40e_status i40e_read_bw_from_alt_ram(struct i40e_hw *hw, u32 *max_bw, u32 *min_bw, bool *min_valid, bool *max_valid);


#line 253 
i40e_status i40e_aq_configure_partition_bw(struct i40e_hw *hw, struct i40e_aqc_configure_partition_bw_data *bw_data, struct i40e_asq_cmd_details *cmd_details);


#line 256 
i40e_status i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr);


#line 260 
void i40e_pre_tx_queue_cfg(struct i40e_hw *hw, u32 queue, bool enable);


#line 262 
i40e_status i40e_get_san_mac_addr(struct i40e_hw *hw, u8 *mac_addr);


#line 279 
void i40e_set_pci_config_data(struct i40e_hw *hw, u16 link_status);


#line 299 
i40e_status i40e_set_filter_control(struct i40e_hw *hw, struct i40e_filter_control_settings *settings);


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
void i40e_free_vfs(struct i40e_pf *pf);


#line 108 
int i40e_pci_sriov_configure(struct pci_dev *pdev, int num_vfs);


#line 109 
int i40e_alloc_vfs(struct i40e_pf *pf, u16 num_alloc_vfs);


#line 110 
int i40e_vc_process_vf_msg(struct i40e_pf *pf, u16 vf_id, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen);


#line 112 
int i40e_vc_process_vflr_event(struct i40e_pf *pf);


#line 113 
void i40e_reset_vf(struct i40e_vf *vf, bool flr);


#line 114 
void i40e_vc_notify_vf_reset(struct i40e_vf *vf);


#line 117 
int i40e_ndo_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac);


#line 118 
int i40e_ndo_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos);


#line 120 
int i40e_ndo_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate, int max_tx_rate);


#line 122 
int i40e_ndo_get_vf_config(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi);


#line 124 
int i40e_ndo_set_vf_link_state(struct net_device *netdev, int vf_id, int link);


#line 125 
int i40e_ndo_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool enable);


#line 127 
void i40e_vc_notify_link_state(struct i40e_pf *pf);


#line 128 
void i40e_vc_notify_reset(struct i40e_pf *pf);


#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
void i40e_alloc_rx_buffers_ps(struct i40e_ring *rx_ring, u16 cleaned_count);


#line 294 
void i40e_alloc_rx_buffers_1buf(struct i40e_ring *rx_ring, u16 cleaned_count);


#line 295 
void i40e_alloc_rx_headers(struct i40e_ring *rx_ring);


#line 296 
netdev_tx_t i40e_lan_xmit_frame(struct sk_buff *skb, struct net_device *netdev);


#line 297 
void i40e_clean_tx_ring(struct i40e_ring *tx_ring);


#line 298 
void i40e_clean_rx_ring(struct i40e_ring *rx_ring);


#line 299 
int i40e_setup_tx_descriptors(struct i40e_ring *tx_ring);


#line 300 
int i40e_setup_rx_descriptors(struct i40e_ring *rx_ring);


#line 301 
void i40e_free_tx_resources(struct i40e_ring *tx_ring);


#line 302 
void i40e_free_rx_resources(struct i40e_ring *rx_ring);


#line 303 
int i40e_napi_poll(struct napi_struct *napi, int budget);


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
i40e_status i40e_aq_get_dcb_config(struct i40e_hw *hw, u8 mib_type, u8 bridgetype, struct i40e_dcbx_config *dcbcfg);


#line 110 
i40e_status i40e_get_dcb_config(struct i40e_hw *hw);


#line 111 
i40e_status i40e_init_dcb(struct i40e_hw *hw);


#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static char *i40e_fw_version_str(struct i40e_hw *hw)
{
  char *__retres;
  char buf[32U];
  
#line 569 
  snprintf((char *)(& buf),32UL,"f%d.%d.%05d a%d.%d n%x.%02x e%x",(int)hw->aq.fw_maj_ver,(int)hw->aq.fw_min_ver,hw->aq.fw_build,(int)hw->aq.api_maj_ver,(int)hw->aq.api_min_ver,(int)hw->nvm.version >> 12,(int)hw->nvm.version & 255,hw->nvm.eetrack & 16777215U);
  
#line 579 
  __retres = (char *)(& buf);
  
#line 579 
  return __retres;
}


#line 596  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static void i40e_vsi_setup_irqhandler(struct i40e_vsi *vsi, irqreturn_t (*irq_handler)(int , void *))
{
  
#line 599 
  vsi->irq_handler = irq_handler;
  
#line 600 
  return;
}


#line 627 
int i40e_up(struct i40e_vsi *vsi);


#line 628 
void i40e_down(struct i40e_vsi *vsi);


#line 630 
char const i40e_driver_version_str[8U];


#line 632 
void i40e_do_reset(struct i40e_pf *pf, u32 reset_flags);


#line 633 
struct i40e_vsi *i40e_find_vsi_from_id(struct i40e_pf *pf, u16 id);


#line 634 
void i40e_update_stats(struct i40e_vsi *vsi);


#line 635 
void i40e_update_eth_stats(struct i40e_vsi *vsi);


#line 642 
int i40e_add_del_fdir(struct i40e_vsi *vsi, struct i40e_fdir_filter *input, bool add);


#line 644 
void i40e_fdir_check_and_reenable(struct i40e_pf *pf);


#line 646 
u32 i40e_get_cur_guaranteed_fd_count(struct i40e_pf *pf);


#line 647 
u32 i40e_get_current_atr_cnt(struct i40e_pf *pf);


#line 648 
u32 i40e_get_global_fd_count(struct i40e_pf *pf);


#line 649 
bool i40e_set_ntuple(struct i40e_pf *pf, netdev_features_t features);


#line 650 
void i40e_set_ethtool_ops(struct net_device *netdev);


#line 663 
void i40e_vsi_setup_queue_map(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt, u8 enabled_tc, bool is_add);


#line 667 
int i40e_vsi_control_rings(struct i40e_vsi *vsi, bool request);


#line 668 
int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count);


#line 673 
int i40e_veb_config_tc(struct i40e_veb *veb, u8 enabled_tc);


#line 689 
void i40e_irq_dynamic_enable(struct i40e_vsi *vsi, int vector);


#line 690 
void i40e_irq_dynamic_disable(struct i40e_vsi *vsi, int vector);


#line 691 
void i40e_irq_dynamic_disable_icr0(struct i40e_pf *pf);


#line 692 
void i40e_irq_dynamic_enable_icr0(struct i40e_pf *pf);


#line 694 
struct rtnl_link_stats64 *i40e_get_netdev_stats_struct(struct net_device *netdev, struct rtnl_link_stats64 *stats);


#line 697 
int i40e_set_mac(struct net_device *netdev, void *p);


#line 698 
void i40e_set_rx_mode(struct net_device *netdev);


#line 700 
int i40e_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);


#line 702 
void i40e_tx_timeout(struct net_device *netdev);


#line 703 
int i40e_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid);


#line 705 
int i40e_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid);


#line 708 
int i40e_open(struct net_device *netdev);


#line 709 
int i40e_vsi_open(struct i40e_vsi *vsi);


#line 710 
void i40e_vlan_stripping_disable(struct i40e_vsi *vsi);


#line 711 
int i40e_vsi_add_vlan(struct i40e_vsi *vsi, s16 vid);


#line 712 
int i40e_vsi_kill_vlan(struct i40e_vsi *vsi, s16 vid);


#line 713 
struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi, u8 *macaddr, bool is_vf, bool is_netdev);


#line 715 
bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi);


#line 716 
struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, u8 *macaddr, bool is_vf, bool is_netdev);


#line 719 
int i40e_close(struct net_device *netdev);


#line 720 
int i40e_setup_tc(struct net_device *netdev, u8 tc);


#line 721 
void i40e_netpoll(struct net_device *netdev);


#line 722 
int i40e_fcoe_enable(struct net_device *netdev);


#line 723 
int i40e_fcoe_disable(struct net_device *netdev);


#line 724 
int i40e_fcoe_vsi_init(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt);


#line 725 
u8 i40e_get_fcoe_tc_map(struct i40e_pf *pf);


#line 726 
void i40e_fcoe_config_netdev(struct net_device *netdev, struct i40e_vsi *vsi);


#line 727 
void i40e_fcoe_vsi_setup(struct i40e_pf *pf);


#line 728 
int i40e_init_pf_fcoe(struct i40e_pf *pf);


#line 729 
int i40e_fcoe_setup_ddp_resources(struct i40e_vsi *vsi);


#line 730 
void i40e_fcoe_free_ddp_resources(struct i40e_vsi *vsi);


#line 737 
void i40e_vlan_stripping_enable(struct i40e_vsi *vsi);


#line 739 
void i40e_dcbnl_flush_apps(struct i40e_pf *pf, struct i40e_dcbx_config *old_cfg, struct i40e_dcbx_config *new_cfg);


#line 742 
void i40e_dcbnl_set_all(struct i40e_vsi *vsi);


#line 743 
void i40e_dcbnl_setup(struct i40e_vsi *vsi);


#line 744 
bool i40e_dcb_need_reconfig(struct i40e_pf *pf, struct i40e_dcbx_config *old_cfg, struct i40e_dcbx_config *new_cfg);


#line 756 
int i40e_is_vsi_uplink_mode_veb(struct i40e_vsi *vsi);


#line 757 
i40e_status i40e_get_npar_bw_setting(struct i40e_pf *pf);


#line 758 
i40e_status i40e_set_npar_bw_setting(struct i40e_pf *pf);


#line 759 
i40e_status i40e_commit_npar_bw_setting(struct i40e_pf *pf);


#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_diag.h"
i40e_status i40e_diag_eeprom_test(struct i40e_hw *hw);


#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/vxlan.h"
void vxlan_get_rx_port(struct net_device *);


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
char const i40e_driver_name[5U] = {(char)'i', (char)'4', (char)'0', (char)'e', (char)'\000'};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static char const i40e_driver_string[50U] = {(char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)'(', (char)'R', (char)')', (char)' ', (char)'E', (char)'t', (char)'h', (char)'e', (char)'r', (char)'n', (char)'e', (char)'t', (char)' ', (char)'C', (char)'o', (char)'n', (char)'n', (char)'e', (char)'c', (char)'t', (char)'i', (char)'o', (char)'n', (char)' ', (char)'X', (char)'L', (char)'7', (char)'1', (char)'0', (char)' ', (char)'N', (char)'e', (char)'t', (char)'w', (char)'o', (char)'r', (char)'k', (char)' ', (char)'D', (char)'r', (char)'i', (char)'v', (char)'e', (char)'r', (char)'\000'};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
char const i40e_driver_version_str[8U] = {(char)'1', (char)'\000'};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static char const i40e_copyright[45U] = {(char)'C', (char)'o', (char)'p', (char)'y', (char)'r', (char)'i', (char)'g', (char)'h', (char)'t', (char)' ', (char)'(', (char)'c', (char)')', (char)' ', (char)'2', (char)'0', (char)'1', (char)'3', (char)' ', (char)'-', (char)' ', (char)'2', (char)'0', (char)'1', (char)'4', (char)' ', (char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)' ', (char)'C', (char)'o', (char)'r', (char)'p', (char)'o', (char)'r', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'.', (char)'\000'};

#line 50 
static void i40e_vsi_reinit_locked(struct i40e_vsi *vsi);


#line 51 
static void i40e_handle_reset_warning(struct i40e_pf *pf);


#line 52 
static int i40e_add_vsi(struct i40e_vsi *vsi);


#line 53 
static int i40e_add_veb(struct i40e_veb *veb, struct i40e_vsi *vsi);


#line 54 
static int i40e_setup_pf_switch(struct i40e_pf *pf, bool reinit);


#line 55 
static int i40e_setup_misc_vector(struct i40e_pf *pf);


#line 56 
static void i40e_determine_queue_usage(struct i40e_pf *pf);


#line 57 
static int i40e_setup_pf_filter_control(struct i40e_pf *pf);


#line 58 
static void i40e_fdir_sb_setup(struct i40e_pf *pf);


#line 59 
static int i40e_veb_get_bw_info(struct i40e_veb *veb);


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct pci_device_id const i40e_pci_tbl[11U] = {{.vendor = 32902U, .device = 5490U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5492U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5503U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5504U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5505U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5507U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5508U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5509U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5510U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 5511U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct pci_device_id const __mod_pci__i40e_pci_tbl_device_table[11U];

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int debug = -1;

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_allocate_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem, u64 size, u32 alignment)
{
  i40e_status __retres;
  
#line 104 
  struct i40e_pf *pf = (struct i40e_pf *)hw->back;
  
#line 106 
  mem->size = (((unsigned int)size + alignment) + 4294967295U) & - alignment;
  
#line 107 
  mem->va = dma_zalloc_coherent(& (pf->pdev)->dev,(unsigned long)mem->size,& mem->pa,208U);
  
#line 109 
  if (mem->va == (void *)0) {
    
#line 110 
    __retres = I40E_ERR_MASTER_REQUESTS_PENDING;
    
#line 110 
    goto return_label;
  }
  else ;
  
#line 112 
  __retres = I40E_SUCCESS;
  return_label: 
#line 112 
                return __retres;
}


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem)
{
  i40e_status __retres;
  
#line 122 
  struct i40e_pf *pf = (struct i40e_pf *)hw->back;
  
#line 124 
  dma_free_attrs(& (pf->pdev)->dev,(unsigned long)mem->size,mem->va,mem->pa,(struct dma_attrs *)0);
  
#line 125 
  mem->va = (void *)0;
  
#line 126 
  mem->pa = 0ULL;
  
#line 127 
  mem->size = 0U;
  
#line 129 
  __retres = I40E_SUCCESS;
  
#line 129 
  return __retres;
}


#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_allocate_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem, u32 size)
{
  i40e_status __retres;
  
#line 141 
  mem->size = size;
  
#line 142 
  mem->va = kzalloc_0((unsigned long)size,208U);
  
#line 144 
  if (mem->va == (void *)0) {
    
#line 145 
    __retres = I40E_ERR_MASTER_REQUESTS_PENDING;
    
#line 145 
    goto return_label;
  }
  else ;
  
#line 147 
  __retres = I40E_SUCCESS;
  return_label: 
#line 147 
                return __retres;
}


#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_free_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem)
{
  i40e_status __retres;
  
#line 158 
  kfree((void const *)mem->va);
  
#line 159 
  mem->va = (void *)0;
  
#line 160 
  mem->size = 0U;
  
#line 162 
  __retres = I40E_SUCCESS;
  
#line 162 
  return __retres;
}


#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_lump(struct i40e_pf *pf, struct i40e_lump_tracking *pile, u16 needed, u16 id)
{
  int __retres;
  int i;
  int j;
  
#line 181 
  int ret = -12;
  
#line 184 
  if ((pile == (struct i40e_lump_tracking *)0 || (unsigned int)needed == 0U) || (int)id < 0) {
    
#line 185 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"param err: pile=%p needed=%d id=0x%04x\n",pile,(int)needed,(int)id);
    
#line 188 
    __retres = -22;
    
#line 188 
    goto return_label;
  }
  else ;
  
#line 192 
  i = (int)pile->search_hint;
  
#line 193 
  goto ldv_61761;
  ldv_61769: 
#line 194 
  ;
  
#line 195 
  if ((int)pile->list[i] < 0) {
    
#line 196 
    i += 1;
    
#line 197 
    goto ldv_61761;
  }
  else ;
  
#line 201 
  j = 0;
  
#line 201 
  goto ldv_61764;
  ldv_61763: 
#line 202 
  ;
  
#line 202 
  if ((int)pile->list[i + j] < 0) 
#line 203 
                                  goto ldv_61762; else ;
  
#line 201 
  j += 1;
  ldv_61764: 
#line 202 
  ;
  
#line 201 
  if ((int)needed > j && i + j < (int)pile->num_entries) 
#line 203 
                                                         goto ldv_61763; else 
                                                                    
#line 206 
                                                                    goto ldv_61762;
  ldv_61762: 
#line 207 
  ;
  
#line 206 
  if ((int)needed == j) {
    
#line 208 
    j = 0;
    
#line 208 
    goto ldv_61766;
    ldv_61765: 
#line 209 
    ;
    
#line 209 
    pile->list[i + j] = (unsigned short)((unsigned int)id | 32768U);
    
#line 208 
    j += 1;
    ldv_61766: 
#line 209 
    ;
    
#line 208 
    if ((int)needed > j) 
#line 210 
                         goto ldv_61765; else 
#line 213 
                                              goto ldv_61767;
    ldv_61767: 
#line 214 
    ;
    
#line 210 
    ret = i;
    
#line 211 
    pile->search_hint = (unsigned short)((int)((unsigned short)i) + (int)((unsigned short)j));
    
#line 212 
    goto ldv_61768;
  }
  else 
#line 215 
       i += j;
  ldv_61761: 
#line 216 
  ;
  
#line 193 
  if ((int)pile->num_entries > i) 
#line 195 
                                  goto ldv_61769; else 
#line 198 
                                                       goto ldv_61768;
  ldv_61768: 
#line 199 
  ;
  
#line 219 
  __retres = ret;
  return_label: 
#line 219 
                return __retres;
}


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_put_lump(struct i40e_lump_tracking *pile, u16 index, u16 id)
{
  int __retres;
  int i;
  
#line 232 
  int valid_id = (int)((unsigned int)id | 32768U);
  
#line 233 
  int count = 0;
  
#line 236 
  if (pile == (struct i40e_lump_tracking *)0 || (int)pile->num_entries <= (int)index) {
    
#line 237 
    __retres = -22;
    
#line 237 
    goto return_label;
  }
  else ;
  
#line 239 
  i = (int)index;
  
#line 239 
  goto ldv_61779;
  ldv_61778: 
#line 240 
  ;
  
#line 242 
  pile->list[i] = (unsigned short)0U;
  
#line 243 
  count += 1;
  
#line 241 
  i += 1;
  ldv_61779: 
#line 242 
  ;
  
#line 240 
  if ((int)pile->num_entries > i && (int)pile->list[i] == valid_id) 
#line 242 
                                                                    goto ldv_61778; else 
                                                                    
#line 245 
                                                                    goto ldv_61780;
  ldv_61780: 
#line 246 
  ;
  
#line 246 
  if (count != 0 && (int)pile->search_hint > (int)index) 
#line 247 
                                                         pile->search_hint = index; else ;
  
#line 249 
  __retres = count;
  return_label: 
#line 249 
                return __retres;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_vsi *i40e_find_vsi_from_id(struct i40e_pf *pf, u16 id)
{
  struct i40e_vsi *__retres;
  int i;
  
#line 261 
  i = 0;
  
#line 261 
  goto ldv_61787;
  ldv_61786: 
#line 262 
  ;
  
#line 262 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + i))->id == (int)id) {
    
#line 263 
    __retres = *(pf->vsi + i);
    
#line 263 
    goto return_label;
  }
  else ;
  
#line 261 
  i += 1;
  ldv_61787: 
#line 262 
  ;
  
#line 261 
  if ((int)pf->num_alloc_vsi > i) 
#line 263 
                                  goto ldv_61786; else 
#line 266 
                                                       goto ldv_61788;
  ldv_61788: 
#line 267 
  ;
  
#line 265 
  __retres = (struct i40e_vsi *)0;
  return_label: 
#line 265 
                return __retres;
}


#line 274  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_service_event_schedule(struct i40e_pf *pf)
{
  int tmp;
  
#line 276 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 276 
  if (tmp == 0) {
    int tmp_0;
    
#line 276 
    tmp_0 = constant_test_bit(9L,(unsigned long const volatile *)(& pf->state));
    
#line 276 
    if (tmp_0 == 0) {
      int tmp_1;
      
#line 277 
      tmp_1 = test_and_set_bit(5L,(unsigned long volatile *)(& pf->state));
      
#line 277 
      if (tmp_1 == 0) 
#line 279 
                      ldv_schedule_work_73(& pf->service_task); else ;
    }
    else ;
  }
  else ;
  
#line 280 
  return;
}


#line 291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_tx_timeout(struct net_device *netdev)
{
  int tmp_0;
  
#line 296 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 297 
  struct i40e_vsi *vsi = np->vsi;
  
#line 298 
  struct i40e_pf *pf = vsi->back;
  
#line 300 
  pf->tx_timeout_count += 1U;
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 302 
    tmp_0 = 1;
  }
  
#line 302 
  if (tmp_0 != 0) {
    int tmp_1;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 302 
      tmp_1 = 1;
    }
    
#line 302 
    if (tmp_1 != 0) {
      
#line 302 
      if ((long)((pf->tx_timeout_last_recovery - jiffies) + 5000UL) < 0L) 
        
#line 303 
        pf->tx_timeout_recovery_level = 1U; else ;
    }
    else ;
  }
  else ;
  
#line 304 
  pf->tx_timeout_last_recovery = jiffies;
  
#line 305 
  netdev_info((struct net_device const *)netdev,"tx_timeout recovery level %d\n",pf->tx_timeout_recovery_level);
  
#line 308 
  switch (pf->tx_timeout_recovery_level) {
    int tmp_2;
    case (u32)0: 
#line 309 
    ;
    
#line 311 
    tmp_2 = preempt_count();
    
#line 311 
    if (((unsigned long)tmp_2 & 2096896UL) != 0UL) {
      
#line 312 
      clear_bit(11L,(unsigned long volatile *)(& pf->state));
      
#line 313 
      clear_bit(11L,(unsigned long volatile *)(& vsi->state));
    }
    else 
#line 315 
         i40e_vsi_reinit_locked(vsi);
    
#line 317 
    goto ldv_61805;
    case (u32)1: 
#line 318 
    ;
    
#line 319 
    clear_bit(12L,(unsigned long volatile *)(& pf->state));
    
#line 320 
    goto ldv_61805;
    case (u32)2: 
#line 321 
    ;
    
#line 322 
    clear_bit(13L,(unsigned long volatile *)(& pf->state));
    
#line 323 
    goto ldv_61805;
    case (u32)3: 
#line 324 
    ;
    
#line 325 
    clear_bit(14L,(unsigned long volatile *)(& pf->state));
    
#line 326 
    goto ldv_61805;
    default: 
#line 327 
    ;
    
#line 328 
    netdev_err((struct net_device const *)netdev,"tx_timeout recovery unsuccessful\n");
    
#line 329 
    clear_bit(21L,(unsigned long volatile *)(& pf->state));
    
#line 330 
    clear_bit(21L,(unsigned long volatile *)(& vsi->state));
    
#line 331 
    goto ldv_61805;
  }
  ldv_61805: 
#line 333 
  ;
  
#line 333 
  i40e_service_event_schedule(pf);
  
#line 334 
  pf->tx_timeout_recovery_level += 1U;
  
#line 335 
  return;
}


#line 362  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct rtnl_link_stats64 *i40e_get_vsi_stats_struct(struct i40e_vsi *vsi)
{
  struct rtnl_link_stats64 *__retres;
  
#line 364 
  __retres = & vsi->net_stats;
  
#line 364 
  return __retres;
}


#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct rtnl_link_stats64 *i40e_get_netdev_stats_struct(struct net_device *netdev, struct rtnl_link_stats64 *stats)
{
  struct rtnl_link_stats64 *__retres;
  struct i40e_ring *tx_ring;
  struct i40e_ring *rx_ring;
  int i;
  int tmp_1;
  
#line 384 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 386 
  struct i40e_vsi *vsi = np->vsi;
  
#line 387 
  struct rtnl_link_stats64 *vsi_stats = i40e_get_vsi_stats_struct(vsi);
  
#line 390 
  tmp_1 = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
  
#line 390 
  if (tmp_1 != 0) {
    
#line 391 
    __retres = stats;
    
#line 391 
    goto return_label;
  }
  else ;
  
#line 393 
  if (vsi->tx_rings == (struct i40e_ring **)0) {
    
#line 394 
    __retres = stats;
    
#line 394 
    goto return_label;
  }
  else ;
  
#line 396 
  rcu_read_lock();
  
#line 397 
  i = 0;
  
#line 397 
  goto ldv_61838;
  ldv_61837: 
#line 398 
  ;
  {
    u64 bytes;
    u64 packets;
    unsigned int start;
    struct i40e_ring * volatile *tmp_2;
    bool tmp_3;
    bool tmp_4;
    {
      
#line 401 
      struct i40e_ring *__var = (struct i40e_ring *)0;
      
#line 401 
      tmp_2 = (struct i40e_ring * volatile *)(vsi->tx_rings + i);
    }
    
#line 401 
    tx_ring = *tmp_2;
    
#line 402 
    if (tx_ring == (struct i40e_ring *)0) 
#line 403 
                                          goto ldv_61832; else ;
    ldv_61833: 
#line 405 
    ;
    
#line 406 
    start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& tx_ring->syncp));
    
#line 407 
    packets = tx_ring->stats.packets;
    
#line 408 
    bytes = tx_ring->stats.bytes;
    
#line 409 
    tmp_3 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& tx_ring->syncp),start);
    
#line 409 
    if ((int)tmp_3 != 0) 
#line 411 
                         goto ldv_61833; else 
#line 414 
                                              goto ldv_61834;
    ldv_61834: 
#line 415 
    ;
    
#line 411 
    stats->tx_packets += packets;
    
#line 412 
    stats->tx_bytes += bytes;
    
#line 413 
    rx_ring = tx_ring + 1U;
    ldv_61835: 
#line 414 
    ;
    
#line 416 
    start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& rx_ring->syncp));
    
#line 417 
    packets = rx_ring->stats.packets;
    
#line 418 
    bytes = rx_ring->stats.bytes;
    
#line 419 
    tmp_4 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& rx_ring->syncp),start);
    
#line 419 
    if ((int)tmp_4 != 0) 
#line 421 
                         goto ldv_61835; else 
#line 424 
                                              goto ldv_61836;
    ldv_61836: 
#line 425 
    ;
    
#line 421 
    stats->rx_packets += packets;
    
#line 422 
    stats->rx_bytes += bytes;
  }
  ldv_61832: 
#line 424 
  ;
  
#line 397 
  i += 1;
  ldv_61838: 
#line 398 
  ;
  
#line 397 
  if ((int)vsi->num_queue_pairs > i) 
#line 399 
                                     goto ldv_61837; else 
#line 402 
                                                          goto ldv_61839;
  ldv_61839: 
#line 403 
  ;
  
#line 424 
  rcu_read_unlock();
  
#line 427 
  stats->multicast = vsi_stats->multicast;
  
#line 428 
  stats->tx_errors = vsi_stats->tx_errors;
  
#line 429 
  stats->tx_dropped = vsi_stats->tx_dropped;
  
#line 430 
  stats->rx_errors = vsi_stats->rx_errors;
  
#line 431 
  stats->rx_crc_errors = vsi_stats->rx_crc_errors;
  
#line 432 
  stats->rx_length_errors = vsi_stats->rx_length_errors;
  
#line 434 
  __retres = stats;
  return_label: 
#line 434 
                return __retres;
}


#line 441  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_reset_stats(struct i40e_vsi *vsi)
{
  struct rtnl_link_stats64 *ns;
  int i;
  
#line 446 
  if (vsi == (struct i40e_vsi *)0) 
#line 447 
                                   goto return_label; else ;
  
#line 449 
  ns = i40e_get_vsi_stats_struct(vsi);
  
#line 450 
  memset((void *)ns,0,184UL);
  
#line 451 
  memset((void *)(& vsi->net_stats_offsets),0,184UL);
  
#line 452 
  memset((void *)(& vsi->eth_stats),0,96UL);
  
#line 453 
  memset((void *)(& vsi->eth_stats_offsets),0,96UL);
  
#line 454 
  if (vsi->rx_rings != (struct i40e_ring **)0 && *(vsi->rx_rings) != (struct i40e_ring *)0) {
    
#line 455 
    i = 0;
    
#line 455 
    goto ldv_61846;
    ldv_61845: 
#line 456 
    ;
    
#line 456 
    memset((void *)(& (*(vsi->rx_rings + i))->stats),0,16UL);
    
#line 458 
    memset((void *)(& (*(vsi->rx_rings + i))->__anonCompField_i40e_ring_122.rx_stats),0,24UL);
    
#line 460 
    memset((void *)(& (*(vsi->tx_rings + i))->stats),0,16UL);
    
#line 462 
    memset((void *)(& (*(vsi->tx_rings + i))->__anonCompField_i40e_ring_122.tx_stats),0,24UL);
    
#line 455 
    i += 1;
    ldv_61846: 
#line 456 
    ;
    
#line 455 
    if ((int)vsi->num_queue_pairs > i) 
#line 457 
                                       goto ldv_61845; else 
#line 460 
                                                            goto ldv_61847;
    ldv_61847: 
#line 461 
    ;
  }
  else ;
  
#line 466 
  vsi->stat_offsets_loaded = (_Bool)0;
  return_label: 
#line 467 
                return;
}


#line 473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_pf_reset_stats(struct i40e_pf *pf)
{
  int i;
  
#line 477 
  memset((void *)(& pf->stats),0,712UL);
  
#line 478 
  memset((void *)(& pf->stats_offsets),0,712UL);
  
#line 479 
  pf->stat_offsets_loaded = (_Bool)0;
  
#line 481 
  i = 0;
  
#line 481 
  goto ldv_61853;
  ldv_61852: 
#line 482 
  ;
  
#line 482 
  if (pf->veb[i] != (struct i40e_veb *)0) {
    
#line 483 
    memset((void *)(& (pf->veb[i])->stats),0,96UL);
    
#line 485 
    memset((void *)(& (pf->veb[i])->stats_offsets),0,96UL);
    
#line 487 
    (pf->veb[i])->stat_offsets_loaded = (_Bool)0;
  }
  else ;
  
#line 481 
  i += 1;
  ldv_61853: 
#line 482 
  ;
  
#line 481 
  if (i <= 15) 
#line 483 
               goto ldv_61852; else 
#line 486 
                                    goto ldv_61854;
  ldv_61854: 
#line 487 
  ;
  
#line 488 
  return;
}


#line 507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_stat_update48(struct i40e_hw *hw, u32 hireg, u32 loreg, bool offset_loaded, u64 *offset, u64 *stat)
{
  u64 new_data;
  
#line 512 
  if ((unsigned int)hw->device_id == 5492U) {
    unsigned int tmp;
    unsigned int tmp_0;
    
#line 513 
    tmp = readl((void const volatile *)(hw->hw_addr + loreg));
    
#line 513 
    new_data = (unsigned long long)tmp;
    
#line 514 
    tmp_0 = readl((void const volatile *)(hw->hw_addr + hireg));
    
#line 514 
    new_data = (((unsigned long long)tmp_0 << 32) & 281470681743360ULL) | new_data;
  }
  else 
#line 516 
       new_data = (u64)readq((void const volatile *)(hw->hw_addr + loreg));
  
#line 518 
  if (! offset_loaded) 
#line 519 
                       *offset = new_data; else ;
  
#line 520 
  if ((long)(*offset <= new_data) != 0L) 
#line 521 
                                         *stat = new_data - *offset; else 
                                                                    
#line 523 
                                                                    *stat = (new_data - *offset) + 281474976710656ULL;
  
#line 524 
  *stat &= 281474976710655ULL;
  
#line 525 
  return;
}


#line 535  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_stat_update32(struct i40e_hw *hw, u32 reg, bool offset_loaded, u64 *offset, u64 *stat)
{
  u32 new_data;
  
#line 540 
  new_data = readl((void const volatile *)(hw->hw_addr + reg));
  
#line 541 
  if (! offset_loaded) 
#line 542 
                       *offset = (unsigned long long)new_data; else ;
  
#line 543 
  if ((long)((unsigned long long)new_data >= *offset) != 0L) 
#line 544 
                                                             *stat = (unsigned long long)(new_data - (unsigned int)*offset); else 
                                                                    
#line 546 
                                                                    *stat = (unsigned long long)(new_data - (unsigned int)*offset);
  
#line 547 
  return;
}


#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_update_eth_stats(struct i40e_vsi *vsi)
{
  struct i40e_eth_stats *oes;
  struct i40e_eth_stats *es;
  
#line 555 
  int stat_idx = (int)vsi->info.stat_counter_idx;
  
#line 556 
  struct i40e_pf *pf = vsi->back;
  
#line 557 
  struct i40e_hw *hw = & pf->hw;
  
#line 561 
  es = & vsi->eth_stats;
  
#line 562 
  oes = & vsi->eth_stats_offsets;
  
#line 565 
  i40e_stat_update32(hw,(unsigned int)((stat_idx + 856064) * 4),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_errors,& es->tx_errors);
  
#line 568 
  i40e_stat_update32(hw,(unsigned int)((stat_idx + 401408) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_discards,& es->rx_discards);
  
#line 571 
  i40e_stat_update32(hw,(unsigned int)((stat_idx + 449664) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_unknown_protocol,& es->rx_unknown_protocol);
  
#line 574 
  i40e_stat_update32(hw,(unsigned int)((stat_idx + 856064) * 4),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_errors,& es->tx_errors);
  
#line 578 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3506180),(unsigned int)((stat_idx + 438272) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_bytes,& es->rx_bytes);
  
#line 582 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3588100),(unsigned int)((stat_idx + 448512) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_unicast,& es->rx_unicast);
  
#line 586 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3591172),(unsigned int)((stat_idx + 448896) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_multicast,& es->rx_multicast);
  
#line 590 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3594244),(unsigned int)((stat_idx + 449280) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_broadcast,& es->rx_broadcast);
  
#line 595 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3309572),(unsigned int)((stat_idx + 413696) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_bytes,& es->tx_bytes);
  
#line 599 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3391492),(unsigned int)((stat_idx + 423936) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_unicast,& es->tx_unicast);
  
#line 603 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3394564),(unsigned int)((stat_idx + 424320) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_multicast,& es->tx_multicast);
  
#line 607 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3397636),(unsigned int)((stat_idx + 424704) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_broadcast,& es->tx_broadcast);
  
#line 611 
  vsi->stat_offsets_loaded = (_Bool)1;
  
#line 612 
  return;
}


#line 618  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_update_veb_stats(struct i40e_veb *veb)
{
  struct i40e_eth_stats *oes;
  struct i40e_eth_stats *es;
  
#line 620 
  struct i40e_pf *pf = veb->pf;
  
#line 621 
  struct i40e_hw *hw = & pf->hw;
  
#line 624 
  int idx = 0;
  
#line 626 
  idx = (int)veb->stats_idx;
  
#line 627 
  es = & veb->stats;
  
#line 628 
  oes = & veb->stats_offsets;
  
#line 631 
  i40e_stat_update32(hw,(unsigned int)((idx + 430080) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_discards,& es->tx_discards);
  
#line 634 
  if ((unsigned int)hw->revision_id != 0U) 
#line 635 
                                           i40e_stat_update32(hw,(unsigned int)((idx + 450608) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_unknown_protocol,& es->rx_unknown_protocol); else ;
  
#line 639 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3522564),(unsigned int)((idx + 440320) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_bytes,& es->rx_bytes);
  
#line 642 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3604484),(unsigned int)((idx + 450560) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_unicast,& es->rx_unicast);
  
#line 645 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3604612),(unsigned int)((idx + 450576) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_multicast,& es->rx_multicast);
  
#line 648 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3604740),(unsigned int)((idx + 450592) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_broadcast,& es->rx_broadcast);
  
#line 652 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3325956),(unsigned int)((idx + 415744) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_bytes,& es->tx_bytes);
  
#line 655 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3407876),(unsigned int)((idx + 425984) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_unicast,& es->tx_unicast);
  
#line 658 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3408004),(unsigned int)((idx + 426000) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_multicast,& es->tx_multicast);
  
#line 661 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3408132),(unsigned int)((idx + 426016) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_broadcast,& es->tx_broadcast);
  
#line 664 
  veb->stat_offsets_loaded = (_Bool)1;
  
#line 665 
  return;
}


#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_update_fcoe_stats(struct i40e_vsi *vsi)
{
  struct i40e_fcoe_stats *ofs;
  struct i40e_fcoe_stats *fs;
  int idx;
  
#line 674 
  struct i40e_pf *pf = vsi->back;
  
#line 675 
  struct i40e_hw *hw = & pf->hw;
  
#line 680 
  if (vsi->type != (unsigned int)I40E_VSI_FCOE) 
#line 681 
                                                goto return_label; else ;
  
#line 683 
  idx = (int)pf->pf_seid + 112;
  
#line 684 
  fs = & vsi->fcoe_stats;
  
#line 685 
  ofs = & vsi->fcoe_stats_offsets;
  
#line 687 
  i40e_stat_update32(hw,(unsigned int)((idx + 404032) * 8),(_Bool)((bool)((int)vsi->fcoe_stat_offsets_loaded) != 0),& ofs->rx_fcoe_packets,& fs->rx_fcoe_packets);
  
#line 690 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3276804),(unsigned int)((idx + 409600) * 8),(_Bool)((bool)((int)vsi->fcoe_stat_offsets_loaded) != 0),& ofs->rx_fcoe_dwords,& fs->rx_fcoe_dwords);
  
#line 693 
  i40e_stat_update32(hw,(unsigned int)((idx + 411648) * 8),(_Bool)((bool)((int)vsi->fcoe_stat_offsets_loaded) != 0),& ofs->rx_fcoe_dropped,& fs->rx_fcoe_dropped);
  
#line 696 
  i40e_stat_update32(hw,(unsigned int)((idx + 428416) * 8),(_Bool)((bool)((int)vsi->fcoe_stat_offsets_loaded) != 0),& ofs->tx_fcoe_packets,& fs->tx_fcoe_packets);
  
#line 699 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3440772),(unsigned int)((idx + 430096) * 8),(_Bool)((bool)((int)vsi->fcoe_stat_offsets_loaded) != 0),& ofs->tx_fcoe_dwords,& fs->tx_fcoe_dwords);
  
#line 702 
  i40e_stat_update32(hw,(unsigned int)((idx + 403888) * 8),(_Bool)((bool)((int)vsi->fcoe_stat_offsets_loaded) != 0),& ofs->fcoe_bad_fccrc,& fs->fcoe_bad_fccrc);
  
#line 705 
  i40e_stat_update32(hw,(unsigned int)((idx + 403456) * 8),(_Bool)((bool)((int)vsi->fcoe_stat_offsets_loaded) != 0),& ofs->fcoe_last_error,& fs->fcoe_last_error);
  
#line 708 
  i40e_stat_update32(hw,(unsigned int)((idx + 403600) * 8),(_Bool)((bool)((int)vsi->fcoe_stat_offsets_loaded) != 0),& ofs->fcoe_ddp_count,& fs->fcoe_ddp_count);
  
#line 712 
  vsi->fcoe_stat_offsets_loaded = (_Bool)1;
  return_label: 
#line 713 
                return;
}


#line 722  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_update_link_xoff_rx(struct i40e_pf *pf)
{
  u16 i;
  u16 v;
  
#line 724 
  struct i40e_hw_port_stats *osd = & pf->stats_offsets;
  
#line 725 
  struct i40e_hw_port_stats *nsd = & pf->stats;
  
#line 726 
  struct i40e_hw *hw = & pf->hw;
  
#line 727 
  u64 xoff = 0ULL;
  
#line 730 
  if (hw->fc.current_mode != (unsigned int)I40E_FC_FULL && hw->fc.current_mode != (unsigned int)I40E_FC_RX_PAUSE) 
    
#line 732 
    goto return_label; else ;
  
#line 734 
  xoff = nsd->link_xoff_rx;
  
#line 735 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393260) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->link_xoff_rx,& nsd->link_xoff_rx);
  
#line 740 
  if (nsd->link_xoff_rx == xoff) 
#line 741 
                                 goto return_label; else ;
  
#line 744 
  v = (unsigned short)0U;
  
#line 744 
  goto ldv_61912;
  ldv_61911: 
#line 745 
  ;
  {
    
#line 745 
    struct i40e_vsi *vsi = *(pf->vsi + (int)v);
    
#line 747 
    if (vsi == (struct i40e_vsi *)0 || *(vsi->tx_rings) == (struct i40e_ring *)0) 
      
#line 748 
      goto ldv_61906; else ;
    
#line 750 
    i = (unsigned short)0U;
    
#line 750 
    goto ldv_61909;
    ldv_61908: 
#line 751 
    ;
    {
      
#line 751 
      struct i40e_ring *ring = *(vsi->tx_rings + (int)i);
      
#line 752 
      clear_bit(3L,(unsigned long volatile *)(& ring->state));
    }
    
#line 750 
    i = (u16)((int)i + 1);
    ldv_61909: 
#line 751 
    ;
    
#line 750 
    if ((int)vsi->num_queue_pairs > (int)i) 
#line 752 
                                            goto ldv_61908; else 
#line 755 
                                                                 goto ldv_61910;
    ldv_61910: 
#line 756 
    ;
  }
  ldv_61906: 
#line 758 
  ;
  
#line 744 
  v = (u16)((int)v + 1);
  ldv_61912: 
#line 745 
  ;
  
#line 744 
  if ((int)pf->num_alloc_vsi > (int)v) 
#line 746 
                                       goto ldv_61911; else 
#line 749 
                                                            goto ldv_61913;
  ldv_61913: 
#line 750 
  ;
  return_label: 
#line 751 
                return;
}


#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_update_prio_xoff_rx(struct i40e_pf *pf)
{
  struct i40e_dcbx_config *dcb_cfg;
  u16 i;
  u16 v;
  u8 tc;
  
#line 765 
  struct i40e_hw_port_stats *osd = & pf->stats_offsets;
  
#line 766 
  struct i40e_hw_port_stats *nsd = & pf->stats;
  
#line 767 
  bool xoff[8U] = {(_Bool)0};
  
#line 769 
  struct i40e_hw *hw = & pf->hw;
  
#line 773 
  dcb_cfg = & hw->local_dcbx_config;
  
#line 776 
  if ((unsigned int)dcb_cfg->pfc.pfcenable == 0U) {
    
#line 777 
    i40e_update_link_xoff_rx(pf);
    
#line 778 
    goto return_label;
  }
  else ;
  
#line 781 
  i = (unsigned short)0U;
  
#line 781 
  goto ldv_61928;
  ldv_61927: 
#line 782 
  ;
  {
    
#line 782 
    u64 prio_xoff = nsd->priority_xoff_rx[(int)i];
    
#line 783 
    i40e_stat_update32(hw,(unsigned int)((((int)hw->port + (int)i * 4) + 393296) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xoff_rx[(int)i],& nsd->priority_xoff_rx[(int)i]);
    
#line 789 
    if (nsd->priority_xoff_rx[(int)i] == prio_xoff) 
#line 790 
                                                    goto ldv_61926; else ;
    
#line 792 
    tc = dcb_cfg->etscfg.prioritytable[(int)i];
    
#line 793 
    xoff[(int)tc] = (_Bool)1;
  }
  ldv_61926: 
#line 795 
  ;
  
#line 781 
  i = (u16)((int)i + 1);
  ldv_61928: 
#line 782 
  ;
  
#line 781 
  if ((unsigned int)i <= 7U) 
#line 783 
                             goto ldv_61927; else 
#line 786 
                                                  goto ldv_61929;
  ldv_61929: 
#line 787 
  ;
  
#line 797 
  v = (unsigned short)0U;
  
#line 797 
  goto ldv_61937;
  ldv_61936: 
#line 798 
  ;
  {
    
#line 798 
    struct i40e_vsi *vsi = *(pf->vsi + (int)v);
    
#line 800 
    if (vsi == (struct i40e_vsi *)0 || *(vsi->tx_rings) == (struct i40e_ring *)0) 
      
#line 801 
      goto ldv_61931; else ;
    
#line 803 
    i = (unsigned short)0U;
    
#line 803 
    goto ldv_61934;
    ldv_61933: 
#line 804 
    ;
    {
      
#line 804 
      struct i40e_ring *ring = *(vsi->tx_rings + (int)i);
      
#line 806 
      tc = ring->dcb_tc;
      
#line 807 
      if ((int)xoff[(int)tc] != 0) 
#line 808 
                                   clear_bit(3L,(unsigned long volatile *)(& ring->state)); else ;
    }
    
#line 803 
    i = (u16)((int)i + 1);
    ldv_61934: 
#line 804 
    ;
    
#line 803 
    if ((int)vsi->num_queue_pairs > (int)i) 
#line 805 
                                            goto ldv_61933; else 
#line 808 
                                                                 goto ldv_61935;
    ldv_61935: 
#line 809 
    ;
  }
  ldv_61931: 
#line 811 
  ;
  
#line 797 
  v = (u16)((int)v + 1);
  ldv_61937: 
#line 798 
  ;
  
#line 797 
  if ((int)pf->num_alloc_vsi > (int)v) 
#line 799 
                                       goto ldv_61936; else 
#line 802 
                                                            goto ldv_61938;
  ldv_61938: 
#line 803 
  ;
  return_label: 
#line 804 
                return;
}


#line 824  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_update_vsi_stats(struct i40e_vsi *vsi)
{
  struct rtnl_link_stats64 *ons;
  struct rtnl_link_stats64 *ns;
  struct i40e_eth_stats *oes;
  struct i40e_eth_stats *es;
  u32 tx_restart;
  u32 tx_busy;
  struct i40e_ring *p;
  u32 rx_page;
  u32 rx_buf;
  u64 bytes;
  u64 packets;
  unsigned int start;
  u64 rx_p;
  u64 rx_b;
  u64 tx_p;
  u64 tx_b;
  u16 q;
  int tmp;
  struct i40e_ring * volatile *tmp_1;
  bool tmp_2;
  bool tmp_3;
  
#line 826 
  struct i40e_pf *pf = vsi->back;
  
#line 840 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
  
#line 840 
  if (tmp != 0) 
#line 842 
                goto return_label;
  else {
    int tmp_0;
    
#line 840 
    tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& pf->state));
    
#line 840 
    if (tmp_0 != 0) 
#line 842 
                    goto return_label; else ;
  }
  
#line 844 
  ns = i40e_get_vsi_stats_struct(vsi);
  
#line 845 
  ons = & vsi->net_stats_offsets;
  
#line 846 
  es = & vsi->eth_stats;
  
#line 847 
  oes = & vsi->eth_stats_offsets;
  
#line 852 
  rx_p = 0ULL;
  
#line 852 
  rx_b = rx_p;
  
#line 853 
  tx_p = 0ULL;
  
#line 853 
  tx_b = tx_p;
  
#line 854 
  tx_busy = 0U;
  
#line 854 
  tx_restart = tx_busy;
  
#line 855 
  rx_page = 0U;
  
#line 856 
  rx_buf = 0U;
  
#line 857 
  rcu_read_lock();
  
#line 858 
  q = (unsigned short)0U;
  
#line 858 
  goto ldv_61967;
  ldv_61966: 
#line 859 
  ;
  {
    
#line 860 
    struct i40e_ring *__var = (struct i40e_ring *)0;
    
#line 860 
    tmp_1 = (struct i40e_ring * volatile *)(vsi->tx_rings + (int)q);
  }
  
#line 860 
  p = *tmp_1;
  ldv_61962: 
#line 862 
  ;
  
#line 863 
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& p->syncp));
  
#line 864 
  packets = p->stats.packets;
  
#line 865 
  bytes = p->stats.bytes;
  
#line 866 
  tmp_2 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& p->syncp),start);
  
#line 866 
  if ((int)tmp_2 != 0) 
#line 868 
                       goto ldv_61962; else 
#line 871 
                                            goto ldv_61963;
  ldv_61963: 
#line 872 
  ;
  
#line 867 
  tx_b += bytes;
  
#line 868 
  tx_p += packets;
  
#line 869 
  tx_restart = (unsigned int)p->__anonCompField_i40e_ring_122.tx_stats.restart_queue + tx_restart;
  
#line 870 
  tx_busy = (unsigned int)p->__anonCompField_i40e_ring_122.tx_stats.tx_busy + tx_busy;
  
#line 873 
  p += 1U;
  ldv_61964: 
#line 874 
  ;
  
#line 875 
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& p->syncp));
  
#line 876 
  packets = p->stats.packets;
  
#line 877 
  bytes = p->stats.bytes;
  
#line 878 
  tmp_3 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& p->syncp),start);
  
#line 878 
  if ((int)tmp_3 != 0) 
#line 880 
                       goto ldv_61964; else 
#line 883 
                                            goto ldv_61965;
  ldv_61965: 
#line 884 
  ;
  
#line 879 
  rx_b += bytes;
  
#line 880 
  rx_p += packets;
  
#line 881 
  rx_buf = (unsigned int)p->__anonCompField_i40e_ring_122.rx_stats.alloc_buff_failed + rx_buf;
  
#line 882 
  rx_page = (unsigned int)p->__anonCompField_i40e_ring_122.rx_stats.alloc_page_failed + rx_page;
  
#line 858 
  q = (u16)((int)q + 1);
  ldv_61967: 
#line 859 
  ;
  
#line 858 
  if ((int)vsi->num_queue_pairs > (int)q) 
#line 860 
                                          goto ldv_61966; else 
#line 863 
                                                               goto ldv_61968;
  ldv_61968: 
#line 864 
  ;
  
#line 884 
  rcu_read_unlock();
  
#line 885 
  vsi->tx_restart = tx_restart;
  
#line 886 
  vsi->tx_busy = tx_busy;
  
#line 887 
  vsi->rx_page_failed = rx_page;
  
#line 888 
  vsi->rx_buf_failed = rx_buf;
  
#line 890 
  ns->rx_packets = rx_p;
  
#line 891 
  ns->rx_bytes = rx_b;
  
#line 892 
  ns->tx_packets = tx_p;
  
#line 893 
  ns->tx_bytes = tx_b;
  
#line 896 
  i40e_update_eth_stats(vsi);
  
#line 897 
  ons->tx_errors = oes->tx_errors;
  
#line 898 
  ns->tx_errors = es->tx_errors;
  
#line 899 
  ons->multicast = oes->rx_multicast;
  
#line 900 
  ns->multicast = es->rx_multicast;
  
#line 901 
  ons->rx_dropped = oes->rx_discards;
  
#line 902 
  ns->rx_dropped = es->rx_discards;
  
#line 903 
  ons->tx_dropped = oes->tx_discards;
  
#line 904 
  ns->tx_dropped = es->tx_discards;
  
#line 907 
  if (*(pf->vsi + (int)pf->lan_vsi) == vsi) {
    
#line 908 
    ns->rx_crc_errors = pf->stats.crc_errors;
    
#line 909 
    ns->rx_errors = pf->stats.crc_errors + pf->stats.illegal_bytes;
    
#line 910 
    ns->rx_length_errors = pf->stats.rx_length_errors;
  }
  else ;
  return_label: 
#line 912 
                return;
}


#line 918  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_update_pf_stats(struct i40e_pf *pf)
{
  u32 val;
  int i;
  
#line 920 
  struct i40e_hw_port_stats *osd = & pf->stats_offsets;
  
#line 921 
  struct i40e_hw_port_stats *nsd = & pf->stats;
  
#line 922 
  struct i40e_hw *hw = & pf->hw;
  
#line 926 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3145732),(unsigned int)(((int)hw->port + 393216) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_bytes,& nsd->eth.rx_bytes);
  
#line 930 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147396),(unsigned int)(((int)hw->port + 393424) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.tx_bytes,& nsd->eth.tx_bytes);
  
#line 934 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393408) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_discards,& nsd->eth.rx_discards);
  
#line 938 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147172),(unsigned int)(((int)hw->port + 393396) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_unicast,& nsd->eth.rx_unicast);
  
#line 943 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147204),(unsigned int)(((int)hw->port + 393400) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_multicast,& nsd->eth.rx_multicast);
  
#line 948 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147236),(unsigned int)(((int)hw->port + 393404) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_broadcast,& nsd->eth.rx_broadcast);
  
#line 953 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3148228),(unsigned int)(((int)hw->port + 393528) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.tx_unicast,& nsd->eth.tx_unicast);
  
#line 958 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3148260),(unsigned int)(((int)hw->port + 393532) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.tx_multicast,& nsd->eth.tx_multicast);
  
#line 963 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3148292),(unsigned int)(((int)hw->port + 393536) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.tx_broadcast,& nsd->eth.tx_broadcast);
  
#line 969 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393540) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_dropped_link_down,& nsd->tx_dropped_link_down);
  
#line 974 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393232) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->crc_errors,& nsd->crc_errors);
  
#line 978 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393244) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->illegal_bytes,& nsd->illegal_bytes);
  
#line 982 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393220) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->mac_local_faults,& nsd->mac_local_faults);
  
#line 986 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393224) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->mac_remote_faults,& nsd->mac_remote_faults);
  
#line 991 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393236) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_length_errors,& nsd->rx_length_errors);
  
#line 996 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393256) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->link_xon_rx,& nsd->link_xon_rx);
  
#line 999 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393520) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->link_xon_tx,& nsd->link_xon_tx);
  
#line 1002 
  i40e_update_prio_xoff_rx(pf);
  
#line 1003 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393524) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->link_xoff_tx,& nsd->link_xoff_tx);
  
#line 1007 
  i = 0;
  
#line 1007 
  goto ldv_61978;
  ldv_61977: 
#line 1008 
  ;
  
#line 1008 
  i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393264) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xon_rx[i],& nsd->priority_xon_rx[i]);
  
#line 1012 
  i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393456) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xon_tx[i],& nsd->priority_xon_tx[i]);
  
#line 1016 
  i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393488) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xoff_tx[i],& nsd->priority_xoff_tx[i]);
  
#line 1020 
  i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393328) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xon_2_xoff[i],& nsd->priority_xon_2_xoff[i]);
  
#line 1007 
  i += 1;
  ldv_61978: 
#line 1008 
  ;
  
#line 1007 
  if (i <= 7) 
#line 1009 
              goto ldv_61977; else 
#line 1012 
                                   goto ldv_61979;
  ldv_61979: 
#line 1013 
  ;
  
#line 1027 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3146884),(unsigned int)(((int)hw->port + 393360) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_64,& nsd->rx_size_64);
  
#line 1031 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3146916),(unsigned int)(((int)hw->port + 393364) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_127,& nsd->rx_size_127);
  
#line 1035 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3146948),(unsigned int)(((int)hw->port + 393368) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_255,& nsd->rx_size_255);
  
#line 1039 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3146980),(unsigned int)(((int)hw->port + 393372) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_511,& nsd->rx_size_511);
  
#line 1043 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147012),(unsigned int)(((int)hw->port + 393376) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_1023,& nsd->rx_size_1023);
  
#line 1047 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147044),(unsigned int)(((int)hw->port + 393380) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_1522,& nsd->rx_size_1522);
  
#line 1051 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147076),(unsigned int)(((int)hw->port + 393384) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_big,& nsd->rx_size_big);
  
#line 1056 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147428),(unsigned int)(((int)hw->port + 393428) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_64,& nsd->tx_size_64);
  
#line 1060 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147460),(unsigned int)(((int)hw->port + 393432) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_127,& nsd->tx_size_127);
  
#line 1064 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147492),(unsigned int)(((int)hw->port + 393436) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_255,& nsd->tx_size_255);
  
#line 1068 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147524),(unsigned int)(((int)hw->port + 393440) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_511,& nsd->tx_size_511);
  
#line 1072 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147556),(unsigned int)(((int)hw->port + 393444) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_1023,& nsd->tx_size_1023);
  
#line 1076 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147588),(unsigned int)(((int)hw->port + 393448) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_1522,& nsd->tx_size_1522);
  
#line 1080 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147620),(unsigned int)(((int)hw->port + 393452) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_big,& nsd->tx_size_big);
  
#line 1085 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393248) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_undersize,& nsd->rx_undersize);
  
#line 1088 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393388) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_fragments,& nsd->rx_fragments);
  
#line 1091 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393252) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_oversize,& nsd->rx_oversize);
  
#line 1094 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393392) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_jabber,& nsd->rx_jabber);
  
#line 1099 
  i40e_stat_update32(hw,(unsigned int)((int)pf->hw.pf_id * 12 + 2516992),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->fd_atr_match,& nsd->fd_atr_match);
  
#line 1103 
  i40e_stat_update32(hw,(unsigned int)(((int)pf->hw.pf_id * 3 + 629249) * 4),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->fd_sb_match,& nsd->fd_sb_match);
  
#line 1107 
  i40e_stat_update32(hw,(unsigned int)(((int)pf->hw.pf_id * 3 + 629250) * 4),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->fd_atr_tunnel_match,& nsd->fd_atr_tunnel_match);
  
#line 1112 
  val = readl((void const volatile *)(hw->hw_addr + 1983264U));
  
#line 1113 
  nsd->tx_lpi_status = val >> 31;
  
#line 1116 
  nsd->rx_lpi_status = (val >> 30) & 1U;
  
#line 1119 
  i40e_stat_update32(hw,1983424U,(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_lpi_count,& nsd->tx_lpi_count);
  
#line 1122 
  i40e_stat_update32(hw,1983392U,(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_lpi_count,& nsd->rx_lpi_count);
  
#line 1126 
  pf->stat_offsets_loaded = (_Bool)1;
  
#line 1127 
  return;
}


#line 1135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_update_stats(struct i40e_vsi *vsi)
{
  
#line 1137 
  struct i40e_pf *pf = vsi->back;
  
#line 1139 
  if (*(pf->vsi + (int)pf->lan_vsi) == vsi) 
#line 1140 
                                            i40e_update_pf_stats(pf); else ;
  
#line 1142 
  i40e_update_vsi_stats(vsi);
  
#line 1144 
  i40e_update_fcoe_stats(vsi);
  
#line 1145 
  return;
}


#line 1158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct i40e_mac_filter *i40e_find_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan, bool is_vf, bool is_netdev)
{
  struct i40e_mac_filter *__retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *tmp;
  bool tmp_0;
  struct i40e_mac_filter *tmp_1;
  
#line 1164 
  if (vsi == (struct i40e_vsi *)0 || macaddr == (u8 *)0U) {
    
#line 1165 
    __retres = (struct i40e_mac_filter *)0;
    
#line 1165 
    goto return_label;
  }
  else ;
  {
    
#line 1167 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 1167 
    tmp = (struct i40e_mac_filter *)__mptr;
  }
  
#line 1167 
  f = tmp;
  
#line 1167 
  goto ldv_61997;
  ldv_61996: 
#line 1168 
  ;
  
#line 1168 
  tmp_0 = ether_addr_equal((u8 const *)macaddr,(u8 const *)(& f->macaddr));
  
#line 1168 
  if ((int)tmp_0 != 0) {
    
#line 1168 
    if ((int)f->vlan == (int)vlan) {
      
#line 1170 
      if (! is_vf || (int)f->is_vf != 0) {
        
#line 1171 
        if (! is_netdev || (int)f->is_netdev != 0) {
          
#line 1172 
          __retres = f;
          
#line 1172 
          goto return_label;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  {
    
#line 1167 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 1167 
    tmp_1 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 1167 
  f = tmp_1;
  ldv_61997: 
#line 1169 
  ;
  
#line 1167 
  if (& f->list != & vsi->mac_filter_list) 
#line 1169 
                                           goto ldv_61996; else 
#line 1172 
                                                                goto ldv_61998;
  ldv_61998: 
#line 1173 
  ;
  
#line 1174 
  __retres = (struct i40e_mac_filter *)0;
  return_label: 
#line 1174 
                return __retres;
}


#line 1187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, u8 *macaddr, bool is_vf, bool is_netdev)
{
  struct i40e_mac_filter *__retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *tmp;
  bool tmp_0;
  struct i40e_mac_filter *tmp_1;
  
#line 1192 
  if (vsi == (struct i40e_vsi *)0 || macaddr == (u8 *)0U) {
    
#line 1193 
    __retres = (struct i40e_mac_filter *)0;
    
#line 1193 
    goto return_label;
  }
  else ;
  {
    
#line 1195 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 1195 
    tmp = (struct i40e_mac_filter *)__mptr;
  }
  
#line 1195 
  f = tmp;
  
#line 1195 
  goto ldv_62011;
  ldv_62010: 
#line 1196 
  ;
  
#line 1196 
  tmp_0 = ether_addr_equal((u8 const *)macaddr,(u8 const *)(& f->macaddr));
  
#line 1196 
  if ((int)tmp_0 != 0) {
    
#line 1197 
    if (! is_vf || (int)f->is_vf != 0) {
      
#line 1198 
      if (! is_netdev || (int)f->is_netdev != 0) {
        
#line 1199 
        __retres = f;
        
#line 1199 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  {
    
#line 1195 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 1195 
    tmp_1 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 1195 
  f = tmp_1;
  ldv_62011: 
#line 1197 
  ;
  
#line 1195 
  if (& f->list != & vsi->mac_filter_list) 
#line 1197 
                                           goto ldv_62010; else 
#line 1200 
                                                                goto ldv_62012;
  ldv_62012: 
#line 1201 
  ;
  
#line 1201 
  __retres = (struct i40e_mac_filter *)0;
  return_label: 
#line 1201 
                return __retres;
}


#line 1210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi)
{
  bool __retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *tmp;
  struct i40e_mac_filter *tmp_0;
  {
    
#line 1217 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 1217 
    tmp = (struct i40e_mac_filter *)__mptr;
  }
  
#line 1217 
  f = tmp;
  
#line 1217 
  goto ldv_62022;
  ldv_62021: 
#line 1218 
  ;
  
#line 1218 
  if ((int)f->vlan >= 0) {
    
#line 1219 
    __retres = (_Bool)1;
    
#line 1219 
    goto return_label;
  }
  else ;
  {
    
#line 1217 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 1217 
    tmp_0 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 1217 
  f = tmp_0;
  ldv_62022: 
#line 1219 
  ;
  
#line 1217 
  if (& f->list != & vsi->mac_filter_list) 
#line 1219 
                                           goto ldv_62021; else 
#line 1222 
                                                                goto ldv_62023;
  ldv_62023: 
#line 1223 
  ;
  
#line 1222 
  __retres = (_Bool)0;
  return_label: 
#line 1222 
                return __retres;
}


#line 1237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi, u8 *macaddr, bool is_vf, bool is_netdev)
{
  struct i40e_mac_filter *__retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *tmp;
  struct i40e_mac_filter *tmp_1;
  struct i40e_mac_filter *tmp_2;
  struct i40e_mac_filter *tmp_5;
  int tmp_3;
  {
    
#line 1242 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 1242 
    tmp = (struct i40e_mac_filter *)__mptr;
  }
  
#line 1242 
  f = tmp;
  
#line 1242 
  goto ldv_62036;
  ldv_62035: 
#line 1243 
  ;
  
#line 1243 
  tmp_1 = i40e_find_filter(vsi,macaddr,(short)((int)f->vlan),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
  
#line 1243 
  if (tmp_1 == (struct i40e_mac_filter *)0) {
    struct i40e_mac_filter *tmp_0;
    
#line 1245 
    tmp_0 = i40e_add_filter(vsi,macaddr,(short)((int)f->vlan),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
    
#line 1245 
    if (tmp_0 == (struct i40e_mac_filter *)0) {
      
#line 1247 
      __retres = (struct i40e_mac_filter *)0;
      
#line 1247 
      goto return_label;
    }
    else ;
  }
  else ;
  {
    
#line 1242 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 1242 
    tmp_2 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 1242 
  f = tmp_2;
  ldv_62036: 
#line 1244 
  ;
  
#line 1242 
  if (& f->list != & vsi->mac_filter_list) 
#line 1244 
                                           goto ldv_62035; else 
#line 1247 
                                                                goto ldv_62037;
  ldv_62037: 
#line 1248 
  ;
  
#line 1251 
  tmp_3 = list_empty((struct list_head const *)(& vsi->mac_filter_list));
  
#line 1251 
  if (tmp_3 == 0) {
    struct i40e_mac_filter *tmp_4;
    {
      
#line 1251 
      struct list_head const *__mptr_1 = (struct list_head const *)vsi->mac_filter_list.next;
      
#line 1251 
      tmp_4 = (struct i40e_mac_filter *)__mptr_1;
    }
    
#line 1251 
    tmp_5 = tmp_4;
  }
  else 
#line 1251 
       tmp_5 = (struct i40e_mac_filter *)0;
  
#line 1251 
  __retres = tmp_5;
  return_label: 
#line 1251 
                return __retres;
}


#line 1263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_rm_default_mac_filter(struct i40e_vsi *vsi, u8 *macaddr)
{
  int __retres;
  struct i40e_aqc_remove_macvlan_element_data element;
  i40e_status aq_ret;
  
#line 1266 
  struct i40e_pf *pf = vsi->back;
  
#line 1270 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) {
    
#line 1271 
    __retres = -22;
    
#line 1271 
    goto return_label;
  }
  else ;
  
#line 1273 
  memset((void *)(& element),0,16UL);
  
#line 1274 
  ether_addr_copy((u8 *)(& element.mac_addr),(u8 const *)macaddr);
  
#line 1275 
  element.vlan_tag = (unsigned short)0U;
  
#line 1276 
  element.flags = (unsigned char)9U;
  
#line 1278 
  aq_ret = i40e_aq_remove_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),& element,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
  
#line 1279 
  if (aq_ret != I40E_SUCCESS) {
    
#line 1280 
    __retres = -2;
    
#line 1280 
    goto return_label;
  }
  else ;
  
#line 1282 
  __retres = 0;
  return_label: 
#line 1282 
                return __retres;
}


#line 1295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_mac_filter *i40e_add_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan, bool is_vf, bool is_netdev)
{
  struct i40e_mac_filter *__retres;
  struct i40e_mac_filter *f;
  
#line 1301 
  if (vsi == (struct i40e_vsi *)0 || macaddr == (u8 *)0U) {
    
#line 1302 
    __retres = (struct i40e_mac_filter *)0;
    
#line 1302 
    goto return_label;
  }
  else ;
  
#line 1304 
  f = i40e_find_filter(vsi,macaddr,(short)((int)vlan),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
  
#line 1305 
  if (f == (struct i40e_mac_filter *)0) {
    
#line 1306 
    f = (struct i40e_mac_filter *)kzalloc_0(32UL,32U);
    
#line 1307 
    if (f == (struct i40e_mac_filter *)0) 
#line 1308 
                                          goto add_filter_out; else ;
    
#line 1310 
    ether_addr_copy((u8 *)(& f->macaddr),(u8 const *)macaddr);
    
#line 1311 
    f->vlan = vlan;
    
#line 1312 
    f->changed = (_Bool)1;
    
#line 1314 
    INIT_LIST_HEAD(& f->list);
    
#line 1315 
    list_add(& f->list,& vsi->mac_filter_list);
  }
  else ;
  
#line 1319 
  if ((int)is_vf != 0) {
    
#line 1320 
    if (! f->is_vf) {
      
#line 1321 
      f->is_vf = (_Bool)1;
      
#line 1322 
      f->counter = (u8)((int)f->counter + 1);
    }
    else ;
  }
  else 
    
#line 1324 
    if ((int)is_netdev != 0) {
      
#line 1325 
      if (! f->is_netdev) {
        
#line 1326 
        f->is_netdev = (_Bool)1;
        
#line 1327 
        f->counter = (u8)((int)f->counter + 1);
      }
      else ;
    }
    else 
#line 1330 
         f->counter = (u8)((int)f->counter + 1);
  
#line 1336 
  if ((int)f->changed != 0) {
    
#line 1337 
    vsi->flags |= 1UL;
    
#line 1338 
    (vsi->back)->flags |= 32768ULL;
  }
  else ;
  add_filter_out: 
#line 1341 
  ;
  
#line 1342 
  __retres = f;
  return_label: 
#line 1342 
                return __retres;
}


#line 1353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_del_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan, bool is_vf, bool is_netdev)
{
  struct i40e_mac_filter *f;
  
#line 1359 
  if (vsi == (struct i40e_vsi *)0 || macaddr == (u8 *)0U) 
#line 1360 
                                                          goto return_label; else ;
  
#line 1362 
  f = i40e_find_filter(vsi,macaddr,(short)((int)vlan),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
  
#line 1363 
  if (f == (struct i40e_mac_filter *)0 || (unsigned int)f->counter == 0U) 
    
#line 1364 
    goto return_label; else ;
  
#line 1366 
  if ((int)is_vf != 0) {
    
#line 1367 
    if ((int)f->is_vf != 0) {
      
#line 1368 
      f->is_vf = (_Bool)0;
      
#line 1369 
      f->counter = (u8)((int)f->counter - 1);
    }
    else ;
  }
  else 
    
#line 1371 
    if ((int)is_netdev != 0) {
      
#line 1372 
      if ((int)f->is_netdev != 0) {
        
#line 1373 
        f->is_netdev = (_Bool)0;
        
#line 1374 
        f->counter = (u8)((int)f->counter - 1);
      }
      else ;
    }
    else {
      
#line 1378 
      int min_f = 0;
      
#line 1379 
      min_f = ((int)f->is_vf != 0) + min_f;
      
#line 1380 
      min_f = ((int)f->is_netdev != 0) + min_f;
      
#line 1382 
      if ((int)f->counter > min_f) 
#line 1383 
                                   f->counter = (u8)((int)f->counter - 1); else ;
    }
  
#line 1389 
  if ((unsigned int)f->counter == 0U) {
    
#line 1390 
    f->changed = (_Bool)1;
    
#line 1391 
    vsi->flags |= 1UL;
    
#line 1392 
    (vsi->back)->flags |= 32768ULL;
  }
  else ;
  return_label: 
#line 1394 
                return;
}


#line 1404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_set_mac(struct net_device *netdev, void *p)
{
  int __retres;
  struct i40e_mac_filter *f;
  int tmp_1;
  bool tmp_0;
  bool tmp_2;
  int tmp_3;
  bool tmp_5;
  bool tmp_6;
  bool tmp_7;
  
#line 1409 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1410 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1411 
  struct i40e_pf *pf = vsi->back;
  
#line 1412 
  struct i40e_hw *hw = & pf->hw;
  
#line 1413 
  struct sockaddr *addr = (struct sockaddr *)p;
  
#line 1416 
  tmp_0 = is_valid_ether_addr((u8 const *)(& addr->sa_data));
  
#line 1416 
  if (tmp_0) 
#line 1416 
             tmp_1 = 0; else 
#line 1416 
                             tmp_1 = 1;
  
#line 1416 
  if (tmp_1) {
    
#line 1417 
    __retres = -99;
    
#line 1417 
    goto return_label;
  }
  else ;
  
#line 1419 
  tmp_2 = ether_addr_equal((u8 const *)netdev->dev_addr,(u8 const *)(& addr->sa_data));
  
#line 1419 
  if ((int)tmp_2 != 0) {
    
#line 1420 
    netdev_info((struct net_device const *)netdev,"already using mac address %pM\n",(char *)(& addr->sa_data));
    
#line 1422 
    __retres = 0;
    
#line 1422 
    goto return_label;
  }
  else ;
  
#line 1425 
  tmp_3 = constant_test_bit(3L,(unsigned long const volatile *)(& (vsi->back)->state));
  
#line 1425 
  if (tmp_3 != 0) {
    
#line 1427 
    __retres = -99;
    
#line 1427 
    goto return_label;
  }
  else {
    int tmp_4;
    
#line 1425 
    tmp_4 = constant_test_bit(9L,(unsigned long const volatile *)(& (vsi->back)->state));
    
#line 1425 
    if (tmp_4 != 0) {
      
#line 1427 
      __retres = -99;
      
#line 1427 
      goto return_label;
    }
    else ;
  }
  
#line 1429 
  tmp_5 = ether_addr_equal((u8 const *)(& hw->mac.addr),(u8 const *)(& addr->sa_data));
  
#line 1429 
  if ((int)tmp_5 != 0) 
#line 1430 
                       netdev_info((struct net_device const *)netdev,"returning to hw mac address %pM\n",(u8 *)(& hw->mac.addr)); else 
                                                                    
#line 1433 
                                                                    netdev_info((struct net_device const *)netdev,"set new mac address %pM\n",(char *)(& addr->sa_data));
  
#line 1435 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) {
    i40e_status ret;
    
#line 1437 
    ret = i40e_aq_mac_address_write(& (vsi->back)->hw,(unsigned short)16384,(u8 *)(& addr->sa_data),(struct i40e_asq_cmd_details *)0);
    
#line 1440 
    if (ret != I40E_SUCCESS) {
      
#line 1441 
      netdev_info((struct net_device const *)netdev,"Addr change for Main VSI failed: %d\n",(int)ret);
      
#line 1444 
      __retres = -99;
      
#line 1444 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1448 
  tmp_6 = ether_addr_equal((u8 const *)netdev->dev_addr,(u8 const *)(& hw->mac.addr));
  
#line 1448 
  if ((int)tmp_6 != 0) {
    struct i40e_aqc_remove_macvlan_element_data element;
    
#line 1451 
    memset((void *)(& element),0,16UL);
    
#line 1452 
    ether_addr_copy((u8 *)(& element.mac_addr),(u8 const *)netdev->dev_addr);
    
#line 1453 
    element.flags = (unsigned char)1U;
    
#line 1454 
    i40e_aq_remove_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),& element,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
  }
  else 
#line 1456 
       i40e_del_filter(vsi,netdev->dev_addr,(short)(-1),(_Bool)0,(_Bool)0);
  
#line 1460 
  tmp_7 = ether_addr_equal((u8 const *)(& addr->sa_data),(u8 const *)(& hw->mac.addr));
  
#line 1460 
  if ((int)tmp_7 != 0) {
    struct i40e_aqc_add_macvlan_element_data element_0;
    
#line 1463 
    memset((void *)(& element_0),0,16UL);
    
#line 1464 
    ether_addr_copy((u8 *)(& element_0.mac_addr),(u8 const *)(& hw->mac.addr));
    
#line 1465 
    element_0.flags = (unsigned short)1U;
    
#line 1466 
    i40e_aq_add_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),& element_0,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
  }
  else {
    
#line 1468 
    f = i40e_add_filter(vsi,(u8 *)(& addr->sa_data),(short)(-1),(_Bool)0,(_Bool)0);
    
#line 1470 
    if (f != (struct i40e_mac_filter *)0) 
#line 1471 
                                          f->is_laa = (_Bool)1; else ;
  }
  
#line 1474 
  i40e_sync_vsi_filters(vsi);
  
#line 1475 
  ether_addr_copy(netdev->dev_addr,(u8 const *)(& addr->sa_data));
  
#line 1477 
  __retres = 0;
  return_label: 
#line 1477 
                return __retres;
}


#line 1490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_setup_queue_map(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt, u8 enabled_tc, bool is_add)
{
  u16 qcount;
  u8 offset;
  u16 qmap;
  int i;
  int tmp_0;
  int tmp_2;
  
#line 1501 
  struct i40e_pf *pf = vsi->back;
  
#line 1502 
  u16 sections = (unsigned short)0U;
  
#line 1503 
  u8 netdev_tc = (unsigned char)0U;
  
#line 1504 
  u16 numtc = (unsigned short)0U;
  
#line 1509 
  u16 num_tc_qps = (unsigned short)0U;
  
#line 1511 
  sections = (unsigned short)64U;
  
#line 1512 
  offset = (unsigned char)0U;
  
#line 1514 
  if ((unsigned int)enabled_tc != 0U && ((vsi->back)->flags & 1048576ULL) != 0ULL) {
    
#line 1516 
    i = 0;
    
#line 1516 
    goto ldv_62094;
    ldv_62093: 
#line 1517 
    ;
    
#line 1517 
    if ((((int)enabled_tc >> i) & 1) != 0) 
#line 1518 
                                           numtc = (u16)((int)numtc + 1); else ;
    
#line 1516 
    i += 1;
    ldv_62094: 
#line 1517 
    ;
    
#line 1516 
    if (i <= 7) 
#line 1518 
                goto ldv_62093; else 
#line 1521 
                                     goto ldv_62095;
    ldv_62095: 
#line 1522 
    ;
    
#line 1520 
    if ((unsigned int)numtc == 0U) {
      
#line 1521 
      dev_warn((struct device const *)(& (pf->pdev)->dev),"DCB is enabled but no TC enabled, forcing TC0\n");
      
#line 1522 
      numtc = (unsigned short)1U;
    }
    else ;
  }
  else 
#line 1526 
       numtc = (unsigned short)1U;
  
#line 1529 
  vsi->tc_config.numtc = (unsigned char)numtc;
  
#line 1530 
  if ((unsigned int)enabled_tc != 0U) 
#line 1530 
                                      vsi->tc_config.enabled_tc = enabled_tc; else 
                                                                    
#line 1530 
                                                                    vsi->tc_config.enabled_tc = (unsigned char)1U;
  {
    int tmp;
    
#line 1536 
    int __min1 = (int)vsi->alloc_queue_pairs;
    
#line 1536 
    int __min2 = (int)pf->num_lan_msix;
    
#line 1536 
    if (__min1 < __min2) 
#line 1536 
                         tmp = __min1; else 
#line 1536 
                                            tmp = __min2;
    
#line 1536 
    tmp_0 = tmp;
  }
  
#line 1536 
  qcount = (unsigned short)tmp_0;
  
#line 1537 
  num_tc_qps = (unsigned short)((int)qcount / (int)numtc);
  {
    int tmp_1;
    
#line 1538 
    int __min1_0 = (int)num_tc_qps;
    
#line 1538 
    int __min2_0 = 64;
    
#line 1538 
    if (__min1_0 < __min2_0) 
#line 1538 
                             tmp_1 = __min1_0; else 
#line 1538 
                                                    tmp_1 = __min2_0;
    
#line 1538 
    tmp_2 = tmp_1;
  }
  
#line 1538 
  num_tc_qps = (unsigned short)tmp_2;
  
#line 1541 
  i = 0;
  
#line 1541 
  goto ldv_62120;
  ldv_62119: 
#line 1542 
  ;
  
#line 1543 
  if ((((int)vsi->tc_config.enabled_tc >> i) & 1) != 0) {
    int pow;
    int num_qps;
    u8 tmp_5_0;
    
#line 1546 
    switch ((unsigned int)vsi->type) {
      int tmp_4;
      case (unsigned int)0: 
#line 1547 
      ;
      {
        int tmp_3;
        
#line 1548 
        int __min1_1 = (int)pf->rss_size;
        
#line 1548 
        int __min2_1 = (int)num_tc_qps;
        
#line 1548 
        if (__min1_1 < __min2_1) 
#line 1548 
                                 tmp_3 = __min1_1; else 
#line 1548 
                                                        tmp_3 = __min2_1;
        
#line 1548 
        tmp_4 = tmp_3;
      }
      
#line 1548 
      qcount = (unsigned short)tmp_4;
      
#line 1549 
      goto ldv_62108;
      case (unsigned int)4: 
#line 1551 
      ;
      
#line 1552 
      qcount = num_tc_qps;
      
#line 1553 
      goto ldv_62108;
      case (unsigned int)7: 
#line 1555 
      ;
      case (unsigned int)6: 
#line 1556 
      ;
      case (unsigned int)2: 
#line 1557 
      ;
      default: 
#line 1558 
      ;
      
#line 1559 
      qcount = num_tc_qps;
      {
        
#line 1560 
        int __ret_warn_on = i != 0;
        
#line 1560 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 1560 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c",1560); else ;
        
#line 1560 
        long tmp_5 = (long)(__ret_warn_on != 0);
      }
      
#line 1561 
      goto ldv_62108;
    }
    ldv_62108: 
#line 1563 
    ;
    
#line 1563 
    vsi->tc_config.tc_info[i].qoffset = (unsigned short)offset;
    
#line 1564 
    vsi->tc_config.tc_info[i].qcount = qcount;
    
#line 1567 
    num_qps = (int)qcount;
    
#line 1568 
    pow = 0;
    
#line 1569 
    goto ldv_62117;
    ldv_62116: 
#line 1570 
    ;
    
#line 1570 
    pow += 1;
    
#line 1571 
    num_qps >>= 1;
    ldv_62117: 
#line 1572 
    ;
    
#line 1569 
    if (num_qps != 0 && 1 << pow < (int)qcount) 
#line 1571 
                                                goto ldv_62116; else 
                                                                  
#line 1574 
                                                                  goto ldv_62118;
    ldv_62118: 
#line 1575 
    ;
    
#line 1574 
    tmp_5_0 = netdev_tc;
    
#line 1574 
    netdev_tc = (u8)((int)netdev_tc + 1);
    
#line 1574 
    vsi->tc_config.tc_info[i].netdev_tc = tmp_5_0;
    
#line 1575 
    qmap = (unsigned short)((int)offset | (pow << 9));
    
#line 1579 
    offset = (unsigned char)((int)((unsigned char)qcount) + (int)offset);
  }
  else {
    
#line 1585 
    vsi->tc_config.tc_info[i].qoffset = (unsigned short)0U;
    
#line 1586 
    vsi->tc_config.tc_info[i].qcount = (unsigned short)1U;
    
#line 1587 
    vsi->tc_config.tc_info[i].netdev_tc = (unsigned char)0U;
    
#line 1589 
    qmap = (unsigned short)0U;
  }
  
#line 1591 
  ctxt->info.tc_mapping[i] = qmap;
  
#line 1541 
  i += 1;
  ldv_62120: 
#line 1542 
  ;
  
#line 1541 
  if (i <= 7) 
#line 1543 
              goto ldv_62119; else 
#line 1546 
                                   goto ldv_62121;
  ldv_62121: 
#line 1547 
  ;
  
#line 1595 
  vsi->num_queue_pairs = (unsigned short)offset;
  
#line 1596 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN && (unsigned int)numtc == 1U) 
    
#line 1597 
    if ((unsigned int)vsi->req_queue_pairs != 0U) 
#line 1598 
                                                  vsi->num_queue_pairs = vsi->req_queue_pairs; else 
                                                                    
#line 1600 
                                                                    vsi->num_queue_pairs = pf->num_lan_msix;
  else ;
  
#line 1604 
  if ((int)is_add != 0) {
    
#line 1605 
    sections = (unsigned short)((unsigned int)sections | 512U);
    
#line 1607 
    ctxt->info.up_enable_bits = enabled_tc;
  }
  else ;
  
#line 1609 
  if (vsi->type == (unsigned int)I40E_VSI_SRIOV) {
    
#line 1610 
    ctxt->info.mapping_flags = (unsigned short)((unsigned int)ctxt->info.mapping_flags | 1U);
    
#line 1612 
    i = 0;
    
#line 1612 
    goto ldv_62123;
    ldv_62122: 
#line 1613 
    ;
    
#line 1613 
    ctxt->info.queue_mapping[i] = (unsigned short)((int)vsi->base_queue + (int)((unsigned short)i));
    
#line 1612 
    i += 1;
    ldv_62123: 
#line 1613 
    ;
    
#line 1612 
    if ((int)vsi->num_queue_pairs > i) 
#line 1614 
                                       goto ldv_62122; else 
#line 1617 
                                                            goto ldv_62124;
    ldv_62124: 
#line 1618 
    ;
  }
  else {
    
#line 1616 
    ctxt->info.mapping_flags = ctxt->info.mapping_flags;
    
#line 1618 
    ctxt->info.queue_mapping[0] = vsi->base_queue;
  }
  
#line 1620 
  ctxt->info.valid_sections = (unsigned short)((int)ctxt->info.valid_sections | (int)sections);
  
#line 1621 
  return;
}


#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_set_rx_mode(struct net_device *netdev)
{
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *ftmp;
  struct netdev_hw_addr *uca;
  struct netdev_hw_addr *mca;
  struct netdev_hw_addr *ha;
  struct netdev_hw_addr *tmp_0;
  struct i40e_mac_filter *tmp_2;
  struct netdev_hw_addr *tmp_3;
  struct netdev_hw_addr *tmp_4;
  struct i40e_mac_filter *tmp_6;
  struct netdev_hw_addr *tmp_7;
  struct i40e_mac_filter *tmp_8;
  struct i40e_mac_filter *tmp_9;
  struct i40e_mac_filter *tmp_32;
  
#line 1633 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1635 
  struct i40e_vsi *vsi = np->vsi;
  {
    
#line 1641 
    struct list_head const *__mptr = (struct list_head const *)netdev->uc.list.next;
    
#line 1641 
    tmp_0 = (struct netdev_hw_addr *)__mptr;
  }
  
#line 1641 
  uca = tmp_0;
  
#line 1641 
  goto ldv_62140;
  ldv_62139: 
#line 1642 
  ;
  
#line 1642 
  tmp_2 = i40e_find_mac(vsi,(u8 *)(& uca->addr),(_Bool)0,(_Bool)1);
  
#line 1642 
  if (tmp_2 == (struct i40e_mac_filter *)0) {
    bool tmp_1;
    
#line 1643 
    tmp_1 = i40e_is_vsi_in_vlan(vsi);
    
#line 1643 
    if ((int)tmp_1 != 0) 
#line 1644 
                         i40e_put_mac_in_vlan(vsi,(u8 *)(& uca->addr),(_Bool)0,(_Bool)1); else 
                                                                    
#line 1647 
                                                                    i40e_add_filter(vsi,(u8 *)(& uca->addr),(short)(-1),(_Bool)0,(_Bool)1);
  }
  else ;
  {
    
#line 1641 
    struct list_head const *__mptr_0 = (struct list_head const *)uca->list.next;
    
#line 1641 
    tmp_3 = (struct netdev_hw_addr *)__mptr_0;
  }
  
#line 1641 
  uca = tmp_3;
  ldv_62140: 
#line 1643 
  ;
  
#line 1641 
  if (& uca->list != & netdev->uc.list) 
#line 1643 
                                        goto ldv_62139; else 
#line 1646 
                                                             goto ldv_62141;
  ldv_62141: 
#line 1647 
  ;
  {
    
#line 1652 
    struct list_head const *__mptr_1 = (struct list_head const *)netdev->mc.list.next;
    
#line 1652 
    tmp_4 = (struct netdev_hw_addr *)__mptr_1;
  }
  
#line 1652 
  mca = tmp_4;
  
#line 1652 
  goto ldv_62147;
  ldv_62146: 
#line 1653 
  ;
  
#line 1653 
  tmp_6 = i40e_find_mac(vsi,(u8 *)(& mca->addr),(_Bool)0,(_Bool)1);
  
#line 1653 
  if (tmp_6 == (struct i40e_mac_filter *)0) {
    bool tmp_5;
    
#line 1654 
    tmp_5 = i40e_is_vsi_in_vlan(vsi);
    
#line 1654 
    if ((int)tmp_5 != 0) 
#line 1655 
                         i40e_put_mac_in_vlan(vsi,(u8 *)(& mca->addr),(_Bool)0,(_Bool)1); else 
                                                                    
#line 1658 
                                                                    i40e_add_filter(vsi,(u8 *)(& mca->addr),(short)(-1),(_Bool)0,(_Bool)1);
  }
  else ;
  {
    
#line 1652 
    struct list_head const *__mptr_2 = (struct list_head const *)mca->list.next;
    
#line 1652 
    tmp_7 = (struct netdev_hw_addr *)__mptr_2;
  }
  
#line 1652 
  mca = tmp_7;
  ldv_62147: 
#line 1654 
  ;
  
#line 1652 
  if (& mca->list != & netdev->mc.list) 
#line 1654 
                                        goto ldv_62146; else 
#line 1657 
                                                             goto ldv_62148;
  ldv_62148: 
#line 1658 
  ;
  {
    
#line 1664 
    struct list_head const *__mptr_3 = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 1664 
    tmp_8 = (struct i40e_mac_filter *)__mptr_3;
  }
  
#line 1664 
  f = tmp_8;
  {
    
#line 1664 
    struct list_head const *__mptr_4 = (struct list_head const *)f->list.next;
    
#line 1664 
    tmp_9 = (struct i40e_mac_filter *)__mptr_4;
  }
  
#line 1665 
  ftmp = tmp_9;
  
#line 1664 
  goto ldv_62203;
  ldv_62202: 
#line 1665 
  ;
  {
    bool tmp_31;
    
#line 1665 
    bool found = (_Bool)0;
    
#line 1667 
    if (! f->is_netdev) 
#line 1668 
                        goto ldv_62156; else ;
    
#line 1670 
    tmp_31 = is_multicast_ether_addr((u8 const *)(& f->macaddr));
    
#line 1670 
    if ((int)tmp_31 != 0) {
      struct netdev_hw_addr *tmp_10;
      bool tmp_11;
      struct netdev_hw_addr *tmp_12;
      {
        
#line 1671 
        struct list_head const *__mptr_5 = (struct list_head const *)netdev->mc.list.next;
        
#line 1671 
        tmp_10 = (struct netdev_hw_addr *)__mptr_5;
      }
      
#line 1671 
      mca = tmp_10;
      
#line 1671 
      goto ldv_62163;
      ldv_62162: 
#line 1672 
      ;
      
#line 1672 
      tmp_11 = ether_addr_equal((u8 const *)(& mca->addr),(u8 const *)(& f->macaddr));
      
#line 1672 
      if ((int)tmp_11 != 0) {
        
#line 1673 
        found = (_Bool)1;
        
#line 1674 
        goto ldv_62161;
      }
      else ;
      {
        
#line 1671 
        struct list_head const *__mptr_6 = (struct list_head const *)mca->list.next;
        
#line 1671 
        tmp_12 = (struct netdev_hw_addr *)__mptr_6;
      }
      
#line 1671 
      mca = tmp_12;
      ldv_62163: 
#line 1673 
      ;
      
#line 1671 
      if (& mca->list != & netdev->mc.list) 
#line 1673 
                                            goto ldv_62162; else 
#line 1676 
                                                                 goto ldv_62161;
      ldv_62161: 
#line 1677 
      ;
    }
    else {
      struct netdev_hw_addr *tmp_13;
      bool tmp_14;
      struct netdev_hw_addr *tmp_15;
      struct netdev_hw_addr *tmp_22;
      bool tmp_23;
      struct netdev_hw_addr *tmp_30;
      {
        
#line 1678 
        struct list_head const *__mptr_7 = (struct list_head const *)netdev->uc.list.next;
        
#line 1678 
        tmp_13 = (struct netdev_hw_addr *)__mptr_7;
      }
      
#line 1678 
      uca = tmp_13;
      
#line 1678 
      goto ldv_62170;
      ldv_62169: 
#line 1679 
      ;
      
#line 1679 
      tmp_14 = ether_addr_equal((u8 const *)(& uca->addr),(u8 const *)(& f->macaddr));
      
#line 1679 
      if ((int)tmp_14 != 0) {
        
#line 1680 
        found = (_Bool)1;
        
#line 1681 
        goto ldv_62168;
      }
      else ;
      {
        
#line 1678 
        struct list_head const *__mptr_8 = (struct list_head const *)uca->list.next;
        
#line 1678 
        tmp_15 = (struct netdev_hw_addr *)__mptr_8;
      }
      
#line 1678 
      uca = tmp_15;
      ldv_62170: 
#line 1680 
      ;
      
#line 1678 
      if (& uca->list != & netdev->uc.list) 
#line 1680 
                                            goto ldv_62169; else 
#line 1683 
                                                                 goto ldv_62168;
      ldv_62168: 
#line 1684 
      ;
      {
        struct netdev_hw_addr *tmp_21;
        
#line 1685 
        struct list_head *__ptr = netdev->dev_addrs.list.next;
        {
          struct list_head *tmp_20;
          {
            struct list_head *tmp_17;
            {
              struct list_head *tmp_16;
              {
                union __anonunion___u_1373 __u;
                
#line 1685 
                __read_once_size((void const volatile *)(& __ptr),(void *)(& __u.__c),8);
                
#line 1685 
                tmp_16 = __u.__val;
              }
              
#line 1685 
              struct list_head *_________p1 = tmp_16;
              
#line 1685 
              tmp_17 = _________p1;
            }
            
#line 1685 
            struct list_head *________p1 = tmp_17;
            {
              bool __warned;
              int tmp_19;
              int tmp_18;
              
#line 1685 
              tmp_18 = debug_lockdep_rcu_enabled();
              
#line 1685 
              if (tmp_18 != 0) 
                
#line 1685 
                if (! __warned) 
#line 1685 
                                tmp_19 = 1; else 
#line 1685 
                                                 tmp_19 = 0;
              else 
#line 1685 
                   tmp_19 = 0;
            }
            
#line 1685 
            tmp_20 = ________p1;
          }
          
#line 1685 
          struct list_head const *__mptr_9 = (struct list_head const *)tmp_20;
          
#line 1685 
          tmp_21 = (struct netdev_hw_addr *)__mptr_9;
        }
        
#line 1685 
        tmp_22 = tmp_21;
      }
      
#line 1685 
      ha = tmp_22;
      
#line 1685 
      goto ldv_62201;
      ldv_62200: 
#line 1686 
      ;
      
#line 1686 
      tmp_23 = ether_addr_equal((u8 const *)(& ha->addr),(u8 const *)(& f->macaddr));
      
#line 1686 
      if ((int)tmp_23 != 0) {
        
#line 1687 
        found = (_Bool)1;
        
#line 1688 
        goto ldv_62199;
      }
      else ;
      {
        struct netdev_hw_addr *tmp_29;
        
#line 1685 
        struct list_head *__ptr_0 = ha->list.next;
        {
          struct list_head *tmp_28;
          {
            struct list_head *tmp_25;
            {
              struct list_head *tmp_24;
              {
                union __anonunion___u_1375 __u_0;
                
#line 1685 
                __read_once_size((void const volatile *)(& __ptr_0),(void *)(& __u_0.__c),8);
                
#line 1685 
                tmp_24 = __u_0.__val;
              }
              
#line 1685 
              struct list_head *_________p1_0 = tmp_24;
              
#line 1685 
              tmp_25 = _________p1_0;
            }
            
#line 1685 
            struct list_head *________p1_0 = tmp_25;
            {
              bool __warned_0;
              int tmp_27;
              int tmp_26;
              
#line 1685 
              tmp_26 = debug_lockdep_rcu_enabled();
              
#line 1685 
              if (tmp_26 != 0) 
                
#line 1685 
                if (! __warned_0) 
#line 1685 
                                  tmp_27 = 1; else 
#line 1685 
                                                   tmp_27 = 0;
              else 
#line 1685 
                   tmp_27 = 0;
            }
            
#line 1685 
            tmp_28 = ________p1_0;
          }
          
#line 1685 
          struct list_head const *__mptr_10 = (struct list_head const *)tmp_28;
          
#line 1685 
          tmp_29 = (struct netdev_hw_addr *)__mptr_10;
        }
        
#line 1685 
        tmp_30 = tmp_29;
      }
      
#line 1685 
      ha = tmp_30;
      ldv_62201: 
#line 1688 
      ;
      
#line 1685 
      if (& ha->list != & netdev->dev_addrs.list) 
#line 1687 
                                                  goto ldv_62200; else 
                                                                    
#line 1690 
                                                                    goto ldv_62199;
      ldv_62199: 
#line 1691 
      ;
    }
    
#line 1692 
    if (! found) 
#line 1693 
                 i40e_del_filter(vsi,(u8 *)(& f->macaddr),(short)(-1),(_Bool)0,(_Bool)1); else ;
  }
  ldv_62156: 
#line 1696 
  ;
  
#line 1664 
  f = ftmp;
  {
    
#line 1664 
    struct list_head const *__mptr_11 = (struct list_head const *)ftmp->list.next;
    
#line 1664 
    tmp_32 = (struct i40e_mac_filter *)__mptr_11;
  }
  
#line 1664 
  ftmp = tmp_32;
  ldv_62203: 
#line 1666 
  ;
  
#line 1664 
  if (& f->list != & vsi->mac_filter_list) 
#line 1666 
                                           goto ldv_62202; else 
#line 1669 
                                                                goto ldv_62204;
  ldv_62204: 
#line 1670 
  ;
  
#line 1698 
  if (vsi->current_netdev_flags != (vsi->netdev)->flags) {
    
#line 1699 
    vsi->flags |= 1UL;
    
#line 1700 
    (vsi->back)->flags |= 32768ULL;
  }
  else ;
  
#line 1702 
  return;
}


#line 1712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_sync_vsi_filters(struct i40e_vsi *vsi)
{
  int __retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *ftmp;
  struct i40e_pf *pf;
  u16 cmd_flags;
  struct i40e_aqc_add_macvlan_element_data *add_list;
  struct i40e_aqc_remove_macvlan_element_data *del_list;
  int tmp;
  
#line 1715 
  bool promisc_forced_on = (_Bool)0;
  
#line 1716 
  bool add_happened = (_Bool)0;
  
#line 1717 
  int filter_list_len = 0;
  
#line 1718 
  u32 changed_flags = 0U;
  
#line 1719 
  i40e_status aq_ret = 0;
  
#line 1721 
  int num_add = 0;
  
#line 1722 
  int num_del = 0;
  
#line 1729 
  goto ldv_62222;
  ldv_62221: 
#line 1730 
  ;
  
#line 1730 
  usleep_range(1000UL,2000UL);
  ldv_62222: 
#line 1731 
  ;
  
#line 1729 
  tmp = test_and_set_bit(1L,(unsigned long volatile *)(& vsi->state));
  
#line 1729 
  if (tmp != 0) 
#line 1731 
                goto ldv_62221; else 
#line 1734 
                                     goto ldv_62223;
  ldv_62223: 
#line 1735 
  ;
  
#line 1731 
  pf = vsi->back;
  
#line 1733 
  if (vsi->netdev != (struct net_device *)0) {
    
#line 1734 
    changed_flags = vsi->current_netdev_flags ^ (vsi->netdev)->flags;
    
#line 1735 
    vsi->current_netdev_flags = (vsi->netdev)->flags;
  }
  else ;
  
#line 1738 
  if ((vsi->flags & 1UL) != 0UL) {
    struct i40e_mac_filter *tmp_1;
    struct i40e_mac_filter *tmp_2;
    struct i40e_mac_filter *tmp_3;
    struct i40e_mac_filter *tmp_5;
    struct i40e_mac_filter *tmp_6;
    struct i40e_mac_filter *tmp_7;
    
#line 1739 
    vsi->flags &= 18446744073709551614UL;
    
#line 1741 
    filter_list_len = (int)((unsigned int)pf->hw.aq.asq_buf_size / 16U);
    
#line 1743 
    del_list = (struct i40e_aqc_remove_macvlan_element_data *)kcalloc((unsigned long)filter_list_len,16UL,208U);
    
#line 1746 
    if (del_list == (struct i40e_aqc_remove_macvlan_element_data *)0) {
      
#line 1747 
      __retres = -12;
      
#line 1747 
      goto return_label;
    }
    else ;
    {
      
#line 1749 
      struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
      
#line 1749 
      tmp_1 = (struct i40e_mac_filter *)__mptr;
    }
    
#line 1749 
    f = tmp_1;
    {
      
#line 1749 
      struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
      
#line 1749 
      tmp_2 = (struct i40e_mac_filter *)__mptr_0;
    }
    
#line 1750 
    ftmp = tmp_2;
    
#line 1749 
    goto ldv_62232;
    ldv_62231: 
#line 1750 
    ;
    
#line 1750 
    if (! f->changed) 
#line 1751 
                      goto ldv_62230; else ;
    
#line 1753 
    if ((unsigned int)f->counter != 0U) 
#line 1754 
                                        goto ldv_62230; else ;
    
#line 1755 
    f->changed = (_Bool)0;
    
#line 1756 
    cmd_flags = (unsigned short)0U;
    
#line 1759 
    ether_addr_copy((u8 *)(& (del_list + num_del)->mac_addr),(u8 const *)(& f->macaddr));
    
#line 1760 
    if ((int)f->vlan != -1) 
#line 1760 
                            (del_list + num_del)->vlan_tag = (unsigned short)f->vlan; else 
                                                                    
#line 1760 
                                                                    (del_list + num_del)->vlan_tag = (unsigned short)0U;
    
#line 1764 
    cmd_flags = (unsigned short)((unsigned int)cmd_flags | 1U);
    
#line 1765 
    (del_list + num_del)->flags = (unsigned char)cmd_flags;
    
#line 1766 
    num_del += 1;
    
#line 1769 
    list_del(& f->list);
    
#line 1770 
    kfree((void const *)f);
    
#line 1773 
    if (num_del == filter_list_len) {
      
#line 1774 
      aq_ret = i40e_aq_remove_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),del_list,(unsigned short)((int)((unsigned short)num_del)),(struct i40e_asq_cmd_details *)0);
      
#line 1777 
      num_del = 0;
      
#line 1778 
      memset((void *)del_list,0,16UL);
      
#line 1780 
      if (aq_ret != I40E_SUCCESS && pf->hw.aq.asq_last_status != (unsigned int)I40E_AQ_RC_ENOENT) 
        
#line 1783 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"ignoring delete macvlan error, err %d, aq_err %d while flushing a full buffer\n",(int)aq_ret,(unsigned int)pf->hw.aq.asq_last_status); else ;
    }
    else ;
    ldv_62230: 
#line 1785 
    ;
    
#line 1749 
    f = ftmp;
    {
      
#line 1749 
      struct list_head const *__mptr_1 = (struct list_head const *)ftmp->list.next;
      
#line 1749 
      tmp_3 = (struct i40e_mac_filter *)__mptr_1;
    }
    
#line 1749 
    ftmp = tmp_3;
    ldv_62232: 
#line 1751 
    ;
    
#line 1749 
    if (& f->list != & vsi->mac_filter_list) 
#line 1751 
                                             goto ldv_62231; else 
#line 1754 
                                                                  goto ldv_62233;
    ldv_62233: 
#line 1755 
    ;
    
#line 1789 
    if (num_del != 0) {
      
#line 1790 
      aq_ret = i40e_aq_remove_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),del_list,(unsigned short)((int)((unsigned short)num_del)),(struct i40e_asq_cmd_details *)0);
      
#line 1792 
      num_del = 0;
      
#line 1794 
      if (aq_ret != I40E_SUCCESS && pf->hw.aq.asq_last_status != (unsigned int)I40E_AQ_RC_ENOENT) 
        
#line 1796 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"ignoring delete macvlan error, err %d, aq_err %d\n",(int)aq_ret,(unsigned int)pf->hw.aq.asq_last_status); else ;
    }
    else ;
    
#line 1801 
    kfree((void const *)del_list);
    
#line 1802 
    del_list = (struct i40e_aqc_remove_macvlan_element_data *)0;
    
#line 1806 
    filter_list_len = (int)((unsigned int)pf->hw.aq.asq_buf_size / 16U);
    
#line 1807 
    add_list = (struct i40e_aqc_add_macvlan_element_data *)kcalloc((unsigned long)filter_list_len,16UL,208U);
    
#line 1810 
    if (add_list == (struct i40e_aqc_add_macvlan_element_data *)0) {
      
#line 1811 
      __retres = -12;
      
#line 1811 
      goto return_label;
    }
    else ;
    {
      
#line 1813 
      struct list_head const *__mptr_2 = (struct list_head const *)vsi->mac_filter_list.next;
      
#line 1813 
      tmp_5 = (struct i40e_mac_filter *)__mptr_2;
    }
    
#line 1813 
    f = tmp_5;
    {
      
#line 1813 
      struct list_head const *__mptr_3 = (struct list_head const *)f->list.next;
      
#line 1813 
      tmp_6 = (struct i40e_mac_filter *)__mptr_3;
    }
    
#line 1814 
    ftmp = tmp_6;
    
#line 1813 
    goto ldv_62243;
    ldv_62242: 
#line 1814 
    ;
    
#line 1814 
    if (! f->changed) 
#line 1815 
                      goto ldv_62240; else ;
    
#line 1817 
    if ((unsigned int)f->counter == 0U) 
#line 1818 
                                        goto ldv_62240; else ;
    
#line 1819 
    f->changed = (_Bool)0;
    
#line 1820 
    add_happened = (_Bool)1;
    
#line 1821 
    cmd_flags = (unsigned short)0U;
    
#line 1824 
    ether_addr_copy((u8 *)(& (add_list + num_add)->mac_addr),(u8 const *)(& f->macaddr));
    
#line 1825 
    if ((int)f->vlan != -1) 
#line 1825 
                            (add_list + num_add)->vlan_tag = (unsigned short)f->vlan; else 
                                                                    
#line 1825 
                                                                    (add_list + num_add)->vlan_tag = (unsigned short)0U;
    
#line 1828 
    (add_list + num_add)->queue_number = (unsigned short)0U;
    
#line 1830 
    cmd_flags = (unsigned short)((unsigned int)cmd_flags | 1U);
    
#line 1831 
    (add_list + num_add)->flags = cmd_flags;
    
#line 1832 
    num_add += 1;
    
#line 1835 
    if (num_add == filter_list_len) {
      
#line 1836 
      aq_ret = i40e_aq_add_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),add_list,(unsigned short)((int)((unsigned short)num_add)),(struct i40e_asq_cmd_details *)0);
      
#line 1839 
      num_add = 0;
      
#line 1841 
      if (aq_ret != I40E_SUCCESS) 
#line 1842 
                                  goto ldv_62241; else ;
      
#line 1843 
      memset((void *)add_list,0,16UL);
    }
    else ;
    ldv_62240: 
#line 1845 
    ;
    
#line 1813 
    f = ftmp;
    {
      
#line 1813 
      struct list_head const *__mptr_4 = (struct list_head const *)ftmp->list.next;
      
#line 1813 
      tmp_7 = (struct i40e_mac_filter *)__mptr_4;
    }
    
#line 1813 
    ftmp = tmp_7;
    ldv_62243: 
#line 1815 
    ;
    
#line 1813 
    if (& f->list != & vsi->mac_filter_list) 
#line 1815 
                                             goto ldv_62242; else 
#line 1818 
                                                                  goto ldv_62241;
    ldv_62241: 
#line 1819 
    ;
    
#line 1846 
    if (num_add != 0) {
      
#line 1847 
      aq_ret = i40e_aq_add_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),add_list,(unsigned short)((int)((unsigned short)num_add)),(struct i40e_asq_cmd_details *)0);
      
#line 1849 
      num_add = 0;
    }
    else ;
    
#line 1851 
    kfree((void const *)add_list);
    
#line 1852 
    add_list = (struct i40e_aqc_add_macvlan_element_data *)0;
    
#line 1854 
    if (((int)add_happened != 0 && aq_ret != I40E_SUCCESS) && pf->hw.aq.asq_last_status != (unsigned int)I40E_AQ_RC_EINVAL) {
      
#line 1856 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"add filter failed, err %d, aq_err %d\n",(int)aq_ret,(unsigned int)pf->hw.aq.asq_last_status);
      
#line 1859 
      if (pf->hw.aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOSPC) {
        int tmp_8;
        
#line 1859 
        tmp_8 = constant_test_bit(17L,(unsigned long const volatile *)(& vsi->state));
        
#line 1859 
        if (tmp_8 == 0) {
          
#line 1862 
          promisc_forced_on = (_Bool)1;
          
#line 1863 
          clear_bit(17L,(unsigned long volatile *)(& vsi->state));
          
#line 1865 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"promiscuous mode forced on\n");
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1871 
  if ((changed_flags & 512U) != 0U) {
    bool cur_multipromisc;
    
#line 1873 
    cur_multipromisc = (_Bool)((vsi->current_netdev_flags & 512U) != 0U);
    
#line 1874 
    aq_ret = i40e_aq_set_vsi_multicast_promiscuous(& (vsi->back)->hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)cur_multipromisc) != 0),(struct i40e_asq_cmd_details *)0);
    
#line 1878 
    if (aq_ret != I40E_SUCCESS) 
#line 1879 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"set multi promisc failed, err %d, aq_err %d\n",(int)aq_ret,(unsigned int)pf->hw.aq.asq_last_status); else ;
  }
  else ;
  
#line 1883 
  if ((changed_flags & 256U) != 0U || (int)promisc_forced_on != 0) {
    bool cur_promisc;
    int tmp_10;
    
#line 1885 
    if ((vsi->current_netdev_flags & 256U) != 0U) 
#line 1885 
                                                  tmp_10 = 1;
    else {
      int tmp_9;
      
#line 1885 
      tmp_9 = constant_test_bit(17L,(unsigned long const volatile *)(& vsi->state));
      
#line 1885 
      if (tmp_9 != 0) 
#line 1885 
                      tmp_10 = 1; else 
#line 1885 
                                       tmp_10 = 0;
    }
    
#line 1885 
    cur_promisc = (_Bool)(tmp_10 != 0);
    
#line 1888 
    aq_ret = i40e_aq_set_vsi_unicast_promiscuous(& (vsi->back)->hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)cur_promisc) != 0),(struct i40e_asq_cmd_details *)0);
    
#line 1891 
    if (aq_ret != I40E_SUCCESS) 
#line 1892 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"set uni promisc failed, err %d, aq_err %d\n",(int)aq_ret,(unsigned int)pf->hw.aq.asq_last_status); else ;
    
#line 1895 
    aq_ret = i40e_aq_set_vsi_broadcast(& (vsi->back)->hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)cur_promisc) != 0),(struct i40e_asq_cmd_details *)0);
    
#line 1898 
    if (aq_ret != I40E_SUCCESS) 
#line 1899 
                                _dev_info((struct device const *)(& (pf->pdev)->dev),"set brdcast promisc failed, err %d, aq_err %d\n",(int)aq_ret,(unsigned int)pf->hw.aq.asq_last_status); else ;
  }
  else ;
  
#line 1904 
  clear_bit(1L,(unsigned long volatile *)(& vsi->state));
  
#line 1905 
  __retres = 0;
  return_label: 
#line 1905 
                return __retres;
}


#line 1912  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_sync_filters_subtask(struct i40e_pf *pf)
{
  int v;
  
#line 1916 
  if (pf == (struct i40e_pf *)0 || (pf->flags & 32768ULL) == 0ULL) 
#line 1917 
                                                                   goto return_label; else ;
  
#line 1918 
  pf->flags &= 18446744073709518847ULL;
  
#line 1920 
  v = 0;
  
#line 1920 
  goto ldv_62251;
  ldv_62250: 
#line 1921 
  ;
  
#line 1921 
  if (*(pf->vsi + v) != (struct i40e_vsi *)0 && ((*(pf->vsi + v))->flags & 1UL) != 0UL) 
    
#line 1923 
    i40e_sync_vsi_filters(*(pf->vsi + v)); else ;
  
#line 1920 
  v += 1;
  ldv_62251: 
#line 1921 
  ;
  
#line 1920 
  if ((int)pf->num_alloc_vsi > v) 
#line 1922 
                                  goto ldv_62250; else 
#line 1925 
                                                       goto ldv_62252;
  ldv_62252: 
#line 1926 
  ;
  return_label: 
#line 1927 
                return;
}


#line 1934  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_change_mtu(struct net_device *netdev, int new_mtu)
{
  int __retres;
  bool tmp_0;
  
#line 1936 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1937 
  int max_frame = new_mtu + 22;
  
#line 1938 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1941 
  if (new_mtu <= 67 || max_frame > 9728) {
    
#line 1942 
    __retres = -22;
    
#line 1942 
    goto return_label;
  }
  else ;
  
#line 1944 
  netdev_info((struct net_device const *)netdev,"changing MTU from %d to %d\n",netdev->mtu,new_mtu);
  
#line 1946 
  netdev->mtu = (unsigned int)new_mtu;
  
#line 1947 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 1947 
  if ((int)tmp_0 != 0) 
#line 1948 
                       i40e_vsi_reinit_locked(vsi); else ;
  
#line 1950 
  __retres = 0;
  return_label: 
#line 1950 
                return __retres;
}


#line 1959  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
  int __retres;
  
#line 1961 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1962 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1964 
  switch (cmd) {
    int tmp_0;
    int tmp_1;
    case 35249: 
#line 1965 
    ;
    
#line 1966 
    tmp_0 = i40e_ptp_get_ts_config(pf,ifr);
    
#line 1966 
    __retres = tmp_0;
    
#line 1966 
    goto return_label;
    case 35248: 
#line 1967 
    ;
    
#line 1968 
    tmp_1 = i40e_ptp_set_ts_config(pf,ifr);
    
#line 1968 
    __retres = tmp_1;
    
#line 1968 
    goto return_label;
    default: 
#line 1969 
    ;
    
#line 1970 
    __retres = -95;
    
#line 1970 
    goto return_label;
  }
  return_label: 
#line 1964 
                return __retres;
}


#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vlan_stripping_enable(struct i40e_vsi *vsi)
{
  struct i40e_vsi_context ctxt;
  i40e_status ret;
  
#line 1983 
  if (((int)vsi->info.valid_sections & 4) != 0 && ((int)vsi->info.port_vlan_flags & 3) == 0) 
    
#line 1986 
    goto return_label; else ;
  
#line 1988 
  vsi->info.valid_sections = (unsigned short)4U;
  
#line 1989 
  vsi->info.port_vlan_flags = (unsigned char)3U;
  
#line 1992 
  ctxt.seid = vsi->seid;
  
#line 1993 
  ctxt.info = vsi->info;
  
#line 1994 
  ret = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 1995 
  if (ret != I40E_SUCCESS) 
#line 1996 
                           _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"%s: update vsi failed, aq_err=%d\n","i40e_vlan_stripping_enable",(unsigned int)(vsi->back)->hw.aq.asq_last_status); else ;
  return_label: 
#line 1997 
                return;
}


#line 2006  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vlan_stripping_disable(struct i40e_vsi *vsi)
{
  struct i40e_vsi_context ctxt;
  i40e_status ret;
  
#line 2011 
  if (((int)vsi->info.valid_sections & 4) != 0 && ((int)vsi->info.port_vlan_flags & 24) == 24) 
    
#line 2015 
    goto return_label; else ;
  
#line 2017 
  vsi->info.valid_sections = (unsigned short)4U;
  
#line 2018 
  vsi->info.port_vlan_flags = (unsigned char)27U;
  
#line 2021 
  ctxt.seid = vsi->seid;
  
#line 2022 
  ctxt.info = vsi->info;
  
#line 2023 
  ret = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 2024 
  if (ret != I40E_SUCCESS) 
#line 2025 
                           _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"%s: update vsi failed, aq_err=%d\n","i40e_vlan_stripping_disable",(unsigned int)(vsi->back)->hw.aq.asq_last_status); else ;
  return_label: 
#line 2026 
                return;
}


#line 2036  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vlan_rx_register(struct net_device *netdev, u32 features)
{
  
#line 2038 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2039 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2041 
  if (((unsigned long long)features & 256ULL) != 0ULL) 
#line 2042 
                                                       i40e_vlan_stripping_enable(vsi); else 
                                                                    
#line 2044 
                                                                    i40e_vlan_stripping_disable(vsi);
  
#line 2045 
  return;
}


#line 2052  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_add_vlan(struct i40e_vsi *vsi, s16 vid)
{
  int __retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *add_f;
  bool is_netdev;
  bool is_vf;
  struct i40e_mac_filter *tmp;
  struct i40e_mac_filter *tmp_0;
  int tmp_5;
  int tmp_7;
  
#line 2057 
  is_vf = (_Bool)(vsi->type == (unsigned int)I40E_VSI_SRIOV);
  
#line 2058 
  is_netdev = (_Bool)(vsi->netdev != (struct net_device *)0);
  
#line 2060 
  if ((int)is_netdev != 0) {
    
#line 2061 
    add_f = i40e_add_filter(vsi,(vsi->netdev)->dev_addr,(short)((int)vid),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
    
#line 2063 
    if (add_f == (struct i40e_mac_filter *)0) {
      
#line 2064 
      _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Could not add vlan filter %d for %pM\n",(int)vid,(vsi->netdev)->dev_addr);
      
#line 2067 
      __retres = -12;
      
#line 2067 
      goto return_label;
    }
    else ;
  }
  else ;
  {
    
#line 2071 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 2071 
    tmp = (struct i40e_mac_filter *)__mptr;
  }
  
#line 2071 
  f = tmp;
  
#line 2071 
  goto ldv_62301;
  ldv_62300: 
#line 2072 
  ;
  
#line 2072 
  add_f = i40e_add_filter(vsi,(u8 *)(& f->macaddr),(short)((int)vid),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
  
#line 2073 
  if (add_f == (struct i40e_mac_filter *)0) {
    
#line 2074 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Could not add vlan filter %d for %pM\n",(int)vid,(u8 *)(& f->macaddr));
    
#line 2077 
    __retres = -12;
    
#line 2077 
    goto return_label;
  }
  else ;
  {
    
#line 2071 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 2071 
    tmp_0 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 2071 
  f = tmp_0;
  ldv_62301: 
#line 2073 
  ;
  
#line 2071 
  if (& f->list != & vsi->mac_filter_list) 
#line 2073 
                                           goto ldv_62300; else 
#line 2076 
                                                                goto ldv_62302;
  ldv_62302: 
#line 2077 
  ;
  
#line 2086 
  if ((int)vid > 0) {
    
#line 2087 
    if ((int)is_netdev != 0) {
      struct i40e_mac_filter *tmp_1;
      
#line 2087 
      tmp_1 = i40e_find_filter(vsi,(vsi->netdev)->dev_addr,(short)(-1),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
      
#line 2087 
      if (tmp_1 != (struct i40e_mac_filter *)0) {
        
#line 2090 
        i40e_del_filter(vsi,(vsi->netdev)->dev_addr,(short)(-1),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
        
#line 2092 
        add_f = i40e_add_filter(vsi,(vsi->netdev)->dev_addr,(short)0,(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
        
#line 2094 
        if (add_f == (struct i40e_mac_filter *)0) {
          
#line 2095 
          _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Could not add filter 0 for %pM\n",(vsi->netdev)->dev_addr);
          
#line 2098 
          __retres = -12;
          
#line 2098 
          goto return_label;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 2104 
  if ((int)vid > 0 && (unsigned int)vsi->info.pvid == 0U) {
    struct i40e_mac_filter *tmp_2;
    struct i40e_mac_filter *tmp_3;
    struct i40e_mac_filter *tmp_4;
    {
      
#line 2105 
      struct list_head const *__mptr_1 = (struct list_head const *)vsi->mac_filter_list.next;
      
#line 2105 
      tmp_2 = (struct i40e_mac_filter *)__mptr_1;
    }
    
#line 2105 
    f = tmp_2;
    
#line 2105 
    goto ldv_62308;
    ldv_62307: 
#line 2106 
    ;
    
#line 2106 
    tmp_3 = i40e_find_filter(vsi,(u8 *)(& f->macaddr),(short)(-1),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
    
#line 2106 
    if (tmp_3 != (struct i40e_mac_filter *)0) {
      
#line 2108 
      i40e_del_filter(vsi,(u8 *)(& f->macaddr),(short)(-1),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
      
#line 2110 
      add_f = i40e_add_filter(vsi,(u8 *)(& f->macaddr),(short)0,(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
      
#line 2112 
      if (add_f == (struct i40e_mac_filter *)0) {
        
#line 2113 
        _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Could not add filter 0 for %pM\n",(u8 *)(& f->macaddr));
        
#line 2116 
        __retres = -12;
        
#line 2116 
        goto return_label;
      }
      else ;
    }
    else ;
    {
      
#line 2105 
      struct list_head const *__mptr_2 = (struct list_head const *)f->list.next;
      
#line 2105 
      tmp_4 = (struct i40e_mac_filter *)__mptr_2;
    }
    
#line 2105 
    f = tmp_4;
    ldv_62308: 
#line 2107 
    ;
    
#line 2105 
    if (& f->list != & vsi->mac_filter_list) 
#line 2107 
                                             goto ldv_62307; else 
#line 2110 
                                                                  goto ldv_62309;
    ldv_62309: 
#line 2111 
    ;
  }
  else ;
  
#line 2122 
  tmp_5 = constant_test_bit(3L,(unsigned long const volatile *)(& (vsi->back)->state));
  
#line 2122 
  if (tmp_5 != 0) {
    
#line 2124 
    __retres = 0;
    
#line 2124 
    goto return_label;
  }
  else {
    int tmp_6;
    
#line 2122 
    tmp_6 = constant_test_bit(9L,(unsigned long const volatile *)(& (vsi->back)->state));
    
#line 2122 
    if (tmp_6 != 0) {
      
#line 2124 
      __retres = 0;
      
#line 2124 
      goto return_label;
    }
    else ;
  }
  
#line 2126 
  tmp_7 = i40e_sync_vsi_filters(vsi);
  
#line 2126 
  __retres = tmp_7;
  return_label: 
#line 2126 
                return __retres;
}


#line 2136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_kill_vlan(struct i40e_vsi *vsi, s16 vid)
{
  int __retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *add_f;
  bool is_vf;
  bool is_netdev;
  struct i40e_mac_filter *tmp;
  struct i40e_mac_filter *tmp_0;
  struct i40e_mac_filter *tmp_1;
  struct i40e_mac_filter *tmp_3;
  int tmp_6;
  int tmp_8;
  
#line 2138 
  struct net_device *netdev = vsi->netdev;
  
#line 2141 
  int filter_count = 0;
  
#line 2143 
  is_vf = (_Bool)(vsi->type == (unsigned int)I40E_VSI_SRIOV);
  
#line 2144 
  is_netdev = (_Bool)(netdev != (struct net_device *)0);
  
#line 2146 
  if ((int)is_netdev != 0) 
#line 2147 
                           i40e_del_filter(vsi,netdev->dev_addr,(short)((int)vid),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0)); else ;
  {
    
#line 2149 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 2149 
    tmp = (struct i40e_mac_filter *)__mptr;
  }
  
#line 2149 
  f = tmp;
  
#line 2149 
  goto ldv_62325;
  ldv_62324: 
#line 2150 
  ;
  
#line 2150 
  i40e_del_filter(vsi,(u8 *)(& f->macaddr),(short)((int)vid),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
  {
    
#line 2149 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 2149 
    tmp_0 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 2149 
  f = tmp_0;
  ldv_62325: 
#line 2151 
  ;
  
#line 2149 
  if (& f->list != & vsi->mac_filter_list) 
#line 2151 
                                           goto ldv_62324; else 
#line 2154 
                                                                goto ldv_62326;
  ldv_62326: 
#line 2155 
  ;
  {
    
#line 2157 
    struct list_head const *__mptr_1 = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 2157 
    tmp_1 = (struct i40e_mac_filter *)__mptr_1;
  }
  
#line 2157 
  f = tmp_1;
  
#line 2157 
  goto ldv_62332;
  ldv_62331: 
#line 2158 
  ;
  
#line 2158 
  if ((int)is_netdev != 0) {
    
#line 2159 
    if ((int)f->vlan != 0) {
      bool tmp_2;
      
#line 2159 
      tmp_2 = ether_addr_equal((u8 const *)netdev->dev_addr,(u8 const *)(& f->macaddr));
      
#line 2159 
      if ((int)tmp_2 != 0) 
#line 2161 
                           filter_count += 1; else ;
    }
    else ;
  }
  else ;
  
#line 2164 
  if ((int)f->vlan != 0) 
#line 2165 
                         filter_count += 1; else ;
  {
    
#line 2157 
    struct list_head const *__mptr_2 = (struct list_head const *)f->list.next;
    
#line 2157 
    tmp_3 = (struct i40e_mac_filter *)__mptr_2;
  }
  
#line 2157 
  f = tmp_3;
  ldv_62332: 
#line 2159 
  ;
  
#line 2157 
  if (& f->list != & vsi->mac_filter_list) 
#line 2159 
                                           goto ldv_62331; else 
#line 2162 
                                                                goto ldv_62333;
  ldv_62333: 
#line 2163 
  ;
  
#line 2168 
  if (filter_count == 0 && (int)is_netdev != 0) {
    
#line 2169 
    i40e_del_filter(vsi,netdev->dev_addr,(short)0,(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
    
#line 2170 
    f = i40e_add_filter(vsi,netdev->dev_addr,(short)(-1),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
    
#line 2172 
    if (f == (struct i40e_mac_filter *)0) {
      
#line 2173 
      _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Could not add filter %d for %pM\n",-1,netdev->dev_addr);
      
#line 2176 
      __retres = -12;
      
#line 2176 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2180 
  if (filter_count == 0) {
    struct i40e_mac_filter *tmp_4;
    struct i40e_mac_filter *tmp_5;
    {
      
#line 2181 
      struct list_head const *__mptr_3 = (struct list_head const *)vsi->mac_filter_list.next;
      
#line 2181 
      tmp_4 = (struct i40e_mac_filter *)__mptr_3;
    }
    
#line 2181 
    f = tmp_4;
    
#line 2181 
    goto ldv_62339;
    ldv_62338: 
#line 2182 
    ;
    
#line 2182 
    i40e_del_filter(vsi,(u8 *)(& f->macaddr),(short)0,(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
    
#line 2183 
    add_f = i40e_add_filter(vsi,(u8 *)(& f->macaddr),(short)(-1),(_Bool)((bool)((int)is_vf) != 0),(_Bool)((bool)((int)is_netdev) != 0));
    
#line 2185 
    if (add_f == (struct i40e_mac_filter *)0) {
      
#line 2186 
      _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Could not add filter %d for %pM\n",-1,(u8 *)(& f->macaddr));
      
#line 2189 
      __retres = -12;
      
#line 2189 
      goto return_label;
    }
    else ;
    {
      
#line 2181 
      struct list_head const *__mptr_4 = (struct list_head const *)f->list.next;
      
#line 2181 
      tmp_5 = (struct i40e_mac_filter *)__mptr_4;
    }
    
#line 2181 
    f = tmp_5;
    ldv_62339: 
#line 2183 
    ;
    
#line 2181 
    if (& f->list != & vsi->mac_filter_list) 
#line 2183 
                                             goto ldv_62338; else 
#line 2186 
                                                                  goto ldv_62340;
    ldv_62340: 
#line 2187 
    ;
  }
  else ;
  
#line 2194 
  tmp_6 = constant_test_bit(3L,(unsigned long const volatile *)(& (vsi->back)->state));
  
#line 2194 
  if (tmp_6 != 0) {
    
#line 2196 
    __retres = 0;
    
#line 2196 
    goto return_label;
  }
  else {
    int tmp_7;
    
#line 2194 
    tmp_7 = constant_test_bit(9L,(unsigned long const volatile *)(& (vsi->back)->state));
    
#line 2194 
    if (tmp_7 != 0) {
      
#line 2196 
      __retres = 0;
      
#line 2196 
      goto return_label;
    }
    else ;
  }
  
#line 2198 
  tmp_8 = i40e_sync_vsi_filters(vsi);
  
#line 2198 
  __retres = tmp_8;
  return_label: 
#line 2198 
                return __retres;
}


#line 2209  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  int __retres;
  
#line 2216 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2217 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2218 
  int ret = 0;
  
#line 2220 
  if ((unsigned int)vid > 4095U) {
    
#line 2221 
    __retres = -22;
    
#line 2221 
    goto return_label;
  }
  else ;
  
#line 2223 
  netdev_info((struct net_device const *)netdev,"adding %pM vid=%d\n",netdev->dev_addr,(int)vid);
  
#line 2231 
  if ((unsigned int)vid != 0U) 
#line 2232 
                               ret = i40e_vsi_add_vlan(vsi,(short)((int)((short)vid))); else ;
  
#line 2234 
  if (ret == 0 && (unsigned int)vid <= 4095U) 
#line 2235 
                                              clear_bit((long)vid,(unsigned long volatile *)(& vsi->active_vlans)); else ;
  
#line 2237 
  __retres = ret;
  return_label: 
#line 2237 
                return __retres;
}


#line 2248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  int __retres;
  
#line 2255 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2256 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2258 
  netdev_info((struct net_device const *)netdev,"removing %pM vid=%d\n",netdev->dev_addr,(int)vid);
  
#line 2264 
  i40e_vsi_kill_vlan(vsi,(short)((int)((short)vid)));
  
#line 2266 
  clear_bit((long)vid,(unsigned long volatile *)(& vsi->active_vlans));
  
#line 2268 
  __retres = 0;
  
#line 2268 
  return __retres;
}


#line 2275  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_restore_vlan(struct i40e_vsi *vsi)
{
  u16 vid;
  unsigned long tmp;
  unsigned long tmp_0;
  
#line 2279 
  if (vsi->netdev == (struct net_device *)0) 
#line 2280 
                                             goto return_label; else ;
  
#line 2282 
  i40e_vlan_rx_register(vsi->netdev,(unsigned int)(vsi->netdev)->features);
  
#line 2284 
  tmp = find_first_bit((unsigned long const *)(& vsi->active_vlans),4096UL);
  
#line 2284 
  vid = (unsigned short)tmp;
  
#line 2284 
  goto ldv_62361;
  ldv_62360: 
#line 2285 
  ;
  
#line 2285 
  i40e_vlan_rx_add_vid(vsi->netdev,(unsigned short)129,(unsigned short)((int)vid));
  
#line 2284 
  tmp_0 = find_next_bit((unsigned long const *)(& vsi->active_vlans),4096UL,(unsigned long)((int)vid + 1));
  
#line 2284 
  vid = (unsigned short)tmp_0;
  ldv_62361: 
#line 2285 
  ;
  
#line 2284 
  if ((unsigned int)vid <= 4095U) 
#line 2286 
                                  goto ldv_62360; else 
#line 2289 
                                                       goto ldv_62362;
  ldv_62362: 
#line 2290 
  ;
  return_label: 
#line 2291 
                return;
}


#line 2294  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_vsi_add_pvid(struct i40e_vsi *vsi, u16 vid)
{
  i40e_status __retres;
  struct i40e_vsi_context ctxt;
  i40e_status aq_ret;
  
#line 2299 
  vsi->info.valid_sections = (unsigned short)4U;
  
#line 2300 
  vsi->info.pvid = vid;
  
#line 2301 
  vsi->info.port_vlan_flags = (unsigned char)21U;
  
#line 2305 
  ctxt.seid = vsi->seid;
  
#line 2306 
  ctxt.info = vsi->info;
  
#line 2307 
  aq_ret = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 2308 
  if (aq_ret != I40E_SUCCESS) {
    
#line 2309 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"%s: update vsi failed, aq_err=%d\n","i40e_vsi_add_pvid",(unsigned int)(vsi->back)->hw.aq.asq_last_status);
    
#line 2312 
    __retres = I40E_ERR_NVM_CHECKSUM;
    
#line 2312 
    goto return_label;
  }
  else ;
  
#line 2315 
  __retres = I40E_SUCCESS;
  return_label: 
#line 2315 
                return __retres;
}


#line 2324  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_remove_pvid(struct i40e_vsi *vsi)
{
  
#line 2326 
  i40e_vlan_stripping_disable(vsi);
  
#line 2328 
  vsi->info.pvid = (unsigned short)0U;
  
#line 2329 
  return;
}


#line 2341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_setup_tx_resources(struct i40e_vsi *vsi)
{
  int i;
  
#line 2343 
  int err = 0;
  
#line 2345 
  i = 0;
  
#line 2345 
  goto ldv_62379;
  ldv_62378: 
#line 2346 
  ;
  
#line 2346 
  err = i40e_setup_tx_descriptors(*(vsi->tx_rings + i));
  
#line 2345 
  i += 1;
  ldv_62379: 
#line 2346 
  ;
  
#line 2345 
  if ((int)vsi->num_queue_pairs > i && err == 0) 
#line 2347 
                                                 goto ldv_62378; else 
                                                                   
#line 2350 
                                                                   goto ldv_62380;
  ldv_62380: 
#line 2351 
  ;
  
#line 2348 
  return err;
}


#line 2357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_tx_resources(struct i40e_vsi *vsi)
{
  int i;
  
#line 2361 
  if (vsi->tx_rings == (struct i40e_ring **)0) 
#line 2362 
                                               goto return_label; else ;
  
#line 2364 
  i = 0;
  
#line 2364 
  goto ldv_62386;
  ldv_62385: 
#line 2365 
  ;
  
#line 2365 
  if (*(vsi->tx_rings + i) != (struct i40e_ring *)0 && (*(vsi->tx_rings + i))->desc != (void *)0) 
    
#line 2366 
    i40e_free_tx_resources(*(vsi->tx_rings + i)); else ;
  
#line 2364 
  i += 1;
  ldv_62386: 
#line 2365 
  ;
  
#line 2364 
  if ((int)vsi->num_queue_pairs > i) 
#line 2366 
                                     goto ldv_62385; else 
#line 2369 
                                                          goto ldv_62387;
  ldv_62387: 
#line 2370 
  ;
  return_label: 
#line 2371 
                return;
}


#line 2379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_setup_rx_resources(struct i40e_vsi *vsi)
{
  int i;
  
#line 2381 
  int err = 0;
  
#line 2383 
  i = 0;
  
#line 2383 
  goto ldv_62394;
  ldv_62393: 
#line 2384 
  ;
  
#line 2384 
  err = i40e_setup_rx_descriptors(*(vsi->rx_rings + i));
  
#line 2383 
  i += 1;
  ldv_62394: 
#line 2384 
  ;
  
#line 2383 
  if ((int)vsi->num_queue_pairs > i && err == 0) 
#line 2385 
                                                 goto ldv_62393; else 
                                                                   
#line 2388 
                                                                   goto ldv_62395;
  ldv_62395: 
#line 2389 
  ;
  
#line 2386 
  i40e_fcoe_setup_ddp_resources(vsi);
  
#line 2388 
  return err;
}


#line 2397  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_rx_resources(struct i40e_vsi *vsi)
{
  int i;
  
#line 2401 
  if (vsi->rx_rings == (struct i40e_ring **)0) 
#line 2402 
                                               goto return_label; else ;
  
#line 2404 
  i = 0;
  
#line 2404 
  goto ldv_62401;
  ldv_62400: 
#line 2405 
  ;
  
#line 2405 
  if (*(vsi->rx_rings + i) != (struct i40e_ring *)0 && (*(vsi->rx_rings + i))->desc != (void *)0) 
    
#line 2406 
    i40e_free_rx_resources(*(vsi->rx_rings + i)); else ;
  
#line 2404 
  i += 1;
  ldv_62401: 
#line 2405 
  ;
  
#line 2404 
  if ((int)vsi->num_queue_pairs > i) 
#line 2406 
                                     goto ldv_62400; else 
#line 2409 
                                                          goto ldv_62402;
  ldv_62402: 
#line 2410 
  ;
  
#line 2408 
  i40e_fcoe_free_ddp_resources(vsi);
  return_label: 
#line 2409 
                return;
}


#line 2419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_config_xps_tx_ring(struct i40e_ring *ring)
{
  cpumask_var_t mask;
  
#line 2421 
  struct i40e_vsi *vsi = ring->vsi;
  
#line 2424 
  if (ring->q_vector == (struct i40e_q_vector *)0 || ring->netdev == (struct net_device *)0) 
    
#line 2425 
    goto return_label; else ;
  
#line 2428 
  if ((unsigned int)vsi->tc_config.numtc <= 1U) {
    int tmp;
    
#line 2429 
    tmp = test_and_set_bit(1L,(unsigned long volatile *)(& ring->state));
    
#line 2429 
    if (tmp == 0) 
#line 2430 
                  netif_set_xps_queue(ring->netdev,(struct cpumask const *)(& (ring->q_vector)->affinity_mask),(unsigned short)((int)ring->queue_index)); else ;
  }
  else {
    bool tmp_0;
    
#line 2433 
    tmp_0 = alloc_cpumask_var((cpumask_var_t **)(& mask),208U);
    
#line 2433 
    if ((int)tmp_0 != 0) {
      
#line 2435 
      bitmap_zero((unsigned long *)(& mask->bits),(unsigned int)nr_cpu_ids);
      
#line 2436 
      netif_set_xps_queue(ring->netdev,(struct cpumask const *)mask,(unsigned short)((int)ring->queue_index));
      
#line 2437 
      free_cpumask_var(mask);
    }
    else ;
  }
  return_label: 
#line 2439 
                return;
}


#line 2447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_configure_tx_ring(struct i40e_ring *ring)
{
  int __retres;
  struct i40e_hmc_obj_txq tx_ctx;
  
#line 2449 
  struct i40e_vsi *vsi = ring->vsi;
  
#line 2450 
  u16 pf_q = (unsigned short)((int)vsi->base_queue + (int)ring->queue_index);
  
#line 2451 
  struct i40e_hw *hw = & (vsi->back)->hw;
  
#line 2453 
  i40e_status err = 0;
  
#line 2454 
  u32 qtx_ctl = 0U;
  
#line 2457 
  if (((vsi->back)->flags & 4194304ULL) != 0ULL) {
    
#line 2458 
    ring->atr_sample_rate = (vsi->back)->atr_sample_rate;
    
#line 2459 
    ring->atr_count = (unsigned char)0U;
  }
  else 
#line 2461 
       ring->atr_sample_rate = (unsigned char)0U;
  
#line 2465 
  i40e_config_xps_tx_ring(ring);
  
#line 2468 
  memset((void *)(& tx_ctx),0,48UL);
  
#line 2470 
  tx_ctx.new_context = (unsigned char)1U;
  
#line 2471 
  tx_ctx.base = ring->dma / 128ULL;
  
#line 2472 
  tx_ctx.qlen = ring->count;
  
#line 2473 
  tx_ctx.fd_ena = (unsigned char)(((vsi->back)->flags & 6291456ULL) != 0ULL);
  
#line 2476 
  tx_ctx.fc_ena = (unsigned char)(vsi->type == (unsigned int)I40E_VSI_FCOE);
  
#line 2478 
  tx_ctx.timesync_ena = (unsigned char)(((vsi->back)->flags & 33554432ULL) != 0ULL);
  
#line 2480 
  if (vsi->type != (unsigned int)I40E_VSI_FDIR) 
#line 2481 
                                                tx_ctx.head_wb_ena = (unsigned char)1U; else ;
  
#line 2482 
  tx_ctx.head_wb_addr = ring->dma + (unsigned long long)((unsigned long)ring->count * 16UL);
  
#line 2495 
  tx_ctx.rdylist = vsi->info.qs_handle[(int)ring->dcb_tc];
  
#line 2496 
  tx_ctx.rdylist_act = (unsigned char)0U;
  
#line 2499 
  err = i40e_clear_lan_tx_queue_context(hw,(unsigned short)((int)pf_q));
  
#line 2500 
  if (err != I40E_SUCCESS) {
    
#line 2501 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Failed to clear LAN Tx queue context on Tx ring %d (pf_q %d), error: %d\n",(int)ring->queue_index,(int)pf_q,(int)err);
    
#line 2504 
    __retres = -12;
    
#line 2504 
    goto return_label;
  }
  else ;
  
#line 2508 
  err = i40e_set_lan_tx_queue_context(hw,(unsigned short)((int)pf_q),& tx_ctx);
  
#line 2509 
  if (err != I40E_SUCCESS) {
    
#line 2510 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Failed to set LAN Tx queue context on Tx ring %d (pf_q %d, error: %d\n",(int)ring->queue_index,(int)pf_q,(int)err);
    
#line 2513 
    __retres = -12;
    
#line 2513 
    goto return_label;
  }
  else ;
  
#line 2517 
  if (vsi->type == (unsigned int)I40E_VSI_VMDQ2) {
    
#line 2518 
    qtx_ctl = 1U;
    
#line 2519 
    qtx_ctl = ((unsigned int)((int)vsi->id << 7) & 65535U) | qtx_ctl;
  }
  else 
#line 2522 
       qtx_ctl = 2U;
  
#line 2525 
  qtx_ctl = ((unsigned int)((int)hw->pf_id << 2) & 60U) | qtx_ctl;
  
#line 2527 
  writel(qtx_ctl,(void volatile *)(hw->hw_addr + ((int)pf_q + 266240) * 4));
  
#line 2528 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 2530 
  clear_bit(3L,(unsigned long volatile *)(& ring->state));
  
#line 2533 
  ring->tail = hw->hw_addr + ((int)pf_q + 270336) * 4;
  
#line 2535 
  __retres = 0;
  return_label: 
#line 2535 
                return __retres;
}


#line 2544  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_configure_rx_ring(struct i40e_ring *ring)
{
  int __retres;
  struct i40e_hmc_obj_rxq rx_ctx;
  int tmp_0;
  int tmp_3;
  
#line 2546 
  struct i40e_vsi *vsi = ring->vsi;
  
#line 2547 
  u32 chain_len = (unsigned int)(vsi->back)->hw.func_caps.rx_buf_chain_len;
  
#line 2548 
  u16 pf_q = (unsigned short)((int)vsi->base_queue + (int)ring->queue_index);
  
#line 2549 
  struct i40e_hw *hw = & (vsi->back)->hw;
  
#line 2551 
  i40e_status err = 0;
  
#line 2553 
  ring->state = 0UL;
  
#line 2556 
  memset((void *)(& rx_ctx),0,48UL);
  
#line 2558 
  ring->rx_buf_len = vsi->rx_buf_len;
  
#line 2559 
  ring->rx_hdr_len = vsi->rx_hdr_len;
  
#line 2561 
  rx_ctx.dbuff = (unsigned short)((int)ring->rx_buf_len >> 7);
  
#line 2562 
  rx_ctx.hbuff = (unsigned short)((int)ring->rx_hdr_len >> 6);
  
#line 2564 
  rx_ctx.base = ring->dma / 128ULL;
  
#line 2565 
  rx_ctx.qlen = ring->count;
  
#line 2567 
  if (((vsi->back)->flags & 8192ULL) != 0ULL) {
    
#line 2568 
    clear_bit(5L,(unsigned long volatile *)(& ring->state));
    
#line 2569 
    rx_ctx.dsize = (unsigned char)0U;
  }
  else 
#line 2571 
       rx_ctx.dsize = (unsigned char)1U;
  
#line 2574 
  rx_ctx.dtype = vsi->dtype;
  
#line 2575 
  if ((unsigned int)vsi->dtype != 0U) {
    
#line 2576 
    clear_bit(4L,(unsigned long volatile *)(& ring->state));
    
#line 2577 
    rx_ctx.hsplit_0 = (unsigned char)15U;
  }
  else 
#line 2582 
       rx_ctx.hsplit_0 = (unsigned char)0U;
  {
    int tmp;
    
#line 2585 
    u16 __min1 = vsi->max_frame;
    
#line 2585 
    u16 __min2 = (unsigned short)((int)ring->rx_buf_len * (int)((unsigned short)chain_len));
    
#line 2585 
    if ((int)__min1 < (int)__min2) 
#line 2585 
                                   tmp = (int)__min1; else 
#line 2585 
                                                           tmp = (int)__min2;
    
#line 2585 
    tmp_0 = tmp;
  }
  
#line 2585 
  rx_ctx.rxmax = (unsigned int)tmp_0;
  
#line 2587 
  if ((unsigned int)hw->revision_id == 0U) 
#line 2588 
                                           rx_ctx.lrxqthresh = (unsigned short)0U; else 
                                                                    
#line 2590 
                                                                    rx_ctx.lrxqthresh = (unsigned short)2U;
  
#line 2591 
  rx_ctx.crcstrip = (unsigned char)1U;
  
#line 2592 
  rx_ctx.l2tsel = (unsigned char)1U;
  
#line 2593 
  rx_ctx.showiv = (unsigned char)1U;
  
#line 2595 
  rx_ctx.fc_ena = (unsigned char)(vsi->type == (unsigned int)I40E_VSI_FCOE);
  
#line 2598 
  rx_ctx.prefena = (unsigned char)1U;
  
#line 2601 
  err = i40e_clear_lan_rx_queue_context(hw,(unsigned short)((int)pf_q));
  
#line 2602 
  if (err != I40E_SUCCESS) {
    
#line 2603 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Failed to clear LAN Rx queue context on Rx ring %d (pf_q %d), error: %d\n",(int)ring->queue_index,(int)pf_q,(int)err);
    
#line 2606 
    __retres = -12;
    
#line 2606 
    goto return_label;
  }
  else ;
  
#line 2610 
  err = i40e_set_lan_rx_queue_context(hw,(unsigned short)((int)pf_q),& rx_ctx);
  
#line 2611 
  if (err != I40E_SUCCESS) {
    
#line 2612 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Failed to set LAN Rx queue context on Rx ring %d (pf_q %d), error: %d\n",(int)ring->queue_index,(int)pf_q,(int)err);
    
#line 2615 
    __retres = -12;
    
#line 2615 
    goto return_label;
  }
  else ;
  
#line 2619 
  ring->tail = hw->hw_addr + ((int)pf_q + 303104) * 4;
  
#line 2620 
  writel(0U,(void volatile *)ring->tail);
  
#line 2622 
  tmp_3 = constant_test_bit(4L,(unsigned long const volatile *)(& ring->state));
  
#line 2622 
  if (tmp_3 != 0) {
    unsigned int tmp_1;
    
#line 2623 
    i40e_alloc_rx_headers(ring);
    
#line 2624 
    if ((int)ring->next_to_clean <= (int)ring->next_to_use) 
#line 2624 
                                                            tmp_1 = (unsigned int)ring->count; else 
                                                                    
#line 2624 
                                                                    tmp_1 = 0U;
    
#line 2624 
    ;
    
#line 2624 
    ;
    
#line 2624 
    i40e_alloc_rx_buffers_ps(ring,(unsigned short)((int)(((tmp_1 + (unsigned int)ring->next_to_clean) - (unsigned int)ring->next_to_use) + 65535U)));
  }
  else {
    unsigned int tmp_2;
    
#line 2626 
    if ((int)ring->next_to_clean <= (int)ring->next_to_use) 
#line 2626 
                                                            tmp_2 = (unsigned int)ring->count; else 
                                                                    
#line 2626 
                                                                    tmp_2 = 0U;
    
#line 2626 
    ;
    
#line 2626 
    ;
    
#line 2626 
    i40e_alloc_rx_buffers_1buf(ring,(unsigned short)((int)(((tmp_2 + (unsigned int)ring->next_to_clean) - (unsigned int)ring->next_to_use) + 65535U)));
  }
  
#line 2629 
  __retres = 0;
  return_label: 
#line 2629 
                return __retres;
}


#line 2638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_configure_tx(struct i40e_vsi *vsi)
{
  u16 i;
  
#line 2640 
  int err = 0;
  
#line 2643 
  i = (unsigned short)0U;
  
#line 2643 
  goto ldv_62435;
  ldv_62434: 
#line 2644 
  ;
  
#line 2644 
  err = i40e_configure_tx_ring(*(vsi->tx_rings + (int)i));
  
#line 2643 
  i = (u16)((int)i + 1);
  ldv_62435: 
#line 2644 
  ;
  
#line 2643 
  if ((int)vsi->num_queue_pairs > (int)i && err == 0) 
#line 2645 
                                                      goto ldv_62434; else 
                                                                    
#line 2648 
                                                                    goto ldv_62436;
  ldv_62436: 
#line 2649 
  ;
  
#line 2646 
  return err;
}


#line 2655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_configure_rx(struct i40e_vsi *vsi)
{
  u16 i;
  
#line 2657 
  int err = 0;
  
#line 2660 
  if (vsi->netdev != (struct net_device *)0 && (vsi->netdev)->mtu > 1500U) 
    
#line 2661 
    vsi->max_frame = (unsigned short)((unsigned int)((unsigned short)(vsi->netdev)->mtu) + 22U); else 
                                                                    
#line 2664 
                                                                    vsi->max_frame = (unsigned short)2048U;
  
#line 2667 
  switch ((vsi->back)->flags & 48ULL) {
    case (unsigned long long)16: 
#line 2669 
    ;
    
#line 2670 
    vsi->rx_hdr_len = (unsigned short)0U;
    
#line 2671 
    vsi->rx_buf_len = vsi->max_frame;
    
#line 2672 
    vsi->dtype = (unsigned char)0U;
    
#line 2673 
    goto ldv_62443;
    case (unsigned long long)32: 
#line 2674 
    ;
    
#line 2675 
    vsi->rx_hdr_len = (unsigned short)512U;
    
#line 2676 
    vsi->rx_buf_len = (unsigned short)2048U;
    
#line 2677 
    vsi->dtype = (unsigned char)1U;
    
#line 2678 
    goto ldv_62443;
    default: 
#line 2679 
    ;
    
#line 2680 
    vsi->rx_hdr_len = (unsigned short)512U;
    
#line 2681 
    vsi->rx_buf_len = (unsigned short)2048U;
    
#line 2682 
    vsi->dtype = (unsigned char)2U;
    
#line 2683 
    goto ldv_62443;
  }
  ldv_62443: 
#line 2688 
  ;
  
#line 2688 
  if (vsi->type == (unsigned int)I40E_VSI_FCOE && ((vsi->back)->flags & 2048ULL) != 0ULL) {
    
#line 2690 
    vsi->rx_hdr_len = (unsigned short)0U;
    
#line 2691 
    vsi->rx_buf_len = (unsigned short)3072U;
    
#line 2692 
    vsi->max_frame = (unsigned short)3072U;
    
#line 2693 
    vsi->dtype = (unsigned char)0U;
  }
  else ;
  
#line 2698 
  vsi->rx_hdr_len = (unsigned short)((unsigned int)((unsigned short)((unsigned int)vsi->rx_hdr_len + 63U)) & 65472U);
  
#line 2700 
  vsi->rx_buf_len = (unsigned short)((unsigned int)((unsigned short)((unsigned int)vsi->rx_buf_len + 127U)) & 65408U);
  
#line 2704 
  i = (unsigned short)0U;
  
#line 2704 
  goto ldv_62447;
  ldv_62446: 
#line 2705 
  ;
  
#line 2705 
  err = i40e_configure_rx_ring(*(vsi->rx_rings + (int)i));
  
#line 2704 
  i = (u16)((int)i + 1);
  ldv_62447: 
#line 2705 
  ;
  
#line 2704 
  if ((int)vsi->num_queue_pairs > (int)i && err == 0) 
#line 2706 
                                                      goto ldv_62446; else 
                                                                    
#line 2709 
                                                                    goto ldv_62448;
  ldv_62448: 
#line 2710 
  ;
  
#line 2707 
  return err;
}


#line 2714  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_config_dcb_rings(struct i40e_vsi *vsi)
{
  struct i40e_ring *tx_ring;
  struct i40e_ring *rx_ring;
  u16 qoffset;
  u16 qcount;
  int i;
  int n;
  
#line 2720 
  if (((vsi->back)->flags & 1048576ULL) == 0ULL) {
    
#line 2722 
    i = 0;
    
#line 2722 
    goto ldv_62459;
    ldv_62458: 
#line 2723 
    ;
    
#line 2723 
    rx_ring = *(vsi->rx_rings + i);
    
#line 2724 
    tx_ring = *(vsi->tx_rings + i);
    
#line 2725 
    rx_ring->dcb_tc = (unsigned char)0U;
    
#line 2726 
    tx_ring->dcb_tc = (unsigned char)0U;
    
#line 2722 
    i += 1;
    ldv_62459: 
#line 2723 
    ;
    
#line 2722 
    if ((int)vsi->num_queue_pairs > i) 
#line 2724 
                                       goto ldv_62458; else 
#line 2727 
                                                            goto ldv_62460;
    ldv_62460: 
#line 2728 
    ;
  }
  else ;
  
#line 2730 
  n = 0;
  
#line 2730 
  goto ldv_62466;
  ldv_62465: 
#line 2731 
  ;
  
#line 2731 
  if ((((int)vsi->tc_config.enabled_tc >> n) & 1) == 0) 
#line 2732 
                                                        goto ldv_62461; else ;
  
#line 2734 
  qoffset = vsi->tc_config.tc_info[n].qoffset;
  
#line 2735 
  qcount = vsi->tc_config.tc_info[n].qcount;
  
#line 2736 
  i = (int)qoffset;
  
#line 2736 
  goto ldv_62463;
  ldv_62462: 
#line 2737 
  ;
  
#line 2737 
  rx_ring = *(vsi->rx_rings + i);
  
#line 2738 
  tx_ring = *(vsi->tx_rings + i);
  
#line 2739 
  rx_ring->dcb_tc = (unsigned char)n;
  
#line 2740 
  tx_ring->dcb_tc = (unsigned char)n;
  
#line 2736 
  i += 1;
  ldv_62463: 
#line 2737 
  ;
  
#line 2736 
  if ((int)qoffset + (int)qcount > i) 
#line 2738 
                                      goto ldv_62462; else 
#line 2741 
                                                           goto ldv_62464;
  ldv_62464: 
#line 2742 
  ;
  ldv_62461: 
#line 2743 
  ;
  
#line 2730 
  n += 1;
  ldv_62466: 
#line 2731 
  ;
  
#line 2730 
  if (n <= 7) 
#line 2732 
              goto ldv_62465; else 
#line 2735 
                                   goto ldv_62467;
  ldv_62467: 
#line 2736 
  ;
  
#line 2737 
  return;
}


#line 2749  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_set_vsi_rx_mode(struct i40e_vsi *vsi)
{
  
#line 2751 
  if (vsi->netdev != (struct net_device *)0) 
#line 2752 
                                             i40e_set_rx_mode(vsi->netdev); else ;
  
#line 2753 
  return;
}


#line 2762  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_filter_restore(struct i40e_vsi *vsi)
{
  struct i40e_fdir_filter *filter;
  struct hlist_node *node;
  struct i40e_fdir_filter *tmp_1;
  struct i40e_fdir_filter *tmp_4;
  
#line 2765 
  struct i40e_pf *pf = vsi->back;
  
#line 2768 
  if ((pf->flags & 2097152ULL) == 0ULL) 
#line 2769 
                                        goto return_label; else ;
  {
    struct i40e_fdir_filter *tmp_0;
    
#line 2771 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    
#line 2771 
    if (____ptr != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp;
      {
        
#line 2771 
        struct hlist_node const *__mptr = (struct hlist_node const *)____ptr;
        
#line 2771 
        tmp = (struct i40e_fdir_filter *)__mptr;
      }
      
#line 2771 
      tmp_0 = tmp;
    }
    else 
#line 2771 
         tmp_0 = (struct i40e_fdir_filter *)0;
    
#line 2771 
    tmp_1 = tmp_0;
  }
  
#line 2771 
  filter = tmp_1;
  
#line 2771 
  goto ldv_62487;
  ldv_62486: 
#line 2772 
  ;
  
#line 2773 
  i40e_add_del_fdir(vsi,filter,(_Bool)1);
  {
    struct i40e_fdir_filter *tmp_3;
    
#line 2771 
    struct hlist_node *____ptr_0 = node;
    
#line 2771 
    if (____ptr_0 != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp_2;
      {
        
#line 2771 
        struct hlist_node const *__mptr_0 = (struct hlist_node const *)____ptr_0;
        
#line 2771 
        tmp_2 = (struct i40e_fdir_filter *)__mptr_0;
      }
      
#line 2771 
      tmp_3 = tmp_2;
    }
    else 
#line 2771 
         tmp_3 = (struct i40e_fdir_filter *)0;
    
#line 2771 
    tmp_4 = tmp_3;
  }
  
#line 2771 
  filter = tmp_4;
  ldv_62487: 
#line 2773 
  ;
  
#line 2771 
  if (filter != (struct i40e_fdir_filter *)0) {
    
#line 2771 
    node = filter->fdir_node.next;
    
#line 2771 
    if (1 != 0) 
#line 2773 
                goto ldv_62486; else 
#line 2776 
                                     goto ldv_62488;
  }
  else 
#line 2776 
       goto ldv_62488;
  ldv_62488: 
#line 2777 
  ;
  return_label: 
#line 2778 
                return;
}


#line 2781  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_configure(struct i40e_vsi *vsi)
{
  int err;
  
#line 2785 
  i40e_set_vsi_rx_mode(vsi);
  
#line 2786 
  i40e_restore_vlan(vsi);
  
#line 2787 
  i40e_vsi_config_dcb_rings(vsi);
  
#line 2788 
  err = i40e_vsi_configure_tx(vsi);
  
#line 2789 
  if (err == 0) 
#line 2790 
                err = i40e_vsi_configure_rx(vsi); else ;
  
#line 2792 
  return err;
}


#line 2799  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_configure_msix(struct i40e_vsi *vsi)
{
  struct i40e_q_vector *q_vector;
  u16 vector;
  int i;
  int q;
  u32 val;
  u32 qp;
  
#line 2801 
  struct i40e_pf *pf = vsi->back;
  
#line 2803 
  struct i40e_hw *hw = & pf->hw;
  
#line 2813 
  qp = (unsigned int)vsi->base_queue;
  
#line 2814 
  vector = (unsigned short)vsi->base_vector;
  
#line 2815 
  i = 0;
  
#line 2815 
  goto ldv_62508;
  ldv_62507: 
#line 2816 
  ;
  
#line 2816 
  q_vector = *(vsi->q_vectors + i);
  
#line 2817 
  q_vector->rx.itr = (unsigned short)((unsigned int)((unsigned short)((int)vsi->rx_itr_setting >> 1)) & 49151U);
  
#line 2818 
  q_vector->rx.latency_range = I40E_LOW_LATENCY;
  
#line 2819 
  writel((unsigned int)q_vector->rx.itr,(void volatile *)(hw->hw_addr + ((int)vector + 49151) * 4));
  
#line 2821 
  q_vector->tx.itr = (unsigned short)((unsigned int)((unsigned short)((int)vsi->tx_itr_setting >> 1)) & 49151U);
  
#line 2822 
  q_vector->tx.latency_range = I40E_LOW_LATENCY;
  
#line 2823 
  writel((unsigned int)q_vector->tx.itr,(void volatile *)(hw->hw_addr + ((int)vector + 49663) * 4));
  
#line 2827 
  writel(qp,(void volatile *)(hw->hw_addr + ((int)vector + 54271) * 4));
  
#line 2828 
  q = 0;
  
#line 2828 
  goto ldv_62505;
  ldv_62504: 
#line 2829 
  ;
  
#line 2829 
  val = ((unsigned int)vector | (qp << 16)) | 1207959552U;
  
#line 2836 
  writel(val,(void volatile *)(hw->hw_addr + (qp + 59392U) * 4U));
  
#line 2838 
  val = ((unsigned int)vector | ((qp + 1U) << 16)) | 1073743872U;
  
#line 2846 
  if ((int)q_vector->num_ringpairs + -1 == q) 
#line 2847 
                                              val |= 134152192U; else ;
  
#line 2850 
  writel(val,(void volatile *)(hw->hw_addr + (qp + 61440U) * 4U));
  
#line 2851 
  qp += 1U;
  
#line 2828 
  q += 1;
  ldv_62505: 
#line 2829 
  ;
  
#line 2828 
  if ((int)q_vector->num_ringpairs > q) 
#line 2830 
                                        goto ldv_62504; else 
#line 2833 
                                                             goto ldv_62506;
  ldv_62506: 
#line 2834 
  ;
  
#line 2815 
  i += 1;
  
#line 2815 
  vector = (u16)((int)vector + 1);
  ldv_62508: 
#line 2816 
  ;
  
#line 2815 
  if (vsi->num_q_vectors > i) 
#line 2817 
                              goto ldv_62507; else 
#line 2820 
                                                   goto ldv_62509;
  ldv_62509: 
#line 2821 
  ;
  
#line 2855 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 2856 
  return;
}


#line 2862  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_enable_misc_int_causes(struct i40e_pf *pf)
{
  u32 val;
  
#line 2864 
  struct i40e_hw *hw = & pf->hw;
  
#line 2868 
  writel(0U,(void volatile *)(hw->hw_addr + 231424U));
  
#line 2869 
  readl((void const volatile *)(hw->hw_addr + 231296U));
  
#line 2871 
  val = 1685651456U;
  
#line 2880 
  if ((pf->flags & 33554432ULL) != 0ULL) 
#line 2881 
                                         val |= 8388608U; else ;
  
#line 2883 
  writel(val,(void volatile *)(hw->hw_addr + 231424U));
  
#line 2886 
  writel(2248146944U,(void volatile *)(hw->hw_addr + 230528U));
  
#line 2890 
  writel(0U,(void volatile *)(hw->hw_addr + 230400U));
  
#line 2891 
  return;
}


#line 2897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_configure_msi_and_legacy(struct i40e_vsi *vsi)
{
  u32 val;
  
#line 2899 
  struct i40e_q_vector *q_vector = *(vsi->q_vectors);
  
#line 2900 
  struct i40e_pf *pf = vsi->back;
  
#line 2901 
  struct i40e_hw *hw = & pf->hw;
  
#line 2905 
  q_vector->rx.itr = (unsigned short)((unsigned int)((unsigned short)((int)vsi->rx_itr_setting >> 1)) & 49151U);
  
#line 2906 
  q_vector->rx.latency_range = I40E_LOW_LATENCY;
  
#line 2907 
  writel((unsigned int)q_vector->rx.itr,(void volatile *)(hw->hw_addr + 229376U));
  
#line 2908 
  q_vector->tx.itr = (unsigned short)((unsigned int)((unsigned short)((int)vsi->tx_itr_setting >> 1)) & 49151U);
  
#line 2909 
  q_vector->tx.latency_range = I40E_LOW_LATENCY;
  
#line 2910 
  writel((unsigned int)q_vector->tx.itr,(void volatile *)(hw->hw_addr + 229504U));
  
#line 2912 
  i40e_enable_misc_int_causes(pf);
  
#line 2915 
  writel(0U,(void volatile *)(hw->hw_addr + 230656U));
  
#line 2918 
  val = 1207959552U;
  
#line 2922 
  writel(val,(void volatile *)(hw->hw_addr + 237568U));
  
#line 2924 
  val = 1207896064U;
  
#line 2928 
  writel(val,(void volatile *)(hw->hw_addr + 245760U));
  
#line 2929 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 2930 
  return;
}


#line 2936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_irq_dynamic_disable_icr0(struct i40e_pf *pf)
{
  
#line 2938 
  struct i40e_hw *hw = & pf->hw;
  
#line 2940 
  writel(24U,(void volatile *)(hw->hw_addr + 230528U));
  
#line 2942 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 2943 
  return;
}


#line 2949  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_irq_dynamic_enable_icr0(struct i40e_pf *pf)
{
  u32 val;
  
#line 2951 
  struct i40e_hw *hw = & pf->hw;
  
#line 2954 
  val = 27U;
  
#line 2958 
  writel(val,(void volatile *)(hw->hw_addr + 230528U));
  
#line 2959 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 2960 
  return;
}


#line 2967  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_irq_dynamic_enable(struct i40e_vsi *vsi, int vector)
{
  u32 val;
  
#line 2969 
  struct i40e_pf *pf = vsi->back;
  
#line 2970 
  struct i40e_hw *hw = & pf->hw;
  
#line 2973 
  val = 27U;
  
#line 2976 
  writel(val,(void volatile *)(hw->hw_addr + (vector + 53759) * 4));
  
#line 2977 
  return;
}


#line 2985  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_irq_dynamic_disable(struct i40e_vsi *vsi, int vector)
{
  u32 val;
  
#line 2987 
  struct i40e_pf *pf = vsi->back;
  
#line 2988 
  struct i40e_hw *hw = & pf->hw;
  
#line 2991 
  val = 24U;
  
#line 2992 
  writel(val,(void volatile *)(hw->hw_addr + (vector + 53759) * 4));
  
#line 2993 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 2994 
  return;
}


#line 3001  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static irqreturn_t i40e_msix_clean_rings(int irq, void *data)
{
  irqreturn_t __retres;
  
#line 3003 
  struct i40e_q_vector *q_vector = (struct i40e_q_vector *)data;
  
#line 3005 
  if (q_vector->tx.ring == (struct i40e_ring *)0 && q_vector->rx.ring == (struct i40e_ring *)0) {
    
#line 3006 
    __retres = IRQ_HANDLED;
    
#line 3006 
    goto return_label;
  }
  else ;
  
#line 3008 
  napi_schedule(& q_vector->napi);
  
#line 3010 
  __retres = IRQ_HANDLED;
  return_label: 
#line 3010 
                return __retres;
}


#line 3020  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_request_irq_msix(struct i40e_vsi *vsi, char *basename)
{
  int __retres;
  int vector;
  int err;
  
#line 3022 
  int q_vectors = vsi->num_q_vectors;
  
#line 3023 
  struct i40e_pf *pf = vsi->back;
  
#line 3024 
  int base = vsi->base_vector;
  
#line 3025 
  int rx_int_idx = 0;
  
#line 3026 
  int tx_int_idx = 0;
  
#line 3029 
  vector = 0;
  
#line 3029 
  goto ldv_62566;
  ldv_62565: 
#line 3030 
  ;
  {
    
#line 3030 
    struct i40e_q_vector *q_vector = *(vsi->q_vectors + vector);
    
#line 3032 
    if (q_vector->tx.ring != (struct i40e_ring *)0 && q_vector->rx.ring != (struct i40e_ring *)0) {
      int tmp;
      
#line 3034 
      tmp = rx_int_idx;
      
#line 3034 
      rx_int_idx += 1;
      
#line 3033 
      ;
      
#line 3033 
      ;
      
#line 3033 
      ;
      
#line 3033 
      snprintf((char *)(& q_vector->name),24UL,"%s-%s-%d",basename,(char *)"TxRx",tmp);
      
#line 3035 
      tx_int_idx += 1;
    }
    else 
      
#line 3036 
      if (q_vector->rx.ring != (struct i40e_ring *)0) {
        int tmp_0;
        
#line 3038 
        tmp_0 = rx_int_idx;
        
#line 3038 
        rx_int_idx += 1;
        
#line 3037 
        ;
        
#line 3037 
        ;
        
#line 3037 
        ;
        
#line 3037 
        snprintf((char *)(& q_vector->name),24UL,"%s-%s-%d",basename,(char *)"rx",tmp_0);
      }
      else 
        
#line 3039 
        if (q_vector->tx.ring != (struct i40e_ring *)0) {
          int tmp_1;
          
#line 3041 
          tmp_1 = tx_int_idx;
          
#line 3041 
          tx_int_idx += 1;
          
#line 3040 
          ;
          
#line 3040 
          ;
          
#line 3040 
          ;
          
#line 3040 
          snprintf((char *)(& q_vector->name),24UL,"%s-%s-%d",basename,(char *)"tx",tmp_1);
        }
        else 
#line 3044 
             goto ldv_62562;
    
#line 3046 
    err = ldv_request_irq_74((pf->msix_entries + (base + vector))->vector,vsi->irq_handler,0UL,(char const *)(& q_vector->name),(void *)q_vector);
    
#line 3051 
    if (err != 0) {
      
#line 3052 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: request_irq failed, error: %d\n","i40e_vsi_request_irq_msix",err);
      
#line 3055 
      goto free_queue_irqs;
    }
    else ;
    
#line 3058 
    irq_set_affinity_hint((pf->msix_entries + (base + vector))->vector,(struct cpumask const *)(& q_vector->affinity_mask));
  }
  ldv_62562: 
#line 3061 
  ;
  
#line 3029 
  vector += 1;
  ldv_62566: 
#line 3030 
  ;
  
#line 3029 
  if (vector < q_vectors) 
#line 3031 
                          goto ldv_62565; else 
#line 3034 
                                               goto ldv_62567;
  ldv_62567: 
#line 3035 
  ;
  
#line 3062 
  vsi->irqs_ready = (_Bool)1;
  
#line 3063 
  __retres = 0;
  
#line 3063 
  goto return_label;
  free_queue_irqs: 
#line 3065 
  ;
  
#line 3066 
  goto ldv_62569;
  ldv_62568: 
#line 3067 
  ;
  
#line 3067 
  vector -= 1;
  
#line 3068 
  irq_set_affinity_hint((pf->msix_entries + (base + vector))->vector,(struct cpumask const *)0);
  
#line 3070 
  ldv_free_irq_75((pf->msix_entries + (base + vector))->vector,(void *)(vsi->q_vectors + vector));
  ldv_62569: 
#line 3072 
  ;
  
#line 3066 
  if (vector != 0) 
#line 3068 
                   goto ldv_62568; else 
#line 3071 
                                        goto ldv_62570;
  ldv_62570: 
#line 3072 
  ;
  
#line 3073 
  __retres = err;
  return_label: 
#line 3073 
                return __retres;
}


#line 3080  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_disable_irq(struct i40e_vsi *vsi)
{
  int i;
  
#line 3082 
  struct i40e_pf *pf = vsi->back;
  
#line 3083 
  struct i40e_hw *hw = & pf->hw;
  
#line 3084 
  int base = vsi->base_vector;
  
#line 3087 
  i = 0;
  
#line 3087 
  goto ldv_62579;
  ldv_62578: 
#line 3088 
  ;
  
#line 3088 
  writel(0U,(void volatile *)(hw->hw_addr + ((int)(*(vsi->tx_rings + i))->reg_idx + 61440) * 4));
  
#line 3089 
  writel(0U,(void volatile *)(hw->hw_addr + ((int)(*(vsi->rx_rings + i))->reg_idx + 59392) * 4));
  
#line 3087 
  i += 1;
  ldv_62579: 
#line 3088 
  ;
  
#line 3087 
  if ((int)vsi->num_queue_pairs > i) 
#line 3089 
                                     goto ldv_62578; else 
#line 3092 
                                                          goto ldv_62580;
  ldv_62580: 
#line 3093 
  ;
  
#line 3092 
  if ((pf->flags & 8ULL) != 0ULL) {
    
#line 3093 
    i = vsi->base_vector;
    
#line 3093 
    goto ldv_62582;
    ldv_62581: 
#line 3094 
    ;
    
#line 3095 
    writel(0U,(void volatile *)(hw->hw_addr + (i + 53759) * 4));
    
#line 3094 
    i += 1;
    ldv_62582: 
#line 3095 
    ;
    
#line 3093 
    if (vsi->num_q_vectors + vsi->base_vector > i) 
#line 3096 
                                                   goto ldv_62581; else 
                                                                    
#line 3099 
                                                                    goto ldv_62583;
    ldv_62583: 
#line 3100 
    ;
    
#line 3097 
    readl((void const volatile *)(hw->hw_addr + 745772U));
    
#line 3098 
    i = 0;
    
#line 3098 
    goto ldv_62585;
    ldv_62584: 
#line 3099 
    ;
    
#line 3099 
    synchronize_irq((pf->msix_entries + (i + base))->vector);
    
#line 3098 
    i += 1;
    ldv_62585: 
#line 3099 
    ;
    
#line 3098 
    if (vsi->num_q_vectors > i) 
#line 3100 
                                goto ldv_62584; else 
#line 3103 
                                                     goto ldv_62586;
    ldv_62586: 
#line 3104 
    ;
  }
  else {
    
#line 3102 
    writel(0U,(void volatile *)(hw->hw_addr + 231424U));
    
#line 3103 
    writel(0U,(void volatile *)(hw->hw_addr + 230528U));
    
#line 3104 
    readl((void const volatile *)(hw->hw_addr + 745772U));
    
#line 3105 
    synchronize_irq((pf->pdev)->irq);
  }
  
#line 3107 
  return;
}


#line 3113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_enable_irq(struct i40e_vsi *vsi)
{
  int __retres;
  int i;
  
#line 3115 
  struct i40e_pf *pf = vsi->back;
  
#line 3118 
  if ((pf->flags & 8ULL) != 0ULL) {
    
#line 3119 
    i = vsi->base_vector;
    
#line 3119 
    goto ldv_62593;
    ldv_62592: 
#line 3120 
    ;
    
#line 3121 
    i40e_irq_dynamic_enable(vsi,i);
    
#line 3120 
    i += 1;
    ldv_62593: 
#line 3121 
    ;
    
#line 3119 
    if (vsi->num_q_vectors + vsi->base_vector > i) 
#line 3122 
                                                   goto ldv_62592; else 
                                                                    
#line 3125 
                                                                    goto ldv_62594;
    ldv_62594: 
#line 3126 
    ;
  }
  else 
#line 3123 
       i40e_irq_dynamic_enable_icr0(pf);
  
#line 3126 
  readl((void const volatile *)(pf->hw.hw_addr + 745772U));
  
#line 3127 
  __retres = 0;
  
#line 3127 
  return __retres;
}


#line 3134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_stop_misc_vector(struct i40e_pf *pf)
{
  
#line 3137 
  writel(0U,(void volatile *)(pf->hw.hw_addr + 231424U));
  
#line 3138 
  readl((void const volatile *)(pf->hw.hw_addr + 745772U));
  
#line 3139 
  return;
}


#line 3150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static irqreturn_t i40e_intr(int irq, void *data)
{
  u32 icr0;
  u32 icr0_remaining;
  u32 val;
  u32 ena_mask;
  int tmp_5;
  
#line 3152 
  struct i40e_pf *pf = (struct i40e_pf *)data;
  
#line 3153 
  struct i40e_hw *hw = & pf->hw;
  
#line 3154 
  irqreturn_t ret = IRQ_NONE;
  
#line 3158 
  icr0 = readl((void const volatile *)(hw->hw_addr + 231296U));
  
#line 3159 
  ena_mask = readl((void const volatile *)(hw->hw_addr + 231424U));
  
#line 3162 
  if ((icr0 & 1U) == 0U) 
#line 3163 
                         goto enable_intr; else ;
  
#line 3166 
  if ((icr0 & 4294967294U) == 0U || icr0 < (u32)0) 
#line 3168 
                                                   pf->sw_int_count = (u16)((int)pf->sw_int_count + 1); else ;
  
#line 3171 
  if ((icr0 & 2U) != 0U) {
    int tmp_0;
    
#line 3174 
    u32 qval = readl((void const volatile *)(hw->hw_addr + 237568U));
    
#line 3175 
    qval &= 3221225471U;
    
#line 3176 
    writel(qval,(void volatile *)(hw->hw_addr + 237568U));
    
#line 3178 
    qval = readl((void const volatile *)(hw->hw_addr + 245760U));
    
#line 3179 
    qval &= 3221225471U;
    
#line 3180 
    writel(qval,(void volatile *)(hw->hw_addr + 245760U));
    
#line 3182 
    tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
    
#line 3182 
    if (tmp_0 == 0) 
#line 3183 
                    napi_schedule(& (*((*(pf->vsi + (int)pf->lan_vsi))->q_vectors))->napi); else ;
  }
  else ;
  
#line 3186 
  if ((icr0 & 1073741824U) != 0U) {
    
#line 3187 
    ena_mask &= 3221225471U;
    
#line 3188 
    clear_bit(6L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 3191 
  if ((icr0 & 524288U) != 0U) {
    
#line 3192 
    ena_mask &= 4294443007U;
    
#line 3193 
    clear_bit(7L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 3196 
  if ((icr0 & 536870912U) != 0U) {
    
#line 3197 
    ena_mask &= 3758096383U;
    
#line 3198 
    clear_bit(8L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 3201 
  if ((icr0 & 1048576U) != 0U) {
    int tmp_1;
    
#line 3202 
    tmp_1 = constant_test_bit(9L,(unsigned long const volatile *)(& pf->state));
    
#line 3202 
    if (tmp_1 == 0) 
#line 3203 
                    clear_bit(10L,(unsigned long volatile *)(& pf->state)); else ;
    
#line 3204 
    ena_mask &= 4293918719U;
    
#line 3205 
    val = readl((void const volatile *)(hw->hw_addr + 754056U));
    
#line 3206 
    val = (val >> 2) & 3U;
    
#line 3208 
    if (val == 1U) 
#line 3209 
                   pf->corer_count = (u16)((int)pf->corer_count + 1);
    else 
      
#line 3210 
      if (val == 2U) 
#line 3211 
                     pf->globr_count = (u16)((int)pf->globr_count + 1);
      else 
        
#line 3212 
        if (val == 3U) {
          
#line 3213 
          pf->empr_count = (u16)((int)pf->empr_count + 1);
          
#line 3214 
          clear_bit(16L,(unsigned long volatile *)(& pf->state));
        }
        else ;
  }
  else ;
  
#line 3218 
  if ((icr0 & 67108864U) != 0U) {
    unsigned int tmp_2;
    unsigned int tmp_3;
    
#line 3219 
    icr0 &= 4227858431U;
    
#line 3220 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"HMC error interrupt\n");
    
#line 3221 
    tmp_2 = readl((void const volatile *)(hw->hw_addr + 787712U));
    
#line 3221 
    tmp_3 = readl((void const volatile *)(hw->hw_addr + 787456U));
    
#line 3221 
    ;
    
#line 3221 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"HMC error info 0x%x, HMC error data 0x%x\n",tmp_3,tmp_2);
  }
  else ;
  
#line 3226 
  if ((icr0 & 8388608U) != 0U) {
    
#line 3227 
    u32 prttsyn_stat = readl((void const volatile *)(hw->hw_addr + 1983008U));
    
#line 3229 
    if ((prttsyn_stat & 16U) != 0U) {
      
#line 3230 
      icr0 &= 4286578687U;
      
#line 3231 
      i40e_ptp_tx_hwtstamp(pf);
    }
    else ;
  }
  else ;
  
#line 3239 
  icr0_remaining = icr0 & ena_mask;
  
#line 3240 
  if (icr0_remaining != 0U) {
    
#line 3241 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"unhandled interrupt icr0=0x%08x\n",icr0_remaining);
    
#line 3243 
    if (((icr0_remaining & 268435456U) != 0U || (icr0_remaining & 2097152U) != 0U) || (icr0_remaining & 65536U) != 0U) {
      
#line 3246 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"device will be reset\n");
      
#line 3247 
      clear_bit(12L,(unsigned long volatile *)(& pf->state));
      
#line 3248 
      i40e_service_event_schedule(pf);
    }
    else ;
    
#line 3250 
    ena_mask = ~ icr0_remaining & ena_mask;
  }
  else ;
  
#line 3252 
  ret = IRQ_HANDLED;
  enable_intr: 
#line 3254 
  ;
  
#line 3256 
  writel(ena_mask,(void volatile *)(hw->hw_addr + 231424U));
  
#line 3257 
  tmp_5 = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 3257 
  if (tmp_5 == 0) {
    
#line 3258 
    i40e_service_event_schedule(pf);
    
#line 3259 
    i40e_irq_dynamic_enable_icr0(pf);
  }
  else ;
  
#line 3262 
  return ret;
}


#line 3272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static bool i40e_clean_fdir_tx_irq(struct i40e_ring *tx_ring, int budget)
{
  bool __retres;
  struct i40e_tx_buffer *tx_buf;
  struct i40e_tx_desc *tx_desc;
  
#line 3274 
  struct i40e_vsi *vsi = tx_ring->vsi;
  
#line 3275 
  u16 i = tx_ring->next_to_clean;
  
#line 3279 
  tx_buf = tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)i;
  
#line 3280 
  tx_desc = (struct i40e_tx_desc *)tx_ring->desc + (int)i;
  
#line 3281 
  i = (unsigned short)((int)i - (int)tx_ring->count);
  ldv_62622: 
#line 3282 
  ;
  {
    
#line 3284 
    struct i40e_tx_desc *eop_desc = tx_buf->next_to_watch;
    
#line 3287 
    if (eop_desc == (struct i40e_tx_desc *)0) 
#line 3288 
                                              goto ldv_62621; else ;
    
#line 3294 
    if ((eop_desc->cmd_type_offset_bsz & 15ULL) == 0ULL) 
#line 3296 
                                                         goto ldv_62621; else ;
    
#line 3299 
    tx_buf->next_to_watch = (struct i40e_tx_desc *)0;
    
#line 3301 
    tx_desc->buffer_addr = 0ULL;
    
#line 3302 
    tx_desc->cmd_type_offset_bsz = 0ULL;
    
#line 3304 
    tx_buf += 1;
    
#line 3305 
    tx_desc += 1;
    
#line 3306 
    i = (u16)((int)i + 1);
    
#line 3307 
    if ((long)((unsigned int)i == 0U) != 0L) {
      
#line 3308 
      i = (unsigned short)((int)i - (int)tx_ring->count);
      
#line 3309 
      tx_buf = tx_ring->__anonCompField_i40e_ring_121.tx_bi;
      
#line 3310 
      tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
    }
    else ;
    
#line 3313 
    dma_unmap_single_attrs(tx_ring->dev,tx_buf->dma,(unsigned long)tx_buf->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 3317 
    if ((tx_buf->tx_flags & 512U) != 0U) 
#line 3318 
                                         kfree((void const *)tx_buf->__anonCompField_i40e_tx_buffer_120.raw_buf); else ;
    
#line 3320 
    tx_buf->__anonCompField_i40e_tx_buffer_120.raw_buf = (void *)0;
    
#line 3321 
    tx_buf->tx_flags = 0U;
    
#line 3322 
    tx_buf->next_to_watch = (struct i40e_tx_desc *)0;
    
#line 3323 
    tx_buf->len = 0U;
    
#line 3324 
    tx_desc->buffer_addr = 0ULL;
    
#line 3325 
    tx_desc->cmd_type_offset_bsz = 0ULL;
    
#line 3328 
    tx_buf += 1;
    
#line 3329 
    tx_desc += 1;
    
#line 3330 
    i = (u16)((int)i + 1);
    
#line 3331 
    if ((long)((unsigned int)i == 0U) != 0L) {
      
#line 3332 
      i = (unsigned short)((int)i - (int)tx_ring->count);
      
#line 3333 
      tx_buf = tx_ring->__anonCompField_i40e_ring_121.tx_bi;
      
#line 3334 
      tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
    }
    else ;
    
#line 3338 
    budget -= 1;
  }
  
#line 3339 
  if ((long)(budget != 0) != 0L) 
#line 3341 
                                 goto ldv_62622; else 
#line 3344 
                                                      goto ldv_62621;
  ldv_62621: 
#line 3345 
  ;
  
#line 3341 
  i = (unsigned short)((int)tx_ring->count + (int)i);
  
#line 3342 
  tx_ring->next_to_clean = i;
  
#line 3344 
  if (((vsi->back)->flags & 8ULL) != 0ULL) 
#line 3345 
                                           i40e_irq_dynamic_enable(vsi,(int)(tx_ring->q_vector)->v_idx + vsi->base_vector); else ;
  
#line 3348 
  __retres = (_Bool)(budget > 0);
  
#line 3348 
  return __retres;
}


#line 3356  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static irqreturn_t i40e_fdir_clean_ring(int irq, void *data)
{
  irqreturn_t __retres;
  struct i40e_vsi *vsi;
  
#line 3358 
  struct i40e_q_vector *q_vector = (struct i40e_q_vector *)data;
  
#line 3361 
  if (q_vector->tx.ring == (struct i40e_ring *)0) {
    
#line 3362 
    __retres = IRQ_HANDLED;
    
#line 3362 
    goto return_label;
  }
  else ;
  
#line 3364 
  vsi = (q_vector->tx.ring)->vsi;
  
#line 3365 
  i40e_clean_fdir_tx_irq(q_vector->tx.ring,(int)vsi->work_limit);
  
#line 3367 
  __retres = IRQ_HANDLED;
  return_label: 
#line 3367 
                return __retres;
}


#line 3376  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void map_vector_to_qp(struct i40e_vsi *vsi, int v_idx, int qp_idx)
{
  
#line 3378 
  struct i40e_q_vector *q_vector = *(vsi->q_vectors + v_idx);
  
#line 3379 
  struct i40e_ring *tx_ring = *(vsi->tx_rings + qp_idx);
  
#line 3380 
  struct i40e_ring *rx_ring = *(vsi->rx_rings + qp_idx);
  
#line 3382 
  tx_ring->q_vector = q_vector;
  
#line 3383 
  tx_ring->next = q_vector->tx.ring;
  
#line 3384 
  q_vector->tx.ring = tx_ring;
  
#line 3385 
  q_vector->tx.count = (u16)((int)q_vector->tx.count + 1);
  
#line 3387 
  rx_ring->q_vector = q_vector;
  
#line 3388 
  rx_ring->next = q_vector->rx.ring;
  
#line 3389 
  q_vector->rx.ring = rx_ring;
  
#line 3390 
  q_vector->rx.count = (u16)((int)q_vector->rx.count + 1);
  
#line 3391 
  return;
}


#line 3402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_map_rings_to_vectors(struct i40e_vsi *vsi)
{
  int num_ringpairs;
  
#line 3404 
  int qp_remaining = (int)vsi->num_queue_pairs;
  
#line 3405 
  int q_vectors = vsi->num_q_vectors;
  
#line 3407 
  int v_start = 0;
  
#line 3408 
  int qp_idx = 0;
  
#line 3417 
  goto ldv_62650;
  ldv_62649: 
#line 3418 
  ;
  {
    int tmp;
    
#line 3418 
    struct i40e_q_vector *q_vector = *(vsi->q_vectors + v_start);
    
#line 3420 
    num_ringpairs = (((q_vectors - v_start) + qp_remaining) + -1) / (q_vectors - v_start);
    
#line 3422 
    q_vector->num_ringpairs = (unsigned char)num_ringpairs;
    
#line 3424 
    q_vector->rx.count = (unsigned short)0U;
    
#line 3425 
    q_vector->tx.count = (unsigned short)0U;
    
#line 3426 
    q_vector->rx.ring = (struct i40e_ring *)0;
    
#line 3427 
    q_vector->tx.ring = (struct i40e_ring *)0;
    
#line 3429 
    goto ldv_62647;
    ldv_62646: 
#line 3430 
    ;
    
#line 3430 
    map_vector_to_qp(vsi,v_start,qp_idx);
    
#line 3431 
    qp_idx += 1;
    
#line 3432 
    qp_remaining -= 1;
    ldv_62647: 
#line 3433 
    ;
    
#line 3429 
    tmp = num_ringpairs;
    
#line 3429 
    num_ringpairs -= 1;
    
#line 3429 
    ;
    
#line 3429 
    if (tmp != 0) 
#line 3431 
                  goto ldv_62646; else 
#line 3434 
                                       goto ldv_62648;
    ldv_62648: 
#line 3435 
    ;
  }
  
#line 3417 
  v_start += 1;
  ldv_62650: 
#line 3418 
  ;
  
#line 3417 
  if (v_start < q_vectors) 
#line 3419 
                           goto ldv_62649; else 
#line 3422 
                                                goto ldv_62651;
  ldv_62651: 
#line 3423 
  ;
  
#line 3424 
  return;
}


#line 3442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_request_irq(struct i40e_vsi *vsi, char *basename)
{
  int err;
  
#line 3444 
  struct i40e_pf *pf = vsi->back;
  
#line 3447 
  if ((pf->flags & 8ULL) != 0ULL) 
#line 3448 
                                  err = i40e_vsi_request_irq_msix(vsi,basename);
  else 
    
#line 3449 
    if ((pf->flags & 4ULL) != 0ULL) 
#line 3450 
                                    err = ldv_request_irq_76((pf->pdev)->irq,& i40e_intr,0UL,(char const *)(& pf->int_name),(void *)pf); else 
                                                                    
#line 3453 
                                                                    err = ldv_request_irq_77((pf->pdev)->irq,& i40e_intr,128UL,(char const *)(& pf->int_name),(void *)pf);
  
#line 3456 
  if (err != 0) 
#line 3457 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"request_irq failed, Error %d\n",err); else ;
  
#line 3459 
  return err;
}


#line 3471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_netpoll(struct net_device *netdev)
{
  int i;
  int tmp_0;
  
#line 3476 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 3477 
  struct i40e_vsi *vsi = np->vsi;
  
#line 3478 
  struct i40e_pf *pf = vsi->back;
  
#line 3482 
  tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
  
#line 3482 
  if (tmp_0 != 0) 
#line 3483 
                  goto return_label; else ;
  
#line 3485 
  pf->flags |= 4096ULL;
  
#line 3486 
  if ((pf->flags & 8ULL) != 0ULL) {
    
#line 3487 
    i = 0;
    
#line 3487 
    goto ldv_62666;
    ldv_62665: 
#line 3488 
    ;
    
#line 3488 
    i40e_msix_clean_rings(0,(void *)*(vsi->q_vectors + i));
    
#line 3487 
    i += 1;
    ldv_62666: 
#line 3488 
    ;
    
#line 3487 
    if (vsi->num_q_vectors > i) 
#line 3489 
                                goto ldv_62665; else 
#line 3492 
                                                     goto ldv_62667;
    ldv_62667: 
#line 3493 
    ;
  }
  else 
#line 3490 
       i40e_intr((int)(pf->pdev)->irq,(void *)netdev);
  
#line 3492 
  pf->flags &= 18446744073709547519ULL;
  return_label: 
#line 3493 
                return;
}


#line 3507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_pf_txq_wait(struct i40e_pf *pf, int pf_q, bool enable)
{
  int __retres;
  int i;
  u32 tx_reg;
  
#line 3512 
  i = 0;
  
#line 3512 
  goto ldv_62677;
  ldv_62676: 
#line 3513 
  ;
  
#line 3513 
  tx_reg = readl((void const volatile *)(pf->hw.hw_addr + (pf_q + 262144) * 4));
  
#line 3514 
  if ((int)enable == ((tx_reg & 4U) != 0U)) 
#line 3515 
                                            goto ldv_62675; else ;
  
#line 3517 
  usleep_range(10UL,20UL);
  
#line 3512 
  i += 1;
  ldv_62677: 
#line 3513 
  ;
  
#line 3512 
  if (i <= 9) 
#line 3514 
              goto ldv_62676; else 
#line 3517 
                                   goto ldv_62675;
  ldv_62675: 
#line 3518 
  ;
  
#line 3519 
  if (i > 9) {
    
#line 3520 
    __retres = -110;
    
#line 3520 
    goto return_label;
  }
  else ;
  
#line 3522 
  __retres = 0;
  return_label: 
#line 3522 
                return __retres;
}


#line 3530  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_control_tx(struct i40e_vsi *vsi, bool enable)
{
  int i;
  int j;
  int pf_q;
  u32 tx_reg;
  
#line 3532 
  struct i40e_pf *pf = vsi->back;
  
#line 3533 
  struct i40e_hw *hw = & pf->hw;
  
#line 3534 
  int ret = 0;
  
#line 3537 
  pf_q = (int)vsi->base_queue;
  
#line 3538 
  i = 0;
  
#line 3538 
  goto ldv_62696;
  ldv_62695: 
#line 3539 
  ;
  
#line 3541 
  i40e_pre_tx_queue_cfg(& pf->hw,(unsigned int)pf_q,(_Bool)((bool)((int)enable) != 0));
  
#line 3542 
  if (! enable) 
#line 3543 
                usleep_range(10UL,20UL); else ;
  
#line 3545 
  j = 0;
  
#line 3545 
  goto ldv_62691;
  ldv_62690: 
#line 3546 
  ;
  
#line 3546 
  tx_reg = readl((void const volatile *)(hw->hw_addr + (pf_q + 262144) * 4));
  
#line 3547 
  if ((((tx_reg >> 2) ^ tx_reg) & 1U) == 0U) 
#line 3549 
                                             goto ldv_62689; else ;
  
#line 3550 
  usleep_range(1000UL,2000UL);
  
#line 3545 
  j += 1;
  ldv_62691: 
#line 3546 
  ;
  
#line 3545 
  if (j <= 49) 
#line 3547 
               goto ldv_62690; else 
#line 3550 
                                    goto ldv_62689;
  ldv_62689: 
#line 3551 
  ;
  
#line 3553 
  if ((int)enable == ((tx_reg & 4U) != 0U)) 
#line 3554 
                                            goto ldv_62692; else ;
  
#line 3557 
  if ((int)enable != 0) {
    
#line 3558 
    writel(0U,(void volatile *)(hw->hw_addr + (pf_q + 233472) * 4));
    
#line 3559 
    tx_reg |= 1U;
  }
  else 
#line 3561 
       tx_reg &= 4294967294U;
  
#line 3564 
  writel(tx_reg,(void volatile *)(hw->hw_addr + (pf_q + 262144) * 4));
  
#line 3566 
  if (! enable) {
    int tmp;
    
#line 3566 
    tmp = constant_test_bit(24L,(unsigned long const volatile *)(& pf->state));
    
#line 3566 
    if (tmp != 0) 
#line 3567 
                  goto ldv_62692; else ;
  }
  else ;
  
#line 3570 
  ret = i40e_pf_txq_wait(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
  
#line 3571 
  if (ret != 0) {
    char *tmp_0;
    
#line 3572 
    if ((int)enable != 0) 
#line 3572 
                          tmp_0 = (char *)"en"; else 
#line 3572 
                                                     tmp_0 = (char *)"dis";
    
#line 3572 
    ;
    
#line 3572 
    ;
    
#line 3572 
    ;
    
#line 3572 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: VSI seid %d Tx ring %d %sable timeout\n","i40e_vsi_control_tx",(int)vsi->seid,pf_q,tmp_0);
    
#line 3576 
    goto ldv_62694;
  }
  else ;
  ldv_62692: 
#line 3578 
  ;
  
#line 3538 
  i += 1;
  
#line 3538 
  pf_q += 1;
  ldv_62696: 
#line 3539 
  ;
  
#line 3538 
  if ((int)vsi->num_queue_pairs > i) 
#line 3540 
                                     goto ldv_62695; else 
#line 3543 
                                                          goto ldv_62694;
  ldv_62694: 
#line 3544 
  ;
  
#line 3580 
  if ((unsigned int)hw->revision_id == 0U) {
    
#line 3581 
    unsigned long __ms = 50UL;
    {
      unsigned long tmp_1;
      
#line 3581 
      goto ldv_62699;
      ldv_62698: 
#line 3582 
      ;
      
#line 3581 
      __const_udelay(4295000UL);
      ldv_62699: 
#line 3583 
      ;
      
#line 3581 
      tmp_1 = __ms;
      
#line 3581 
      __ms -= 1UL;
      
#line 3581 
      ;
      
#line 3581 
      if (tmp_1 != 0UL) 
#line 3583 
                        goto ldv_62698; else 
#line 3586 
                                             goto ldv_62700;
      ldv_62700: 
#line 3587 
      ;
    }
  }
  else ;
  
#line 3582 
  return ret;
}


#line 3596  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_pf_rxq_wait(struct i40e_pf *pf, int pf_q, bool enable)
{
  int __retres;
  int i;
  u32 rx_reg;
  
#line 3601 
  i = 0;
  
#line 3601 
  goto ldv_62710;
  ldv_62709: 
#line 3602 
  ;
  
#line 3602 
  rx_reg = readl((void const volatile *)(pf->hw.hw_addr + (pf_q + 294912) * 4));
  
#line 3603 
  if ((int)enable == ((rx_reg & 4U) != 0U)) 
#line 3604 
                                            goto ldv_62708; else ;
  
#line 3606 
  usleep_range(10UL,20UL);
  
#line 3601 
  i += 1;
  ldv_62710: 
#line 3602 
  ;
  
#line 3601 
  if (i <= 9) 
#line 3603 
              goto ldv_62709; else 
#line 3606 
                                   goto ldv_62708;
  ldv_62708: 
#line 3607 
  ;
  
#line 3608 
  if (i > 9) {
    
#line 3609 
    __retres = -110;
    
#line 3609 
    goto return_label;
  }
  else ;
  
#line 3611 
  __retres = 0;
  return_label: 
#line 3611 
                return __retres;
}


#line 3619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_control_rx(struct i40e_vsi *vsi, bool enable)
{
  int i;
  int j;
  int pf_q;
  u32 rx_reg;
  
#line 3621 
  struct i40e_pf *pf = vsi->back;
  
#line 3622 
  struct i40e_hw *hw = & pf->hw;
  
#line 3623 
  int ret = 0;
  
#line 3626 
  pf_q = (int)vsi->base_queue;
  
#line 3627 
  i = 0;
  
#line 3627 
  goto ldv_62729;
  ldv_62728: 
#line 3628 
  ;
  
#line 3628 
  j = 0;
  
#line 3628 
  goto ldv_62724;
  ldv_62723: 
#line 3629 
  ;
  
#line 3629 
  rx_reg = readl((void const volatile *)(hw->hw_addr + (pf_q + 294912) * 4));
  
#line 3630 
  if ((((rx_reg >> 2) ^ rx_reg) & 1U) == 0U) 
#line 3632 
                                             goto ldv_62722; else ;
  
#line 3633 
  usleep_range(1000UL,2000UL);
  
#line 3628 
  j += 1;
  ldv_62724: 
#line 3629 
  ;
  
#line 3628 
  if (j <= 49) 
#line 3630 
               goto ldv_62723; else 
#line 3633 
                                    goto ldv_62722;
  ldv_62722: 
#line 3634 
  ;
  
#line 3637 
  if ((int)enable == ((rx_reg & 4U) != 0U)) 
#line 3638 
                                            goto ldv_62725; else ;
  
#line 3641 
  if ((int)enable != 0) 
#line 3642 
                        rx_reg |= 1U; else 
#line 3644 
                                           rx_reg &= 4294967294U;
  
#line 3645 
  writel(rx_reg,(void volatile *)(hw->hw_addr + (pf_q + 294912) * 4));
  
#line 3648 
  ret = i40e_pf_rxq_wait(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
  
#line 3649 
  if (ret != 0) {
    char *tmp;
    
#line 3650 
    if ((int)enable != 0) 
#line 3650 
                          tmp = (char *)"en"; else 
#line 3650 
                                                   tmp = (char *)"dis";
    
#line 3650 
    ;
    
#line 3650 
    ;
    
#line 3650 
    ;
    
#line 3650 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: VSI seid %d Rx ring %d %sable timeout\n","i40e_vsi_control_rx",(int)vsi->seid,pf_q,tmp);
    
#line 3654 
    goto ldv_62727;
  }
  else ;
  ldv_62725: 
#line 3656 
  ;
  
#line 3627 
  i += 1;
  
#line 3627 
  pf_q += 1;
  ldv_62729: 
#line 3628 
  ;
  
#line 3627 
  if ((int)vsi->num_queue_pairs > i) 
#line 3629 
                                     goto ldv_62728; else 
#line 3632 
                                                          goto ldv_62727;
  ldv_62727: 
#line 3633 
  ;
  
#line 3658 
  return ret;
}


#line 3666  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_control_rings(struct i40e_vsi *vsi, bool request)
{
  int __retres;
  
#line 3668 
  int ret = 0;
  
#line 3671 
  if ((int)request != 0) {
    
#line 3672 
    ret = i40e_vsi_control_rx(vsi,(_Bool)((bool)((int)request) != 0));
    
#line 3673 
    if (ret != 0) {
      
#line 3674 
      __retres = ret;
      
#line 3674 
      goto return_label;
    }
    else ;
    
#line 3675 
    ret = i40e_vsi_control_tx(vsi,(_Bool)((bool)((int)request) != 0));
  }
  else {
    
#line 3678 
    i40e_vsi_control_tx(vsi,(_Bool)((bool)((int)request) != 0));
    
#line 3679 
    i40e_vsi_control_rx(vsi,(_Bool)((bool)((int)request) != 0));
  }
  
#line 3682 
  __retres = ret;
  return_label: 
#line 3682 
                return __retres;
}


#line 3689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_irq(struct i40e_vsi *vsi)
{
  u32 val;
  u32 qp;
  int i;
  
#line 3691 
  struct i40e_pf *pf = vsi->back;
  
#line 3692 
  struct i40e_hw *hw = & pf->hw;
  
#line 3693 
  int base = vsi->base_vector;
  
#line 3697 
  if ((pf->flags & 8ULL) != 0ULL) {
    
#line 3698 
    if (vsi->q_vectors == (struct i40e_q_vector **)0) 
#line 3699 
                                                      goto return_label; else ;
    
#line 3701 
    if (! vsi->irqs_ready) 
#line 3702 
                           goto return_label; else ;
    
#line 3704 
    vsi->irqs_ready = (_Bool)0;
    
#line 3705 
    i = 0;
    
#line 3705 
    goto ldv_62751;
    ldv_62750: 
#line 3706 
    ;
    {
      
#line 3706 
      u16 vector = (unsigned short)((int)((unsigned short)i) + (int)((unsigned short)base));
      
#line 3709 
      if (*(vsi->q_vectors + i) == (struct i40e_q_vector *)0 || (unsigned int)(*(vsi->q_vectors + i))->num_ringpairs == 0U) 
        
#line 3711 
        goto ldv_62745; else ;
      
#line 3714 
      irq_set_affinity_hint((pf->msix_entries + (int)vector)->vector,(struct cpumask const *)0);
      
#line 3716 
      ldv_free_irq_78((pf->msix_entries + (int)vector)->vector,(void *)*(vsi->q_vectors + i));
      
#line 3726 
      val = readl((void const volatile *)(hw->hw_addr + ((int)vector + 54271) * 4));
      
#line 3727 
      qp = val & 2047U;
      
#line 3729 
      val |= 2047U;
      
#line 3731 
      writel(val,(void volatile *)(hw->hw_addr + ((int)vector + 54271) * 4));
      
#line 3733 
      goto ldv_62748;
      ldv_62747: 
#line 3734 
      ;
      {
        u32 next;
        
#line 3736 
        val = readl((void const volatile *)(hw->hw_addr + (qp + 59392U) * 4U));
        
#line 3738 
        val &= 1073684224U;
        
#line 3743 
        val |= 134158336U;
        
#line 3746 
        writel(val,(void volatile *)(hw->hw_addr + (qp + 59392U) * 4U));
        
#line 3748 
        val = readl((void const volatile *)(hw->hw_addr + (qp + 61440U) * 4U));
        
#line 3750 
        next = (val >> 16) & 2047U;
        
#line 3753 
        val &= 1073684224U;
        
#line 3758 
        val |= 134158336U;
        
#line 3761 
        writel(val,(void volatile *)(hw->hw_addr + (qp + 61440U) * 4U));
        
#line 3762 
        qp = next;
      }
      ldv_62748: 
#line 3764 
      ;
      
#line 3733 
      if (qp != 2047U) 
#line 3735 
                       goto ldv_62747; else 
#line 3738 
                                            goto ldv_62749;
      ldv_62749: 
#line 3739 
      ;
    }
    ldv_62745: 
#line 3741 
    ;
    
#line 3705 
    i += 1;
    ldv_62751: 
#line 3706 
    ;
    
#line 3705 
    if (vsi->num_q_vectors > i) 
#line 3707 
                                goto ldv_62750; else 
#line 3710 
                                                     goto ldv_62752;
    ldv_62752: 
#line 3711 
    ;
  }
  else {
    
#line 3766 
    ldv_free_irq_79((pf->pdev)->irq,(void *)pf);
    
#line 3768 
    val = readl((void const volatile *)(hw->hw_addr + 230656U));
    
#line 3769 
    qp = val & 2047U;
    
#line 3771 
    val |= 2047U;
    
#line 3773 
    writel(val,(void volatile *)(hw->hw_addr + 230656U));
    
#line 3775 
    val = readl((void const volatile *)(hw->hw_addr + (qp + 59392U) * 4U));
    
#line 3776 
    val &= 1073684224U;
    
#line 3781 
    val |= 134158336U;
    
#line 3784 
    writel(val,(void volatile *)(hw->hw_addr + (qp + 59392U) * 4U));
    
#line 3786 
    val = readl((void const volatile *)(hw->hw_addr + (qp + 61440U) * 4U));
    
#line 3788 
    val &= 1073684224U;
    
#line 3793 
    val |= 134158336U;
    
#line 3796 
    writel(val,(void volatile *)(hw->hw_addr + (qp + 61440U) * 4U));
  }
  return_label: 
#line 3798 
                return;
}


#line 3830 
void __compiletime_assert_3830(void);


#line 3809  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_free_q_vector(struct i40e_vsi *vsi, int v_idx)
{
  struct i40e_ring *ring;
  
#line 3811 
  struct i40e_q_vector *q_vector = *(vsi->q_vectors + v_idx);
  
#line 3814 
  if (q_vector == (struct i40e_q_vector *)0) 
#line 3815 
                                             goto return_label; else ;
  
#line 3818 
  ring = q_vector->tx.ring;
  
#line 3818 
  goto ldv_62760;
  ldv_62759: 
#line 3819 
  ;
  
#line 3819 
  ring->q_vector = (struct i40e_q_vector *)0;
  
#line 3818 
  ring = ring->next;
  ldv_62760: 
#line 3819 
  ;
  
#line 3818 
  if (ring != (struct i40e_ring *)0) 
#line 3820 
                                     goto ldv_62759; else 
#line 3823 
                                                          goto ldv_62761;
  ldv_62761: 
#line 3824 
  ;
  
#line 3821 
  ring = q_vector->rx.ring;
  
#line 3821 
  goto ldv_62763;
  ldv_62762: 
#line 3822 
  ;
  
#line 3822 
  ring->q_vector = (struct i40e_q_vector *)0;
  
#line 3821 
  ring = ring->next;
  ldv_62763: 
#line 3822 
  ;
  
#line 3821 
  if (ring != (struct i40e_ring *)0) 
#line 3823 
                                     goto ldv_62762; else 
#line 3826 
                                                          goto ldv_62764;
  ldv_62764: 
#line 3827 
  ;
  
#line 3825 
  if (vsi->netdev != (struct net_device *)0) 
#line 3826 
                                             netif_napi_del(& q_vector->napi); else ;
  
#line 3828 
  *(vsi->q_vectors + v_idx) = (struct i40e_q_vector *)0;
  {
    
#line 3830 
    bool __cond = (_Bool)0;
    
#line 3830 
    if ((int)__cond != 0) 
#line 3830 
                          __compiletime_assert_3830(); else ;
  }
  
#line 3830 
  kfree_call_rcu(& q_vector->rcu,(void (*)(struct callback_head *))1392);
  return_label: 
#line 3831 
                return;
}


#line 3840  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_q_vectors(struct i40e_vsi *vsi)
{
  int v_idx;
  
#line 3844 
  v_idx = 0;
  
#line 3844 
  goto ldv_62775;
  ldv_62774: 
#line 3845 
  ;
  
#line 3845 
  i40e_free_q_vector(vsi,v_idx);
  
#line 3844 
  v_idx += 1;
  ldv_62775: 
#line 3845 
  ;
  
#line 3844 
  if (vsi->num_q_vectors > v_idx) 
#line 3846 
                                  goto ldv_62774; else 
#line 3849 
                                                       goto ldv_62776;
  ldv_62776: 
#line 3850 
  ;
  
#line 3851 
  return;
}


#line 3852  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reset_interrupt_capability(struct i40e_pf *pf)
{
  
#line 3855 
  if ((pf->flags & 8ULL) != 0ULL) {
    
#line 3856 
    pci_disable_msix(pf->pdev);
    
#line 3857 
    kfree((void const *)pf->msix_entries);
    
#line 3858 
    pf->msix_entries = (struct msix_entry *)0;
    
#line 3859 
    kfree((void const *)pf->irq_pile);
    
#line 3860 
    pf->irq_pile = (struct i40e_lump_tracking *)0;
  }
  else 
    
#line 3861 
    if ((pf->flags & 4ULL) != 0ULL) 
#line 3862 
                                    pci_disable_msi(pf->pdev); else ;
  
#line 3864 
  pf->flags &= 18446744073709551603ULL;
  
#line 3865 
  return;
}


#line 3874  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_clear_interrupt_scheme(struct i40e_pf *pf)
{
  int i;
  
#line 3878 
  i40e_stop_misc_vector(pf);
  
#line 3879 
  if ((pf->flags & 8ULL) != 0ULL) {
    
#line 3880 
    synchronize_irq((pf->msix_entries)->vector);
    
#line 3881 
    ldv_free_irq_80((pf->msix_entries)->vector,(void *)pf);
  }
  else ;
  
#line 3884 
  i40e_put_lump(pf->irq_pile,(unsigned short)0,(unsigned short)32767);
  
#line 3885 
  i = 0;
  
#line 3885 
  goto ldv_62785;
  ldv_62784: 
#line 3886 
  ;
  
#line 3886 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0) 
#line 3887 
                                              i40e_vsi_free_q_vectors(*(pf->vsi + i)); else ;
  
#line 3885 
  i += 1;
  ldv_62785: 
#line 3886 
  ;
  
#line 3885 
  if ((int)pf->num_alloc_vsi > i) 
#line 3887 
                                  goto ldv_62784; else 
#line 3890 
                                                       goto ldv_62786;
  ldv_62786: 
#line 3891 
  ;
  
#line 3888 
  i40e_reset_interrupt_capability(pf);
  
#line 3889 
  return;
}


#line 3895  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_napi_enable_all(struct i40e_vsi *vsi)
{
  int q_idx;
  
#line 3899 
  if (vsi->netdev == (struct net_device *)0) 
#line 3900 
                                             goto return_label; else ;
  
#line 3902 
  q_idx = 0;
  
#line 3902 
  goto ldv_62792;
  ldv_62791: 
#line 3903 
  ;
  
#line 3903 
  napi_enable(& (*(vsi->q_vectors + q_idx))->napi);
  
#line 3902 
  q_idx += 1;
  ldv_62792: 
#line 3903 
  ;
  
#line 3902 
  if (vsi->num_q_vectors > q_idx) 
#line 3904 
                                  goto ldv_62791; else 
#line 3907 
                                                       goto ldv_62793;
  ldv_62793: 
#line 3908 
  ;
  return_label: 
#line 3909 
                return;
}


#line 3910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_napi_disable_all(struct i40e_vsi *vsi)
{
  int q_idx;
  
#line 3914 
  if (vsi->netdev == (struct net_device *)0) 
#line 3915 
                                             goto return_label; else ;
  
#line 3917 
  q_idx = 0;
  
#line 3917 
  goto ldv_62799;
  ldv_62798: 
#line 3918 
  ;
  
#line 3918 
  napi_disable(& (*(vsi->q_vectors + q_idx))->napi);
  
#line 3917 
  q_idx += 1;
  ldv_62799: 
#line 3918 
  ;
  
#line 3917 
  if (vsi->num_q_vectors > q_idx) 
#line 3919 
                                  goto ldv_62798; else 
#line 3922 
                                                       goto ldv_62800;
  ldv_62800: 
#line 3923 
  ;
  return_label: 
#line 3924 
                return;
}


#line 3925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_close(struct i40e_vsi *vsi)
{
  int tmp;
  
#line 3927 
  tmp = test_and_set_bit(3L,(unsigned long volatile *)(& vsi->state));
  
#line 3927 
  if (tmp == 0) 
#line 3928 
                i40e_down(vsi); else ;
  
#line 3929 
  i40e_vsi_free_irq(vsi);
  
#line 3930 
  i40e_vsi_free_tx_resources(vsi);
  
#line 3931 
  i40e_vsi_free_rx_resources(vsi);
  
#line 3932 
  return;
}


#line 3938  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_quiesce_vsi(struct i40e_vsi *vsi)
{
  int tmp;
  int tmp_0;
  
#line 3940 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
  
#line 3940 
  if (tmp != 0) 
#line 3941 
                goto return_label; else ;
  
#line 3944 
  tmp_0 = constant_test_bit(24L,(unsigned long const volatile *)(& (vsi->back)->state));
  
#line 3944 
  if (tmp_0 != 0) {
    
#line 3944 
    if (vsi->type == (unsigned int)I40E_VSI_FCOE) {
      {
        
#line 3946 
        struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_quiesce_vsi", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "%s: VSI seid %d skipping FCoE VSI disable\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3948U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 3946 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 3946 
                                                            __dynamic_dev_dbg(& descriptor,(struct device const *)(& ((vsi->back)->pdev)->dev),"%s: VSI seid %d skipping FCoE VSI disable\n","i40e_quiesce_vsi",(int)vsi->seid); else ;
      }
      
#line 3949 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 3952 
  clear_bit(4L,(unsigned long volatile *)(& vsi->state));
  
#line 3953 
  if (vsi->netdev != (struct net_device *)0) {
    bool tmp_1;
    
#line 3953 
    tmp_1 = netif_running((struct net_device const *)vsi->netdev);
    
#line 3953 
    if ((int)tmp_1 != 0) 
#line 3954 
                         (*(((vsi->netdev)->netdev_ops)->ndo_stop))(vsi->netdev); else 
                                                                    
#line 3956 
                                                                    i40e_vsi_close(vsi);
  }
  else 
#line 3956 
       i40e_vsi_close(vsi);
  return_label: 
#line 3957 
                return;
}


#line 3964  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_unquiesce_vsi(struct i40e_vsi *vsi)
{
  int tmp;
  
#line 3966 
  tmp = constant_test_bit(4L,(unsigned long const volatile *)(& vsi->state));
  
#line 3966 
  if (tmp == 0) 
#line 3967 
                goto return_label; else ;
  
#line 3969 
  clear_bit(4L,(unsigned long volatile *)(& vsi->state));
  
#line 3970 
  if (vsi->netdev != (struct net_device *)0) {
    bool tmp_0;
    
#line 3970 
    tmp_0 = netif_running((struct net_device const *)vsi->netdev);
    
#line 3970 
    if ((int)tmp_0 != 0) 
#line 3971 
                         (*(((vsi->netdev)->netdev_ops)->ndo_open))(vsi->netdev); else 
                                                                    
#line 3973 
                                                                    i40e_vsi_open(vsi);
  }
  else 
#line 3973 
       i40e_vsi_open(vsi);
  return_label: 
#line 3974 
                return;
}


#line 3980  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_pf_quiesce_all_vsi(struct i40e_pf *pf)
{
  int v;
  
#line 3984 
  v = 0;
  
#line 3984 
  goto ldv_62817;
  ldv_62816: 
#line 3985 
  ;
  
#line 3985 
  if (*(pf->vsi + v) != (struct i40e_vsi *)0) 
#line 3986 
                                              i40e_quiesce_vsi(*(pf->vsi + v)); else ;
  
#line 3984 
  v += 1;
  ldv_62817: 
#line 3985 
  ;
  
#line 3984 
  if ((int)pf->num_alloc_vsi > v) 
#line 3986 
                                  goto ldv_62816; else 
#line 3989 
                                                       goto ldv_62818;
  ldv_62818: 
#line 3990 
  ;
  
#line 3991 
  return;
}


#line 3994  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_pf_unquiesce_all_vsi(struct i40e_pf *pf)
{
  int v;
  
#line 3998 
  v = 0;
  
#line 3998 
  goto ldv_62824;
  ldv_62823: 
#line 3999 
  ;
  
#line 3999 
  if (*(pf->vsi + v) != (struct i40e_vsi *)0) 
#line 4000 
                                              i40e_unquiesce_vsi(*(pf->vsi + v)); else ;
  
#line 3998 
  v += 1;
  ldv_62824: 
#line 3999 
  ;
  
#line 3998 
  if ((int)pf->num_alloc_vsi > v) 
#line 4000 
                                  goto ldv_62823; else 
#line 4003 
                                                       goto ldv_62825;
  ldv_62825: 
#line 4004 
  ;
  
#line 4005 
  return;
}


#line 4011  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_wait_txq_disabled(struct i40e_vsi *vsi)
{
  int __retres;
  int i;
  int pf_q;
  int ret;
  
#line 4013 
  struct i40e_pf *pf = vsi->back;
  
#line 4016 
  pf_q = (int)vsi->base_queue;
  
#line 4017 
  i = 0;
  
#line 4017 
  goto ldv_62835;
  ldv_62834: 
#line 4018 
  ;
  
#line 4019 
  ret = i40e_pf_txq_wait(pf,pf_q,(_Bool)0);
  
#line 4020 
  if (ret != 0) {
    
#line 4021 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: VSI seid %d Tx ring %d disable timeout\n","i40e_vsi_wait_txq_disabled",(int)vsi->seid,pf_q);
    
#line 4024 
    __retres = ret;
    
#line 4024 
    goto return_label;
  }
  else ;
  
#line 4017 
  i += 1;
  
#line 4017 
  pf_q += 1;
  ldv_62835: 
#line 4018 
  ;
  
#line 4017 
  if ((int)vsi->num_queue_pairs > i) 
#line 4019 
                                     goto ldv_62834; else 
#line 4022 
                                                          goto ldv_62836;
  ldv_62836: 
#line 4023 
  ;
  
#line 4028 
  __retres = 0;
  return_label: 
#line 4028 
                return __retres;
}


#line 4038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_pf_wait_txq_disabled(struct i40e_pf *pf)
{
  int v;
  
#line 4040 
  int ret = 0;
  
#line 4042 
  v = 0;
  
#line 4042 
  goto ldv_62844;
  ldv_62843: 
#line 4043 
  ;
  
#line 4044 
  if (*(pf->vsi + v) != (struct i40e_vsi *)0 && (*(pf->vsi + v))->type != (unsigned int)I40E_VSI_FCOE) {
    
#line 4045 
    ret = i40e_vsi_wait_txq_disabled(*(pf->vsi + v));
    
#line 4046 
    if (ret != 0) 
#line 4047 
                  goto ldv_62842; else ;
  }
  else ;
  
#line 4042 
  v += 1;
  ldv_62844: 
#line 4043 
  ;
  
#line 4042 
  if (pf->hw.func_caps.num_vsis > (unsigned int)v) 
#line 4044 
                                                   goto ldv_62843; else 
                                                                    
#line 4047 
                                                                    goto ldv_62842;
  ldv_62842: 
#line 4048 
  ;
  
#line 4051 
  return ret;
}


#line 4062  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_get_iscsi_tc_map(struct i40e_pf *pf)
{
  struct i40e_dcb_app_priority_table app;
  u8 tc;
  u8 i;
  
#line 4065 
  struct i40e_hw *hw = & pf->hw;
  
#line 4066 
  u8 enabled_tc = (unsigned char)1U;
  
#line 4069 
  struct i40e_dcbx_config *dcbcfg = & hw->local_dcbx_config;
  
#line 4071 
  i = (unsigned char)0U;
  
#line 4071 
  goto ldv_62856;
  ldv_62855: 
#line 4072 
  ;
  
#line 4072 
  app = dcbcfg->app[(int)i];
  
#line 4073 
  if ((unsigned int)app.selector == 2U && (unsigned int)app.protocolid == 3260U) {
    
#line 4075 
    tc = dcbcfg->etscfg.prioritytable[(int)app.priority];
    
#line 4076 
    enabled_tc = (unsigned char)((1 << (int)tc) | (int)enabled_tc);
    
#line 4077 
    goto ldv_62854;
  }
  else ;
  
#line 4071 
  i = (u8)((int)i + 1);
  ldv_62856: 
#line 4072 
  ;
  
#line 4071 
  if ((unsigned int)i < dcbcfg->numapps) 
#line 4073 
                                         goto ldv_62855; else 
#line 4076 
                                                              goto ldv_62854;
  ldv_62854: 
#line 4077 
  ;
  
#line 4081 
  return enabled_tc;
}


#line 4090  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_dcb_get_num_tc(struct i40e_dcbx_config *dcbcfg)
{
  u8 __retres;
  int i;
  
#line 4092 
  u8 num_tc = (unsigned char)0U;
  
#line 4100 
  i = 0;
  
#line 4100 
  goto ldv_62863;
  ldv_62862: 
#line 4101 
  ;
  
#line 4101 
  if ((int)dcbcfg->etscfg.prioritytable[i] > (int)num_tc) 
#line 4102 
                                                          num_tc = dcbcfg->etscfg.prioritytable[i]; else ;
  
#line 4100 
  i += 1;
  ldv_62863: 
#line 4101 
  ;
  
#line 4100 
  if (i <= 7) 
#line 4102 
              goto ldv_62862; else 
#line 4105 
                                   goto ldv_62864;
  ldv_62864: 
#line 4106 
  ;
  
#line 4108 
  __retres = (unsigned char)((unsigned int)num_tc + 1U);
  
#line 4108 
  return __retres;
}


#line 4118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_dcb_get_enabled_tc(struct i40e_dcbx_config *dcbcfg)
{
  u8 i;
  
#line 4120 
  u8 num_tc = i40e_dcb_get_num_tc(dcbcfg);
  
#line 4121 
  u8 enabled_tc = (unsigned char)1U;
  
#line 4124 
  i = (unsigned char)0U;
  
#line 4124 
  goto ldv_62872;
  ldv_62871: 
#line 4125 
  ;
  
#line 4125 
  enabled_tc = (unsigned char)((1 << (int)i) | (int)enabled_tc);
  
#line 4124 
  i = (u8)((int)i + 1);
  ldv_62872: 
#line 4125 
  ;
  
#line 4124 
  if ((int)i < (int)num_tc) 
#line 4126 
                            goto ldv_62871; else 
#line 4129 
                                                 goto ldv_62873;
  ldv_62873: 
#line 4130 
  ;
  
#line 4127 
  return enabled_tc;
}


#line 4136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_pf_get_num_tc(struct i40e_pf *pf)
{
  u8 __retres;
  u8 i;
  u8 enabled_tc;
  
#line 4138 
  struct i40e_hw *hw = & pf->hw;
  
#line 4140 
  u8 num_tc = (unsigned char)0U;
  
#line 4141 
  struct i40e_dcbx_config *dcbcfg = & hw->local_dcbx_config;
  
#line 4144 
  if ((pf->flags & 1048576ULL) == 0ULL) {
    
#line 4145 
    __retres = (unsigned char)1U;
    
#line 4145 
    goto return_label;
  }
  else ;
  
#line 4148 
  if ((pf->flags & 67108864ULL) == 0ULL) {
    u8 tmp;
    
#line 4149 
    tmp = i40e_dcb_get_num_tc(dcbcfg);
    
#line 4149 
    __retres = tmp;
    
#line 4149 
    goto return_label;
  }
  else ;
  
#line 4152 
  if ((int)pf->hw.func_caps.iscsi != 0) 
#line 4153 
                                        enabled_tc = i40e_get_iscsi_tc_map(pf);
  else {
    
#line 4155 
    __retres = (unsigned char)1U;
    
#line 4155 
    goto return_label;
  }
  
#line 4158 
  if ((unsigned int)enabled_tc != 0U) 
#line 4158 
                                      enabled_tc = enabled_tc; else 
#line 4158 
                                                                    enabled_tc = (unsigned char)1U;
  
#line 4159 
  i = (unsigned char)0U;
  
#line 4159 
  goto ldv_62883;
  ldv_62882: 
#line 4160 
  ;
  
#line 4160 
  if ((((int)enabled_tc >> (int)i) & 1) != 0) 
#line 4161 
                                              num_tc = (u8)((int)num_tc + 1); else ;
  
#line 4159 
  i = (u8)((int)i + 1);
  ldv_62883: 
#line 4160 
  ;
  
#line 4159 
  if ((unsigned int)i <= 7U) 
#line 4161 
                             goto ldv_62882; else 
#line 4164 
                                                  goto ldv_62884;
  ldv_62884: 
#line 4165 
  ;
  
#line 4163 
  __retres = num_tc;
  return_label: 
#line 4163 
                return __retres;
}


#line 4172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_pf_get_default_tc(struct i40e_pf *pf)
{
  u8 __retres;
  
#line 4174 
  u8 enabled_tc = (unsigned char)pf->hw.func_caps.enabled_tcmap;
  
#line 4175 
  u8 i = (unsigned char)0U;
  
#line 4177 
  if ((unsigned int)enabled_tc == 0U) {
    
#line 4178 
    __retres = (unsigned char)1U;
    
#line 4178 
    goto return_label;
  }
  else ;
  
#line 4181 
  i = (unsigned char)0U;
  
#line 4181 
  goto ldv_62892;
  ldv_62891: 
#line 4182 
  ;
  
#line 4182 
  if ((((int)enabled_tc >> (int)i) & 1) != 0) 
#line 4183 
                                              goto ldv_62890; else ;
  
#line 4181 
  i = (u8)((int)i + 1);
  ldv_62892: 
#line 4182 
  ;
  
#line 4181 
  if ((unsigned int)i <= 7U) 
#line 4183 
                             goto ldv_62891; else 
#line 4186 
                                                  goto ldv_62890;
  ldv_62890: 
#line 4187 
  ;
  
#line 4186 
  __retres = (unsigned char)(1 << (int)i);
  return_label: 
#line 4186 
                return __retres;
}


#line 4195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_pf_get_tc_map(struct i40e_pf *pf)
{
  u8 __retres;
  
#line 4198 
  if ((pf->flags & 1048576ULL) == 0ULL) {
    u8 tmp;
    
#line 4199 
    tmp = i40e_pf_get_default_tc(pf);
    
#line 4199 
    __retres = tmp;
    
#line 4199 
    goto return_label;
  }
  else ;
  
#line 4202 
  if ((pf->flags & 67108864ULL) == 0ULL) {
    u8 tmp_0;
    
#line 4203 
    tmp_0 = i40e_dcb_get_enabled_tc(& pf->hw.local_dcbx_config);
    
#line 4203 
    __retres = tmp_0;
    
#line 4203 
    goto return_label;
  }
  else ;
  
#line 4206 
  if ((int)pf->hw.func_caps.iscsi != 0) {
    u8 tmp_1;
    
#line 4207 
    tmp_1 = i40e_get_iscsi_tc_map(pf);
    
#line 4207 
    __retres = tmp_1;
    
#line 4207 
    goto return_label;
  }
  else {
    u8 tmp_2;
    
#line 4209 
    tmp_2 = i40e_pf_get_default_tc(pf);
    
#line 4209 
    __retres = tmp_2;
    
#line 4209 
    goto return_label;
  }
  return_label: 
#line 4206 
                return __retres;
}


#line 4218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_get_bw_info(struct i40e_vsi *vsi)
{
  int __retres;
  i40e_status aq_ret;
  u32 tc_bw_max;
  int i;
  
#line 4220 
  struct i40e_aqc_query_vsi_ets_sla_config_resp bw_ets_config = {.tc_valid_bits = (unsigned char)0U, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0}, .share_credits = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .credits = {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0}, .tc_bw_max = {(unsigned short)0, (unsigned short)0}};
  
#line 4221 
  struct i40e_aqc_query_vsi_bw_config_resp bw_config = {.tc_valid_bits = (unsigned char)0U, .tc_suspended_bits = (unsigned char)0, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .qs_handles = {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0}, .reserved1 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .port_bw_limit = (unsigned short)0, .reserved2 = {(unsigned char)0, (unsigned char)0}, .max_bw = (unsigned char)0, .reserved3 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
  
#line 4222 
  struct i40e_pf *pf = vsi->back;
  
#line 4223 
  struct i40e_hw *hw = & pf->hw;
  
#line 4229 
  aq_ret = i40e_aq_query_vsi_bw_config(hw,(unsigned short)((int)vsi->seid),& bw_config,(struct i40e_asq_cmd_details *)0);
  
#line 4230 
  if (aq_ret != I40E_SUCCESS) {
    
#line 4231 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"couldn\'t get PF vsi bw config, err %d, aq_err %d\n",(int)aq_ret,(unsigned int)pf->hw.aq.asq_last_status);
    
#line 4234 
    __retres = -22;
    
#line 4234 
    goto return_label;
  }
  else ;
  
#line 4238 
  aq_ret = i40e_aq_query_vsi_ets_sla_config(hw,(unsigned short)((int)vsi->seid),& bw_ets_config,(struct i40e_asq_cmd_details *)0);
  
#line 4240 
  if (aq_ret != I40E_SUCCESS) {
    
#line 4241 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"couldn\'t get PF vsi ets bw config, err %d, aq_err %d\n",(int)aq_ret,(unsigned int)pf->hw.aq.asq_last_status);
    
#line 4244 
    __retres = -22;
    
#line 4244 
    goto return_label;
  }
  else ;
  
#line 4247 
  if ((int)bw_config.tc_valid_bits != (int)bw_ets_config.tc_valid_bits) 
    
#line 4248 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Enabled TCs mismatch from querying VSI BW info 0x%08x 0x%08x\n",(int)bw_config.tc_valid_bits,(int)bw_ets_config.tc_valid_bits); else ;
  
#line 4255 
  vsi->bw_limit = bw_config.port_bw_limit;
  
#line 4256 
  vsi->bw_max_quanta = bw_config.max_bw;
  
#line 4257 
  tc_bw_max = (unsigned int)((int)bw_ets_config.tc_bw_max[0] | ((int)bw_ets_config.tc_bw_max[1] << 16));
  
#line 4259 
  i = 0;
  
#line 4259 
  goto ldv_62907;
  ldv_62906: 
#line 4260 
  ;
  
#line 4260 
  vsi->bw_ets_share_credits[i] = bw_ets_config.share_credits[i];
  
#line 4261 
  vsi->bw_ets_limit_credits[i] = bw_ets_config.credits[i];
  
#line 4264 
  vsi->bw_ets_max_quanta[i] = (unsigned char)((unsigned int)((unsigned char)(tc_bw_max >> i * 4)) & 7U);
  
#line 4259 
  i += 1;
  ldv_62907: 
#line 4260 
  ;
  
#line 4259 
  if (i <= 7) 
#line 4261 
              goto ldv_62906; else 
#line 4264 
                                   goto ldv_62908;
  ldv_62908: 
#line 4265 
  ;
  
#line 4267 
  __retres = 0;
  return_label: 
#line 4267 
                return __retres;
}


#line 4278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_configure_bw_alloc(struct i40e_vsi *vsi, u8 enabled_tc, u8 *bw_share)
{
  int __retres;
  struct i40e_aqc_configure_vsi_tc_bw_data bw_data;
  i40e_status aq_ret;
  int i;
  
#line 4285 
  bw_data.tc_valid_bits = enabled_tc;
  
#line 4286 
  i = 0;
  
#line 4286 
  goto ldv_62918;
  ldv_62917: 
#line 4287 
  ;
  
#line 4287 
  bw_data.tc_bw_credits[i] = *(bw_share + i);
  
#line 4286 
  i += 1;
  ldv_62918: 
#line 4287 
  ;
  
#line 4286 
  if (i <= 7) 
#line 4288 
              goto ldv_62917; else 
#line 4291 
                                   goto ldv_62919;
  ldv_62919: 
#line 4292 
  ;
  
#line 4289 
  aq_ret = i40e_aq_config_vsi_tc_bw(& (vsi->back)->hw,(unsigned short)((int)vsi->seid),& bw_data,(struct i40e_asq_cmd_details *)0);
  
#line 4291 
  if (aq_ret != I40E_SUCCESS) {
    
#line 4292 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"AQ command Config VSI BW allocation per TC failed = %d\n",(unsigned int)(vsi->back)->hw.aq.asq_last_status);
    
#line 4295 
    __retres = -22;
    
#line 4295 
    goto return_label;
  }
  else ;
  
#line 4298 
  i = 0;
  
#line 4298 
  goto ldv_62921;
  ldv_62920: 
#line 4299 
  ;
  
#line 4299 
  vsi->info.qs_handle[i] = bw_data.qs_handles[i];
  
#line 4298 
  i += 1;
  ldv_62921: 
#line 4299 
  ;
  
#line 4298 
  if (i <= 7) 
#line 4300 
              goto ldv_62920; else 
#line 4303 
                                   goto ldv_62922;
  ldv_62922: 
#line 4304 
  ;
  
#line 4301 
  __retres = 0;
  return_label: 
#line 4301 
                return __retres;
}


#line 4310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_config_netdev_tc(struct i40e_vsi *vsi, u8 enabled_tc)
{
  int i;
  int tmp;
  
#line 4312 
  struct net_device *netdev = vsi->netdev;
  
#line 4313 
  struct i40e_pf *pf = vsi->back;
  
#line 4314 
  struct i40e_hw *hw = & pf->hw;
  
#line 4315 
  u8 netdev_tc = (unsigned char)0U;
  
#line 4317 
  struct i40e_dcbx_config *dcbcfg = & hw->local_dcbx_config;
  
#line 4319 
  if (netdev == (struct net_device *)0) 
#line 4320 
                                        goto return_label; else ;
  
#line 4322 
  if ((unsigned int)enabled_tc == 0U) {
    
#line 4323 
    netdev_reset_tc(netdev);
    
#line 4324 
    goto return_label;
  }
  else ;
  
#line 4328 
  tmp = netdev_set_num_tc(netdev,(unsigned char)((int)vsi->tc_config.numtc));
  
#line 4328 
  if (tmp != 0) 
#line 4329 
                goto return_label; else ;
  
#line 4332 
  i = 0;
  
#line 4332 
  goto ldv_62934;
  ldv_62933: 
#line 4333 
  ;
  
#line 4340 
  if ((((int)vsi->tc_config.enabled_tc >> i) & 1) != 0) 
#line 4341 
                                                        netdev_set_tc_queue(netdev,(unsigned char)((int)vsi->tc_config.tc_info[i].netdev_tc),(unsigned short)((int)vsi->tc_config.tc_info[i].qcount),(unsigned short)((int)vsi->tc_config.tc_info[i].qoffset)); else ;
  
#line 4332 
  i += 1;
  ldv_62934: 
#line 4333 
  ;
  
#line 4332 
  if (i <= 7) 
#line 4334 
              goto ldv_62933; else 
#line 4337 
                                   goto ldv_62935;
  ldv_62935: 
#line 4338 
  ;
  
#line 4348 
  i = 0;
  
#line 4348 
  goto ldv_62938;
  ldv_62937: 
#line 4349 
  ;
  {
    
#line 4350 
    u8 ets_tc = dcbcfg->etscfg.prioritytable[i];
    
#line 4352 
    netdev_tc = vsi->tc_config.tc_info[(int)ets_tc].netdev_tc;
    
#line 4353 
    netdev_set_prio_tc_map(netdev,(unsigned char)((int)((unsigned char)i)),(unsigned char)((int)netdev_tc));
  }
  
#line 4348 
  i += 1;
  ldv_62938: 
#line 4349 
  ;
  
#line 4348 
  if (i <= 7) 
#line 4350 
              goto ldv_62937; else 
#line 4353 
                                   goto ldv_62939;
  ldv_62939: 
#line 4354 
  ;
  return_label: 
#line 4355 
                return;
}


#line 4362  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_update_queue_map(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt)
{
  
#line 4369 
  vsi->info.mapping_flags = ctxt->info.mapping_flags;
  
#line 4370 
  memcpy((void *)(& vsi->info.queue_mapping),(void const *)(& ctxt->info.queue_mapping),32UL);
  
#line 4372 
  memcpy((void *)(& vsi->info.tc_mapping),(void const *)(& ctxt->info.tc_mapping),16UL);
  
#line 4373 
  return;
}


#line 4389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_config_tc(struct i40e_vsi *vsi, u8 enabled_tc)
{
  int __retres;
  struct i40e_vsi_context ctxt;
  int i;
  i40e_status tmp;
  
#line 4391 
  u8 bw_share[8U] = {(unsigned char)0U};
  
#line 4393 
  int ret = 0;
  
#line 4397 
  if ((int)vsi->tc_config.enabled_tc == (int)enabled_tc) {
    
#line 4398 
    __retres = ret;
    
#line 4398 
    goto return_label;
  }
  else ;
  
#line 4401 
  i = 0;
  
#line 4401 
  goto ldv_62953;
  ldv_62952: 
#line 4402 
  ;
  
#line 4402 
  if ((((int)enabled_tc >> i) & 1) != 0) 
#line 4403 
                                         bw_share[i] = (unsigned char)1U; else ;
  
#line 4401 
  i += 1;
  ldv_62953: 
#line 4402 
  ;
  
#line 4401 
  if (i <= 7) 
#line 4403 
              goto ldv_62952; else 
#line 4406 
                                   goto ldv_62954;
  ldv_62954: 
#line 4407 
  ;
  
#line 4406 
  ret = i40e_vsi_configure_bw_alloc(vsi,(unsigned char)((int)enabled_tc),(u8 *)(& bw_share));
  
#line 4407 
  if (ret != 0) {
    
#line 4408 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Failed configuring TC map %d for VSI %d\n",(int)enabled_tc,(int)vsi->seid);
    
#line 4411 
    goto out;
  }
  else ;
  
#line 4415 
  ctxt.seid = vsi->seid;
  
#line 4416 
  ctxt.pf_num = (vsi->back)->hw.pf_id;
  
#line 4417 
  ctxt.vf_num = (unsigned char)0U;
  
#line 4418 
  ctxt.uplink_seid = vsi->uplink_seid;
  
#line 4419 
  ctxt.info = vsi->info;
  
#line 4420 
  i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)0);
  
#line 4423 
  tmp = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 4423 
  ret = (int)tmp;
  
#line 4424 
  if (ret != 0) {
    
#line 4425 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"update vsi failed, aq_err=%d\n",(unsigned int)(vsi->back)->hw.aq.asq_last_status);
    
#line 4428 
    goto out;
  }
  else ;
  
#line 4431 
  i40e_vsi_update_queue_map(vsi,& ctxt);
  
#line 4432 
  vsi->info.valid_sections = (unsigned short)0U;
  
#line 4435 
  ret = i40e_vsi_get_bw_info(vsi);
  
#line 4436 
  if (ret != 0) {
    
#line 4437 
    _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"Failed updating vsi bw info, aq_err=%d\n",(unsigned int)(vsi->back)->hw.aq.asq_last_status);
    
#line 4440 
    goto out;
  }
  else ;
  
#line 4444 
  i40e_vsi_config_netdev_tc(vsi,(unsigned char)((int)enabled_tc));
  out: 
#line 4445 
  ;
  
#line 4446 
  __retres = ret;
  return_label: 
#line 4446 
                return __retres;
}


#line 4456  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_veb_config_tc(struct i40e_veb *veb, u8 enabled_tc)
{
  int __retres;
  int i;
  i40e_status tmp;
  
#line 4458 
  struct i40e_aqc_configure_switching_comp_bw_config_data bw_data = {.tc_valid_bits = (unsigned char)0U, .reserved = {(unsigned char)0, (unsigned char)0}, .absolute_credits = (unsigned char)0, .tc_bw_share_credits = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .reserved1 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
  
#line 4459 
  struct i40e_pf *pf = veb->pf;
  
#line 4460 
  int ret = 0;
  
#line 4464 
  if ((unsigned int)enabled_tc == 0U || (int)veb->enabled_tc == (int)enabled_tc) {
    
#line 4465 
    __retres = ret;
    
#line 4465 
    goto return_label;
  }
  else ;
  
#line 4467 
  bw_data.tc_valid_bits = enabled_tc;
  
#line 4471 
  i = 0;
  
#line 4471 
  goto ldv_62965;
  ldv_62964: 
#line 4472 
  ;
  
#line 4472 
  if ((((int)enabled_tc >> i) & 1) != 0) 
#line 4473 
                                         bw_data.tc_bw_share_credits[i] = (unsigned char)1U; else ;
  
#line 4471 
  i += 1;
  ldv_62965: 
#line 4472 
  ;
  
#line 4471 
  if (i <= 7) 
#line 4473 
              goto ldv_62964; else 
#line 4476 
                                   goto ldv_62966;
  ldv_62966: 
#line 4477 
  ;
  
#line 4476 
  tmp = i40e_aq_config_switch_comp_bw_config(& pf->hw,(unsigned short)((int)veb->seid),& bw_data,(struct i40e_asq_cmd_details *)0);
  
#line 4476 
  ret = (int)tmp;
  
#line 4478 
  if (ret != 0) {
    
#line 4479 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"veb bw config failed, aq_err=%d\n",(unsigned int)pf->hw.aq.asq_last_status);
    
#line 4482 
    goto out;
  }
  else ;
  
#line 4486 
  ret = i40e_veb_get_bw_info(veb);
  
#line 4487 
  if (ret != 0) 
#line 4488 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"Failed getting veb bw config, aq_err=%d\n",(unsigned int)pf->hw.aq.asq_last_status); else ;
  out: 
#line 4493 
  ;
  
#line 4494 
  __retres = ret;
  return_label: 
#line 4494 
                return __retres;
}


#line 4506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_dcb_reconfigure(struct i40e_pf *pf)
{
  int ret;
  u8 v;
  
#line 4508 
  u8 tc_map = (unsigned char)0U;
  
#line 4513 
  tc_map = i40e_pf_get_tc_map(pf);
  
#line 4514 
  v = (unsigned char)0U;
  
#line 4514 
  goto ldv_62976;
  ldv_62975: 
#line 4515 
  ;
  
#line 4515 
  if (pf->veb[(int)v] == (struct i40e_veb *)0) 
#line 4516 
                                               goto ldv_62974; else ;
  
#line 4517 
  ret = i40e_veb_config_tc(pf->veb[(int)v],(unsigned char)((int)tc_map));
  
#line 4518 
  if (ret != 0) 
#line 4519 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"Failed configuring TC for VEB seid=%d\n",(int)(pf->veb[(int)v])->seid); else ;
  ldv_62974: 
#line 4520 
  ;
  
#line 4514 
  v = (u8)((int)v + 1);
  ldv_62976: 
#line 4515 
  ;
  
#line 4514 
  if ((unsigned int)v <= 15U) 
#line 4516 
                              goto ldv_62975; else 
#line 4519 
                                                   goto ldv_62977;
  ldv_62977: 
#line 4520 
  ;
  
#line 4527 
  v = (unsigned char)0U;
  
#line 4527 
  goto ldv_62980;
  ldv_62979: 
#line 4528 
  ;
  
#line 4528 
  if (*(pf->vsi + (int)v) == (struct i40e_vsi *)0) 
#line 4529 
                                                   goto ldv_62978; else ;
  
#line 4538 
  if ((int)((unsigned short)v) == (int)pf->lan_vsi) 
#line 4539 
                                                    tc_map = i40e_pf_get_tc_map(pf); else 
                                                                    
#line 4541 
                                                                    tc_map = i40e_pf_get_default_tc(pf);
  
#line 4543 
  if ((*(pf->vsi + (int)v))->type == (unsigned int)I40E_VSI_FCOE) 
#line 4544 
                                                                  tc_map = i40e_get_fcoe_tc_map(pf); else ;
  
#line 4547 
  ret = i40e_vsi_config_tc(*(pf->vsi + (int)v),(unsigned char)((int)tc_map));
  
#line 4548 
  if (ret != 0) 
#line 4549 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"Failed configuring TC for VSI seid=%d\n",(int)(*(pf->vsi + (int)v))->seid);
  else {
    
#line 4555 
    i40e_vsi_map_rings_to_vectors(*(pf->vsi + (int)v));
    
#line 4556 
    if ((*(pf->vsi + (int)v))->netdev != (struct net_device *)0) 
#line 4557 
                                                                 i40e_dcbnl_set_all(*(pf->vsi + (int)v)); else ;
  }
  ldv_62978: 
#line 4559 
  ;
  
#line 4527 
  v = (u8)((int)v + 1);
  ldv_62980: 
#line 4528 
  ;
  
#line 4527 
  if ((int)((unsigned short)v) < (int)pf->num_alloc_vsi) 
#line 4529 
                                                         goto ldv_62979; else 
                                                                    
#line 4532 
                                                                    goto ldv_62981;
  ldv_62981: 
#line 4533 
  ;
  
#line 4534 
  return;
}


#line 4569  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_resume_port_tx(struct i40e_pf *pf)
{
  int ret;
  i40e_status tmp;
  
#line 4571 
  struct i40e_hw *hw = & pf->hw;
  
#line 4574 
  tmp = i40e_aq_resume_port_tx(hw,(struct i40e_asq_cmd_details *)0);
  
#line 4574 
  ret = (int)tmp;
  
#line 4575 
  if (ret != 0) {
    
#line 4576 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ command Resume Port Tx failed = %d\n",(unsigned int)pf->hw.aq.asq_last_status);
    
#line 4580 
    clear_bit(12L,(unsigned long volatile *)(& pf->state));
    
#line 4581 
    i40e_service_event_schedule(pf);
  }
  else ;
  
#line 4584 
  return ret;
}


#line 4594  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_pf_dcb(struct i40e_pf *pf)
{
  i40e_status tmp;
  
#line 4596 
  struct i40e_hw *hw = & pf->hw;
  
#line 4597 
  int err = 0;
  
#line 4600 
  if (((unsigned int)pf->hw.aq.fw_maj_ver == 4U && (unsigned int)pf->hw.aq.fw_min_ver <= 32U) || (unsigned int)pf->hw.aq.fw_maj_ver <= 3U) 
    
#line 4602 
    goto out; else ;
  
#line 4605 
  tmp = i40e_init_dcb(hw);
  
#line 4605 
  err = (int)tmp;
  
#line 4606 
  if (err == 0) 
    
#line 4608 
    if (! hw->func_caps.dcb || (unsigned int)hw->dcbx_status == 7U) {
      
#line 4610 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"DCBX offload is not supported or is disabled for this PF.\n");
      
#line 4613 
      if ((pf->flags & 67108864ULL) != 0ULL) 
#line 4614 
                                             goto out; else ;
    }
    else {
      u8 tmp_0;
      
#line 4618 
      pf->dcbx_cap = (unsigned short)10U;
      
#line 4621 
      pf->flags |= 536870912ULL;
      
#line 4623 
      tmp_0 = i40e_dcb_get_num_tc(& hw->local_dcbx_config);
      
#line 4623 
      if ((unsigned int)tmp_0 > 1U) 
#line 4624 
                                    pf->flags |= 1048576ULL; else ;
      {
        
#line 4625 
        struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_init_pf_dcb", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "DCBX offload is supported for this PF.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4626U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 4625 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 4625 
                                                            __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"DCBX offload is supported for this PF.\n"); else ;
      }
    }
  else 
#line 4629 
       _dev_info((struct device const *)(& (pf->pdev)->dev),"AQ Querying DCB configuration failed: aq_err %d\n",(unsigned int)pf->hw.aq.asq_last_status);
  out: 
#line 4634 
  ;
  
#line 4635 
  return err;
}


#line 4644  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_print_link_message(struct i40e_vsi *vsi, bool isup)
{
  
#line 4646 
  char speed[14U] = {(char)'U', (char)'n', (char)'k', (char)'n', (char)'o', (char)'w', (char)'n', (char)'\000'};
  
#line 4647 
  char fc[8U] = {(char)'R', (char)'X', (char)'/', (char)'T', (char)'X', (char)'\000'};
  
#line 4649 
  if (! isup) {
    
#line 4650 
    netdev_info((struct net_device const *)vsi->netdev,"NIC Link is Down\n");
    
#line 4651 
    goto return_label;
  }
  else ;
  
#line 4657 
  if ((vsi->back)->hw.func_caps.npar_enable != 0U && ((vsi->back)->hw.phy.link_info.link_speed == (unsigned int)I40E_LINK_SPEED_1GB || (vsi->back)->hw.phy.link_info.link_speed == (unsigned int)I40E_LINK_SPEED_100MB)) 
    
#line 4660 
    netdev_warn((struct net_device const *)vsi->netdev,"The partition detected link speed that is less than 10Gbps\n"); else ;
  
#line 4663 
  switch ((unsigned int)(vsi->back)->hw.phy.link_info.link_speed) {
    case (unsigned int)16: 
#line 4664 
    ;
    
#line 4665 
    strlcpy((char *)(& speed),"40 Gbps",14UL);
    
#line 4666 
    goto ldv_63002;
    case (unsigned int)32: 
#line 4667 
    ;
    
#line 4668 
    strncpy((char *)(& speed),"20 Gbps",14UL);
    
#line 4669 
    goto ldv_63002;
    case (unsigned int)8: 
#line 4670 
    ;
    
#line 4671 
    strlcpy((char *)(& speed),"10 Gbps",14UL);
    
#line 4672 
    goto ldv_63002;
    case (unsigned int)4: 
#line 4673 
    ;
    
#line 4674 
    strlcpy((char *)(& speed),"1000 Mbps",14UL);
    
#line 4675 
    goto ldv_63002;
    case (unsigned int)2: 
#line 4676 
    ;
    
#line 4677 
    strncpy((char *)(& speed),"100 Mbps",14UL);
    
#line 4678 
    goto ldv_63002;
    default: 
#line 4679 
    ;
    
#line 4680 
    goto ldv_63002;
  }
  ldv_63002: 
#line 4683 
  ;
  
#line 4683 
  switch ((unsigned int)(vsi->back)->hw.fc.current_mode) {
    case (unsigned int)3: 
#line 4684 
    ;
    
#line 4685 
    strlcpy((char *)(& fc),"RX/TX",8UL);
    
#line 4686 
    goto ldv_63009;
    case (unsigned int)2: 
#line 4687 
    ;
    
#line 4688 
    strlcpy((char *)(& fc),"TX",8UL);
    
#line 4689 
    goto ldv_63009;
    case (unsigned int)1: 
#line 4690 
    ;
    
#line 4691 
    strlcpy((char *)(& fc),"RX",8UL);
    
#line 4692 
    goto ldv_63009;
    default: 
#line 4693 
    ;
    
#line 4694 
    strlcpy((char *)(& fc),"None",8UL);
    
#line 4695 
    goto ldv_63009;
  }
  ldv_63009: 
#line 4698 
  ;
  
#line 4698 
  netdev_info((struct net_device const *)vsi->netdev,"NIC Link is Up %s Full Duplex, Flow Control: %s\n",(char *)(& speed),(char *)(& fc));
  return_label: 
#line 4700 
                return;
}


#line 4706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_up_complete(struct i40e_vsi *vsi)
{
  int __retres;
  int err;
  
#line 4708 
  struct i40e_pf *pf = vsi->back;
  
#line 4711 
  if ((pf->flags & 8ULL) != 0ULL) 
#line 4712 
                                  i40e_vsi_configure_msix(vsi); else 
                                                                  
#line 4714 
                                                                  i40e_configure_msi_and_legacy(vsi);
  
#line 4717 
  err = i40e_vsi_control_rings(vsi,(_Bool)1);
  
#line 4718 
  if (err != 0) {
    
#line 4719 
    __retres = err;
    
#line 4719 
    goto return_label;
  }
  else ;
  
#line 4721 
  clear_bit(3L,(unsigned long volatile *)(& vsi->state));
  
#line 4722 
  i40e_napi_enable_all(vsi);
  
#line 4723 
  i40e_vsi_enable_irq(vsi);
  
#line 4725 
  if (((int)pf->hw.phy.link_info.link_info & 1) != 0 && vsi->netdev != (struct net_device *)0) {
    
#line 4727 
    i40e_print_link_message(vsi,(_Bool)1);
    
#line 4728 
    netif_tx_start_all_queues(vsi->netdev);
    
#line 4729 
    netif_carrier_on(vsi->netdev);
  }
  else 
    
#line 4730 
    if (vsi->netdev != (struct net_device *)0) {
      
#line 4731 
      i40e_print_link_message(vsi,(_Bool)0);
      
#line 4733 
      if (((int)pf->hw.phy.link_info.link_info & 64) != 0 && (int)pf->hw.phy.link_info.an_info >= 0) 
        
#line 4737 
        netdev_err((struct net_device const *)vsi->netdev,"the driver failed to link because an unqualified module was detected."); else ;
    }
    else ;
  
#line 4742 
  if (vsi->type == (unsigned int)I40E_VSI_FDIR) {
    u32 tmp;
    
#line 4744 
    tmp = 0U;
    
#line 4744 
    pf->fd_atr_cnt = tmp;
    
#line 4744 
    pf->fd_add_err = tmp;
    
#line 4745 
    if (pf->fd_tcp_rule != 0U) {
      
#line 4746 
      pf->flags &= 18446744073705357311ULL;
      
#line 4747 
      if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 4748 
                                             _dev_info((struct device const *)(& (pf->pdev)->dev),"Forcing ATR off, sideband rules for TCP/IPv4 exist\n"); else ;
      
#line 4749 
      pf->fd_tcp_rule = 0U;
    }
    else ;
    
#line 4751 
    i40e_fdir_filter_restore(vsi);
  }
  else ;
  
#line 4753 
  i40e_service_event_schedule(pf);
  
#line 4755 
  __retres = 0;
  return_label: 
#line 4755 
                return __retres;
}


#line 4765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_reinit_locked(struct i40e_vsi *vsi)
{
  int tmp_0;
  
#line 4767 
  struct i40e_pf *pf = vsi->back;
  {
    int tmp;
    
#line 4769 
    tmp = preempt_count();
    
#line 4769 
    int __ret_warn_on = ((unsigned long)tmp & 2096896UL) != 0UL;
    
#line 4769 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 4769 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c",4769); else ;
    
#line 4769 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 4770 
  goto ldv_63025;
  ldv_63024: 
#line 4771 
  ;
  
#line 4771 
  usleep_range(1000UL,2000UL);
  ldv_63025: 
#line 4772 
  ;
  
#line 4770 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& pf->state));
  
#line 4770 
  if (tmp_0 != 0) 
#line 4772 
                  goto ldv_63024; else 
#line 4775 
                                       goto ldv_63026;
  ldv_63026: 
#line 4776 
  ;
  
#line 4772 
  i40e_down(vsi);
  
#line 4778 
  if (vsi->type == (unsigned int)I40E_VSI_SRIOV) 
#line 4779 
                                                 msleep(2000U); else ;
  
#line 4780 
  i40e_up(vsi);
  
#line 4781 
  clear_bit(1L,(unsigned long volatile *)(& pf->state));
  
#line 4782 
  return;
}


#line 4788  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_up(struct i40e_vsi *vsi)
{
  int err;
  
#line 4792 
  err = i40e_vsi_configure(vsi);
  
#line 4793 
  if (err == 0) 
#line 4794 
                err = i40e_up_complete(vsi); else ;
  
#line 4796 
  return err;
}


#line 4803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_down(struct i40e_vsi *vsi)
{
  int i;
  
#line 4810 
  if (vsi->netdev != (struct net_device *)0) {
    
#line 4811 
    netif_carrier_off(vsi->netdev);
    
#line 4812 
    netif_tx_disable(vsi->netdev);
  }
  else ;
  
#line 4814 
  i40e_vsi_disable_irq(vsi);
  
#line 4815 
  i40e_vsi_control_rings(vsi,(_Bool)0);
  
#line 4816 
  i40e_napi_disable_all(vsi);
  
#line 4818 
  i = 0;
  
#line 4818 
  goto ldv_63036;
  ldv_63035: 
#line 4819 
  ;
  
#line 4819 
  i40e_clean_tx_ring(*(vsi->tx_rings + i));
  
#line 4820 
  i40e_clean_rx_ring(*(vsi->rx_rings + i));
  
#line 4818 
  i += 1;
  ldv_63036: 
#line 4819 
  ;
  
#line 4818 
  if ((int)vsi->num_queue_pairs > i) 
#line 4820 
                                     goto ldv_63035; else 
#line 4823 
                                                          goto ldv_63037;
  ldv_63037: 
#line 4824 
  ;
  
#line 4825 
  return;
}


#line 4830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_setup_tc(struct net_device *netdev, u8 tc)
{
  int __retres;
  int i;
  u8 tmp_0;
  
#line 4835 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 4836 
  struct i40e_vsi *vsi = np->vsi;
  
#line 4837 
  struct i40e_pf *pf = vsi->back;
  
#line 4838 
  u8 enabled_tc = (unsigned char)0U;
  
#line 4839 
  int ret = -22;
  
#line 4843 
  if ((pf->flags & 1048576ULL) == 0ULL) {
    
#line 4844 
    netdev_info((struct net_device const *)netdev,"DCB is not enabled for adapter\n");
    
#line 4845 
    goto exit;
  }
  else ;
  
#line 4849 
  if ((pf->flags & 67108864ULL) != 0ULL) {
    
#line 4850 
    netdev_info((struct net_device const *)netdev,"Configuring TC not supported in MFP mode\n");
    
#line 4851 
    goto exit;
  }
  else ;
  
#line 4855 
  tmp_0 = i40e_pf_get_num_tc(pf);
  
#line 4855 
  ;
  
#line 4855 
  if ((int)tmp_0 < (int)tc) {
    
#line 4856 
    netdev_info((struct net_device const *)netdev,"TC count greater than enabled on link for adapter\n");
    
#line 4857 
    goto exit;
  }
  else ;
  
#line 4861 
  i = 0;
  
#line 4861 
  goto ldv_63050;
  ldv_63049: 
#line 4862 
  ;
  
#line 4862 
  enabled_tc = (unsigned char)((1 << i) | (int)enabled_tc);
  
#line 4861 
  i += 1;
  ldv_63050: 
#line 4862 
  ;
  
#line 4861 
  if ((int)tc > i) 
#line 4863 
                   goto ldv_63049; else 
#line 4866 
                                        goto ldv_63051;
  ldv_63051: 
#line 4867 
  ;
  
#line 4865 
  if ((int)vsi->tc_config.enabled_tc == (int)enabled_tc) {
    
#line 4866 
    __retres = 0;
    
#line 4866 
    goto return_label;
  }
  else ;
  
#line 4869 
  i40e_quiesce_vsi(vsi);
  
#line 4872 
  ret = i40e_vsi_config_tc(vsi,(unsigned char)((int)enabled_tc));
  
#line 4873 
  if (ret != 0) {
    
#line 4874 
    netdev_info((struct net_device const *)netdev,"Failed configuring TC for VSI seid=%d\n",(int)vsi->seid);
    
#line 4876 
    goto exit;
  }
  else ;
  
#line 4880 
  i40e_unquiesce_vsi(vsi);
  exit: 
#line 4882 
  ;
  
#line 4883 
  __retres = ret;
  return_label: 
#line 4883 
                return __retres;
}


#line 4898  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_open(struct net_device *netdev)
{
  int __retres;
  int err;
  int tmp_0;
  
#line 4900 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 4901 
  struct i40e_vsi *vsi = np->vsi;
  
#line 4902 
  struct i40e_pf *pf = vsi->back;
  
#line 4906 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& pf->state));
  
#line 4906 
  if (tmp_0 != 0) {
    
#line 4908 
    __retres = -16;
    
#line 4908 
    goto return_label;
  }
  else {
    int tmp_1;
    
#line 4906 
    tmp_1 = constant_test_bit(20L,(unsigned long const volatile *)(& pf->state));
    
#line 4906 
    if (tmp_1 != 0) {
      
#line 4908 
      __retres = -16;
      
#line 4908 
      goto return_label;
    }
    else ;
  }
  
#line 4910 
  netif_carrier_off(netdev);
  
#line 4912 
  err = i40e_vsi_open(vsi);
  
#line 4913 
  if (err != 0) {
    
#line 4914 
    __retres = err;
    
#line 4914 
    goto return_label;
  }
  else ;
  
#line 4917 
  writel(9U,(void volatile *)(pf->hw.hw_addr + 279256U));
  
#line 4919 
  writel(137U,(void volatile *)(pf->hw.hw_addr + 279260U));
  
#line 4922 
  writel(128U,(void volatile *)(pf->hw.hw_addr + 279264U));
  
#line 4925 
  vxlan_get_rx_port(netdev);
  
#line 4928 
  __retres = 0;
  return_label: 
#line 4928 
                return __retres;
}


#line 4939  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_open(struct i40e_vsi *vsi)
{
  int __retres;
  char int_name[25U];
  int err;
  
#line 4941 
  struct i40e_pf *pf = vsi->back;
  
#line 4946 
  err = i40e_vsi_setup_tx_resources(vsi);
  
#line 4947 
  if (err != 0) 
#line 4948 
                goto err_setup_tx; else ;
  
#line 4949 
  err = i40e_vsi_setup_rx_resources(vsi);
  
#line 4950 
  if (err != 0) 
#line 4951 
                goto err_setup_rx; else ;
  
#line 4953 
  err = i40e_vsi_configure(vsi);
  
#line 4954 
  if (err != 0) 
#line 4955 
                goto err_setup_rx; else ;
  
#line 4957 
  if (vsi->netdev != (struct net_device *)0) {
    char const *tmp;
    
#line 4958 
    ;
    
#line 4958 
    tmp = dev_driver_string((struct device const *)(& (pf->pdev)->dev));
    
#line 4958 
    snprintf((char *)(& int_name),24UL,"%s-%s",tmp,(char *)(& (vsi->netdev)->name));
    
#line 4960 
    err = i40e_vsi_request_irq(vsi,(char *)(& int_name));
    
#line 4961 
    if (err != 0) 
#line 4962 
                  goto err_setup_rx; else ;
    
#line 4965 
    err = netif_set_real_num_tx_queues(vsi->netdev,(unsigned int)vsi->num_queue_pairs);
    
#line 4967 
    if (err != 0) 
#line 4968 
                  goto err_set_queues; else ;
    
#line 4970 
    err = netif_set_real_num_rx_queues(vsi->netdev,(unsigned int)vsi->num_queue_pairs);
    
#line 4972 
    if (err != 0) 
#line 4973 
                  goto err_set_queues; else ;
  }
  else 
    
#line 4975 
    if (vsi->type == (unsigned int)I40E_VSI_FDIR) {
      char const *tmp_0;
      char const *tmp_1;
      
#line 4977 
      tmp_0 = dev_name((struct device const *)(& (pf->pdev)->dev));
      
#line 4976 
      tmp_1 = dev_driver_string((struct device const *)(& (pf->pdev)->dev));
      
#line 4976 
      snprintf((char *)(& int_name),24UL,"%s-%s:fdir",tmp_1,tmp_0);
      
#line 4979 
      err = i40e_vsi_request_irq(vsi,(char *)(& int_name));
    }
    else {
      
#line 4982 
      err = -22;
      
#line 4983 
      goto err_setup_rx;
    }
  
#line 4986 
  err = i40e_up_complete(vsi);
  
#line 4987 
  if (err != 0) 
#line 4988 
                goto err_up_complete; else ;
  
#line 4990 
  __retres = 0;
  
#line 4990 
  goto return_label;
  err_up_complete: 
#line 4992 
  ;
  
#line 4993 
  i40e_down(vsi);
  err_set_queues: 
#line 4994 
  ;
  
#line 4995 
  i40e_vsi_free_irq(vsi);
  err_setup_rx: 
#line 4996 
  ;
  
#line 4997 
  i40e_vsi_free_rx_resources(vsi);
  err_setup_tx: 
#line 4998 
  ;
  
#line 4999 
  i40e_vsi_free_tx_resources(vsi);
  
#line 5000 
  if (*(pf->vsi + (int)pf->lan_vsi) == vsi) 
#line 5001 
                                            i40e_do_reset(pf,4096U); else ;
  
#line 5003 
  __retres = err;
  return_label: 
#line 5003 
                return __retres;
}


#line 5013  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_filter_exit(struct i40e_pf *pf)
{
  struct i40e_fdir_filter *filter;
  struct hlist_node *node2;
  struct i40e_fdir_filter *tmp_1;
  struct i40e_fdir_filter *tmp_4;
  {
    struct i40e_fdir_filter *tmp_0;
    
#line 5018 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    
#line 5018 
    if (____ptr != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp;
      {
        
#line 5018 
        struct hlist_node const *__mptr = (struct hlist_node const *)____ptr;
        
#line 5018 
        tmp = (struct i40e_fdir_filter *)__mptr;
      }
      
#line 5018 
      tmp_0 = tmp;
    }
    else 
#line 5018 
         tmp_0 = (struct i40e_fdir_filter *)0;
    
#line 5018 
    tmp_1 = tmp_0;
  }
  
#line 5018 
  filter = tmp_1;
  
#line 5018 
  goto ldv_63084;
  ldv_63083: 
#line 5019 
  ;
  
#line 5020 
  hlist_del(& filter->fdir_node);
  
#line 5021 
  kfree((void const *)filter);
  {
    struct i40e_fdir_filter *tmp_3;
    
#line 5018 
    struct hlist_node *____ptr_0 = node2;
    
#line 5018 
    if (____ptr_0 != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp_2;
      {
        
#line 5018 
        struct hlist_node const *__mptr_0 = (struct hlist_node const *)____ptr_0;
        
#line 5018 
        tmp_2 = (struct i40e_fdir_filter *)__mptr_0;
      }
      
#line 5018 
      tmp_3 = tmp_2;
    }
    else 
#line 5018 
         tmp_3 = (struct i40e_fdir_filter *)0;
    
#line 5018 
    tmp_4 = tmp_3;
  }
  
#line 5018 
  filter = tmp_4;
  ldv_63084: 
#line 5020 
  ;
  
#line 5018 
  if (filter != (struct i40e_fdir_filter *)0) {
    
#line 5018 
    node2 = filter->fdir_node.next;
    
#line 5018 
    if (1 != 0) 
#line 5020 
                goto ldv_63083; else 
#line 5023 
                                     goto ldv_63085;
  }
  else 
#line 5023 
       goto ldv_63085;
  ldv_63085: 
#line 5024 
  ;
  
#line 5023 
  pf->fdir_pf_active_filters = (unsigned short)0U;
  
#line 5024 
  return;
}


#line 5037  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_close(struct net_device *netdev)
{
  int __retres;
  
#line 5042 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 5043 
  struct i40e_vsi *vsi = np->vsi;
  
#line 5045 
  i40e_vsi_close(vsi);
  
#line 5047 
  __retres = 0;
  
#line 5047 
  return __retres;
}


#line 5059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_do_reset(struct i40e_pf *pf, u32 reset_flags)
{
  u32 val;
  bool tmp_0;
  {
    int tmp;
    
#line 5063 
    tmp = preempt_count();
    
#line 5063 
    int __ret_warn_on = ((unsigned long)tmp & 2096896UL) != 0UL;
    
#line 5063 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 5063 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c",5063); else ;
    
#line 5063 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 5065 
  tmp_0 = i40e_check_asq_alive(& pf->hw);
  
#line 5065 
  if ((int)tmp_0 != 0) 
#line 5066 
                       i40e_vc_notify_reset(pf); else ;
  
#line 5069 
  if ((reset_flags & 16384U) != 0U) {
    {
      
#line 5079 
      struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_do_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "GlobalR requested\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5079U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 5079 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 5079 
                                                          __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"GlobalR requested\n"); else ;
    }
    
#line 5080 
    val = readl((void const volatile *)(pf->hw.hw_addr + 754064U));
    
#line 5081 
    val |= 2U;
    
#line 5082 
    writel(val,(void volatile *)(pf->hw.hw_addr + 754064U));
  }
  else 
    
#line 5084 
    if ((reset_flags & 8192U) != 0U) {
      {
        
#line 5090 
        struct _ddebug descriptor_0 = {.modname = "i40e", .function = "i40e_do_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "CoreR requested\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5090U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 5090 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 5090 
                                                              __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (pf->pdev)->dev),"CoreR requested\n"); else ;
      }
      
#line 5091 
      val = readl((void const volatile *)(pf->hw.hw_addr + 754064U));
      
#line 5092 
      val |= 1U;
      
#line 5093 
      writel(val,(void volatile *)(pf->hw.hw_addr + 754064U));
      
#line 5094 
      readl((void const volatile *)(pf->hw.hw_addr + 745772U));
    }
    else 
      
#line 5096 
      if ((reset_flags & 4096U) != 0U) {
        {
          
#line 5106 
          struct _ddebug descriptor_1 = {.modname = "i40e", .function = "i40e_do_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "PFR requested\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5106U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 5106 
          if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 5106 
                                                                __dynamic_dev_dbg(& descriptor_1,(struct device const *)(& (pf->pdev)->dev),"PFR requested\n"); else ;
        }
        
#line 5107 
        i40e_handle_reset_warning(pf);
      }
      else 
        
#line 5109 
        if ((reset_flags & 2048U) != 0U) {
          int v;
          
#line 5113 
          _dev_info((struct device const *)(& (pf->pdev)->dev),"VSI reinit requested\n");
          
#line 5115 
          v = 0;
          
#line 5115 
          goto ldv_63105;
          ldv_63104: 
#line 5116 
          ;
          {
            
#line 5116 
            struct i40e_vsi *vsi = *(pf->vsi + v);
            
#line 5117 
            if (vsi != (struct i40e_vsi *)0) {
              int tmp_1;
              
#line 5117 
              tmp_1 = constant_test_bit(11L,(unsigned long const volatile *)(& vsi->state));
              
#line 5117 
              if (tmp_1 != 0) {
                
#line 5119 
                i40e_vsi_reinit_locked(*(pf->vsi + v));
                
#line 5120 
                clear_bit(11L,(unsigned long volatile *)(& vsi->state));
              }
              else ;
            }
            else ;
          }
          
#line 5115 
          v += 1;
          ldv_63105: 
#line 5116 
          ;
          
#line 5115 
          if ((int)pf->num_alloc_vsi > v) 
#line 5117 
                                          goto ldv_63104; else 
#line 5120 
                                                               goto ldv_63106;
          ldv_63106: 
#line 5121 
          ;
          
#line 5125 
          goto return_label;
        }
        else 
          
#line 5126 
          if ((reset_flags & 2097152U) != 0U) {
            int v_0;
            
#line 5130 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"VSI down requested\n");
            
#line 5131 
            v_0 = 0;
            
#line 5131 
            goto ldv_63110;
            ldv_63109: 
#line 5132 
            ;
            {
              
#line 5132 
              struct i40e_vsi *vsi_0 = *(pf->vsi + v_0);
              
#line 5133 
              if (vsi_0 != (struct i40e_vsi *)0) {
                int tmp_2_0;
                
#line 5133 
                tmp_2_0 = constant_test_bit(21L,(unsigned long const volatile *)(& vsi_0->state));
                
#line 5133 
                if (tmp_2_0 != 0) {
                  
#line 5135 
                  clear_bit(3L,(unsigned long volatile *)(& vsi_0->state));
                  
#line 5136 
                  i40e_down(vsi_0);
                  
#line 5137 
                  clear_bit(21L,(unsigned long volatile *)(& vsi_0->state));
                }
                else ;
              }
              else ;
            }
            
#line 5131 
            v_0 += 1;
            ldv_63110: 
#line 5132 
            ;
            
#line 5131 
            if ((int)pf->num_alloc_vsi > v_0) 
#line 5133 
                                              goto ldv_63109; else 
#line 5136 
                                                                   goto ldv_63111;
            ldv_63111: 
#line 5137 
            ;
            
#line 5142 
            goto return_label;
          }
          else {
            
#line 5144 
            _dev_info((struct device const *)(& (pf->pdev)->dev),"bad reset request 0x%08x\n",reset_flags);
            
#line 5146 
            goto return_label;
          }
  return_label: 
#line 5148 
                return;
}


#line 5157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
bool i40e_dcb_need_reconfig(struct i40e_pf *pf, struct i40e_dcbx_config *old_cfg, struct i40e_dcbx_config *new_cfg)
{
  int tmp_2;
  int tmp_3;
  int tmp_4;
  
#line 5161 
  bool need_reconfig = (_Bool)0;
  
#line 5164 
  tmp_2 = memcmp((void const *)(& new_cfg->etscfg),(void const *)(& old_cfg->etscfg),27UL);
  
#line 5164 
  if (tmp_2 != 0) {
    int tmp;
    int tmp_0;
    int tmp_1;
    
#line 5168 
    tmp = memcmp((void const *)(& new_cfg->etscfg.prioritytable),(void const *)(& old_cfg->etscfg.prioritytable),8UL);
    
#line 5168 
    if (tmp != 0) {
      
#line 5171 
      need_reconfig = (_Bool)1;
      {
        
#line 5172 
        struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_dcb_need_reconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "ETS UP2TC changed.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5172U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 5172 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 5172 
                                                            __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"ETS UP2TC changed.\n"); else ;
      }
    }
    else ;
    
#line 5175 
    tmp_0 = memcmp((void const *)(& new_cfg->etscfg.tcbwtable),(void const *)(& old_cfg->etscfg.tcbwtable),8UL);
    
#line 5175 
    if (tmp_0 != 0) {
      
#line 5178 
      struct _ddebug descriptor_0 = {.modname = "i40e", .function = "i40e_dcb_need_reconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "ETS TC BW Table changed.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5178U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 5178 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 5178 
                                                            __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (pf->pdev)->dev),"ETS TC BW Table changed.\n"); else ;
    }
    else ;
    
#line 5180 
    tmp_1 = memcmp((void const *)(& new_cfg->etscfg.tsatable),(void const *)(& old_cfg->etscfg.tsatable),8UL);
    
#line 5180 
    if (tmp_1 != 0) {
      
#line 5183 
      struct _ddebug descriptor_1 = {.modname = "i40e", .function = "i40e_dcb_need_reconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "ETS TSA Table changed.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5183U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 5183 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 5183 
                                                            __dynamic_dev_dbg(& descriptor_1,(struct device const *)(& (pf->pdev)->dev),"ETS TSA Table changed.\n"); else ;
    }
    else ;
  }
  else ;
  
#line 5187 
  tmp_3 = memcmp((void const *)(& new_cfg->pfc),(void const *)(& old_cfg->pfc),4UL);
  
#line 5187 
  if (tmp_3 != 0) {
    
#line 5190 
    need_reconfig = (_Bool)1;
    {
      
#line 5191 
      struct _ddebug descriptor_2 = {.modname = "i40e", .function = "i40e_dcb_need_reconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "PFC config change detected.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5191U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 5191 
      if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) 
#line 5191 
                                                            __dynamic_dev_dbg(& descriptor_2,(struct device const *)(& (pf->pdev)->dev),"PFC config change detected.\n"); else ;
    }
  }
  else ;
  
#line 5195 
  tmp_4 = memcmp((void const *)(& new_cfg->app),(void const *)(& old_cfg->app),128UL);
  
#line 5195 
  if (tmp_4 != 0) {
    
#line 5198 
    need_reconfig = (_Bool)1;
    {
      
#line 5199 
      struct _ddebug descriptor_3 = {.modname = "i40e", .function = "i40e_dcb_need_reconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "APP Table change detected.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5199U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 5199 
      if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) 
#line 5199 
                                                            __dynamic_dev_dbg(& descriptor_3,(struct device const *)(& (pf->pdev)->dev),"APP Table change detected.\n"); else ;
    }
  }
  else ;
  {
    
#line 5202 
    struct _ddebug descriptor_4 = {.modname = "i40e", .function = "i40e_dcb_need_reconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "%s: need_reconfig=%d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5203U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 5202 
    if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) 
#line 5202 
                                                          __dynamic_dev_dbg(& descriptor_4,(struct device const *)(& (pf->pdev)->dev),"%s: need_reconfig=%d\n","i40e_dcb_need_reconfig",(int)need_reconfig); else ;
  }
  
#line 5204 
  return need_reconfig;
}


#line 5212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_handle_lldp_event(struct i40e_pf *pf, struct i40e_arq_event_info *e)
{
  int __retres;
  struct i40e_dcbx_config tmp_dcbx_cfg;
  u8 type;
  i40e_status tmp_1;
  int tmp_2;
  u8 tmp_3;
  
#line 5215 
  struct i40e_aqc_lldp_get_mib *mib = (struct i40e_aqc_lldp_get_mib *)(& e->desc.params.raw);
  
#line 5217 
  struct i40e_hw *hw = & pf->hw;
  
#line 5219 
  bool need_reconfig = (_Bool)0;
  
#line 5220 
  int ret = 0;
  
#line 5224 
  if ((pf->flags & 536870912ULL) == 0ULL) {
    
#line 5225 
    __retres = ret;
    
#line 5225 
    goto return_label;
  }
  else ;
  
#line 5228 
  type = (unsigned char)((unsigned int)((unsigned char)((int)mib->type >> 2)) & 12U);
  {
    
#line 5230 
    struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_handle_lldp_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "%s: LLDP event mib bridge type 0x%x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5231U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 5230 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 5230 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"%s: LLDP event mib bridge type 0x%x\n","i40e_handle_lldp_event",(int)type); else ;
  }
  
#line 5232 
  if ((unsigned int)type != 0U) {
    
#line 5233 
    __retres = ret;
    
#line 5233 
    goto return_label;
  }
  else ;
  
#line 5236 
  type = (unsigned char)((unsigned int)mib->type & 3U);
  {
    
#line 5237 
    struct _ddebug descriptor_0 = {.modname = "i40e", .function = "i40e_handle_lldp_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "%s: LLDP event mib type %s\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5239U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 5237 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      char *tmp;
      
#line 5237 
      if ((unsigned int)type != 0U) 
#line 5237 
                                    tmp = (char *)"remote"; else 
#line 5237 
                                                                 tmp = (char *)"local";
      
#line 5237 
      ;
      
#line 5237 
      __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (pf->pdev)->dev),"%s: LLDP event mib type %s\n","i40e_handle_lldp_event",tmp);
    }
    else ;
  }
  
#line 5240 
  if ((unsigned int)type == 1U) {
    i40e_status tmp_0;
    
#line 5242 
    tmp_0 = i40e_aq_get_dcb_config(hw,(unsigned char)1,(unsigned char)0,& hw->remote_dcbx_config);
    
#line 5242 
    ret = (int)tmp_0;
    
#line 5245 
    goto exit;
  }
  else ;
  
#line 5249 
  tmp_dcbx_cfg = hw->local_dcbx_config;
  
#line 5252 
  memset((void *)(& hw->local_dcbx_config),0,196UL);
  
#line 5254 
  tmp_1 = i40e_get_dcb_config(& pf->hw);
  
#line 5254 
  ret = (int)tmp_1;
  
#line 5255 
  if (ret != 0) {
    
#line 5256 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Failed querying DCB configuration data from firmware.\n");
    
#line 5257 
    goto exit;
  }
  else ;
  
#line 5261 
  tmp_2 = memcmp((void const *)(& tmp_dcbx_cfg),(void const *)(& hw->local_dcbx_config),196UL);
  
#line 5261 
  if (tmp_2 == 0) {
    {
      
#line 5263 
      struct _ddebug descriptor_1 = {.modname = "i40e", .function = "i40e_handle_lldp_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "No change detected in DCBX configuration.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5263U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 5263 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 5263 
                                                            __dynamic_dev_dbg(& descriptor_1,(struct device const *)(& (pf->pdev)->dev),"No change detected in DCBX configuration.\n"); else ;
    }
    
#line 5264 
    goto exit;
  }
  else ;
  
#line 5267 
  need_reconfig = i40e_dcb_need_reconfig(pf,& tmp_dcbx_cfg,& hw->local_dcbx_config);
  
#line 5270 
  i40e_dcbnl_flush_apps(pf,& tmp_dcbx_cfg,& hw->local_dcbx_config);
  
#line 5272 
  if (! need_reconfig) 
#line 5273 
                       goto exit; else ;
  
#line 5276 
  tmp_3 = i40e_dcb_get_num_tc(& hw->local_dcbx_config);
  
#line 5276 
  if ((unsigned int)tmp_3 > 1U) 
#line 5277 
                                pf->flags |= 1048576ULL; else 
#line 5279 
                                                              pf->flags &= 18446744073708503039ULL;
  
#line 5281 
  clear_bit(24L,(unsigned long volatile *)(& pf->state));
  
#line 5283 
  i40e_pf_quiesce_all_vsi(pf);
  
#line 5286 
  i40e_dcb_reconfigure(pf);
  
#line 5288 
  ret = i40e_resume_port_tx(pf);
  
#line 5290 
  clear_bit(24L,(unsigned long volatile *)(& pf->state));
  
#line 5292 
  if (ret != 0) 
#line 5293 
                goto exit; else ;
  
#line 5296 
  ret = i40e_pf_wait_txq_disabled(pf);
  
#line 5297 
  if (ret != 0) {
    
#line 5299 
    clear_bit(12L,(unsigned long volatile *)(& pf->state));
    
#line 5300 
    i40e_service_event_schedule(pf);
  }
  else 
#line 5302 
       i40e_pf_unquiesce_all_vsi(pf);
  exit: 
#line 5305 
  ;
  
#line 5306 
  __retres = ret;
  return_label: 
#line 5306 
                return __retres;
}


#line 5316  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_do_reset_safe(struct i40e_pf *pf, u32 reset_flags)
{
  
#line 5318 
  rtnl_lock();
  
#line 5319 
  i40e_do_reset(pf,reset_flags);
  
#line 5320 
  rtnl_unlock();
  
#line 5321 
  return;
}


#line 5331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_handle_lan_overflow_event(struct i40e_pf *pf, struct i40e_arq_event_info *e)
{
  struct i40e_vf *vf;
  u16 vf_id;
  
#line 5334 
  struct i40e_aqc_lan_overflow *data = (struct i40e_aqc_lan_overflow *)(& e->desc.params.raw);
  
#line 5336 
  u32 queue = data->prtdcb_rupto;
  
#line 5337 
  u32 qtx_ctl = data->otx_ctl;
  
#line 5338 
  struct i40e_hw *hw = & pf->hw;
  {
    
#line 5342 
    struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_handle_lan_overflow_event", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "overflow Rx Queue Number = %d QTX_CTL=0x%08x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5343U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 5342 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 5342 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"overflow Rx Queue Number = %d QTX_CTL=0x%08x\n",queue,qtx_ctl); else ;
  }
  
#line 5346 
  if ((qtx_ctl & 3U) == 0U) {
    
#line 5348 
    vf_id = (unsigned short)((unsigned int)((unsigned short)(qtx_ctl >> 7)) & 511U);
    
#line 5350 
    vf_id = (unsigned short)((int)vf_id - (int)((unsigned short)hw->func_caps.vf_base_id));
    
#line 5351 
    vf = pf->vf + (int)vf_id;
    
#line 5352 
    i40e_vc_notify_vf_reset(vf);
    
#line 5354 
    msleep(20U);
    
#line 5355 
    i40e_reset_vf(vf,(_Bool)0);
  }
  else ;
  
#line 5357 
  return;
}


#line 5363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_service_event_complete(struct i40e_pf *pf)
{
  int tmp;
  
#line 5365 
  tmp = constant_test_bit(5L,(unsigned long const volatile *)(& pf->state));
  
#line 5365 
  if ((long)(tmp == 0) != 0L) {
    
#line 5367 
    ldv_inline_asm();
    
#line 5365 
    ;
  }
  else ;
  
#line 5367 
  ldv_inline_asm();
  
#line 5369 
  clear_bit(5L,(unsigned long volatile *)(& pf->state));
  
#line 5370 
  return;
}


#line 5376  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_cur_guaranteed_fd_count(struct i40e_pf *pf)
{
  u32 val;
  u32 fcnt_prog;
  
#line 5380 
  val = readl((void const volatile *)(pf->hw.hw_addr + 2384768U));
  
#line 5381 
  fcnt_prog = val & 8191U;
  
#line 5382 
  return fcnt_prog;
}


#line 5389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_current_fd_count(struct i40e_pf *pf)
{
  u32 val;
  u32 fcnt_prog;
  
#line 5393 
  val = readl((void const volatile *)(pf->hw.hw_addr + 2384768U));
  
#line 5394 
  fcnt_prog = (val & 8191U) + ((val >> 16) & 8191U);
  
#line 5397 
  return fcnt_prog;
}


#line 5404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_global_fd_count(struct i40e_pf *pf)
{
  u32 val;
  u32 fcnt_prog;
  
#line 5408 
  val = readl((void const volatile *)(pf->hw.hw_addr + 2530220U));
  
#line 5409 
  fcnt_prog = (val & 8191U) + ((val >> 13) & 8191U);
  
#line 5412 
  return fcnt_prog;
}


#line 5419  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_fdir_check_and_reenable(struct i40e_pf *pf)
{
  u32 fcnt_prog;
  u32 fcnt_avail;
  int tmp;
  
#line 5423 
  tmp = constant_test_bit(22L,(unsigned long const volatile *)(& pf->state));
  
#line 5423 
  if (tmp != 0) 
#line 5424 
                goto return_label; else ;
  
#line 5429 
  fcnt_prog = i40e_get_global_fd_count(pf);
  
#line 5430 
  fcnt_avail = (unsigned int)pf->fdir_pf_filter_count;
  
#line 5431 
  if (fcnt_avail + 4294967264U > fcnt_prog || pf->fd_add_err == 0U) 
#line 5431 
                                                                    goto _LOR;
  else {
    u32 tmp_0;
    
#line 5432 
    tmp_0 = i40e_get_current_atr_cnt(pf);
    
#line 5432 
    ;
    
#line 5432 
    if (tmp_0 < pf->fd_atr_cnt) {
      _LOR: 
#line 5434 
            if ((pf->flags & 2097152ULL) != 0ULL && (pf->auto_disable_flags & 2097152ULL) != 0ULL) {
              
#line 5436 
              pf->auto_disable_flags &= 18446744073707454463ULL;
              
#line 5437 
              if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 5438 
                                                     _dev_info((struct device const *)(& (pf->pdev)->dev),"FD Sideband/ntuple is being enabled since we have space in the table now\n"); else ;
            }
            else ;
    }
    else ;
  }
  
#line 5442 
  if (fcnt_avail + 4294967232U > fcnt_prog) {
    
#line 5443 
    if ((pf->flags & 4194304ULL) != 0ULL && (pf->auto_disable_flags & 4194304ULL) != 0ULL) {
      
#line 5445 
      pf->auto_disable_flags &= 18446744073705357311ULL;
      
#line 5446 
      if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 5447 
                                             _dev_info((struct device const *)(& (pf->pdev)->dev),"ATR is being enabled since we have space in the table now\n"); else ;
    }
    else ;
  }
  else ;
  return_label: 
#line 5449 
                return;
}


#line 5458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_flush_and_replay(struct i40e_pf *pf)
{
  unsigned long min_flush_time;
  int fd_room;
  int reg;
  int tmp_3;
  
#line 5461 
  int flush_wait_retry = 50;
  
#line 5462 
  bool disable_atr = (_Bool)0;
  
#line 5466 
  if ((pf->flags & 6291456ULL) == 0ULL) 
#line 5467 
                                        goto return_label; else ;
  {
    unsigned long __dummy_1;
    unsigned long volatile __dummy2_1;
    
#line 5469 
    tmp_3 = 1;
  }
  
#line 5469 
  if (tmp_3 != 0) {
    int tmp_4;
    {
      unsigned long __dummy_2;
      unsigned long __dummy2_2;
      
#line 5469 
      tmp_4 = 1;
    }
    
#line 5469 
    if (tmp_4 != 0) {
      
#line 5469 
      if ((long)((pf->fd_flush_timestamp - jiffies) + 2500UL) < 0L) {
        int tmp;
        unsigned int tmp_1;
        int tmp_2;
        
#line 5474 
        min_flush_time = pf->fd_flush_timestamp + 7500UL;
        
#line 5476 
        fd_room = (int)pf->fdir_pf_filter_count - (int)pf->fdir_pf_active_filters;
        {
          unsigned long __dummy;
          unsigned long volatile __dummy2;
          
#line 5478 
          tmp = 1;
        }
        
#line 5478 
        if (tmp == 0) 
#line 5478 
                      goto _LOR;
        else {
          int tmp_0;
          {
            unsigned long __dummy_0;
            unsigned long __dummy2_0;
            
#line 5478 
            tmp_0 = 1;
          }
          
#line 5478 
          if (tmp_0 == 0) 
#line 5478 
                          goto _LOR;
          else 
            
#line 5478 
            if ((long)(min_flush_time - jiffies) >= 0L) {
              _LOR: 
#line 5478 
              ;
              
#line 5478 
              if (fd_room <= 127) {
                
#line 5480 
                if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 5481 
                                                       _dev_info((struct device const *)(& (pf->pdev)->dev),"ATR disabled, not enough FD filter space.\n"); else ;
                
#line 5482 
                disable_atr = (_Bool)1;
              }
              else ;
            }
            else ;
        }
        
#line 5485 
        pf->fd_flush_timestamp = jiffies;
        
#line 5486 
        pf->flags &= 18446744073705357311ULL;
        
#line 5488 
        writel(1U,(void volatile *)(pf->hw.hw_addr + 2383232U));
        
#line 5490 
        readl((void const volatile *)(pf->hw.hw_addr + 745772U));
        
#line 5491 
        pf->fd_flush_cnt += 1U;
        
#line 5492 
        pf->fd_add_err = 0U;
        ldv_63200: 
#line 5493 
        ;
        
#line 5495 
        usleep_range(5000UL,6000UL);
        
#line 5496 
        tmp_1 = readl((void const volatile *)(pf->hw.hw_addr + 2383232U));
        
#line 5496 
        reg = (int)tmp_1;
        
#line 5497 
        if ((reg & 1) == 0) 
#line 5498 
                            goto ldv_63199; else ;
        
#line 5499 
        tmp_2 = flush_wait_retry;
        
#line 5499 
        flush_wait_retry -= 1;
        
#line 5499 
        ;
        
#line 5499 
        if (tmp_2 != 0) 
#line 5501 
                        goto ldv_63200; else 
#line 5504 
                                             goto ldv_63199;
        ldv_63199: 
#line 5505 
        ;
        
#line 5500 
        if ((reg & 1) != 0) 
#line 5501 
                            dev_warn((struct device const *)(& (pf->pdev)->dev),"FD table did not flush, needs more time\n");
        else {
          
#line 5504 
          i40e_fdir_filter_restore(*(pf->vsi + (int)pf->lan_vsi));
          
#line 5505 
          if (! disable_atr) 
#line 5506 
                             pf->flags |= 4194304ULL; else ;
          
#line 5507 
          clear_bit(22L,(unsigned long volatile *)(& pf->state));
          
#line 5508 
          if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 5509 
                                                 _dev_info((struct device const *)(& (pf->pdev)->dev),"FD Filter table flushed and FD-SB replayed.\n"); else ;
        }
      }
      else ;
    }
    else ;
  }
  else ;
  return_label: 
#line 5512 
                return;
}


#line 5518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_current_atr_cnt(struct i40e_pf *pf)
{
  u32 __retres;
  u32 tmp;
  
#line 5520 
  tmp = i40e_get_current_fd_count(pf);
  
#line 5520 
  ;
  
#line 5520 
  __retres = tmp - (unsigned int)pf->fdir_pf_active_filters;
  
#line 5520 
  return __retres;
}


#line 5534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_reinit_subtask(struct i40e_pf *pf)
{
  int tmp;
  int tmp_0;
  
#line 5538 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 5538 
  if (tmp != 0) 
#line 5539 
                goto return_label; else ;
  
#line 5541 
  if ((pf->flags & 6291456ULL) == 0ULL) 
#line 5542 
                                        goto return_label; else ;
  
#line 5544 
  tmp_0 = constant_test_bit(22L,(unsigned long const volatile *)(& pf->state));
  
#line 5544 
  if (tmp_0 != 0) 
#line 5545 
                  i40e_fdir_flush_and_replay(pf); else ;
  
#line 5547 
  i40e_fdir_check_and_reenable(pf);
  return_label: 
#line 5548 
                return;
}


#line 5556  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_link_event(struct i40e_vsi *vsi, bool link_up)
{
  
#line 5558 
  if (vsi == (struct i40e_vsi *)0) 
#line 5559 
                                   goto return_label;
  else {
    int tmp;
    
#line 5558 
    tmp = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
    
#line 5558 
    if (tmp != 0) 
#line 5559 
                  goto return_label; else ;
  }
  
#line 5561 
  switch ((unsigned int)vsi->type) {
    case (unsigned int)0: 
#line 5562 
    ;
    case (unsigned int)4: 
#line 5564 
    ;
    
#line 5566 
    if (vsi->netdev == (struct net_device *)0 || ! vsi->netdev_registered) 
      
#line 5567 
      goto ldv_63213; else ;
    
#line 5569 
    if ((int)link_up != 0) {
      
#line 5570 
      netif_carrier_on(vsi->netdev);
      
#line 5571 
      netif_tx_wake_all_queues(vsi->netdev);
    }
    else {
      
#line 5573 
      netif_carrier_off(vsi->netdev);
      
#line 5574 
      netif_tx_stop_all_queues(vsi->netdev);
    }
    
#line 5576 
    goto ldv_63213;
    case (unsigned int)6: 
#line 5578 
    ;
    case (unsigned int)2: 
#line 5579 
    ;
    case (unsigned int)3: 
#line 5580 
    ;
    case (unsigned int)5: 
#line 5581 
    ;
    default: 
#line 5582 
    ;
    
#line 5584 
    goto ldv_63213;
  }
  ldv_63213: 
#line 5586 
  ;
  return_label: 
#line 5587 
                return;
}


#line 5593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_veb_link_event(struct i40e_veb *veb, bool link_up)
{
  struct i40e_pf *pf;
  int i;
  
#line 5598 
  if (veb == (struct i40e_veb *)0 || veb->pf == (struct i40e_pf *)0) 
    
#line 5599 
    goto return_label; else ;
  
#line 5600 
  pf = veb->pf;
  
#line 5603 
  i = 0;
  
#line 5603 
  goto ldv_63226;
  ldv_63225: 
#line 5604 
  ;
  
#line 5604 
  if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->uplink_seid == (int)veb->seid) 
    
#line 5605 
    i40e_veb_link_event(pf->veb[i],(_Bool)((bool)((int)link_up) != 0)); else ;
  
#line 5603 
  i += 1;
  ldv_63226: 
#line 5604 
  ;
  
#line 5603 
  if (i <= 15) 
#line 5605 
               goto ldv_63225; else 
#line 5608 
                                    goto ldv_63227;
  ldv_63227: 
#line 5609 
  ;
  
#line 5608 
  i = 0;
  
#line 5608 
  goto ldv_63229;
  ldv_63228: 
#line 5609 
  ;
  
#line 5609 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + i))->uplink_seid == (int)veb->seid) 
    
#line 5610 
    i40e_vsi_link_event(*(pf->vsi + i),(_Bool)((bool)((int)link_up) != 0)); else ;
  
#line 5608 
  i += 1;
  ldv_63229: 
#line 5609 
  ;
  
#line 5608 
  if ((int)pf->num_alloc_vsi > i) 
#line 5610 
                                  goto ldv_63228; else 
#line 5613 
                                                       goto ldv_63230;
  ldv_63230: 
#line 5614 
  ;
  return_label: 
#line 5615 
                return;
}


#line 5617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_link_event(struct i40e_pf *pf)
{
  bool new_link;
  bool old_link;
  u8 new_link_speed;
  u8 old_link_speed;
  int tmp_1;
  
#line 5620 
  struct i40e_vsi *vsi = *(pf->vsi + (int)pf->lan_vsi);
  
#line 5624 
  pf->hw.phy.get_link_info = (_Bool)1;
  
#line 5626 
  old_link = (_Bool)(((int)pf->hw.phy.link_info_old.link_info & 1) != 0);
  
#line 5627 
  new_link = i40e_get_link_status(& pf->hw);
  
#line 5628 
  old_link_speed = (unsigned char)pf->hw.phy.link_info_old.link_speed;
  
#line 5629 
  new_link_speed = (unsigned char)pf->hw.phy.link_info.link_speed;
  
#line 5631 
  if ((int)new_link == (int)old_link && (int)new_link_speed == (int)old_link_speed) {
    int tmp;
    
#line 5632 
    tmp = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
    
#line 5632 
    if (tmp != 0) 
#line 5635 
                  goto return_label;
    else {
      bool tmp_0;
      
#line 5633 
      tmp_0 = netif_carrier_ok((struct net_device const *)vsi->netdev);
      
#line 5633 
      ;
      
#line 5633 
      if ((int)tmp_0 == (int)new_link) 
#line 5635 
                                       goto return_label; else ;
    }
  }
  else ;
  
#line 5637 
  tmp_1 = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
  
#line 5637 
  if (tmp_1 == 0) 
#line 5638 
                  i40e_print_link_message(vsi,(_Bool)((bool)((int)new_link) != 0)); else ;
  
#line 5643 
  if ((unsigned int)pf->lan_veb != 65535U && pf->veb[(int)pf->lan_veb] != (struct i40e_veb *)0) 
    
#line 5644 
    i40e_veb_link_event(pf->veb[(int)pf->lan_veb],(_Bool)((bool)((int)new_link) != 0)); else 
                                                                    
#line 5646 
                                                                    i40e_vsi_link_event(vsi,(_Bool)((bool)((int)new_link) != 0));
  
#line 5648 
  if (pf->vf != (struct i40e_vf *)0) 
#line 5649 
                                     i40e_vc_notify_link_state(pf); else ;
  
#line 5651 
  if ((pf->flags & 33554432ULL) != 0ULL) 
#line 5652 
                                         i40e_ptp_set_increment(pf); else ;
  return_label: 
#line 5653 
                return;
}


#line 5662  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_check_hang_subtask(struct i40e_pf *pf)
{
  int i;
  int v;
  int tmp;
  
#line 5667 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 5667 
  if (tmp != 0) 
#line 5669 
                goto return_label;
  else {
    int tmp_0;
    
#line 5667 
    tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& pf->state));
    
#line 5667 
    if (tmp_0 != 0) 
#line 5669 
                    goto return_label; else ;
  }
  
#line 5677 
  v = 0;
  
#line 5677 
  goto ldv_63256;
  ldv_63255: 
#line 5678 
  ;
  {
    int tmp_4;
    
#line 5678 
    struct i40e_vsi *vsi = *(pf->vsi + v);
    
#line 5679 
    int armed = 0;
    
#line 5681 
    if (*(pf->vsi + v) == (struct i40e_vsi *)0) 
#line 5681 
                                                goto _LOR;
    else {
      int tmp_1;
      
#line 5681 
      tmp_1 = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
      
#line 5681 
      if (tmp_1 != 0) 
#line 5681 
                      goto _LOR;
      else 
        
#line 5682 
        if (vsi->netdev != (struct net_device *)0) {
          int tmp_3;
          bool tmp_2;
          
#line 5683 
          tmp_2 = netif_carrier_ok((struct net_device const *)vsi->netdev);
          
#line 5683 
          if (tmp_2) 
#line 5683 
                     tmp_3 = 0; else 
#line 5683 
                                     tmp_3 = 1;
          
#line 5683 
          if (tmp_3) _LOR: 
#line 5684 
                           goto ldv_63246; else ;
        }
        else ;
    }
    
#line 5686 
    i = 0;
    
#line 5686 
    goto ldv_63248;
    ldv_63247: 
#line 5687 
    ;
    
#line 5687 
    clear_bit(2L,(unsigned long volatile *)(& (*(vsi->tx_rings + i))->state));
    
#line 5688 
    tmp_4 = constant_test_bit(3L,(unsigned long const volatile *)(& (*(vsi->tx_rings + i))->state));
    
#line 5688 
    if (tmp_4 != 0) 
#line 5690 
                    armed += 1; else ;
    
#line 5686 
    i += 1;
    ldv_63248: 
#line 5687 
    ;
    
#line 5686 
    if ((int)vsi->num_queue_pairs > i) 
#line 5688 
                                       goto ldv_63247; else 
#line 5691 
                                                            goto ldv_63249;
    ldv_63249: 
#line 5692 
    ;
    
#line 5693 
    if (armed != 0) {
      
#line 5694 
      if ((pf->flags & 8ULL) == 0ULL) 
#line 5695 
                                      writel(117440541U,(void volatile *)((vsi->back)->hw.hw_addr + 230528U));
      else {
        
#line 5702 
        u16 vec = (unsigned short)((unsigned int)((unsigned short)vsi->base_vector) + 65535U);
        
#line 5703 
        u32 val = 117440541U;
        
#line 5708 
        i = 0;
        
#line 5708 
        goto ldv_63253;
        ldv_63252: 
#line 5709 
        ;
        
#line 5709 
        writel(val,(void volatile *)((vsi->back)->hw.hw_addr + ((int)vec + 53760) * 4));
        
#line 5708 
        i += 1;
        
#line 5708 
        vec = (u16)((int)vec + 1);
        ldv_63253: 
#line 5709 
        ;
        
#line 5708 
        if (vsi->num_q_vectors > i) 
#line 5710 
                                    goto ldv_63252; else 
#line 5713 
                                                         goto ldv_63254;
        ldv_63254: 
#line 5714 
        ;
      }
      
#line 5712 
      readl((void const volatile *)((vsi->back)->hw.hw_addr + 745772U));
    }
    else ;
  }
  ldv_63246: 
#line 5715 
  ;
  
#line 5677 
  v += 1;
  ldv_63256: 
#line 5678 
  ;
  
#line 5677 
  if ((int)pf->num_alloc_vsi > v) 
#line 5679 
                                  goto ldv_63255; else 
#line 5682 
                                                       goto ldv_63257;
  ldv_63257: 
#line 5683 
  ;
  return_label: 
#line 5684 
                return;
}


#line 5721  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_watchdog_subtask(struct i40e_pf *pf)
{
  int i;
  int tmp;
  int tmp_1;
  
#line 5726 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 5726 
  if (tmp != 0) 
#line 5728 
                goto return_label;
  else {
    int tmp_0;
    
#line 5726 
    tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& pf->state));
    
#line 5726 
    if (tmp_0 != 0) 
#line 5728 
                    goto return_label; else ;
  }
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
#line 5731 
    tmp_1 = 1;
  }
  
#line 5731 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_0;
      unsigned long volatile __dummy2_0;
      
#line 5731 
      tmp_2 = 1;
    }
    
#line 5731 
    if (tmp_2 != 0) {
      
#line 5731 
      if ((long)(jiffies - (pf->service_timer_previous + pf->service_timer_period)) < 0L) 
        
#line 5733 
        goto return_label; else ;
    }
    else ;
  }
  else ;
  
#line 5734 
  pf->service_timer_previous = jiffies;
  
#line 5736 
  i40e_check_hang_subtask(pf);
  
#line 5737 
  i40e_link_event(pf);
  
#line 5742 
  i = 0;
  
#line 5742 
  goto ldv_63269;
  ldv_63268: 
#line 5743 
  ;
  
#line 5743 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (*(pf->vsi + i))->netdev != (struct net_device *)0) 
    
#line 5744 
    i40e_update_stats(*(pf->vsi + i)); else ;
  
#line 5742 
  i += 1;
  ldv_63269: 
#line 5743 
  ;
  
#line 5742 
  if ((int)pf->num_alloc_vsi > i) 
#line 5744 
                                  goto ldv_63268; else 
#line 5747 
                                                       goto ldv_63270;
  ldv_63270: 
#line 5748 
  ;
  
#line 5747 
  i = 0;
  
#line 5747 
  goto ldv_63272;
  ldv_63271: 
#line 5748 
  ;
  
#line 5748 
  if (pf->veb[i] != (struct i40e_veb *)0) 
#line 5749 
                                          i40e_update_veb_stats(pf->veb[i]); else ;
  
#line 5747 
  i += 1;
  ldv_63272: 
#line 5748 
  ;
  
#line 5747 
  if (i <= 15) 
#line 5749 
               goto ldv_63271; else 
#line 5752 
                                    goto ldv_63273;
  ldv_63273: 
#line 5753 
  ;
  
#line 5751 
  i40e_ptp_rx_hang(*(pf->vsi + (int)pf->lan_vsi));
  return_label: 
#line 5752 
                return;
}


#line 5758  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reset_subtask(struct i40e_pf *pf)
{
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  
#line 5760 
  u32 reset_flags = 0U;
  
#line 5762 
  rtnl_lock();
  
#line 5763 
  tmp = constant_test_bit(11L,(unsigned long const volatile *)(& pf->state));
  
#line 5763 
  if (tmp != 0) {
    
#line 5764 
    reset_flags |= 2048U;
    
#line 5765 
    clear_bit(11L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 5767 
  tmp_0 = constant_test_bit(12L,(unsigned long const volatile *)(& pf->state));
  
#line 5767 
  if (tmp_0 != 0) {
    
#line 5768 
    reset_flags |= 4096U;
    
#line 5769 
    clear_bit(12L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 5771 
  tmp_1 = constant_test_bit(13L,(unsigned long const volatile *)(& pf->state));
  
#line 5771 
  if (tmp_1 != 0) {
    
#line 5772 
    reset_flags |= 8192U;
    
#line 5773 
    clear_bit(13L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 5775 
  tmp_2 = constant_test_bit(14L,(unsigned long const volatile *)(& pf->state));
  
#line 5775 
  if (tmp_2 != 0) {
    
#line 5776 
    reset_flags |= 16384U;
    
#line 5777 
    clear_bit(14L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 5779 
  tmp_3 = constant_test_bit(21L,(unsigned long const volatile *)(& pf->state));
  
#line 5779 
  if (tmp_3 != 0) {
    
#line 5780 
    reset_flags |= 2097152U;
    
#line 5781 
    clear_bit(21L,(unsigned long volatile *)(& pf->state));
  }
  else ;
  
#line 5787 
  tmp_4 = constant_test_bit(10L,(unsigned long const volatile *)(& pf->state));
  
#line 5787 
  if (tmp_4 != 0) {
    
#line 5788 
    i40e_handle_reset_warning(pf);
    
#line 5789 
    goto unlock;
  }
  else ;
  
#line 5793 
  if (reset_flags != 0U) {
    int tmp_5;
    
#line 5793 
    tmp_5 = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
    
#line 5793 
    if (tmp_5 == 0) {
      int tmp_6;
      
#line 5794 
      tmp_6 = constant_test_bit(1L,(unsigned long const volatile *)(& pf->state));
      
#line 5794 
      if (tmp_6 == 0) 
#line 5796 
                      i40e_do_reset(pf,reset_flags); else ;
    }
    else ;
  }
  else ;
  unlock: 
#line 5798 
  ;
  
#line 5799 
  rtnl_unlock();
  
#line 5800 
  return;
}


#line 5807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_handle_link_event(struct i40e_pf *pf, struct i40e_arq_event_info *e)
{
  
#line 5810 
  struct i40e_hw *hw = & pf->hw;
  
#line 5811 
  struct i40e_aqc_get_link_status *status = (struct i40e_aqc_get_link_status *)(& e->desc.params.raw);
  
#line 5815 
  hw->phy.link_info_old = hw->phy.link_info;
  
#line 5823 
  i40e_link_event(pf);
  
#line 5826 
  if ((((int)status->link_info & 64) != 0 && (int)status->an_info >= 0) && ((int)status->link_info & 1) == 0) 
    
#line 5829 
    dev_err((struct device const *)(& (pf->pdev)->dev),"The driver failed to link because an unqualified module was detected.\n"); else ;
  
#line 5831 
  return;
}


#line 5837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_clean_adminq_subtask(struct i40e_pf *pf)
{
  struct i40e_arq_event_info event;
  u16 pending;
  i40e_status ret;
  u16 opcode;
  u32 oldval;
  u32 val;
  int tmp;
  
#line 5840 
  struct i40e_hw *hw = & pf->hw;
  
#line 5841 
  u16 i = (unsigned short)0U;
  
#line 5848 
  tmp = constant_test_bit(23L,(unsigned long const volatile *)(& pf->state));
  
#line 5848 
  if (tmp != 0) 
#line 5849 
                goto return_label; else ;
  
#line 5852 
  val = readl((void const volatile *)(pf->hw.hw_addr + pf->hw.aq.arq.len));
  
#line 5853 
  oldval = val;
  
#line 5854 
  if ((val & 268435456U) != 0U) {
    
#line 5855 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ARQ VF Error detected\n");
    
#line 5856 
    val &= 4026531839U;
  }
  else ;
  
#line 5858 
  if ((val & 536870912U) != 0U) {
    
#line 5859 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ARQ Overflow Error detected\n");
    
#line 5860 
    val &= 3758096383U;
  }
  else ;
  
#line 5862 
  if ((val & 1073741824U) != 0U) {
    
#line 5863 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ARQ Critical Error detected\n");
    
#line 5864 
    val &= 3221225471U;
  }
  else ;
  
#line 5866 
  if (oldval != val) 
#line 5867 
                     writel(val,(void volatile *)(pf->hw.hw_addr + pf->hw.aq.arq.len)); else ;
  
#line 5869 
  val = readl((void const volatile *)(pf->hw.hw_addr + pf->hw.aq.asq.len));
  
#line 5870 
  oldval = val;
  
#line 5871 
  if ((val & 268435456U) != 0U) {
    
#line 5872 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ASQ VF Error detected\n");
    
#line 5873 
    val &= 4026531839U;
  }
  else ;
  
#line 5875 
  if ((val & 536870912U) != 0U) {
    
#line 5876 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ASQ Overflow Error detected\n");
    
#line 5877 
    val &= 3758096383U;
  }
  else ;
  
#line 5879 
  if ((val & 1073741824U) != 0U) {
    
#line 5880 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ASQ Critical Error detected\n");
    
#line 5881 
    val &= 3221225471U;
  }
  else ;
  
#line 5883 
  if (oldval != val) 
#line 5884 
                     writel(val,(void volatile *)(pf->hw.hw_addr + pf->hw.aq.asq.len)); else ;
  
#line 5886 
  event.buf_len = (unsigned short)4096U;
  
#line 5887 
  event.msg_buf = (u8 *)kzalloc_0((unsigned long)event.buf_len,208U);
  
#line 5888 
  if (event.msg_buf == (u8 *)0U) 
#line 5889 
                                 goto return_label; else ;
  ldv_63309: 
#line 5890 
  ;
  
#line 5892 
  ret = i40e_clean_arq_element(hw,& event,& pending);
  
#line 5893 
  if (ret == I40E_ERR_ADMIN_QUEUE_NO_WORK) 
#line 5894 
                                           goto ldv_63296;
  else 
    
#line 5895 
    if (ret != I40E_SUCCESS) {
      
#line 5896 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"ARQ event error %d\n",(int)ret);
      
#line 5897 
      goto ldv_63296;
    }
    else ;
  
#line 5900 
  opcode = event.desc.opcode;
  
#line 5901 
  switch ((int)opcode) {
    int tmp_1;
    int tmp_2;
    case 1543: 
#line 5903 
    ;
    
#line 5904 
    i40e_handle_link_event(pf,& event);
    
#line 5905 
    goto ldv_63298;
    case 2049: 
#line 5906 
    ;
    
#line 5907 
    tmp_1 = i40e_vc_process_vf_msg(pf,(unsigned short)((int)event.desc.retval),event.desc.cookie_high,event.desc.cookie_low,event.msg_buf,(unsigned short)((int)event.msg_len));
    
#line 5907 
    ret = (enum i40e_status_code)tmp_1;
    
#line 5913 
    goto ldv_63298;
    case 2561: 
#line 5914 
    ;
    {
      
#line 5915 
      struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_clean_adminq_subtask", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "ARQ: Update LLDP MIB event received\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5915U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 5915 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 5915 
                                                          __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"ARQ: Update LLDP MIB event received\n"); else ;
    }
    
#line 5917 
    rtnl_lock();
    
#line 5918 
    tmp_2 = i40e_handle_lldp_event(pf,& event);
    
#line 5918 
    ret = (enum i40e_status_code)tmp_2;
    
#line 5919 
    rtnl_unlock();
    
#line 5921 
    goto ldv_63298;
    case 4097: 
#line 5922 
    ;
    {
      
#line 5923 
      struct _ddebug descriptor_0 = {.modname = "i40e", .function = "i40e_clean_adminq_subtask", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "ARQ LAN queue overflow event received\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5923U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 5923 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 5923 
                                                            __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (pf->pdev)->dev),"ARQ LAN queue overflow event received\n"); else ;
    }
    
#line 5924 
    i40e_handle_lan_overflow_event(pf,& event);
    
#line 5925 
    goto ldv_63298;
    case 2051: 
#line 5926 
    ;
    
#line 5927 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ARQ: Msg from other pf\n");
    
#line 5928 
    goto ldv_63298;
    case 1794: 
#line 5929 
    ;
    case 1795: 
#line 5930 
    ;
    
#line 5931 
    if ((pf->hw.debug_mask & 128U) != 0U) 
#line 5931 
                                          printk("\001",(int)pf->hw.bus.device,(int)pf->hw.bus.func); else ;
    
#line 5932 
    goto ldv_63298;
    default: 
#line 5933 
    ;
    
#line 5934 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"ARQ Error: Unknown event 0x%04x received\n",(int)opcode);
    
#line 5937 
    goto ldv_63298;
  }
  ldv_63298: 
#line 5939 
  ;
  
#line 5939 
  if ((unsigned int)pending != 0U) {
    u16 tmp_3;
    
#line 5939 
    tmp_3 = i;
    
#line 5939 
    i = (u16)((int)i + 1);
    
#line 5939 
    ;
    
#line 5939 
    if ((int)tmp_3 < (int)pf->adminq_work_limit) 
#line 5941 
                                                 goto ldv_63309; else 
                                                                   
#line 5944 
                                                                   goto ldv_63296;
  }
  else 
#line 5944 
       goto ldv_63296;
  ldv_63296: 
#line 5945 
  ;
  
#line 5941 
  clear_bit(6L,(unsigned long volatile *)(& pf->state));
  
#line 5943 
  val = readl((void const volatile *)(hw->hw_addr + 231424U));
  
#line 5944 
  val |= 1073741824U;
  
#line 5945 
  writel(val,(void volatile *)(hw->hw_addr + 231424U));
  
#line 5946 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 5948 
  kfree((void const *)event.msg_buf);
  return_label: 
#line 5949 
                return;
}


#line 5955  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_verify_eeprom(struct i40e_pf *pf)
{
  int err;
  i40e_status tmp;
  
#line 5959 
  tmp = i40e_diag_eeprom_test(& pf->hw);
  
#line 5959 
  err = (int)tmp;
  
#line 5960 
  if (err != 0) {
    i40e_status tmp_0;
    
#line 5962 
    tmp_0 = i40e_diag_eeprom_test(& pf->hw);
    
#line 5962 
    err = (int)tmp_0;
    
#line 5963 
    if (err != 0) {
      
#line 5964 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"eeprom check failed (%d), Tx/Rx traffic disabled\n",err);
      
#line 5966 
      clear_bit(20L,(unsigned long volatile *)(& pf->state));
    }
    else ;
  }
  else ;
  
#line 5970 
  if (err == 0) {
    int tmp_1;
    
#line 5970 
    tmp_1 = constant_test_bit(20L,(unsigned long const volatile *)(& pf->state));
    
#line 5970 
    if (tmp_1 != 0) {
      
#line 5971 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"eeprom check passed, Tx/Rx traffic enabled\n");
      
#line 5972 
      clear_bit(20L,(unsigned long volatile *)(& pf->state));
    }
    else ;
  }
  else ;
  
#line 5974 
  return;
}


#line 5982  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_enable_pf_switch_lb(struct i40e_pf *pf)
{
  struct i40e_vsi_context ctxt;
  int aq_ret;
  i40e_status tmp;
  i40e_status tmp_0;
  
#line 5984 
  struct i40e_vsi *vsi = *(pf->vsi + (int)pf->lan_vsi);
  
#line 5988 
  ctxt.seid = pf->main_vsi_seid;
  
#line 5989 
  ctxt.pf_num = pf->hw.pf_id;
  
#line 5990 
  ctxt.vf_num = (unsigned char)0U;
  
#line 5991 
  tmp = i40e_aq_get_vsi_params(& pf->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 5991 
  aq_ret = (int)tmp;
  
#line 5992 
  if (aq_ret != 0) {
    
#line 5993 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%s couldn\'t get PF vsi config, err %d, aq_err %d\n","i40e_enable_pf_switch_lb",aq_ret,(unsigned int)pf->hw.aq.asq_last_status);
    
#line 5996 
    goto return_label;
  }
  else ;
  
#line 5998 
  ctxt.flags = (unsigned short)2U;
  
#line 5999 
  ctxt.info.valid_sections = (unsigned short)1U;
  
#line 6000 
  ctxt.info.switch_id = (unsigned short)((unsigned int)ctxt.info.switch_id | 8192U);
  
#line 6002 
  tmp_0 = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 6002 
  aq_ret = (int)tmp_0;
  
#line 6003 
  if (aq_ret != 0) 
#line 6004 
                   _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: update vsi switch failed, aq_err=%d\n","i40e_enable_pf_switch_lb",(unsigned int)(vsi->back)->hw.aq.asq_last_status); else ;
  return_label: 
#line 6005 
                return;
}


#line 6016  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_disable_pf_switch_lb(struct i40e_pf *pf)
{
  struct i40e_vsi_context ctxt;
  int aq_ret;
  i40e_status tmp;
  i40e_status tmp_0;
  
#line 6018 
  struct i40e_vsi *vsi = *(pf->vsi + (int)pf->lan_vsi);
  
#line 6022 
  ctxt.seid = pf->main_vsi_seid;
  
#line 6023 
  ctxt.pf_num = pf->hw.pf_id;
  
#line 6024 
  ctxt.vf_num = (unsigned char)0U;
  
#line 6025 
  tmp = i40e_aq_get_vsi_params(& pf->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 6025 
  aq_ret = (int)tmp;
  
#line 6026 
  if (aq_ret != 0) {
    
#line 6027 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"%s couldn\'t get PF vsi config, err %d, aq_err %d\n","i40e_disable_pf_switch_lb",aq_ret,(unsigned int)pf->hw.aq.asq_last_status);
    
#line 6030 
    goto return_label;
  }
  else ;
  
#line 6032 
  ctxt.flags = (unsigned short)2U;
  
#line 6033 
  ctxt.info.valid_sections = (unsigned short)1U;
  
#line 6034 
  ctxt.info.switch_id = (unsigned short)((unsigned int)ctxt.info.switch_id & 57343U);
  
#line 6036 
  tmp_0 = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 6036 
  aq_ret = (int)tmp_0;
  
#line 6037 
  if (aq_ret != 0) 
#line 6038 
                   _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: update vsi switch failed, aq_err=%d\n","i40e_disable_pf_switch_lb",(unsigned int)(vsi->back)->hw.aq.asq_last_status); else ;
  return_label: 
#line 6039 
                return;
}


#line 6052  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_config_bridge_mode(struct i40e_veb *veb)
{
  char *tmp;
  
#line 6054 
  struct i40e_pf *pf = veb->pf;
  
#line 6056 
  if ((unsigned int)veb->bridge_mode == 1U) 
#line 6056 
                                            tmp = (char *)"VEPA"; else 
                                                                    
#line 6056 
                                                                    tmp = (char *)"VEB";
  
#line 6056 
  ;
  
#line 6056 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"enabling bridge mode: %s\n",tmp);
  
#line 6058 
  if (((int)veb->bridge_mode & 1) != 0) 
#line 6059 
                                        i40e_disable_pf_switch_lb(pf); else 
                                                                    
#line 6061 
                                                                    i40e_enable_pf_switch_lb(pf);
  
#line 6062 
  return;
}


#line 6073  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_reconstitute_veb(struct i40e_veb *veb)
{
  int v;
  int veb_idx;
  int ret;
  
#line 6075 
  struct i40e_vsi *ctl_vsi = (struct i40e_vsi *)0;
  
#line 6076 
  struct i40e_pf *pf = veb->pf;
  
#line 6081 
  v = 0;
  
#line 6081 
  goto ldv_63342;
  ldv_63341: 
#line 6082 
  ;
  
#line 6082 
  if ((*(pf->vsi + v) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + v))->veb_idx == (int)veb->idx) && ((*(pf->vsi + v))->flags & 2UL) != 0UL) {
    
#line 6085 
    ctl_vsi = *(pf->vsi + v);
    
#line 6086 
    goto ldv_63340;
  }
  else ;
  
#line 6081 
  v += 1;
  ldv_63342: 
#line 6082 
  ;
  
#line 6081 
  if ((int)pf->num_alloc_vsi > v && ctl_vsi == (struct i40e_vsi *)0) 
    
#line 6083 
    goto ldv_63341; else 
#line 6086 
                         goto ldv_63340;
  ldv_63340: 
#line 6087 
  ;
  
#line 6089 
  if (ctl_vsi == (struct i40e_vsi *)0) {
    
#line 6090 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"missing owner VSI for veb_idx %d\n",(int)veb->idx);
    
#line 6092 
    ret = -2;
    
#line 6093 
    goto end_reconstitute;
  }
  else ;
  
#line 6095 
  if (*(pf->vsi + (int)pf->lan_vsi) != ctl_vsi) 
#line 6096 
                                                ctl_vsi->uplink_seid = (*(pf->vsi + (int)pf->lan_vsi))->uplink_seid; else ;
  
#line 6097 
  ret = i40e_add_vsi(ctl_vsi);
  
#line 6098 
  if (ret != 0) {
    
#line 6099 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"rebuild of owner VSI failed: %d\n",ret);
    
#line 6101 
    goto end_reconstitute;
  }
  else ;
  
#line 6103 
  i40e_vsi_reset_stats(ctl_vsi);
  
#line 6106 
  ret = i40e_add_veb(veb,ctl_vsi);
  
#line 6107 
  if (ret != 0) 
#line 6108 
                goto end_reconstitute; else ;
  
#line 6110 
  if ((pf->flags & 1099511627776ULL) != 0ULL) 
#line 6111 
                                              veb->bridge_mode = (unsigned short)0U; else 
                                                                    
#line 6113 
                                                                    veb->bridge_mode = (unsigned short)1U;
  
#line 6114 
  i40e_config_bridge_mode(veb);
  
#line 6117 
  v = 0;
  
#line 6117 
  goto ldv_63347;
  ldv_63346: 
#line 6118 
  ;
  
#line 6118 
  if (*(pf->vsi + v) == (struct i40e_vsi *)0 || *(pf->vsi + v) == ctl_vsi) 
    
#line 6119 
    goto ldv_63344; else ;
  
#line 6121 
  if ((int)(*(pf->vsi + v))->veb_idx == (int)veb->idx) {
    
#line 6122 
    struct i40e_vsi *vsi = *(pf->vsi + v);
    
#line 6123 
    vsi->uplink_seid = veb->seid;
    
#line 6124 
    ret = i40e_add_vsi(vsi);
    
#line 6125 
    if (ret != 0) {
      
#line 6126 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"rebuild of vsi_idx %d failed: %d\n",v,ret);
      
#line 6129 
      goto end_reconstitute;
    }
    else ;
    
#line 6131 
    i40e_vsi_reset_stats(vsi);
  }
  else ;
  ldv_63344: 
#line 6133 
  ;
  
#line 6117 
  v += 1;
  ldv_63347: 
#line 6118 
  ;
  
#line 6117 
  if ((int)pf->num_alloc_vsi > v) 
#line 6119 
                                  goto ldv_63346; else 
#line 6122 
                                                       goto ldv_63348;
  ldv_63348: 
#line 6123 
  ;
  
#line 6136 
  veb_idx = 0;
  
#line 6136 
  goto ldv_63351;
  ldv_63350: 
#line 6137 
  ;
  
#line 6137 
  if (pf->veb[veb_idx] != (struct i40e_veb *)0 && (int)(pf->veb[veb_idx])->veb_idx == (int)veb->idx) {
    
#line 6138 
    (pf->veb[veb_idx])->uplink_seid = veb->seid;
    
#line 6139 
    ret = i40e_reconstitute_veb(pf->veb[veb_idx]);
    
#line 6140 
    if (ret != 0) 
#line 6141 
                  goto ldv_63349; else ;
  }
  else ;
  
#line 6136 
  veb_idx += 1;
  ldv_63351: 
#line 6137 
  ;
  
#line 6136 
  if (veb_idx <= 15) 
#line 6138 
                     goto ldv_63350; else 
#line 6141 
                                          goto ldv_63349;
  ldv_63349: 
#line 6142 
  ;
  end_reconstitute: 
#line 6145 
  ;
  
#line 6146 
  return ret;
}


#line 6153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_capabilities(struct i40e_pf *pf)
{
  int __retres;
  struct i40e_aqc_list_capabilities_element_resp *cap_buf;
  u16 data_size;
  int buf_len;
  int err;
  i40e_status tmp_0;
  
#line 6160 
  buf_len = 1280;
  ldv_63359: 
#line 6161 
  ;
  
#line 6162 
  cap_buf = (struct i40e_aqc_list_capabilities_element_resp *)kzalloc_0((unsigned long)buf_len,208U);
  
#line 6163 
  if (cap_buf == (struct i40e_aqc_list_capabilities_element_resp *)0) {
    
#line 6164 
    __retres = -12;
    
#line 6164 
    goto return_label;
  }
  else ;
  
#line 6167 
  tmp_0 = i40e_aq_discover_capabilities(& pf->hw,(void *)cap_buf,(unsigned short)((int)((unsigned short)buf_len)),& data_size,(enum i40e_admin_queue_opc)i40e_aqc_opc_list_func_capabilities,(struct i40e_asq_cmd_details *)0);
  
#line 6167 
  err = (int)tmp_0;
  
#line 6172 
  kfree((void const *)cap_buf);
  
#line 6174 
  if (pf->hw.aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOMEM) 
#line 6176 
                                                                    buf_len = (int)data_size;
  else 
    
#line 6177 
    if (pf->hw.aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) {
      
#line 6178 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"capability discovery failed: aq=%d\n",(unsigned int)pf->hw.aq.asq_last_status);
      
#line 6181 
      __retres = -19;
      
#line 6181 
      goto return_label;
    }
    else ;
  
#line 6183 
  if (err != 0) 
#line 6185 
                goto ldv_63359; else 
#line 6188 
                                     goto ldv_63360;
  ldv_63360: 
#line 6189 
  ;
  
#line 6185 
  if (((unsigned int)pf->hw.aq.fw_maj_ver == 2U && (unsigned int)pf->hw.aq.fw_min_ver <= 21U) || (unsigned int)pf->hw.aq.fw_maj_ver <= 1U) {
    
#line 6187 
    pf->hw.func_caps.num_msix_vectors += 1U;
    
#line 6188 
    pf->hw.func_caps.num_msix_vectors_vf += 1U;
  }
  else ;
  
#line 6191 
  if ((pf->hw.debug_mask & 4026531840U) != 0U) 
#line 6192 
                                               _dev_info((struct device const *)(& (pf->pdev)->dev),"pf=%d, num_vfs=%d, msix_pf=%d, msix_vf=%d, fd_g=%d, fd_b=%d, pf_max_q=%d num_vsi=%d\n",(int)pf->hw.pf_id,pf->hw.func_caps.num_vfs,pf->hw.func_caps.num_msix_vectors,pf->hw.func_caps.num_msix_vectors_vf,pf->hw.func_caps.fd_filters_guaranteed,pf->hw.func_caps.fd_filters_best_effort,pf->hw.func_caps.num_tx_qp,pf->hw.func_caps.num_vsis); else ;
  
#line 6204 
  if ((unsigned int)pf->hw.revision_id == 0U) {
    int tmp_3;
    
#line 6204 
    if ((int)pf->hw.func_caps.fcoe != 0) 
#line 6204 
                                         tmp_3 = 2; else 
#line 6204 
                                                         tmp_3 = 1;
    
#line 6204 
    ;
    
#line 6204 
    if ((unsigned int)tmp_3 + pf->hw.func_caps.num_vfs > pf->hw.func_caps.num_vsis) {
      int tmp_1;
      int tmp_2;
      
#line 6205 
      if ((int)pf->hw.func_caps.fcoe != 0) 
#line 6205 
                                           tmp_1 = 2; else 
#line 6205 
                                                           tmp_1 = 1;
      
#line 6205 
      ;
      
#line 6205 
      ;
      
#line 6205 
      ;
      
#line 6205 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"got num_vsis %d, setting num_vsis to %d\n",pf->hw.func_caps.num_vsis,(unsigned int)tmp_1 + pf->hw.func_caps.num_vfs);
      
#line 6208 
      if ((int)pf->hw.func_caps.fcoe != 0) 
#line 6208 
                                           tmp_2 = 2; else 
#line 6208 
                                                           tmp_2 = 1;
      
#line 6208 
      pf->hw.func_caps.num_vsis = (unsigned int)tmp_2 + pf->hw.func_caps.num_vfs;
    }
    else ;
  }
  else ;
  
#line 6211 
  __retres = 0;
  return_label: 
#line 6211 
                return __retres;
}


#line 6214 
static int i40e_vsi_clear(struct i40e_vsi *vsi);


#line 6220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_sb_setup(struct i40e_pf *pf)
{
  struct i40e_vsi *vsi;
  int i;
  unsigned int tmp;
  
#line 6228 
  tmp = readl((void const volatile *)(pf->hw.hw_addr + 2556224U));
  
#line 6228 
  if (tmp == 0U) {
    
#line 6229 
    u32 const hkey[13U] = {3863008063U, 3456014507U, 1945792865U, 226131254U, 3939204449U, 2857305526U, 2623310317U, 4232207835U, 2758101042U, 4235485652U, 2407691801U, 4123409441U, 2511578989U};
    
#line 6235 
    i = 0;
    
#line 6235 
    goto ldv_63370;
    ldv_63369: 
#line 6236 
    ;
    
#line 6236 
    writel(hkey[i],(void volatile *)(pf->hw.hw_addr + (i + 639056) * 4));
    
#line 6235 
    i += 1;
    ldv_63370: 
#line 6236 
    ;
    
#line 6235 
    if (i <= 12) 
#line 6237 
                 goto ldv_63369; else 
#line 6240 
                                      goto ldv_63371;
    ldv_63371: 
#line 6241 
    ;
  }
  else ;
  
#line 6239 
  if ((pf->flags & 2097152ULL) == 0ULL) 
#line 6240 
                                        goto return_label; else ;
  
#line 6243 
  vsi = (struct i40e_vsi *)0;
  
#line 6244 
  i = 0;
  
#line 6244 
  goto ldv_63374;
  ldv_63373: 
#line 6245 
  ;
  
#line 6245 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (*(pf->vsi + i))->type == (unsigned int)I40E_VSI_FDIR) {
    
#line 6246 
    vsi = *(pf->vsi + i);
    
#line 6247 
    goto ldv_63372;
  }
  else ;
  
#line 6244 
  i += 1;
  ldv_63374: 
#line 6245 
  ;
  
#line 6244 
  if ((int)pf->num_alloc_vsi > i) 
#line 6246 
                                  goto ldv_63373; else 
#line 6249 
                                                       goto ldv_63372;
  ldv_63372: 
#line 6250 
  ;
  
#line 6252 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 6253 
    vsi = i40e_vsi_setup(pf,(unsigned char)7,(unsigned short)((int)(*(pf->vsi + (int)pf->lan_vsi))->seid),0U);
    
#line 6255 
    if (vsi == (struct i40e_vsi *)0) {
      
#line 6256 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"Couldn\'t create FDir VSI\n");
      
#line 6257 
      pf->flags &= 18446744073707454463ULL;
      
#line 6258 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 6262 
  i40e_vsi_setup_irqhandler(vsi,& i40e_fdir_clean_ring);
  return_label: 
#line 6263 
                return;
}


#line 6269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_teardown(struct i40e_pf *pf)
{
  int i;
  
#line 6273 
  i40e_fdir_filter_exit(pf);
  
#line 6274 
  i = 0;
  
#line 6274 
  goto ldv_63381;
  ldv_63380: 
#line 6275 
  ;
  
#line 6275 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (*(pf->vsi + i))->type == (unsigned int)I40E_VSI_FDIR) {
    
#line 6276 
    i40e_vsi_release(*(pf->vsi + i));
    
#line 6277 
    goto ldv_63379;
  }
  else ;
  
#line 6274 
  i += 1;
  ldv_63381: 
#line 6275 
  ;
  
#line 6274 
  if ((int)pf->num_alloc_vsi > i) 
#line 6276 
                                  goto ldv_63380; else 
#line 6279 
                                                       goto ldv_63379;
  ldv_63379: 
#line 6280 
  ;
  
#line 6281 
  return;
}


#line 6288  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_prep_for_reset(struct i40e_pf *pf)
{
  u32 v;
  int tmp;
  
#line 6290 
  struct i40e_hw *hw = & pf->hw;
  
#line 6291 
  i40e_status ret = 0;
  
#line 6294 
  clear_bit(10L,(unsigned long volatile *)(& pf->state));
  
#line 6295 
  tmp = test_and_set_bit(9L,(unsigned long volatile *)(& pf->state));
  
#line 6295 
  if (tmp != 0) 
#line 6296 
                goto return_label; else ;
  {
    
#line 6298 
    struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_prep_for_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "Tearing down internal switch for reset\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))6298U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 6298 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 6298 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"Tearing down internal switch for reset\n"); else ;
  }
  
#line 6301 
  i40e_pf_quiesce_all_vsi(pf);
  
#line 6303 
  v = 0U;
  
#line 6303 
  goto ldv_63391;
  ldv_63390: 
#line 6304 
  ;
  
#line 6304 
  if (*(pf->vsi + v) != (struct i40e_vsi *)0) 
#line 6305 
                                              (*(pf->vsi + v))->seid = (unsigned short)0U; else ;
  
#line 6303 
  v += 1U;
  ldv_63391: 
#line 6304 
  ;
  
#line 6303 
  if ((unsigned int)pf->num_alloc_vsi > v) 
#line 6305 
                                           goto ldv_63390; else 
#line 6308 
                                                                goto ldv_63392;
  ldv_63392: 
#line 6309 
  ;
  
#line 6308 
  i40e_shutdown_adminq(& pf->hw);
  
#line 6311 
  if (hw->hmc.hmc_obj != (struct i40e_hmc_obj_info *)0) {
    
#line 6312 
    ret = i40e_shutdown_lan_hmc(hw);
    
#line 6313 
    if (ret != I40E_SUCCESS) 
#line 6314 
                             dev_warn((struct device const *)(& (pf->pdev)->dev),"shutdown_lan_hmc failed: %d\n",(int)ret); else ;
  }
  else ;
  return_label: 
#line 6317 
                return;
}


#line 6323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_send_version(struct i40e_pf *pf)
{
  struct i40e_driver_version dv;
  
#line 6327 
  dv.major_version = (unsigned char)1U;
  
#line 6328 
  dv.minor_version = (unsigned char)3U;
  
#line 6329 
  dv.build_version = (unsigned char)4U;
  
#line 6330 
  dv.subbuild_version = (unsigned char)0U;
  
#line 6331 
  strlcpy((char *)(& dv.driver_string),"1",32UL);
  
#line 6332 
  i40e_aq_send_driver_version(& pf->hw,& dv,(struct i40e_asq_cmd_details *)0);
  
#line 6333 
  return;
}


#line 6340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit)
{
  i40e_status ret;
  u32 v;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  
#line 6342 
  struct i40e_hw *hw = & pf->hw;
  
#line 6343 
  u8 set_fc_aq_fail = (unsigned char)0U;
  
#line 6351 
  ret = i40e_pf_reset(hw);
  
#line 6352 
  if (ret != I40E_SUCCESS) {
    
#line 6353 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"PF reset failed, %d\n",(int)ret);
    
#line 6354 
    clear_bit(23L,(unsigned long volatile *)(& pf->state));
    
#line 6355 
    goto clear_recovery;
  }
  else ;
  
#line 6357 
  pf->pfr_count = (u16)((int)pf->pfr_count + 1);
  
#line 6359 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 6359 
  if (tmp != 0) 
#line 6360 
                goto clear_recovery; else ;
  {
    
#line 6361 
    struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_reset_and_rebuild", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "Rebuilding internal switch\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))6361U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 6361 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 6361 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"Rebuilding internal switch\n"); else ;
  }
  
#line 6364 
  ret = i40e_init_adminq(& pf->hw);
  
#line 6365 
  if (ret != I40E_SUCCESS) {
    
#line 6366 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Rebuild AdminQ failed, %d\n",(int)ret);
    
#line 6367 
    goto clear_recovery;
  }
  else ;
  
#line 6371 
  tmp_0 = test_and_set_bit(16L,(unsigned long volatile *)(& pf->state));
  
#line 6371 
  if (tmp_0 != 0) 
#line 6372 
                  i40e_verify_eeprom(pf); else ;
  
#line 6374 
  i40e_clear_pxe_mode(hw);
  
#line 6375 
  tmp_1 = i40e_get_capabilities(pf);
  
#line 6375 
  ret = (enum i40e_status_code)tmp_1;
  
#line 6376 
  if (ret != I40E_SUCCESS) {
    
#line 6377 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"i40e_get_capabilities failed, %d\n",(int)ret);
    
#line 6379 
    goto end_core_reset;
  }
  else ;
  
#line 6382 
  ret = i40e_init_lan_hmc(hw,hw->func_caps.num_tx_qp,hw->func_caps.num_rx_qp,pf->fcoe_hmc_cntx_num,pf->fcoe_hmc_filt_num);
  
#line 6385 
  if (ret != I40E_SUCCESS) {
    
#line 6386 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"init_lan_hmc failed: %d\n",(int)ret);
    
#line 6387 
    goto end_core_reset;
  }
  else ;
  
#line 6389 
  ret = i40e_configure_lan_hmc(hw,(enum i40e_hmc_model)I40E_HMC_MODEL_DIRECT_ONLY);
  
#line 6390 
  if (ret != I40E_SUCCESS) {
    
#line 6391 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"configure_lan_hmc failed: %d\n",(int)ret);
    
#line 6392 
    goto end_core_reset;
  }
  else ;
  
#line 6396 
  tmp_2 = i40e_init_pf_dcb(pf);
  
#line 6396 
  ret = (enum i40e_status_code)tmp_2;
  
#line 6397 
  if (ret != I40E_SUCCESS) {
    
#line 6398 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"DCB init failed %d, disabled\n",(int)ret);
    
#line 6399 
    pf->flags &= 18446744073172680703ULL;
  }
  else ;
  
#line 6404 
  tmp_3 = i40e_init_pf_fcoe(pf);
  
#line 6404 
  ret = (enum i40e_status_code)tmp_3;
  
#line 6405 
  if (ret != I40E_SUCCESS) 
#line 6406 
                           _dev_info((struct device const *)(& (pf->pdev)->dev),"init_pf_fcoe failed: %d\n",(int)ret); else ;
  
#line 6410 
  tmp_4 = i40e_setup_pf_switch(pf,(_Bool)((bool)((int)reinit) != 0));
  
#line 6410 
  ret = (enum i40e_status_code)tmp_4;
  
#line 6411 
  if (ret != I40E_SUCCESS) 
#line 6412 
                           goto end_core_reset; else ;
  
#line 6417 
  ret = i40e_aq_set_phy_int_mask(& pf->hw,(unsigned short)258,(struct i40e_asq_cmd_details *)0);
  
#line 6420 
  if (ret != I40E_SUCCESS) 
#line 6421 
                           _dev_info((struct device const *)(& (pf->pdev)->dev),"set phy mask fail, aq_err %d\n",(int)ret); else ;
  
#line 6424 
  ret = i40e_set_fc(& pf->hw,& set_fc_aq_fail,(_Bool)1);
  
#line 6425 
  if (ret != I40E_SUCCESS) 
#line 6426 
                           _dev_info((struct device const *)(& (pf->pdev)->dev),"set fc fail, aq_err %d\n",(int)ret); else ;
  
#line 6435 
  if ((int)(*(pf->vsi + (int)pf->lan_vsi))->uplink_seid != (int)pf->mac_seid) {
    {
      
#line 6436 
      struct _ddebug descriptor_0 = {.modname = "i40e", .function = "i40e_reset_and_rebuild", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "attempting to rebuild switch\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))6436U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 6436 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) 
#line 6436 
                                                            __dynamic_dev_dbg(& descriptor_0,(struct device const *)(& (pf->pdev)->dev),"attempting to rebuild switch\n"); else ;
    }
    
#line 6438 
    v = 0U;
    
#line 6438 
    goto ldv_63413;
    ldv_63412: 
#line 6439 
    ;
    
#line 6439 
    if (pf->veb[v] == (struct i40e_veb *)0) 
#line 6440 
                                            goto ldv_63410; else ;
    
#line 6442 
    if ((int)(pf->veb[v])->uplink_seid == (int)pf->mac_seid || (unsigned int)(pf->veb[v])->uplink_seid == 0U) {
      int tmp_5;
      
#line 6444 
      tmp_5 = i40e_reconstitute_veb(pf->veb[v]);
      
#line 6444 
      ret = (enum i40e_status_code)tmp_5;
      
#line 6446 
      if (ret == I40E_SUCCESS) 
#line 6447 
                               goto ldv_63410; else ;
      
#line 6455 
      if ((int)(pf->veb[v])->uplink_seid == (int)pf->mac_seid) {
        
#line 6456 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"rebuild of switch failed: %d, will try to set up simple PF connection\n",(int)ret);
        
#line 6460 
        (*(pf->vsi + (int)pf->lan_vsi))->uplink_seid = pf->mac_seid;
        
#line 6461 
        goto ldv_63411;
      }
      else 
        
#line 6462 
        if ((unsigned int)(pf->veb[v])->uplink_seid == 0U) 
#line 6463 
                                                           _dev_info((struct device const *)(& (pf->pdev)->dev),"rebuild of orphan VEB failed: %d\n",(int)ret); else ;
    }
    else ;
    ldv_63410: 
#line 6465 
    ;
    
#line 6438 
    v += 1U;
    ldv_63413: 
#line 6439 
    ;
    
#line 6438 
    if (v <= 15U) 
#line 6440 
                  goto ldv_63412; else 
#line 6443 
                                       goto ldv_63411;
    ldv_63411: 
#line 6444 
    ;
  }
  else ;
  
#line 6471 
  if ((int)(*(pf->vsi + (int)pf->lan_vsi))->uplink_seid == (int)pf->mac_seid) {
    int tmp_6;
    {
      
#line 6472 
      struct _ddebug descriptor_1 = {.modname = "i40e", .function = "i40e_reset_and_rebuild", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = "attempting to rebuild PF VSI\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))6472U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 6472 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) 
#line 6472 
                                                            __dynamic_dev_dbg(& descriptor_1,(struct device const *)(& (pf->pdev)->dev),"attempting to rebuild PF VSI\n"); else ;
    }
    
#line 6474 
    tmp_6 = i40e_add_vsi(*(pf->vsi + (int)pf->lan_vsi));
    
#line 6474 
    ret = (enum i40e_status_code)tmp_6;
    
#line 6475 
    if (ret != I40E_SUCCESS) {
      
#line 6476 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"rebuild of Main VSI failed: %d\n",(int)ret);
      
#line 6478 
      goto end_core_reset;
    }
    else ;
  }
  else ;
  
#line 6482 
  if (((unsigned int)pf->hw.aq.fw_maj_ver == 4U && (unsigned int)pf->hw.aq.fw_min_ver <= 32U) || (unsigned int)pf->hw.aq.fw_maj_ver <= 3U) {
    
#line 6484 
    msleep(75U);
    
#line 6485 
    ret = i40e_aq_set_link_restart_an(& pf->hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
    
#line 6486 
    if (ret != I40E_SUCCESS) 
#line 6487 
                             _dev_info((struct device const *)(& (pf->pdev)->dev),"link restart failed, aq_err=%d\n",(unsigned int)pf->hw.aq.asq_last_status); else ;
  }
  else ;
  
#line 6491 
  if ((pf->flags & 8ULL) != 0ULL) {
    int tmp_7;
    
#line 6492 
    tmp_7 = i40e_setup_misc_vector(pf);
    
#line 6492 
    ret = (enum i40e_status_code)tmp_7;
  }
  else ;
  
#line 6495 
  i40e_pf_unquiesce_all_vsi(pf);
  
#line 6497 
  if (pf->num_alloc_vfs != 0) {
    
#line 6498 
    v = 0U;
    
#line 6498 
    goto ldv_63416;
    ldv_63415: 
#line 6499 
    ;
    
#line 6499 
    i40e_reset_vf(pf->vf + v,(_Bool)1);
    
#line 6498 
    v += 1U;
    ldv_63416: 
#line 6499 
    ;
    
#line 6498 
    if ((unsigned int)pf->num_alloc_vfs > v) 
#line 6500 
                                             goto ldv_63415; else 
#line 6503 
                                                                  goto ldv_63417;
    ldv_63417: 
#line 6504 
    ;
  }
  else ;
  
#line 6503 
  i40e_send_version(pf);
  end_core_reset: 
#line 6505 
  ;
  
#line 6506 
  clear_bit(23L,(unsigned long volatile *)(& pf->state));
  clear_recovery: 
#line 6507 
  ;
  
#line 6508 
  clear_bit(9L,(unsigned long volatile *)(& pf->state));
  
#line 6509 
  return;
}


#line 6518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_handle_reset_warning(struct i40e_pf *pf)
{
  
#line 6520 
  i40e_prep_for_reset(pf);
  
#line 6521 
  i40e_reset_and_rebuild(pf,(_Bool)0);
  
#line 6522 
  return;
}


#line 6530  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_handle_mdd_event(struct i40e_pf *pf)
{
  struct i40e_vf *vf;
  u32 reg;
  int i;
  int tmp;
  
#line 6532 
  struct i40e_hw *hw = & pf->hw;
  
#line 6533 
  bool mdd_detected = (_Bool)0;
  
#line 6534 
  bool pf_mdd_detected = (_Bool)0;
  
#line 6539 
  tmp = constant_test_bit(7L,(unsigned long const volatile *)(& pf->state));
  
#line 6539 
  if (tmp == 0) 
#line 6540 
                goto return_label; else ;
  
#line 6543 
  reg = readl((void const volatile *)(hw->hw_addr + 943232U));
  
#line 6544 
  if (reg < (u32)0) {
    
#line 6545 
    u8 pf_num = (unsigned char)((unsigned int)((unsigned char)(reg >> 21)) & 15U);
    
#line 6547 
    u16 vf_num = (unsigned short)((unsigned int)((unsigned short)(reg >> 12)) & 511U);
    
#line 6549 
    u8 event = (unsigned char)((unsigned int)((unsigned char)(reg >> 25)) & 31U);
    
#line 6551 
    u16 queue = (unsigned short)(((unsigned int)((unsigned short)reg) & 4095U) - (unsigned int)((unsigned short)pf->hw.func_caps.base_queue));
    
#line 6554 
    if ((pf->msg_enable & 128U) != 0U) 
#line 6555 
                                       _dev_info((struct device const *)(& (pf->pdev)->dev),"Malicious Driver Detection event 0x%02x on TX queue %d PF number 0x%02x VF number 0x%02x\n",(int)event,(int)queue,(int)pf_num,(int)vf_num); else ;
    
#line 6557 
    writel(4294967295U,(void volatile *)(hw->hw_addr + 943232U));
    
#line 6558 
    mdd_detected = (_Bool)1;
  }
  else ;
  
#line 6560 
  reg = readl((void const volatile *)(hw->hw_addr + 1221904U));
  
#line 6561 
  if (reg < (u32)0) {
    
#line 6562 
    u8 func = (unsigned char)reg;
    
#line 6564 
    u8 event_0 = (unsigned char)(reg >> 8);
    
#line 6566 
    u16 queue_0 = (unsigned short)(((unsigned int)((unsigned short)(reg >> 17)) & 16383U) - (unsigned int)((unsigned short)pf->hw.func_caps.base_queue));
    
#line 6569 
    if ((pf->msg_enable & 64U) != 0U) 
#line 6570 
                                      _dev_info((struct device const *)(& (pf->pdev)->dev),"Malicious Driver Detection event 0x%02x on RX queue %d of function 0x%02x\n",(int)event_0,(int)queue_0,(int)func); else ;
    
#line 6572 
    writel(4294967295U,(void volatile *)(hw->hw_addr + 1221904U));
    
#line 6573 
    mdd_detected = (_Bool)1;
  }
  else ;
  
#line 6576 
  if ((int)mdd_detected != 0) {
    
#line 6577 
    reg = readl((void const volatile *)(hw->hw_addr + 943104U));
    
#line 6578 
    if ((reg & 1U) != 0U) {
      
#line 6579 
      writel(65535U,(void volatile *)(hw->hw_addr + 943104U));
      
#line 6580 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"TX driver issue detected, PF reset issued\n");
      
#line 6581 
      pf_mdd_detected = (_Bool)1;
    }
    else ;
    
#line 6583 
    reg = readl((void const volatile *)(hw->hw_addr + 1221632U));
    
#line 6584 
    if ((reg & 1U) != 0U) {
      
#line 6585 
      writel(65535U,(void volatile *)(hw->hw_addr + 1221632U));
      
#line 6586 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"RX driver issue detected, PF reset issued\n");
      
#line 6587 
      pf_mdd_detected = (_Bool)1;
    }
    else ;
    
#line 6590 
    if ((int)pf_mdd_detected != 0) {
      
#line 6591 
      clear_bit(12L,(unsigned long volatile *)(& pf->state));
      
#line 6592 
      i40e_service_event_schedule(pf);
    }
    else ;
  }
  else ;
  
#line 6597 
  i = 0;
  
#line 6597 
  goto ldv_63438;
  ldv_63437: 
#line 6598 
  ;
  
#line 6598 
  vf = pf->vf + i;
  
#line 6599 
  reg = readl((void const volatile *)(hw->hw_addr + (i + 235520) * 4));
  
#line 6600 
  if ((reg & 1U) != 0U) {
    
#line 6601 
    writel(65535U,(void volatile *)(hw->hw_addr + (i + 235520) * 4));
    
#line 6602 
    vf->num_mdd_events += 1ULL;
    
#line 6603 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"TX driver issue detected on VF %d\n",i);
  }
  else ;
  
#line 6607 
  reg = readl((void const volatile *)(hw->hw_addr + (i + 305152) * 4));
  
#line 6608 
  if ((reg & 1U) != 0U) {
    
#line 6609 
    writel(65535U,(void volatile *)(hw->hw_addr + (i + 305152) * 4));
    
#line 6610 
    vf->num_mdd_events += 1ULL;
    
#line 6611 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"RX driver issue detected on VF %d\n",i);
  }
  else ;
  
#line 6615 
  if (vf->num_mdd_events > 3ULL) {
    
#line 6616 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Too many MDD events on VF %d, disabled\n",i);
    
#line 6618 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Use PF Control I/F to re-enable the VF\n");
    
#line 6620 
    clear_bit(3L,(unsigned long volatile *)(& vf->vf_states));
  }
  else ;
  
#line 6597 
  i += 1;
  ldv_63438: 
#line 6598 
  ;
  
#line 6597 
  if (pf->num_alloc_vfs > i && (int)mdd_detected != 0) 
#line 6599 
                                                       goto ldv_63437; else 
                                                                    
#line 6602 
                                                                    goto ldv_63439;
  ldv_63439: 
#line 6603 
  ;
  
#line 6625 
  clear_bit(7L,(unsigned long volatile *)(& pf->state));
  
#line 6626 
  reg = readl((void const volatile *)(hw->hw_addr + 231424U));
  
#line 6627 
  reg |= 524288U;
  
#line 6628 
  writel(reg,(void volatile *)(hw->hw_addr + 231424U));
  
#line 6629 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  return_label: 
#line 6630 
                return;
}


#line 6637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_sync_vxlan_filters_subtask(struct i40e_pf *pf)
{
  i40e_status ret;
  __be16 port;
  int i;
  
#line 6639 
  struct i40e_hw *hw = & pf->hw;
  
#line 6644 
  if ((pf->flags & 134217728ULL) == 0ULL) 
#line 6645 
                                          goto return_label; else ;
  
#line 6647 
  pf->flags &= 18446744073575333887ULL;
  
#line 6649 
  i = 0;
  
#line 6649 
  goto ldv_63448;
  ldv_63447: 
#line 6650 
  ;
  
#line 6650 
  if ((((int)pf->pending_vxlan_bitmap >> i) & 1) != 0) {
    
#line 6651 
    pf->pending_vxlan_bitmap = (unsigned short)((int)pf->pending_vxlan_bitmap & ~ (1 << i));
    
#line 6652 
    port = pf->vxlan_ports[i];
    
#line 6653 
    if ((unsigned int)port != 0U) {
      int tmp_0;
      
#line 6654 
      if (0 != 0) 
#line 6654 
                  tmp_0 = (int)((unsigned short)(((int)port << 8) | ((int)port >> 8)));
      else {
        __u16 tmp;
        
#line 6654 
        tmp = __fswab16((unsigned short)((int)port));
        
#line 6654 
        tmp_0 = (int)tmp;
      }
      
#line 6654 
      ;
      
#line 6654 
      ret = i40e_aq_add_udp_tunnel(hw,(unsigned short)tmp_0,(unsigned char)0,(u8 *)0U,(struct i40e_asq_cmd_details *)0);
    }
    else 
#line 6658 
         ret = i40e_aq_del_udp_tunnel(hw,(unsigned char)((int)((unsigned char)i)),(struct i40e_asq_cmd_details *)0);
    
#line 6660 
    if (ret != I40E_SUCCESS) {
      int tmp_2;
      char *tmp_3;
      
#line 6661 
      ;
      
#line 6661 
      ;
      
#line 6661 
      ;
      
#line 6661 
      if (0 != 0) 
#line 6661 
                  tmp_2 = (int)((unsigned short)(((int)port << 8) | ((int)port >> 8)));
      else {
        __u16 tmp_1;
        
#line 6661 
        tmp_1 = __fswab16((unsigned short)((int)port));
        
#line 6661 
        tmp_2 = (int)tmp_1;
      }
      
#line 6661 
      if ((unsigned int)port != 0U) 
#line 6661 
                                    tmp_3 = (char *)"add"; else 
#line 6661 
                                                                tmp_3 = (char *)"delete";
      
#line 6661 
      ;
      
#line 6661 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"%s vxlan port %d, index %d failed, err %d, aq_err %d\n",tmp_3,tmp_2,i,(int)ret,(unsigned int)pf->hw.aq.asq_last_status);
      
#line 6666 
      pf->vxlan_ports[i] = (unsigned short)0U;
    }
    else ;
  }
  else ;
  
#line 6649 
  i += 1;
  ldv_63448: 
#line 6650 
  ;
  
#line 6649 
  if (i <= 15) 
#line 6651 
               goto ldv_63447; else 
#line 6654 
                                    goto ldv_63449;
  ldv_63449: 
#line 6655 
  ;
  return_label: 
#line 6656 
                return;
}


#line 6677  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_service_task(struct work_struct *work)
{
  struct i40e_pf *tmp;
  int tmp_0;
  int tmp_1;
  {
    
#line 6679 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 6679 
    tmp = (struct i40e_pf *)__mptr + 18446744073709549696U;
  }
  
#line 6679 
  struct i40e_pf *pf = tmp;
  
#line 6682 
  unsigned long start_time = jiffies;
  
#line 6685 
  tmp_0 = constant_test_bit(9L,(unsigned long const volatile *)(& pf->state));
  
#line 6685 
  if (tmp_0 != 0) {
    
#line 6686 
    i40e_service_event_complete(pf);
    
#line 6687 
    goto return_label;
  }
  else ;
  
#line 6690 
  i40e_reset_subtask(pf);
  
#line 6691 
  i40e_handle_mdd_event(pf);
  
#line 6692 
  i40e_vc_process_vflr_event(pf);
  
#line 6693 
  i40e_watchdog_subtask(pf);
  
#line 6694 
  i40e_fdir_reinit_subtask(pf);
  
#line 6695 
  i40e_sync_filters_subtask(pf);
  
#line 6697 
  i40e_sync_vxlan_filters_subtask(pf);
  
#line 6699 
  i40e_clean_adminq_subtask(pf);
  
#line 6701 
  i40e_service_event_complete(pf);
  {
    unsigned long __dummy;
    unsigned long volatile __dummy2;
    
#line 6707 
    tmp_1 = 1;
  }
  
#line 6707 
  if (tmp_1 != 0) {
    int tmp_2;
    {
      unsigned long __dummy_0;
      unsigned long __dummy2_0;
      
#line 6707 
      tmp_2 = 1;
    }
    
#line 6707 
    if (tmp_2 != 0) {
      
#line 6707 
      if ((long)((pf->service_timer_period + start_time) - jiffies) < 0L) 
        
#line 6711 
        i40e_service_event_schedule(pf); else 
#line 6707 
                                              goto _LAND_0;
    }
    else 
#line 6707 
         goto _LAND_0;
  }
  else {
    int tmp_3;
    _LAND_0: 
#line 6707 
    tmp_3 = constant_test_bit(6L,(unsigned long const volatile *)(& pf->state));
    
#line 6707 
    if (tmp_3 != 0) 
#line 6711 
                    i40e_service_event_schedule(pf);
    else {
      int tmp_4;
      
#line 6708 
      tmp_4 = constant_test_bit(7L,(unsigned long const volatile *)(& pf->state));
      
#line 6708 
      if (tmp_4 != 0) 
#line 6711 
                      i40e_service_event_schedule(pf);
      else {
        int tmp_5;
        
#line 6709 
        tmp_5 = constant_test_bit(8L,(unsigned long const volatile *)(& pf->state));
        
#line 6709 
        if (tmp_5 != 0) 
#line 6711 
                        i40e_service_event_schedule(pf); else ;
      }
    }
  }
  return_label: 
#line 6712 
                return;
}


#line 6718  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_service_timer(unsigned long data)
{
  unsigned long tmp;
  
#line 6720 
  struct i40e_pf *pf = (struct i40e_pf *)data;
  
#line 6722 
  tmp = round_jiffies(pf->service_timer_period + jiffies);
  
#line 6722 
  ;
  
#line 6722 
  ldv_mod_timer_81(& pf->service_timer,tmp);
  
#line 6724 
  i40e_service_event_schedule(pf);
  
#line 6725 
  return;
}


#line 6731  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_set_num_rings_in_vsi(struct i40e_vsi *vsi)
{
  int __retres;
  
#line 6733 
  struct i40e_pf *pf = vsi->back;
  
#line 6735 
  switch ((unsigned int)vsi->type) {
    case (unsigned int)0: 
#line 6736 
    ;
    
#line 6737 
    vsi->alloc_queue_pairs = pf->num_lan_qps;
    
#line 6738 
    vsi->num_desc = (unsigned short)512U;
    
#line 6740 
    if ((pf->flags & 8ULL) != 0ULL) 
#line 6741 
                                    vsi->num_q_vectors = (int)pf->num_lan_msix; else 
                                                                    
#line 6743 
                                                                    vsi->num_q_vectors = 1;
    
#line 6745 
    goto ldv_63472;
    case (unsigned int)7: 
#line 6747 
    ;
    
#line 6748 
    vsi->alloc_queue_pairs = (unsigned short)1U;
    
#line 6749 
    vsi->num_desc = (unsigned short)32U;
    
#line 6751 
    vsi->num_q_vectors = 1;
    
#line 6752 
    goto ldv_63472;
    case (unsigned int)2: 
#line 6754 
    ;
    
#line 6755 
    vsi->alloc_queue_pairs = pf->num_vmdq_qps;
    
#line 6756 
    vsi->num_desc = (unsigned short)512U;
    
#line 6758 
    vsi->num_q_vectors = (int)pf->num_vmdq_msix;
    
#line 6759 
    goto ldv_63472;
    case (unsigned int)6: 
#line 6761 
    ;
    
#line 6762 
    vsi->alloc_queue_pairs = pf->num_vf_qps;
    
#line 6763 
    vsi->num_desc = (unsigned short)512U;
    
#line 6765 
    goto ldv_63472;
    case (unsigned int)4: 
#line 6768 
    ;
    
#line 6769 
    vsi->alloc_queue_pairs = pf->num_fcoe_qps;
    
#line 6770 
    vsi->num_desc = (unsigned short)512U;
    
#line 6772 
    vsi->num_q_vectors = (int)pf->num_fcoe_msix;
    
#line 6773 
    goto ldv_63472;
    default: 
#line 6776 
    ;
    {
      
#line 6777 
      int __ret_warn_on = 1;
      
#line 6777 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 6777 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c",6777); else ;
      
#line 6777 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 6778 
    __retres = -61;
    
#line 6778 
    goto return_label;
  }
  ldv_63472: 
#line 6781 
  ;
  
#line 6781 
  __retres = 0;
  return_label: 
#line 6781 
                return __retres;
}


#line 6792  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_alloc_arrays(struct i40e_vsi *vsi, bool alloc_qvectors)
{
  int __retres;
  int size;
  
#line 6795 
  int ret = 0;
  
#line 6798 
  size = (int)((unsigned int)vsi->alloc_queue_pairs * 16U);
  
#line 6799 
  vsi->tx_rings = (struct i40e_ring **)kzalloc_0((unsigned long)size,208U);
  
#line 6800 
  if (vsi->tx_rings == (struct i40e_ring **)0) {
    
#line 6801 
    __retres = -12;
    
#line 6801 
    goto return_label;
  }
  else ;
  
#line 6802 
  vsi->rx_rings = vsi->tx_rings + (int)vsi->alloc_queue_pairs;
  
#line 6804 
  if ((int)alloc_qvectors != 0) {
    
#line 6806 
    size = (int)((unsigned long)vsi->num_q_vectors * (unsigned long)8U);
    
#line 6807 
    vsi->q_vectors = (struct i40e_q_vector **)kzalloc_0((unsigned long)size,208U);
    
#line 6808 
    if (vsi->q_vectors == (struct i40e_q_vector **)0) {
      
#line 6809 
      ret = -12;
      
#line 6810 
      goto err_vectors;
    }
    else ;
  }
  else ;
  
#line 6813 
  __retres = ret;
  
#line 6813 
  goto return_label;
  err_vectors: 
#line 6815 
  ;
  
#line 6816 
  kfree((void const *)vsi->tx_rings);
  
#line 6817 
  __retres = ret;
  return_label: 
#line 6817 
                return __retres;
}


#line 6828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_mem_alloc(struct i40e_pf *pf, enum i40e_vsi_type type)
{
  struct i40e_vsi *vsi;
  int vsi_idx;
  int i;
  
#line 6830 
  int ret = -19;
  
#line 6836 
  ldv_mutex_lock_82(& pf->switch_mutex);
  
#line 6844 
  i = (int)pf->next_vsi;
  
#line 6845 
  goto ldv_63496;
  ldv_63495: 
#line 6846 
  ;
  
#line 6846 
  i += 1;
  ldv_63496: 
#line 6847 
  ;
  
#line 6845 
  if ((int)pf->num_alloc_vsi > i && *(pf->vsi + i) != (struct i40e_vsi *)0) 
    
#line 6847 
    goto ldv_63495; else 
#line 6850 
                         goto ldv_63497;
  ldv_63497: 
#line 6851 
  ;
  
#line 6847 
  if ((int)pf->num_alloc_vsi <= i) {
    
#line 6848 
    i = 0;
    
#line 6849 
    goto ldv_63499;
    ldv_63498: 
#line 6850 
    ;
    
#line 6850 
    i += 1;
    ldv_63499: 
#line 6851 
    ;
    
#line 6849 
    if ((int)pf->next_vsi > i && *(pf->vsi + i) != (struct i40e_vsi *)0) 
      
#line 6851 
      goto ldv_63498; else 
#line 6854 
                           goto ldv_63500;
    ldv_63500: 
#line 6855 
    ;
  }
  else ;
  
#line 6853 
  if ((int)pf->num_alloc_vsi > i && *(pf->vsi + i) == (struct i40e_vsi *)0) 
    
#line 6854 
    vsi_idx = i;
  else {
    
#line 6856 
    ret = -19;
    
#line 6857 
    goto unlock_pf;
  }
  
#line 6859 
  i += 1;
  
#line 6859 
  pf->next_vsi = (unsigned short)i;
  
#line 6861 
  vsi = (struct i40e_vsi *)kzalloc_0(4096UL,208U);
  
#line 6862 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 6863 
    ret = -12;
    
#line 6864 
    goto unlock_pf;
  }
  else ;
  
#line 6866 
  vsi->type = type;
  
#line 6867 
  vsi->back = pf;
  
#line 6868 
  clear_bit(3L,(unsigned long volatile *)(& vsi->state));
  
#line 6869 
  vsi->flags = 0UL;
  
#line 6870 
  vsi->idx = (unsigned short)vsi_idx;
  
#line 6871 
  vsi->rx_itr_setting = pf->rx_itr_default;
  
#line 6872 
  vsi->tx_itr_setting = pf->tx_itr_default;
  
#line 6873 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) 
#line 6873 
                                                vsi->rss_table_size = pf->rss_table_size; else 
                                                                    
#line 6873 
                                                                    vsi->rss_table_size = (unsigned short)64U;
  
#line 6875 
  vsi->netdev_registered = (_Bool)0;
  
#line 6876 
  vsi->work_limit = (unsigned short)256U;
  
#line 6877 
  INIT_LIST_HEAD(& vsi->mac_filter_list);
  
#line 6878 
  vsi->irqs_ready = (_Bool)0;
  
#line 6880 
  ret = i40e_set_num_rings_in_vsi(vsi);
  
#line 6881 
  if (ret != 0) 
#line 6882 
                goto err_rings; else ;
  
#line 6884 
  ret = i40e_vsi_alloc_arrays(vsi,(_Bool)1);
  
#line 6885 
  if (ret != 0) 
#line 6886 
                goto err_rings; else ;
  
#line 6889 
  i40e_vsi_setup_irqhandler(vsi,& i40e_msix_clean_rings);
  
#line 6891 
  *(pf->vsi + vsi_idx) = vsi;
  
#line 6892 
  ret = vsi_idx;
  
#line 6893 
  goto unlock_pf;
  err_rings: 
#line 6895 
  ;
  
#line 6896 
  pf->next_vsi = (unsigned short)((unsigned int)((unsigned short)i) + 65535U);
  
#line 6897 
  kfree((void const *)vsi);
  unlock_pf: 
#line 6898 
  ;
  
#line 6899 
  ldv_mutex_unlock_83(& pf->switch_mutex);
  
#line 6900 
  return ret;
}


#line 6911  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_arrays(struct i40e_vsi *vsi, bool free_qvectors)
{
  
#line 6914 
  if ((int)free_qvectors != 0) {
    
#line 6915 
    kfree((void const *)vsi->q_vectors);
    
#line 6916 
    vsi->q_vectors = (struct i40e_q_vector **)0;
  }
  else ;
  
#line 6918 
  kfree((void const *)vsi->tx_rings);
  
#line 6919 
  vsi->tx_rings = (struct i40e_ring **)0;
  
#line 6920 
  vsi->rx_rings = (struct i40e_ring **)0;
  
#line 6921 
  return;
}


#line 6927  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_clear(struct i40e_vsi *vsi)
{
  int __retres;
  struct i40e_pf *pf;
  
#line 6931 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 6932 
    __retres = 0;
    
#line 6932 
    goto return_label;
  }
  else ;
  
#line 6934 
  if (vsi->back == (struct i40e_pf *)0) 
#line 6935 
                                        goto free_vsi; else ;
  
#line 6936 
  pf = vsi->back;
  
#line 6938 
  ldv_mutex_lock_84(& pf->switch_mutex);
  
#line 6939 
  if (*(pf->vsi + (int)vsi->idx) == (struct i40e_vsi *)0) {
    
#line 6940 
    dev_err((struct device const *)(& (pf->pdev)->dev),"pf->vsi[%d] is NULL, just free vsi[%d](%p,type %d)\n",(int)vsi->idx,(int)vsi->idx,vsi,(unsigned int)vsi->type);
    
#line 6942 
    goto unlock_vsi;
  }
  else ;
  
#line 6945 
  if (*(pf->vsi + (int)vsi->idx) != vsi) {
    
#line 6946 
    dev_err((struct device const *)(& (pf->pdev)->dev),"pf->vsi[%d](%p, type %d) != vsi[%d](%p,type %d): no free!\n",(int)(*(pf->vsi + (int)vsi->idx))->idx,*(pf->vsi + (int)vsi->idx),(unsigned int)(*(pf->vsi + (int)vsi->idx))->type,(int)vsi->idx,vsi,(unsigned int)vsi->type);
    
#line 6952 
    goto unlock_vsi;
  }
  else ;
  
#line 6956 
  i40e_put_lump(pf->qp_pile,(unsigned short)((int)vsi->base_queue),(unsigned short)((int)vsi->idx));
  
#line 6957 
  i40e_put_lump(pf->irq_pile,(unsigned short)((int)((unsigned short)vsi->base_vector)),(unsigned short)((int)vsi->idx));
  
#line 6959 
  i40e_vsi_free_arrays(vsi,(_Bool)1);
  
#line 6961 
  *(pf->vsi + (int)vsi->idx) = (struct i40e_vsi *)0;
  
#line 6962 
  if ((int)vsi->idx < (int)pf->next_vsi) 
#line 6963 
                                         pf->next_vsi = vsi->idx; else ;
  unlock_vsi: 
#line 6965 
  ;
  
#line 6966 
  ldv_mutex_unlock_85(& pf->switch_mutex);
  free_vsi: 
#line 6967 
  ;
  
#line 6968 
  kfree((void const *)vsi);
  
#line 6970 
  __retres = 0;
  return_label: 
#line 6970 
                return __retres;
}


#line 6983 
void __compiletime_assert_6983(void);


#line 6977  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_clear_rings(struct i40e_vsi *vsi)
{
  int i;
  
#line 6981 
  if (vsi->tx_rings != (struct i40e_ring **)0 && *(vsi->tx_rings) != (struct i40e_ring *)0) {
    
#line 6982 
    i = 0;
    
#line 6982 
    goto ldv_63523;
    ldv_63522: 
#line 6983 
    ;
    {
      
#line 6983 
      bool __cond = (_Bool)0;
      
#line 6983 
      if ((int)__cond != 0) 
#line 6983 
                            __compiletime_assert_6983(); else ;
    }
    
#line 6983 
    kfree_call_rcu(& (*(vsi->tx_rings + i))->rcu,(void (*)(struct callback_head *))168);
    
#line 6984 
    *(vsi->tx_rings + i) = (struct i40e_ring *)0;
    
#line 6985 
    *(vsi->rx_rings + i) = (struct i40e_ring *)0;
    
#line 6982 
    i += 1;
    ldv_63523: 
#line 6983 
    ;
    
#line 6982 
    if ((int)vsi->alloc_queue_pairs > i) 
#line 6984 
                                         goto ldv_63522; else 
#line 6987 
                                                              goto ldv_63524;
    ldv_63524: 
#line 6988 
    ;
  }
  else ;
  
#line 6990 
  return;
}


#line 6994  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_alloc_rings(struct i40e_vsi *vsi)
{
  int __retres;
  struct i40e_ring *tx_ring;
  struct i40e_ring *rx_ring;
  int i;
  
#line 6997 
  struct i40e_pf *pf = vsi->back;
  
#line 7001 
  i = 0;
  
#line 7001 
  goto ldv_63534;
  ldv_63533: 
#line 7002 
  ;
  
#line 7003 
  tx_ring = (struct i40e_ring *)kzalloc_0(8192UL,208U);
  
#line 7004 
  if (tx_ring == (struct i40e_ring *)0) 
#line 7005 
                                        goto err_out; else ;
  
#line 7007 
  tx_ring->queue_index = (unsigned short)i;
  
#line 7008 
  tx_ring->reg_idx = (unsigned short)((int)vsi->base_queue + (int)((unsigned short)i));
  
#line 7009 
  tx_ring->ring_active = (_Bool)0;
  
#line 7010 
  tx_ring->vsi = vsi;
  
#line 7011 
  tx_ring->netdev = vsi->netdev;
  
#line 7012 
  tx_ring->dev = & (pf->pdev)->dev;
  
#line 7013 
  tx_ring->count = vsi->num_desc;
  
#line 7014 
  tx_ring->size = 0U;
  
#line 7015 
  tx_ring->dcb_tc = (unsigned char)0U;
  
#line 7016 
  *(vsi->tx_rings + i) = tx_ring;
  
#line 7018 
  rx_ring = tx_ring + 1U;
  
#line 7019 
  rx_ring->queue_index = (unsigned short)i;
  
#line 7020 
  rx_ring->reg_idx = (unsigned short)((int)vsi->base_queue + (int)((unsigned short)i));
  
#line 7021 
  rx_ring->ring_active = (_Bool)0;
  
#line 7022 
  rx_ring->vsi = vsi;
  
#line 7023 
  rx_ring->netdev = vsi->netdev;
  
#line 7024 
  rx_ring->dev = & (pf->pdev)->dev;
  
#line 7025 
  rx_ring->count = vsi->num_desc;
  
#line 7026 
  rx_ring->size = 0U;
  
#line 7027 
  rx_ring->dcb_tc = (unsigned char)0U;
  
#line 7028 
  if ((pf->flags & 8192ULL) != 0ULL) 
#line 7029 
                                     clear_bit(5L,(unsigned long volatile *)(& rx_ring->state)); else 
                                                                    
#line 7031 
                                                                    clear_bit(5L,(unsigned long volatile *)(& rx_ring->state));
  
#line 7032 
  *(vsi->rx_rings + i) = rx_ring;
  
#line 7001 
  i += 1;
  ldv_63534: 
#line 7002 
  ;
  
#line 7001 
  if ((int)vsi->alloc_queue_pairs > i) 
#line 7003 
                                       goto ldv_63533; else 
#line 7006 
                                                            goto ldv_63535;
  ldv_63535: 
#line 7007 
  ;
  
#line 7035 
  __retres = 0;
  
#line 7035 
  goto return_label;
  err_out: 
#line 7037 
  ;
  
#line 7038 
  i40e_vsi_clear_rings(vsi);
  
#line 7039 
  __retres = -12;
  return_label: 
#line 7039 
                return __retres;
}


#line 7049  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_reserve_msix_vectors(struct i40e_pf *pf, int vectors)
{
  
#line 7051 
  vectors = pci_enable_msix_range(pf->pdev,pf->msix_entries,2,vectors);
  
#line 7053 
  if (vectors < 0) {
    
#line 7054 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"MSI-X vector reservation failed: %d\n",vectors);
    
#line 7056 
    vectors = 0;
  }
  else ;
  
#line 7059 
  return vectors;
}


#line 7070  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_msix(struct i40e_pf *pf)
{
  int __retres;
  int vectors_left;
  int v_budget;
  int i;
  int v_actual;
  int tmp_1;
  
#line 7072 
  struct i40e_hw *hw = & pf->hw;
  
#line 7077 
  if ((pf->flags & 8ULL) == 0ULL) {
    
#line 7078 
    __retres = -19;
    
#line 7078 
    goto return_label;
  }
  else ;
  
#line 7097 
  vectors_left = (int)hw->func_caps.num_msix_vectors;
  
#line 7098 
  v_budget = 0;
  
#line 7101 
  if (vectors_left != 0) {
    
#line 7102 
    v_budget += 1;
    
#line 7103 
    vectors_left -= 1;
  }
  else ;
  {
    unsigned int tmp;
    int tmp_0;
    
#line 7107 
    tmp = cpumask_weight(cpu_online_mask);
    
#line 7107 
    int __min1 = (int)tmp;
    
#line 7107 
    int __min2 = vectors_left;
    
#line 7107 
    if (__min1 < __min2) 
#line 7107 
                         tmp_0 = __min1; else 
#line 7107 
                                              tmp_0 = __min2;
    
#line 7107 
    tmp_1 = tmp_0;
  }
  
#line 7107 
  pf->num_lan_msix = (unsigned short)tmp_1;
  
#line 7108 
  vectors_left -= (int)pf->num_lan_msix;
  
#line 7109 
  v_budget = (int)pf->num_lan_msix + v_budget;
  
#line 7112 
  if ((pf->flags & 2097152ULL) != 0ULL) 
    
#line 7113 
    if (vectors_left != 0) {
      
#line 7114 
      v_budget += 1;
      
#line 7115 
      vectors_left -= 1;
    }
    else 
#line 7117 
         pf->flags &= 18446744073707454463ULL;
  else ;
  
#line 7123 
  if ((pf->flags & 2048ULL) != 0ULL) {
    
#line 7124 
    if (vectors_left == 0) 
#line 7125 
                           pf->num_fcoe_msix = (unsigned short)0U;
    else 
      
#line 7126 
      if ((int)pf->num_fcoe_qps <= vectors_left) 
#line 7127 
                                                 pf->num_fcoe_msix = pf->num_fcoe_qps; else 
                                                                    
#line 7129 
                                                                    pf->num_fcoe_msix = (unsigned short)1U;
    
#line 7130 
    v_budget = (int)pf->num_fcoe_msix + v_budget;
    
#line 7131 
    vectors_left -= (int)pf->num_fcoe_msix;
  }
  else ;
  
#line 7136 
  if ((pf->flags & 128ULL) != 0ULL) {
    int tmp_3;
    
#line 7137 
    int vmdq_vecs_wanted = (int)pf->num_vmdq_vsis * (int)pf->num_vmdq_qps;
    {
      int tmp_2;
      
#line 7138 
      int __min1_0 = vectors_left;
      
#line 7138 
      int __min2_0 = vmdq_vecs_wanted;
      
#line 7138 
      if (__min1_0 < __min2_0) 
#line 7138 
                               tmp_2 = __min1_0; else 
#line 7138 
                                                      tmp_2 = __min2_0;
      
#line 7138 
      tmp_3 = tmp_2;
    }
    
#line 7138 
    int vmdq_vecs = tmp_3;
    
#line 7146 
    if (vmdq_vecs < vmdq_vecs_wanted) 
#line 7147 
                                      pf->num_vmdq_qps = (unsigned short)1U; else ;
    
#line 7148 
    pf->num_vmdq_msix = pf->num_vmdq_qps;
    
#line 7150 
    v_budget += vmdq_vecs;
    
#line 7151 
    vectors_left -= vmdq_vecs;
  }
  else ;
  
#line 7154 
  pf->msix_entries = (struct msix_entry *)kcalloc((unsigned long)v_budget,8UL,208U);
  
#line 7156 
  if (pf->msix_entries == (struct msix_entry *)0) {
    
#line 7157 
    __retres = -12;
    
#line 7157 
    goto return_label;
  }
  else ;
  
#line 7159 
  i = 0;
  
#line 7159 
  goto ldv_63557;
  ldv_63556: 
#line 7160 
  ;
  
#line 7160 
  (pf->msix_entries + i)->entry = (unsigned short)i;
  
#line 7159 
  i += 1;
  ldv_63557: 
#line 7160 
  ;
  
#line 7159 
  if (i < v_budget) 
#line 7161 
                    goto ldv_63556; else 
#line 7164 
                                         goto ldv_63558;
  ldv_63558: 
#line 7165 
  ;
  
#line 7161 
  v_actual = i40e_reserve_msix_vectors(pf,v_budget);
  
#line 7163 
  if (v_actual != v_budget) {
    
#line 7170 
    pf->num_fcoe_qps = (unsigned short)0U;
    
#line 7171 
    pf->num_fcoe_msix = (unsigned short)0U;
    
#line 7173 
    pf->num_vmdq_msix = (unsigned short)0U;
  }
  else ;
  
#line 7176 
  if (v_actual <= 1) {
    
#line 7177 
    pf->flags &= 18446744073709551607ULL;
    
#line 7178 
    kfree((void const *)pf->msix_entries);
    
#line 7179 
    pf->msix_entries = (struct msix_entry *)0;
    
#line 7180 
    __retres = -19;
    
#line 7180 
    goto return_label;
  }
  else 
    
#line 7182 
    if (v_actual == 2) {
      
#line 7184 
      pf->num_vmdq_vsis = (unsigned short)0U;
      
#line 7185 
      pf->num_vmdq_qps = (unsigned short)0U;
      
#line 7186 
      pf->num_lan_qps = (unsigned short)1U;
      
#line 7187 
      pf->num_lan_msix = (unsigned short)1U;
    }
    else 
      
#line 7189 
      if (v_actual != v_budget) {
        int vec;
        
#line 7193 
        vec = v_actual + -1;
        
#line 7196 
        pf->num_vmdq_msix = (unsigned short)1U;
        
#line 7197 
        pf->num_vmdq_vsis = (unsigned short)1U;
        
#line 7198 
        pf->num_vmdq_qps = (unsigned short)1U;
        
#line 7199 
        pf->flags &= 18446744073707454463ULL;
        
#line 7202 
        switch (vec) {
          int tmp_6;
          case 2: 
#line 7203 
          ;
          
#line 7204 
          pf->num_lan_msix = (unsigned short)1U;
          
#line 7205 
          goto ldv_63561;
          case 3: 
#line 7206 
          ;
          
#line 7209 
          if ((pf->flags & 2048ULL) != 0ULL) {
            
#line 7210 
            pf->num_lan_msix = (unsigned short)1U;
            
#line 7211 
            pf->num_fcoe_msix = (unsigned short)1U;
          }
          else ;
          
#line 7216 
          goto ldv_63561;
          default: 
#line 7217 
          ;
          
#line 7220 
          if ((pf->flags & 2048ULL) != 0ULL) {
            
#line 7221 
            pf->num_fcoe_msix = (unsigned short)1U;
            
#line 7222 
            vec -= 1;
          }
          else ;
          {
            int tmp_5;
            
#line 7226 
            int __min1_1 = vec;
            
#line 7226 
            int __min2_1 = (int)pf->num_lan_qps;
            
#line 7226 
            if (__min1_1 < __min2_1) 
#line 7226 
                                     tmp_5 = __min1_1; else 
#line 7226 
                                                            tmp_5 = __min2_1;
            
#line 7226 
            tmp_6 = tmp_5;
          }
          
#line 7226 
          pf->num_lan_msix = (unsigned short)tmp_6;
          
#line 7227 
          goto ldv_63561;
        }
        ldv_63561: 
#line 7229 
        ;
      }
      else ;
  
#line 7231 
  if ((pf->flags & 128ULL) != 0ULL && (unsigned int)pf->num_vmdq_msix == 0U) {
    
#line 7233 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"VMDq disabled, not enough MSI-X vectors\n");
    
#line 7234 
    pf->flags &= 18446744073709551487ULL;
  }
  else ;
  
#line 7238 
  if ((pf->flags & 2048ULL) != 0ULL && (unsigned int)pf->num_fcoe_msix == 0U) {
    
#line 7239 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"FCOE disabled, not enough MSI-X vectors\n");
    
#line 7240 
    pf->flags &= 18446744073709549567ULL;
  }
  else ;
  
#line 7243 
  __retres = v_actual;
  return_label: 
#line 7243 
                return __retres;
}


#line 7253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_alloc_q_vector(struct i40e_vsi *vsi, int v_idx)
{
  int __retres;
  struct i40e_q_vector *q_vector;
  
#line 7258 
  q_vector = (struct i40e_q_vector *)kzalloc_0(4096UL,208U);
  
#line 7259 
  if (q_vector == (struct i40e_q_vector *)0) {
    
#line 7260 
    __retres = -12;
    
#line 7260 
    goto return_label;
  }
  else ;
  
#line 7262 
  q_vector->vsi = vsi;
  
#line 7263 
  q_vector->v_idx = (unsigned short)v_idx;
  
#line 7264 
  cpumask_set_cpu((unsigned int)v_idx,& q_vector->affinity_mask);
  
#line 7265 
  if (vsi->netdev != (struct net_device *)0) 
#line 7266 
                                             netif_napi_add(vsi->netdev,& q_vector->napi,& i40e_napi_poll,64); else ;
  
#line 7269 
  q_vector->rx.latency_range = I40E_LOW_LATENCY;
  
#line 7270 
  q_vector->tx.latency_range = I40E_LOW_LATENCY;
  
#line 7273 
  *(vsi->q_vectors + v_idx) = q_vector;
  
#line 7275 
  __retres = 0;
  return_label: 
#line 7275 
                return __retres;
}


#line 7285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_alloc_q_vectors(struct i40e_vsi *vsi)
{
  int __retres;
  int v_idx;
  int num_q_vectors;
  int err;
  int tmp;
  
#line 7287 
  struct i40e_pf *pf = vsi->back;
  
#line 7292 
  if ((pf->flags & 8ULL) != 0ULL) 
#line 7293 
                                  num_q_vectors = vsi->num_q_vectors;
  else 
    
#line 7294 
    if (*(pf->vsi + (int)pf->lan_vsi) == vsi) 
#line 7295 
                                              num_q_vectors = 1;
    else {
      
#line 7297 
      __retres = -22;
      
#line 7297 
      goto return_label;
    }
  
#line 7299 
  v_idx = 0;
  
#line 7299 
  goto ldv_63581;
  ldv_63580: 
#line 7300 
  ;
  
#line 7300 
  err = i40e_vsi_alloc_q_vector(vsi,v_idx);
  
#line 7301 
  if (err != 0) 
#line 7302 
                goto err_out; else ;
  
#line 7299 
  v_idx += 1;
  ldv_63581: 
#line 7300 
  ;
  
#line 7299 
  if (v_idx < num_q_vectors) 
#line 7301 
                             goto ldv_63580; else 
#line 7304 
                                                  goto ldv_63582;
  ldv_63582: 
#line 7305 
  ;
  
#line 7305 
  __retres = 0;
  
#line 7305 
  goto return_label;
  err_out: 
#line 7307 
  ;
  
#line 7308 
  goto ldv_63584;
  ldv_63583: 
#line 7309 
  ;
  
#line 7309 
  i40e_free_q_vector(vsi,v_idx);
  ldv_63584: 
#line 7310 
  ;
  
#line 7308 
  tmp = v_idx;
  
#line 7308 
  v_idx -= 1;
  
#line 7308 
  ;
  
#line 7308 
  if (tmp != 0) 
#line 7310 
                goto ldv_63583; else 
#line 7313 
                                     goto ldv_63585;
  ldv_63585: 
#line 7314 
  ;
  
#line 7311 
  __retres = err;
  return_label: 
#line 7311 
                return __retres;
}


#line 7318  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_interrupt_scheme(struct i40e_pf *pf)
{
  int __retres;
  ssize_t size;
  
#line 7320 
  int vectors = 0;
  
#line 7323 
  if ((pf->flags & 8ULL) != 0ULL) {
    
#line 7324 
    vectors = i40e_init_msix(pf);
    
#line 7325 
    if (vectors < 0) {
      
#line 7326 
      pf->flags &= 18446744073165862711ULL;
      
#line 7338 
      i40e_determine_queue_usage(pf);
    }
    else ;
  }
  else ;
  
#line 7342 
  if ((pf->flags & 8ULL) == 0ULL && (pf->flags & 4ULL) != 0ULL) {
    
#line 7344 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"MSI-X not available, trying MSI\n");
    
#line 7345 
    vectors = pci_enable_msi_exact(pf->pdev,1);
    
#line 7346 
    if (vectors < 0) {
      
#line 7347 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"MSI init failed - %d\n",vectors);
      
#line 7349 
      pf->flags &= 18446744073709551611ULL;
    }
    else ;
    
#line 7351 
    vectors = 1;
  }
  else ;
  
#line 7354 
  if ((pf->flags & 12ULL) == 0ULL) 
#line 7355 
                                   _dev_info((struct device const *)(& (pf->pdev)->dev),"MSI-X and MSI not available, falling back to Legacy IRQ\n"); else ;
  
#line 7358 
  size = (long)(((unsigned long)vectors + 2UL) * 2UL);
  
#line 7359 
  pf->irq_pile = (struct i40e_lump_tracking *)kzalloc_0((unsigned long)size,208U);
  
#line 7360 
  if (pf->irq_pile == (struct i40e_lump_tracking *)0) {
    
#line 7361 
    dev_err((struct device const *)(& (pf->pdev)->dev),"error allocating irq_pile memory\n");
    
#line 7362 
    __retres = -12;
    
#line 7362 
    goto return_label;
  }
  else ;
  
#line 7364 
  (pf->irq_pile)->num_entries = (unsigned short)vectors;
  
#line 7365 
  (pf->irq_pile)->search_hint = (unsigned short)0U;
  
#line 7368 
  i40e_get_lump(pf,pf->irq_pile,(unsigned short)1,(unsigned short)32767);
  
#line 7370 
  __retres = 0;
  return_label: 
#line 7370 
                return __retres;
}


#line 7381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_misc_vector(struct i40e_pf *pf)
{
  int __retres;
  int tmp;
  
#line 7383 
  struct i40e_hw *hw = & pf->hw;
  
#line 7384 
  int err = 0;
  
#line 7389 
  tmp = constant_test_bit(9L,(unsigned long const volatile *)(& pf->state));
  
#line 7389 
  if (tmp == 0) {
    
#line 7390 
    err = ldv_request_irq_86((pf->msix_entries)->vector,& i40e_intr,0UL,(char const *)(& pf->int_name),(void *)pf);
    
#line 7392 
    if (err != 0) {
      
#line 7393 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"request_irq for %s failed: %d\n",(char *)(& pf->int_name),err);
      
#line 7396 
      __retres = -14;
      
#line 7396 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 7400 
  i40e_enable_misc_int_causes(pf);
  
#line 7403 
  writel(2047U,(void volatile *)(hw->hw_addr + 230656U));
  
#line 7404 
  writel(62U,(void volatile *)(hw->hw_addr + 229376U));
  
#line 7406 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 7408 
  i40e_irq_dynamic_enable_icr0(pf);
  
#line 7410 
  __retres = err;
  return_label: 
#line 7410 
                return __retres;
}


#line 7417  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_config_rss(struct i40e_pf *pf)
{
  int __retres;
  u32 rss_key[13U];
  int i;
  int j;
  u64 hena;
  u32 reg_val;
  unsigned int tmp;
  unsigned int tmp_0;
  int tmp_2;
  
#line 7420 
  struct i40e_vsi *vsi = *(pf->vsi + (int)pf->lan_vsi);
  
#line 7421 
  struct i40e_hw *hw = & pf->hw;
  
#line 7422 
  u32 lut = 0U;
  
#line 7427 
  netdev_rss_key_fill((void *)(& rss_key),52UL);
  
#line 7428 
  i = 0;
  
#line 7428 
  goto ldv_63608;
  ldv_63607: 
#line 7429 
  ;
  
#line 7429 
  writel(rss_key[i],(void volatile *)(hw->hw_addr + (i + 18576) * 128));
  
#line 7428 
  i += 1;
  ldv_63608: 
#line 7429 
  ;
  
#line 7428 
  if (i <= 12) 
#line 7430 
               goto ldv_63607; else 
#line 7433 
                                    goto ldv_63609;
  ldv_63609: 
#line 7434 
  ;
  
#line 7432 
  tmp = readl((void const volatile *)(hw->hw_addr + 2382080U));
  
#line 7433 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + 2382208U));
  
#line 7432 
  hena = (unsigned long long)tmp | ((unsigned long long)tmp_0 << 32);
  
#line 7434 
  hena |= 9223506308269867008ULL;
  
#line 7435 
  writel((unsigned int)hena,(void volatile *)(hw->hw_addr + 2382080U));
  
#line 7436 
  writel((unsigned int)(hena >> 32),(void volatile *)(hw->hw_addr + 2382208U));
  {
    int tmp_1;
    
#line 7438 
    int __min1 = (int)pf->rss_size;
    
#line 7438 
    int __min2 = (int)vsi->num_queue_pairs;
    
#line 7438 
    if (__min1 < __min2) 
#line 7438 
                         tmp_1 = __min1; else 
#line 7438 
                                              tmp_1 = __min2;
    
#line 7438 
    tmp_2 = tmp_1;
  }
  
#line 7438 
  vsi->rss_size = (unsigned short)tmp_2;
  
#line 7441 
  reg_val = readl((void const volatile *)(hw->hw_addr + 1837760U));
  
#line 7442 
  if ((unsigned int)pf->rss_table_size == 512U) 
#line 7443 
                                                reg_val |= 65536U; else 
                                                                    
#line 7445 
                                                                    reg_val &= 4294901759U;
  
#line 7446 
  writel(reg_val,(void volatile *)(hw->hw_addr + 1837760U));
  
#line 7449 
  i = 0;
  
#line 7449 
  j = 0;
  
#line 7449 
  goto ldv_63614;
  ldv_63613: 
#line 7450 
  ;
  
#line 7458 
  if ((int)vsi->rss_size == j) 
#line 7459 
                               j = 0; else ;
  
#line 7461 
  lut = (lut << 8) | (unsigned int)(((1 << pf->hw.func_caps.rss_table_entry_width) + -1) & j);
  
#line 7464 
  if ((i & 3) == 3) 
#line 7465 
                    writel(lut,(void volatile *)(hw->hw_addr + ((i >> 2) + 18432) * 128)); else ;
  
#line 7449 
  i += 1;
  
#line 7449 
  j += 1;
  ldv_63614: 
#line 7450 
  ;
  
#line 7449 
  if ((int)pf->rss_table_size > i) 
#line 7451 
                                   goto ldv_63613; else 
#line 7454 
                                                        goto ldv_63615;
  ldv_63615: 
#line 7455 
  ;
  
#line 7467 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 7469 
  __retres = 0;
  
#line 7469 
  return __retres;
}


#line 7480  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
  int __retres;
  int new_rss_size;
  int tmp_0;
  
#line 7482 
  struct i40e_vsi *vsi = *(pf->vsi + (int)pf->lan_vsi);
  
#line 7485 
  if ((pf->flags & 64ULL) == 0ULL) {
    
#line 7486 
    __retres = 0;
    
#line 7486 
    goto return_label;
  }
  else ;
  {
    int tmp;
    
#line 7488 
    int __min1 = queue_count;
    
#line 7488 
    int __min2 = (int)pf->rss_size_max;
    
#line 7488 
    if (__min1 < __min2) 
#line 7488 
                         tmp = __min1; else 
#line 7488 
                                            tmp = __min2;
    
#line 7488 
    tmp_0 = tmp;
  }
  
#line 7488 
  new_rss_size = tmp_0;
  
#line 7490 
  if ((int)vsi->num_queue_pairs != queue_count) {
    
#line 7491 
    vsi->req_queue_pairs = (unsigned short)queue_count;
    
#line 7492 
    i40e_prep_for_reset(pf);
    
#line 7494 
    pf->rss_size = (unsigned short)new_rss_size;
    
#line 7496 
    i40e_reset_and_rebuild(pf,(_Bool)1);
    
#line 7497 
    i40e_config_rss(pf);
  }
  else ;
  
#line 7499 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"RSS count:  %d\n",(int)pf->rss_size);
  
#line 7500 
  __retres = (int)pf->rss_size;
  return_label: 
#line 7500 
                return __retres;
}


#line 7507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_get_npar_bw_setting(struct i40e_pf *pf)
{
  i40e_status status;
  bool min_valid;
  bool max_valid;
  u32 max_bw;
  u32 min_bw;
  
#line 7513 
  status = i40e_read_bw_from_alt_ram(& pf->hw,& max_bw,& min_bw,& min_valid,& max_valid);
  
#line 7516 
  if (status == I40E_SUCCESS) {
    
#line 7517 
    if ((int)min_valid != 0) 
#line 7518 
                             pf->npar_min_bw = min_bw; else ;
    
#line 7519 
    if ((int)max_valid != 0) 
#line 7520 
                             pf->npar_max_bw = max_bw; else ;
  }
  else ;
  
#line 7523 
  return status;
}


#line 7530  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_set_npar_bw_setting(struct i40e_pf *pf)
{
  struct i40e_aqc_configure_partition_bw_data bw_data;
  i40e_status status;
  
#line 7536 
  bw_data.pf_valid_bits = (unsigned short)(1 << (int)pf->hw.pf_id);
  
#line 7537 
  bw_data.max_bw[(int)pf->hw.pf_id] = (unsigned char)pf->npar_max_bw;
  
#line 7538 
  bw_data.min_bw[(int)pf->hw.pf_id] = (unsigned char)pf->npar_min_bw;
  
#line 7541 
  status = i40e_aq_configure_partition_bw(& pf->hw,& bw_data,(struct i40e_asq_cmd_details *)0);
  
#line 7543 
  return status;
}


#line 7550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_commit_npar_bw_setting(struct i40e_pf *pf)
{
  enum i40e_admin_queue_err last_aq_status;
  i40e_status ret;
  u16 nvm_word;
  
#line 7557 
  if ((unsigned int)pf->hw.partition_id != 1U) {
    
#line 7558 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Commit BW only works on partition 1! This is partition %d",(int)pf->hw.partition_id);
    
#line 7561 
    ret = I40E_NOT_SUPPORTED;
    
#line 7562 
    goto bw_commit_out;
  }
  else ;
  
#line 7566 
  ret = i40e_acquire_nvm(& pf->hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  
#line 7567 
  last_aq_status = pf->hw.aq.asq_last_status;
  
#line 7568 
  if (ret != I40E_SUCCESS) {
    
#line 7569 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Cannot acquire NVM for read access, err %d: aq_err %d\n",(int)ret,(unsigned int)last_aq_status);
    
#line 7572 
    goto bw_commit_out;
  }
  else ;
  
#line 7576 
  ret = i40e_aq_read_nvm(& pf->hw,(unsigned char)0,16U,(unsigned short)2,(void *)(& nvm_word),(_Bool)0,(struct i40e_asq_cmd_details *)0);
  
#line 7583 
  last_aq_status = pf->hw.aq.asq_last_status;
  
#line 7584 
  i40e_release_nvm(& pf->hw);
  
#line 7585 
  if (ret != I40E_SUCCESS) {
    
#line 7586 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"NVM read error, err %d aq_err %d\n",(int)ret,(unsigned int)last_aq_status);
    
#line 7588 
    goto bw_commit_out;
  }
  else ;
  
#line 7592 
  msleep(50U);
  
#line 7595 
  ret = i40e_acquire_nvm(& pf->hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
  
#line 7596 
  last_aq_status = pf->hw.aq.asq_last_status;
  
#line 7597 
  if (ret != I40E_SUCCESS) {
    
#line 7598 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Cannot acquire NVM for write access, err %d: aq_err %d\n",(int)ret,(unsigned int)last_aq_status);
    
#line 7601 
    goto bw_commit_out;
  }
  else ;
  
#line 7607 
  ret = i40e_aq_update_nvm(& pf->hw,(unsigned char)0,16U,(unsigned short)2,(void *)(& nvm_word),(_Bool)1,(struct i40e_asq_cmd_details *)0);
  
#line 7614 
  last_aq_status = pf->hw.aq.asq_last_status;
  
#line 7615 
  i40e_release_nvm(& pf->hw);
  
#line 7616 
  if (ret != I40E_SUCCESS) 
#line 7617 
                           _dev_info((struct device const *)(& (pf->pdev)->dev),"BW settings NOT SAVED, err %d aq_err %d\n",(int)ret,(unsigned int)last_aq_status); else ;
  bw_commit_out: 
#line 7620 
  ;
  
#line 7622 
  return ret;
}


#line 7633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_sw_init(struct i40e_pf *pf)
{
  int size;
  bool tmp;
  int tmp_1;
  
#line 7635 
  int err = 0;
  
#line 7638 
  pf->msg_enable = netif_msg_init(4,7);
  
#line 7640 
  pf->hw.debug_mask = pf->msg_enable | 2048U;
  
#line 7641 
  if (debug != -1 && debug != 4) {
    
#line 7642 
    if (((unsigned int)debug & 4026531840U) != 0U) 
#line 7643 
                                                   pf->hw.debug_mask = (unsigned int)debug; else ;
    
#line 7644 
    pf->msg_enable = netif_msg_init(debug & 268435455,4);
  }
  else ;
  
#line 7649 
  pf->flags = 14ULL;
  
#line 7653 
  tmp = iommu_present(& pci_bus_type);
  
#line 7653 
  if ((int)tmp != 0) 
#line 7654 
                     pf->flags |= 32ULL; else 
#line 7656 
                                              pf->flags |= 16ULL;
  
#line 7659 
  pf->rx_itr_default = (unsigned short)32830U;
  
#line 7660 
  pf->tx_itr_default = (unsigned short)32890U;
  
#line 7665 
  pf->rss_size_max = (unsigned short)(1 << pf->hw.func_caps.rss_table_entry_width);
  
#line 7666 
  pf->rss_size = (unsigned short)1U;
  
#line 7667 
  pf->rss_table_size = (unsigned short)pf->hw.func_caps.rss_table_size;
  {
    int tmp_0;
    
#line 7668 
    int __min1 = (int)pf->rss_size_max;
    
#line 7668 
    int __min2 = (int)pf->hw.func_caps.num_tx_qp;
    
#line 7668 
    if (__min1 < __min2) 
#line 7668 
                         tmp_0 = __min1; else 
#line 7668 
                                              tmp_0 = __min2;
    
#line 7668 
    tmp_1 = tmp_0;
  }
  
#line 7668 
  pf->rss_size_max = (unsigned short)tmp_1;
  
#line 7670 
  if ((int)pf->hw.func_caps.rss != 0) {
    int tmp_4;
    
#line 7671 
    pf->flags |= 64ULL;
    {
      unsigned int tmp_2;
      int tmp_3;
      
#line 7672 
      int __min1_0 = (int)pf->rss_size_max;
      
#line 7672 
      tmp_2 = cpumask_weight(cpu_online_mask);
      
#line 7672 
      int __min2_0 = (int)tmp_2;
      
#line 7672 
      if (__min1_0 < __min2_0) 
#line 7672 
                               tmp_3 = __min1_0; else 
#line 7672 
                                                      tmp_3 = __min2_0;
      
#line 7672 
      tmp_4 = tmp_3;
    }
    
#line 7672 
    pf->rss_size = (unsigned short)tmp_4;
  }
  else ;
  
#line 7676 
  if (pf->hw.func_caps.npar_enable != 0U || (int)pf->hw.func_caps.mfp_mode_1 != 0) {
    i40e_status tmp_5;
    
#line 7677 
    pf->flags |= 67108864ULL;
    
#line 7678 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"MFP mode Enabled\n");
    
#line 7679 
    tmp_5 = i40e_get_npar_bw_setting(pf);
    
#line 7679 
    if (tmp_5 != I40E_SUCCESS) 
#line 7680 
                               dev_warn((struct device const *)(& (pf->pdev)->dev),"Could not get NPAR bw settings\n"); else 
                                                                    
#line 7683 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"Min BW = %8.8x, Max BW = %8.8x\n",pf->npar_min_bw,pf->npar_max_bw);
  }
  else ;
  
#line 7689 
  if (pf->hw.func_caps.fd_filters_guaranteed != 0U || pf->hw.func_caps.fd_filters_best_effort != 0U) {
    
#line 7691 
    pf->flags |= 4194304ULL;
    
#line 7692 
    pf->atr_sample_rate = (unsigned char)20U;
    
#line 7693 
    if ((pf->flags & 67108864ULL) == 0ULL) 
#line 7694 
                                           pf->flags |= 2097152ULL; else 
                                                                    
#line 7696 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"Flow Director Sideband mode Disabled in MFP mode\n");
    
#line 7699 
    pf->fdir_pf_filter_count = (unsigned short)pf->hw.func_caps.fd_filters_guaranteed;
    
#line 7701 
    pf->hw.fdir_shared_filter_count = (unsigned short)pf->hw.func_caps.fd_filters_best_effort;
  }
  else ;
  
#line 7705 
  if ((int)pf->hw.func_caps.vmdq != 0) {
    
#line 7706 
    pf->flags |= 128ULL;
    
#line 7707 
    pf->num_vmdq_vsis = (unsigned short)8U;
    
#line 7708 
    pf->num_vmdq_qps = (unsigned short)2U;
  }
  else ;
  
#line 7712 
  err = i40e_init_pf_fcoe(pf);
  
#line 7713 
  if (err != 0) 
#line 7714 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"init_pf_fcoe failed: %d\n",err); else ;
  
#line 7718 
  if (pf->hw.func_caps.num_vfs != 0U && (unsigned int)pf->hw.partition_id == 1U) {
    int tmp_7;
    
#line 7719 
    pf->num_vf_qps = (unsigned short)4U;
    
#line 7720 
    pf->flags |= 524288ULL;
    {
      int tmp_6;
      
#line 7721 
      int __min1_1 = (int)pf->hw.func_caps.num_vfs;
      
#line 7721 
      int __min2_1 = 128;
      
#line 7721 
      if (__min1_1 < __min2_1) 
#line 7721 
                               tmp_6 = __min1_1; else 
#line 7721 
                                                      tmp_6 = __min2_1;
      
#line 7721 
      tmp_7 = tmp_6;
    }
    
#line 7721 
    pf->num_req_vfs = (unsigned short)tmp_7;
  }
  else ;
  
#line 7726 
  pf->eeprom_version = (unsigned short)57005U;
  
#line 7727 
  pf->lan_veb = (unsigned short)65535U;
  
#line 7728 
  pf->lan_vsi = (unsigned short)65535U;
  
#line 7731 
  size = (int)(((unsigned long)pf->hw.func_caps.num_tx_qp + 2UL) * (unsigned long)2U);
  
#line 7733 
  pf->qp_pile = (struct i40e_lump_tracking *)kzalloc_0((unsigned long)size,208U);
  
#line 7734 
  if (pf->qp_pile == (struct i40e_lump_tracking *)0) {
    
#line 7735 
    err = -12;
    
#line 7736 
    goto sw_init_done;
  }
  else ;
  
#line 7738 
  (pf->qp_pile)->num_entries = (unsigned short)pf->hw.func_caps.num_tx_qp;
  
#line 7739 
  (pf->qp_pile)->search_hint = (unsigned short)0U;
  
#line 7741 
  pf->tx_timeout_recovery_level = 1U;
  {
    struct lock_class_key __key;
    
#line 7743 
    __mutex_init(& pf->switch_mutex,"&pf->switch_mutex",& __key);
  }
  
#line 7746 
  if (pf->hw.func_caps.npar_enable != 0U) {
    i40e_status tmp_9;
    
#line 7746 
    tmp_9 = i40e_get_npar_bw_setting(pf);
    
#line 7746 
    if (tmp_9 == I40E_SUCCESS) 
#line 7747 
                               i40e_set_npar_bw_setting(pf); else ;
  }
  else ;
  sw_init_done: 
#line 7749 
  ;
  
#line 7750 
  return err;
}


#line 7760  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
bool i40e_set_ntuple(struct i40e_pf *pf, netdev_features_t features)
{
  
#line 7762 
  bool need_reset = (_Bool)0;
  
#line 7767 
  if ((features & 4294967296ULL) != 0ULL) {
    
#line 7769 
    if ((pf->flags & 2097152ULL) == 0ULL) 
#line 7770 
                                          need_reset = (_Bool)1; else ;
    
#line 7771 
    pf->flags |= 2097152ULL;
  }
  else {
    u32 tmp_0;
    u32 tmp;
    
#line 7774 
    if ((pf->flags & 2097152ULL) != 0ULL) {
      
#line 7775 
      need_reset = (_Bool)1;
      
#line 7776 
      i40e_fdir_filter_exit(pf);
    }
    else ;
    
#line 7778 
    pf->flags &= 18446744073707454463ULL;
    
#line 7779 
    pf->auto_disable_flags &= 18446744073707454463ULL;
    
#line 7781 
    tmp_0 = 0U;
    
#line 7781 
    pf->fd_tcp_rule = tmp_0;
    
#line 7781 
    tmp = tmp_0;
    
#line 7781 
    pf->fd_atr_cnt = tmp;
    
#line 7781 
    pf->fd_add_err = tmp;
    
#line 7782 
    pf->fdir_pf_active_filters = (unsigned short)0U;
    
#line 7783 
    pf->flags |= 4194304ULL;
    
#line 7784 
    if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 7785 
                                           _dev_info((struct device const *)(& (pf->pdev)->dev),"ATR re-enabled.\n"); else ;
    
#line 7787 
    if ((pf->flags & 4194304ULL) != 0ULL && (pf->auto_disable_flags & 4194304ULL) != 0ULL) 
      
#line 7789 
      pf->auto_disable_flags &= 18446744073705357311ULL; else ;
  }
  
#line 7791 
  return need_reset;
}


#line 7799  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_set_features(struct net_device *netdev, netdev_features_t features)
{
  int __retres;
  bool need_reset;
  
#line 7802 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 7803 
  struct i40e_vsi *vsi = np->vsi;
  
#line 7804 
  struct i40e_pf *pf = vsi->back;
  
#line 7807 
  if ((features & 256ULL) != 0ULL) 
#line 7808 
                                   i40e_vlan_stripping_enable(vsi); else 
                                                                    
#line 7810 
                                                                    i40e_vlan_stripping_disable(vsi);
  
#line 7812 
  need_reset = i40e_set_ntuple(pf,features);
  
#line 7814 
  if ((int)need_reset != 0) 
#line 7815 
                            i40e_do_reset(pf,4096U); else ;
  
#line 7817 
  __retres = 0;
  
#line 7817 
  return __retres;
}


#line 7828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_get_vxlan_port_idx(struct i40e_pf *pf, __be16 port)
{
  u8 __retres;
  u8 i;
  
#line 7832 
  i = (unsigned char)0U;
  
#line 7832 
  goto ldv_63680;
  ldv_63679: 
#line 7833 
  ;
  
#line 7833 
  if ((int)pf->vxlan_ports[(int)i] == (int)port) {
    
#line 7834 
    __retres = i;
    
#line 7834 
    goto return_label;
  }
  else ;
  
#line 7832 
  i = (u8)((int)i + 1);
  ldv_63680: 
#line 7833 
  ;
  
#line 7832 
  if ((unsigned int)i <= 15U) 
#line 7834 
                              goto ldv_63679; else 
#line 7837 
                                                   goto ldv_63681;
  ldv_63681: 
#line 7838 
  ;
  
#line 7837 
  __retres = i;
  return_label: 
#line 7837 
                return __retres;
}


#line 7846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_add_vxlan_port(struct net_device *netdev, sa_family_t sa_family, __be16 port)
{
  u8 next_idx;
  u8 idx;
  int tmp_5;
  
#line 7849 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 7850 
  struct i40e_vsi *vsi = np->vsi;
  
#line 7851 
  struct i40e_pf *pf = vsi->back;
  
#line 7855 
  if ((unsigned int)sa_family == 10U) 
#line 7856 
                                      goto return_label; else ;
  
#line 7858 
  idx = i40e_get_vxlan_port_idx(pf,(unsigned short)((int)port));
  
#line 7861 
  if ((unsigned int)idx <= 15U) {
    int tmp_1;
    
#line 7862 
    if (0 != 0) 
#line 7862 
                tmp_1 = (int)((unsigned short)(((int)port << 8) | ((int)port >> 8)));
    else {
      __u16 tmp_0;
      
#line 7863 
      tmp_0 = __fswab16((unsigned short)((int)port));
      
#line 7862 
      tmp_1 = (int)tmp_0;
    }
    
#line 7862 
    ;
    
#line 7862 
    netdev_info((struct net_device const *)netdev,"vxlan port %d already offloaded\n",tmp_1);
    
#line 7864 
    goto return_label;
  }
  else ;
  
#line 7868 
  next_idx = i40e_get_vxlan_port_idx(pf,(unsigned short)0);
  
#line 7870 
  if ((unsigned int)next_idx == 16U) {
    int tmp_3;
    
#line 7871 
    if (0 != 0) 
#line 7871 
                tmp_3 = (int)((unsigned short)(((int)port << 8) | ((int)port >> 8)));
    else {
      __u16 tmp_2;
      
#line 7872 
      tmp_2 = __fswab16((unsigned short)((int)port));
      
#line 7871 
      tmp_3 = (int)tmp_2;
    }
    
#line 7871 
    ;
    
#line 7871 
    netdev_info((struct net_device const *)netdev,"maximum number of vxlan UDP ports reached, not adding port %d\n",tmp_3);
    
#line 7873 
    goto return_label;
  }
  else ;
  
#line 7877 
  pf->vxlan_ports[(int)next_idx] = port;
  
#line 7878 
  pf->pending_vxlan_bitmap = (unsigned short)((int)pf->pending_vxlan_bitmap | (1 << (int)next_idx));
  
#line 7879 
  pf->flags |= 134217728ULL;
  
#line 7881 
  if (0 != 0) 
#line 7881 
              tmp_5 = (int)((unsigned short)(((int)port << 8) | ((int)port >> 8)));
  else {
    __u16 tmp_4;
    
#line 7881 
    tmp_4 = __fswab16((unsigned short)((int)port));
    
#line 7881 
    tmp_5 = (int)tmp_4;
  }
  
#line 7881 
  ;
  
#line 7881 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"adding vxlan port %d\n",tmp_5);
  return_label: 
#line 7882 
                return;
}


#line 7890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_del_vxlan_port(struct net_device *netdev, sa_family_t sa_family, __be16 port)
{
  u8 idx;
  
#line 7893 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 7894 
  struct i40e_vsi *vsi = np->vsi;
  
#line 7895 
  struct i40e_pf *pf = vsi->back;
  
#line 7898 
  if ((unsigned int)sa_family == 10U) 
#line 7899 
                                      goto return_label; else ;
  
#line 7901 
  idx = i40e_get_vxlan_port_idx(pf,(unsigned short)((int)port));
  
#line 7904 
  if ((unsigned int)idx <= 15U) {
    int tmp_1;
    
#line 7908 
    pf->vxlan_ports[(int)idx] = (unsigned short)0U;
    
#line 7909 
    pf->pending_vxlan_bitmap = (unsigned short)((int)pf->pending_vxlan_bitmap | (1 << (int)idx));
    
#line 7910 
    pf->flags |= 134217728ULL;
    
#line 7912 
    if (0 != 0) 
#line 7912 
                tmp_1 = (int)((unsigned short)(((int)port << 8) | ((int)port >> 8)));
    else {
      __u16 tmp_0;
      
#line 7912 
      tmp_0 = __fswab16((unsigned short)((int)port));
      
#line 7912 
      tmp_1 = (int)tmp_0;
    }
    
#line 7912 
    ;
    
#line 7912 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"deleting vxlan port %d\n",tmp_1);
  }
  else {
    int tmp_3;
    
#line 7915 
    if (0 != 0) 
#line 7915 
                tmp_3 = (int)((unsigned short)(((int)port << 8) | ((int)port >> 8)));
    else {
      __u16 tmp_2;
      
#line 7916 
      tmp_2 = __fswab16((unsigned short)((int)port));
      
#line 7915 
      tmp_3 = (int)tmp_2;
    }
    
#line 7915 
    ;
    
#line 7915 
    netdev_warn((struct net_device const *)netdev,"vxlan port %d was not found, not deleting\n",tmp_3);
  }
  return_label: 
#line 7917 
                return;
}


#line 7921  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_phys_port_id(struct net_device *netdev, struct netdev_phys_item_id *ppid)
{
  int __retres;
  int tmp_1;
  
#line 7924 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 7925 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 7926 
  struct i40e_hw *hw = & pf->hw;
  
#line 7928 
  if ((pf->flags & 268435456ULL) == 0ULL) {
    
#line 7929 
    __retres = -95;
    
#line 7929 
    goto return_label;
  }
  else ;
  {
    int tmp_0;
    
#line 7931 
    int __min1 = 6;
    
#line 7931 
    int __min2 = 32;
    
#line 7931 
    if (__min1 < __min2) 
#line 7931 
                         tmp_0 = __min1; else 
#line 7931 
                                              tmp_0 = __min2;
    
#line 7931 
    tmp_1 = tmp_0;
  }
  
#line 7931 
  ppid->id_len = (unsigned char)tmp_1;
  
#line 7932 
  memcpy((void *)(& ppid->id),(void const *)(& hw->mac.port_addr),(unsigned long)ppid->id_len);
  
#line 7934 
  __retres = 0;
  return_label: 
#line 7934 
                return __retres;
}


#line 7945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_ndo_fdb_add(struct ndmsg *ndm, struct nlattr **tb, struct net_device *dev, unsigned char const *addr, u16 vid, u16 flags)
{
  int __retres;
  bool tmp_1;
  
#line 7950 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)dev);
  
#line 7951 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 7952 
  int err = 0;
  
#line 7954 
  if ((pf->flags & 524288ULL) == 0ULL) {
    
#line 7955 
    __retres = -95;
    
#line 7955 
    goto return_label;
  }
  else ;
  
#line 7957 
  if ((unsigned int)vid != 0U) {
    
#line 7958 
    printk("\001",(char *)(& dev->name));
    
#line 7959 
    __retres = -22;
    
#line 7959 
    goto return_label;
  }
  else ;
  
#line 7965 
  if ((unsigned int)ndm->ndm_state != 0U && ((int)ndm->ndm_state & 128) == 0) {
    
#line 7966 
    netdev_info((struct net_device const *)dev,"FDB only supports static addresses\n");
    
#line 7967 
    __retres = -22;
    
#line 7967 
    goto return_label;
  }
  else ;
  
#line 7970 
  tmp_1 = is_unicast_ether_addr(addr);
  
#line 7970 
  if ((int)tmp_1 != 0) 
#line 7970 
                       goto _LOR;
  else {
    bool tmp_2;
    
#line 7970 
    tmp_2 = is_link_local_ether_addr(addr);
    
#line 7970 
    if ((int)tmp_2 != 0) _LOR: 
#line 7971 
                               err = dev_uc_add_excl(dev,addr);
    else {
      bool tmp_0;
      
#line 7972 
      tmp_0 = is_multicast_ether_addr(addr);
      
#line 7972 
      if ((int)tmp_0 != 0) 
#line 7973 
                           err = dev_mc_add_excl(dev,addr); else 
#line 7975 
                                                                 err = -22;
    }
  }
  
#line 7978 
  if (err == -17 && ((int)flags & 512) == 0) 
#line 7979 
                                             err = 0; else ;
  
#line 7981 
  __retres = err;
  return_label: 
#line 7981 
                return __retres;
}


#line 8102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct net_device_ops const i40e_netdev_ops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & i40e_open, .ndo_stop = & i40e_close, .ndo_start_xmit = & i40e_lan_xmit_frame, .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & i40e_set_rx_mode, .ndo_set_mac_address = & i40e_set_mac, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & i40e_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & i40e_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = & i40e_tx_timeout, .ndo_get_stats64 = & i40e_get_netdev_stats_struct, .ndo_get_stats = (struct net_device_stats *(*)(struct net_device *))0, .ndo_vlan_rx_add_vid = & i40e_vlan_rx_add_vid, .ndo_vlan_rx_kill_vid = & i40e_vlan_rx_kill_vid, .ndo_poll_controller = & i40e_netpoll, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = (int (*)(struct napi_struct *))0, .ndo_set_vf_mac = & i40e_ndo_set_vf_mac, .ndo_set_vf_vlan = & i40e_ndo_set_vf_port_vlan, .ndo_set_vf_rate = & i40e_ndo_set_vf_bw, .ndo_set_vf_spoofchk = & i40e_ndo_set_vf_spoofchk, .ndo_get_vf_config = & i40e_ndo_get_vf_config, .ndo_set_vf_link_state = & i40e_ndo_set_vf_link_state, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = & i40e_setup_tc, .ndo_fcoe_enable = & i40e_fcoe_enable, .ndo_fcoe_disable = & i40e_fcoe_disable, .ndo_fcoe_ddp_setup = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_ddp_done = (int (*)(struct net_device *, u16 ))0, .ndo_fcoe_ddp_target = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = (int (*)(struct net_device *, struct sk_buff const *, u16 , u32 ))0, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = (netdev_features_t (*)(struct net_device *, netdev_features_t ))0, .ndo_set_features = & i40e_set_features, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = & i40e_ndo_fdb_add, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = & i40e_get_phys_port_id, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = & i40e_add_vxlan_port, .ndo_del_vxlan_port = & i40e_del_vxlan_port, .ndo_dfwd_add_station = (void *(*)(struct net_device *, struct net_device *))0, .ndo_dfwd_del_station = (void (*)(struct net_device *, void *))0, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = (netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t ))0, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 8148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_config_netdev(struct i40e_vsi *vsi)
{
  int __retres;
  struct i40e_netdev_priv *np;
  struct net_device *netdev;
  u8 mac_addr[6U];
  int etherdev_size;
  
#line 8150 
  u8 brdcast[6U] = {(unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U};
  
#line 8151 
  struct i40e_pf *pf = vsi->back;
  
#line 8152 
  struct i40e_hw *hw = & pf->hw;
  
#line 8158 
  etherdev_size = 8;
  
#line 8159 
  netdev = ldv_alloc_etherdev_mqs_87(etherdev_size,(unsigned int)vsi->alloc_queue_pairs,(unsigned int)vsi->alloc_queue_pairs);
  
#line 8160 
  if (netdev == (struct net_device *)0) {
    
#line 8161 
    __retres = -12;
    
#line 8161 
    goto return_label;
  }
  else ;
  
#line 8163 
  vsi->netdev = netdev;
  
#line 8164 
  np = (struct i40e_netdev_priv *)netdev_priv((struct net_device const *)netdev);
  
#line 8165 
  np->vsi = vsi;
  
#line 8167 
  netdev->hw_enc_features |= 67174402ULL;
  
#line 8171 
  netdev->features = 26912293811ULL;
  
#line 8187 
  if ((pf->flags & 67108864ULL) == 0ULL) 
#line 8188 
                                         netdev->features |= 4294967296ULL; else ;
  
#line 8191 
  netdev->hw_features |= netdev->features;
  
#line 8193 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) {
    int tmp_0;
    
#line 8194 
    netdev->dev.parent = & (pf->pdev)->dev;
    
#line 8195 
    ether_addr_copy((u8 *)(& mac_addr),(u8 const *)(& hw->mac.perm_addr));
    
#line 8201 
    tmp_0 = i40e_rm_default_mac_filter(vsi,(u8 *)(& mac_addr));
    
#line 8201 
    if (tmp_0 == 0) 
#line 8202 
                    i40e_add_filter(vsi,(u8 *)(& mac_addr),(short)(-1),(_Bool)0,(_Bool)1); else ;
  }
  else {
    
#line 8206 
    snprintf((char *)(& netdev->name),16UL,"%sv%%d",(char *)(& ((*(pf->vsi + (int)pf->lan_vsi))->netdev)->name));
    
#line 8208 
    eth_random_addr((u8 *)(& mac_addr));
    
#line 8209 
    i40e_add_filter(vsi,(u8 *)(& mac_addr),(short)(-1),(_Bool)0,(_Bool)0);
  }
  
#line 8211 
  i40e_add_filter(vsi,(u8 *)(& brdcast),(short)(-1),(_Bool)0,(_Bool)0);
  
#line 8213 
  ether_addr_copy(netdev->dev_addr,(u8 const *)(& mac_addr));
  
#line 8214 
  ether_addr_copy((u8 *)(& netdev->perm_addr),(u8 const *)(& mac_addr));
  
#line 8218 
  netdev->vlan_features = netdev->features & 18446744073709550719ULL;
  
#line 8221 
  netdev->priv_flags |= 131072U;
  
#line 8222 
  netdev->priv_flags |= 524288U;
  
#line 8224 
  i40e_vsi_config_netdev_tc(vsi,(unsigned char)((int)vsi->tc_config.enabled_tc));
  
#line 8226 
  netdev->netdev_ops = & i40e_netdev_ops;
  
#line 8227 
  netdev->watchdog_timeo = 1250;
  
#line 8228 
  i40e_set_ethtool_ops(netdev);
  
#line 8230 
  i40e_fcoe_config_netdev(netdev,vsi);
  
#line 8233 
  __retres = 0;
  return_label: 
#line 8233 
                return __retres;
}


#line 8242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_delete(struct i40e_vsi *vsi)
{
  
#line 8245 
  if (*((vsi->back)->vsi + (int)(vsi->back)->lan_vsi) == vsi) 
#line 8246 
                                                              goto return_label; else ;
  
#line 8248 
  i40e_aq_delete_element(& (vsi->back)->hw,(unsigned short)((int)vsi->seid),(struct i40e_asq_cmd_details *)0);
  return_label: 
#line 8249 
                return;
}


#line 8257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_is_vsi_uplink_mode_veb(struct i40e_vsi *vsi)
{
  int __retres;
  struct i40e_veb *veb;
  
#line 8260 
  struct i40e_pf *pf = vsi->back;
  
#line 8263 
  if ((unsigned int)vsi->veb_idx == 65535U) {
    
#line 8264 
    __retres = 1;
    
#line 8264 
    goto return_label;
  }
  else ;
  
#line 8266 
  veb = pf->veb[(int)vsi->veb_idx];
  
#line 8268 
  if (veb != (struct i40e_veb *)0 && ((int)veb->bridge_mode & 1) != 0) {
    
#line 8269 
    __retres = 0;
    
#line 8269 
    goto return_label;
  }
  else ;
  
#line 8272 
  __retres = 1;
  return_label: 
#line 8272 
                return __retres;
}


#line 8282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_add_vsi(struct i40e_vsi *vsi)
{
  int __retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *ftmp;
  struct i40e_vsi_context ctxt;
  struct i40e_mac_filter *tmp_5;
  struct i40e_mac_filter *tmp_6;
  struct i40e_mac_filter *tmp_8;
  
#line 8284 
  int ret = -19;
  
#line 8286 
  struct i40e_pf *pf = vsi->back;
  
#line 8287 
  struct i40e_hw *hw = & pf->hw;
  
#line 8289 
  u8 enabled_tc = (unsigned char)1U;
  
#line 8290 
  int f_count = 0;
  
#line 8292 
  memset((void *)(& ctxt),0,144UL);
  
#line 8293 
  switch ((unsigned int)vsi->type) {
    i40e_status tmp;
    int tmp_2;
    int tmp_3;
    case (unsigned int)0: 
#line 8294 
    ;
    
#line 8300 
    ctxt.seid = pf->main_vsi_seid;
    
#line 8301 
    ctxt.pf_num = pf->hw.pf_id;
    
#line 8302 
    ctxt.vf_num = (unsigned char)0U;
    
#line 8303 
    tmp = i40e_aq_get_vsi_params(& pf->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
    
#line 8303 
    ret = (int)tmp;
    
#line 8304 
    ctxt.flags = (unsigned short)2U;
    
#line 8305 
    if (ret != 0) {
      
#line 8306 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"couldn\'t get PF vsi config, err %d, aq_err %d\n",ret,(unsigned int)pf->hw.aq.asq_last_status);
      
#line 8309 
      __retres = -2;
      
#line 8309 
      goto return_label;
    }
    else ;
    
#line 8311 
    vsi->info = ctxt.info;
    
#line 8312 
    vsi->info.valid_sections = (unsigned short)0U;
    
#line 8314 
    vsi->seid = ctxt.seid;
    
#line 8315 
    vsi->id = ctxt.vsi_number;
    
#line 8317 
    enabled_tc = i40e_pf_get_tc_map(pf);
    
#line 8320 
    if ((pf->flags & 67108864ULL) != 0ULL && ! pf->hw.func_caps.iscsi) {
      i40e_status tmp_0;
      
#line 8322 
      memset((void *)(& ctxt),0,144UL);
      
#line 8323 
      ctxt.seid = pf->main_vsi_seid;
      
#line 8324 
      ctxt.pf_num = pf->hw.pf_id;
      
#line 8325 
      ctxt.vf_num = (unsigned char)0U;
      
#line 8326 
      i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)0);
      
#line 8327 
      tmp_0 = i40e_aq_update_vsi_params(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
      
#line 8327 
      ret = (int)tmp_0;
      
#line 8328 
      if (ret != 0) {
        
#line 8329 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"update vsi failed, aq_err=%d\n",(unsigned int)pf->hw.aq.asq_last_status);
        
#line 8332 
        ret = -2;
        
#line 8333 
        goto err;
      }
      else ;
      
#line 8336 
      i40e_vsi_update_queue_map(vsi,& ctxt);
      
#line 8337 
      vsi->info.valid_sections = (unsigned short)0U;
    }
    else {
      
#line 8345 
      ret = i40e_vsi_config_tc(vsi,(unsigned char)((int)enabled_tc));
      
#line 8346 
      if (ret != 0) {
        
#line 8347 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"failed to configure TCs for main VSI tc_map 0x%08x, err %d, aq_err %d\n",(int)enabled_tc,ret,(unsigned int)pf->hw.aq.asq_last_status);
        
#line 8351 
        ret = -2;
      }
      else ;
    }
    
#line 8354 
    goto ldv_63754;
    case (unsigned int)7: 
#line 8356 
    ;
    
#line 8357 
    ctxt.pf_num = hw->pf_id;
    
#line 8358 
    ctxt.vf_num = (unsigned char)0U;
    
#line 8359 
    ctxt.uplink_seid = vsi->uplink_seid;
    
#line 8360 
    ctxt.connection_type = (unsigned char)1U;
    
#line 8361 
    ctxt.flags = (unsigned short)2U;
    
#line 8362 
    if ((pf->flags & 1099511627776ULL) != 0ULL) {
      int tmp_1;
      
#line 8362 
      tmp_1 = i40e_is_vsi_uplink_mode_veb(vsi);
      
#line 8362 
      if (tmp_1 != 0) {
        
#line 8364 
        ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 1U);
        
#line 8366 
        ctxt.info.switch_id = (unsigned short)8192U;
      }
      else ;
    }
    else ;
    
#line 8369 
    i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)1);
    
#line 8370 
    goto ldv_63754;
    case (unsigned int)2: 
#line 8372 
    ;
    
#line 8373 
    ctxt.pf_num = hw->pf_id;
    
#line 8374 
    ctxt.vf_num = (unsigned char)0U;
    
#line 8375 
    ctxt.uplink_seid = vsi->uplink_seid;
    
#line 8376 
    ctxt.connection_type = (unsigned char)1U;
    
#line 8377 
    ctxt.flags = (unsigned short)1U;
    
#line 8382 
    tmp_2 = i40e_is_vsi_uplink_mode_veb(vsi);
    
#line 8382 
    if (tmp_2 != 0) {
      
#line 8383 
      ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 1U);
      
#line 8385 
      ctxt.info.switch_id = (unsigned short)8192U;
    }
    else ;
    
#line 8390 
    i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)1);
    
#line 8391 
    goto ldv_63754;
    case (unsigned int)6: 
#line 8393 
    ;
    
#line 8394 
    ctxt.pf_num = hw->pf_id;
    
#line 8395 
    ctxt.vf_num = (unsigned char)((int)((unsigned char)vsi->vf_id) + (int)((unsigned char)hw->func_caps.vf_base_id));
    
#line 8396 
    ctxt.uplink_seid = vsi->uplink_seid;
    
#line 8397 
    ctxt.connection_type = (unsigned char)1U;
    
#line 8398 
    ctxt.flags = (unsigned short)0U;
    
#line 8403 
    tmp_3 = i40e_is_vsi_uplink_mode_veb(vsi);
    
#line 8403 
    if (tmp_3 != 0) {
      
#line 8404 
      ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 1U);
      
#line 8406 
      ctxt.info.switch_id = (unsigned short)8192U;
    }
    else ;
    
#line 8410 
    ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 4U);
    
#line 8411 
    ctxt.info.port_vlan_flags = (unsigned char)((unsigned int)ctxt.info.port_vlan_flags | 3U);
    
#line 8412 
    if ((int)(pf->vf + (int)vsi->vf_id)->spoofchk != 0) {
      
#line 8413 
      ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 2U);
      
#line 8415 
      ctxt.info.sec_flags = (unsigned char)((unsigned int)ctxt.info.sec_flags | 6U);
    }
    else ;
    
#line 8420 
    i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)1);
    
#line 8421 
    goto ldv_63754;
    case (unsigned int)4: 
#line 8424 
    ;
    
#line 8425 
    ret = i40e_fcoe_vsi_init(vsi,& ctxt);
    
#line 8426 
    if (ret != 0) {
      
#line 8427 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"failed to initialize FCoE VSI\n");
      
#line 8428 
      __retres = ret;
      
#line 8428 
      goto return_label;
    }
    else ;
    
#line 8430 
    goto ldv_63754;
    default: 
#line 8433 
    ;
    
#line 8434 
    __retres = -19;
    
#line 8434 
    goto return_label;
  }
  ldv_63754: 
#line 8437 
  ;
  
#line 8437 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) {
    i40e_status tmp_4;
    
#line 8438 
    tmp_4 = i40e_aq_add_vsi(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
    
#line 8438 
    ret = (int)tmp_4;
    
#line 8439 
    if (ret != 0) {
      
#line 8440 
      _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"add vsi failed, aq_err=%d\n",(unsigned int)(vsi->back)->hw.aq.asq_last_status);
      
#line 8443 
      ret = -2;
      
#line 8444 
      goto err;
    }
    else ;
    
#line 8446 
    vsi->info = ctxt.info;
    
#line 8447 
    vsi->info.valid_sections = (unsigned short)0U;
    
#line 8448 
    vsi->seid = ctxt.seid;
    
#line 8449 
    vsi->id = ctxt.vsi_number;
  }
  else ;
  {
    
#line 8453 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 8453 
    tmp_5 = (struct i40e_mac_filter *)__mptr;
  }
  
#line 8453 
  f = tmp_5;
  {
    
#line 8453 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 8453 
    tmp_6 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 8454 
  ftmp = tmp_6;
  
#line 8453 
  goto ldv_63768;
  ldv_63767: 
#line 8454 
  ;
  
#line 8454 
  f->changed = (_Bool)1;
  
#line 8455 
  f_count += 1;
  
#line 8457 
  if ((int)f->is_laa != 0 && vsi->type == (unsigned int)I40E_VSI_MAIN) {
    struct i40e_aqc_remove_macvlan_element_data element;
    i40e_status tmp_7;
    
#line 8460 
    memset((void *)(& element),0,16UL);
    
#line 8461 
    ether_addr_copy((u8 *)(& element.mac_addr),(u8 const *)(& f->macaddr));
    
#line 8462 
    element.flags = (unsigned char)1U;
    
#line 8463 
    tmp_7 = i40e_aq_remove_macvlan(hw,(unsigned short)((int)vsi->seid),& element,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
    
#line 8463 
    ret = (int)tmp_7;
    
#line 8465 
    if (ret != 0) {
      
#line 8467 
      element.flags = (unsigned char)((unsigned int)element.flags | 8U);
      
#line 8469 
      i40e_aq_remove_macvlan(hw,(unsigned short)((int)vsi->seid),& element,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
    }
    else ;
    
#line 8473 
    i40e_aq_mac_address_write(hw,(unsigned short)16384,(u8 *)(& f->macaddr),(struct i40e_asq_cmd_details *)0);
  }
  else ;
  
#line 8453 
  f = ftmp;
  {
    
#line 8453 
    struct list_head const *__mptr_1 = (struct list_head const *)ftmp->list.next;
    
#line 8453 
    tmp_8 = (struct i40e_mac_filter *)__mptr_1;
  }
  
#line 8453 
  ftmp = tmp_8;
  ldv_63768: 
#line 8455 
  ;
  
#line 8453 
  if (& f->list != & vsi->mac_filter_list) 
#line 8455 
                                           goto ldv_63767; else 
#line 8458 
                                                                goto ldv_63769;
  ldv_63769: 
#line 8459 
  ;
  
#line 8478 
  if (f_count != 0) {
    
#line 8479 
    vsi->flags |= 1UL;
    
#line 8480 
    pf->flags |= 32768ULL;
  }
  else ;
  
#line 8484 
  ret = i40e_vsi_get_bw_info(vsi);
  
#line 8485 
  if (ret != 0) {
    
#line 8486 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"couldn\'t get vsi bw info, err %d, aq_err %d\n",ret,(unsigned int)pf->hw.aq.asq_last_status);
    
#line 8490 
    ret = 0;
  }
  else ;
  err: 
#line 8493 
  ;
  
#line 8494 
  __retres = ret;
  return_label: 
#line 8494 
                return __retres;
}


#line 8503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_release(struct i40e_vsi *vsi)
{
  int __retres;
  struct i40e_mac_filter *f;
  struct i40e_mac_filter *ftmp;
  struct i40e_pf *pf;
  u16 uplink_seid;
  int i;
  int n;
  struct i40e_mac_filter *tmp_0;
  struct i40e_mac_filter *tmp_1;
  struct i40e_mac_filter *tmp_2;
  
#line 8506 
  struct i40e_veb *veb = (struct i40e_veb *)0;
  
#line 8511 
  pf = vsi->back;
  
#line 8514 
  if ((vsi->flags & 2UL) != 0UL) {
    
#line 8515 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"VSI %d has existing VEB %d\n",(int)vsi->seid,(int)vsi->uplink_seid);
    
#line 8517 
    __retres = -19;
    
#line 8517 
    goto return_label;
  }
  else ;
  
#line 8519 
  if (*(pf->vsi + (int)pf->lan_vsi) == vsi) {
    int tmp;
    
#line 8519 
    tmp = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
    
#line 8519 
    if (tmp == 0) {
      
#line 8521 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"Can\'t remove PF VSI\n");
      
#line 8522 
      __retres = -19;
      
#line 8522 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 8525 
  uplink_seid = vsi->uplink_seid;
  
#line 8526 
  if (vsi->type != (unsigned int)I40E_VSI_SRIOV) {
    
#line 8527 
    if ((int)vsi->netdev_registered != 0) {
      
#line 8528 
      vsi->netdev_registered = (_Bool)0;
      
#line 8529 
      if (vsi->netdev != (struct net_device *)0) 
#line 8531 
                                                 ldv_unregister_netdev_88(vsi->netdev); else ;
    }
    else 
#line 8534 
         i40e_vsi_close(vsi);
    
#line 8536 
    i40e_vsi_disable_irq(vsi);
  }
  else ;
  {
    
#line 8539 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 8539 
    tmp_0 = (struct i40e_mac_filter *)__mptr;
  }
  
#line 8539 
  f = tmp_0;
  {
    
#line 8539 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 8539 
    tmp_1 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 8540 
  ftmp = tmp_1;
  
#line 8539 
  goto ldv_63787;
  ldv_63786: 
#line 8540 
  ;
  
#line 8540 
  i40e_del_filter(vsi,(u8 *)(& f->macaddr),(short)((int)f->vlan),(_Bool)((bool)((int)f->is_vf) != 0),(_Bool)((bool)((int)f->is_netdev) != 0));
  
#line 8539 
  f = ftmp;
  {
    
#line 8539 
    struct list_head const *__mptr_1 = (struct list_head const *)ftmp->list.next;
    
#line 8539 
    tmp_2 = (struct i40e_mac_filter *)__mptr_1;
  }
  
#line 8539 
  ftmp = tmp_2;
  ldv_63787: 
#line 8541 
  ;
  
#line 8539 
  if (& f->list != & vsi->mac_filter_list) 
#line 8541 
                                           goto ldv_63786; else 
#line 8544 
                                                                goto ldv_63788;
  ldv_63788: 
#line 8545 
  ;
  
#line 8542 
  i40e_sync_vsi_filters(vsi);
  
#line 8544 
  i40e_vsi_delete(vsi);
  
#line 8545 
  i40e_vsi_free_q_vectors(vsi);
  
#line 8546 
  if (vsi->netdev != (struct net_device *)0) {
    
#line 8547 
    ldv_free_netdev_89(vsi->netdev);
    
#line 8548 
    vsi->netdev = (struct net_device *)0;
  }
  else ;
  
#line 8550 
  i40e_vsi_clear_rings(vsi);
  
#line 8551 
  i40e_vsi_clear(vsi);
  
#line 8561 
  n = 0;
  
#line 8561 
  i = 0;
  
#line 8561 
  goto ldv_63790;
  ldv_63789: 
#line 8562 
  ;
  
#line 8562 
  if ((*(pf->vsi + i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + i))->uplink_seid == (int)uplink_seid) && ((*(pf->vsi + i))->flags & 2UL) == 0UL) 
    
#line 8565 
    n += 1; else ;
  
#line 8561 
  i += 1;
  ldv_63790: 
#line 8562 
  ;
  
#line 8561 
  if ((int)pf->num_alloc_vsi > i) 
#line 8563 
                                  goto ldv_63789; else 
#line 8566 
                                                       goto ldv_63791;
  ldv_63791: 
#line 8567 
  ;
  
#line 8568 
  i = 0;
  
#line 8568 
  goto ldv_63794;
  ldv_63793: 
#line 8569 
  ;
  
#line 8569 
  if (pf->veb[i] == (struct i40e_veb *)0) 
#line 8570 
                                          goto ldv_63792; else ;
  
#line 8571 
  if ((int)(pf->veb[i])->uplink_seid == (int)uplink_seid) 
#line 8572 
                                                          n += 1; else ;
  
#line 8573 
  if ((int)(pf->veb[i])->seid == (int)uplink_seid) 
#line 8574 
                                                   veb = pf->veb[i]; else ;
  ldv_63792: 
#line 8575 
  ;
  
#line 8568 
  i += 1;
  ldv_63794: 
#line 8569 
  ;
  
#line 8568 
  if (i <= 15) 
#line 8570 
               goto ldv_63793; else 
#line 8573 
                                    goto ldv_63795;
  ldv_63795: 
#line 8574 
  ;
  
#line 8576 
  if ((n == 0 && veb != (struct i40e_veb *)0) && (unsigned int)veb->uplink_seid != 0U) 
    
#line 8577 
    i40e_veb_release(veb); else ;
  
#line 8579 
  __retres = 0;
  return_label: 
#line 8579 
                return __retres;
}


#line 8592  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_setup_vectors(struct i40e_vsi *vsi)
{
  int __retres;
  
#line 8594 
  int ret = -2;
  
#line 8595 
  struct i40e_pf *pf = vsi->back;
  
#line 8597 
  if (*(vsi->q_vectors) != (struct i40e_q_vector *)0) {
    
#line 8598 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"VSI %d has existing q_vectors\n",(int)vsi->seid);
    
#line 8600 
    __retres = -17;
    
#line 8600 
    goto return_label;
  }
  else ;
  
#line 8603 
  if (vsi->base_vector != 0) {
    
#line 8604 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"VSI %d has non-zero base vector %d\n",(int)vsi->seid,vsi->base_vector);
    
#line 8606 
    __retres = -17;
    
#line 8606 
    goto return_label;
  }
  else ;
  
#line 8609 
  ret = i40e_vsi_alloc_q_vectors(vsi);
  
#line 8610 
  if (ret != 0) {
    
#line 8611 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"failed to allocate %d q_vector for VSI %d, ret=%d\n",vsi->num_q_vectors,(int)vsi->seid,ret);
    
#line 8614 
    vsi->num_q_vectors = 0;
    
#line 8615 
    goto vector_setup_out;
  }
  else ;
  
#line 8618 
  if (vsi->num_q_vectors != 0) 
#line 8619 
                               vsi->base_vector = i40e_get_lump(pf,pf->irq_pile,(unsigned short)((int)((unsigned short)vsi->num_q_vectors)),(unsigned short)((int)vsi->idx)); else ;
  
#line 8621 
  if (vsi->base_vector < 0) {
    
#line 8622 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"failed to get tracking for %d vectors for VSI %d, err=%d\n",vsi->num_q_vectors,(int)vsi->seid,vsi->base_vector);
    
#line 8625 
    i40e_vsi_free_q_vectors(vsi);
    
#line 8626 
    ret = -2;
    
#line 8627 
    goto vector_setup_out;
  }
  else ;
  vector_setup_out: 
#line 8630 
  ;
  
#line 8631 
  __retres = ret;
  return_label: 
#line 8631 
                return __retres;
}


#line 8643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct i40e_vsi *i40e_vsi_reinit_setup(struct i40e_vsi *vsi)
{
  struct i40e_vsi *__retres;
  u8 enabled_tc;
  int ret;
  
#line 8645 
  struct i40e_pf *pf = vsi->back;
  
#line 8649 
  i40e_put_lump(pf->qp_pile,(unsigned short)((int)vsi->base_queue),(unsigned short)((int)vsi->idx));
  
#line 8650 
  i40e_vsi_clear_rings(vsi);
  
#line 8652 
  i40e_vsi_free_arrays(vsi,(_Bool)0);
  
#line 8653 
  i40e_set_num_rings_in_vsi(vsi);
  
#line 8654 
  ret = i40e_vsi_alloc_arrays(vsi,(_Bool)0);
  
#line 8655 
  if (ret != 0) 
#line 8656 
                goto err_vsi; else ;
  
#line 8658 
  ret = i40e_get_lump(pf,pf->qp_pile,(unsigned short)((int)vsi->alloc_queue_pairs),(unsigned short)((int)vsi->idx));
  
#line 8659 
  if (ret < 0) {
    
#line 8660 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"failed to get tracking for %d queues for VSI %d err=%d\n",(int)vsi->alloc_queue_pairs,(int)vsi->seid,ret);
    
#line 8663 
    goto err_vsi;
  }
  else ;
  
#line 8665 
  vsi->base_queue = (unsigned short)ret;
  
#line 8670 
  enabled_tc = (*(pf->vsi + (int)pf->lan_vsi))->tc_config.enabled_tc;
  
#line 8671 
  (*(pf->vsi + (int)pf->lan_vsi))->tc_config.enabled_tc = (unsigned char)0U;
  
#line 8672 
  (*(pf->vsi + (int)pf->lan_vsi))->seid = pf->main_vsi_seid;
  
#line 8673 
  i40e_vsi_config_tc(*(pf->vsi + (int)pf->lan_vsi),(unsigned char)((int)enabled_tc));
  
#line 8676 
  ret = i40e_alloc_rings(vsi);
  
#line 8677 
  if (ret != 0) 
#line 8678 
                goto err_rings; else ;
  
#line 8681 
  i40e_vsi_map_rings_to_vectors(vsi);
  
#line 8682 
  __retres = vsi;
  
#line 8682 
  goto return_label;
  err_rings: 
#line 8684 
  ;
  
#line 8685 
  i40e_vsi_free_q_vectors(vsi);
  
#line 8686 
  if ((int)vsi->netdev_registered != 0) {
    
#line 8687 
    vsi->netdev_registered = (_Bool)0;
    
#line 8688 
    ldv_unregister_netdev_90(vsi->netdev);
    
#line 8689 
    ldv_free_netdev_91(vsi->netdev);
    
#line 8690 
    vsi->netdev = (struct net_device *)0;
  }
  else ;
  
#line 8692 
  i40e_aq_delete_element(& pf->hw,(unsigned short)((int)vsi->seid),(struct i40e_asq_cmd_details *)0);
  err_vsi: 
#line 8693 
  ;
  
#line 8694 
  i40e_vsi_clear(vsi);
  
#line 8695 
  __retres = (struct i40e_vsi *)0;
  return_label: 
#line 8695 
                return __retres;
}


#line 8711  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_vsi *i40e_vsi_setup(struct i40e_pf *pf, u8 type, u16 uplink_seid, u32 param1)
{
  struct i40e_vsi *__retres;
  int ret;
  int i;
  int v_idx;
  
#line 8714 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  
#line 8715 
  struct i40e_veb *veb = (struct i40e_veb *)0;
  
#line 8732 
  i = 0;
  
#line 8732 
  goto ldv_63823;
  ldv_63822: 
#line 8733 
  ;
  
#line 8733 
  if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == (int)uplink_seid) {
    
#line 8734 
    veb = pf->veb[i];
    
#line 8735 
    goto ldv_63821;
  }
  else ;
  
#line 8732 
  i += 1;
  ldv_63823: 
#line 8733 
  ;
  
#line 8732 
  if (i <= 15) 
#line 8734 
               goto ldv_63822; else 
#line 8737 
                                    goto ldv_63821;
  ldv_63821: 
#line 8738 
  ;
  
#line 8739 
  if (veb == (struct i40e_veb *)0 && (int)pf->mac_seid != (int)uplink_seid) {
    
#line 8741 
    i = 0;
    
#line 8741 
    goto ldv_63826;
    ldv_63825: 
#line 8742 
    ;
    
#line 8742 
    if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + i))->seid == (int)uplink_seid) {
      
#line 8743 
      vsi = *(pf->vsi + i);
      
#line 8744 
      goto ldv_63824;
    }
    else ;
    
#line 8741 
    i += 1;
    ldv_63826: 
#line 8742 
    ;
    
#line 8741 
    if ((int)pf->num_alloc_vsi > i) 
#line 8743 
                                    goto ldv_63825; else 
#line 8746 
                                                         goto ldv_63824;
    ldv_63824: 
#line 8747 
    ;
    
#line 8747 
    if (vsi == (struct i40e_vsi *)0) {
      
#line 8748 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"no such uplink_seid %d\n",(int)uplink_seid);
      
#line 8750 
      __retres = (struct i40e_vsi *)0;
      
#line 8750 
      goto return_label;
    }
    else ;
    
#line 8753 
    if ((int)vsi->uplink_seid == (int)pf->mac_seid) 
#line 8754 
                                                    veb = i40e_veb_setup(pf,(unsigned short)0,(unsigned short)((int)pf->mac_seid),(unsigned short)((int)vsi->seid),(unsigned char)((int)vsi->tc_config.enabled_tc));
    else 
      
#line 8756 
      if ((vsi->flags & 2UL) == 0UL) 
#line 8757 
                                     veb = i40e_veb_setup(pf,(unsigned short)0,(unsigned short)((int)vsi->uplink_seid),(unsigned short)((int)vsi->seid),(unsigned char)((int)vsi->tc_config.enabled_tc)); else ;
    
#line 8759 
    if (veb != (struct i40e_veb *)0) {
      
#line 8760 
      if ((int)vsi->seid != (int)(*(pf->vsi + (int)pf->lan_vsi))->seid) {
        
#line 8761 
        _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"%s: New VSI creation error, uplink seid of LAN VSI expected.\n","i40e_vsi_setup");
        
#line 8764 
        __retres = (struct i40e_vsi *)0;
        
#line 8764 
        goto return_label;
      }
      else ;
      
#line 8770 
      if ((pf->flags & 1099511627776ULL) == 0ULL) {
        
#line 8771 
        veb->bridge_mode = (unsigned short)1U;
        
#line 8772 
        pf->flags &= 18446742974197923839ULL;
      }
      else ;
      
#line 8774 
      i40e_config_bridge_mode(veb);
    }
    else ;
    
#line 8776 
    i = 0;
    
#line 8776 
    goto ldv_63829;
    ldv_63828: 
#line 8777 
    ;
    
#line 8777 
    if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == (int)vsi->uplink_seid) 
      
#line 8778 
      veb = pf->veb[i]; else ;
    
#line 8776 
    i += 1;
    ldv_63829: 
#line 8777 
    ;
    
#line 8776 
    if (i <= 15 && veb == (struct i40e_veb *)0) 
#line 8778 
                                                goto ldv_63828; else 
                                                                  
#line 8781 
                                                                  goto ldv_63830;
    ldv_63830: 
#line 8782 
    ;
    
#line 8780 
    if (veb == (struct i40e_veb *)0) {
      
#line 8781 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"couldn\'t add VEB\n");
      
#line 8782 
      __retres = (struct i40e_vsi *)0;
      
#line 8782 
      goto return_label;
    }
    else ;
    
#line 8785 
    vsi->flags |= 2UL;
    
#line 8786 
    uplink_seid = veb->seid;
  }
  else ;
  
#line 8790 
  v_idx = i40e_vsi_mem_alloc(pf,(enum i40e_vsi_type)type);
  
#line 8791 
  if (v_idx < 0) 
#line 8792 
                 goto err_alloc; else ;
  
#line 8793 
  vsi = *(pf->vsi + v_idx);
  
#line 8794 
  if (vsi == (struct i40e_vsi *)0) 
#line 8795 
                                   goto err_alloc; else ;
  
#line 8796 
  vsi->type = (enum i40e_vsi_type)type;
  
#line 8797 
  if (veb != (struct i40e_veb *)0) 
#line 8797 
                                   vsi->veb_idx = veb->idx; else 
#line 8797 
                                                                 vsi->veb_idx = (unsigned short)65535U;
  
#line 8799 
  if ((unsigned int)type == 0U) 
#line 8800 
                                pf->lan_vsi = (unsigned short)v_idx;
  else 
    
#line 8801 
    if ((unsigned int)type == 6U) 
#line 8802 
                                  vsi->vf_id = (unsigned short)param1; else ;
  
#line 8804 
  ret = i40e_get_lump(pf,pf->qp_pile,(unsigned short)((int)vsi->alloc_queue_pairs),(unsigned short)((int)vsi->idx));
  
#line 8806 
  if (ret < 0) {
    
#line 8807 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"failed to get tracking for %d queues for VSI %d err=%d\n",(int)vsi->alloc_queue_pairs,(int)vsi->seid,ret);
    
#line 8810 
    goto err_vsi;
  }
  else ;
  
#line 8812 
  vsi->base_queue = (unsigned short)ret;
  
#line 8815 
  vsi->uplink_seid = uplink_seid;
  
#line 8816 
  ret = i40e_add_vsi(vsi);
  
#line 8817 
  if (ret != 0) 
#line 8818 
                goto err_vsi; else ;
  
#line 8820 
  switch ((unsigned int)vsi->type) {
    case (unsigned int)0: 
#line 8822 
    ;
    case (unsigned int)2: 
#line 8823 
    ;
    case (unsigned int)4: 
#line 8824 
    ;
    
#line 8825 
    ret = i40e_config_netdev(vsi);
    
#line 8826 
    if (ret != 0) 
#line 8827 
                  goto err_netdev; else ;
    
#line 8828 
    ret = ldv_register_netdev_92(vsi->netdev);
    
#line 8829 
    if (ret != 0) 
#line 8830 
                  goto err_netdev; else ;
    
#line 8831 
    vsi->netdev_registered = (_Bool)1;
    
#line 8832 
    netif_carrier_off(vsi->netdev);
    
#line 8835 
    i40e_dcbnl_setup(vsi);
    case (unsigned int)7: 
#line 8839 
    ;
    
#line 8841 
    ret = i40e_vsi_setup_vectors(vsi);
    
#line 8842 
    if (ret != 0) 
#line 8843 
                  goto err_msix; else ;
    
#line 8845 
    ret = i40e_alloc_rings(vsi);
    
#line 8846 
    if (ret != 0) 
#line 8847 
                  goto err_rings; else ;
    
#line 8850 
    i40e_vsi_map_rings_to_vectors(vsi);
    
#line 8852 
    i40e_vsi_reset_stats(vsi);
    
#line 8853 
    goto ldv_63840;
    default: 
#line 8855 
    ;
    
#line 8857 
    goto ldv_63840;
  }
  ldv_63840: 
#line 8860 
  ;
  
#line 8860 
  __retres = vsi;
  
#line 8860 
  goto return_label;
  err_rings: 
#line 8862 
  ;
  
#line 8863 
  i40e_vsi_free_q_vectors(vsi);
  err_msix: 
#line 8864 
  ;
  
#line 8865 
  if ((int)vsi->netdev_registered != 0) {
    
#line 8866 
    vsi->netdev_registered = (_Bool)0;
    
#line 8867 
    ldv_unregister_netdev_93(vsi->netdev);
    
#line 8868 
    ldv_free_netdev_94(vsi->netdev);
    
#line 8869 
    vsi->netdev = (struct net_device *)0;
  }
  else ;
  err_netdev: 
#line 8871 
  ;
  
#line 8872 
  i40e_aq_delete_element(& pf->hw,(unsigned short)((int)vsi->seid),(struct i40e_asq_cmd_details *)0);
  err_vsi: 
#line 8873 
  ;
  
#line 8874 
  i40e_vsi_clear(vsi);
  err_alloc: 
#line 8875 
  ;
  
#line 8876 
  __retres = (struct i40e_vsi *)0;
  return_label: 
#line 8876 
                return __retres;
}


#line 8885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_veb_get_bw_info(struct i40e_veb *veb)
{
  struct i40e_aqc_query_switching_comp_ets_config_resp ets_data;
  struct i40e_aqc_query_switching_comp_bw_config_resp bw_data;
  u32 tc_bw_max;
  int i;
  i40e_status tmp;
  i40e_status tmp_0;
  
#line 8889 
  struct i40e_pf *pf = veb->pf;
  
#line 8890 
  struct i40e_hw *hw = & pf->hw;
  
#line 8892 
  int ret = 0;
  
#line 8895 
  tmp = i40e_aq_query_switch_comp_bw_config(hw,(unsigned short)((int)veb->seid),& bw_data,(struct i40e_asq_cmd_details *)0);
  
#line 8895 
  ret = (int)tmp;
  
#line 8897 
  if (ret != 0) {
    
#line 8898 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"query veb bw config failed, aq_err=%d\n",(unsigned int)hw->aq.asq_last_status);
    
#line 8901 
    goto out;
  }
  else ;
  
#line 8904 
  tmp_0 = i40e_aq_query_switch_comp_ets_config(hw,(unsigned short)((int)veb->seid),& ets_data,(struct i40e_asq_cmd_details *)0);
  
#line 8904 
  ret = (int)tmp_0;
  
#line 8906 
  if (ret != 0) {
    
#line 8907 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"query veb bw ets config failed, aq_err=%d\n",(unsigned int)hw->aq.asq_last_status);
    
#line 8910 
    goto out;
  }
  else ;
  
#line 8913 
  veb->bw_limit = ets_data.port_bw_limit;
  
#line 8914 
  veb->bw_max_quanta = ets_data.tc_bw_max;
  
#line 8915 
  veb->is_abs_credits = (_Bool)((unsigned int)bw_data.absolute_credits_enable != 0U);
  
#line 8916 
  veb->enabled_tc = ets_data.tc_valid_bits;
  
#line 8917 
  tc_bw_max = (unsigned int)((int)bw_data.tc_bw_max[0] | ((int)bw_data.tc_bw_max[1] << 16));
  
#line 8919 
  i = 0;
  
#line 8919 
  goto ldv_63854;
  ldv_63853: 
#line 8920 
  ;
  
#line 8920 
  veb->bw_tc_share_credits[i] = bw_data.tc_bw_share_credits[i];
  
#line 8921 
  veb->bw_tc_limit_credits[i] = bw_data.tc_bw_limits[i];
  
#line 8923 
  veb->bw_tc_max_quanta[i] = (unsigned char)((unsigned int)((unsigned char)(tc_bw_max >> i * 4)) & 7U);
  
#line 8919 
  i += 1;
  ldv_63854: 
#line 8920 
  ;
  
#line 8919 
  if (i <= 7) 
#line 8921 
              goto ldv_63853; else 
#line 8924 
                                   goto ldv_63855;
  ldv_63855: 
#line 8925 
  ;
  out: 
#line 8926 
  ;
  
#line 8927 
  return ret;
}


#line 8937  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_veb_mem_alloc(struct i40e_pf *pf)
{
  struct i40e_veb *veb;
  int i;
  
#line 8939 
  int ret = -2;
  
#line 8944 
  ldv_mutex_lock_95(& pf->switch_mutex);
  
#line 8952 
  i = 0;
  
#line 8953 
  goto ldv_63863;
  ldv_63862: 
#line 8954 
  ;
  
#line 8954 
  i += 1;
  ldv_63863: 
#line 8955 
  ;
  
#line 8953 
  if (i <= 15 && pf->veb[i] != (struct i40e_veb *)0) 
#line 8955 
                                                     goto ldv_63862; else 
                                                                    
#line 8958 
                                                                    goto ldv_63864;
  ldv_63864: 
#line 8959 
  ;
  
#line 8955 
  if (i > 15) {
    
#line 8956 
    ret = -12;
    
#line 8957 
    goto err_alloc_veb;
  }
  else ;
  
#line 8960 
  veb = (struct i40e_veb *)kzalloc_0(272UL,208U);
  
#line 8961 
  if (veb == (struct i40e_veb *)0) {
    
#line 8962 
    ret = -12;
    
#line 8963 
    goto err_alloc_veb;
  }
  else ;
  
#line 8965 
  veb->pf = pf;
  
#line 8966 
  veb->idx = (unsigned short)i;
  
#line 8967 
  veb->enabled_tc = (unsigned char)1U;
  
#line 8969 
  pf->veb[i] = veb;
  
#line 8970 
  ret = i;
  err_alloc_veb: 
#line 8971 
  ;
  
#line 8972 
  ldv_mutex_unlock_96(& pf->switch_mutex);
  
#line 8973 
  return ret;
}


#line 8983  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_switch_branch_release(struct i40e_veb *branch)
{
  int i;
  
#line 8985 
  struct i40e_pf *pf = branch->pf;
  
#line 8986 
  u16 branch_seid = branch->seid;
  
#line 8987 
  u16 veb_idx = branch->idx;
  
#line 8991 
  i = 0;
  
#line 8991 
  goto ldv_63875;
  ldv_63874: 
#line 8992 
  ;
  
#line 8992 
  if (pf->veb[i] == (struct i40e_veb *)0) 
#line 8993 
                                          goto ldv_63873; else ;
  
#line 8994 
  if ((int)(pf->veb[i])->uplink_seid == (int)branch->seid) 
#line 8995 
                                                           i40e_switch_branch_release(pf->veb[i]); else ;
  ldv_63873: 
#line 8996 
  ;
  
#line 8991 
  i += 1;
  ldv_63875: 
#line 8992 
  ;
  
#line 8991 
  if (i <= 15) 
#line 8993 
               goto ldv_63874; else 
#line 8996 
                                    goto ldv_63876;
  ldv_63876: 
#line 8997 
  ;
  
#line 9003 
  i = 0;
  
#line 9003 
  goto ldv_63879;
  ldv_63878: 
#line 9004 
  ;
  
#line 9004 
  if (*(pf->vsi + i) == (struct i40e_vsi *)0) 
#line 9005 
                                              goto ldv_63877; else ;
  
#line 9006 
  if ((int)(*(pf->vsi + i))->uplink_seid == (int)branch_seid && ((*(pf->vsi + i))->flags & 2UL) == 0UL) 
    
#line 9008 
    i40e_vsi_release(*(pf->vsi + i)); else ;
  ldv_63877: 
#line 9009 
  ;
  
#line 9003 
  i += 1;
  ldv_63879: 
#line 9004 
  ;
  
#line 9003 
  if ((int)pf->num_alloc_vsi > i) 
#line 9005 
                                  goto ldv_63878; else 
#line 9008 
                                                       goto ldv_63880;
  ldv_63880: 
#line 9009 
  ;
  
#line 9017 
  if (pf->veb[(int)veb_idx] != (struct i40e_veb *)0) 
#line 9018 
                                                     i40e_veb_release(pf->veb[(int)veb_idx]); else ;
  
#line 9019 
  return;
}


#line 9025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_veb_clear(struct i40e_veb *veb)
{
  
#line 9027 
  if (veb == (struct i40e_veb *)0) 
#line 9028 
                                   goto return_label; else ;
  
#line 9030 
  if (veb->pf != (struct i40e_pf *)0) {
    
#line 9031 
    struct i40e_pf *pf = veb->pf;
    
#line 9033 
    ldv_mutex_lock_97(& pf->switch_mutex);
    
#line 9034 
    if (pf->veb[(int)veb->idx] == veb) 
#line 9035 
                                       pf->veb[(int)veb->idx] = (struct i40e_veb *)0; else ;
    
#line 9036 
    ldv_mutex_unlock_98(& pf->switch_mutex);
  }
  else ;
  
#line 9039 
  kfree((void const *)veb);
  return_label: 
#line 9040 
                return;
}


#line 9046  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_veb_release(struct i40e_veb *veb)
{
  struct i40e_pf *pf;
  int i;
  
#line 9048 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  
#line 9050 
  int n = 0;
  
#line 9052 
  pf = veb->pf;
  
#line 9055 
  i = 0;
  
#line 9055 
  goto ldv_63893;
  ldv_63892: 
#line 9056 
  ;
  
#line 9056 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + i))->uplink_seid == (int)veb->seid) {
    
#line 9057 
    n += 1;
    
#line 9058 
    vsi = *(pf->vsi + i);
  }
  else ;
  
#line 9055 
  i += 1;
  ldv_63893: 
#line 9056 
  ;
  
#line 9055 
  if ((int)pf->num_alloc_vsi > i) 
#line 9057 
                                  goto ldv_63892; else 
#line 9060 
                                                       goto ldv_63894;
  ldv_63894: 
#line 9061 
  ;
  
#line 9061 
  if (n != 1) {
    
#line 9062 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"can\'t remove VEB %d with %d VSIs left\n",(int)veb->seid,n);
    
#line 9065 
    goto return_label;
  }
  else ;
  
#line 9069 
  vsi->flags &= 18446744073709551613UL;
  
#line 9070 
  if ((unsigned int)veb->uplink_seid != 0U) {
    
#line 9071 
    vsi->uplink_seid = veb->uplink_seid;
    
#line 9072 
    if ((int)veb->uplink_seid == (int)pf->mac_seid) 
#line 9073 
                                                    vsi->veb_idx = (unsigned short)65535U; else 
                                                                    
#line 9075 
                                                                    vsi->veb_idx = veb->veb_idx;
  }
  else {
    
#line 9078 
    vsi->uplink_seid = (*(pf->vsi + (int)pf->lan_vsi))->uplink_seid;
    
#line 9079 
    vsi->veb_idx = (*(pf->vsi + (int)pf->lan_vsi))->veb_idx;
  }
  
#line 9082 
  i40e_aq_delete_element(& pf->hw,(unsigned short)((int)veb->seid),(struct i40e_asq_cmd_details *)0);
  
#line 9083 
  i40e_veb_clear(veb);
  return_label: 
#line 9084 
                return;
}


#line 9091  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_add_veb(struct i40e_veb *veb, struct i40e_vsi *vsi)
{
  int __retres;
  int ret;
  i40e_status tmp;
  i40e_status tmp_0;
  
#line 9093 
  bool is_default = (_Bool)0;
  
#line 9094 
  bool is_cloud = (_Bool)0;
  
#line 9098 
  tmp = i40e_aq_add_veb(& (veb->pf)->hw,(unsigned short)((int)veb->uplink_seid),(unsigned short)((int)vsi->seid),(unsigned char)((int)veb->enabled_tc),(_Bool)((bool)((int)is_default) != 0),(_Bool)((bool)((int)is_cloud) != 0),& veb->seid,(struct i40e_asq_cmd_details *)0);
  
#line 9098 
  ret = (int)tmp;
  
#line 9101 
  if (ret != 0) {
    
#line 9102 
    _dev_info((struct device const *)(& ((veb->pf)->pdev)->dev),"couldn\'t add VEB, err %d, aq_err %d\n",ret,(unsigned int)(veb->pf)->hw.aq.asq_last_status);
    
#line 9105 
    __retres = -1;
    
#line 9105 
    goto return_label;
  }
  else ;
  
#line 9109 
  tmp_0 = i40e_aq_get_veb_parameters(& (veb->pf)->hw,(unsigned short)((int)veb->seid),(u16 *)0U,(bool *)0,& veb->stats_idx,(u16 *)0U,(u16 *)0U,(struct i40e_asq_cmd_details *)0);
  
#line 9109 
  ret = (int)tmp_0;
  
#line 9111 
  if (ret != 0) {
    
#line 9112 
    _dev_info((struct device const *)(& ((veb->pf)->pdev)->dev),"couldn\'t get VEB statistics idx, err %d, aq_err %d\n",ret,(unsigned int)(veb->pf)->hw.aq.asq_last_status);
    
#line 9115 
    __retres = -1;
    
#line 9115 
    goto return_label;
  }
  else ;
  
#line 9117 
  ret = i40e_veb_get_bw_info(veb);
  
#line 9118 
  if (ret != 0) {
    
#line 9119 
    _dev_info((struct device const *)(& ((veb->pf)->pdev)->dev),"couldn\'t get VEB bw info, err %d, aq_err %d\n",ret,(unsigned int)(veb->pf)->hw.aq.asq_last_status);
    
#line 9122 
    i40e_aq_delete_element(& (veb->pf)->hw,(unsigned short)((int)veb->seid),(struct i40e_asq_cmd_details *)0);
    
#line 9123 
    __retres = -2;
    
#line 9123 
    goto return_label;
  }
  else ;
  
#line 9126 
  vsi->uplink_seid = veb->seid;
  
#line 9127 
  vsi->veb_idx = veb->idx;
  
#line 9128 
  vsi->flags |= 2UL;
  
#line 9130 
  __retres = 0;
  return_label: 
#line 9130 
                return __retres;
}


#line 9149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_veb *i40e_veb_setup(struct i40e_pf *pf, u16 flags, u16 uplink_seid, u16 vsi_seid, u8 enabled_tc)
{
  struct i40e_veb *__retres;
  struct i40e_veb *veb;
  int vsi_idx;
  int veb_idx;
  int ret;
  
#line 9153 
  struct i40e_veb *uplink_veb = (struct i40e_veb *)0;
  
#line 9158 
  if (((unsigned int)uplink_seid == 0U || (unsigned int)vsi_seid == 0U) && (int)uplink_seid + (int)vsi_seid != 0) {
    
#line 9160 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"one, not both seid\'s are 0: uplink=%d vsi=%d\n",(int)uplink_seid,(int)vsi_seid);
    
#line 9163 
    __retres = (struct i40e_veb *)0;
    
#line 9163 
    goto return_label;
  }
  else ;
  
#line 9167 
  vsi_idx = 0;
  
#line 9167 
  goto ldv_63916;
  ldv_63915: 
#line 9168 
  ;
  
#line 9168 
  if (*(pf->vsi + vsi_idx) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + vsi_idx))->seid == (int)vsi_seid) 
    
#line 9169 
    goto ldv_63914; else ;
  
#line 9167 
  vsi_idx += 1;
  ldv_63916: 
#line 9168 
  ;
  
#line 9167 
  if ((int)pf->num_alloc_vsi > vsi_idx) 
#line 9169 
                                        goto ldv_63915; else 
#line 9172 
                                                             goto ldv_63914;
  ldv_63914: 
#line 9173 
  ;
  
#line 9170 
  if ((int)pf->num_alloc_vsi <= vsi_idx && (unsigned int)vsi_seid != 0U) {
    
#line 9171 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"vsi seid %d not found\n",(int)vsi_seid);
    
#line 9173 
    __retres = (struct i40e_veb *)0;
    
#line 9173 
    goto return_label;
  }
  else ;
  
#line 9176 
  if ((unsigned int)uplink_seid != 0U && (int)pf->mac_seid != (int)uplink_seid) {
    
#line 9177 
    veb_idx = 0;
    
#line 9177 
    goto ldv_63919;
    ldv_63918: 
#line 9178 
    ;
    
#line 9178 
    if (pf->veb[veb_idx] != (struct i40e_veb *)0 && (int)(pf->veb[veb_idx])->seid == (int)uplink_seid) {
      
#line 9180 
      uplink_veb = pf->veb[veb_idx];
      
#line 9181 
      goto ldv_63917;
    }
    else ;
    
#line 9177 
    veb_idx += 1;
    ldv_63919: 
#line 9178 
    ;
    
#line 9177 
    if (veb_idx <= 15) 
#line 9179 
                       goto ldv_63918; else 
#line 9182 
                                            goto ldv_63917;
    ldv_63917: 
#line 9183 
    ;
    
#line 9184 
    if (uplink_veb == (struct i40e_veb *)0) {
      
#line 9185 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"uplink seid %d not found\n",(int)uplink_seid);
      
#line 9187 
      __retres = (struct i40e_veb *)0;
      
#line 9187 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 9192 
  veb_idx = i40e_veb_mem_alloc(pf);
  
#line 9193 
  if (veb_idx < 0) 
#line 9194 
                   goto err_alloc; else ;
  
#line 9195 
  veb = pf->veb[veb_idx];
  
#line 9196 
  veb->flags = flags;
  
#line 9197 
  veb->uplink_seid = uplink_seid;
  
#line 9198 
  if (uplink_veb != (struct i40e_veb *)0) 
#line 9198 
                                          veb->veb_idx = uplink_veb->idx; else 
                                                                    
#line 9198 
                                                                    veb->veb_idx = (unsigned short)65535U;
  
#line 9199 
  if ((unsigned int)enabled_tc != 0U) 
#line 9199 
                                      veb->enabled_tc = enabled_tc; else 
                                                                    
#line 9199 
                                                                    veb->enabled_tc = (unsigned char)1U;
  
#line 9202 
  ret = i40e_add_veb(veb,*(pf->vsi + vsi_idx));
  
#line 9203 
  if (ret != 0) 
#line 9204 
                goto err_veb; else ;
  
#line 9205 
  if ((int)pf->lan_vsi == vsi_idx) 
#line 9206 
                                   pf->lan_veb = veb->idx; else ;
  
#line 9208 
  __retres = veb;
  
#line 9208 
  goto return_label;
  err_veb: 
#line 9210 
  ;
  
#line 9211 
  i40e_veb_clear(veb);
  err_alloc: 
#line 9212 
  ;
  
#line 9213 
  __retres = (struct i40e_veb *)0;
  return_label: 
#line 9213 
                return __retres;
}


#line 9225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_setup_pf_switch_element(struct i40e_pf *pf, struct i40e_aqc_switch_config_element_resp *ele, u16 num_reported, bool printconfig)
{
  
#line 9229 
  u16 downlink_seid = ele->downlink_seid;
  
#line 9230 
  u16 uplink_seid = ele->uplink_seid;
  
#line 9231 
  u8 element_type = ele->element_type;
  
#line 9232 
  u16 seid = ele->seid;
  
#line 9234 
  if ((int)printconfig != 0) 
#line 9235 
                             _dev_info((struct device const *)(& (pf->pdev)->dev),"type=%d seid=%d uplink=%d downlink=%d\n",(int)element_type,(int)seid,(int)uplink_seid,(int)downlink_seid); else ;
  
#line 9239 
  switch ((int)element_type) {
    case 1: 
#line 9240 
    ;
    
#line 9241 
    pf->mac_seid = seid;
    
#line 9242 
    goto ldv_63933;
    case 17: 
#line 9243 
    ;
    
#line 9245 
    if ((int)pf->mac_seid != (int)uplink_seid) 
#line 9246 
                                               goto ldv_63933; else ;
    
#line 9247 
    if ((unsigned int)pf->lan_veb == 65535U) {
      int v;
      
#line 9251 
      v = 0;
      
#line 9251 
      goto ldv_63938;
      ldv_63937: 
#line 9252 
      ;
      
#line 9252 
      if (pf->veb[v] != (struct i40e_veb *)0 && (int)(pf->veb[v])->seid == (int)seid) {
        
#line 9253 
        pf->lan_veb = (unsigned short)v;
        
#line 9254 
        goto ldv_63936;
      }
      else ;
      
#line 9251 
      v += 1;
      ldv_63938: 
#line 9252 
      ;
      
#line 9251 
      if (v <= 15) 
#line 9253 
                   goto ldv_63937; else 
#line 9256 
                                        goto ldv_63936;
      ldv_63936: 
#line 9257 
      ;
      
#line 9257 
      if ((unsigned int)pf->lan_veb == 65535U) {
        
#line 9258 
        v = i40e_veb_mem_alloc(pf);
        
#line 9259 
        if (v < 0) 
#line 9260 
                   goto ldv_63933; else ;
        
#line 9261 
        pf->lan_veb = (unsigned short)v;
      }
      else ;
    }
    else ;
    
#line 9265 
    (pf->veb[(int)pf->lan_veb])->seid = seid;
    
#line 9266 
    (pf->veb[(int)pf->lan_veb])->uplink_seid = pf->mac_seid;
    
#line 9267 
    (pf->veb[(int)pf->lan_veb])->pf = pf;
    
#line 9268 
    (pf->veb[(int)pf->lan_veb])->veb_idx = (unsigned short)65535U;
    
#line 9269 
    goto ldv_63933;
    case 19: 
#line 9270 
    ;
    
#line 9271 
    if ((unsigned int)num_reported != 1U) 
#line 9272 
                                          goto ldv_63933; else ;
    
#line 9276 
    pf->mac_seid = uplink_seid;
    
#line 9277 
    pf->pf_seid = downlink_seid;
    
#line 9278 
    pf->main_vsi_seid = seid;
    
#line 9279 
    if ((int)printconfig != 0) 
#line 9280 
                               _dev_info((struct device const *)(& (pf->pdev)->dev),"pf_seid=%d main_vsi_seid=%d\n",(int)pf->pf_seid,(int)pf->main_vsi_seid); else ;
    
#line 9283 
    goto ldv_63933;
    case 2: 
#line 9284 
    ;
    case 3: 
#line 9285 
    ;
    case 4: 
#line 9286 
    ;
    case 6: 
#line 9287 
    ;
    case 16: 
#line 9288 
    ;
    case 18: 
#line 9289 
    ;
    
#line 9291 
    goto ldv_63933;
    default: 
#line 9292 
    ;
    
#line 9293 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"unknown element type=%d seid=%d\n",(int)element_type,(int)seid);
    
#line 9295 
    goto ldv_63933;
  }
  ldv_63933: 
#line 9297 
  ;
  
#line 9298 
  return;
}


#line 9307  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_fetch_switch_configuration(struct i40e_pf *pf, bool printconfig)
{
  int __retres;
  struct i40e_aqc_get_switch_config_resp *sw_config;
  u8 *aq_buf;
  int i;
  
#line 9310 
  u16 next_seid = (unsigned short)0U;
  
#line 9311 
  int ret = 0;
  
#line 9315 
  aq_buf = (u8 *)kzalloc_0(512UL,208U);
  
#line 9316 
  if (aq_buf == (u8 *)0U) {
    
#line 9317 
    __retres = -12;
    
#line 9317 
    goto return_label;
  }
  else ;
  
#line 9319 
  sw_config = (struct i40e_aqc_get_switch_config_resp *)aq_buf;
  ldv_63962: 
#line 9320 
  ;
  {
    u16 num_reported;
    u16 num_total;
    i40e_status tmp_0;
    
#line 9323 
    tmp_0 = i40e_aq_get_switch_config(& pf->hw,sw_config,(unsigned short)512,& next_seid,(struct i40e_asq_cmd_details *)0);
    
#line 9323 
    ret = (int)tmp_0;
    
#line 9326 
    if (ret != 0) {
      
#line 9327 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"get switch config failed %d aq_err=%x\n",ret,(unsigned int)pf->hw.aq.asq_last_status);
      
#line 9330 
      kfree((void const *)aq_buf);
      
#line 9331 
      __retres = -2;
      
#line 9331 
      goto return_label;
    }
    else ;
    
#line 9334 
    num_reported = sw_config->header.num_reported;
    
#line 9335 
    num_total = sw_config->header.num_total;
    
#line 9337 
    if ((int)printconfig != 0) 
#line 9338 
                               _dev_info((struct device const *)(& (pf->pdev)->dev),"header: %d reported %d total\n",(int)num_reported,(int)num_total); else ;
    
#line 9342 
    i = 0;
    
#line 9342 
    goto ldv_63960;
    ldv_63959: 
#line 9343 
    ;
    {
      
#line 9343 
      struct i40e_aqc_switch_config_element_resp *ele = & sw_config->element[i];
      
#line 9346 
      i40e_setup_pf_switch_element(pf,ele,(unsigned short)((int)num_reported),(_Bool)((bool)((int)printconfig) != 0));
    }
    
#line 9342 
    i += 1;
    ldv_63960: 
#line 9343 
    ;
    
#line 9342 
    if ((int)num_reported > i) 
#line 9344 
                               goto ldv_63959; else 
#line 9347 
                                                    goto ldv_63961;
    ldv_63961: 
#line 9348 
    ;
  }
  
#line 9349 
  if ((unsigned int)next_seid != 0U) 
#line 9351 
                                     goto ldv_63962; else 
#line 9354 
                                                          goto ldv_63963;
  ldv_63963: 
#line 9355 
  ;
  
#line 9351 
  kfree((void const *)aq_buf);
  
#line 9352 
  __retres = ret;
  return_label: 
#line 9352 
                return __retres;
}


#line 9362  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_pf_switch(struct i40e_pf *pf, bool reinit)
{
  int __retres;
  int ret;
  
#line 9367 
  ret = i40e_fetch_switch_configuration(pf,(_Bool)0);
  
#line 9368 
  if (ret != 0) {
    
#line 9369 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"couldn\'t fetch switch config, err %d, aq_err %d\n",ret,(unsigned int)pf->hw.aq.asq_last_status);
    
#line 9372 
    __retres = ret;
    
#line 9372 
    goto return_label;
  }
  else ;
  
#line 9374 
  i40e_pf_reset_stats(pf);
  
#line 9377 
  if ((unsigned int)pf->lan_vsi == 65535U || (int)reinit != 0) {
    u16 uplink_seid;
    
#line 9378 
    struct i40e_vsi *vsi = (struct i40e_vsi *)0;
    
#line 9384 
    if ((unsigned int)pf->lan_veb != 65535U && pf->veb[(int)pf->lan_veb] != (struct i40e_veb *)0) 
      
#line 9385 
      uplink_seid = (pf->veb[(int)pf->lan_veb])->seid; else 
#line 9387 
                                                            uplink_seid = pf->mac_seid;
    
#line 9388 
    if ((unsigned int)pf->lan_vsi == 65535U) 
#line 9389 
                                             vsi = i40e_vsi_setup(pf,(unsigned char)0,(unsigned short)((int)uplink_seid),0U);
    else 
      
#line 9390 
      if ((int)reinit != 0) 
#line 9391 
                            vsi = i40e_vsi_reinit_setup(*(pf->vsi + (int)pf->lan_vsi)); else ;
    
#line 9392 
    if (vsi == (struct i40e_vsi *)0) {
      
#line 9393 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"setup of MAIN VSI failed\n");
      
#line 9394 
      i40e_fdir_teardown(pf);
      
#line 9395 
      __retres = -11;
      
#line 9395 
      goto return_label;
    }
    else ;
  }
  else {
    
#line 9399 
    u8 enabled_tc = (*(pf->vsi + (int)pf->lan_vsi))->tc_config.enabled_tc;
    
#line 9400 
    (*(pf->vsi + (int)pf->lan_vsi))->tc_config.enabled_tc = (unsigned char)0U;
    
#line 9401 
    (*(pf->vsi + (int)pf->lan_vsi))->seid = pf->main_vsi_seid;
    
#line 9402 
    i40e_vsi_config_tc(*(pf->vsi + (int)pf->lan_vsi),(unsigned char)((int)enabled_tc));
  }
  
#line 9404 
  i40e_vlan_stripping_disable(*(pf->vsi + (int)pf->lan_vsi));
  
#line 9406 
  i40e_fdir_sb_setup(pf);
  
#line 9409 
  ret = i40e_setup_pf_filter_control(pf);
  
#line 9410 
  if (ret != 0) 
#line 9411 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"setup_pf_filter_control failed: %d\n",ret); else ;
  
#line 9419 
  if ((pf->flags & 64ULL) != 0ULL) 
#line 9420 
                                   i40e_config_rss(pf); else ;
  
#line 9423 
  i40e_aq_get_link_info(& pf->hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
  
#line 9424 
  i40e_link_event(pf);
  
#line 9427 
  pf->fc_autoneg_status = (_Bool)(((int)pf->hw.phy.link_info.an_info & 1) != 0);
  
#line 9430 
  i40e_ptp_init(pf);
  
#line 9432 
  __retres = ret;
  return_label: 
#line 9432 
                return __retres;
}


#line 9439  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_determine_queue_usage(struct i40e_pf *pf)
{
  int queues_left;
  
#line 9443 
  pf->num_lan_qps = (unsigned short)0U;
  
#line 9445 
  pf->num_fcoe_qps = (unsigned short)0U;
  
#line 9452 
  queues_left = (int)pf->hw.func_caps.num_tx_qp;
  
#line 9454 
  if (queues_left == 1 || (pf->flags & 8ULL) == 0ULL) {
    u16 tmp;
    
#line 9457 
    queues_left = 0;
    
#line 9458 
    tmp = (unsigned short)1U;
    
#line 9458 
    pf->num_lan_qps = tmp;
    
#line 9458 
    pf->rss_size = tmp;
    
#line 9461 
    pf->flags &= 18446744073165862719ULL;
  }
  else 
    
#line 9470 
    if ((pf->flags & 543162432ULL) == 0ULL) {
      u16 tmp_0;
      
#line 9475 
      tmp_0 = (unsigned short)1U;
      
#line 9475 
      pf->num_lan_qps = tmp_0;
      
#line 9475 
      pf->rss_size = tmp_0;
      
#line 9476 
      queues_left -= (int)pf->num_lan_qps;
      
#line 9478 
      pf->flags &= 18446744073702209343ULL;
    }
    else {
      int tmp_3;
      int tmp_5;
      
#line 9488 
      if ((pf->flags & 536870912ULL) != 0ULL && queues_left <= 7) {
        
#line 9490 
        pf->flags &= 18446744073172680703ULL;
        
#line 9491 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"not enough queues for DCB. DCB is disabled.\n");
      }
      else ;
      {
        unsigned int tmp_1;
        int tmp_2;
        
#line 9493 
        int __max1 = (int)pf->rss_size_max;
        
#line 9493 
        tmp_1 = cpumask_weight(cpu_online_mask);
        
#line 9493 
        int __max2 = (int)tmp_1;
        
#line 9493 
        if (__max1 > __max2) 
#line 9493 
                             tmp_2 = __max1; else 
#line 9493 
                                                  tmp_2 = __max2;
        
#line 9493 
        tmp_3 = tmp_2;
      }
      
#line 9493 
      pf->num_lan_qps = (unsigned short)tmp_3;
      {
        int tmp_4;
        
#line 9495 
        int __min1 = (int)pf->num_lan_qps;
        
#line 9495 
        int __min2 = (int)pf->hw.func_caps.num_tx_qp;
        
#line 9495 
        if (__min1 < __min2) 
#line 9495 
                             tmp_4 = __min1; else 
#line 9495 
                                                  tmp_4 = __min2;
        
#line 9495 
        tmp_5 = tmp_4;
      }
      
#line 9495 
      pf->num_lan_qps = (unsigned short)tmp_5;
      
#line 9498 
      queues_left -= (int)pf->num_lan_qps;
    }
  
#line 9502 
  if ((pf->flags & 2048ULL) != 0ULL) {
    
#line 9503 
    if (queues_left > 7) 
#line 9504 
                         pf->num_fcoe_qps = (unsigned short)8U;
    else 
      
#line 9505 
      if (queues_left > 0) 
#line 9506 
                           pf->num_fcoe_qps = (unsigned short)1U;
      else {
        
#line 9508 
        pf->num_fcoe_qps = (unsigned short)0U;
        
#line 9509 
        pf->flags &= 18446744073709549567ULL;
        
#line 9510 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"not enough queues for FCoE. FCoE feature will be disabled\n");
      }
    
#line 9513 
    queues_left -= (int)pf->num_fcoe_qps;
  }
  else ;
  
#line 9517 
  if ((pf->flags & 2097152ULL) != 0ULL) 
    
#line 9518 
    if (queues_left > 1) 
#line 9519 
                         queues_left += -1;
    else {
      
#line 9521 
      pf->flags &= 18446744073707454463ULL;
      
#line 9522 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"not enough queues for Flow Director. Flow Director feature is disabled\n");
    }
  else ;
  
#line 9526 
  if ((((pf->flags & 524288ULL) != 0ULL && (unsigned int)pf->num_vf_qps != 0U) && (unsigned int)pf->num_req_vfs != 0U) && queues_left != 0) {
    int tmp_7;
    {
      int tmp_6;
      
#line 9528 
      int __min1_0 = (int)pf->num_req_vfs;
      
#line 9528 
      int __min2_0 = queues_left / (int)pf->num_vf_qps;
      
#line 9528 
      if (__min1_0 < __min2_0) 
#line 9528 
                               tmp_6 = __min1_0; else 
#line 9528 
                                                      tmp_6 = __min2_0;
      
#line 9528 
      tmp_7 = tmp_6;
    }
    
#line 9528 
    pf->num_req_vfs = (unsigned short)tmp_7;
    
#line 9530 
    queues_left -= (int)pf->num_req_vfs * (int)pf->num_vf_qps;
  }
  else ;
  
#line 9533 
  if ((((pf->flags & 128ULL) != 0ULL && (unsigned int)pf->num_vmdq_vsis != 0U) && (unsigned int)pf->num_vmdq_qps != 0U) && queues_left != 0) {
    int tmp_9;
    {
      int tmp_8;
      
#line 9535 
      int __min1_1 = (int)pf->num_vmdq_vsis;
      
#line 9535 
      int __min2_1 = queues_left / (int)pf->num_vmdq_qps;
      
#line 9535 
      if (__min1_1 < __min2_1) 
#line 9535 
                               tmp_8 = __min1_1; else 
#line 9535 
                                                      tmp_8 = __min2_1;
      
#line 9535 
      tmp_9 = tmp_8;
    }
    
#line 9535 
    pf->num_vmdq_vsis = (unsigned short)tmp_9;
    
#line 9537 
    queues_left -= (int)pf->num_vmdq_vsis * (int)pf->num_vmdq_qps;
  }
  else ;
  
#line 9540 
  pf->queues_left = queues_left;
  
#line 9542 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"fcoe queues = %d\n",(int)pf->num_fcoe_qps);
  
#line 9543 
  return;
}


#line 9557  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_pf_filter_control(struct i40e_pf *pf)
{
  int __retres;
  i40e_status tmp;
  
#line 9559 
  struct i40e_filter_control_settings *settings = & pf->filter_settings;
  
#line 9561 
  settings->hash_lut_size = I40E_HASH_LUT_SIZE_128;
  
#line 9564 
  if ((pf->flags & 6291456ULL) != 0ULL) 
#line 9565 
                                        settings->enable_fdir = (_Bool)1; else ;
  
#line 9568 
  settings->enable_ethtype = (_Bool)1;
  
#line 9569 
  settings->enable_macvlan = (_Bool)1;
  
#line 9571 
  tmp = i40e_set_filter_control(& pf->hw,settings);
  
#line 9571 
  if (tmp != I40E_SUCCESS) {
    
#line 9572 
    __retres = -2;
    
#line 9572 
    goto return_label;
  }
  else ;
  
#line 9574 
  __retres = 0;
  return_label: 
#line 9574 
                return __retres;
}


#line 9578  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_print_features(struct i40e_pf *pf)
{
  char *buf;
  char *string;
  int tmp_0;
  int tmp_1;
  int tmp_3;
  char *tmp_2;
  
#line 9580 
  struct i40e_hw *hw = & pf->hw;
  
#line 9583 
  string = (char *)kzalloc_0(255UL,208U);
  
#line 9584 
  if (string == (char *)0) {
    
#line 9585 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Features string allocation failed\n");
    
#line 9586 
    goto return_label;
  }
  else ;
  
#line 9589 
  buf = string;
  
#line 9591 
  tmp_0 = sprintf(string,"Features: PF-id[%d] ",(int)hw->pf_id);
  
#line 9591 
  buf += tmp_0;
  
#line 9593 
  tmp_1 = sprintf(buf,"VFs: %d ",(int)pf->num_req_vfs);
  
#line 9593 
  buf += tmp_1;
  
#line 9597 
  if ((pf->flags & 32ULL) != 0ULL) 
#line 9597 
                                   tmp_2 = (char *)"PS"; else 
#line 9597 
                                                              tmp_2 = (char *)"1BUF";
  
#line 9595 
  ;
  
#line 9595 
  ;
  
#line 9595 
  tmp_3 = sprintf(buf,"VSIs: %d QP: %d RX: %s ",pf->hw.func_caps.num_vsis,(int)(*(pf->vsi + (int)pf->lan_vsi))->num_queue_pairs,tmp_2);
  
#line 9598 
  buf += tmp_3;
  
#line 9600 
  if ((pf->flags & 64ULL) != 0ULL) {
    int tmp_4;
    
#line 9601 
    tmp_4 = sprintf(buf,"RSS ");
    
#line 9601 
    buf += tmp_4;
  }
  else ;
  
#line 9602 
  if ((pf->flags & 4194304ULL) != 0ULL) {
    int tmp_5;
    
#line 9603 
    tmp_5 = sprintf(buf,"FD_ATR ");
    
#line 9603 
    buf += tmp_5;
  }
  else ;
  
#line 9604 
  if ((pf->flags & 2097152ULL) != 0ULL) {
    int tmp_6;
    int tmp_7;
    
#line 9605 
    tmp_6 = sprintf(buf,"FD_SB ");
    
#line 9605 
    buf += tmp_6;
    
#line 9606 
    tmp_7 = sprintf(buf,"NTUPLE ");
    
#line 9606 
    buf += tmp_7;
  }
  else ;
  
#line 9608 
  if ((pf->flags & 536870912ULL) != 0ULL) {
    int tmp_8;
    
#line 9609 
    tmp_8 = sprintf(buf,"DCB ");
    
#line 9609 
    buf += tmp_8;
  }
  else ;
  
#line 9610 
  if ((pf->flags & 33554432ULL) != 0ULL) {
    int tmp_9;
    
#line 9611 
    tmp_9 = sprintf(buf,"PTP ");
    
#line 9611 
    buf += tmp_9;
  }
  else ;
  
#line 9613 
  if ((pf->flags & 2048ULL) != 0ULL) {
    int tmp_10;
    
#line 9614 
    tmp_10 = sprintf(buf,"FCOE ");
    
#line 9614 
    buf += tmp_10;
  }
  else ;
  
#line 9617 
  if ((long)(string + 255U < buf) != 0L) {
    
#line 9619 
    ldv_inline_asm();
    
#line 9617 
    ;
  }
  else ;
  
#line 9618 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"%s\n",string);
  
#line 9619 
  kfree((void const *)string);
  return_label: 
#line 9620 
                return;
}


#line 9633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_probe(struct pci_dev *pdev, struct pci_device_id const *ent)
{
  int __retres;
  struct i40e_aq_get_phy_abilities_resp abilities;
  unsigned long ioremap_len;
  struct i40e_pf *pf;
  struct i40e_hw *hw;
  u16 pfs_found;
  u16 link_status;
  u32 len;
  u32 i;
  int tmp;
  unsigned long tmp_3;
  i40e_status tmp_7;
  char const *tmp_8;
  char const *tmp_9;
  i40e_status tmp_10;
  i40e_status tmp_11;
  char *tmp_12;
  i40e_status tmp_13;
  i40e_status tmp_14;
  int tmp_16;
  bool tmp_15;
  bool tmp_17;
  i40e_status tmp_18;
  int tmp_20;
  bool tmp_19;
  i40e_status tmp_24;
  unsigned long tmp_29;
  char *tmp_33;
  char *tmp_36;
  enum i40e_status_code tmp_37;
  int tmp_38;
  
#line 9641 
  int err = 0;
  
#line 9645 
  err = pci_enable_device_mem(pdev);
  
#line 9646 
  if (err != 0) {
    
#line 9647 
    __retres = err;
    
#line 9647 
    goto return_label;
  }
  else ;
  
#line 9650 
  err = dma_set_mask_and_coherent(& pdev->dev,18446744073709551615ULL);
  
#line 9651 
  if (err != 0) {
    
#line 9652 
    err = dma_set_mask_and_coherent(& pdev->dev,4294967295ULL);
    
#line 9653 
    if (err != 0) {
      
#line 9654 
      dev_err((struct device const *)(& pdev->dev),"DMA configuration failed: 0x%x\n",err);
      
#line 9656 
      goto err_dma;
    }
    else ;
  }
  else ;
  
#line 9661 
  tmp = pci_select_bars(pdev,512UL);
  
#line 9661 
  ;
  
#line 9661 
  err = pci_request_selected_regions(pdev,tmp,(char const *)(& i40e_driver_name));
  
#line 9663 
  if (err != 0) {
    
#line 9664 
    _dev_info((struct device const *)(& pdev->dev),"pci_request_selected_regions failed %d\n",err);
    
#line 9666 
    goto err_pci_reg;
  }
  else ;
  
#line 9669 
  pci_enable_pcie_error_reporting(pdev);
  
#line 9670 
  pci_set_master(pdev);
  
#line 9677 
  pf = (struct i40e_pf *)kzalloc_0(135240UL,208U);
  
#line 9678 
  if (pf == (struct i40e_pf *)0) {
    
#line 9679 
    err = -12;
    
#line 9680 
    goto err_pf_alloc;
  }
  else ;
  
#line 9682 
  pf->next_vsi = (unsigned short)0U;
  
#line 9683 
  pf->pdev = pdev;
  
#line 9684 
  clear_bit(3L,(unsigned long volatile *)(& pf->state));
  
#line 9686 
  hw = & pf->hw;
  
#line 9687 
  hw->back = (void *)pf;
  {
    resource_size_t tmp_1;
    unsigned long tmp_2;
    
#line 9689 
    if (pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start) 
      
#line 9689 
      tmp_1 = (pdev->resource[0].end - pdev->resource[0].start) + 1ULL; else 
                                                                    
#line 9689 
                                                                    tmp_1 = 0ULL;
    
#line 9689 
    unsigned long __min1 = (unsigned long)tmp_1;
    
#line 9689 
    unsigned long __min2 = 4128768UL;
    
#line 9689 
    if (__min1 < __min2) 
#line 9689 
                         tmp_2 = __min1; else 
#line 9689 
                                              tmp_2 = __min2;
    
#line 9689 
    tmp_3 = tmp_2;
  }
  
#line 9689 
  ioremap_len = tmp_3;
  
#line 9692 
  hw->hw_addr = (u8 *)ioremap(pdev->resource[0].start,ioremap_len);
  
#line 9693 
  if (hw->hw_addr == (u8 *)0U) {
    unsigned int tmp_5;
    
#line 9694 
    err = -5;
    
#line 9695 
    ;
    
#line 9695 
    if (pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start) 
      
#line 9695 
      tmp_5 = (unsigned int)((pdev->resource[0].end - pdev->resource[0].start) + 1ULL); else 
                                                                    
#line 9695 
                                                                    tmp_5 = 0U;
    
#line 9695 
    ;
    
#line 9695 
    ;
    
#line 9695 
    _dev_info((struct device const *)(& pdev->dev),"ioremap(0x%04x, 0x%04x) failed: 0x%x\n",(unsigned int)pdev->resource[0].start,tmp_5,err);
    
#line 9698 
    goto err_ioremap;
  }
  else ;
  
#line 9700 
  hw->vendor_id = pdev->vendor;
  
#line 9701 
  hw->device_id = pdev->device;
  
#line 9702 
  pci_read_config_byte((struct pci_dev const *)pdev,8,& hw->revision_id);
  
#line 9703 
  hw->subsystem_vendor_id = pdev->subsystem_vendor;
  
#line 9704 
  hw->subsystem_device_id = pdev->subsystem_device;
  
#line 9705 
  hw->bus.device = (unsigned short)((unsigned int)((unsigned short)(pdev->devfn >> 3)) & 31U);
  
#line 9706 
  hw->bus.func = (unsigned short)((unsigned int)((unsigned short)pdev->devfn) & 7U);
  
#line 9707 
  pf->instance = pfs_found;
  
#line 9709 
  if (debug != -1) {
    
#line 9710 
    pf->msg_enable = pf->hw.debug_mask;
    
#line 9711 
    pf->msg_enable = (unsigned int)debug;
  }
  else ;
  
#line 9715 
  if ((unsigned int)hw->revision_id == 0U) {
    unsigned int tmp_6;
    
#line 9715 
    tmp_6 = readl((void const volatile *)(hw->hw_addr + 1221888U));
    
#line 9715 
    if ((tmp_6 & 1U) != 0U) {
      
#line 9717 
      writel(1U,(void volatile *)(hw->hw_addr + 754064U));
      
#line 9718 
      readl((void const volatile *)(hw->hw_addr + 745772U));
      
#line 9719 
      msleep(200U);
      
#line 9720 
      pf->corer_count = (u16)((int)pf->corer_count + 1);
      
#line 9722 
      i40e_clear_pxe_mode(hw);
    }
    else ;
  }
  else ;
  
#line 9726 
  i40e_clear_hw(hw);
  
#line 9727 
  tmp_7 = i40e_pf_reset(hw);
  
#line 9727 
  err = (int)tmp_7;
  
#line 9728 
  if (err != 0) {
    
#line 9729 
    _dev_info((struct device const *)(& pdev->dev),"Initial pf_reset failed: %d\n",err);
    
#line 9730 
    goto err_pf_reset;
  }
  else ;
  
#line 9732 
  pf->pfr_count = (u16)((int)pf->pfr_count + 1);
  
#line 9734 
  hw->aq.num_arq_entries = (unsigned short)256U;
  
#line 9735 
  hw->aq.num_asq_entries = (unsigned short)256U;
  
#line 9736 
  hw->aq.arq_buf_size = (unsigned short)4096U;
  
#line 9737 
  hw->aq.asq_buf_size = (unsigned short)4096U;
  
#line 9738 
  pf->adminq_work_limit = (unsigned short)32U;
  
#line 9742 
  tmp_8 = dev_name((struct device const *)(& pdev->dev));
  
#line 9741 
  tmp_9 = dev_driver_string((struct device const *)(& (pf->pdev)->dev));
  
#line 9740 
  ;
  
#line 9740 
  snprintf((char *)(& pf->int_name),24UL,"%s-%s:misc",tmp_9,tmp_8);
  
#line 9744 
  tmp_10 = i40e_init_shared_code(hw);
  
#line 9744 
  err = (int)tmp_10;
  
#line 9745 
  if (err != 0) {
    
#line 9746 
    _dev_info((struct device const *)(& pdev->dev),"init_shared_code failed: %d\n",err);
    
#line 9747 
    goto err_pf_reset;
  }
  else ;
  
#line 9751 
  pf->hw.fc.requested_mode = I40E_FC_NONE;
  
#line 9753 
  tmp_11 = i40e_init_adminq(hw);
  
#line 9753 
  err = (int)tmp_11;
  
#line 9754 
  tmp_12 = i40e_fw_version_str(hw);
  
#line 9754 
  ;
  
#line 9754 
  _dev_info((struct device const *)(& pdev->dev),"%s\n",tmp_12);
  
#line 9755 
  if (err != 0) {
    
#line 9756 
    _dev_info((struct device const *)(& pdev->dev),"The driver for the device stopped because the NVM image is newer than expected. You must install the most recent version of the network driver.\n");
    
#line 9758 
    goto err_pf_reset;
  }
  else ;
  
#line 9761 
  if ((unsigned int)hw->aq.api_maj_ver == 1U && (unsigned int)hw->aq.api_min_ver > 2U) 
    
#line 9763 
    _dev_info((struct device const *)(& pdev->dev),"The driver for the device detected a newer version of the NVM image than expected. Please install the most recent version of the network driver.\n");
  else 
    
#line 9765 
    if ((unsigned int)hw->aq.api_maj_ver == 0U || (unsigned int)hw->aq.api_min_ver == 0U) 
      
#line 9767 
      _dev_info((struct device const *)(& pdev->dev),"The driver for the device detected an older version of the NVM image than expected. Please update the NVM image.\n"); else ;
  
#line 9770 
  i40e_verify_eeprom(pf);
  
#line 9773 
  if ((unsigned int)hw->revision_id == 0U) 
#line 9774 
                                           dev_warn((struct device const *)(& pdev->dev),"This device is a pre-production adapter/LOM. Please be aware there may be issues with your hardware. If you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\n"); else ;
  
#line 9776 
  i40e_clear_pxe_mode(hw);
  
#line 9777 
  err = i40e_get_capabilities(pf);
  
#line 9778 
  if (err != 0) 
#line 9779 
                goto err_adminq_setup; else ;
  
#line 9781 
  err = i40e_sw_init(pf);
  
#line 9782 
  if (err != 0) {
    
#line 9783 
    _dev_info((struct device const *)(& pdev->dev),"sw_init failed: %d\n",err);
    
#line 9784 
    goto err_sw_init;
  }
  else ;
  
#line 9787 
  tmp_13 = i40e_init_lan_hmc(hw,hw->func_caps.num_tx_qp,hw->func_caps.num_rx_qp,pf->fcoe_hmc_cntx_num,pf->fcoe_hmc_filt_num);
  
#line 9787 
  err = (int)tmp_13;
  
#line 9790 
  if (err != 0) {
    
#line 9791 
    _dev_info((struct device const *)(& pdev->dev),"init_lan_hmc failed: %d\n",err);
    
#line 9792 
    goto err_init_lan_hmc;
  }
  else ;
  
#line 9795 
  tmp_14 = i40e_configure_lan_hmc(hw,(enum i40e_hmc_model)I40E_HMC_MODEL_DIRECT_ONLY);
  
#line 9795 
  err = (int)tmp_14;
  
#line 9796 
  if (err != 0) {
    
#line 9797 
    _dev_info((struct device const *)(& pdev->dev),"configure_lan_hmc failed: %d\n",err);
    
#line 9798 
    err = -2;
    
#line 9799 
    goto err_configure_lan_hmc;
  }
  else ;
  
#line 9806 
  if (((unsigned int)pf->hw.aq.fw_maj_ver == 4U && (unsigned int)pf->hw.aq.fw_min_ver <= 2U) || (unsigned int)pf->hw.aq.fw_maj_ver <= 3U) {
    
#line 9808 
    _dev_info((struct device const *)(& pdev->dev),"Stopping firmware LLDP agent.\n");
    
#line 9809 
    i40e_aq_stop_lldp(hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
  }
  else ;
  
#line 9812 
  i40e_get_mac_addr(hw,(u8 *)(& hw->mac.addr));
  
#line 9813 
  tmp_15 = is_valid_ether_addr((u8 const *)(& hw->mac.addr));
  
#line 9813 
  if (tmp_15) 
#line 9813 
              tmp_16 = 0; else 
#line 9813 
                               tmp_16 = 1;
  
#line 9813 
  if (tmp_16) {
    
#line 9814 
    _dev_info((struct device const *)(& pdev->dev),"invalid MAC address %pM\n",(u8 *)(& hw->mac.addr));
    
#line 9815 
    err = -5;
    
#line 9816 
    goto err_mac_addr;
  }
  else ;
  
#line 9818 
  _dev_info((struct device const *)(& pdev->dev),"MAC address: %pM\n",(u8 *)(& hw->mac.addr));
  
#line 9819 
  ether_addr_copy((u8 *)(& hw->mac.perm_addr),(u8 const *)(& hw->mac.addr));
  
#line 9820 
  i40e_get_port_mac_addr(hw,(u8 *)(& hw->mac.port_addr));
  
#line 9821 
  tmp_17 = is_valid_ether_addr((u8 const *)(& hw->mac.port_addr));
  
#line 9821 
  if ((int)tmp_17 != 0) 
#line 9822 
                        pf->flags |= 268435456ULL; else ;
  
#line 9824 
  tmp_18 = i40e_get_san_mac_addr(hw,(u8 *)(& hw->mac.san_addr));
  
#line 9824 
  err = (int)tmp_18;
  
#line 9825 
  if (err != 0) 
#line 9826 
                _dev_info((struct device const *)(& pdev->dev),"(non-fatal) SAN MAC retrieval failed: %d\n",err); else ;
  
#line 9828 
  tmp_19 = is_valid_ether_addr((u8 const *)(& hw->mac.san_addr));
  
#line 9828 
  if (tmp_19) 
#line 9828 
              tmp_20 = 0; else 
#line 9828 
                               tmp_20 = 1;
  
#line 9828 
  if (tmp_20) {
    
#line 9829 
    dev_warn((struct device const *)(& pdev->dev),"invalid SAN MAC address %pM, falling back to LAN MAC\n",(u8 *)(& hw->mac.san_addr));
    
#line 9831 
    ether_addr_copy((u8 *)(& hw->mac.san_addr),(u8 const *)(& hw->mac.addr));
  }
  else ;
  
#line 9833 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"SAN MAC: %pM\n",(u8 *)(& hw->mac.san_addr));
  
#line 9836 
  pci_set_drvdata(pdev,(void *)pf);
  
#line 9837 
  pci_save_state(pdev);
  
#line 9839 
  err = i40e_init_pf_dcb(pf);
  
#line 9840 
  if (err != 0) {
    
#line 9841 
    _dev_info((struct device const *)(& pdev->dev),"DCB init failed %d, disabled\n",err);
    
#line 9842 
    pf->flags &= 18446744073172680703ULL;
  }
  else ;
  {
    struct lock_class_key __key;
    
#line 9848 
    init_timer_key(& pf->service_timer,0U,"((&pf->service_timer))",& __key);
  }
  
#line 9848 
  pf->service_timer.function = & i40e_service_timer;
  
#line 9848 
  pf->service_timer.data = (unsigned long)pf;
  
#line 9849 
  pf->service_timer_period = 250UL;
  {
    struct lock_class_key __key_0;
    
#line 9851 
    __init_work(& pf->service_task,0);
    
#line 9851 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 9851 
    pf->service_task.data = __constr_expr_37;
    
#line 9851 
    lockdep_init_map(& pf->service_task.lockdep_map,"(&pf->service_task)",& __key_0,0);
    
#line 9851 
    INIT_LIST_HEAD(& pf->service_task.entry);
    
#line 9851 
    pf->service_task.func = & i40e_service_task;
  }
  
#line 9852 
  clear_bit(5L,(unsigned long volatile *)(& pf->state));
  
#line 9853 
  pf->flags |= 512ULL;
  
#line 9854 
  pf->link_check_timeout = jiffies;
  
#line 9857 
  pf->wol_en = (_Bool)0;
  
#line 9858 
  device_set_wakeup_enable(& (pf->pdev)->dev,(_Bool)((bool)((int)pf->wol_en) != 0));
  
#line 9861 
  i40e_determine_queue_usage(pf);
  
#line 9862 
  err = i40e_init_interrupt_scheme(pf);
  
#line 9863 
  if (err != 0) 
#line 9864 
                goto err_switch_setup; else ;
  
#line 9871 
  if (pf->hw.func_caps.num_vsis <= 50U) 
#line 9872 
                                        pf->num_alloc_vsi = (unsigned short)51U; else 
                                                                    
#line 9874 
                                                                    pf->num_alloc_vsi = (unsigned short)pf->hw.func_caps.num_vsis;
  
#line 9877 
  len = (unsigned int)pf->num_alloc_vsi * 8U;
  
#line 9878 
  pf->vsi = (struct i40e_vsi **)kzalloc_0((unsigned long)len,208U);
  
#line 9879 
  if (pf->vsi == (struct i40e_vsi **)0) {
    
#line 9880 
    err = -12;
    
#line 9881 
    goto err_switch_setup;
  }
  else ;
  
#line 9886 
  if ((pf->flags & 524288ULL) != 0ULL && (pf->flags & 8ULL) != 0ULL) {
    int tmp_23;
    
#line 9887 
    tmp_23 = constant_test_bit(20L,(unsigned long const volatile *)(& pf->state));
    
#line 9887 
    if (tmp_23 == 0) {
      int tmp_22;
      
#line 9889 
      tmp_22 = pci_num_vf(pdev);
      
#line 9889 
      if (tmp_22 != 0) 
#line 9890 
                       pf->flags |= 1099511627776ULL; else ;
    }
    else ;
  }
  else ;
  
#line 9893 
  err = i40e_setup_pf_switch(pf,(_Bool)0);
  
#line 9894 
  if (err != 0) {
    
#line 9895 
    _dev_info((struct device const *)(& pdev->dev),"setup_pf_switch failed: %d\n",err);
    
#line 9896 
    goto err_vsis;
  }
  else ;
  
#line 9899 
  i = 0U;
  
#line 9899 
  goto ldv_64031;
  ldv_64030: 
#line 9900 
  ;
  
#line 9900 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0 && (*(pf->vsi + i))->type == (unsigned int)I40E_VSI_FDIR) {
    
#line 9901 
    i40e_vsi_open(*(pf->vsi + i));
    
#line 9902 
    goto ldv_64029;
  }
  else ;
  
#line 9899 
  i += 1U;
  ldv_64031: 
#line 9900 
  ;
  
#line 9899 
  if ((unsigned int)pf->num_alloc_vsi > i) 
#line 9901 
                                           goto ldv_64030; else 
#line 9904 
                                                                goto ldv_64029;
  ldv_64029: 
#line 9905 
  ;
  
#line 9909 
  tmp_24 = i40e_aq_set_phy_int_mask(& pf->hw,(unsigned short)258,(struct i40e_asq_cmd_details *)0);
  
#line 9909 
  err = (int)tmp_24;
  
#line 9912 
  if (err != 0) 
#line 9913 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"set phy mask fail, aq_err %d\n",err); else ;
  
#line 9915 
  if (((unsigned int)pf->hw.aq.fw_maj_ver == 4U && (unsigned int)pf->hw.aq.fw_min_ver <= 32U) || (unsigned int)pf->hw.aq.fw_maj_ver <= 3U) {
    i40e_status tmp_25;
    
#line 9917 
    msleep(75U);
    
#line 9918 
    tmp_25 = i40e_aq_set_link_restart_an(& pf->hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
    
#line 9918 
    err = (int)tmp_25;
    
#line 9919 
    if (err != 0) 
#line 9920 
                  _dev_info((struct device const *)(& (pf->pdev)->dev),"link restart failed, aq_err=%d\n",(unsigned int)pf->hw.aq.asq_last_status); else ;
  }
  else ;
  
#line 9927 
  clear_bit(3L,(unsigned long volatile *)(& pf->state));
  
#line 9934 
  if ((pf->flags & 8ULL) != 0ULL) {
    
#line 9935 
    err = i40e_setup_misc_vector(pf);
    
#line 9936 
    if (err != 0) {
      
#line 9937 
      _dev_info((struct device const *)(& pdev->dev),"setup of misc vector failed: %d\n",err);
      
#line 9939 
      goto err_vsis;
    }
    else ;
  }
  else ;
  
#line 9945 
  if ((pf->flags & 524288ULL) != 0ULL && (pf->flags & 8ULL) != 0ULL) {
    int tmp_28;
    
#line 9946 
    tmp_28 = constant_test_bit(20L,(unsigned long const volatile *)(& pf->state));
    
#line 9946 
    if (tmp_28 == 0) {
      u32 val;
      int tmp_27;
      
#line 9951 
      val = readl((void const volatile *)(hw->hw_addr + 258304U));
      
#line 9952 
      val &= 4294967279U;
      
#line 9953 
      writel(val,(void volatile *)(hw->hw_addr + 258304U));
      
#line 9954 
      readl((void const volatile *)(hw->hw_addr + 745772U));
      
#line 9956 
      tmp_27 = pci_num_vf(pdev);
      
#line 9956 
      if (tmp_27 != 0) {
        int tmp_26;
        
#line 9957 
        _dev_info((struct device const *)(& pdev->dev),"Active VFs found, allocating resources.\n");
        
#line 9959 
        tmp_26 = pci_num_vf(pdev);
        
#line 9959 
        ;
        
#line 9959 
        err = i40e_alloc_vfs(pf,(unsigned short)((int)((unsigned short)tmp_26)));
        
#line 9960 
        if (err != 0) 
#line 9961 
                      _dev_info((struct device const *)(& pdev->dev),"Error %d allocating resources for existing VFs\n",err); else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 9968 
  pfs_found = (u16)((int)pfs_found + 1);
  
#line 9970 
  i40e_dbg_pf_init(pf);
  
#line 9973 
  i40e_send_version(pf);
  
#line 9976 
  tmp_29 = round_jiffies(pf->service_timer_period + jiffies);
  
#line 9976 
  ;
  
#line 9976 
  ldv_mod_timer_99(& pf->service_timer,tmp_29);
  
#line 9981 
  i40e_fcoe_vsi_setup(pf);
  
#line 9985 
  pcie_capability_read_word(pf->pdev,18,& link_status);
  
#line 9987 
  i40e_set_pci_config_data(hw,(unsigned short)((int)link_status));
  
#line 9989 
  if (hw->bus.width != (unsigned int)i40e_bus_width_pcie_x8) {
    char *tmp_32;
    
#line 9989 
    if (hw->bus.width != (unsigned int)i40e_bus_width_pcie_x4) {
      char *tmp_31;
      
#line 9989 
      if (hw->bus.width != (unsigned int)i40e_bus_width_pcie_x2) {
        char *tmp_30;
        
#line 9989 
        if (hw->bus.width == (unsigned int)i40e_bus_width_pcie_x1) 
#line 9989 
                                                                   tmp_30 = (char *)"Width x1"; else 
                                                                    
#line 9989 
                                                                    tmp_30 = (char *)"Unknown";
        
#line 9989 
        tmp_31 = tmp_30;
      }
      else 
#line 9989 
           tmp_31 = (char *)"Width x2";
      
#line 9989 
      tmp_32 = tmp_31;
    }
    else 
#line 9989 
         tmp_32 = (char *)"Width x4";
    
#line 9989 
    tmp_33 = tmp_32;
  }
  else 
#line 9989 
       tmp_33 = (char *)"Width x8";
  
#line 9989 
  if (hw->bus.speed != (unsigned int)i40e_bus_speed_8000) {
    char *tmp_35;
    
#line 9989 
    if (hw->bus.speed != (unsigned int)i40e_bus_speed_5000) {
      char *tmp_34;
      
#line 9989 
      if (hw->bus.speed == (unsigned int)i40e_bus_speed_2500) 
#line 9989 
                                                              tmp_34 = (char *)"Speed 2.5GT/s"; else 
                                                                    
#line 9989 
                                                                    tmp_34 = (char *)"Unknown";
      
#line 9989 
      tmp_35 = tmp_34;
    }
    else 
#line 9989 
         tmp_35 = (char *)"Speed 5.0GT/s";
    
#line 9989 
    tmp_36 = tmp_35;
  }
  else 
#line 9989 
       tmp_36 = (char *)"Speed 8.0GT/s";
  
#line 9989 
  ;
  
#line 9989 
  _dev_info((struct device const *)(& pdev->dev),"PCI-Express: %s %s\n",tmp_36,tmp_33);
  
#line 10000 
  if (hw->bus.width <= (unsigned int)7 || hw->bus.speed <= (unsigned int)7999) {
    
#line 10002 
    dev_warn((struct device const *)(& pdev->dev),"PCI-Express bandwidth available for this device may be insufficient for optimal performance.\n");
    
#line 10003 
    dev_warn((struct device const *)(& pdev->dev),"Please move the device to a different PCI-e link with more lanes and/or higher transfer rate.\n");
  }
  else ;
  
#line 10007 
  tmp_37 = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
  
#line 10007 
  err = (int)tmp_37;
  
#line 10008 
  if (err != 0) 
#line 10009 
                _dev_info((struct device const *)(& (pf->pdev)->dev),"get phy abilities failed, aq_err %d, advertised speed settings may not be correct\n",err); else ;
  
#line 10011 
  pf->hw.phy.link_info.requested_speeds = abilities.link_speed;
  
#line 10014 
  i40e_print_features(pf);
  
#line 10016 
  __retres = 0;
  
#line 10016 
  goto return_label;
  err_vsis: 
#line 10019 
  ;
  
#line 10020 
  clear_bit(3L,(unsigned long volatile *)(& pf->state));
  
#line 10021 
  i40e_clear_interrupt_scheme(pf);
  
#line 10022 
  kfree((void const *)pf->vsi);
  err_switch_setup: 
#line 10023 
  ;
  
#line 10024 
  i40e_reset_interrupt_capability(pf);
  
#line 10025 
  ldv_del_timer_sync_100(& pf->service_timer);
  err_mac_addr: 
#line 10026 
  ;
  err_configure_lan_hmc: 
#line 10027 
  ;
  
#line 10028 
  i40e_shutdown_lan_hmc(hw);
  err_init_lan_hmc: 
#line 10029 
  ;
  
#line 10030 
  kfree((void const *)pf->qp_pile);
  err_sw_init: 
#line 10031 
  ;
  err_adminq_setup: 
#line 10032 
  ;
  
#line 10033 
  i40e_shutdown_adminq(hw);
  err_pf_reset: 
#line 10034 
  ;
  
#line 10035 
  iounmap((void volatile *)hw->hw_addr);
  err_ioremap: 
#line 10036 
  ;
  
#line 10037 
  kfree((void const *)pf);
  err_pf_alloc: 
#line 10038 
  ;
  
#line 10039 
  pci_disable_pcie_error_reporting(pdev);
  
#line 10040 
  tmp_38 = pci_select_bars(pdev,512UL);
  
#line 10040 
  ;
  
#line 10040 
  pci_release_selected_regions(pdev,tmp_38);
  err_pci_reg: 
#line 10042 
  ;
  err_dma: 
#line 10043 
  ;
  
#line 10044 
  pci_disable_device(pdev);
  
#line 10045 
  __retres = err;
  return_label: 
#line 10045 
                return __retres;
}


#line 10057  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_remove(struct pci_dev *pdev)
{
  i40e_status ret_code;
  int i;
  int tmp_0;
  
#line 10059 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 10063 
  i40e_dbg_pf_exit(pf);
  
#line 10065 
  i40e_ptp_stop(pf);
  
#line 10068 
  clear_bit(3L,(unsigned long volatile *)(& pf->state));
  
#line 10069 
  ldv_del_timer_sync_101(& pf->service_timer);
  
#line 10070 
  cancel_work_sync(& pf->service_task);
  
#line 10071 
  i40e_fdir_teardown(pf);
  
#line 10073 
  if ((pf->flags & 524288ULL) != 0ULL) {
    
#line 10074 
    i40e_free_vfs(pf);
    
#line 10075 
    pf->flags &= 18446744073709027327ULL;
  }
  else ;
  
#line 10078 
  i40e_fdir_teardown(pf);
  
#line 10083 
  i = 0;
  
#line 10083 
  goto ldv_64041;
  ldv_64040: 
#line 10084 
  ;
  
#line 10084 
  if (pf->veb[i] == (struct i40e_veb *)0) 
#line 10085 
                                          goto ldv_64039; else ;
  
#line 10087 
  if ((int)(pf->veb[i])->uplink_seid == (int)pf->mac_seid || (unsigned int)(pf->veb[i])->uplink_seid == 0U) 
    
#line 10089 
    i40e_switch_branch_release(pf->veb[i]); else ;
  ldv_64039: 
#line 10090 
  ;
  
#line 10083 
  i += 1;
  ldv_64041: 
#line 10084 
  ;
  
#line 10083 
  if (i <= 15) 
#line 10085 
               goto ldv_64040; else 
#line 10088 
                                    goto ldv_64042;
  ldv_64042: 
#line 10089 
  ;
  
#line 10095 
  if (*(pf->vsi + (int)pf->lan_vsi) != (struct i40e_vsi *)0) 
#line 10096 
                                                             i40e_vsi_release(*(pf->vsi + (int)pf->lan_vsi)); else ;
  
#line 10099 
  if (pf->hw.hmc.hmc_obj != (struct i40e_hmc_obj_info *)0) {
    
#line 10100 
    ret_code = i40e_shutdown_lan_hmc(& pf->hw);
    
#line 10101 
    if (ret_code != I40E_SUCCESS) 
#line 10102 
                                  dev_warn((struct device const *)(& pdev->dev),"Failed to destroy the HMC resources: %d\n",(int)ret_code); else ;
  }
  else ;
  
#line 10108 
  ret_code = i40e_shutdown_adminq(& pf->hw);
  
#line 10109 
  if (ret_code != I40E_SUCCESS) 
#line 10110 
                                dev_warn((struct device const *)(& pdev->dev),"Failed to destroy the Admin Queue resources: %d\n",(int)ret_code); else ;
  
#line 10115 
  i40e_clear_interrupt_scheme(pf);
  
#line 10116 
  i = 0;
  
#line 10116 
  goto ldv_64044;
  ldv_64043: 
#line 10117 
  ;
  
#line 10117 
  if (*(pf->vsi + i) != (struct i40e_vsi *)0) {
    
#line 10118 
    i40e_vsi_clear_rings(*(pf->vsi + i));
    
#line 10119 
    i40e_vsi_clear(*(pf->vsi + i));
    
#line 10120 
    *(pf->vsi + i) = (struct i40e_vsi *)0;
  }
  else ;
  
#line 10116 
  i += 1;
  ldv_64044: 
#line 10117 
  ;
  
#line 10116 
  if ((int)pf->num_alloc_vsi > i) 
#line 10118 
                                  goto ldv_64043; else 
#line 10121 
                                                       goto ldv_64045;
  ldv_64045: 
#line 10122 
  ;
  
#line 10124 
  i = 0;
  
#line 10124 
  goto ldv_64047;
  ldv_64046: 
#line 10125 
  ;
  
#line 10125 
  kfree((void const *)pf->veb[i]);
  
#line 10126 
  pf->veb[i] = (struct i40e_veb *)0;
  
#line 10124 
  i += 1;
  ldv_64047: 
#line 10125 
  ;
  
#line 10124 
  if (i <= 15) 
#line 10126 
               goto ldv_64046; else 
#line 10129 
                                    goto ldv_64048;
  ldv_64048: 
#line 10130 
  ;
  
#line 10129 
  kfree((void const *)pf->qp_pile);
  
#line 10130 
  kfree((void const *)pf->vsi);
  
#line 10132 
  iounmap((void volatile *)pf->hw.hw_addr);
  
#line 10133 
  kfree((void const *)pf);
  
#line 10134 
  tmp_0 = pci_select_bars(pdev,512UL);
  
#line 10134 
  ;
  
#line 10134 
  pci_release_selected_regions(pdev,tmp_0);
  
#line 10137 
  pci_disable_pcie_error_reporting(pdev);
  
#line 10138 
  pci_disable_device(pdev);
  
#line 10139 
  return;
}


#line 10149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static pci_ers_result_t i40e_pci_error_detected(struct pci_dev *pdev, enum pci_channel_state error)
{
  pci_ers_result_t __retres;
  int tmp_0;
  
#line 10152 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 10154 
  _dev_info((struct device const *)(& pdev->dev),"%s: error %d\n","i40e_pci_error_detected",(unsigned int)error);
  
#line 10157 
  tmp_0 = constant_test_bit(18L,(unsigned long const volatile *)(& pf->state));
  
#line 10157 
  if (tmp_0 == 0) {
    
#line 10158 
    rtnl_lock();
    
#line 10159 
    i40e_prep_for_reset(pf);
    
#line 10160 
    rtnl_unlock();
  }
  else ;
  
#line 10164 
  __retres = 3U;
  
#line 10164 
  return __retres;
}


#line 10176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static pci_ers_result_t i40e_pci_error_slot_reset(struct pci_dev *pdev)
{
  pci_ers_result_t result;
  int err;
  u32 reg;
  int tmp_0;
  
#line 10178 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 10183 
  _dev_info((struct device const *)(& pdev->dev),"%s\n","i40e_pci_error_slot_reset");
  
#line 10184 
  tmp_0 = pci_enable_device_mem(pdev);
  
#line 10184 
  if (tmp_0 != 0) {
    
#line 10185 
    _dev_info((struct device const *)(& pdev->dev),"Cannot re-enable PCI device after reset.\n");
    
#line 10187 
    result = 4U;
  }
  else {
    
#line 10189 
    pci_set_master(pdev);
    
#line 10190 
    pci_restore_state(pdev);
    
#line 10191 
    pci_save_state(pdev);
    
#line 10192 
    pci_wake_from_d3(pdev,(_Bool)0);
    
#line 10194 
    reg = readl((void const volatile *)(pf->hw.hw_addr + 754064U));
    
#line 10195 
    if (reg == 0U) 
#line 10196 
                   result = 5U; else 
#line 10198 
                                     result = 4U;
  }
  
#line 10201 
  err = pci_cleanup_aer_uncorrect_error_status(pdev);
  
#line 10202 
  if (err != 0) 
#line 10203 
                _dev_info((struct device const *)(& pdev->dev),"pci_cleanup_aer_uncorrect_error_status failed 0x%0x\n",err); else ;
  
#line 10209 
  return result;
}


#line 10219  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_pci_error_resume(struct pci_dev *pdev)
{
  int tmp_0;
  
#line 10221 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 10223 
  _dev_info((struct device const *)(& pdev->dev),"%s\n","i40e_pci_error_resume");
  
#line 10224 
  tmp_0 = constant_test_bit(18L,(unsigned long const volatile *)(& pf->state));
  
#line 10224 
  if (tmp_0 != 0) 
#line 10225 
                  goto return_label; else ;
  
#line 10227 
  rtnl_lock();
  
#line 10228 
  i40e_handle_reset_warning(pf);
  
#line 10229 
  rtnl_lock();
  return_label: 
#line 10230 
                return;
}


#line 10236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_shutdown(struct pci_dev *pdev)
{
  int tmp_0;
  
#line 10238 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 10239 
  struct i40e_hw *hw = & pf->hw;
  
#line 10241 
  clear_bit(18L,(unsigned long volatile *)(& pf->state));
  
#line 10242 
  clear_bit(3L,(unsigned long volatile *)(& pf->state));
  
#line 10243 
  rtnl_lock();
  
#line 10244 
  i40e_prep_for_reset(pf);
  
#line 10245 
  rtnl_unlock();
  
#line 10247 
  writel((unsigned int)((int)pf->wol_en != 0),(void volatile *)(hw->hw_addr + 753792U));
  
#line 10248 
  ;
  
#line 10248 
  if ((int)pf->wol_en != 0) 
#line 10248 
                            tmp_0 = 2; else 
#line 10248 
                                            tmp_0 = 0;
  
#line 10248 
  writel((unsigned int)tmp_0,(void volatile *)(hw->hw_addr + 439296U));
  
#line 10250 
  i40e_clear_interrupt_scheme(pf);
  
#line 10252 
  if (system_state == (unsigned int)SYSTEM_POWER_OFF) {
    
#line 10253 
    pci_wake_from_d3(pdev,(_Bool)((bool)((int)pf->wol_en) != 0));
    
#line 10254 
    pci_set_power_state(pdev,3);
  }
  else ;
  
#line 10256 
  return;
}


#line 10263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_suspend(struct pci_dev *pdev, pm_message_t state)
{
  int __retres;
  int tmp_0;
  
#line 10265 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 10266 
  struct i40e_hw *hw = & pf->hw;
  
#line 10268 
  clear_bit(18L,(unsigned long volatile *)(& pf->state));
  
#line 10269 
  clear_bit(3L,(unsigned long volatile *)(& pf->state));
  
#line 10270 
  ldv_del_timer_sync_102(& pf->service_timer);
  
#line 10271 
  cancel_work_sync(& pf->service_task);
  
#line 10272 
  i40e_fdir_teardown(pf);
  
#line 10274 
  rtnl_lock();
  
#line 10275 
  i40e_prep_for_reset(pf);
  
#line 10276 
  rtnl_unlock();
  
#line 10278 
  writel((unsigned int)((int)pf->wol_en != 0),(void volatile *)(hw->hw_addr + 753792U));
  
#line 10279 
  ;
  
#line 10279 
  if ((int)pf->wol_en != 0) 
#line 10279 
                            tmp_0 = 2; else 
#line 10279 
                                            tmp_0 = 0;
  
#line 10279 
  writel((unsigned int)tmp_0,(void volatile *)(hw->hw_addr + 439296U));
  
#line 10281 
  pci_wake_from_d3(pdev,(_Bool)((bool)((int)pf->wol_en) != 0));
  
#line 10282 
  pci_set_power_state(pdev,3);
  
#line 10284 
  __retres = 0;
  
#line 10284 
  return __retres;
}


#line 10291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_resume(struct pci_dev *pdev)
{
  int __retres;
  u32 err;
  int tmp_0;
  int tmp_1;
  
#line 10293 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 10296 
  pci_set_power_state(pdev,0);
  
#line 10297 
  pci_restore_state(pdev);
  
#line 10301 
  pci_save_state(pdev);
  
#line 10303 
  tmp_0 = pci_enable_device_mem(pdev);
  
#line 10303 
  err = (unsigned int)tmp_0;
  
#line 10304 
  if (err != 0U) {
    
#line 10305 
    dev_err((struct device const *)(& pdev->dev),"%s: Cannot enable PCI device from suspend\n","i40e_resume");
    
#line 10308 
    __retres = (int)err;
    
#line 10308 
    goto return_label;
  }
  else ;
  
#line 10310 
  pci_set_master(pdev);
  
#line 10313 
  pci_wake_from_d3(pdev,(_Bool)0);
  
#line 10316 
  tmp_1 = test_and_set_bit(18L,(unsigned long volatile *)(& pf->state));
  
#line 10316 
  if (tmp_1 != 0) {
    
#line 10317 
    clear_bit(3L,(unsigned long volatile *)(& pf->state));
    
#line 10318 
    rtnl_lock();
    
#line 10319 
    i40e_reset_and_rebuild(pf,(_Bool)0);
    
#line 10320 
    rtnl_unlock();
  }
  else ;
  
#line 10323 
  __retres = 0;
  return_label: 
#line 10323 
                return __retres;
}


#line 10327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct pci_error_handlers const i40e_err_handler = {.error_detected = & i40e_pci_error_detected, .mmio_enabled = (pci_ers_result_t (*)(struct pci_dev *))0, .link_reset = (pci_ers_result_t (*)(struct pci_dev *))0, .slot_reset = & i40e_pci_error_slot_reset, .reset_notify = (void (*)(struct pci_dev *, bool ))0, .resume = & i40e_pci_error_resume};

#line 10333  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct pci_driver i40e_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = (char const *)(& i40e_driver_name), .id_table = (struct pci_device_id const *)(& i40e_pci_tbl), .probe = & i40e_probe, .remove = & i40e_remove, .suspend = & i40e_suspend, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = & i40e_resume, .shutdown = & i40e_shutdown, .sriov_configure = & i40e_pci_sriov_configure, .err_handler = & i40e_err_handler, .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 10353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_module(void)
{
  int tmp;
  
#line 10355 
  printk("\001",(char const *)(& i40e_driver_name),(char const *)(& i40e_driver_string),(char const *)(& i40e_driver_version_str));
  
#line 10357 
  printk("\001",(char const *)(& i40e_driver_name),(char const *)(& i40e_copyright));
  
#line 10359 
  i40e_dbg_init();
  
#line 10360 
  tmp = ldv___pci_register_driver_103(& i40e_driver,& __this_module,"i40e");
  
#line 10360 
  return tmp;
}


#line 10370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_exit_module(void)
{
  
#line 10372 
  ldv_pci_unregister_driver_104(& i40e_driver);
  
#line 10373 
  i40e_dbg_exit();
  
#line 10374 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
struct pci_driver *ldv_emg_alias_i40e_driver_2 = & i40e_driver;

#line 59 
void ldv_emg_unregister_netdev(struct net_device *arg0);


#line 60 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 61 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 62 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 63 
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1);


#line 64 
_Bool ldv_emg_schedule_work(struct work_struct *arg0);


#line 65 
int ldv_emg_del_timer_sync(struct timer_list *arg0);


#line 66 
void ldv_emg_free_netdev(struct net_device *arg0);


#line 67 
int ldv_emg_register_netdev(struct net_device *arg0);


#line 68 
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);


#line 69 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
int ldv_emg_wrapper_i40e_set_features_31(struct net_device *arg0, unsigned long long arg1)
{
  int tmp;
  
#line 74 
  tmp = i40e_set_features(arg0,arg1);
  
#line 74 
  return tmp;
}


#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
enum irqreturn ldv_emg_wrapper_i40e_intr_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 79 
  tmp = i40e_intr(arg0,arg1);
  
#line 79 
  return tmp;
}


#line 83  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
int ldv_emg_wrapper_i40e_probe_3(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 84 
  tmp = i40e_probe(arg0,(struct pci_device_id const *)arg1);
  
#line 84 
  return tmp;
}


#line 88  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
void ldv_emg_i40e_exit_module(void)
{
  
#line 89 
  i40e_exit_module();
  
#line 90 
  return;
}


#line 92  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
int ldv_emg_wrapper_i40e_ndo_fdb_add_18(struct ndmsg *arg0, struct nlattr **arg1, struct net_device *arg2, unsigned char *arg3, unsigned short arg4, unsigned short arg5)
{
  int tmp;
  
#line 93 
  tmp = i40e_ndo_fdb_add(arg0,arg1,arg2,(unsigned char const *)arg3,(unsigned short)((int)arg4),(unsigned short)((int)arg5));
  
#line 93 
  return tmp;
}


#line 97  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
void ldv_emg_wrapper_i40e_del_vxlan_port_23(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  
#line 98 
  i40e_del_vxlan_port(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 99 
  return;
}


#line 102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
void ldv_emg_wrapper_i40e_shutdown_2(struct pci_dev *arg0)
{
  
#line 103 
  i40e_shutdown(arg0);
  
#line 104 
  return;
}


#line 107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
void ldv_emg_wrapper_i40e_remove_5(struct pci_dev *arg0)
{
  
#line 108 
  i40e_remove(arg0);
  
#line 109 
  return;
}


#line 112  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
int ldv_emg_wrapper_i40e_get_phys_port_id_42(struct net_device *arg0, struct netdev_phys_item_id *arg1)
{
  int tmp;
  
#line 113 
  tmp = i40e_get_phys_port_id(arg0,arg1);
  
#line 113 
  return tmp;
}


#line 117  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
void ldv_emg_wrapper_i40e_add_vxlan_port_34(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  
#line 118 
  i40e_add_vxlan_port(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 119 
  return;
}


#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
int ldv_emg_wrapper_i40e_suspend_4(struct pci_dev *arg0, struct pm_message arg1)
{
  int tmp;
  
#line 123 
  tmp = i40e_suspend(arg0,arg1);
  
#line 123 
  return tmp;
}


#line 127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
int ldv_emg_i40e_init_module(void)
{
  int tmp;
  
#line 128 
  tmp = i40e_init_module();
  
#line 128 
  return tmp;
}


#line 131  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
int ldv_emg_wrapper_i40e_resume_6(struct pci_dev *arg0)
{
  int tmp;
  
#line 132 
  tmp = i40e_resume(arg0);
  
#line 132 
  return tmp;
}


#line 483  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 486 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 486 
  return tmp;
}


#line 490  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 493 
  tmp = ldv_kzalloc(size,flags);
  
#line 493 
  return tmp;
}


#line 674  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_spin_lock_60(spinlock_t *lock)
{
  
#line 678 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 680 
  spin_lock(lock);
  
#line 681 
  return;
}


#line 717  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_spin_unlock_63(spinlock_t *lock)
{
  
#line 721 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 723 
  spin_unlock(lock);
  
#line 724 
  return;
}


#line 817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static bool ldv_schedule_work_73(struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 821 
  tmp = ldv_emg_schedule_work(work);
  
#line 821 
  __retres = tmp != 0;
  
#line 821 
  return __retres;
}


#line 825  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_request_irq_74(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 829 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 829 
  return tmp;
}


#line 833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_free_irq_75(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 837 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 838 
  return;
}


#line 841  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_request_irq_76(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 845 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 845 
  return tmp;
}


#line 849  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_request_irq_77(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 853 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 853 
  return tmp;
}


#line 857  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_free_irq_78(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 861 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 862 
  return;
}


#line 865  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_free_irq_79(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 869 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 870 
  return;
}


#line 873  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_free_irq_80(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 877 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 878 
  return;
}


#line 881  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_mod_timer_81(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 885 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 885 
  return tmp;
}


#line 889  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_lock_82(struct mutex *ldv_func_arg1)
{
  
#line 893 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 894 
  return;
}


#line 897  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1)
{
  
#line 901 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 902 
  return;
}


#line 905  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_lock_84(struct mutex *ldv_func_arg1)
{
  
#line 909 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 910 
  return;
}


#line 913  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_unlock_85(struct mutex *ldv_func_arg1)
{
  
#line 917 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 918 
  return;
}


#line 921  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_request_irq_86(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 925 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 925 
  return tmp;
}


#line 929  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_87(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3)
{
  struct net_device *tmp;
  
#line 933 
  tmp = ldv_emg_alloc_etherdev_mqs(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 933 
  return tmp;
}


#line 937  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_unregister_netdev_88(struct net_device *ldv_func_arg1)
{
  
#line 941 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 942 
  return;
}


#line 945  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_free_netdev_89(struct net_device *ldv_func_arg1)
{
  
#line 949 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 950 
  return;
}


#line 953  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_unregister_netdev_90(struct net_device *ldv_func_arg1)
{
  
#line 957 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 958 
  return;
}


#line 961  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_free_netdev_91(struct net_device *ldv_func_arg1)
{
  
#line 965 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 966 
  return;
}


#line 969  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_register_netdev_92(struct net_device *ldv_func_arg1)
{
  int tmp;
  
#line 973 
  tmp = ldv_emg_register_netdev(ldv_func_arg1);
  
#line 973 
  return tmp;
}


#line 977  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_unregister_netdev_93(struct net_device *ldv_func_arg1)
{
  
#line 981 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 982 
  return;
}


#line 985  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_free_netdev_94(struct net_device *ldv_func_arg1)
{
  
#line 989 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 990 
  return;
}


#line 993  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_lock_95(struct mutex *ldv_func_arg1)
{
  
#line 997 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 998 
  return;
}


#line 1001  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1)
{
  
#line 1005 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 1006 
  return;
}


#line 1009  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_lock_97(struct mutex *ldv_func_arg1)
{
  
#line 1013 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 1014 
  return;
}


#line 1017  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1)
{
  
#line 1021 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"switch_mutex_of_i40e_pf");
  
#line 1022 
  return;
}


#line 1025  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_mod_timer_99(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 1029 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 1029 
  return tmp;
}


#line 1033  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_del_timer_sync_100(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1037 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1037 
  return tmp;
}


#line 1041  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_del_timer_sync_101(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1045 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1045 
  return tmp;
}


#line 1049  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv_del_timer_sync_102(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 1053 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 1053 
  return tmp;
}


#line 1057  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static int ldv___pci_register_driver_103(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 1061 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 1061 
  return tmp;
}


#line 1065  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_main.c.aux"
static void ldv_pci_unregister_driver_104(struct pci_driver *ldv_func_arg1)
{
  
#line 1069 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 1070 
  return;
}


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_1(size_t size, gfp_t flags);


#line 1672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_enable_sriov(struct pci_dev *, int);


#line 1673 
void pci_disable_sriov(struct pci_dev *);


#line 1675 
int pci_vfs_assigned(struct pci_dev *);


#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 161 
  __retres = (_Bool)((unsigned int)(((int)*((u16 const *)addr) & (int)*((u16 const *)(addr + 2U))) & (int)*((u16 const *)(addr + 4U))) == 65535U);
  
#line 161 
  return __retres;
}


#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
i40e_status i40e_aq_send_msg_to_vf(struct i40e_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen, struct i40e_asq_cmd_details *cmd_details);


#line 195 
i40e_status i40e_aq_config_vsi_bw_limit(struct i40e_hw *hw, u16 seid, u16 credit, u8 max_credit, struct i40e_asq_cmd_details *cmd_details);


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_vc_vf_broadcast(struct i40e_pf *pf, enum i40e_virtchnl_ops v_opcode, i40e_status v_retval, u8 *msg, u16 msglen)
{
  int i;
  
#line 46 
  struct i40e_hw *hw = & pf->hw;
  
#line 47 
  struct i40e_vf *vf = pf->vf;
  
#line 50 
  i = 0;
  
#line 50 
  goto ldv_61389;
  ldv_61388: 
#line 51 
  ;
  {
    int tmp;
    
#line 51 
    int abs_vf_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
    
#line 53 
    tmp = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_states));
    
#line 53 
    if (tmp == 0) {
      int tmp_0;
      
#line 53 
      tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
      
#line 53 
      if (tmp_0 == 0) 
#line 55 
                      goto ldv_61387; else ;
    }
    else ;
    
#line 60 
    i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)abs_vf_id)),(unsigned int)v_opcode,(unsigned int)v_retval,msg,(unsigned short)((int)msglen),(struct i40e_asq_cmd_details *)0);
  }
  ldv_61387: 
#line 62 
  ;
  
#line 50 
  i += 1;
  
#line 50 
  vf += 1;
  ldv_61389: 
#line 51 
  ;
  
#line 50 
  if (pf->num_alloc_vfs > i) 
#line 52 
                             goto ldv_61388; else 
#line 55 
                                                  goto ldv_61390;
  ldv_61390: 
#line 56 
  ;
  
#line 57 
  return;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_vc_notify_vf_link_state(struct i40e_vf *vf)
{
  struct i40e_virtchnl_pf_event pfe;
  
#line 74 
  struct i40e_pf *pf = vf->pf;
  
#line 75 
  struct i40e_hw *hw = & pf->hw;
  
#line 76 
  struct i40e_link_status *ls = & pf->hw.phy.link_info;
  
#line 77 
  int abs_vf_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
  
#line 79 
  pfe.event = I40E_VIRTCHNL_EVENT_LINK_CHANGE;
  
#line 80 
  pfe.severity = 0;
  
#line 81 
  if ((int)vf->link_forced != 0) {
    int tmp;
    
#line 82 
    pfe.event_data.link_event.link_status = vf->link_up;
    
#line 84 
    if ((int)vf->link_up != 0) 
#line 84 
                               tmp = 16; else 
#line 84 
                                              tmp = 0;
    
#line 83 
    pfe.event_data.link_event.link_speed = (enum i40e_aq_link_speed)tmp;
  }
  else {
    
#line 86 
    pfe.event_data.link_event.link_status = (_Bool)(((int)ls->link_info & 1) != 0);
    
#line 88 
    pfe.event_data.link_event.link_speed = ls->link_speed;
  }
  
#line 90 
  i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)abs_vf_id)),17U,0U,(u8 *)(& pfe),(unsigned short)16,(struct i40e_asq_cmd_details *)0);
  
#line 92 
  return;
}


#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_link_state(struct i40e_pf *pf)
{
  int i;
  
#line 104 
  i = 0;
  
#line 104 
  goto ldv_61404;
  ldv_61403: 
#line 105 
  ;
  
#line 105 
  i40e_vc_notify_vf_link_state(pf->vf + i);
  
#line 104 
  i += 1;
  ldv_61404: 
#line 105 
  ;
  
#line 104 
  if (pf->num_alloc_vfs > i) 
#line 106 
                             goto ldv_61403; else 
#line 109 
                                                  goto ldv_61405;
  ldv_61405: 
#line 110 
  ;
  
#line 111 
  return;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_reset(struct i40e_pf *pf)
{
  struct i40e_virtchnl_pf_event pfe;
  
#line 118 
  pfe.event = I40E_VIRTCHNL_EVENT_RESET_IMPENDING;
  
#line 119 
  pfe.severity = 255;
  
#line 120 
  i40e_vc_vf_broadcast(pf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_EVENT,(enum i40e_status_code)I40E_SUCCESS,(u8 *)(& pfe),(unsigned short)16);
  
#line 122 
  return;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_vf_reset(struct i40e_vf *vf)
{
  struct i40e_virtchnl_pf_event pfe;
  int abs_vf_id;
  int tmp;
  
#line 136 
  if (vf == (struct i40e_vf *)0 || (int)vf->vf_id >= (vf->pf)->num_alloc_vfs) 
    
#line 137 
    goto return_label; else ;
  
#line 140 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 140 
  if (tmp == 0) {
    int tmp_0;
    
#line 140 
    tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
    
#line 140 
    if (tmp_0 == 0) 
#line 142 
                    goto return_label; else ;
  }
  else ;
  
#line 144 
  abs_vf_id = (int)((unsigned int)vf->vf_id + (vf->pf)->hw.func_caps.vf_base_id);
  
#line 146 
  pfe.event = I40E_VIRTCHNL_EVENT_RESET_IMPENDING;
  
#line 147 
  pfe.severity = 255;
  
#line 148 
  i40e_aq_send_msg_to_vf(& (vf->pf)->hw,(unsigned short)((int)((unsigned short)abs_vf_id)),17U,0U,(u8 *)(& pfe),(unsigned short)16,(struct i40e_asq_cmd_details *)0);
  return_label: 
#line 150 
                return;
}


#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static void i40e_vc_disable_vf(struct i40e_pf *pf, struct i40e_vf *vf)
{
  u32 reg;
  
#line 163 
  struct i40e_hw *hw = & pf->hw;
  
#line 166 
  reg = readl((void const volatile *)(hw->hw_addr + ((int)vf->vf_id + 148992) * 4));
  
#line 167 
  reg |= 1U;
  
#line 168 
  writel(reg,(void volatile *)(hw->hw_addr + ((int)vf->vf_id + 148992) * 4));
  
#line 169 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 170 
  return;
}


#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static bool i40e_vc_isvalid_vsi_id(struct i40e_vf *vf, u16 vsi_id)
{
  bool __retres;
  
#line 181 
  struct i40e_pf *pf = vf->pf;
  
#line 182 
  struct i40e_vsi *vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  
#line 184 
  __retres = (_Bool)((vsi != (struct i40e_vsi *)0 && (int)vsi->vf_id == (int)vf->vf_id) != 0);
  
#line 184 
  return __retres;
}


#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static bool i40e_vc_isvalid_queue_id(struct i40e_vf *vf, u16 vsi_id, u8 qid)
{
  bool __retres;
  
#line 198 
  struct i40e_pf *pf = vf->pf;
  
#line 199 
  struct i40e_vsi *vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  
#line 201 
  __retres = (_Bool)((vsi != (struct i40e_vsi *)0 && (int)((unsigned short)qid) < (int)vsi->alloc_queue_pairs) != 0);
  
#line 201 
  return __retres;
}


#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static bool i40e_vc_isvalid_vector_id(struct i40e_vf *vf, u8 vector_id)
{
  bool __retres;
  
#line 213 
  struct i40e_pf *pf = vf->pf;
  
#line 215 
  __retres = (_Bool)((unsigned int)vector_id < pf->hw.func_caps.num_msix_vectors_vf);
  
#line 215 
  return __retres;
}


#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static u16 i40e_vc_get_pf_queue_id(struct i40e_vf *vf, u16 vsi_id, u8 vsi_queue_id)
{
  u16 __retres;
  
#line 231 
  struct i40e_pf *pf = vf->pf;
  
#line 232 
  struct i40e_vsi *vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  
#line 233 
  u16 pf_queue_id = (unsigned short)2047U;
  
#line 235 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 236 
    __retres = pf_queue_id;
    
#line 236 
    goto return_label;
  }
  else ;
  
#line 238 
  if (((int)vsi->info.mapping_flags & 1) != 0) 
#line 240 
                                               pf_queue_id = vsi->info.queue_mapping[(int)vsi_queue_id]; else 
                                                                    
#line 243 
                                                                    pf_queue_id = (unsigned short)((int)vsi->info.queue_mapping[0] + (int)((unsigned short)vsi_queue_id));
  
#line 246 
  __retres = pf_queue_id;
  return_label: 
#line 246 
                return __retres;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_config_irq_link_list(struct i40e_vf *vf, u16 vsi_id, struct i40e_virtchnl_vector_map *vecmap)
{
  unsigned long tempmap;
  u16 vsi_queue_id;
  u16 pf_queue_id;
  enum i40e_queue_type qtype;
  u16 next_q;
  u16 vector_id;
  u32 reg;
  u32 reg_idx;
  unsigned long tmp;
  unsigned long tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  unsigned long tmp_3;
  unsigned long tmp_4;
  
#line 260 
  unsigned long linklistmap = 0UL;
  
#line 261 
  struct i40e_pf *pf = vf->pf;
  
#line 262 
  struct i40e_hw *hw = & pf->hw;
  
#line 267 
  u16 itr_idx = (unsigned short)0U;
  
#line 269 
  vector_id = vecmap->vector_id;
  
#line 271 
  if ((unsigned int)vector_id == 0U) 
#line 272 
                                     reg_idx = (unsigned int)(((int)vf->vf_id + 43520) * 4); else 
                                                                    
#line 274 
                                                                    reg_idx = (((pf->hw.func_caps.num_msix_vectors_vf + 4294967295U) * (unsigned int)vf->vf_id + (unsigned int)vector_id) + 37887U) * 4U;
  
#line 278 
  if ((unsigned int)vecmap->rxq_map == 0U && (unsigned int)vecmap->txq_map == 0U) {
    
#line 280 
    writel(2047U,(void volatile *)(hw->hw_addr + reg_idx));
    
#line 281 
    goto irq_list_done;
  }
  else ;
  
#line 283 
  tempmap = (unsigned long)vecmap->rxq_map;
  
#line 284 
  tmp = find_first_bit((unsigned long const *)(& tempmap),16UL);
  
#line 284 
  vsi_queue_id = (unsigned short)tmp;
  
#line 284 
  goto ldv_61466;
  ldv_61465: 
#line 285 
  ;
  
#line 285 
  linklistmap = (unsigned long)(1 << (int)vsi_queue_id * 2) | linklistmap;
  
#line 284 
  tmp_0 = find_next_bit((unsigned long const *)(& tempmap),16UL,(unsigned long)((int)vsi_queue_id + 1));
  
#line 284 
  vsi_queue_id = (unsigned short)tmp_0;
  ldv_61466: 
#line 285 
  ;
  
#line 284 
  if ((unsigned int)vsi_queue_id <= 15U) 
#line 286 
                                         goto ldv_61465; else 
#line 289 
                                                              goto ldv_61467;
  ldv_61467: 
#line 290 
  ;
  
#line 290 
  tempmap = (unsigned long)vecmap->txq_map;
  
#line 291 
  tmp_1 = find_first_bit((unsigned long const *)(& tempmap),16UL);
  
#line 291 
  vsi_queue_id = (unsigned short)tmp_1;
  
#line 291 
  goto ldv_61469;
  ldv_61468: 
#line 292 
  ;
  
#line 292 
  linklistmap = (unsigned long)(1 << ((int)vsi_queue_id * 2 + 1)) | linklistmap;
  
#line 291 
  tmp_2 = find_next_bit((unsigned long const *)(& tempmap),16UL,(unsigned long)((int)vsi_queue_id + 1));
  
#line 291 
  vsi_queue_id = (unsigned short)tmp_2;
  ldv_61469: 
#line 292 
  ;
  
#line 291 
  if ((unsigned int)vsi_queue_id <= 15U) 
#line 293 
                                         goto ldv_61468; else 
#line 296 
                                                              goto ldv_61470;
  ldv_61470: 
#line 297 
  ;
  
#line 297 
  tmp_3 = find_first_bit((unsigned long const *)(& linklistmap),32UL);
  
#line 297 
  next_q = (unsigned short)tmp_3;
  
#line 300 
  vsi_queue_id = (unsigned short)((unsigned int)next_q / 2U);
  
#line 301 
  qtype = (enum i40e_queue_type)((int)next_q & 1);
  
#line 302 
  pf_queue_id = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
  
#line 303 
  reg = ((unsigned int)qtype << 11) | (unsigned int)pf_queue_id;
  
#line 305 
  writel(reg,(void volatile *)(hw->hw_addr + reg_idx));
  
#line 307 
  goto ldv_61476;
  ldv_61475: 
#line 308 
  ;
  
#line 308 
  switch ((unsigned int)qtype) {
    case (unsigned int)0: 
#line 309 
    ;
    
#line 310 
    reg_idx = (unsigned int)(((int)pf_queue_id + 59392) * 4);
    
#line 311 
    itr_idx = vecmap->rxitr_idx;
    
#line 312 
    goto ldv_61472;
    case (unsigned int)1: 
#line 313 
    ;
    
#line 314 
    reg_idx = (unsigned int)(((int)pf_queue_id + 61440) * 4);
    
#line 315 
    itr_idx = vecmap->txitr_idx;
    
#line 316 
    goto ldv_61472;
    default: 
#line 317 
    ;
    
#line 318 
    goto ldv_61472;
  }
  ldv_61472: 
#line 321 
  ;
  
#line 321 
  tmp_4 = find_next_bit((unsigned long const *)(& linklistmap),32UL,(unsigned long)((int)next_q + 1));
  
#line 321 
  next_q = (unsigned short)tmp_4;
  
#line 325 
  if ((unsigned int)next_q <= 31U) {
    
#line 327 
    vsi_queue_id = (unsigned short)((unsigned int)next_q / 2U);
    
#line 328 
    qtype = (enum i40e_queue_type)((int)next_q & 1);
    
#line 329 
    pf_queue_id = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
  }
  else {
    
#line 332 
    pf_queue_id = (unsigned short)2047U;
    
#line 333 
    qtype = I40E_QUEUE_TYPE_RX;
  }
  
#line 337 
  reg = ((((unsigned int)vector_id | ((unsigned int)qtype << 27)) | (unsigned int)((int)pf_queue_id << 16)) | (unsigned int)((int)itr_idx << 11)) | 1073741824U;
  
#line 342 
  writel(reg,(void volatile *)(hw->hw_addr + reg_idx));
  ldv_61476: 
#line 343 
  ;
  
#line 307 
  if ((unsigned int)next_q <= 31U) 
#line 309 
                                   goto ldv_61475; else 
#line 312 
                                                        goto ldv_61477;
  ldv_61477: 
#line 313 
  ;
  irq_list_done: 
#line 345 
  ;
  
#line 346 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 347 
  return;
}


#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_config_vsi_tx_queue(struct i40e_vf *vf, u16 vsi_id, u16 vsi_queue_id, struct i40e_virtchnl_txq_info *info)
{
  struct i40e_hmc_obj_txq tx_ctx;
  struct i40e_vsi *vsi;
  u16 pf_queue_id;
  u32 qtx_ctl;
  i40e_status tmp;
  i40e_status tmp_0;
  
#line 362 
  struct i40e_pf *pf = vf->pf;
  
#line 363 
  struct i40e_hw *hw = & pf->hw;
  
#line 368 
  int ret = 0;
  
#line 370 
  pf_queue_id = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
  
#line 371 
  vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  
#line 374 
  memset((void *)(& tx_ctx),0,48UL);
  
#line 377 
  tx_ctx.base = info->dma_ring_addr / 128ULL;
  
#line 378 
  tx_ctx.qlen = info->ring_len;
  
#line 379 
  tx_ctx.rdylist = vsi->info.qs_handle[0];
  
#line 380 
  tx_ctx.rdylist_act = (unsigned char)0U;
  
#line 381 
  tx_ctx.head_wb_ena = (unsigned char)info->headwb_enabled;
  
#line 382 
  tx_ctx.head_wb_addr = info->dma_headwb_addr;
  
#line 385 
  tmp = i40e_clear_lan_tx_queue_context(hw,(unsigned short)((int)pf_queue_id));
  
#line 385 
  ret = (int)tmp;
  
#line 386 
  if (ret != 0) {
    
#line 387 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Failed to clear VF LAN Tx queue context %d, error: %d\n",(int)pf_queue_id,ret);
    
#line 390 
    ret = -2;
    
#line 391 
    goto error_context;
  }
  else ;
  
#line 395 
  tmp_0 = i40e_set_lan_tx_queue_context(hw,(unsigned short)((int)pf_queue_id),& tx_ctx);
  
#line 395 
  ret = (int)tmp_0;
  
#line 396 
  if (ret != 0) {
    
#line 397 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Failed to set VF LAN Tx queue context %d error: %d\n",(int)pf_queue_id,ret);
    
#line 400 
    ret = -2;
    
#line 401 
    goto error_context;
  }
  else ;
  
#line 405 
  qtx_ctl = 0U;
  
#line 406 
  qtx_ctl = ((unsigned int)((int)hw->pf_id << 2) & 60U) | qtx_ctl;
  
#line 408 
  qtx_ctl = ((((unsigned int)vf->vf_id + hw->func_caps.vf_base_id) << 7) & 65535U) | qtx_ctl;
  
#line 411 
  writel(qtx_ctl,(void volatile *)(hw->hw_addr + ((int)pf_queue_id + 266240) * 4));
  
#line 412 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  error_context: 
#line 414 
  ;
  
#line 415 
  return ret;
}


#line 427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_config_vsi_rx_queue(struct i40e_vf *vf, u16 vsi_id, u16 vsi_queue_id, struct i40e_virtchnl_rxq_info *info)
{
  struct i40e_hmc_obj_rxq rx_ctx;
  u16 pf_queue_id;
  i40e_status tmp;
  i40e_status tmp_0;
  
#line 431 
  struct i40e_pf *pf = vf->pf;
  
#line 432 
  struct i40e_hw *hw = & pf->hw;
  
#line 435 
  int ret = 0;
  
#line 437 
  pf_queue_id = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
  
#line 440 
  memset((void *)(& rx_ctx),0,48UL);
  
#line 443 
  rx_ctx.base = info->dma_ring_addr / 128ULL;
  
#line 444 
  rx_ctx.qlen = (unsigned short)info->ring_len;
  
#line 446 
  if ((unsigned int)info->splithdr_enabled != 0U) {
    
#line 447 
    rx_ctx.hsplit_0 = (unsigned char)15U;
    
#line 452 
    if ((unsigned int)info->hdr_size > 1984U) {
      
#line 453 
      ret = -22;
      
#line 454 
      goto error_param;
    }
    else ;
    
#line 456 
    rx_ctx.hbuff = (unsigned short)((int)info->hdr_size >> 6);
    
#line 459 
    rx_ctx.dtype = (unsigned char)2U;
  }
  else ;
  
#line 463 
  if (info->databuffer_size > 16256U) {
    
#line 464 
    ret = -22;
    
#line 465 
    goto error_param;
  }
  else ;
  
#line 467 
  rx_ctx.dbuff = (unsigned short)(info->databuffer_size >> 7);
  
#line 470 
  if (info->max_pkt_size + 4294967232U > 16319U) {
    
#line 471 
    ret = -22;
    
#line 472 
    goto error_param;
  }
  else ;
  
#line 474 
  rx_ctx.rxmax = info->max_pkt_size;
  
#line 477 
  rx_ctx.dsize = (unsigned char)1U;
  
#line 480 
  rx_ctx.lrxqthresh = (unsigned short)2U;
  
#line 481 
  rx_ctx.crcstrip = (unsigned char)1U;
  
#line 482 
  rx_ctx.prefena = (unsigned char)1U;
  
#line 483 
  rx_ctx.l2tsel = (unsigned char)1U;
  
#line 486 
  tmp = i40e_clear_lan_rx_queue_context(hw,(unsigned short)((int)pf_queue_id));
  
#line 486 
  ret = (int)tmp;
  
#line 487 
  if (ret != 0) {
    
#line 488 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Failed to clear VF LAN Rx queue context %d, error: %d\n",(int)pf_queue_id,ret);
    
#line 491 
    ret = -2;
    
#line 492 
    goto error_param;
  }
  else ;
  
#line 496 
  tmp_0 = i40e_set_lan_rx_queue_context(hw,(unsigned short)((int)pf_queue_id),& rx_ctx);
  
#line 496 
  ret = (int)tmp_0;
  
#line 497 
  if (ret != 0) {
    
#line 498 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Failed to set VF LAN Rx queue context %d error: %d\n",(int)pf_queue_id,ret);
    
#line 501 
    ret = -2;
    
#line 502 
    goto error_param;
  }
  else ;
  error_param: 
#line 505 
  ;
  
#line 506 
  return ret;
}


#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_alloc_vsi_res(struct i40e_vf *vf, enum i40e_vsi_type type)
{
  struct i40e_vsi *vsi;
  
#line 518 
  struct i40e_mac_filter *f = (struct i40e_mac_filter *)0;
  
#line 519 
  struct i40e_pf *pf = vf->pf;
  
#line 521 
  int ret = 0;
  
#line 523 
  vsi = i40e_vsi_setup(pf,(unsigned char)((int)((unsigned char)type)),(unsigned short)((int)(*(pf->vsi + (int)pf->lan_vsi))->seid),(unsigned int)vf->vf_id);
  
#line 525 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 526 
    dev_err((struct device const *)(& (pf->pdev)->dev),"add vsi failed for VF %d, aq_err %d\n",(int)vf->vf_id,(unsigned int)pf->hw.aq.asq_last_status);
    
#line 529 
    ret = -2;
    
#line 530 
    goto error_alloc_vsi_res;
  }
  else ;
  
#line 532 
  if (type == (unsigned int)I40E_VSI_SRIOV) {
    
#line 533 
    u8 brdcast[6U] = {(unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U, (unsigned char)255U};
    
#line 534 
    vf->lan_vsi_idx = (unsigned char)vsi->idx;
    
#line 535 
    vf->lan_vsi_id = (unsigned char)vsi->id;
    
#line 542 
    if ((unsigned int)vf->port_vlan_id != 0U) 
#line 543 
                                              i40e_vsi_add_pvid(vsi,(unsigned short)((int)vf->port_vlan_id)); else ;
    
#line 544 
    f = i40e_add_filter(vsi,(u8 *)(& vf->default_lan_addr.addr),(short)((int)((short)vf->port_vlan_id)),(_Bool)1,(_Bool)0);
    
#line 546 
    if (f == (struct i40e_mac_filter *)0) 
#line 547 
                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"Could not allocate VF MAC addr\n"); else ;
    
#line 549 
    f = i40e_add_filter(vsi,(u8 *)(& brdcast),(short)((int)((short)vf->port_vlan_id)),(_Bool)1,(_Bool)0);
    
#line 551 
    if (f == (struct i40e_mac_filter *)0) 
#line 552 
                                          _dev_info((struct device const *)(& (pf->pdev)->dev),"Could not allocate VF broadcast filter\n"); else ;
  }
  else ;
  
#line 557 
  ret = i40e_sync_vsi_filters(vsi);
  
#line 558 
  if (ret != 0) 
#line 559 
                dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to program ucast filters\n"); else ;
  
#line 562 
  if (vf->tx_rate != 0U) {
    i40e_status tmp;
    
#line 563 
    tmp = i40e_aq_config_vsi_bw_limit(& pf->hw,(unsigned short)((int)vsi->seid),(unsigned short)((int)((unsigned short)(vf->tx_rate / 50U))),(unsigned char)0,(struct i40e_asq_cmd_details *)0);
    
#line 563 
    ret = (int)tmp;
    
#line 565 
    if (ret != 0) 
#line 566 
                  dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to set tx rate, VF %d, error code %d.\n",(int)vf->vf_id,ret); else ;
  }
  else ;
  error_alloc_vsi_res: 
#line 570 
  ;
  
#line 571 
  return ret;
}


#line 580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_enable_vf_mappings(struct i40e_vf *vf)
{
  u32 reg;
  int j;
  
#line 582 
  struct i40e_pf *pf = vf->pf;
  
#line 583 
  struct i40e_hw *hw = & pf->hw;
  
#line 584 
  u32 total_queue_pairs = 0U;
  
#line 591 
  writel(2048U,(void volatile *)(hw->hw_addr + ((int)vf->lan_vsi_id + 537088) * 4));
  
#line 595 
  reg = 1U;
  
#line 596 
  writel(reg,(void volatile *)(hw->hw_addr + ((int)vf->vf_id + 118784) * 4));
  
#line 599 
  j = 0;
  
#line 599 
  goto ldv_61524;
  ldv_61523: 
#line 600 
  ;
  {
    
#line 600 
    u16 qid = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vf->lan_vsi_id),(unsigned char)((int)((unsigned char)j)));
    
#line 601 
    reg = (unsigned int)qid & 2047U;
    
#line 602 
    writel(reg,(void volatile *)(hw->hw_addr + ((total_queue_pairs * 1024U + (unsigned int)((int)vf->vf_id * 4)) + 458752U)));
    
#line 603 
    total_queue_pairs += 1U;
  }
  
#line 599 
  j += 1;
  ldv_61524: 
#line 600 
  ;
  
#line 599 
  if ((int)(*(pf->vsi + (int)vf->lan_vsi_idx))->alloc_queue_pairs > j) 
    
#line 601 
    goto ldv_61523; else 
#line 604 
                         goto ldv_61525;
  ldv_61525: 
#line 605 
  ;
  
#line 607 
  j = 0;
  
#line 607 
  goto ldv_61528;
  ldv_61527: 
#line 608 
  ;
  
#line 608 
  if (j * 2 >= (int)(*(pf->vsi + (int)vf->lan_vsi_idx))->alloc_queue_pairs) 
    
#line 609 
    reg = 134154239U;
  else {
    
#line 611 
    u16 qid_0 = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vf->lan_vsi_id),(unsigned char)((int)((unsigned int)((unsigned char)j) * 2U)));
    
#line 613 
    reg = (unsigned int)qid_0;
    
#line 614 
    qid_0 = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vf->lan_vsi_id),(unsigned char)((int)((unsigned int)((unsigned char)j) * 2U + 1U)));
    
#line 616 
    reg = (unsigned int)((int)qid_0 << 16) | reg;
  }
  
#line 618 
  writel(reg,(void volatile *)(hw->hw_addr + ((j * 512 + (int)vf->lan_vsi_id) + 524288) * 4));
  
#line 607 
  j += 1;
  ldv_61528: 
#line 608 
  ;
  
#line 607 
  if (j <= 6) 
#line 609 
              goto ldv_61527; else 
#line 612 
                                   goto ldv_61529;
  ldv_61529: 
#line 613 
  ;
  
#line 621 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 622 
  return;
}


#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_disable_vf_mappings(struct i40e_vf *vf)
{
  int i;
  
#line 632 
  struct i40e_pf *pf = vf->pf;
  
#line 633 
  struct i40e_hw *hw = & pf->hw;
  
#line 637 
  writel(0U,(void volatile *)(hw->hw_addr + ((int)vf->vf_id + 118784) * 4));
  
#line 638 
  i = 0;
  
#line 638 
  goto ldv_61537;
  ldv_61536: 
#line 639 
  ;
  
#line 639 
  writel(2047U,(void volatile *)(hw->hw_addr + ((i * 256 + (int)vf->vf_id) + 114688) * 4));
  
#line 638 
  i += 1;
  ldv_61537: 
#line 639 
  ;
  
#line 638 
  if (i <= 15) 
#line 640 
               goto ldv_61536; else 
#line 643 
                                    goto ldv_61538;
  ldv_61538: 
#line 644 
  ;
  
#line 641 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 642 
  return;
}


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_free_vf_res(struct i40e_vf *vf)
{
  u32 reg_idx;
  u32 reg;
  int i;
  int msix_vf;
  
#line 652 
  struct i40e_pf *pf = vf->pf;
  
#line 653 
  struct i40e_hw *hw = & pf->hw;
  
#line 658 
  if ((unsigned int)vf->lan_vsi_idx != 0U) {
    
#line 659 
    i40e_vsi_release(*(pf->vsi + (int)vf->lan_vsi_idx));
    
#line 660 
    vf->lan_vsi_idx = (unsigned char)0U;
    
#line 661 
    vf->lan_vsi_id = (unsigned char)0U;
  }
  else ;
  
#line 663 
  msix_vf = (int)pf->hw.func_caps.num_msix_vectors_vf;
  
#line 666 
  i = 0;
  
#line 666 
  goto ldv_61549;
  ldv_61548: 
#line 667 
  ;
  
#line 668 
  if (i == 0) 
#line 669 
              reg_idx = (unsigned int)(((int)vf->vf_id + 43264) * 4); else 
                                                                    
#line 671 
                                                                    reg_idx = (unsigned int)((((msix_vf + -1) * (int)vf->vf_id + (i + -1)) + 37376) * 4);
  
#line 674 
  writel(2U,(void volatile *)(hw->hw_addr + reg_idx));
  
#line 675 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 666 
  i += 1;
  ldv_61549: 
#line 667 
  ;
  
#line 666 
  if (i < msix_vf) 
#line 668 
                   goto ldv_61548; else 
#line 671 
                                        goto ldv_61550;
  ldv_61550: 
#line 672 
  ;
  
#line 679 
  i = 0;
  
#line 679 
  goto ldv_61552;
  ldv_61551: 
#line 680 
  ;
  
#line 681 
  if (i == 0) 
#line 682 
              reg_idx = (unsigned int)(((int)vf->vf_id + 43520) * 4); else 
                                                                    
#line 684 
                                                                    reg_idx = (unsigned int)((((msix_vf + -1) * (int)vf->vf_id + (i + -1)) + 37888) * 4);
  
#line 687 
  reg = 8191U;
  
#line 689 
  writel(reg,(void volatile *)(hw->hw_addr + reg_idx));
  
#line 690 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 679 
  i += 1;
  ldv_61552: 
#line 680 
  ;
  
#line 679 
  if (i < msix_vf) 
#line 681 
                   goto ldv_61551; else 
#line 684 
                                        goto ldv_61553;
  ldv_61553: 
#line 685 
  ;
  
#line 695 
  vf->num_queue_pairs = (unsigned char)0U;
  
#line 696 
  vf->vf_states = 0UL;
  
#line 697 
  return;
}


#line 705  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_alloc_vf_res(struct i40e_vf *vf)
{
  int ret;
  
#line 707 
  struct i40e_pf *pf = vf->pf;
  
#line 708 
  int total_queue_pairs = 0;
  
#line 712 
  ret = i40e_alloc_vsi_res(vf,(enum i40e_vsi_type)I40E_VSI_SRIOV);
  
#line 713 
  if (ret != 0) 
#line 714 
                goto error_alloc; else ;
  
#line 715 
  total_queue_pairs = (int)(*(pf->vsi + (int)vf->lan_vsi_idx))->alloc_queue_pairs + total_queue_pairs;
  
#line 716 
  clear_bit(0L,(unsigned long volatile *)(& vf->vf_caps));
  
#line 721 
  vf->num_queue_pairs = (unsigned char)total_queue_pairs;
  
#line 724 
  clear_bit(0L,(unsigned long volatile *)(& vf->vf_states));
  error_alloc: 
#line 726 
  ;
  
#line 727 
  if (ret != 0) 
#line 728 
                i40e_free_vf_res(vf); else ;
  
#line 730 
  return ret;
}


#line 742  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_quiesce_vf_pci(struct i40e_vf *vf)
{
  int __retres;
  int vf_abs_id;
  int i;
  u32 reg;
  
#line 744 
  struct i40e_pf *pf = vf->pf;
  
#line 745 
  struct i40e_hw *hw = & pf->hw;
  
#line 749 
  vf_abs_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
  
#line 751 
  writel((unsigned int)((vf_abs_id << 12) | 170),(void volatile *)(hw->hw_addr + 639104U));
  
#line 753 
  i = 0;
  
#line 753 
  goto ldv_61570;
  ldv_61569: 
#line 754 
  ;
  
#line 754 
  reg = readl((void const volatile *)(hw->hw_addr + 639232U));
  
#line 755 
  if ((reg & 32U) == 0U) {
    
#line 756 
    __retres = 0;
    
#line 756 
    goto return_label;
  }
  else ;
  
#line 757 
  __const_udelay(4295UL);
  
#line 753 
  i += 1;
  ldv_61570: 
#line 754 
  ;
  
#line 753 
  if (i <= 99) 
#line 755 
               goto ldv_61569; else 
#line 758 
                                    goto ldv_61571;
  ldv_61571: 
#line 759 
  ;
  
#line 759 
  __retres = -5;
  return_label: 
#line 759 
                return __retres;
}


#line 769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_reset_vf(struct i40e_vf *vf, bool flr)
{
  int i;
  u32 reg;
  int tmp;
  int tmp_0;
  
#line 771 
  struct i40e_pf *pf = vf->pf;
  
#line 772 
  struct i40e_hw *hw = & pf->hw;
  
#line 773 
  bool rsd = (_Bool)0;
  
#line 777 
  tmp = test_and_set_bit(25L,(unsigned long volatile *)(& pf->state));
  
#line 777 
  if (tmp != 0) 
#line 778 
                goto return_label; else ;
  
#line 781 
  clear_bit(1L,(unsigned long volatile *)(& vf->vf_states));
  
#line 786 
  if (! flr) {
    
#line 788 
    reg = readl((void const volatile *)(hw->hw_addr + ((int)vf->vf_id + 148992) * 4));
    
#line 789 
    reg |= 1U;
    
#line 790 
    writel(reg,(void volatile *)(hw->hw_addr + ((int)vf->vf_id + 148992) * 4));
    
#line 791 
    readl((void const volatile *)(hw->hw_addr + 745772U));
  }
  else ;
  
#line 794 
  tmp_0 = i40e_quiesce_vf_pci(vf);
  
#line 794 
  if (tmp_0 != 0) 
#line 795 
                  dev_err((struct device const *)(& (pf->pdev)->dev),"VF %d PCI transactions stuck\n",(int)vf->vf_id); else ;
  
#line 801 
  i = 0;
  
#line 801 
  goto ldv_61583;
  ldv_61582: 
#line 802 
  ;
  
#line 807 
  usleep_range(10000UL,20000UL);
  
#line 808 
  reg = readl((void const volatile *)(hw->hw_addr + ((int)vf->vf_id + 149248) * 4));
  
#line 809 
  if ((reg & 1U) != 0U) {
    
#line 810 
    rsd = (_Bool)1;
    
#line 811 
    goto ldv_61581;
  }
  else ;
  
#line 801 
  i += 1;
  ldv_61583: 
#line 802 
  ;
  
#line 801 
  if (i <= 9) 
#line 803 
              goto ldv_61582; else 
#line 806 
                                   goto ldv_61581;
  ldv_61581: 
#line 807 
  ;
  
#line 815 
  if ((int)flr != 0) 
#line 816 
                     usleep_range(10000UL,20000UL); else ;
  
#line 818 
  if (! rsd) 
#line 819 
             dev_err((struct device const *)(& (pf->pdev)->dev),"VF reset check timeout on VF %d\n",(int)vf->vf_id); else ;
  
#line 821 
  writel(1U,(void volatile *)(hw->hw_addr + ((int)vf->vf_id + 119040) * 4));
  
#line 823 
  reg = readl((void const volatile *)(hw->hw_addr + ((int)vf->vf_id + 148992) * 4));
  
#line 824 
  reg &= 4294967294U;
  
#line 825 
  writel(reg,(void volatile *)(hw->hw_addr + ((int)vf->vf_id + 148992) * 4));
  
#line 828 
  if ((unsigned int)vf->lan_vsi_idx == 0U) 
#line 829 
                                           goto complete_reset; else ;
  
#line 831 
  i40e_vsi_control_rings(*(pf->vsi + (int)vf->lan_vsi_idx),(_Bool)0);
  complete_reset: 
#line 832 
  ;
  
#line 834 
  i40e_free_vf_res(vf);
  
#line 835 
  i40e_alloc_vf_res(vf);
  
#line 836 
  i40e_enable_vf_mappings(vf);
  
#line 837 
  clear_bit(1L,(unsigned long volatile *)(& vf->vf_states));
  
#line 840 
  writel(2U,(void volatile *)(hw->hw_addr + ((int)vf->vf_id + 119040) * 4));
  
#line 841 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 842 
  clear_bit(25L,(unsigned long volatile *)(& pf->state));
  return_label: 
#line 843 
                return;
}


#line 851  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_free_vfs(struct i40e_pf *pf)
{
  u32 reg_idx;
  u32 bit_idx;
  int i;
  int tmp;
  int vf_id;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  
#line 853 
  struct i40e_hw *hw = & pf->hw;
  
#line 857 
  if (pf->vf == (struct i40e_vf *)0) 
#line 858 
                                     goto return_label; else ;
  
#line 859 
  goto ldv_61595;
  ldv_61594: 
#line 860 
  ;
  
#line 860 
  usleep_range(1000UL,2000UL);
  ldv_61595: 
#line 861 
  ;
  
#line 859 
  tmp_0 = test_and_set_bit(25L,(unsigned long volatile *)(& pf->state));
  
#line 859 
  if (tmp_0 != 0) 
#line 861 
                  goto ldv_61594; else 
#line 864 
                                       goto ldv_61596;
  ldv_61596: 
#line 865 
  ;
  
#line 862 
  i = 0;
  
#line 862 
  goto ldv_61598;
  ldv_61597: 
#line 863 
  ;
  
#line 863 
  tmp_1 = constant_test_bit(0L,(unsigned long const volatile *)(& (pf->vf + i)->vf_states));
  
#line 863 
  if (tmp_1 != 0) 
#line 864 
                  i40e_vsi_control_rings(*(pf->vsi + (int)(pf->vf + i)->lan_vsi_idx),(_Bool)0); else ;
  
#line 862 
  i += 1;
  ldv_61598: 
#line 863 
  ;
  
#line 862 
  if (pf->num_alloc_vfs > i) 
#line 864 
                             goto ldv_61597; else 
#line 867 
                                                  goto ldv_61599;
  ldv_61599: 
#line 868 
  ;
  
#line 871 
  tmp_2 = pci_vfs_assigned(pf->pdev);
  
#line 871 
  if (tmp_2 == 0) 
#line 872 
                  pci_disable_sriov(pf->pdev); else 
#line 874 
                                                    dev_warn((struct device const *)(& (pf->pdev)->dev),"VFs are assigned - not disabling SR-IOV\n");
  
#line 876 
  msleep(20U);
  
#line 879 
  tmp = pf->num_alloc_vfs;
  
#line 880 
  pf->num_alloc_vfs = 0;
  
#line 881 
  i = 0;
  
#line 881 
  goto ldv_61601;
  ldv_61600: 
#line 882 
  ;
  
#line 882 
  tmp_3 = constant_test_bit(0L,(unsigned long const volatile *)(& (pf->vf + i)->vf_states));
  
#line 882 
  if (tmp_3 != 0) 
#line 883 
                  i40e_free_vf_res(pf->vf + i); else ;
  
#line 885 
  i40e_disable_vf_mappings(pf->vf + i);
  
#line 881 
  i += 1;
  ldv_61601: 
#line 882 
  ;
  
#line 881 
  if (i < tmp) 
#line 883 
               goto ldv_61600; else 
#line 886 
                                    goto ldv_61602;
  ldv_61602: 
#line 887 
  ;
  
#line 888 
  kfree((void const *)pf->vf);
  
#line 889 
  pf->vf = (struct i40e_vf *)0;
  
#line 895 
  tmp_4 = pci_vfs_assigned(pf->pdev);
  
#line 895 
  if (tmp_4 == 0) {
    
#line 899 
    vf_id = 0;
    
#line 899 
    goto ldv_61604;
    ldv_61603: 
#line 900 
    ;
    
#line 900 
    reg_idx = (hw->func_caps.vf_base_id + (unsigned int)vf_id) / 32U;
    
#line 901 
    bit_idx = (hw->func_caps.vf_base_id + (unsigned int)vf_id) & 31U;
    
#line 902 
    writel((unsigned int)(1 << bit_idx),(void volatile *)(hw->hw_addr + (reg_idx + 149888U) * 4U));
    
#line 899 
    vf_id += 1;
    ldv_61604: 
#line 900 
    ;
    
#line 899 
    if (vf_id < tmp) 
#line 901 
                     goto ldv_61603; else 
#line 904 
                                          goto ldv_61605;
    ldv_61605: 
#line 905 
    ;
  }
  else ;
  
#line 905 
  clear_bit(25L,(unsigned long volatile *)(& pf->state));
  return_label: 
#line 906 
                return;
}


#line 916  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_alloc_vfs(struct i40e_pf *pf, u16 num_alloc_vfs)
{
  struct i40e_vf *vfs;
  int i;
  int tmp;
  
#line 919 
  int ret = 0;
  
#line 922 
  i40e_irq_dynamic_disable_icr0(pf);
  
#line 925 
  tmp = pci_num_vf(pf->pdev);
  
#line 925 
  ;
  
#line 925 
  if (tmp != (int)num_alloc_vfs) {
    
#line 926 
    ret = pci_enable_sriov(pf->pdev,(int)num_alloc_vfs);
    
#line 927 
    if (ret != 0) {
      
#line 928 
      dev_err((struct device const *)(& (pf->pdev)->dev),"Failed to enable SR-IOV, error %d.\n",ret);
      
#line 930 
      pf->num_alloc_vfs = 0;
      
#line 931 
      goto err_iov;
    }
    else ;
  }
  else ;
  
#line 935 
  vfs = (struct i40e_vf *)kcalloc_0((unsigned long)num_alloc_vfs,88UL,208U);
  
#line 936 
  if (vfs == (struct i40e_vf *)0) {
    
#line 937 
    ret = -12;
    
#line 938 
    goto err_alloc;
  }
  else ;
  
#line 940 
  pf->vf = vfs;
  
#line 943 
  i = 0;
  
#line 943 
  goto ldv_61616;
  ldv_61615: 
#line 944 
  ;
  
#line 944 
  (vfs + i)->pf = pf;
  
#line 945 
  (vfs + i)->parent_type = I40E_SWITCH_ELEMENT_TYPE_VEB;
  
#line 946 
  (vfs + i)->vf_id = (unsigned short)i;
  
#line 949 
  clear_bit(1L,(unsigned long volatile *)(& (vfs + i)->vf_caps));
  
#line 950 
  (vfs + i)->spoofchk = (_Bool)1;
  
#line 952 
  i40e_reset_vf(vfs + i,(_Bool)0);
  
#line 955 
  i40e_enable_vf_mappings(vfs + i);
  
#line 943 
  i += 1;
  ldv_61616: 
#line 944 
  ;
  
#line 943 
  if ((int)num_alloc_vfs > i) 
#line 945 
                              goto ldv_61615; else 
#line 948 
                                                   goto ldv_61617;
  ldv_61617: 
#line 949 
  ;
  
#line 957 
  pf->num_alloc_vfs = (int)num_alloc_vfs;
  err_alloc: 
#line 959 
  ;
  
#line 960 
  if (ret != 0) 
#line 961 
                i40e_free_vfs(pf); else ;
  err_iov: 
#line 962 
  ;
  
#line 964 
  i40e_irq_dynamic_enable_icr0(pf);
  
#line 965 
  return ret;
}


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_pci_sriov_enable(struct pci_dev *pdev, int num_vfs)
{
  int __retres;
  
#line 979 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 980 
  int pre_existing_vfs = pci_num_vf(pdev);
  
#line 981 
  int err = 0;
  
#line 990 
  _dev_info((struct device const *)(& pdev->dev),"Allocating %d VFs.\n",num_vfs);
  
#line 991 
  if (pre_existing_vfs != 0 && pre_existing_vfs != num_vfs) 
#line 992 
                                                            i40e_free_vfs(pf);
  else 
    
#line 993 
    if (pre_existing_vfs != 0 && pre_existing_vfs == num_vfs) 
#line 994 
                                                              goto out; else ;
  
#line 996 
  if ((int)pf->num_req_vfs < num_vfs) {
    
#line 997 
    err = -1;
    
#line 998 
    goto err_out;
  }
  else ;
  
#line 1001 
  err = i40e_alloc_vfs(pf,(unsigned short)((int)((unsigned short)num_vfs)));
  
#line 1002 
  if (err != 0) {
    
#line 1003 
    dev_warn((struct device const *)(& pdev->dev),"Failed to enable SR-IOV: %d\n",err);
    
#line 1004 
    goto err_out;
  }
  else ;
  out: 
#line 1007 
  ;
  
#line 1008 
  __retres = num_vfs;
  
#line 1008 
  goto return_label;
  err_out: 
#line 1010 
  ;
  
#line 1011 
  __retres = err;
  
#line 1011 
  goto return_label;
  
#line 1013 
  __retres = 0;
  return_label: 
#line 1013 
                return __retres;
}


#line 1024  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_pci_sriov_configure(struct pci_dev *pdev, int num_vfs)
{
  int __retres;
  int tmp_1;
  
#line 1026 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  
#line 1028 
  if (num_vfs != 0) {
    int tmp_0;
    
#line 1029 
    if ((pf->flags & 1099511627776ULL) == 0ULL) {
      
#line 1030 
      pf->flags |= 1099511627776ULL;
      
#line 1031 
      i40e_do_reset_safe(pf,4096U);
    }
    else ;
    
#line 1034 
    tmp_0 = i40e_pci_sriov_enable(pdev,num_vfs);
    
#line 1034 
    __retres = tmp_0;
    
#line 1034 
    goto return_label;
  }
  else ;
  
#line 1037 
  tmp_1 = pci_vfs_assigned(pf->pdev);
  
#line 1037 
  if (tmp_1 == 0) {
    
#line 1038 
    i40e_free_vfs(pf);
    
#line 1039 
    pf->flags &= 18446742974197923839ULL;
    
#line 1040 
    i40e_do_reset_safe(pf,4096U);
  }
  else {
    
#line 1042 
    dev_warn((struct device const *)(& pdev->dev),"Unable to free VFs because some are assigned to VMs.\n");
    
#line 1043 
    __retres = -22;
    
#line 1043 
    goto return_label;
  }
  
#line 1045 
  __retres = 0;
  return_label: 
#line 1045 
                return __retres;
}


#line 1060  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_send_msg_to_vf(struct i40e_vf *vf, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen)
{
  int __retres;
  struct i40e_pf *pf;
  struct i40e_hw *hw;
  int abs_vf_id;
  i40e_status aq_ret;
  
#line 1069 
  if (vf == (struct i40e_vf *)0 || (int)vf->vf_id >= (vf->pf)->num_alloc_vfs) {
    
#line 1070 
    __retres = -22;
    
#line 1070 
    goto return_label;
  }
  else ;
  
#line 1072 
  pf = vf->pf;
  
#line 1073 
  hw = & pf->hw;
  
#line 1074 
  abs_vf_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
  
#line 1077 
  if (v_retval != 0U) {
    
#line 1078 
    vf->num_invalid_msgs += 1ULL;
    
#line 1079 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Failed opcode %d Error: %d\n",v_opcode,v_retval);
    
#line 1081 
    if (vf->num_invalid_msgs > 10ULL) {
      
#line 1083 
      dev_err((struct device const *)(& (pf->pdev)->dev),"Number of invalid messages exceeded for VF %d\n",(int)vf->vf_id);
      
#line 1086 
      dev_err((struct device const *)(& (pf->pdev)->dev),"Use PF Control I/F to enable the VF\n");
      
#line 1087 
      clear_bit(3L,(unsigned long volatile *)(& vf->vf_states));
    }
    else ;
  }
  else 
#line 1090 
       vf->num_valid_msgs += 1ULL;
  
#line 1093 
  aq_ret = i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)abs_vf_id)),v_opcode,v_retval,msg,(unsigned short)((int)msglen),(struct i40e_asq_cmd_details *)0);
  
#line 1095 
  if (aq_ret != I40E_SUCCESS) {
    
#line 1096 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to send the message to VF %d aq_err %d\n",(int)vf->vf_id,(unsigned int)pf->hw.aq.asq_last_status);
    
#line 1099 
    __retres = -5;
    
#line 1099 
    goto return_label;
  }
  else ;
  
#line 1102 
  __retres = 0;
  return_label: 
#line 1102 
                return __retres;
}


#line 1113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_send_resp_to_vf(struct i40e_vf *vf, enum i40e_virtchnl_ops opcode, i40e_status retval)
{
  int tmp;
  
#line 1117 
  tmp = i40e_vc_send_msg_to_vf(vf,(unsigned int)opcode,(unsigned int)retval,(u8 *)0U,(unsigned short)0);
  
#line 1117 
  return tmp;
}


#line 1126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_get_version_msg(struct i40e_vf *vf)
{
  int tmp;
  
#line 1128 
  struct i40e_virtchnl_version_info info = {.major = 1U, .minor = 0U};
  
#line 1132 
  tmp = i40e_vc_send_msg_to_vf(vf,1U,0U,(u8 *)(& info),(unsigned short)8);
  
#line 1132 
  return tmp;
}


#line 1146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_get_vf_resources_msg(struct i40e_vf *vf)
{
  struct i40e_vsi *vsi;
  int ret;
  int tmp;
  
#line 1148 
  struct i40e_virtchnl_vf_resource *vfres = (struct i40e_virtchnl_vf_resource *)0;
  
#line 1149 
  struct i40e_pf *pf = vf->pf;
  
#line 1150 
  i40e_status aq_ret = 0;
  
#line 1152 
  int i = 0;
  
#line 1152 
  int len = 0;
  
#line 1153 
  int num_vsis = 1;
  
#line 1156 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1156 
  if (tmp == 0) {
    
#line 1157 
    aq_ret = I40E_ERR_PARAM;
    
#line 1158 
    goto err;
  }
  else ;
  
#line 1161 
  len = (int)((unsigned long)num_vsis * (unsigned long)16U + (unsigned long)36U);
  
#line 1164 
  vfres = (struct i40e_virtchnl_vf_resource *)kzalloc_1((unsigned long)len,208U);
  
#line 1165 
  if (vfres == (struct i40e_virtchnl_vf_resource *)0) {
    
#line 1166 
    aq_ret = I40E_ERR_NO_MEMORY;
    
#line 1167 
    len = 0;
    
#line 1168 
    goto err;
  }
  else ;
  
#line 1171 
  vfres->vf_offload_flags = 1U;
  
#line 1172 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 1173 
  if ((unsigned int)vsi->info.pvid == 0U) 
#line 1174 
                                          vfres->vf_offload_flags |= 65536U; else ;
  
#line 1176 
  vfres->num_vsis = (unsigned short)num_vsis;
  
#line 1177 
  vfres->num_queue_pairs = (unsigned short)vf->num_queue_pairs;
  
#line 1178 
  vfres->max_vectors = (unsigned short)pf->hw.func_caps.num_msix_vectors_vf;
  
#line 1179 
  if ((unsigned int)vf->lan_vsi_idx != 0U) {
    
#line 1180 
    vfres->vsi_res[i].vsi_id = (unsigned short)vf->lan_vsi_id;
    
#line 1181 
    vfres->vsi_res[i].vsi_type = I40E_VSI_SRIOV;
    
#line 1182 
    vfres->vsi_res[i].num_queue_pairs = (*(pf->vsi + (int)vf->lan_vsi_idx))->alloc_queue_pairs;
    
#line 1184 
    memcpy((void *)(& vfres->vsi_res[i].default_mac_addr),(void const *)(& vf->default_lan_addr.addr),6UL);
    
#line 1186 
    i += 1;
  }
  else ;
  
#line 1188 
  clear_bit(1L,(unsigned long volatile *)(& vf->vf_states));
  err: 
#line 1190 
  ;
  
#line 1192 
  ret = i40e_vc_send_msg_to_vf(vf,3U,(unsigned int)aq_ret,(u8 *)vfres,(unsigned short)((int)((unsigned short)len)));
  
#line 1195 
  kfree((void const *)vfres);
  
#line 1196 
  return ret;
}


#line 1209  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_vc_reset_vf_msg(struct i40e_vf *vf)
{
  int tmp;
  
#line 1211 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1211 
  if (tmp != 0) 
#line 1212 
                i40e_reset_vf(vf,(_Bool)0); else ;
  
#line 1213 
  return;
}


#line 1224  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_config_promiscuous_mode_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  struct i40e_vsi *vsi;
  i40e_status aq_ret;
  int tmp;
  int tmp_3;
  
#line 1227 
  struct i40e_virtchnl_promisc_info *info = (struct i40e_virtchnl_promisc_info *)msg;
  
#line 1229 
  struct i40e_pf *pf = vf->pf;
  
#line 1230 
  struct i40e_hw *hw = & pf->hw;
  
#line 1232 
  bool allmulti = (_Bool)0;
  
#line 1235 
  vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)info->vsi_id));
  
#line 1236 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1236 
  if (tmp == 0) 
#line 1236 
                goto _LOR;
  else {
    int tmp_0;
    
#line 1236 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_caps));
    
#line 1236 
    if (tmp_0 == 0) 
#line 1236 
                    goto _LOR;
    else {
      int tmp_2;
      bool tmp_1;
      
#line 1238 
      tmp_1 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)info->vsi_id));
      
#line 1238 
      if (tmp_1) 
#line 1238 
                 tmp_2 = 0; else 
#line 1238 
                                 tmp_2 = 1;
      
#line 1238 
      if (tmp_2) 
#line 1236 
                 goto _LOR;
      else 
        
#line 1238 
        if (vsi->type != (unsigned int)I40E_VSI_FCOE) {
          _LOR: {
                  
#line 1240 
                  aq_ret = I40E_ERR_PARAM;
                  
#line 1241 
                  goto error_param;
                }
        }
        else ;
    }
  }
  
#line 1243 
  if (((int)info->flags & 2) != 0) 
#line 1244 
                                   allmulti = (_Bool)1; else ;
  
#line 1245 
  aq_ret = i40e_aq_set_vsi_multicast_promiscuous(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)allmulti) != 0),(struct i40e_asq_cmd_details *)0);
  error_param: 
#line 1248 
  ;
  
#line 1250 
  tmp_3 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,aq_ret);
  
#line 1250 
  return tmp_3;
}


#line 1264  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_config_queues_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  struct i40e_virtchnl_queue_pair_info *qpi;
  u16 vsi_id;
  u16 vsi_queue_id;
  int i;
  int tmp;
  int tmp_1;
  bool tmp_0;
  int tmp_4;
  int tmp_6;
  
#line 1266 
  struct i40e_virtchnl_vsi_queue_config_info *qci = (struct i40e_virtchnl_vsi_queue_config_info *)msg;
  
#line 1269 
  struct i40e_pf *pf = vf->pf;
  
#line 1271 
  i40e_status aq_ret = 0;
  
#line 1274 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1274 
  if (tmp == 0) {
    
#line 1275 
    aq_ret = I40E_ERR_PARAM;
    
#line 1276 
    goto error_param;
  }
  else ;
  
#line 1279 
  vsi_id = qci->vsi_id;
  
#line 1280 
  tmp_0 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vsi_id));
  
#line 1280 
  if (tmp_0) 
#line 1280 
             tmp_1 = 0; else 
#line 1280 
                             tmp_1 = 1;
  
#line 1280 
  if (tmp_1) {
    
#line 1281 
    aq_ret = I40E_ERR_PARAM;
    
#line 1282 
    goto error_param;
  }
  else ;
  
#line 1284 
  i = 0;
  
#line 1284 
  goto ldv_61693;
  ldv_61692: 
#line 1285 
  ;
  
#line 1285 
  qpi = & qci->qpair[i];
  
#line 1286 
  vsi_queue_id = qpi->txq.queue_id;
  
#line 1287 
  if (((int)qpi->txq.vsi_id != (int)vsi_id || (int)qpi->rxq.vsi_id != (int)vsi_id) || (int)qpi->rxq.queue_id != (int)vsi_queue_id) 
    
#line 1287 
    goto _LOR;
  else {
    int tmp_3;
    bool tmp_2;
    
#line 1290 
    tmp_2 = i40e_vc_isvalid_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
    
#line 1290 
    if (tmp_2) 
#line 1290 
               tmp_3 = 0; else 
#line 1290 
                               tmp_3 = 1;
    
#line 1290 
    if (tmp_3) {
      _LOR: {
              
#line 1291 
              aq_ret = I40E_ERR_PARAM;
              
#line 1292 
              goto error_param;
            }
    }
    else ;
  }
  
#line 1295 
  tmp_4 = i40e_config_vsi_rx_queue(vf,(unsigned short)((int)vsi_id),(unsigned short)((int)vsi_queue_id),& qpi->rxq);
  
#line 1295 
  if (tmp_4 != 0) 
#line 1295 
                  goto _LOR_0;
  else {
    int tmp_5;
    
#line 1296 
    tmp_5 = i40e_config_vsi_tx_queue(vf,(unsigned short)((int)vsi_id),(unsigned short)((int)vsi_queue_id),& qpi->txq);
    
#line 1296 
    if (tmp_5 != 0) {
      _LOR_0: {
                
#line 1299 
                aq_ret = I40E_ERR_PARAM;
                
#line 1300 
                goto error_param;
              }
    }
    else ;
  }
  
#line 1284 
  i += 1;
  ldv_61693: 
#line 1285 
  ;
  
#line 1284 
  if ((int)qci->num_queue_pairs > i) 
#line 1286 
                                     goto ldv_61692; else 
#line 1289 
                                                          goto ldv_61694;
  ldv_61694: 
#line 1290 
  ;
  
#line 1304 
  (*(pf->vsi + (int)vf->lan_vsi_idx))->num_queue_pairs = qci->num_queue_pairs;
  error_param: 
#line 1306 
  ;
  
#line 1308 
  tmp_6 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES,aq_ret);
  
#line 1308 
  return tmp_6;
}


#line 1321  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_config_irq_map_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  struct i40e_virtchnl_vector_map *map;
  u16 vsi_id;
  u16 vsi_queue_id;
  u16 vector_id;
  unsigned long tempmap;
  int i;
  int tmp;
  int tmp_1;
  bool tmp_0;
  unsigned long tmp_4;
  int tmp_6;
  bool tmp_5;
  unsigned long tmp_7;
  unsigned long tmp_8;
  int tmp_10;
  bool tmp_9;
  unsigned long tmp_11;
  int tmp_12;
  
#line 1323 
  struct i40e_virtchnl_irq_map_info *irqmap_info = (struct i40e_virtchnl_irq_map_info *)msg;
  
#line 1327 
  i40e_status aq_ret = 0;
  
#line 1331 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1331 
  if (tmp == 0) {
    
#line 1332 
    aq_ret = I40E_ERR_PARAM;
    
#line 1333 
    goto error_param;
  }
  else ;
  
#line 1336 
  i = 0;
  
#line 1336 
  goto ldv_61716;
  ldv_61715: 
#line 1337 
  ;
  
#line 1337 
  map = & irqmap_info->vecmap[i];
  
#line 1339 
  vector_id = map->vector_id;
  
#line 1340 
  vsi_id = map->vsi_id;
  
#line 1342 
  tmp_0 = i40e_vc_isvalid_vector_id(vf,(unsigned char)((int)((unsigned char)vector_id)));
  
#line 1342 
  if (tmp_0) 
#line 1342 
             tmp_1 = 0; else 
#line 1342 
                             tmp_1 = 1;
  
#line 1342 
  if (tmp_1) 
#line 1342 
             goto _LOR;
  else {
    int tmp_3;
    bool tmp_2;
    
#line 1343 
    tmp_2 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vsi_id));
    
#line 1343 
    if (tmp_2) 
#line 1343 
               tmp_3 = 0; else 
#line 1343 
                               tmp_3 = 1;
    
#line 1343 
    if (tmp_3) {
      _LOR: {
              
#line 1344 
              aq_ret = I40E_ERR_PARAM;
              
#line 1345 
              goto error_param;
            }
    }
    else ;
  }
  
#line 1349 
  tempmap = (unsigned long)map->rxq_map;
  
#line 1350 
  tmp_4 = find_first_bit((unsigned long const *)(& tempmap),16UL);
  
#line 1350 
  vsi_queue_id = (unsigned short)tmp_4;
  
#line 1350 
  goto ldv_61710;
  ldv_61709: 
#line 1351 
  ;
  
#line 1351 
  tmp_5 = i40e_vc_isvalid_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
  
#line 1351 
  if (tmp_5) 
#line 1351 
             tmp_6 = 0; else 
#line 1351 
                             tmp_6 = 1;
  
#line 1351 
  if (tmp_6) {
    
#line 1353 
    aq_ret = I40E_ERR_PARAM;
    
#line 1354 
    goto error_param;
  }
  else ;
  
#line 1350 
  tmp_7 = find_next_bit((unsigned long const *)(& tempmap),16UL,(unsigned long)((int)vsi_queue_id + 1));
  
#line 1350 
  vsi_queue_id = (unsigned short)tmp_7;
  ldv_61710: 
#line 1351 
  ;
  
#line 1350 
  if ((unsigned int)vsi_queue_id <= 15U) 
#line 1352 
                                         goto ldv_61709; else 
#line 1355 
                                                              goto ldv_61711;
  ldv_61711: 
#line 1356 
  ;
  
#line 1358 
  tempmap = (unsigned long)map->txq_map;
  
#line 1359 
  tmp_8 = find_first_bit((unsigned long const *)(& tempmap),16UL);
  
#line 1359 
  vsi_queue_id = (unsigned short)tmp_8;
  
#line 1359 
  goto ldv_61713;
  ldv_61712: 
#line 1360 
  ;
  
#line 1360 
  tmp_9 = i40e_vc_isvalid_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
  
#line 1360 
  if (tmp_9) 
#line 1360 
             tmp_10 = 0; else 
#line 1360 
                              tmp_10 = 1;
  
#line 1360 
  if (tmp_10) {
    
#line 1362 
    aq_ret = I40E_ERR_PARAM;
    
#line 1363 
    goto error_param;
  }
  else ;
  
#line 1359 
  tmp_11 = find_next_bit((unsigned long const *)(& tempmap),16UL,(unsigned long)((int)vsi_queue_id + 1));
  
#line 1359 
  vsi_queue_id = (unsigned short)tmp_11;
  ldv_61713: 
#line 1360 
  ;
  
#line 1359 
  if ((unsigned int)vsi_queue_id <= 15U) 
#line 1361 
                                         goto ldv_61712; else 
#line 1364 
                                                              goto ldv_61714;
  ldv_61714: 
#line 1365 
  ;
  
#line 1367 
  i40e_config_irq_link_list(vf,(unsigned short)((int)vsi_id),map);
  
#line 1336 
  i += 1;
  ldv_61716: 
#line 1337 
  ;
  
#line 1336 
  if ((int)irqmap_info->num_vectors > i) 
#line 1338 
                                         goto ldv_61715; else 
#line 1341 
                                                              goto ldv_61717;
  ldv_61717: 
#line 1342 
  ;
  error_param: 
#line 1369 
  ;
  
#line 1371 
  tmp_12 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP,aq_ret);
  
#line 1371 
  return tmp_12;
}


#line 1383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_enable_queues_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  int tmp;
  int tmp_1;
  bool tmp_0;
  int tmp_2;
  int tmp_3;
  
#line 1385 
  struct i40e_virtchnl_queue_select *vqs = (struct i40e_virtchnl_queue_select *)msg;
  
#line 1387 
  struct i40e_pf *pf = vf->pf;
  
#line 1388 
  u16 vsi_id = vqs->vsi_id;
  
#line 1389 
  i40e_status aq_ret = 0;
  
#line 1391 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1391 
  if (tmp == 0) {
    
#line 1392 
    aq_ret = I40E_ERR_PARAM;
    
#line 1393 
    goto error_param;
  }
  else ;
  
#line 1396 
  tmp_0 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vsi_id));
  
#line 1396 
  if (tmp_0) 
#line 1396 
             tmp_1 = 0; else 
#line 1396 
                             tmp_1 = 1;
  
#line 1396 
  if (tmp_1) {
    
#line 1397 
    aq_ret = I40E_ERR_PARAM;
    
#line 1398 
    goto error_param;
  }
  else ;
  
#line 1401 
  if (vqs->rx_queues == 0U && vqs->tx_queues == 0U) {
    
#line 1402 
    aq_ret = I40E_ERR_PARAM;
    
#line 1403 
    goto error_param;
  }
  else ;
  
#line 1406 
  tmp_2 = i40e_vsi_control_rings(*(pf->vsi + (int)vf->lan_vsi_idx),(_Bool)1);
  
#line 1406 
  if (tmp_2 != 0) 
#line 1407 
                  aq_ret = I40E_ERR_TIMEOUT; else ;
  error_param: 
#line 1408 
  ;
  
#line 1410 
  tmp_3 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_ENABLE_QUEUES,aq_ret);
  
#line 1410 
  return tmp_3;
}


#line 1423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_disable_queues_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  int tmp;
  int tmp_1;
  bool tmp_0;
  int tmp_2;
  int tmp_3;
  
#line 1425 
  struct i40e_virtchnl_queue_select *vqs = (struct i40e_virtchnl_queue_select *)msg;
  
#line 1427 
  struct i40e_pf *pf = vf->pf;
  
#line 1428 
  i40e_status aq_ret = 0;
  
#line 1430 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1430 
  if (tmp == 0) {
    
#line 1431 
    aq_ret = I40E_ERR_PARAM;
    
#line 1432 
    goto error_param;
  }
  else ;
  
#line 1435 
  tmp_0 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vqs->vsi_id));
  
#line 1435 
  if (tmp_0) 
#line 1435 
             tmp_1 = 0; else 
#line 1435 
                             tmp_1 = 1;
  
#line 1435 
  if (tmp_1) {
    
#line 1436 
    aq_ret = I40E_ERR_PARAM;
    
#line 1437 
    goto error_param;
  }
  else ;
  
#line 1440 
  if (vqs->rx_queues == 0U && vqs->tx_queues == 0U) {
    
#line 1441 
    aq_ret = I40E_ERR_PARAM;
    
#line 1442 
    goto error_param;
  }
  else ;
  
#line 1445 
  tmp_2 = i40e_vsi_control_rings(*(pf->vsi + (int)vf->lan_vsi_idx),(_Bool)0);
  
#line 1445 
  if (tmp_2 != 0) 
#line 1446 
                  aq_ret = I40E_ERR_TIMEOUT; else ;
  error_param: 
#line 1448 
  ;
  
#line 1450 
  tmp_3 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_DISABLE_QUEUES,aq_ret);
  
#line 1450 
  return tmp_3;
}


#line 1462  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_get_stats_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  struct i40e_eth_stats stats;
  struct i40e_vsi *vsi;
  int tmp;
  int tmp_1;
  bool tmp_0;
  int tmp_2;
  
#line 1464 
  struct i40e_virtchnl_queue_select *vqs = (struct i40e_virtchnl_queue_select *)msg;
  
#line 1466 
  struct i40e_pf *pf = vf->pf;
  
#line 1468 
  i40e_status aq_ret = 0;
  
#line 1471 
  memset((void *)(& stats),0,96UL);
  
#line 1473 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1473 
  if (tmp == 0) {
    
#line 1474 
    aq_ret = I40E_ERR_PARAM;
    
#line 1475 
    goto error_param;
  }
  else ;
  
#line 1478 
  tmp_0 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vqs->vsi_id));
  
#line 1478 
  if (tmp_0) 
#line 1478 
             tmp_1 = 0; else 
#line 1478 
                             tmp_1 = 1;
  
#line 1478 
  if (tmp_1) {
    
#line 1479 
    aq_ret = I40E_ERR_PARAM;
    
#line 1480 
    goto error_param;
  }
  else ;
  
#line 1483 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 1484 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 1485 
    aq_ret = I40E_ERR_PARAM;
    
#line 1486 
    goto error_param;
  }
  else ;
  
#line 1488 
  i40e_update_eth_stats(vsi);
  
#line 1489 
  stats = vsi->eth_stats;
  error_param: 
#line 1491 
  ;
  
#line 1493 
  tmp_2 = i40e_vc_send_msg_to_vf(vf,15U,(unsigned int)aq_ret,(u8 *)(& stats),(unsigned short)96);
  
#line 1493 
  return tmp_2;
}


#line 1507  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static int i40e_check_vf_permission(struct i40e_vf *vf, u8 *macaddr)
{
  bool tmp_3;
  
#line 1509 
  struct i40e_pf *pf = vf->pf;
  
#line 1510 
  int ret = 0;
  
#line 1512 
  tmp_3 = is_broadcast_ether_addr((u8 const *)macaddr);
  
#line 1512 
  if ((int)tmp_3 != 0) 
#line 1512 
                       goto _LOR;
  else {
    bool tmp_4;
    
#line 1512 
    tmp_4 = is_zero_ether_addr((u8 const *)macaddr);
    
#line 1512 
    if ((int)tmp_4 != 0) {
      _LOR: {
              
#line 1514 
              dev_err((struct device const *)(& (pf->pdev)->dev),"invalid VF MAC addr %pM\n",macaddr);
              
#line 1515 
              ret = -10;
            }
    }
    else 
      
#line 1516 
      if ((int)vf->pf_set_mac != 0) {
        int tmp_0;
        bool tmp;
        
#line 1516 
        tmp = is_multicast_ether_addr((u8 const *)macaddr);
        
#line 1516 
        if (tmp) 
#line 1516 
                 tmp_0 = 0; else 
#line 1516 
                                 tmp_0 = 1;
        
#line 1516 
        if (tmp_0) {
          int tmp_2;
          bool tmp_1;
          
#line 1517 
          tmp_1 = ether_addr_equal((u8 const *)macaddr,(u8 const *)(& vf->default_lan_addr.addr));
          
#line 1517 
          if (tmp_1) 
#line 1517 
                     tmp_2 = 0; else 
#line 1517 
                                     tmp_2 = 1;
          
#line 1517 
          if (tmp_2) {
            
#line 1524 
            dev_err((struct device const *)(& (pf->pdev)->dev),"VF attempting to override administratively set MAC address\nPlease reload the VF driver to resume normal operation\n");
            
#line 1526 
            ret = -1;
          }
          else ;
        }
        else ;
      }
      else ;
  }
  
#line 1528 
  return ret;
}


#line 1539  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_add_mac_addr_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  int i;
  int tmp;
  int tmp_3;
  int tmp_5;
  int tmp_6;
  
#line 1541 
  struct i40e_virtchnl_ether_addr_list *al = (struct i40e_virtchnl_ether_addr_list *)msg;
  
#line 1543 
  struct i40e_pf *pf = vf->pf;
  
#line 1544 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  
#line 1545 
  u16 vsi_id = al->vsi_id;
  
#line 1546 
  i40e_status ret = 0;
  
#line 1549 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1549 
  if (tmp == 0) 
#line 1549 
                goto _LOR;
  else {
    int tmp_0;
    
#line 1549 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_caps));
    
#line 1549 
    if (tmp_0 == 0) 
#line 1549 
                    goto _LOR;
    else {
      int tmp_2;
      bool tmp_1;
      
#line 1551 
      tmp_1 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vsi_id));
      
#line 1551 
      if (tmp_1) 
#line 1551 
                 tmp_2 = 0; else 
#line 1551 
                                 tmp_2 = 1;
      
#line 1551 
      if (tmp_2) {
        _LOR: {
                
#line 1552 
                ret = I40E_ERR_PARAM;
                
#line 1553 
                goto error_param;
              }
      }
      else ;
    }
  }
  
#line 1556 
  i = 0;
  
#line 1556 
  goto ldv_61767;
  ldv_61766: 
#line 1557 
  ;
  
#line 1557 
  tmp_3 = i40e_check_vf_permission(vf,(u8 *)(& al->list[i].addr));
  
#line 1557 
  ret = (enum i40e_status_code)tmp_3;
  
#line 1558 
  if (ret != I40E_SUCCESS) 
#line 1559 
                           goto error_param; else ;
  
#line 1556 
  i += 1;
  ldv_61767: 
#line 1557 
  ;
  
#line 1556 
  if ((int)al->num_elements > i) 
#line 1558 
                                 goto ldv_61766; else 
#line 1561 
                                                      goto ldv_61768;
  ldv_61768: 
#line 1562 
  ;
  
#line 1561 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 1564 
  i = 0;
  
#line 1564 
  goto ldv_61771;
  ldv_61770: 
#line 1565 
  ;
  {
    struct i40e_mac_filter *f;
    
#line 1567 
    f = i40e_find_mac(vsi,(u8 *)(& al->list[i].addr),(_Bool)1,(_Bool)0);
    
#line 1568 
    if (f == (struct i40e_mac_filter *)0) {
      bool tmp_4;
      
#line 1569 
      tmp_4 = i40e_is_vsi_in_vlan(vsi);
      
#line 1569 
      if ((int)tmp_4 != 0) 
#line 1570 
                           f = i40e_put_mac_in_vlan(vsi,(u8 *)(& al->list[i].addr),(_Bool)1,(_Bool)0); else 
                                                                    
#line 1573 
                                                                    f = i40e_add_filter(vsi,(u8 *)(& al->list[i].addr),(short)(-1),(_Bool)1,(_Bool)0);
    }
    else ;
    
#line 1577 
    if (f == (struct i40e_mac_filter *)0) {
      
#line 1578 
      dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to add VF MAC filter\n");
      
#line 1580 
      ret = I40E_ERR_PARAM;
      
#line 1581 
      goto error_param;
    }
    else ;
  }
  
#line 1564 
  i += 1;
  ldv_61771: 
#line 1565 
  ;
  
#line 1564 
  if ((int)al->num_elements > i) 
#line 1566 
                                 goto ldv_61770; else 
#line 1569 
                                                      goto ldv_61772;
  ldv_61772: 
#line 1570 
  ;
  
#line 1586 
  tmp_5 = i40e_sync_vsi_filters(vsi);
  
#line 1586 
  if (tmp_5 != 0) 
#line 1587 
                  dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to program VF MAC filters\n"); else ;
  error_param: 
#line 1589 
  ;
  
#line 1591 
  tmp_6 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS,ret);
  
#line 1591 
  return tmp_6;
}


#line 1603  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_del_mac_addr_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  int i;
  int tmp;
  bool tmp_3;
  int tmp_5;
  int tmp_6;
  
#line 1605 
  struct i40e_virtchnl_ether_addr_list *al = (struct i40e_virtchnl_ether_addr_list *)msg;
  
#line 1607 
  struct i40e_pf *pf = vf->pf;
  
#line 1608 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  
#line 1609 
  u16 vsi_id = al->vsi_id;
  
#line 1610 
  i40e_status ret = 0;
  
#line 1613 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1613 
  if (tmp == 0) 
#line 1613 
                goto _LOR;
  else {
    int tmp_0;
    
#line 1613 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_caps));
    
#line 1613 
    if (tmp_0 == 0) 
#line 1613 
                    goto _LOR;
    else {
      int tmp_2;
      bool tmp_1;
      
#line 1615 
      tmp_1 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vsi_id));
      
#line 1615 
      if (tmp_1) 
#line 1615 
                 tmp_2 = 0; else 
#line 1615 
                                 tmp_2 = 1;
      
#line 1615 
      if (tmp_2) {
        _LOR: {
                
#line 1616 
                ret = I40E_ERR_PARAM;
                
#line 1617 
                goto error_param;
              }
      }
      else ;
    }
  }
  
#line 1620 
  i = 0;
  
#line 1620 
  goto ldv_61786;
  ldv_61785: 
#line 1621 
  ;
  
#line 1621 
  tmp_3 = is_broadcast_ether_addr((u8 const *)(& al->list[i].addr));
  
#line 1621 
  if ((int)tmp_3 != 0) 
#line 1621 
                       goto _LOR_0;
  else {
    bool tmp_4;
    
#line 1621 
    tmp_4 = is_zero_ether_addr((u8 const *)(& al->list[i].addr));
    
#line 1621 
    if ((int)tmp_4 != 0) {
      _LOR_0: {
                
#line 1623 
                dev_err((struct device const *)(& (pf->pdev)->dev),"invalid VF MAC addr %pM\n",(u8 *)(& al->list[i].addr));
                
#line 1625 
                ret = I40E_ERR_INVALID_MAC_ADDR;
                
#line 1626 
                goto error_param;
              }
    }
    else ;
  }
  
#line 1620 
  i += 1;
  ldv_61786: 
#line 1621 
  ;
  
#line 1620 
  if ((int)al->num_elements > i) 
#line 1622 
                                 goto ldv_61785; else 
#line 1625 
                                                      goto ldv_61787;
  ldv_61787: 
#line 1626 
  ;
  
#line 1629 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 1632 
  i = 0;
  
#line 1632 
  goto ldv_61789;
  ldv_61788: 
#line 1633 
  ;
  
#line 1633 
  i40e_del_filter(vsi,(u8 *)(& al->list[i].addr),(short)(-1),(_Bool)1,(_Bool)0);
  
#line 1632 
  i += 1;
  ldv_61789: 
#line 1633 
  ;
  
#line 1632 
  if ((int)al->num_elements > i) 
#line 1634 
                                 goto ldv_61788; else 
#line 1637 
                                                      goto ldv_61790;
  ldv_61790: 
#line 1638 
  ;
  
#line 1637 
  tmp_5 = i40e_sync_vsi_filters(vsi);
  
#line 1637 
  if (tmp_5 != 0) 
#line 1638 
                  dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to program VF MAC filters\n"); else ;
  error_param: 
#line 1640 
  ;
  
#line 1642 
  tmp_6 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS,ret);
  
#line 1642 
  return tmp_6;
}


#line 1654  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_add_vlan_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  int i;
  int tmp;
  int tmp_4;
  
#line 1656 
  struct i40e_virtchnl_vlan_filter_list *vfl = (struct i40e_virtchnl_vlan_filter_list *)msg;
  
#line 1658 
  struct i40e_pf *pf = vf->pf;
  
#line 1659 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  
#line 1660 
  u16 vsi_id = vfl->vsi_id;
  
#line 1661 
  i40e_status aq_ret = 0;
  
#line 1664 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1664 
  if (tmp == 0) 
#line 1664 
                goto _LOR;
  else {
    int tmp_0;
    
#line 1664 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_caps));
    
#line 1664 
    if (tmp_0 == 0) 
#line 1664 
                    goto _LOR;
    else {
      int tmp_2;
      bool tmp_1;
      
#line 1666 
      tmp_1 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vsi_id));
      
#line 1666 
      if (tmp_1) 
#line 1666 
                 tmp_2 = 0; else 
#line 1666 
                                 tmp_2 = 1;
      
#line 1666 
      if (tmp_2) {
        _LOR: {
                
#line 1667 
                aq_ret = I40E_ERR_PARAM;
                
#line 1668 
                goto error_param;
              }
      }
      else ;
    }
  }
  
#line 1671 
  i = 0;
  
#line 1671 
  goto ldv_61804;
  ldv_61803: 
#line 1672 
  ;
  
#line 1672 
  if ((unsigned int)vfl->vlan_id[i] > 4095U) {
    
#line 1673 
    aq_ret = I40E_ERR_PARAM;
    
#line 1674 
    dev_err((struct device const *)(& (pf->pdev)->dev),"invalid VF VLAN id %d\n",(int)vfl->vlan_id[i]);
    
#line 1676 
    goto error_param;
  }
  else ;
  
#line 1671 
  i += 1;
  ldv_61804: 
#line 1672 
  ;
  
#line 1671 
  if ((int)vfl->num_elements > i) 
#line 1673 
                                  goto ldv_61803; else 
#line 1676 
                                                       goto ldv_61805;
  ldv_61805: 
#line 1677 
  ;
  
#line 1679 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 1680 
  if ((unsigned int)vsi->info.pvid != 0U) {
    
#line 1681 
    aq_ret = I40E_ERR_PARAM;
    
#line 1682 
    goto error_param;
  }
  else ;
  
#line 1685 
  i40e_vlan_stripping_enable(vsi);
  
#line 1686 
  i = 0;
  
#line 1686 
  goto ldv_61808;
  ldv_61807: 
#line 1687 
  ;
  {
    
#line 1688 
    int ret = i40e_vsi_add_vlan(vsi,(short)((int)((short)vfl->vlan_id[i])));
    
#line 1689 
    if (ret != 0) 
#line 1690 
                  dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to add VF vlan filter %d, error %d\n",(int)vfl->vlan_id[i],ret); else ;
  }
  
#line 1686 
  i += 1;
  ldv_61808: 
#line 1687 
  ;
  
#line 1686 
  if ((int)vfl->num_elements > i) 
#line 1688 
                                  goto ldv_61807; else 
#line 1691 
                                                       goto ldv_61809;
  ldv_61809: 
#line 1692 
  ;
  error_param: 
#line 1695 
  ;
  
#line 1697 
  tmp_4 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_ADD_VLAN,aq_ret);
  
#line 1697 
  return tmp_4;
}


#line 1708  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_remove_vlan_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  int i;
  int tmp;
  int tmp_4;
  
#line 1710 
  struct i40e_virtchnl_vlan_filter_list *vfl = (struct i40e_virtchnl_vlan_filter_list *)msg;
  
#line 1712 
  struct i40e_pf *pf = vf->pf;
  
#line 1713 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  
#line 1714 
  u16 vsi_id = vfl->vsi_id;
  
#line 1715 
  i40e_status aq_ret = 0;
  
#line 1718 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1718 
  if (tmp == 0) 
#line 1718 
                goto _LOR;
  else {
    int tmp_0;
    
#line 1718 
    tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_caps));
    
#line 1718 
    if (tmp_0 == 0) 
#line 1718 
                    goto _LOR;
    else {
      int tmp_2;
      bool tmp_1;
      
#line 1720 
      tmp_1 = i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vsi_id));
      
#line 1720 
      if (tmp_1) 
#line 1720 
                 tmp_2 = 0; else 
#line 1720 
                                 tmp_2 = 1;
      
#line 1720 
      if (tmp_2) {
        _LOR: {
                
#line 1721 
                aq_ret = I40E_ERR_PARAM;
                
#line 1722 
                goto error_param;
              }
      }
      else ;
    }
  }
  
#line 1725 
  i = 0;
  
#line 1725 
  goto ldv_61823;
  ldv_61822: 
#line 1726 
  ;
  
#line 1726 
  if ((unsigned int)vfl->vlan_id[i] > 4095U) {
    
#line 1727 
    aq_ret = I40E_ERR_PARAM;
    
#line 1728 
    goto error_param;
  }
  else ;
  
#line 1725 
  i += 1;
  ldv_61823: 
#line 1726 
  ;
  
#line 1725 
  if ((int)vfl->num_elements > i) 
#line 1727 
                                  goto ldv_61822; else 
#line 1730 
                                                       goto ldv_61824;
  ldv_61824: 
#line 1731 
  ;
  
#line 1732 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 1733 
  if ((unsigned int)vsi->info.pvid != 0U) {
    
#line 1734 
    aq_ret = I40E_ERR_PARAM;
    
#line 1735 
    goto error_param;
  }
  else ;
  
#line 1738 
  i = 0;
  
#line 1738 
  goto ldv_61827;
  ldv_61826: 
#line 1739 
  ;
  {
    
#line 1739 
    int ret = i40e_vsi_kill_vlan(vsi,(short)((int)((short)vfl->vlan_id[i])));
    
#line 1740 
    if (ret != 0) 
#line 1741 
                  dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to delete VF vlan filter %d, error %d\n",(int)vfl->vlan_id[i],ret); else ;
  }
  
#line 1738 
  i += 1;
  ldv_61827: 
#line 1739 
  ;
  
#line 1738 
  if ((int)vfl->num_elements > i) 
#line 1740 
                                  goto ldv_61826; else 
#line 1743 
                                                       goto ldv_61828;
  ldv_61828: 
#line 1744 
  ;
  error_param: 
#line 1746 
  ;
  
#line 1748 
  tmp_4 = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)I40E_VIRTCHNL_OP_DEL_VLAN,aq_ret);
  
#line 1748 
  return tmp_4;
}


#line 1760  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_validate_vf_msg(struct i40e_vf *vf, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen)
{
  int __retres;
  int valid_len;
  int tmp;
  
#line 1763 
  bool err_msg_format = (_Bool)0;
  
#line 1767 
  tmp = constant_test_bit(3L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 1767 
  if (tmp != 0) {
    
#line 1768 
    __retres = -5;
    
#line 1768 
    goto return_label;
  }
  else ;
  
#line 1771 
  switch (v_opcode) {
    case (u32)1: 
#line 1772 
    ;
    
#line 1773 
    valid_len = 8;
    
#line 1774 
    goto ldv_61839;
    case (u32)2: 
#line 1775 
    ;
    case (u32)3: 
#line 1776 
    ;
    
#line 1777 
    valid_len = 0;
    
#line 1778 
    goto ldv_61839;
    case (u32)4: 
#line 1779 
    ;
    
#line 1780 
    valid_len = 24;
    
#line 1781 
    goto ldv_61839;
    case (u32)5: 
#line 1782 
    ;
    
#line 1783 
    valid_len = 40;
    
#line 1784 
    goto ldv_61839;
    case (u32)6: 
#line 1785 
    ;
    
#line 1786 
    valid_len = 72;
    
#line 1787 
    if ((int)msglen >= valid_len) {
      
#line 1788 
      struct i40e_virtchnl_vsi_queue_config_info *vqc = (struct i40e_virtchnl_vsi_queue_config_info *)msg;
      
#line 1790 
      valid_len = (int)((unsigned int)vqc->num_queue_pairs * 64U + (unsigned int)valid_len);
      
#line 1793 
      if ((unsigned int)vqc->num_queue_pairs == 0U) 
#line 1794 
                                                    err_msg_format = (_Bool)1; else ;
    }
    else ;
    
#line 1796 
    goto ldv_61839;
    case (u32)7: 
#line 1797 
    ;
    
#line 1798 
    valid_len = 14;
    
#line 1799 
    if ((int)msglen >= valid_len) {
      
#line 1800 
      struct i40e_virtchnl_irq_map_info *vimi = (struct i40e_virtchnl_irq_map_info *)msg;
      
#line 1802 
      valid_len = (int)((unsigned int)vimi->num_vectors * 12U + (unsigned int)valid_len);
      
#line 1804 
      if ((unsigned int)vimi->num_vectors == 0U) 
#line 1805 
                                                 err_msg_format = (_Bool)1; else ;
    }
    else ;
    
#line 1807 
    goto ldv_61839;
    case (u32)8: 
#line 1808 
    ;
    case (u32)9: 
#line 1809 
    ;
    
#line 1810 
    valid_len = 12;
    
#line 1811 
    goto ldv_61839;
    case (u32)10: 
#line 1812 
    ;
    case (u32)11: 
#line 1813 
    ;
    
#line 1814 
    valid_len = 12;
    
#line 1815 
    if ((int)msglen >= valid_len) {
      
#line 1816 
      struct i40e_virtchnl_ether_addr_list *veal = (struct i40e_virtchnl_ether_addr_list *)msg;
      
#line 1818 
      valid_len = (int)((unsigned int)veal->num_elements * 8U + (unsigned int)valid_len);
      
#line 1820 
      if ((unsigned int)veal->num_elements == 0U) 
#line 1821 
                                                  err_msg_format = (_Bool)1; else ;
    }
    else ;
    
#line 1823 
    goto ldv_61839;
    case (u32)12: 
#line 1824 
    ;
    case (u32)13: 
#line 1825 
    ;
    
#line 1826 
    valid_len = 6;
    
#line 1827 
    if ((int)msglen >= valid_len) {
      
#line 1828 
      struct i40e_virtchnl_vlan_filter_list *vfl = (struct i40e_virtchnl_vlan_filter_list *)msg;
      
#line 1830 
      valid_len = (int)((unsigned int)vfl->num_elements * 2U + (unsigned int)valid_len);
      
#line 1831 
      if ((unsigned int)vfl->num_elements == 0U) 
#line 1832 
                                                 err_msg_format = (_Bool)1; else ;
    }
    else ;
    
#line 1834 
    goto ldv_61839;
    case (u32)14: 
#line 1835 
    ;
    
#line 1836 
    valid_len = 4;
    
#line 1837 
    goto ldv_61839;
    case (u32)15: 
#line 1838 
    ;
    
#line 1839 
    valid_len = 12;
    
#line 1840 
    goto ldv_61839;
    case (u32)17: 
#line 1842 
    ;
    case (u32)0: 
#line 1843 
    ;
    default: 
#line 1844 
    ;
    
#line 1845 
    __retres = -1;
    
#line 1845 
    goto return_label;
  }
  ldv_61839: 
#line 1849 
  ;
  
#line 1849 
  if ((int)msglen != valid_len || (int)err_msg_format != 0) {
    
#line 1850 
    i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)v_opcode,(enum i40e_status_code)I40E_ERR_PARAM);
    
#line 1851 
    __retres = -22;
    
#line 1851 
    goto return_label;
  }
  else {
    
#line 1853 
    __retres = 0;
    
#line 1853 
    goto return_label;
  }
  return_label: 
#line 1849 
                return __retres;
}


#line 1868  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_vc_process_vf_msg(struct i40e_pf *pf, u16 vf_id, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen)
{
  int __retres;
  struct i40e_vf *vf;
  int ret;
  
#line 1871 
  struct i40e_hw *hw = & pf->hw;
  
#line 1872 
  unsigned int local_vf_id = (unsigned int)vf_id - hw->func_caps.vf_base_id;
  
#line 1876 
  pf->vf_aq_requests += 1U;
  
#line 1877 
  if ((unsigned int)pf->num_alloc_vfs <= local_vf_id) {
    
#line 1878 
    __retres = -22;
    
#line 1878 
    goto return_label;
  }
  else ;
  
#line 1879 
  vf = pf->vf + local_vf_id;
  
#line 1881 
  ret = i40e_vc_validate_vf_msg(vf,v_opcode,v_retval,msg,(unsigned short)((int)msglen));
  
#line 1883 
  if (ret != 0) {
    
#line 1884 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid message from VF %d, opcode %d, len %d\n",local_vf_id,v_opcode,(int)msglen);
    
#line 1886 
    __retres = ret;
    
#line 1886 
    goto return_label;
  }
  else ;
  
#line 1889 
  switch (v_opcode) {
    case (u32)1: 
#line 1890 
    ;
    
#line 1891 
    ret = i40e_vc_get_version_msg(vf);
    
#line 1892 
    goto ldv_61874;
    case (u32)3: 
#line 1893 
    ;
    
#line 1894 
    ret = i40e_vc_get_vf_resources_msg(vf);
    
#line 1895 
    goto ldv_61874;
    case (u32)2: 
#line 1896 
    ;
    
#line 1897 
    i40e_vc_reset_vf_msg(vf);
    
#line 1898 
    ret = 0;
    
#line 1899 
    goto ldv_61874;
    case (u32)14: 
#line 1900 
    ;
    
#line 1901 
    ret = i40e_vc_config_promiscuous_mode_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1902 
    goto ldv_61874;
    case (u32)6: 
#line 1903 
    ;
    
#line 1904 
    ret = i40e_vc_config_queues_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1905 
    goto ldv_61874;
    case (u32)7: 
#line 1906 
    ;
    
#line 1907 
    ret = i40e_vc_config_irq_map_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1908 
    goto ldv_61874;
    case (u32)8: 
#line 1909 
    ;
    
#line 1910 
    ret = i40e_vc_enable_queues_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1911 
    i40e_vc_notify_vf_link_state(vf);
    
#line 1912 
    goto ldv_61874;
    case (u32)9: 
#line 1913 
    ;
    
#line 1914 
    ret = i40e_vc_disable_queues_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1915 
    goto ldv_61874;
    case (u32)10: 
#line 1916 
    ;
    
#line 1917 
    ret = i40e_vc_add_mac_addr_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1918 
    goto ldv_61874;
    case (u32)11: 
#line 1919 
    ;
    
#line 1920 
    ret = i40e_vc_del_mac_addr_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1921 
    goto ldv_61874;
    case (u32)12: 
#line 1922 
    ;
    
#line 1923 
    ret = i40e_vc_add_vlan_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1924 
    goto ldv_61874;
    case (u32)13: 
#line 1925 
    ;
    
#line 1926 
    ret = i40e_vc_remove_vlan_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1927 
    goto ldv_61874;
    case (u32)15: 
#line 1928 
    ;
    
#line 1929 
    ret = i40e_vc_get_stats_msg(vf,msg,(unsigned short)((int)msglen));
    
#line 1930 
    goto ldv_61874;
    case (u32)0: 
#line 1931 
    ;
    default: 
#line 1932 
    ;
    
#line 1933 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Unsupported opcode %d from VF %d\n",v_opcode,local_vf_id);
    
#line 1935 
    ret = i40e_vc_send_resp_to_vf(vf,(enum i40e_virtchnl_ops)v_opcode,(enum i40e_status_code)I40E_ERR_NOT_IMPLEMENTED);
    
#line 1937 
    goto ldv_61874;
  }
  ldv_61874: 
#line 1940 
  ;
  
#line 1940 
  __retres = ret;
  return_label: 
#line 1940 
                return __retres;
}


#line 1950  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_vc_process_vflr_event(struct i40e_pf *pf)
{
  int __retres;
  u32 reg;
  u32 reg_idx;
  u32 bit_idx;
  u32 vf_id;
  struct i40e_vf *vf;
  int tmp;
  
#line 1953 
  struct i40e_hw *hw = & pf->hw;
  
#line 1956 
  tmp = constant_test_bit(8L,(unsigned long const volatile *)(& pf->state));
  
#line 1956 
  if (tmp == 0) {
    
#line 1957 
    __retres = 0;
    
#line 1957 
    goto return_label;
  }
  else ;
  
#line 1960 
  reg = readl((void const volatile *)(hw->hw_addr + 231424U));
  
#line 1961 
  reg |= 536870912U;
  
#line 1962 
  writel(reg,(void volatile *)(hw->hw_addr + 231424U));
  
#line 1963 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 1965 
  clear_bit(8L,(unsigned long volatile *)(& pf->state));
  
#line 1966 
  vf_id = 0U;
  
#line 1966 
  goto ldv_61899;
  ldv_61898: 
#line 1967 
  ;
  
#line 1967 
  reg_idx = (hw->func_caps.vf_base_id + vf_id) / 32U;
  
#line 1968 
  bit_idx = (hw->func_caps.vf_base_id + vf_id) & 31U;
  
#line 1970 
  vf = pf->vf + vf_id;
  
#line 1971 
  reg = readl((void const volatile *)(hw->hw_addr + (reg_idx + 149888U) * 4U));
  
#line 1972 
  if (((unsigned int)(1 << bit_idx) & reg) != 0U) {
    int tmp_0;
    
#line 1974 
    writel((unsigned int)(1 << bit_idx),(void volatile *)(hw->hw_addr + (reg_idx + 149888U) * 4U));
    
#line 1976 
    tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
    
#line 1976 
    if (tmp_0 == 0) 
#line 1977 
                    i40e_reset_vf(vf,(_Bool)1); else ;
  }
  else ;
  
#line 1966 
  vf_id += 1U;
  ldv_61899: 
#line 1967 
  ;
  
#line 1966 
  if ((unsigned int)pf->num_alloc_vfs > vf_id) 
#line 1968 
                                               goto ldv_61898; else 
#line 1971 
                                                                    goto ldv_61900;
  ldv_61900: 
#line 1972 
  ;
  
#line 1981 
  __retres = 0;
  return_label: 
#line 1981 
                return __retres;
}


#line 1992  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac)
{
  struct i40e_mac_filter *f;
  struct i40e_vf *vf;
  int tmp_0;
  int tmp_2;
  bool tmp_1;
  struct i40e_mac_filter *tmp_3;
  struct i40e_mac_filter *tmp_4;
  int tmp_5;
  
#line 1994 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1995 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1996 
  struct i40e_pf *pf = vsi->back;
  
#line 1999 
  int ret = 0;
  
#line 2002 
  if (pf->num_alloc_vfs <= vf_id) {
    
#line 2003 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid VF Identifier %d\n",vf_id);
    
#line 2005 
    ret = -22;
    
#line 2006 
    goto error_param;
  }
  else ;
  
#line 2009 
  vf = pf->vf + vf_id;
  
#line 2010 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 2011 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 2011 
  if (tmp_0 == 0) {
    
#line 2012 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Uninitialized VF %d\n",vf_id);
    
#line 2014 
    ret = -22;
    
#line 2015 
    goto error_param;
  }
  else ;
  
#line 2018 
  tmp_1 = is_valid_ether_addr((u8 const *)mac);
  
#line 2018 
  if (tmp_1) 
#line 2018 
             tmp_2 = 0; else 
#line 2018 
                             tmp_2 = 1;
  
#line 2018 
  if (tmp_2) {
    
#line 2019 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid VF ethernet address\n");
    
#line 2021 
    ret = -22;
    
#line 2022 
    goto error_param;
  }
  else ;
  
#line 2026 
  i40e_del_filter(vsi,(u8 *)(& vf->default_lan_addr.addr),(short)((int)((short)vf->port_vlan_id)),(_Bool)1,(_Bool)0);
  {
    
#line 2032 
    struct list_head const *__mptr = (struct list_head const *)vsi->mac_filter_list.next;
    
#line 2032 
    tmp_3 = (struct i40e_mac_filter *)__mptr;
  }
  
#line 2032 
  f = tmp_3;
  
#line 2032 
  goto ldv_61918;
  ldv_61917: 
#line 2033 
  ;
  
#line 2033 
  i40e_del_filter(vsi,(u8 *)(& f->macaddr),(short)((int)f->vlan),(_Bool)1,(_Bool)0);
  {
    
#line 2032 
    struct list_head const *__mptr_0 = (struct list_head const *)f->list.next;
    
#line 2032 
    tmp_4 = (struct i40e_mac_filter *)__mptr_0;
  }
  
#line 2032 
  f = tmp_4;
  ldv_61918: 
#line 2034 
  ;
  
#line 2032 
  if (& f->list != & vsi->mac_filter_list) 
#line 2034 
                                           goto ldv_61917; else 
#line 2037 
                                                                goto ldv_61919;
  ldv_61919: 
#line 2038 
  ;
  
#line 2035 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"Setting MAC %pM on VF %d\n",mac,vf_id);
  
#line 2037 
  tmp_5 = i40e_sync_vsi_filters(vsi);
  
#line 2037 
  if (tmp_5 != 0) {
    
#line 2038 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to program ucast filters\n");
    
#line 2039 
    ret = -5;
    
#line 2040 
    goto error_param;
  }
  else ;
  
#line 2042 
  ether_addr_copy((u8 *)(& vf->default_lan_addr.addr),(u8 const *)mac);
  
#line 2043 
  vf->pf_set_mac = (_Bool)1;
  
#line 2045 
  i40e_vc_disable_vf(pf,vf);
  
#line 2046 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"Reload the VF driver to make this change effective.\n");
  error_param: 
#line 2048 
  ;
  
#line 2049 
  return ret;
}


#line 2061  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos)
{
  struct i40e_vsi *vsi;
  struct i40e_vf *vf;
  int tmp_0;
  
#line 2064 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2065 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 2068 
  int ret = 0;
  
#line 2071 
  if (pf->num_alloc_vfs <= vf_id) {
    
#line 2072 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid VF Identifier %d\n",vf_id);
    
#line 2073 
    ret = -22;
    
#line 2074 
    goto error_pvid;
  }
  else ;
  
#line 2077 
  if ((unsigned int)vlan_id > 4095U || (unsigned int)qos > 7U) {
    
#line 2078 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid VF Parameters\n");
    
#line 2079 
    ret = -22;
    
#line 2080 
    goto error_pvid;
  }
  else ;
  
#line 2083 
  vf = pf->vf + vf_id;
  
#line 2084 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 2085 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 2085 
  if (tmp_0 == 0) {
    
#line 2086 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Uninitialized VF %d\n",vf_id);
    
#line 2087 
    ret = -22;
    
#line 2088 
    goto error_pvid;
  }
  else ;
  
#line 2091 
  if ((unsigned int)vsi->info.pvid == 0U) {
    bool tmp_1;
    
#line 2091 
    tmp_1 = i40e_is_vsi_in_vlan(vsi);
    
#line 2091 
    if ((int)tmp_1 != 0) {
      
#line 2092 
      dev_err((struct device const *)(& (pf->pdev)->dev),"VF %d has already configured VLAN filters and the administrator is requesting a port VLAN override.\nPlease unload and reload the VF driver for this change to take effect.\n",vf_id);
      
#line 2099 
      i40e_vc_disable_vf(pf,vf);
    }
    else ;
  }
  else ;
  
#line 2110 
  if ((((unsigned int)vlan_id == 0U && (unsigned int)qos == 0U) || ((int)vlan_id | (int)qos) != (int)vsi->info.pvid) && (unsigned int)vsi->info.pvid != 0U) 
    
#line 2113 
    ret = i40e_vsi_add_vlan(vsi,(short)(-1)); else ;
  
#line 2115 
  if ((unsigned int)vsi->info.pvid != 0U) {
    
#line 2117 
    ret = i40e_vsi_kill_vlan(vsi,(short)((int)((short)vsi->info.pvid) & 4095));
    
#line 2119 
    if (ret != 0) 
#line 2120 
                  _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"remove VLAN failed, ret=%d, aq_err=%d\n",ret,(unsigned int)pf->hw.aq.asq_last_status); else ;
  }
  else ;
  
#line 2125 
  if ((unsigned int)vlan_id != 0U || (unsigned int)qos != 0U) {
    i40e_status tmp_2;
    
#line 2126 
    tmp_2 = i40e_vsi_add_pvid(vsi,(unsigned short)((int)((unsigned short)(((int)qos << 12) | (int)vlan_id))));
    
#line 2126 
    ret = (int)tmp_2;
  }
  else 
#line 2129 
       i40e_vsi_remove_pvid(vsi);
  
#line 2131 
  if ((unsigned int)vlan_id != 0U) {
    
#line 2132 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Setting VLAN %d, QOS 0x%x on VF %d\n",(int)vlan_id,(int)qos,vf_id);
    
#line 2136 
    ret = i40e_vsi_add_vlan(vsi,(short)((int)((short)vlan_id)));
    
#line 2137 
    if (ret != 0) {
      
#line 2138 
      _dev_info((struct device const *)(& ((vsi->back)->pdev)->dev),"add VF VLAN failed, ret=%d aq_err=%d\n",ret,(unsigned int)(vsi->back)->hw.aq.asq_last_status);
      
#line 2141 
      goto error_pvid;
    }
    else ;
    
#line 2146 
    i40e_vsi_kill_vlan(vsi,(short)(-1));
  }
  else ;
  
#line 2149 
  if (ret != 0) {
    
#line 2150 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to update VF vsi context\n");
    
#line 2151 
    goto error_pvid;
  }
  else ;
  
#line 2156 
  vf->port_vlan_id = vsi->info.pvid;
  
#line 2157 
  ret = 0;
  error_pvid: 
#line 2159 
  ;
  
#line 2160 
  return ret;
}


#line 2173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate, int max_tx_rate)
{
  int __retres;
  struct i40e_vsi *vsi;
  struct i40e_vf *vf;
  int tmp_0;
  i40e_status tmp_1;
  
#line 2176 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2177 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 2180 
  int speed = 0;
  
#line 2181 
  int ret = 0;
  
#line 2184 
  if (pf->num_alloc_vfs <= vf_id) {
    
#line 2185 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid VF Identifier %d.\n",vf_id);
    
#line 2186 
    ret = -22;
    
#line 2187 
    goto error;
  }
  else ;
  
#line 2190 
  if (min_tx_rate != 0) {
    
#line 2191 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid min tx rate (%d) (greater than 0) specified for VF %d.\n",min_tx_rate,vf_id);
    
#line 2193 
    __retres = -22;
    
#line 2193 
    goto return_label;
  }
  else ;
  
#line 2196 
  vf = pf->vf + vf_id;
  
#line 2197 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 2198 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 2198 
  if (tmp_0 == 0) {
    
#line 2199 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Uninitialized VF %d.\n",vf_id);
    
#line 2200 
    ret = -22;
    
#line 2201 
    goto error;
  }
  else ;
  
#line 2204 
  switch ((unsigned int)pf->hw.phy.link_info.link_speed) {
    case (unsigned int)16: 
#line 2205 
    ;
    
#line 2206 
    speed = 40000;
    
#line 2207 
    goto ldv_61946;
    case (unsigned int)8: 
#line 2208 
    ;
    
#line 2209 
    speed = 10000;
    
#line 2210 
    goto ldv_61946;
    case (unsigned int)4: 
#line 2211 
    ;
    
#line 2212 
    speed = 1000;
    
#line 2213 
    goto ldv_61946;
    default: 
#line 2214 
    ;
    
#line 2215 
    goto ldv_61946;
  }
  ldv_61946: 
#line 2218 
  ;
  
#line 2218 
  if (max_tx_rate > speed) {
    
#line 2219 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid max tx rate %d specified for VF %d.",max_tx_rate,(int)vf->vf_id);
    
#line 2221 
    ret = -22;
    
#line 2222 
    goto error;
  }
  else ;
  
#line 2225 
  if ((unsigned int)max_tx_rate + 4294967295U <= 48U) {
    
#line 2226 
    dev_warn((struct device const *)(& (pf->pdev)->dev),"Setting max Tx rate to minimum usable value of 50Mbps.\n");
    
#line 2227 
    max_tx_rate = 50;
  }
  else ;
  
#line 2231 
  tmp_1 = i40e_aq_config_vsi_bw_limit(& pf->hw,(unsigned short)((int)vsi->seid),(unsigned short)((int)((unsigned short)(max_tx_rate / 50))),(unsigned char)4,(struct i40e_asq_cmd_details *)0);
  
#line 2231 
  ret = (int)tmp_1;
  
#line 2234 
  if (ret != 0) {
    
#line 2235 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Unable to set max tx rate, error code %d.\n",ret);
    
#line 2237 
    ret = -5;
    
#line 2238 
    goto error;
  }
  else ;
  
#line 2240 
  vf->tx_rate = (unsigned int)max_tx_rate;
  error: 
#line 2241 
  ;
  
#line 2242 
  __retres = ret;
  return_label: 
#line 2242 
                return __retres;
}


#line 2253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_get_vf_config(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi)
{
  struct i40e_vf *vf;
  int tmp_0;
  
#line 2256 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2257 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2258 
  struct i40e_pf *pf = vsi->back;
  
#line 2260 
  int ret = 0;
  
#line 2263 
  if (pf->num_alloc_vfs <= vf_id) {
    
#line 2264 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid VF Identifier %d\n",vf_id);
    
#line 2265 
    ret = -22;
    
#line 2266 
    goto error_param;
  }
  else ;
  
#line 2269 
  vf = pf->vf + vf_id;
  
#line 2271 
  vsi = *(pf->vsi + (int)vf->lan_vsi_idx);
  
#line 2272 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& vf->vf_states));
  
#line 2272 
  if (tmp_0 == 0) {
    
#line 2273 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Uninitialized VF %d\n",vf_id);
    
#line 2274 
    ret = -22;
    
#line 2275 
    goto error_param;
  }
  else ;
  
#line 2278 
  ivi->vf = (unsigned int)vf_id;
  
#line 2280 
  memcpy((void *)(& ivi->mac),(void const *)(& vf->default_lan_addr.addr),6UL);
  
#line 2282 
  ivi->max_tx_rate = vf->tx_rate;
  
#line 2283 
  ivi->min_tx_rate = 0U;
  
#line 2284 
  ivi->vlan = (unsigned int)vsi->info.pvid & 4095U;
  
#line 2285 
  ivi->qos = (unsigned int)((int)vsi->info.pvid >> 12) & 7U;
  
#line 2287 
  if (! vf->link_forced) 
#line 2288 
                         ivi->linkstate = 0U;
  else 
    
#line 2289 
    if ((int)vf->link_up == 1) 
#line 2290 
                               ivi->linkstate = 1U; else 
#line 2292 
                                                         ivi->linkstate = 2U;
  
#line 2293 
  ivi->spoofchk = (unsigned int)vf->spoofchk;
  
#line 2294 
  ret = 0;
  error_param: 
#line 2296 
  ;
  
#line 2297 
  return ret;
}


#line 2308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_link_state(struct net_device *netdev, int vf_id, int link)
{
  struct i40e_virtchnl_pf_event pfe;
  struct i40e_vf *vf;
  int abs_vf_id;
  
#line 2310 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2311 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 2313 
  struct i40e_hw *hw = & pf->hw;
  
#line 2316 
  int ret = 0;
  
#line 2319 
  if (pf->num_alloc_vfs <= vf_id) {
    
#line 2320 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid VF Identifier %d\n",vf_id);
    
#line 2321 
    ret = -22;
    
#line 2322 
    goto error_out;
  }
  else ;
  
#line 2325 
  vf = pf->vf + vf_id;
  
#line 2326 
  abs_vf_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
  
#line 2328 
  pfe.event = I40E_VIRTCHNL_EVENT_LINK_CHANGE;
  
#line 2329 
  pfe.severity = 0;
  
#line 2331 
  switch (link) {
    case 0: 
#line 2332 
    ;
    
#line 2333 
    vf->link_forced = (_Bool)0;
    
#line 2334 
    pfe.event_data.link_event.link_status = (_Bool)(((int)pf->hw.phy.link_info.link_info & 1) != 0);
    
#line 2336 
    pfe.event_data.link_event.link_speed = pf->hw.phy.link_info.link_speed;
    
#line 2338 
    goto ldv_61975;
    case 1: 
#line 2339 
    ;
    
#line 2340 
    vf->link_forced = (_Bool)1;
    
#line 2341 
    vf->link_up = (_Bool)1;
    
#line 2342 
    pfe.event_data.link_event.link_status = (_Bool)1;
    
#line 2343 
    pfe.event_data.link_event.link_speed = I40E_LINK_SPEED_40GB;
    
#line 2344 
    goto ldv_61975;
    case 2: 
#line 2345 
    ;
    
#line 2346 
    vf->link_forced = (_Bool)1;
    
#line 2347 
    vf->link_up = (_Bool)0;
    
#line 2348 
    pfe.event_data.link_event.link_status = (_Bool)0;
    
#line 2349 
    pfe.event_data.link_event.link_speed = I40E_LINK_SPEED_UNKNOWN;
    
#line 2350 
    goto ldv_61975;
    default: 
#line 2351 
    ;
    
#line 2352 
    ret = -22;
    
#line 2353 
    goto error_out;
  }
  ldv_61975: 
#line 2356 
  ;
  
#line 2356 
  i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)abs_vf_id)),17U,0U,(u8 *)(& pfe),(unsigned short)16,(struct i40e_asq_cmd_details *)0);
  error_out: 
#line 2359 
  ;
  
#line 2360 
  return ret;
}


#line 2371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool enable)
{
  struct i40e_vsi_context ctxt;
  struct i40e_vf *vf;
  i40e_status tmp_0;
  
#line 2373 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2374 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2375 
  struct i40e_pf *pf = vsi->back;
  
#line 2377 
  struct i40e_hw *hw = & pf->hw;
  
#line 2379 
  int ret = 0;
  
#line 2382 
  if (pf->num_alloc_vfs <= vf_id) {
    
#line 2383 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Invalid VF Identifier %d\n",vf_id);
    
#line 2384 
    ret = -22;
    
#line 2385 
    goto out;
  }
  else ;
  
#line 2388 
  vf = pf->vf + vf_id;
  
#line 2390 
  if ((int)vf->spoofchk == (int)enable) 
#line 2391 
                                        goto out; else ;
  
#line 2393 
  vf->spoofchk = enable;
  
#line 2394 
  memset((void *)(& ctxt),0,144UL);
  
#line 2395 
  ctxt.seid = (*(pf->vsi + (int)vf->lan_vsi_idx))->seid;
  
#line 2396 
  ctxt.pf_num = pf->hw.pf_id;
  
#line 2397 
  ctxt.info.valid_sections = (unsigned short)2U;
  
#line 2398 
  if ((int)enable != 0) 
#line 2399 
                        ctxt.info.sec_flags = (unsigned char)((unsigned int)ctxt.info.sec_flags | 6U); else ;
  
#line 2401 
  tmp_0 = i40e_aq_update_vsi_params(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  
#line 2401 
  ret = (int)tmp_0;
  
#line 2402 
  if (ret != 0) {
    
#line 2403 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Error %d updating VSI parameters\n",ret);
    
#line 2405 
    ret = -5;
  }
  else ;
  out: 
#line 2407 
  ;
  
#line 2408 
  return ret;
}


#line 415  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_virtchnl_pf.c.aux"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 418 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 418 
  return tmp;
}


#line 422  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_virtchnl_pf.c.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 425 
  tmp = ldv_kzalloc(size,flags);
  
#line 425 
  return tmp;
}

unsigned int __builtin_bswap32(unsigned int);


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val)
{
  __u32 tmp;
  
#line 60 
  tmp = __builtin_bswap32(val);
  
#line 60 
  return tmp;
}


#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_HLIST_NODE(struct hlist_node *h)
{
  
#line 600 
  h->next = (struct hlist_node *)0;
  
#line 601 
  h->pprev = (struct hlist_node **)0;
  
#line 602 
  return;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
  
#line 640 
  struct hlist_node *first = h->first;
  
#line 641 
  n->next = first;
  
#line 642 
  if (first != (struct hlist_node *)0) 
#line 643 
                                       first->pprev = & n->next; else ;
  
#line 644 
  h->first = n;
  
#line 645 
  n->pprev = & h->first;
  
#line 646 
  return;
}


#line 658  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void hlist_add_behind(struct hlist_node *n, struct hlist_node *prev)
{
  
#line 661 
  n->next = prev->next;
  
#line 662 
  prev->next = n;
  
#line 663 
  n->pprev = & prev->next;
  
#line 665 
  if (n->next != (struct hlist_node *)0) 
#line 666 
                                         (n->next)->pprev = & n->next; else ;
  
#line 667 
  return;
}


#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kcalloc_1(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc_2(size_t size, gfp_t flags);


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep, __u32 speed)
{
  
#line 117 
  ep->speed = (unsigned short)speed;
  
#line 118 
  ep->speed_hi = (unsigned short)(speed >> 16);
  
#line 119 
  return;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
u32 ethtool_op_get_link(struct net_device *);


#line 86 
int ethtool_op_get_ts_info(struct net_device *, struct ethtool_ts_info *);


#line 2182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
int dev_open(struct net_device *);


#line 2183 
int dev_close(struct net_device *);


#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ptp_clock_kernel.h"
int ptp_clock_index(struct ptp_clock *);


#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
u32 i40e_led_get(struct i40e_hw *hw);


#line 63 
void i40e_led_set(struct i40e_hw *hw, u32 mode, bool blink);


#line 86 
enum i40e_status_code i40e_aq_set_phy_config(struct i40e_hw *hw, struct i40e_aq_set_phy_config *config, struct i40e_asq_cmd_details *cmd_details);


#line 269 
i40e_status i40e_read_nvm_word(struct i40e_hw *hw, u16 offset, u16 *data);


#line 276 
i40e_status i40e_nvmupd_command(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno);


#line 588  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static struct i40e_pf *i40e_netdev_to_pf(struct net_device *netdev)
{
  struct i40e_pf *__retres;
  
#line 590 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 591 
  struct i40e_vsi *vsi = np->vsi;
  
#line 593 
  __retres = vsi->back;
  
#line 593 
  return __retres;
}


#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static int i40e_get_fd_cnt_all(struct i40e_pf *pf)
{
  int __retres;
  
#line 623 
  __retres = (int)pf->hw.fdir_shared_filter_count + (int)pf->fdir_pf_filter_count;
  
#line 623 
  return __retres;
}


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_diag.h"
struct i40e_diag_reg_test_info i40e_reg_list[12U];


#line 48 
i40e_status i40e_diag_reg_test(struct i40e_hw *hw);


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats const i40e_gstrings_net_stats[11U] = {{.stat_string = {(char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 0}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 8}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 16}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 24}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 32}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 40}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 48}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 56}, {.stat_string = {(char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 72}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 80}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 96}};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats const i40e_gstrings_veb_stats[12U] = {{.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 80}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 128}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 88}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 136}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 96}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 144}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 104}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 152}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'d', (char)'i', (char)'s', (char)'c', (char)'a', (char)'r', (char)'d', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 112}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'i', (char)'s', (char)'c', (char)'a', (char)'r', (char)'d', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 160}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 168}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'k', (char)'n', (char)'o', (char)'w', (char)'n', (char)'_', (char)'p', (char)'r', (char)'o', (char)'t', (char)'o', (char)'c', (char)'o', (char)'l', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 120}};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats const i40e_gstrings_misc_stats[7U] = {{.stat_string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 936}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 984}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 944}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 992}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 952}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1000}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'k', (char)'n', (char)'o', (char)'w', (char)'n', (char)'_', (char)'p', (char)'r', (char)'o', (char)'t', (char)'o', (char)'c', (char)'o', (char)'l', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 968}};

#line 92 
static int i40e_add_fdir_ethtool(struct i40e_vsi *vsi, struct ethtool_rxnfc *cmd);


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats i40e_gstrings_stats[50U] = {{.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133120}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133168}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133128}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133176}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133136}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133184}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133144}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133192}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133208}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133152}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'_', (char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'d', (char)'o', (char)'w', (char)'n', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133216}, {.stat_string = {(char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133224}, {.stat_string = {(char)'i', (char)'l', (char)'l', (char)'e', (char)'g', (char)'a', (char)'l', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133232}, {.stat_string = {(char)'m', (char)'a', (char)'c', (char)'_', (char)'l', (char)'o', (char)'c', (char)'a', (char)'l', (char)'_', (char)'f', (char)'a', (char)'u', (char)'l', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133248}, {.stat_string = {(char)'m', (char)'a', (char)'c', (char)'_', (char)'r', (char)'e', (char)'m', (char)'o', (char)'t', (char)'e', (char)'_', (char)'f', (char)'a', (char)'u', (char)'l', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133256}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'o', (char)'u', (char)'t', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 134544}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'s', (char)'u', (char)'m', (char)'_', (char)'b', (char)'a', (char)'d', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 134564}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133264}, {.stat_string = {(char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'r', (char)'x', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133272}, {.stat_string = {(char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'r', (char)'x', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133280}, {.stat_string = {(char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'t', (char)'x', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133416}, {.stat_string = {(char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'t', (char)'x', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133424}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'6', (char)'4', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133624}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'2', (char)'7', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133632}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'2', (char)'5', (char)'5', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133640}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'5', (char)'1', (char)'1', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133648}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'0', (char)'2', (char)'3', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133656}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'5', (char)'2', (char)'2', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133664}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'b', (char)'i', (char)'g', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133672}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'6', (char)'4', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133712}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'2', (char)'7', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133720}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'2', (char)'5', (char)'5', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133728}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'5', (char)'1', (char)'1', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133736}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'0', (char)'2', (char)'3', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133744}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'5', (char)'2', (char)'2', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133752}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'b', (char)'i', (char)'g', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133760}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'s', (char)'i', (char)'z', (char)'e', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133680}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'r', (char)'a', (char)'g', (char)'m', (char)'e', (char)'n', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133688}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'s', (char)'i', (char)'z', (char)'e', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133696}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'j', (char)'a', (char)'b', (char)'b', (char)'e', (char)'r', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133704}, {.stat_string = {(char)'V', (char)'F', (char)'_', (char)'a', (char)'d', (char)'m', (char)'i', (char)'n', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'_', (char)'r', (char)'e', (char)'q', (char)'u', (char)'e', (char)'s', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 134948}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'h', (char)'w', (char)'t', (char)'s', (char)'t', (char)'a', (char)'m', (char)'p', (char)'_', (char)'c', (char)'l', (char)'e', (char)'a', (char)'r', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 135220}, {.stat_string = {(char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'f', (char)'l', (char)'u', (char)'s', (char)'h', (char)'_', (char)'c', (char)'n', (char)'t', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 1680}, {.stat_string = {(char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'a', (char)'t', (char)'r', (char)'_', (char)'m', (char)'a', (char)'t', (char)'c', (char)'h', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133784}, {.stat_string = {(char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'a', (char)'t', (char)'r', (char)'_', (char)'t', (char)'u', (char)'n', (char)'n', (char)'e', (char)'l', (char)'_', (char)'m', (char)'a', (char)'t', (char)'c', (char)'h', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133800}, {.stat_string = {(char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'s', (char)'b', (char)'_', (char)'m', (char)'a', (char)'t', (char)'c', (char)'h', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133792}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'l', (char)'p', (char)'i', (char)'_', (char)'s', (char)'t', (char)'a', (char)'t', (char)'u', (char)'s', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 133808}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'p', (char)'i', (char)'_', (char)'s', (char)'t', (char)'a', (char)'t', (char)'u', (char)'s', (char)'\000'}, .sizeof_stat = 4, .stat_offset = 133812}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'l', (char)'p', (char)'i', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133816}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'p', (char)'i', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 133824}};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats const i40e_gstrings_fcoe_stats[8U] = {{.stat_string = {(char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'b', (char)'a', (char)'d', (char)'_', (char)'f', (char)'c', (char)'c', (char)'r', (char)'c', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1160}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1136}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1120}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'d', (char)'w', (char)'o', (char)'r', (char)'d', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1128}, {.stat_string = {(char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'d', (char)'d', (char)'p', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1176}, {.stat_string = {(char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'l', (char)'a', (char)'s', (char)'t', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1168}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1144}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'c', (char)'o', (char)'e', (char)'_', (char)'d', (char)'w', (char)'o', (char)'r', (char)'d', (char)'s', (char)'\000'}, .sizeof_stat = 8, .stat_offset = 1152}};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static char const i40e_gstrings_test[5U][32U] = {{(char)'R', (char)'e', (char)'g', (char)'i', (char)'s', (char)'t', (char)'e', (char)'r', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}, {(char)'E', (char)'e', (char)'p', (char)'r', (char)'o', (char)'m', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}, {(char)'I', (char)'n', (char)'t', (char)'e', (char)'r', (char)'r', (char)'u', (char)'p', (char)'t', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}, {(char)'L', (char)'o', (char)'o', (char)'p', (char)'b', (char)'a', (char)'c', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}, {(char)'L', (char)'i', (char)'n', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'n', (char)'/', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static char const i40e_priv_flags_strings[1U][32U] = {{(char)'N', (char)'P', (char)'A', (char)'R', (char)'\000'}};

#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_partition_setting_complaint(struct i40e_pf *pf)
{
  
#line 234 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"The link settings are allowed to be changed only from the first partition of a given port. Please switch to the first partition in order to change the setting.\n");
  
#line 235 
  return;
}


#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_settings_link_up(struct i40e_hw *hw, struct ethtool_cmd *ecmd, struct net_device *netdev)
{
  
#line 249 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  
#line 250 
  u32 link_speed = hw_link_info->link_speed;
  
#line 253 
  switch ((unsigned int)hw_link_info->phy_type) {
    case (unsigned int)24: 
#line 254 
    ;
    case (unsigned int)10: 
#line 255 
    ;
    
#line 256 
    ecmd->supported = 16777280U;
    
#line 258 
    ecmd->advertising = 16777280U;
    
#line 260 
    goto ldv_61423;
    case (unsigned int)8: 
#line 261 
    ;
    case (unsigned int)9: 
#line 262 
    ;
    case (unsigned int)13: 
#line 263 
    ;
    
#line 264 
    ecmd->supported = 16777216U;
    
#line 265 
    goto ldv_61423;
    case (unsigned int)4: 
#line 266 
    ;
    
#line 267 
    ecmd->supported = 8388672U;
    
#line 269 
    ecmd->advertising = 8388672U;
    
#line 271 
    goto ldv_61423;
    case (unsigned int)25: 
#line 272 
    ;
    
#line 273 
    ecmd->supported = 33554432U;
    
#line 274 
    goto ldv_61423;
    case (unsigned int)26: 
#line 275 
    ;
    
#line 276 
    ecmd->supported = 67108864U;
    
#line 277 
    goto ldv_61423;
    case (unsigned int)30: 
#line 278 
    ;
    
#line 279 
    ecmd->supported = 4194368U;
    
#line 281 
    ecmd->advertising = 4194368U;
    
#line 283 
    goto ldv_61423;
    case (unsigned int)2: 
#line 284 
    ;
    
#line 285 
    ecmd->supported = 262208U;
    
#line 287 
    ecmd->advertising = 262208U;
    
#line 289 
    goto ldv_61423;
    case (unsigned int)3: 
#line 290 
    ;
    
#line 291 
    ecmd->supported = 524352U;
    
#line 293 
    ecmd->advertising = 524352U;
    
#line 295 
    goto ldv_61423;
    case (unsigned int)20: 
#line 296 
    ;
    case (unsigned int)21: 
#line 297 
    ;
    case (unsigned int)27: 
#line 298 
    ;
    case (unsigned int)28: 
#line 299 
    ;
    
#line 300 
    ecmd->supported = 4128U;
    
#line 302 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
#line 303 
                                                        ecmd->advertising |= 4096U; else ;
    
#line 304 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
#line 305 
                                                        ecmd->advertising |= 32U; else ;
    
#line 306 
    goto ldv_61423;
    case (unsigned int)1: 
#line 307 
    ;
    
#line 308 
    ecmd->supported = 131136U;
    
#line 310 
    ecmd->advertising = 131136U;
    
#line 312 
    goto ldv_61423;
    case (unsigned int)19: 
#line 313 
    ;
    case (unsigned int)18: 
#line 314 
    ;
    case (unsigned int)17: 
#line 315 
    ;
    
#line 316 
    ecmd->supported = 4200U;
    
#line 320 
    ecmd->advertising = 64U;
    
#line 321 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
#line 322 
                                                        ecmd->advertising |= 4096U; else ;
    
#line 323 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
#line 324 
                                                        ecmd->advertising |= 32U; else ;
    
#line 325 
    if (((int)hw_link_info->requested_speeds & 2) != 0) 
#line 326 
                                                        ecmd->advertising |= 8U; else ;
    
#line 327 
    goto ldv_61423;
    case (unsigned int)11: 
#line 328 
    ;
    case (unsigned int)23: 
#line 329 
    ;
    
#line 330 
    ecmd->supported = 4160U;
    
#line 332 
    ecmd->advertising = 4160U;
    
#line 334 
    goto ldv_61423;
    case (unsigned int)5: 
#line 335 
    ;
    case (unsigned int)6: 
#line 336 
    ;
    case (unsigned int)7: 
#line 337 
    ;
    case (unsigned int)22: 
#line 338 
    ;
    case (unsigned int)12: 
#line 339 
    ;
    
#line 340 
    ecmd->supported = 4096U;
    
#line 341 
    goto ldv_61423;
    case (unsigned int)0: 
#line 342 
    ;
    
#line 343 
    ecmd->supported = 104U;
    
#line 346 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
#line 347 
                                                        ecmd->advertising |= 32U; else ;
    
#line 348 
    if (((int)hw_link_info->requested_speeds & 2) != 0) 
#line 349 
                                                        ecmd->advertising |= 8U; else ;
    
#line 350 
    goto ldv_61423;
    default: 
#line 351 
    ;
    
#line 353 
    netdev_info((struct net_device const *)netdev,"WARNING: Link is up but PHY type 0x%x is not recognized.\n",(unsigned int)hw_link_info->phy_type);
  }
  ldv_61423: 
#line 358 
  ;
  
#line 358 
  switch (link_speed) {
    case (u32)16: 
#line 359 
    ;
    
#line 360 
    ethtool_cmd_speed_set(ecmd,40000U);
    
#line 361 
    goto ldv_61451;
    case (u32)32: 
#line 362 
    ;
    
#line 363 
    ethtool_cmd_speed_set(ecmd,20000U);
    
#line 364 
    goto ldv_61451;
    case (u32)8: 
#line 365 
    ;
    
#line 366 
    ethtool_cmd_speed_set(ecmd,10000U);
    
#line 367 
    goto ldv_61451;
    case (u32)4: 
#line 368 
    ;
    
#line 369 
    ethtool_cmd_speed_set(ecmd,1000U);
    
#line 370 
    goto ldv_61451;
    case (u32)2: 
#line 371 
    ;
    
#line 372 
    ethtool_cmd_speed_set(ecmd,100U);
    
#line 373 
    goto ldv_61451;
    default: 
#line 374 
    ;
    
#line 375 
    goto ldv_61451;
  }
  ldv_61451: 
#line 377 
  ;
  
#line 377 
  ecmd->duplex = (unsigned char)1U;
  
#line 378 
  return;
}


#line 387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_settings_link_down(struct i40e_hw *hw, struct ethtool_cmd *ecmd)
{
  
#line 390 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  
#line 396 
  switch ((int)hw->device_id) {
    case 5507: 
#line 397 
    ;
    case 5508: 
#line 398 
    ;
    case 5509: 
#line 399 
    ;
    
#line 401 
    ecmd->supported = 117440512U;
    
#line 404 
    ecmd->advertising = 117440512U;
    
#line 407 
    goto ldv_61465;
    case 5504: 
#line 408 
    ;
    
#line 410 
    ecmd->supported = 8388608U;
    
#line 411 
    ecmd->advertising = 8388608U;
    
#line 412 
    goto ldv_61465;
    case 5505: 
#line 413 
    ;
    
#line 415 
    ecmd->supported = 524288U;
    
#line 416 
    ecmd->advertising = 524288U;
    
#line 417 
    goto ldv_61465;
    case 5510: 
#line 418 
    ;
    
#line 419 
    ecmd->supported = 4136U;
    
#line 423 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
#line 424 
                                                        ecmd->advertising |= 4096U; else ;
    
#line 425 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
#line 426 
                                                        ecmd->advertising |= 32U; else ;
    
#line 427 
    if (((int)hw_link_info->requested_speeds & 2) != 0) 
#line 428 
                                                        ecmd->advertising |= 8U; else ;
    
#line 429 
    goto ldv_61465;
    case 5511: 
#line 430 
    ;
    
#line 432 
    ecmd->supported = 4194304U;
    
#line 433 
    ecmd->advertising = 4194304U;
    
#line 434 
    goto ldv_61465;
    default: 
#line 435 
    ;
    
#line 437 
    ecmd->supported = 4128U;
    
#line 440 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
#line 441 
                                                        ecmd->advertising |= 4096U; else ;
    
#line 442 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
#line 443 
                                                        ecmd->advertising |= 32U; else ;
    
#line 444 
    goto ldv_61465;
  }
  ldv_61465: 
#line 448 
  ;
  
#line 448 
  ethtool_cmd_speed_set(ecmd,4294967295U);
  
#line 449 
  ecmd->duplex = (unsigned char)255U;
  
#line 450 
  return;
}


#line 459  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
{
  int __retres;
  
#line 462 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 463 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 464 
  struct i40e_hw *hw = & pf->hw;
  
#line 465 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  
#line 466 
  bool link_up = (_Bool)(((int)hw_link_info->link_info & 1) != 0);
  
#line 468 
  if ((int)link_up != 0) 
#line 469 
                         i40e_get_settings_link_up(hw,ecmd,netdev); else 
                                                                    
#line 471 
                                                                    i40e_get_settings_link_down(hw,ecmd);
  
#line 476 
  ecmd->autoneg = (unsigned char)((unsigned int)hw_link_info->an_info & 1U);
  
#line 479 
  switch ((unsigned int)hw->phy.media_type) {
    case (unsigned int)3: 
#line 480 
    ;
    
#line 481 
    ecmd->supported |= 65600U;
    
#line 483 
    ecmd->advertising |= 65600U;
    
#line 485 
    ecmd->port = (unsigned char)239U;
    
#line 486 
    goto ldv_61481;
    case (unsigned int)2: 
#line 487 
    ;
    
#line 488 
    ecmd->supported |= 128U;
    
#line 489 
    ecmd->advertising |= 128U;
    
#line 490 
    ecmd->port = (unsigned char)0U;
    
#line 491 
    goto ldv_61481;
    case (unsigned int)5: 
#line 492 
    ;
    case (unsigned int)4: 
#line 493 
    ;
    
#line 494 
    ecmd->supported |= 1024U;
    
#line 495 
    ecmd->advertising |= 1024U;
    
#line 496 
    ecmd->port = (unsigned char)5U;
    
#line 497 
    goto ldv_61481;
    case (unsigned int)1: 
#line 498 
    ;
    
#line 499 
    ecmd->supported |= 1024U;
    
#line 500 
    ecmd->port = (unsigned char)3U;
    
#line 501 
    goto ldv_61481;
    case (unsigned int)0: 
#line 502 
    ;
    default: 
#line 503 
    ;
    
#line 504 
    ecmd->port = (unsigned char)255U;
    
#line 505 
    goto ldv_61481;
  }
  ldv_61481: 
#line 509 
  ;
  
#line 509 
  ecmd->transceiver = (unsigned char)1U;
  
#line 512 
  ecmd->supported |= 8192U;
  
#line 514 
  switch ((unsigned int)hw->fc.requested_mode) {
    case (unsigned int)3: 
#line 515 
    ;
    
#line 516 
    ecmd->advertising |= 8192U;
    
#line 517 
    goto ldv_61489;
    case (unsigned int)2: 
#line 518 
    ;
    
#line 519 
    ecmd->advertising |= 16384U;
    
#line 520 
    goto ldv_61489;
    case (unsigned int)1: 
#line 521 
    ;
    
#line 522 
    ecmd->advertising |= 24576U;
    
#line 524 
    goto ldv_61489;
    default: 
#line 525 
    ;
    
#line 526 
    ecmd->advertising &= 4294942719U;
    
#line 528 
    goto ldv_61489;
  }
  ldv_61489: 
#line 531 
  ;
  
#line 531 
  __retres = 0;
  
#line 531 
  return __retres;
}


#line 541  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
{
  int __retres;
  struct i40e_aq_get_phy_abilities_resp abilities;
  struct i40e_aq_set_phy_config config;
  struct ethtool_cmd safe_ecmd;
  u8 autoneg;
  u32 advertise;
  int tmp_0;
  int tmp_1;
  
#line 544 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 547 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 548 
  struct i40e_vsi *vsi = np->vsi;
  
#line 549 
  struct i40e_hw *hw = & pf->hw;
  
#line 551 
  i40e_status status = 0;
  
#line 552 
  bool change = (_Bool)0;
  
#line 553 
  int err = 0;
  
#line 560 
  if ((unsigned int)hw->partition_id != 1U) {
    
#line 561 
    i40e_partition_setting_complaint(pf);
    
#line 562 
    __retres = -95;
    
#line 562 
    goto return_label;
  }
  else ;
  
#line 565 
  if (*(pf->vsi + (int)pf->lan_vsi) != vsi) {
    
#line 566 
    __retres = -95;
    
#line 566 
    goto return_label;
  }
  else ;
  
#line 569 
  if ((unsigned int)hw->phy.media_type + 4294967295U > 2U && ((int)hw->phy.link_info.link_info & 1) != 0) {
    
#line 572 
    __retres = -95;
    
#line 572 
    goto return_label;
  }
  else ;
  
#line 575 
  memset((void *)(& safe_ecmd),0,44UL);
  
#line 576 
  i40e_get_settings(netdev,& safe_ecmd);
  
#line 579 
  autoneg = ecmd->autoneg;
  
#line 580 
  advertise = ecmd->advertising;
  
#line 583 
  ecmd->autoneg = safe_ecmd.autoneg;
  
#line 584 
  ecmd->advertising = safe_ecmd.advertising;
  
#line 586 
  ecmd->cmd = safe_ecmd.cmd;
  
#line 590 
  tmp_0 = memcmp((void const *)ecmd,(void const *)(& safe_ecmd),44UL);
  
#line 590 
  if (tmp_0 != 0) {
    
#line 591 
    __retres = -95;
    
#line 591 
    goto return_label;
  }
  else ;
  
#line 593 
  goto ldv_61510;
  ldv_61509: 
#line 594 
  ;
  
#line 594 
  usleep_range(1000UL,2000UL);
  ldv_61510: 
#line 595 
  ;
  
#line 593 
  tmp_1 = constant_test_bit(1L,(unsigned long const volatile *)(& vsi->state));
  
#line 593 
  if (tmp_1 != 0) 
#line 595 
                  goto ldv_61509; else 
#line 598 
                                       goto ldv_61511;
  ldv_61511: 
#line 599 
  ;
  
#line 597 
  status = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
  
#line 599 
  if (status != I40E_SUCCESS) {
    
#line 600 
    __retres = -11;
    
#line 600 
    goto return_label;
  }
  else ;
  
#line 605 
  memset((void *)(& config),0,16UL);
  
#line 606 
  config.abilities = abilities.abilities;
  
#line 609 
  if ((unsigned int)autoneg == 1U) {
    
#line 611 
    if ((safe_ecmd.supported & 64U) == 0U) {
      
#line 612 
      netdev_info((struct net_device const *)netdev,"Autoneg not supported on this phy\n");
      
#line 613 
      __retres = -22;
      
#line 613 
      goto return_label;
    }
    else ;
    
#line 616 
    if (((int)hw->phy.link_info.an_info & 1) == 0) {
      
#line 617 
      config.abilities = (unsigned char)((unsigned int)abilities.abilities | 16U);
      
#line 619 
      change = (_Bool)1;
    }
    else ;
  }
  else {
    
#line 625 
    if ((safe_ecmd.supported & 64U) != 0U && hw->phy.link_info.phy_type != (unsigned int)I40E_PHY_TYPE_10GBASE_T) {
      
#line 627 
      netdev_info((struct net_device const *)netdev,"Autoneg cannot be disabled on this phy\n");
      
#line 628 
      __retres = -22;
      
#line 628 
      goto return_label;
    }
    else ;
    
#line 631 
    if (((int)hw->phy.link_info.an_info & 1) != 0) {
      
#line 632 
      config.abilities = (unsigned char)((unsigned int)abilities.abilities & 239U);
      
#line 634 
      change = (_Bool)1;
    }
    else ;
  }
  
#line 638 
  if ((~ safe_ecmd.supported & advertise) != 0U) {
    
#line 639 
    __retres = -22;
    
#line 639 
    goto return_label;
  }
  else ;
  
#line 641 
  if ((advertise & 8U) != 0U) 
#line 642 
                              config.link_speed = (unsigned char)((unsigned int)config.link_speed | 2U); else ;
  
#line 643 
  if ((advertise & 32U) != 0U || (advertise & 131072U) != 0U) 
#line 645 
                                                              config.link_speed = (unsigned char)((unsigned int)config.link_speed | 4U); else ;
  
#line 646 
  if (((advertise & 4096U) != 0U || (advertise & 262144U) != 0U) || (advertise & 524288U) != 0U) 
    
#line 649 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 8U); else ;
  
#line 650 
  if ((advertise & 4194304U) != 0U) 
#line 651 
                                    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 32U); else ;
  
#line 652 
  if ((((advertise & 8388608U) != 0U || (advertise & 16777216U) != 0U) || (advertise & 33554432U) != 0U) || (advertise & 67108864U) != 0U) 
    
#line 656 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 16U); else ;
  
#line 658 
  if ((int)change != 0 || (int)abilities.link_speed != (int)config.link_speed) {
    
#line 660 
    config.phy_type = abilities.phy_type;
    
#line 661 
    config.eee_capability = abilities.eee_capability;
    
#line 662 
    config.eeer = abilities.eeer_val;
    
#line 663 
    config.low_power_ctrl = abilities.d3_lpan;
    
#line 666 
    hw->phy.link_info.requested_speeds = config.link_speed;
    
#line 668 
    config.abilities = (unsigned char)((unsigned int)config.abilities | 32U);
    
#line 670 
    if (((int)hw->phy.link_info.link_info & 1) != 0) {
      
#line 674 
      netdev_info((struct net_device const *)netdev,"PHY settings change requested, NIC Link is going down.\n");
      
#line 675 
      netif_carrier_off(netdev);
      
#line 676 
      netif_tx_stop_all_queues(netdev);
    }
    else ;
    
#line 680 
    status = i40e_aq_set_phy_config(hw,& config,(struct i40e_asq_cmd_details *)0);
    
#line 681 
    if (status != I40E_SUCCESS) {
      
#line 682 
      netdev_info((struct net_device const *)netdev,"Set phy config failed with error %d.\n",(int)status);
      
#line 684 
      __retres = -11;
      
#line 684 
      goto return_label;
    }
    else ;
    
#line 687 
    status = i40e_aq_get_link_info(hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
    
#line 688 
    if (status != I40E_SUCCESS) 
#line 689 
                                netdev_info((struct net_device const *)netdev,"Updating link info failed with error %d\n",(int)status); else ;
  }
  else 
#line 693 
       netdev_info((struct net_device const *)netdev,"Nothing changed, exiting without setting anything.\n");
  
#line 696 
  __retres = err;
  return_label: 
#line 696 
                return __retres;
}


#line 699  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_nway_reset(struct net_device *netdev)
{
  int __retres;
  
#line 702 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 703 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 704 
  struct i40e_hw *hw = & pf->hw;
  
#line 705 
  bool link_up = (_Bool)(((int)hw->phy.link_info.link_info & 1) != 0);
  
#line 706 
  i40e_status ret = 0;
  
#line 708 
  ret = i40e_aq_set_link_restart_an(hw,(_Bool)((bool)((int)link_up) != 0),(struct i40e_asq_cmd_details *)0);
  
#line 709 
  if (ret != I40E_SUCCESS) {
    
#line 710 
    netdev_info((struct net_device const *)netdev,"link restart failed, aq_err=%d\n",(unsigned int)pf->hw.aq.asq_last_status);
    
#line 712 
    __retres = -5;
    
#line 712 
    goto return_label;
  }
  else ;
  
#line 715 
  __retres = 0;
  return_label: 
#line 715 
                return __retres;
}


#line 722  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  
#line 725 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 726 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 727 
  struct i40e_hw *hw = & pf->hw;
  
#line 728 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  
#line 729 
  struct i40e_dcbx_config *dcbx_cfg = & hw->local_dcbx_config;
  
#line 731 
  pause->autoneg = (unsigned int)hw_link_info->an_info & 1U;
  
#line 736 
  if ((unsigned int)dcbx_cfg->pfc.pfcenable != 0U) {
    
#line 737 
    pause->rx_pause = 0U;
    
#line 738 
    pause->tx_pause = 0U;
    
#line 739 
    goto return_label;
  }
  else ;
  
#line 742 
  if (hw->fc.current_mode == (unsigned int)I40E_FC_RX_PAUSE) 
#line 743 
                                                             pause->rx_pause = 1U;
  else 
    
#line 744 
    if (hw->fc.current_mode == (unsigned int)I40E_FC_TX_PAUSE) 
#line 745 
                                                               pause->tx_pause = 1U;
    else 
      
#line 746 
      if (hw->fc.current_mode == (unsigned int)I40E_FC_FULL) {
        
#line 747 
        pause->rx_pause = 1U;
        
#line 748 
        pause->tx_pause = 1U;
      }
      else ;
  return_label: 
#line 750 
                return;
}


#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  int __retres;
  i40e_status status;
  u8 aq_failures;
  int tmp_0;
  int tmp_3;
  
#line 760 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 761 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 762 
  struct i40e_vsi *vsi = np->vsi;
  
#line 763 
  struct i40e_hw *hw = & pf->hw;
  
#line 764 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  
#line 765 
  struct i40e_dcbx_config *dcbx_cfg = & hw->local_dcbx_config;
  
#line 766 
  bool link_up = (_Bool)(((int)hw_link_info->link_info & 1) != 0);
  
#line 769 
  int err = 0;
  
#line 774 
  if ((unsigned int)hw->partition_id != 1U) {
    
#line 775 
    i40e_partition_setting_complaint(pf);
    
#line 776 
    __retres = -95;
    
#line 776 
    goto return_label;
  }
  else ;
  
#line 779 
  if (*(pf->vsi + (int)pf->lan_vsi) != vsi) {
    
#line 780 
    __retres = -95;
    
#line 780 
    goto return_label;
  }
  else ;
  
#line 782 
  if (pause->autoneg != ((unsigned int)hw_link_info->an_info & 1U)) {
    
#line 784 
    netdev_info((struct net_device const *)netdev,"To change autoneg please use: ethtool -s <dev> autoneg <on|off>\n");
    
#line 785 
    __retres = -95;
    
#line 785 
    goto return_label;
  }
  else ;
  
#line 789 
  tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 789 
  if (tmp_0 == 0) {
    
#line 789 
    if (((int)hw_link_info->an_info & 1) == 0) 
#line 792 
                                               netdev_info((struct net_device const *)netdev,"Autoneg did not complete so changing settings may not result in an actual change.\n"); else ;
  }
  else ;
  
#line 795 
  if ((unsigned int)dcbx_cfg->pfc.pfcenable != 0U) {
    
#line 796 
    netdev_info((struct net_device const *)netdev,"Priority flow control enabled. Cannot set link flow control.\n");
    
#line 798 
    __retres = -95;
    
#line 798 
    goto return_label;
  }
  else ;
  
#line 801 
  if (pause->rx_pause != 0U && pause->tx_pause != 0U) 
#line 802 
                                                      hw->fc.requested_mode = I40E_FC_FULL;
  else 
    
#line 803 
    if (pause->rx_pause != 0U && pause->tx_pause == 0U) 
#line 804 
                                                        hw->fc.requested_mode = I40E_FC_RX_PAUSE;
    else 
      
#line 805 
      if (pause->rx_pause == 0U && pause->tx_pause != 0U) 
#line 806 
                                                          hw->fc.requested_mode = I40E_FC_TX_PAUSE;
      else 
        
#line 807 
        if (pause->rx_pause == 0U && pause->tx_pause == 0U) 
#line 808 
                                                            hw->fc.requested_mode = I40E_FC_NONE;
        else {
          
#line 810 
          __retres = -22;
          
#line 810 
          goto return_label;
        }
  
#line 815 
  netdev_info((struct net_device const *)netdev,"Flow control settings change requested, NIC Link is going down.\n");
  
#line 816 
  netif_carrier_off(netdev);
  
#line 817 
  netif_tx_stop_all_queues(netdev);
  
#line 820 
  status = i40e_set_fc(hw,& aq_failures,(_Bool)((bool)((int)link_up) != 0));
  
#line 822 
  if (((int)aq_failures & 1) != 0) {
    
#line 823 
    netdev_info((struct net_device const *)netdev,"Set fc failed on the get_phy_capabilities call with error %d and status %d\n",(int)status,(unsigned int)hw->aq.asq_last_status);
    
#line 825 
    err = -11;
  }
  else ;
  
#line 827 
  if (((int)aq_failures & 2) != 0) {
    
#line 828 
    netdev_info((struct net_device const *)netdev,"Set fc failed on the set_phy_config call with error %d and status %d\n",(int)status,(unsigned int)hw->aq.asq_last_status);
    
#line 830 
    err = -11;
  }
  else ;
  
#line 832 
  if (((int)aq_failures & 4) != 0) {
    
#line 833 
    netdev_info((struct net_device const *)netdev,"Set fc failed on the get_link_info call with error %d and status %d\n",(int)status,(unsigned int)hw->aq.asq_last_status);
    
#line 835 
    err = -11;
  }
  else ;
  
#line 838 
  tmp_3 = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 838 
  if (tmp_3 == 0) {
    int tmp_2;
    
#line 840 
    msleep(75U);
    
#line 841 
    tmp_2 = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
    
#line 841 
    if (tmp_2 == 0) {
      int tmp_1;
      
#line 842 
      tmp_1 = i40e_nway_reset(netdev);
      
#line 842 
      __retres = tmp_1;
      
#line 842 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 845 
  __retres = err;
  return_label: 
#line 845 
                return __retres;
}


#line 848  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u32 i40e_get_msglevel(struct net_device *netdev)
{
  u32 __retres;
  
#line 850 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 851 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 853 
  __retres = pf->msg_enable;
  
#line 853 
  return __retres;
}


#line 856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_set_msglevel(struct net_device *netdev, u32 data)
{
  
#line 858 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 859 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 861 
  if ((data & 4026531840U) != 0U) 
#line 862 
                                  pf->hw.debug_mask = data; else ;
  
#line 863 
  pf->msg_enable = data;
  
#line 864 
  return;
}


#line 866  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_regs_len(struct net_device *netdev)
{
  int __retres;
  int i;
  
#line 868 
  int reg_count = 0;
  
#line 871 
  i = 0;
  
#line 871 
  goto ldv_61560;
  ldv_61559: 
#line 872 
  ;
  
#line 872 
  reg_count = (int)(i40e_reg_list[i].elements + (unsigned int)reg_count);
  
#line 871 
  i += 1;
  ldv_61560: 
#line 872 
  ;
  
#line 871 
  if (i40e_reg_list[i].offset != 0U) 
#line 873 
                                     goto ldv_61559; else 
#line 876 
                                                          goto ldv_61561;
  ldv_61561: 
#line 877 
  ;
  
#line 874 
  __retres = (int)((unsigned long)reg_count * (unsigned long)4U);
  
#line 874 
  return __retres;
}


#line 877  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_regs(struct net_device *netdev, struct ethtool_regs *regs, void *p)
{
  int i;
  int j;
  int ri;
  u32 reg;
  int tmp_0;
  
#line 880 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 881 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 882 
  struct i40e_hw *hw = & pf->hw;
  
#line 883 
  u32 *reg_buf = (u32 *)p;
  
#line 894 
  regs->version = 1U;
  
#line 897 
  ri = 0;
  
#line 898 
  i = 0;
  
#line 898 
  goto ldv_61579;
  ldv_61578: 
#line 899 
  ;
  
#line 899 
  j = 0;
  
#line 899 
  goto ldv_61576;
  ldv_61575: 
#line 900 
  ;
  
#line 900 
  reg = i40e_reg_list[i].offset + i40e_reg_list[i].stride * (unsigned int)j;
  
#line 902 
  tmp_0 = ri;
  
#line 902 
  ri += 1;
  
#line 902 
  *(reg_buf + tmp_0) = readl((void const volatile *)(hw->hw_addr + reg));
  
#line 899 
  j += 1;
  ldv_61576: 
#line 900 
  ;
  
#line 899 
  if (i40e_reg_list[i].elements > (unsigned int)j) 
#line 901 
                                                   goto ldv_61575; else 
                                                                    
#line 904 
                                                                    goto ldv_61577;
  ldv_61577: 
#line 905 
  ;
  
#line 898 
  i += 1;
  ldv_61579: 
#line 899 
  ;
  
#line 898 
  if (i40e_reg_list[i].offset != 0U) 
#line 900 
                                     goto ldv_61578; else 
#line 903 
                                                          goto ldv_61580;
  ldv_61580: 
#line 904 
  ;
  
#line 905 
  return;
}


#line 908  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  int __retres;
  int len;
  int offset;
  u8 *eeprom_buff;
  u16 i;
  u16 sectors;
  bool last;
  u32 magic;
  i40e_status tmp_2;
  i40e_status tmp_3;
  
#line 911 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 912 
  struct i40e_hw *hw = & ((np->vsi)->back)->hw;
  
#line 913 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 914 
  int ret_val = 0;
  
#line 921 
  if (eeprom->len == 0U) {
    
#line 922 
    __retres = -22;
    
#line 922 
    goto return_label;
  }
  else ;
  
#line 925 
  magic = (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16));
  
#line 926 
  if (eeprom->magic != 0U && eeprom->magic != magic) {
    struct i40e_nvm_access *cmd;
    int errno;
    i40e_status tmp_0;
    
#line 931 
    if (eeprom->magic >> 16 != (unsigned int)hw->device_id) {
      
#line 932 
      __retres = -22;
      
#line 932 
      goto return_label;
    }
    else ;
    
#line 934 
    cmd = (struct i40e_nvm_access *)eeprom;
    
#line 935 
    tmp_0 = i40e_nvmupd_command(hw,cmd,bytes,& errno);
    
#line 935 
    ret_val = (int)tmp_0;
    
#line 936 
    if (ret_val != 0 && (hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_EACCES || (hw->debug_mask & 128U) != 0U)) 
      
#line 939 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"NVMUpdate read failed err=%d status=0x%x errno=%d module=%d offset=0x%x size=%d\n",ret_val,(unsigned int)hw->aq.asq_last_status,errno,(int)((unsigned char)cmd->config),cmd->offset,cmd->data_size); else ;
    
#line 945 
    __retres = errno;
    
#line 945 
    goto return_label;
  }
  else ;
  
#line 949 
  eeprom->magic = (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16));
  
#line 951 
  eeprom_buff = (u8 *)kzalloc_2((unsigned long)eeprom->len,208U);
  
#line 952 
  if (eeprom_buff == (u8 *)0U) {
    
#line 953 
    __retres = -12;
    
#line 953 
    goto return_label;
  }
  else ;
  
#line 955 
  tmp_2 = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  
#line 955 
  ret_val = (int)tmp_2;
  
#line 956 
  if (ret_val != 0) {
    
#line 957 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Failed Acquiring NVM resource for read err=%d status=0x%x\n",ret_val,(unsigned int)hw->aq.asq_last_status);
    
#line 960 
    goto free_buff;
  }
  else ;
  
#line 963 
  sectors = (unsigned short)(eeprom->len / 4096U);
  
#line 964 
  sectors = (unsigned short)(((eeprom->len & 4095U) != 0U) + (int)sectors);
  
#line 965 
  len = 4096;
  
#line 966 
  last = (_Bool)0;
  
#line 967 
  i = (unsigned short)0U;
  
#line 967 
  goto ldv_61602;
  ldv_61601: 
#line 968 
  ;
  
#line 968 
  if ((int)i == (int)sectors + -1) {
    
#line 969 
    len = (int)(eeprom->len - (unsigned int)((int)i * 4096));
    
#line 970 
    last = (_Bool)1;
  }
  else ;
  
#line 972 
  offset = (int)(eeprom->offset + (unsigned int)((int)i * 4096));
  
#line 973 
  tmp_3 = i40e_aq_read_nvm(hw,(unsigned char)0,(unsigned int)offset,(unsigned short)((int)((unsigned short)len)),(void *)(eeprom_buff + (int)i * 4096),(_Bool)((bool)((int)last) != 0),(struct i40e_asq_cmd_details *)0);
  
#line 972 
  ret_val = (int)tmp_3;
  
#line 976 
  if (ret_val != 0 && hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EPERM) {
    
#line 977 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"read NVM failed, invalid offset 0x%x\n",offset);
    
#line 980 
    goto ldv_61600;
  }
  else 
    
#line 981 
    if (ret_val != 0 && hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EACCES) {
      
#line 983 
      _dev_info((struct device const *)(& (pf->pdev)->dev),"read NVM failed, access, offset 0x%x\n",offset);
      
#line 986 
      goto ldv_61600;
    }
    else 
      
#line 987 
      if (ret_val != 0) {
        
#line 988 
        _dev_info((struct device const *)(& (pf->pdev)->dev),"read NVM failed offset %d err=%d status=0x%x\n",offset,ret_val,(unsigned int)hw->aq.asq_last_status);
        
#line 991 
        goto ldv_61600;
      }
      else ;
  
#line 967 
  i = (u16)((int)i + 1);
  ldv_61602: 
#line 968 
  ;
  
#line 967 
  if ((int)i < (int)sectors) 
#line 969 
                             goto ldv_61601; else 
#line 972 
                                                  goto ldv_61600;
  ldv_61600: 
#line 973 
  ;
  
#line 995 
  i40e_release_nvm(hw);
  
#line 996 
  memcpy((void *)bytes,(void const *)eeprom_buff,(unsigned long)eeprom->len);
  free_buff: 
#line 997 
  ;
  
#line 998 
  kfree((void const *)eeprom_buff);
  
#line 999 
  __retres = ret_val;
  return_label: 
#line 999 
                return __retres;
}


#line 1002  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_eeprom_len(struct net_device *netdev)
{
  int __retres;
  u32 val;
  unsigned int tmp_0;
  
#line 1004 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1005 
  struct i40e_hw *hw = & ((np->vsi)->back)->hw;
  
#line 1008 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + 779396U));
  
#line 1008 
  val = (tmp_0 >> 6) & 7U;
  
#line 1012 
  val = (unsigned int)(65536 << val);
  
#line 1013 
  __retres = (int)val;
  
#line 1013 
  return __retres;
}


#line 1016  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  int __retres;
  struct i40e_nvm_access *cmd;
  int errno;
  u32 magic;
  int tmp_0;
  i40e_status tmp_2;
  
#line 1019 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1020 
  struct i40e_hw *hw = & ((np->vsi)->back)->hw;
  
#line 1021 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1023 
  int ret_val = 0;
  
#line 1028 
  magic = (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16));
  
#line 1029 
  if (eeprom->magic == magic) {
    
#line 1030 
    __retres = -95;
    
#line 1030 
    goto return_label;
  }
  else ;
  
#line 1033 
  if (eeprom->magic == 0U || eeprom->magic >> 16 != (unsigned int)hw->device_id) {
    
#line 1034 
    __retres = -22;
    
#line 1034 
    goto return_label;
  }
  else ;
  
#line 1036 
  tmp_0 = constant_test_bit(9L,(unsigned long const volatile *)(& pf->state));
  
#line 1036 
  if (tmp_0 != 0) {
    
#line 1038 
    __retres = -16;
    
#line 1038 
    goto return_label;
  }
  else {
    int tmp_1;
    
#line 1036 
    tmp_1 = constant_test_bit(10L,(unsigned long const volatile *)(& pf->state));
    
#line 1036 
    if (tmp_1 != 0) {
      
#line 1038 
      __retres = -16;
      
#line 1038 
      goto return_label;
    }
    else ;
  }
  
#line 1040 
  cmd = (struct i40e_nvm_access *)eeprom;
  
#line 1041 
  tmp_2 = i40e_nvmupd_command(hw,cmd,bytes,& errno);
  
#line 1041 
  ret_val = (int)tmp_2;
  
#line 1042 
  if (ret_val != 0 && ((hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_EPERM && hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_EBUSY) || (hw->debug_mask & 128U) != 0U)) 
    
#line 1046 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"NVMUpdate write failed err=%d status=0x%x errno=%d module=%d offset=0x%x size=%d\n",ret_val,(unsigned int)hw->aq.asq_last_status,errno,(int)((unsigned char)cmd->config),cmd->offset,cmd->data_size); else ;
  
#line 1052 
  __retres = errno;
  return_label: 
#line 1052 
                return __retres;
}


#line 1055  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
{
  char *tmp_0;
  char const *tmp_1;
  
#line 1058 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1059 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1060 
  struct i40e_pf *pf = vsi->back;
  
#line 1062 
  strlcpy((char *)(& drvinfo->driver),(char const *)(& i40e_driver_name),32UL);
  
#line 1063 
  strlcpy((char *)(& drvinfo->version),(char const *)(& i40e_driver_version_str),32UL);
  
#line 1065 
  tmp_0 = i40e_fw_version_str(& pf->hw);
  
#line 1065 
  ;
  
#line 1065 
  strlcpy((char *)(& drvinfo->fw_version),(char const *)tmp_0,32UL);
  
#line 1067 
  tmp_1 = pci_name((struct pci_dev const *)pf->pdev);
  
#line 1067 
  ;
  
#line 1067 
  strlcpy((char *)(& drvinfo->bus_info),tmp_1,32UL);
  
#line 1069 
  drvinfo->n_priv_flags = 1U;
  
#line 1070 
  return;
}


#line 1072  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  
#line 1075 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1076 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1077 
  struct i40e_vsi *vsi = *(pf->vsi + (int)pf->lan_vsi);
  
#line 1079 
  ring->rx_max_pending = 4096U;
  
#line 1080 
  ring->tx_max_pending = 4096U;
  
#line 1081 
  ring->rx_mini_max_pending = 0U;
  
#line 1082 
  ring->rx_jumbo_max_pending = 0U;
  
#line 1083 
  ring->rx_pending = (unsigned int)(*(vsi->rx_rings))->count;
  
#line 1084 
  ring->tx_pending = (unsigned int)(*(vsi->tx_rings))->count;
  
#line 1085 
  ring->rx_mini_pending = 0U;
  
#line 1086 
  ring->rx_jumbo_pending = 0U;
  
#line 1087 
  return;
}


#line 1089  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  int __retres;
  u32 new_rx_count;
  u32 new_tx_count;
  int i;
  int tmp_0;
  int tmp_2;
  bool tmp_1;
  
#line 1092 
  struct i40e_ring *tx_rings = (struct i40e_ring *)0;
  
#line 1092 
  struct i40e_ring *rx_rings = (struct i40e_ring *)0;
  
#line 1093 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1094 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1095 
  struct i40e_pf *pf = vsi->back;
  
#line 1097 
  int err = 0;
  
#line 1099 
  if (ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) {
    
#line 1100 
    __retres = -22;
    
#line 1100 
    goto return_label;
  }
  else ;
  
#line 1102 
  if ((ring->tx_pending + 4294967232U > 4032U || ring->rx_pending > 4096U) || ring->rx_pending <= 63U) {
    
#line 1106 
    netdev_info((struct net_device const *)netdev,"Descriptors requested (Tx: %d / Rx: %d) out of range [%d-%d]\n",ring->tx_pending,ring->rx_pending,64,4096);
    
#line 1110 
    __retres = -22;
    
#line 1110 
    goto return_label;
  }
  else ;
  
#line 1113 
  new_tx_count = (ring->tx_pending + 31U) & 4294967264U;
  
#line 1114 
  new_rx_count = (ring->rx_pending + 31U) & 4294967264U;
  
#line 1117 
  if ((unsigned int)(*(vsi->tx_rings))->count == new_tx_count && (unsigned int)(*(vsi->rx_rings))->count == new_rx_count) {
    
#line 1119 
    __retres = 0;
    
#line 1119 
    goto return_label;
  }
  else ;
  
#line 1121 
  goto ldv_61649;
  ldv_61648: 
#line 1122 
  ;
  
#line 1122 
  usleep_range(1000UL,2000UL);
  ldv_61649: 
#line 1123 
  ;
  
#line 1121 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& pf->state));
  
#line 1121 
  if (tmp_0 != 0) 
#line 1123 
                  goto ldv_61648; else 
#line 1126 
                                       goto ldv_61650;
  ldv_61650: 
#line 1127 
  ;
  
#line 1124 
  tmp_1 = netif_running((struct net_device const *)vsi->netdev);
  
#line 1124 
  if (tmp_1) 
#line 1124 
             tmp_2 = 0; else 
#line 1124 
                             tmp_2 = 1;
  
#line 1124 
  if (tmp_2) {
    
#line 1126 
    i = 0;
    
#line 1126 
    goto ldv_61652;
    ldv_61651: 
#line 1127 
    ;
    
#line 1127 
    (*(vsi->tx_rings + i))->count = (unsigned short)new_tx_count;
    
#line 1128 
    (*(vsi->rx_rings + i))->count = (unsigned short)new_rx_count;
    
#line 1126 
    i += 1;
    ldv_61652: 
#line 1127 
    ;
    
#line 1126 
    if ((int)vsi->num_queue_pairs > i) 
#line 1128 
                                       goto ldv_61651; else 
#line 1131 
                                                            goto ldv_61653;
    ldv_61653: 
#line 1132 
    ;
    
#line 1130 
    goto done;
  }
  else ;
  
#line 1139 
  if ((unsigned int)(*(vsi->tx_rings))->count != new_tx_count) {
    
#line 1140 
    netdev_info((struct net_device const *)netdev,"Changing Tx descriptor count from %d to %d.\n",(int)(*(vsi->tx_rings))->count,new_tx_count);
    
#line 1143 
    tx_rings = (struct i40e_ring *)kcalloc_1((unsigned long)vsi->alloc_queue_pairs,4096UL,208U);
    
#line 1145 
    if (tx_rings == (struct i40e_ring *)0) {
      
#line 1146 
      err = -12;
      
#line 1147 
      goto done;
    }
    else ;
    
#line 1150 
    i = 0;
    
#line 1150 
    goto ldv_61659;
    ldv_61658: 
#line 1151 
    ;
    
#line 1152 
    *(tx_rings + i) = *(*(vsi->tx_rings + i));
    
#line 1153 
    (tx_rings + i)->count = (unsigned short)new_tx_count;
    
#line 1154 
    err = i40e_setup_tx_descriptors(tx_rings + i);
    
#line 1155 
    if (err != 0) {
      
#line 1156 
      goto ldv_61656;
      ldv_61655: 
#line 1157 
      ;
      
#line 1157 
      i -= 1;
      
#line 1158 
      i40e_free_tx_resources(tx_rings + i);
      ldv_61656: 
#line 1159 
      ;
      
#line 1156 
      if (i != 0) 
#line 1158 
                  goto ldv_61655; else 
#line 1161 
                                       goto ldv_61657;
      ldv_61657: 
#line 1162 
      ;
      
#line 1160 
      kfree((void const *)tx_rings);
      
#line 1161 
      tx_rings = (struct i40e_ring *)0;
      
#line 1163 
      goto done;
    }
    else ;
    
#line 1150 
    i += 1;
    ldv_61659: 
#line 1151 
    ;
    
#line 1150 
    if ((int)vsi->num_queue_pairs > i) 
#line 1152 
                                       goto ldv_61658; else 
#line 1155 
                                                            goto ldv_61660;
    ldv_61660: 
#line 1156 
    ;
  }
  else ;
  
#line 1169 
  if ((unsigned int)(*(vsi->rx_rings))->count != new_rx_count) {
    
#line 1170 
    netdev_info((struct net_device const *)netdev,"Changing Rx descriptor count from %d to %d\n",(int)(*(vsi->rx_rings))->count,new_rx_count);
    
#line 1173 
    rx_rings = (struct i40e_ring *)kcalloc_1((unsigned long)vsi->alloc_queue_pairs,4096UL,208U);
    
#line 1175 
    if (rx_rings == (struct i40e_ring *)0) {
      
#line 1176 
      err = -12;
      
#line 1177 
      goto free_tx;
    }
    else ;
    
#line 1180 
    i = 0;
    
#line 1180 
    goto ldv_61666;
    ldv_61665: 
#line 1181 
    ;
    
#line 1182 
    *(rx_rings + i) = *(*(vsi->rx_rings + i));
    
#line 1183 
    (rx_rings + i)->count = (unsigned short)new_rx_count;
    
#line 1184 
    err = i40e_setup_rx_descriptors(rx_rings + i);
    
#line 1185 
    if (err != 0) {
      
#line 1186 
      goto ldv_61663;
      ldv_61662: 
#line 1187 
      ;
      
#line 1187 
      i -= 1;
      
#line 1188 
      i40e_free_rx_resources(rx_rings + i);
      ldv_61663: 
#line 1189 
      ;
      
#line 1186 
      if (i != 0) 
#line 1188 
                  goto ldv_61662; else 
#line 1191 
                                       goto ldv_61664;
      ldv_61664: 
#line 1192 
      ;
      
#line 1190 
      kfree((void const *)rx_rings);
      
#line 1191 
      rx_rings = (struct i40e_ring *)0;
      
#line 1193 
      goto free_tx;
    }
    else ;
    
#line 1180 
    i += 1;
    ldv_61666: 
#line 1181 
    ;
    
#line 1180 
    if ((int)vsi->num_queue_pairs > i) 
#line 1182 
                                       goto ldv_61665; else 
#line 1185 
                                                            goto ldv_61667;
    ldv_61667: 
#line 1186 
    ;
  }
  else ;
  
#line 1201 
  i40e_down(vsi);
  
#line 1203 
  if (tx_rings != (struct i40e_ring *)0) {
    
#line 1204 
    i = 0;
    
#line 1204 
    goto ldv_61669;
    ldv_61668: 
#line 1205 
    ;
    
#line 1205 
    i40e_free_tx_resources(*(vsi->tx_rings + i));
    
#line 1206 
    *(*(vsi->tx_rings + i)) = *(tx_rings + i);
    
#line 1204 
    i += 1;
    ldv_61669: 
#line 1205 
    ;
    
#line 1204 
    if ((int)vsi->num_queue_pairs > i) 
#line 1206 
                                       goto ldv_61668; else 
#line 1209 
                                                            goto ldv_61670;
    ldv_61670: 
#line 1210 
    ;
    
#line 1208 
    kfree((void const *)tx_rings);
    
#line 1209 
    tx_rings = (struct i40e_ring *)0;
  }
  else ;
  
#line 1212 
  if (rx_rings != (struct i40e_ring *)0) {
    
#line 1213 
    i = 0;
    
#line 1213 
    goto ldv_61672;
    ldv_61671: 
#line 1214 
    ;
    
#line 1214 
    i40e_free_rx_resources(*(vsi->rx_rings + i));
    
#line 1215 
    *(*(vsi->rx_rings + i)) = *(rx_rings + i);
    
#line 1213 
    i += 1;
    ldv_61672: 
#line 1214 
    ;
    
#line 1213 
    if ((int)vsi->num_queue_pairs > i) 
#line 1215 
                                       goto ldv_61671; else 
#line 1218 
                                                            goto ldv_61673;
    ldv_61673: 
#line 1219 
    ;
    
#line 1217 
    kfree((void const *)rx_rings);
    
#line 1218 
    rx_rings = (struct i40e_ring *)0;
  }
  else ;
  
#line 1221 
  i40e_up(vsi);
  free_tx: 
#line 1223 
  ;
  
#line 1225 
  if (tx_rings != (struct i40e_ring *)0) {
    
#line 1226 
    i = 0;
    
#line 1226 
    goto ldv_61675;
    ldv_61674: 
#line 1227 
    ;
    
#line 1227 
    i40e_free_tx_resources(tx_rings + i);
    
#line 1226 
    i += 1;
    ldv_61675: 
#line 1227 
    ;
    
#line 1226 
    if ((int)vsi->num_queue_pairs > i) 
#line 1228 
                                       goto ldv_61674; else 
#line 1231 
                                                            goto ldv_61676;
    ldv_61676: 
#line 1232 
    ;
    
#line 1228 
    kfree((void const *)tx_rings);
    
#line 1229 
    tx_rings = (struct i40e_ring *)0;
  }
  else ;
  done: 
#line 1232 
  ;
  
#line 1233 
  clear_bit(1L,(unsigned long volatile *)(& pf->state));
  
#line 1235 
  __retres = err;
  return_label: 
#line 1235 
                return __retres;
}


#line 1238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_sset_count(struct net_device *netdev, int sset)
{
  int __retres;
  
#line 1240 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1241 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1242 
  struct i40e_pf *pf = vsi->back;
  
#line 1244 
  switch (sset) {
    case 0: 
#line 1245 
    ;
    
#line 1246 
    __retres = 5;
    
#line 1246 
    goto return_label;
    case 1: 
#line 1247 
    ;
    
#line 1248 
    if (*(pf->vsi + (int)pf->lan_vsi) == vsi && (unsigned int)pf->hw.partition_id == 1U) {
      void *tmp_0;
      
#line 1249 
      tmp_0 = netdev_priv((struct net_device const *)netdev);
      
#line 1249 
      int len = (int)(((unsigned long)(((struct i40e_netdev_priv *)tmp_0)->vsi)->num_queue_pairs + 29UL) * (unsigned long)4U);
      
#line 1251 
      if ((unsigned int)pf->lan_veb != 65535U) 
#line 1252 
                                               len = (int)((unsigned int)len + 12U); else ;
      
#line 1253 
      __retres = len;
      
#line 1253 
      goto return_label;
    }
    else {
      void *tmp_1;
      
#line 1255 
      tmp_1 = netdev_priv((struct net_device const *)netdev);
      
#line 1255 
      ;
      
#line 1255 
      __retres = (int)((unsigned int)(((struct i40e_netdev_priv *)tmp_1)->vsi)->num_queue_pairs * 4U + 26U);
      
#line 1255 
      goto return_label;
    }
    case 2: 
#line 1257 
    ;
    
#line 1258 
    __retres = 1;
    
#line 1258 
    goto return_label;
    default: 
#line 1259 
    ;
    
#line 1260 
    __retres = -95;
    
#line 1260 
    goto return_label;
  }
  return_label: 
#line 1244 
                return __retres;
}


#line 1264  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_ethtool_stats(struct net_device *netdev, struct ethtool_stats *stats, u64 *data)
{
  struct i40e_ring *tx_ring;
  struct i40e_ring *rx_ring;
  char *p;
  int j;
  unsigned int start;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  struct i40e_ring * volatile *tmp_4;
  bool tmp_5;
  bool tmp_6;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  
#line 1267 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1269 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1270 
  struct i40e_pf *pf = vsi->back;
  
#line 1271 
  int i = 0;
  
#line 1274 
  struct rtnl_link_stats64 *net_stats = i40e_get_vsi_stats_struct(vsi);
  
#line 1277 
  i40e_update_stats(vsi);
  
#line 1279 
  j = 0;
  
#line 1279 
  goto ldv_61732;
  ldv_61731: 
#line 1280 
  ;
  
#line 1280 
  p = (char *)net_stats + i40e_gstrings_net_stats[j].stat_offset;
  
#line 1281 
  tmp_1 = i;
  
#line 1281 
  i += 1;
  
#line 1281 
  if (i40e_gstrings_net_stats[j].sizeof_stat == 8) 
#line 1281 
                                                   *(data + tmp_1) = *((u64 *)p); else 
                                                                    
#line 1281 
                                                                    *(data + tmp_1) = (unsigned long long)*((u32 *)p);
  
#line 1279 
  j += 1;
  ldv_61732: 
#line 1280 
  ;
  
#line 1279 
  if ((unsigned int)j <= 10U) 
#line 1281 
                              goto ldv_61731; else 
#line 1284 
                                                   goto ldv_61733;
  ldv_61733: 
#line 1285 
  ;
  
#line 1284 
  j = 0;
  
#line 1284 
  goto ldv_61738;
  ldv_61737: 
#line 1285 
  ;
  
#line 1285 
  p = (char *)vsi + i40e_gstrings_misc_stats[j].stat_offset;
  
#line 1286 
  tmp_2 = i;
  
#line 1286 
  i += 1;
  
#line 1286 
  if (i40e_gstrings_misc_stats[j].sizeof_stat == 8) 
#line 1286 
                                                    *(data + tmp_2) = *((u64 *)p); else 
                                                                    
#line 1286 
                                                                    *(data + tmp_2) = (unsigned long long)*((u32 *)p);
  
#line 1284 
  j += 1;
  ldv_61738: 
#line 1285 
  ;
  
#line 1284 
  if ((unsigned int)j <= 6U) 
#line 1286 
                             goto ldv_61737; else 
#line 1289 
                                                  goto ldv_61739;
  ldv_61739: 
#line 1290 
  ;
  
#line 1290 
  j = 0;
  
#line 1290 
  goto ldv_61744;
  ldv_61743: 
#line 1291 
  ;
  
#line 1291 
  p = (char *)vsi + i40e_gstrings_fcoe_stats[j].stat_offset;
  
#line 1292 
  tmp_3 = i;
  
#line 1292 
  i += 1;
  
#line 1292 
  if (i40e_gstrings_fcoe_stats[j].sizeof_stat == 8) 
#line 1292 
                                                    *(data + tmp_3) = *((u64 *)p); else 
                                                                    
#line 1292 
                                                                    *(data + tmp_3) = (unsigned long long)*((u32 *)p);
  
#line 1290 
  j += 1;
  ldv_61744: 
#line 1291 
  ;
  
#line 1290 
  if ((unsigned int)j <= 7U) 
#line 1292 
                             goto ldv_61743; else 
#line 1295 
                                                  goto ldv_61745;
  ldv_61745: 
#line 1296 
  ;
  
#line 1296 
  rcu_read_lock();
  
#line 1297 
  j = 0;
  
#line 1297 
  goto ldv_61754;
  ldv_61753: 
#line 1298 
  ;
  {
    
#line 1298 
    struct i40e_ring *__var = (struct i40e_ring *)0;
    
#line 1298 
    tmp_4 = (struct i40e_ring * volatile *)(vsi->tx_rings + j);
  }
  
#line 1298 
  tx_ring = *tmp_4;
  
#line 1300 
  if (tx_ring == (struct i40e_ring *)0) 
#line 1301 
                                        goto ldv_61748; else ;
  ldv_61749: 
#line 1303 
  ;
  
#line 1305 
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& tx_ring->syncp));
  
#line 1306 
  *(data + i) = tx_ring->stats.packets;
  
#line 1307 
  *(data + ((unsigned int)i + 1U)) = tx_ring->stats.bytes;
  
#line 1308 
  tmp_5 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& tx_ring->syncp),start);
  
#line 1308 
  if ((int)tmp_5 != 0) 
#line 1310 
                       goto ldv_61749; else 
#line 1313 
                                            goto ldv_61750;
  ldv_61750: 
#line 1314 
  ;
  
#line 1309 
  i += 2;
  
#line 1312 
  rx_ring = tx_ring + 1U;
  ldv_61751: 
#line 1313 
  ;
  
#line 1314 
  start = u64_stats_fetch_begin_irq((struct u64_stats_sync const *)(& rx_ring->syncp));
  
#line 1315 
  *(data + i) = rx_ring->stats.packets;
  
#line 1316 
  *(data + ((unsigned int)i + 1U)) = rx_ring->stats.bytes;
  
#line 1317 
  tmp_6 = u64_stats_fetch_retry_irq((struct u64_stats_sync const *)(& rx_ring->syncp),start);
  
#line 1317 
  if ((int)tmp_6 != 0) 
#line 1319 
                       goto ldv_61751; else 
#line 1322 
                                            goto ldv_61752;
  ldv_61752: 
#line 1323 
  ;
  
#line 1318 
  i += 2;
  ldv_61748: 
#line 1319 
  ;
  
#line 1297 
  j += 1;
  ldv_61754: 
#line 1298 
  ;
  
#line 1297 
  if ((int)vsi->num_queue_pairs > j) 
#line 1299 
                                     goto ldv_61753; else 
#line 1302 
                                                          goto ldv_61755;
  ldv_61755: 
#line 1303 
  ;
  
#line 1320 
  rcu_read_unlock();
  
#line 1321 
  if (*(pf->vsi + (int)pf->lan_vsi) != vsi || (unsigned int)pf->hw.partition_id != 1U) 
    
#line 1322 
    goto return_label; else ;
  
#line 1324 
  if ((unsigned int)pf->lan_veb != 65535U) {
    int tmp_7;
    
#line 1325 
    struct i40e_veb *veb = pf->veb[(int)pf->lan_veb];
    
#line 1326 
    j = 0;
    
#line 1326 
    goto ldv_61761;
    ldv_61760: 
#line 1327 
    ;
    
#line 1327 
    p = (char *)veb;
    
#line 1328 
    p += i40e_gstrings_veb_stats[j].stat_offset;
    
#line 1329 
    tmp_7 = i;
    
#line 1329 
    i += 1;
    
#line 1329 
    if (i40e_gstrings_veb_stats[j].sizeof_stat == 8) 
#line 1329 
                                                     *(data + tmp_7) = *((u64 *)p); else 
                                                                    
#line 1329 
                                                                    *(data + tmp_7) = (unsigned long long)*((u32 *)p);
    
#line 1326 
    j += 1;
    ldv_61761: 
#line 1327 
    ;
    
#line 1326 
    if ((unsigned int)j <= 11U) 
#line 1328 
                                goto ldv_61760; else 
#line 1331 
                                                     goto ldv_61762;
    ldv_61762: 
#line 1332 
    ;
  }
  else ;
  
#line 1333 
  j = 0;
  
#line 1333 
  goto ldv_61767;
  ldv_61766: 
#line 1334 
  ;
  
#line 1334 
  p = (char *)pf + i40e_gstrings_stats[j].stat_offset;
  
#line 1335 
  tmp_8 = i;
  
#line 1335 
  i += 1;
  
#line 1335 
  if (i40e_gstrings_stats[j].sizeof_stat == 8) 
#line 1335 
                                               *(data + tmp_8) = *((u64 *)p); else 
                                                                    
#line 1335 
                                                                    *(data + tmp_8) = (unsigned long long)*((u32 *)p);
  
#line 1333 
  j += 1;
  ldv_61767: 
#line 1334 
  ;
  
#line 1333 
  if ((unsigned int)j <= 49U) 
#line 1335 
                              goto ldv_61766; else 
#line 1338 
                                                   goto ldv_61768;
  ldv_61768: 
#line 1339 
  ;
  
#line 1338 
  j = 0;
  
#line 1338 
  goto ldv_61770;
  ldv_61769: 
#line 1339 
  ;
  
#line 1339 
  tmp_9 = i;
  
#line 1339 
  i += 1;
  
#line 1339 
  *(data + tmp_9) = pf->stats.priority_xon_tx[j];
  
#line 1340 
  tmp_10 = i;
  
#line 1340 
  i += 1;
  
#line 1340 
  *(data + tmp_10) = pf->stats.priority_xoff_tx[j];
  
#line 1338 
  j += 1;
  ldv_61770: 
#line 1339 
  ;
  
#line 1338 
  if (j <= 7) 
#line 1340 
              goto ldv_61769; else 
#line 1343 
                                   goto ldv_61771;
  ldv_61771: 
#line 1344 
  ;
  
#line 1342 
  j = 0;
  
#line 1342 
  goto ldv_61773;
  ldv_61772: 
#line 1343 
  ;
  
#line 1343 
  tmp_11 = i;
  
#line 1343 
  i += 1;
  
#line 1343 
  *(data + tmp_11) = pf->stats.priority_xon_rx[j];
  
#line 1344 
  tmp_12 = i;
  
#line 1344 
  i += 1;
  
#line 1344 
  *(data + tmp_12) = pf->stats.priority_xoff_rx[j];
  
#line 1342 
  j += 1;
  ldv_61773: 
#line 1343 
  ;
  
#line 1342 
  if (j <= 7) 
#line 1344 
              goto ldv_61772; else 
#line 1347 
                                   goto ldv_61774;
  ldv_61774: 
#line 1348 
  ;
  
#line 1346 
  j = 0;
  
#line 1346 
  goto ldv_61776;
  ldv_61775: 
#line 1347 
  ;
  
#line 1347 
  tmp_13 = i;
  
#line 1347 
  i += 1;
  
#line 1347 
  *(data + tmp_13) = pf->stats.priority_xon_2_xoff[j];
  
#line 1346 
  j += 1;
  ldv_61776: 
#line 1347 
  ;
  
#line 1346 
  if (j <= 7) 
#line 1348 
              goto ldv_61775; else 
#line 1351 
                                   goto ldv_61777;
  ldv_61777: 
#line 1352 
  ;
  return_label: 
#line 1353 
                return;
}


#line 1350  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
{
  int i;
  
#line 1353 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1354 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1355 
  struct i40e_pf *pf = vsi->back;
  
#line 1356 
  char *p = (char *)data;
  
#line 1359 
  switch (stringset) {
    case (u32)0: 
#line 1360 
    ;
    
#line 1361 
    i = 0;
    
#line 1361 
    goto ldv_61790;
    ldv_61789: 
#line 1362 
    ;
    
#line 1362 
    memcpy((void *)data,(void const *)(& i40e_gstrings_test[i]),32UL);
    
#line 1363 
    data += 32U;
    
#line 1361 
    i += 1;
    ldv_61790: 
#line 1362 
    ;
    
#line 1361 
    if ((unsigned int)i <= 4U) 
#line 1363 
                               goto ldv_61789; else 
#line 1366 
                                                    goto ldv_61791;
    ldv_61791: 
#line 1367 
    ;
    
#line 1365 
    goto ldv_61792;
    case (u32)1: 
#line 1366 
    ;
    
#line 1367 
    i = 0;
    
#line 1367 
    goto ldv_61798;
    ldv_61797: 
#line 1368 
    ;
    
#line 1368 
    snprintf(p,32UL,"%s",(char const *)(& i40e_gstrings_net_stats[i].stat_string));
    
#line 1370 
    p += 32U;
    
#line 1367 
    i += 1;
    ldv_61798: 
#line 1368 
    ;
    
#line 1367 
    if ((unsigned int)i <= 10U) 
#line 1369 
                                goto ldv_61797; else 
#line 1372 
                                                     goto ldv_61799;
    ldv_61799: 
#line 1373 
    ;
    
#line 1372 
    i = 0;
    
#line 1372 
    goto ldv_61804;
    ldv_61803: 
#line 1373 
    ;
    
#line 1373 
    snprintf(p,32UL,"%s",(char const *)(& i40e_gstrings_misc_stats[i].stat_string));
    
#line 1375 
    p += 32U;
    
#line 1372 
    i += 1;
    ldv_61804: 
#line 1373 
    ;
    
#line 1372 
    if ((unsigned int)i <= 6U) 
#line 1374 
                               goto ldv_61803; else 
#line 1377 
                                                    goto ldv_61805;
    ldv_61805: 
#line 1378 
    ;
    
#line 1378 
    i = 0;
    
#line 1378 
    goto ldv_61810;
    ldv_61809: 
#line 1379 
    ;
    
#line 1379 
    snprintf(p,32UL,"%s",(char const *)(& i40e_gstrings_fcoe_stats[i].stat_string));
    
#line 1381 
    p += 32U;
    
#line 1378 
    i += 1;
    ldv_61810: 
#line 1379 
    ;
    
#line 1378 
    if ((unsigned int)i <= 7U) 
#line 1380 
                               goto ldv_61809; else 
#line 1383 
                                                    goto ldv_61811;
    ldv_61811: 
#line 1384 
    ;
    
#line 1384 
    i = 0;
    
#line 1384 
    goto ldv_61813;
    ldv_61812: 
#line 1385 
    ;
    
#line 1385 
    snprintf(p,32UL,"tx-%u.tx_packets",i);
    
#line 1386 
    p += 32U;
    
#line 1387 
    snprintf(p,32UL,"tx-%u.tx_bytes",i);
    
#line 1388 
    p += 32U;
    
#line 1389 
    snprintf(p,32UL,"rx-%u.rx_packets",i);
    
#line 1390 
    p += 32U;
    
#line 1391 
    snprintf(p,32UL,"rx-%u.rx_bytes",i);
    
#line 1392 
    p += 32U;
    
#line 1384 
    i += 1;
    ldv_61813: 
#line 1385 
    ;
    
#line 1384 
    if ((int)vsi->num_queue_pairs > i) 
#line 1386 
                                       goto ldv_61812; else 
#line 1389 
                                                            goto ldv_61814;
    ldv_61814: 
#line 1390 
    ;
    
#line 1394 
    if (*(pf->vsi + (int)pf->lan_vsi) != vsi || (unsigned int)pf->hw.partition_id != 1U) 
      
#line 1395 
      goto return_label; else ;
    
#line 1397 
    if ((unsigned int)pf->lan_veb != 65535U) {
      
#line 1398 
      i = 0;
      
#line 1398 
      goto ldv_61819;
      ldv_61818: 
#line 1399 
      ;
      
#line 1399 
      snprintf(p,32UL,"veb.%s",(char const *)(& i40e_gstrings_veb_stats[i].stat_string));
      
#line 1401 
      p += 32U;
      
#line 1398 
      i += 1;
      ldv_61819: 
#line 1399 
      ;
      
#line 1398 
      if ((unsigned int)i <= 11U) 
#line 1400 
                                  goto ldv_61818; else 
#line 1403 
                                                       goto ldv_61820;
      ldv_61820: 
#line 1404 
      ;
    }
    else ;
    
#line 1404 
    i = 0;
    
#line 1404 
    goto ldv_61825;
    ldv_61824: 
#line 1405 
    ;
    
#line 1405 
    snprintf(p,32UL,"port.%s",(char *)(& i40e_gstrings_stats[i].stat_string));
    
#line 1407 
    p += 32U;
    
#line 1404 
    i += 1;
    ldv_61825: 
#line 1405 
    ;
    
#line 1404 
    if ((unsigned int)i <= 49U) 
#line 1406 
                                goto ldv_61824; else 
#line 1409 
                                                     goto ldv_61826;
    ldv_61826: 
#line 1410 
    ;
    
#line 1409 
    i = 0;
    
#line 1409 
    goto ldv_61828;
    ldv_61827: 
#line 1410 
    ;
    
#line 1410 
    snprintf(p,32UL,"port.tx_priority_%u_xon",i);
    
#line 1412 
    p += 32U;
    
#line 1413 
    snprintf(p,32UL,"port.tx_priority_%u_xoff",i);
    
#line 1415 
    p += 32U;
    
#line 1409 
    i += 1;
    ldv_61828: 
#line 1410 
    ;
    
#line 1409 
    if (i <= 7) 
#line 1411 
                goto ldv_61827; else 
#line 1414 
                                     goto ldv_61829;
    ldv_61829: 
#line 1415 
    ;
    
#line 1417 
    i = 0;
    
#line 1417 
    goto ldv_61831;
    ldv_61830: 
#line 1418 
    ;
    
#line 1418 
    snprintf(p,32UL,"port.rx_priority_%u_xon",i);
    
#line 1420 
    p += 32U;
    
#line 1421 
    snprintf(p,32UL,"port.rx_priority_%u_xoff",i);
    
#line 1423 
    p += 32U;
    
#line 1417 
    i += 1;
    ldv_61831: 
#line 1418 
    ;
    
#line 1417 
    if (i <= 7) 
#line 1419 
                goto ldv_61830; else 
#line 1422 
                                     goto ldv_61832;
    ldv_61832: 
#line 1423 
    ;
    
#line 1425 
    i = 0;
    
#line 1425 
    goto ldv_61834;
    ldv_61833: 
#line 1426 
    ;
    
#line 1426 
    snprintf(p,32UL,"port.rx_priority_%u_xon_2_xoff",i);
    
#line 1428 
    p += 32U;
    
#line 1425 
    i += 1;
    ldv_61834: 
#line 1426 
    ;
    
#line 1425 
    if (i <= 7) 
#line 1427 
                goto ldv_61833; else 
#line 1430 
                                     goto ldv_61835;
    ldv_61835: 
#line 1431 
    ;
    
#line 1431 
    goto ldv_61792;
    case (u32)2: 
#line 1432 
    ;
    
#line 1433 
    i = 0;
    
#line 1433 
    goto ldv_61838;
    ldv_61837: 
#line 1434 
    ;
    
#line 1434 
    memcpy((void *)data,(void const *)(& i40e_priv_flags_strings[i]),32UL);
    
#line 1436 
    data += 32U;
    
#line 1433 
    i += 1;
    ldv_61838: 
#line 1434 
    ;
    
#line 1433 
    if (i == 0) 
#line 1435 
                goto ldv_61837; else 
#line 1438 
                                     goto ldv_61839;
    ldv_61839: 
#line 1439 
    ;
    
#line 1438 
    goto ldv_61792;
    default: 
#line 1439 
    ;
    
#line 1440 
    goto ldv_61792;
  }
  ldv_61792: 
#line 1442 
  ;
  return_label: 
#line 1443 
                return;
}


#line 1444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
{
  int __retres;
  
#line 1447 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  
#line 1450 
  if ((pf->flags & 33554432ULL) == 0ULL) {
    int tmp_0;
    
#line 1451 
    tmp_0 = ethtool_op_get_ts_info(dev,info);
    
#line 1451 
    __retres = tmp_0;
    
#line 1451 
    goto return_label;
  }
  else ;
  
#line 1453 
  info->so_timestamping = 95U;
  
#line 1460 
  if (pf->ptp_clock != (struct ptp_clock *)0) 
#line 1461 
                                              info->phc_index = ptp_clock_index(pf->ptp_clock); else 
                                                                    
#line 1463 
                                                                    info->phc_index = -1;
  
#line 1465 
  info->tx_types = 3U;
  
#line 1467 
  info->rx_filters = 32753U;
  
#line 1480 
  __retres = 0;
  return_label: 
#line 1480 
                return __retres;
}


#line 1483  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_link_test(struct net_device *netdev, u64 *data)
{
  int __retres;
  bool tmp_0;
  
#line 1485 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1486 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1488 
  if ((pf->msg_enable & 8192U) != 0U) 
#line 1488 
                                      netdev_info((struct net_device const *)netdev,"link test\n"); else ;
  
#line 1489 
  tmp_0 = i40e_get_link_status(& pf->hw);
  
#line 1489 
  if ((int)tmp_0 != 0) 
#line 1490 
                       *data = 0ULL; else 
#line 1492 
                                          *data = 1ULL;
  
#line 1494 
  __retres = (int)*data;
  
#line 1494 
  return __retres;
}


#line 1497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_reg_test(struct net_device *netdev, u64 *data)
{
  int __retres;
  i40e_status tmp_0;
  
#line 1499 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1500 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1502 
  if ((pf->msg_enable & 8192U) != 0U) 
#line 1502 
                                      netdev_info((struct net_device const *)netdev,"register test\n"); else ;
  
#line 1503 
  tmp_0 = i40e_diag_reg_test(& pf->hw);
  
#line 1503 
  *data = (unsigned long long)tmp_0;
  
#line 1505 
  __retres = (int)*data;
  
#line 1505 
  return __retres;
}


#line 1508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_eeprom_test(struct net_device *netdev, u64 *data)
{
  int __retres;
  i40e_status tmp_0;
  
#line 1510 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1511 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1513 
  if ((pf->msg_enable & 8192U) != 0U) 
#line 1513 
                                      netdev_info((struct net_device const *)netdev,"eeprom test\n"); else ;
  
#line 1514 
  tmp_0 = i40e_diag_eeprom_test(& pf->hw);
  
#line 1514 
  *data = (unsigned long long)tmp_0;
  
#line 1517 
  pf->hw.nvmupd_state = I40E_NVMUPD_STATE_INIT;
  
#line 1519 
  __retres = (int)*data;
  
#line 1519 
  return __retres;
}


#line 1522  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_intr_test(struct net_device *netdev, u64 *data)
{
  int __retres;
  
#line 1524 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1525 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1526 
  u16 swc_old = pf->sw_int_count;
  
#line 1528 
  if ((pf->msg_enable & 8192U) != 0U) 
#line 1528 
                                      netdev_info((struct net_device const *)netdev,"interrupt test\n"); else ;
  
#line 1529 
  writel(117440541U,(void volatile *)(pf->hw.hw_addr + 230528U));
  
#line 1535 
  usleep_range(1000UL,2000UL);
  
#line 1536 
  *data = (unsigned long long)((int)pf->sw_int_count == (int)swc_old);
  
#line 1538 
  __retres = (int)*data;
  
#line 1538 
  return __retres;
}


#line 1541  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_loopback_test(struct net_device *netdev, u64 *data)
{
  int __retres;
  
#line 1543 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1544 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1546 
  if ((pf->msg_enable & 8192U) != 0U) 
#line 1546 
                                      netdev_info((struct net_device const *)netdev,"loopback test not implemented\n"); else ;
  
#line 1547 
  *data = 0ULL;
  
#line 1549 
  __retres = (int)*data;
  
#line 1549 
  return __retres;
}


#line 1552  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
__inline static bool i40e_active_vfs(struct i40e_pf *pf)
{
  bool __retres;
  int i;
  
#line 1554 
  struct i40e_vf *vfs = pf->vf;
  
#line 1557 
  i = 0;
  
#line 1557 
  goto ldv_61883;
  ldv_61882: 
#line 1558 
  ;
  
#line 1558 
  if (((vfs + i)->vf_states & 1UL) != 0UL) {
    
#line 1559 
    __retres = (_Bool)1;
    
#line 1559 
    goto return_label;
  }
  else ;
  
#line 1557 
  i += 1;
  ldv_61883: 
#line 1558 
  ;
  
#line 1557 
  if (pf->num_alloc_vfs > i) 
#line 1559 
                             goto ldv_61882; else 
#line 1562 
                                                  goto ldv_61884;
  ldv_61884: 
#line 1563 
  ;
  
#line 1560 
  __retres = (_Bool)0;
  return_label: 
#line 1560 
                return __retres;
}


#line 1563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_diag_test(struct net_device *netdev, struct ethtool_test *eth_test, u64 *data)
{
  
#line 1566 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1567 
  bool if_running = netif_running((struct net_device const *)netdev);
  
#line 1568 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1570 
  if (eth_test->flags == 1U) {
    bool tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_5;
    int tmp_6;
    
#line 1572 
    if ((pf->msg_enable & 1U) != 0U) 
#line 1572 
                                     netdev_info((struct net_device const *)netdev,"offline testing starting\n"); else ;
    
#line 1574 
    clear_bit(0L,(unsigned long volatile *)(& pf->state));
    
#line 1576 
    tmp_1 = i40e_active_vfs(pf);
    
#line 1576 
    if ((int)tmp_1 != 0) {
      
#line 1577 
      dev_warn((struct device const *)(& (pf->pdev)->dev),"Please take active VFS offline and restart the adapter before running NIC diagnostics\n");
      
#line 1579 
      *data = 1ULL;
      
#line 1580 
      *(data + 1U) = 1ULL;
      
#line 1581 
      *(data + 2U) = 1ULL;
      
#line 1582 
      *(data + 3U) = 1ULL;
      
#line 1583 
      *(data + 4U) = 1ULL;
      
#line 1584 
      eth_test->flags |= 2U;
      
#line 1585 
      clear_bit(0L,(unsigned long volatile *)(& pf->state));
      
#line 1586 
      goto skip_ol_tests;
    }
    else ;
    
#line 1590 
    if ((int)if_running != 0) 
#line 1592 
                              dev_close(netdev); else 
#line 1594 
                                                      i40e_do_reset(pf,4096U);
    
#line 1599 
    tmp_2 = i40e_link_test(netdev,data + 4U);
    
#line 1599 
    if (tmp_2 != 0) 
#line 1600 
                    eth_test->flags |= 2U; else ;
    
#line 1602 
    tmp_3 = i40e_eeprom_test(netdev,data + 1U);
    
#line 1602 
    if (tmp_3 != 0) 
#line 1603 
                    eth_test->flags |= 2U; else ;
    
#line 1605 
    tmp_4 = i40e_intr_test(netdev,data + 2U);
    
#line 1605 
    if (tmp_4 != 0) 
#line 1606 
                    eth_test->flags |= 2U; else ;
    
#line 1608 
    tmp_5 = i40e_loopback_test(netdev,data + 3U);
    
#line 1608 
    if (tmp_5 != 0) 
#line 1609 
                    eth_test->flags |= 2U; else ;
    
#line 1612 
    tmp_6 = i40e_reg_test(netdev,data);
    
#line 1612 
    if (tmp_6 != 0) 
#line 1613 
                    eth_test->flags |= 2U; else ;
    
#line 1615 
    clear_bit(0L,(unsigned long volatile *)(& pf->state));
    
#line 1616 
    i40e_do_reset(pf,4096U);
    
#line 1618 
    if ((int)if_running != 0) 
#line 1619 
                              dev_open(netdev); else ;
  }
  else {
    int tmp_7;
    
#line 1622 
    if ((pf->msg_enable & 1U) != 0U) 
#line 1622 
                                     netdev_info((struct net_device const *)netdev,"online testing starting\n"); else ;
    
#line 1624 
    tmp_7 = i40e_link_test(netdev,data + 4U);
    
#line 1624 
    if (tmp_7 != 0) 
#line 1625 
                    eth_test->flags |= 2U; else ;
    
#line 1628 
    *data = 0ULL;
    
#line 1629 
    *(data + 1U) = 0ULL;
    
#line 1630 
    *(data + 2U) = 0ULL;
    
#line 1631 
    *(data + 3U) = 0ULL;
  }
  skip_ol_tests: 
#line 1634 
  ;
  
#line 1636 
  if ((pf->msg_enable & 1U) != 0U) 
#line 1636 
                                   netdev_info((struct net_device const *)netdev,"testing finished\n"); else ;
  
#line 1637 
  return;
}


#line 1639  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
  u16 wol_nvm_bits;
  
#line 1642 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1643 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1644 
  struct i40e_hw *hw = & pf->hw;
  
#line 1648 
  i40e_read_nvm_word(hw,(unsigned short)25,& wol_nvm_bits);
  
#line 1649 
  if ((((int)wol_nvm_bits >> (int)hw->port) & 1) != 0 || (unsigned int)hw->partition_id != 1U) {
    
#line 1650 
    wol->supported = 0U;
    
#line 1651 
    wol->wolopts = 0U;
  }
  else {
    int tmp_0;
    
#line 1653 
    wol->supported = 32U;
    
#line 1654 
    if ((int)pf->wol_en != 0) 
#line 1654 
                              tmp_0 = 32; else 
#line 1654 
                                               tmp_0 = 0;
    
#line 1654 
    wol->wolopts = (unsigned int)tmp_0;
  }
  
#line 1656 
  return;
}


#line 1663  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
  int __retres;
  u16 wol_nvm_bits;
  
#line 1665 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1666 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1667 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1668 
  struct i40e_hw *hw = & pf->hw;
  
#line 1672 
  if ((unsigned int)hw->partition_id != 1U) {
    
#line 1673 
    i40e_partition_setting_complaint(pf);
    
#line 1674 
    __retres = -95;
    
#line 1674 
    goto return_label;
  }
  else ;
  
#line 1677 
  if (*(pf->vsi + (int)pf->lan_vsi) != vsi) {
    
#line 1678 
    __retres = -95;
    
#line 1678 
    goto return_label;
  }
  else ;
  
#line 1681 
  i40e_read_nvm_word(hw,(unsigned short)25,& wol_nvm_bits);
  
#line 1682 
  if ((((int)wol_nvm_bits >> (int)hw->port) & 1) != 0) {
    
#line 1683 
    __retres = -95;
    
#line 1683 
    goto return_label;
  }
  else ;
  
#line 1686 
  if (wol->wolopts != 0U && wol->wolopts != 32U) {
    
#line 1687 
    __retres = -95;
    
#line 1687 
    goto return_label;
  }
  else ;
  
#line 1690 
  if ((int)pf->wol_en != (wol->wolopts != 0U)) {
    
#line 1691 
    pf->wol_en = (_Bool)(wol->wolopts != 0U);
    
#line 1692 
    device_set_wakeup_enable(& (pf->pdev)->dev,(_Bool)((bool)((int)pf->wol_en) != 0));
  }
  else ;
  
#line 1695 
  __retres = 0;
  return_label: 
#line 1695 
                return __retres;
}


#line 1698  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)
{
  int __retres;
  
#line 1701 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1702 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 1703 
  struct i40e_hw *hw = & pf->hw;
  
#line 1704 
  int blink_freq = 2;
  
#line 1706 
  switch ((unsigned int)state) {
    case (unsigned int)1: 
#line 1707 
    ;
    
#line 1708 
    pf->led_status = i40e_led_get(hw);
    
#line 1709 
    __retres = blink_freq;
    
#line 1709 
    goto return_label;
    case (unsigned int)2: 
#line 1710 
    ;
    
#line 1711 
    i40e_led_set(hw,15U,(_Bool)0);
    
#line 1712 
    goto ldv_61921;
    case (unsigned int)3: 
#line 1713 
    ;
    
#line 1714 
    i40e_led_set(hw,0U,(_Bool)0);
    
#line 1715 
    goto ldv_61921;
    case (unsigned int)0: 
#line 1716 
    ;
    
#line 1717 
    i40e_led_set(hw,pf->led_status,(_Bool)0);
    
#line 1718 
    goto ldv_61921;
    default: 
#line 1719 
    ;
    
#line 1720 
    goto ldv_61921;
  }
  ldv_61921: 
#line 1723 
  ;
  
#line 1723 
  __retres = 0;
  return_label: 
#line 1723 
                return __retres;
}


#line 1731  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
{
  int __retres;
  
#line 1734 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1735 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1737 
  ec->tx_max_coalesced_frames_irq = (unsigned int)vsi->work_limit;
  
#line 1738 
  ec->rx_max_coalesced_frames_irq = (unsigned int)vsi->work_limit;
  
#line 1740 
  if ((int)vsi->rx_itr_setting < 0) 
#line 1741 
                                    ec->use_adaptive_rx_coalesce = 1U; else ;
  
#line 1743 
  if ((int)vsi->tx_itr_setting < 0) 
#line 1744 
                                    ec->use_adaptive_tx_coalesce = 1U; else ;
  
#line 1746 
  ec->rx_coalesce_usecs = (unsigned int)vsi->rx_itr_setting & 4294934527U;
  
#line 1747 
  ec->tx_coalesce_usecs = (unsigned int)vsi->tx_itr_setting & 4294934527U;
  
#line 1749 
  __retres = 0;
  
#line 1749 
  return __retres;
}


#line 1752  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
{
  int __retres;
  struct i40e_q_vector *q_vector;
  u16 vector;
  int i;
  
#line 1755 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1757 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1758 
  struct i40e_pf *pf = vsi->back;
  
#line 1759 
  struct i40e_hw *hw = & pf->hw;
  
#line 1763 
  if (ec->tx_max_coalesced_frames_irq != 0U || ec->rx_max_coalesced_frames_irq != 0U) 
    
#line 1764 
    vsi->work_limit = (unsigned short)ec->tx_max_coalesced_frames_irq; else ;
  
#line 1766 
  vector = (unsigned short)vsi->base_vector;
  
#line 1767 
  if (ec->rx_coalesce_usecs + 4294967294U <= 8158U) 
#line 1769 
                                                    vsi->rx_itr_setting = (unsigned short)ec->rx_coalesce_usecs;
  else 
    
#line 1770 
    if (ec->rx_coalesce_usecs == 0U) {
      
#line 1771 
      vsi->rx_itr_setting = (unsigned short)ec->rx_coalesce_usecs;
      
#line 1772 
      if (ec->use_adaptive_rx_coalesce != 0U) {
        
#line 1773 
        if ((pf->msg_enable & 1U) != 0U) 
#line 1773 
                                         netdev_info((struct net_device const *)netdev,"rx-usecs=0, need to disable adaptive-rx for a complete disable\n"); else ;
      }
      else ;
    }
    else {
      
#line 1775 
      if ((pf->msg_enable & 1U) != 0U) 
#line 1775 
                                       netdev_info((struct net_device const *)netdev,"Invalid value, rx-usecs range is 0-8160\n"); else ;
      
#line 1776 
      __retres = -22;
      
#line 1776 
      goto return_label;
    }
  
#line 1779 
  if (ec->tx_coalesce_usecs + 4294967294U <= 8158U) 
#line 1781 
                                                    vsi->tx_itr_setting = (unsigned short)ec->tx_coalesce_usecs;
  else 
    
#line 1782 
    if (ec->tx_coalesce_usecs == 0U) {
      
#line 1783 
      vsi->tx_itr_setting = (unsigned short)ec->tx_coalesce_usecs;
      
#line 1784 
      if (ec->use_adaptive_tx_coalesce != 0U) {
        
#line 1785 
        if ((pf->msg_enable & 1U) != 0U) 
#line 1785 
                                         netdev_info((struct net_device const *)netdev,"tx-usecs=0, need to disable adaptive-tx for a complete disable\n"); else ;
      }
      else ;
    }
    else {
      
#line 1787 
      if ((pf->msg_enable & 1U) != 0U) 
#line 1787 
                                       netdev_info((struct net_device const *)netdev,"Invalid value, tx-usecs range is 0-8160\n"); else ;
      
#line 1789 
      __retres = -22;
      
#line 1789 
      goto return_label;
    }
  
#line 1792 
  if (ec->use_adaptive_rx_coalesce != 0U) 
#line 1793 
                                          vsi->rx_itr_setting = (unsigned short)((unsigned int)vsi->rx_itr_setting | 32768U); else 
                                                                    
#line 1795 
                                                                    vsi->rx_itr_setting = (unsigned short)((unsigned int)vsi->rx_itr_setting & 32767U);
  
#line 1797 
  if (ec->use_adaptive_tx_coalesce != 0U) 
#line 1798 
                                          vsi->tx_itr_setting = (unsigned short)((unsigned int)vsi->tx_itr_setting | 32768U); else 
                                                                    
#line 1800 
                                                                    vsi->tx_itr_setting = (unsigned short)((unsigned int)vsi->tx_itr_setting & 32767U);
  
#line 1802 
  i = 0;
  
#line 1802 
  goto ldv_61943;
  ldv_61942: 
#line 1803 
  ;
  
#line 1803 
  q_vector = *(vsi->q_vectors + i);
  
#line 1804 
  q_vector->rx.itr = (unsigned short)((unsigned int)((unsigned short)((int)vsi->rx_itr_setting >> 1)) & 49151U);
  
#line 1805 
  writel((unsigned int)q_vector->rx.itr,(void volatile *)(hw->hw_addr + ((int)vector + 49151) * 4));
  
#line 1806 
  q_vector->tx.itr = (unsigned short)((unsigned int)((unsigned short)((int)vsi->tx_itr_setting >> 1)) & 49151U);
  
#line 1807 
  writel((unsigned int)q_vector->tx.itr,(void volatile *)(hw->hw_addr + ((int)vector + 49663) * 4));
  
#line 1808 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 1802 
  i += 1;
  
#line 1802 
  vector = (u16)((int)vector + 1);
  ldv_61943: 
#line 1803 
  ;
  
#line 1802 
  if (vsi->num_q_vectors > i) 
#line 1804 
                              goto ldv_61942; else 
#line 1807 
                                                   goto ldv_61944;
  ldv_61944: 
#line 1808 
  ;
  
#line 1811 
  __retres = 0;
  return_label: 
#line 1811 
                return __retres;
}


#line 1821  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_rss_hash_opts(struct i40e_pf *pf, struct ethtool_rxnfc *cmd)
{
  int __retres;
  
#line 1823 
  cmd->data = 0ULL;
  
#line 1825 
  if ((*(pf->vsi + (int)pf->lan_vsi))->rxnfc.data != 0ULL) {
    
#line 1826 
    cmd->data = (*(pf->vsi + (int)pf->lan_vsi))->rxnfc.data;
    
#line 1827 
    cmd->flow_type = (*(pf->vsi + (int)pf->lan_vsi))->rxnfc.flow_type;
    
#line 1828 
    __retres = 0;
    
#line 1828 
    goto return_label;
  }
  else ;
  
#line 1831 
  switch (cmd->flow_type) {
    case (__u32)1: 
#line 1832 
    ;
    case (__u32)2: 
#line 1833 
    ;
    
#line 1834 
    cmd->data |= 192ULL;
    case (__u32)3: 
#line 1836 
    ;
    case (__u32)4: 
#line 1837 
    ;
    case (__u32)9: 
#line 1838 
    ;
    case (__u32)10: 
#line 1839 
    ;
    case (__u32)16: 
#line 1840 
    ;
    
#line 1841 
    cmd->data |= 48ULL;
    
#line 1842 
    goto ldv_61956;
    case (__u32)5: 
#line 1843 
    ;
    case (__u32)6: 
#line 1844 
    ;
    
#line 1845 
    cmd->data |= 192ULL;
    case (__u32)7: 
#line 1847 
    ;
    case (__u32)8: 
#line 1848 
    ;
    case (__u32)11: 
#line 1849 
    ;
    case (__u32)12: 
#line 1850 
    ;
    case (__u32)17: 
#line 1851 
    ;
    
#line 1852 
    cmd->data |= 48ULL;
    
#line 1853 
    goto ldv_61956;
    default: 
#line 1854 
    ;
    
#line 1855 
    __retres = -22;
    
#line 1855 
    goto return_label;
  }
  ldv_61956: 
#line 1858 
  ;
  
#line 1858 
  __retres = 0;
  return_label: 
#line 1858 
                return __retres;
}


#line 1872  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_ethtool_fdir_all(struct i40e_pf *pf, struct ethtool_rxnfc *cmd, u32 *rule_locs)
{
  int __retres;
  struct i40e_fdir_filter *rule;
  struct hlist_node *node2;
  int tmp;
  struct i40e_fdir_filter *tmp_2;
  struct i40e_fdir_filter *tmp_5;
  
#line 1878 
  int cnt = 0;
  
#line 1881 
  tmp = i40e_get_fd_cnt_all(pf);
  
#line 1881 
  cmd->data = (unsigned long long)tmp;
  {
    struct i40e_fdir_filter *tmp_1;
    
#line 1883 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    
#line 1883 
    if (____ptr != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp_0;
      {
        
#line 1883 
        struct hlist_node const *__mptr = (struct hlist_node const *)____ptr;
        
#line 1883 
        tmp_0 = (struct i40e_fdir_filter *)__mptr;
      }
      
#line 1883 
      tmp_1 = tmp_0;
    }
    else 
#line 1883 
         tmp_1 = (struct i40e_fdir_filter *)0;
    
#line 1883 
    tmp_2 = tmp_1;
  }
  
#line 1883 
  rule = tmp_2;
  
#line 1883 
  goto ldv_61983;
  ldv_61982: 
#line 1884 
  ;
  
#line 1885 
  if (cmd->rule_cnt == (unsigned int)cnt) {
    
#line 1886 
    __retres = -90;
    
#line 1886 
    goto return_label;
  }
  else ;
  
#line 1888 
  *(rule_locs + cnt) = rule->fd_id;
  
#line 1889 
  cnt += 1;
  {
    struct i40e_fdir_filter *tmp_4;
    
#line 1883 
    struct hlist_node *____ptr_0 = node2;
    
#line 1883 
    if (____ptr_0 != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp_3;
      {
        
#line 1883 
        struct hlist_node const *__mptr_0 = (struct hlist_node const *)____ptr_0;
        
#line 1883 
        tmp_3 = (struct i40e_fdir_filter *)__mptr_0;
      }
      
#line 1883 
      tmp_4 = tmp_3;
    }
    else 
#line 1883 
         tmp_4 = (struct i40e_fdir_filter *)0;
    
#line 1883 
    tmp_5 = tmp_4;
  }
  
#line 1883 
  rule = tmp_5;
  ldv_61983: 
#line 1885 
  ;
  
#line 1883 
  if (rule != (struct i40e_fdir_filter *)0) {
    
#line 1883 
    node2 = rule->fdir_node.next;
    
#line 1883 
    if (1 != 0) 
#line 1885 
                goto ldv_61982; else 
#line 1888 
                                     goto ldv_61984;
  }
  else 
#line 1888 
       goto ldv_61984;
  ldv_61984: 
#line 1889 
  ;
  
#line 1892 
  cmd->rule_cnt = (unsigned int)cnt;
  
#line 1894 
  __retres = 0;
  return_label: 
#line 1894 
                return __retres;
}


#line 1907  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_ethtool_fdir_entry(struct i40e_pf *pf, struct ethtool_rxnfc *cmd)
{
  int __retres;
  struct hlist_node *node2;
  struct i40e_fdir_filter *tmp_1;
  struct i40e_fdir_filter *tmp_4;
  
#line 1910 
  struct ethtool_rx_flow_spec *fsp = & cmd->fs;
  
#line 1912 
  struct i40e_fdir_filter *rule = (struct i40e_fdir_filter *)0;
  {
    struct i40e_fdir_filter *tmp_0;
    
#line 1915 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    
#line 1915 
    if (____ptr != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp;
      {
        
#line 1915 
        struct hlist_node const *__mptr = (struct hlist_node const *)____ptr;
        
#line 1915 
        tmp = (struct i40e_fdir_filter *)__mptr;
      }
      
#line 1915 
      tmp_0 = tmp;
    }
    else 
#line 1915 
         tmp_0 = (struct i40e_fdir_filter *)0;
    
#line 1915 
    tmp_1 = tmp_0;
  }
  
#line 1915 
  rule = tmp_1;
  
#line 1915 
  goto ldv_62003;
  ldv_62002: 
#line 1916 
  ;
  
#line 1917 
  if (fsp->location <= rule->fd_id) 
#line 1918 
                                    goto ldv_62001; else ;
  {
    struct i40e_fdir_filter *tmp_3;
    
#line 1915 
    struct hlist_node *____ptr_0 = node2;
    
#line 1915 
    if (____ptr_0 != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp_2;
      {
        
#line 1915 
        struct hlist_node const *__mptr_0 = (struct hlist_node const *)____ptr_0;
        
#line 1915 
        tmp_2 = (struct i40e_fdir_filter *)__mptr_0;
      }
      
#line 1915 
      tmp_3 = tmp_2;
    }
    else 
#line 1915 
         tmp_3 = (struct i40e_fdir_filter *)0;
    
#line 1915 
    tmp_4 = tmp_3;
  }
  
#line 1915 
  rule = tmp_4;
  ldv_62003: 
#line 1917 
  ;
  
#line 1915 
  if (rule != (struct i40e_fdir_filter *)0) {
    
#line 1915 
    node2 = rule->fdir_node.next;
    
#line 1915 
    if (1 != 0) 
#line 1917 
                goto ldv_62002; else 
#line 1920 
                                     goto ldv_62001;
  }
  else 
#line 1920 
       goto ldv_62001;
  ldv_62001: 
#line 1921 
  ;
  
#line 1921 
  if (rule == (struct i40e_fdir_filter *)0 || fsp->location != rule->fd_id) {
    
#line 1922 
    __retres = -22;
    
#line 1922 
    goto return_label;
  }
  else ;
  
#line 1924 
  fsp->flow_type = (unsigned int)rule->flow_type;
  
#line 1925 
  if (fsp->flow_type == 13U) {
    
#line 1926 
    fsp->h_u.usr_ip4_spec.ip_ver = (unsigned char)1U;
    
#line 1927 
    fsp->h_u.usr_ip4_spec.proto = (unsigned char)0U;
    
#line 1928 
    fsp->m_u.usr_ip4_spec.proto = (unsigned char)0U;
  }
  else ;
  
#line 1934 
  fsp->h_u.tcp_ip4_spec.psrc = rule->dst_port;
  
#line 1935 
  fsp->h_u.tcp_ip4_spec.pdst = rule->src_port;
  
#line 1936 
  fsp->h_u.tcp_ip4_spec.ip4src = rule->dst_ip[0];
  
#line 1937 
  fsp->h_u.tcp_ip4_spec.ip4dst = rule->src_ip[0];
  
#line 1939 
  if ((unsigned int)rule->dest_ctl == 0U) 
#line 1940 
                                          fsp->ring_cookie = 18446744073709551615ULL; else 
                                                                    
#line 1942 
                                                                    fsp->ring_cookie = (unsigned long long)rule->q_index;
  
#line 1944 
  if ((int)rule->dest_vsi != (int)(*(pf->vsi + (int)pf->lan_vsi))->id) {
    struct i40e_vsi *vsi;
    
#line 1947 
    vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)rule->dest_vsi));
    
#line 1948 
    if (vsi != (struct i40e_vsi *)0 && vsi->type == (unsigned int)I40E_VSI_SRIOV) {
      
#line 1949 
      if (0 != 0) 
#line 1949 
                  fsp->h_ext.data[1] = ((unsigned int)vsi->vf_id << 24) | (((unsigned int)vsi->vf_id << 8) & 16711680U); else 
                                                                    
#line 1949 
                                                                    fsp->h_ext.data[1] = __fswab32((unsigned int)vsi->vf_id);
      
#line 1950 
      fsp->m_ext.data[1] = 16777216U;
    }
    else ;
  }
  else ;
  
#line 1954 
  __retres = 0;
  return_label: 
#line 1954 
                return __retres;
}


#line 1964  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd, u32 *rule_locs)
{
  
#line 1967 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1968 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1969 
  struct i40e_pf *pf = vsi->back;
  
#line 1970 
  int ret = -95;
  
#line 1972 
  switch (cmd->cmd) {
    int tmp_0;
    case (__u32)45: 
#line 1973 
    ;
    
#line 1974 
    cmd->data = (unsigned long long)vsi->alloc_queue_pairs;
    
#line 1975 
    ret = 0;
    
#line 1976 
    goto ldv_62015;
    case (__u32)41: 
#line 1977 
    ;
    
#line 1978 
    ret = i40e_get_rss_hash_opts(pf,cmd);
    
#line 1979 
    goto ldv_62015;
    case (__u32)46: 
#line 1980 
    ;
    
#line 1981 
    cmd->rule_cnt = (unsigned int)pf->fdir_pf_active_filters;
    
#line 1983 
    tmp_0 = i40e_get_fd_cnt_all(pf);
    
#line 1983 
    cmd->data = (unsigned long long)tmp_0;
    
#line 1984 
    ret = 0;
    
#line 1985 
    goto ldv_62015;
    case (__u32)47: 
#line 1986 
    ;
    
#line 1987 
    ret = i40e_get_ethtool_fdir_entry(pf,cmd);
    
#line 1988 
    goto ldv_62015;
    case (__u32)48: 
#line 1989 
    ;
    
#line 1990 
    ret = i40e_get_ethtool_fdir_all(pf,cmd,rule_locs);
    
#line 1991 
    goto ldv_62015;
    default: 
#line 1992 
    ;
    
#line 1993 
    goto ldv_62015;
  }
  ldv_62015: 
#line 1996 
  ;
  
#line 1996 
  return ret;
}


#line 2006  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_rss_hash_opt(struct i40e_pf *pf, struct ethtool_rxnfc *nfc)
{
  int __retres;
  unsigned int tmp;
  unsigned int tmp_0;
  
#line 2008 
  struct i40e_hw *hw = & pf->hw;
  
#line 2009 
  tmp = readl((void const volatile *)(hw->hw_addr + 2382080U));
  
#line 2010 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + 2382208U));
  
#line 2009 
  u64 hena = (unsigned long long)tmp | ((unsigned long long)tmp_0 << 32);
  
#line 2015 
  if ((nfc->data & 18446744073709551375ULL) != 0ULL) {
    
#line 2017 
    __retres = -22;
    
#line 2017 
    goto return_label;
  }
  else ;
  
#line 2020 
  if ((nfc->data & 16ULL) == 0ULL || (nfc->data & 32ULL) == 0ULL) {
    
#line 2022 
    __retres = -22;
    
#line 2022 
    goto return_label;
  }
  else ;
  
#line 2024 
  switch (nfc->flow_type) {
    case (__u32)1: 
#line 2025 
    ;
    
#line 2026 
    switch (nfc->data & 192ULL) {
      case (unsigned long long)0: 
#line 2027 
      ;
      
#line 2028 
      hena &= 18446744065119617023ULL;
      
#line 2029 
      goto ldv_62029;
      case (unsigned long long)192: 
#line 2030 
      ;
      
#line 2031 
      hena |= 8589934592ULL;
      
#line 2032 
      goto ldv_62029;
      default: 
#line 2033 
      ;
      
#line 2034 
      __retres = -22;
      
#line 2034 
      goto return_label;
    }
    ldv_62029: 
#line 2036 
    ;
    
#line 2036 
    goto ldv_62032;
    case (__u32)5: 
#line 2037 
    ;
    
#line 2038 
    switch (nfc->data & 192ULL) {
      case (unsigned long long)0: 
#line 2039 
      ;
      
#line 2040 
      hena &= 18446735277616529407ULL;
      
#line 2041 
      goto ldv_62035;
      case (unsigned long long)192: 
#line 2042 
      ;
      
#line 2043 
      hena |= 8796093022208ULL;
      
#line 2044 
      goto ldv_62035;
      default: 
#line 2045 
      ;
      
#line 2046 
      __retres = -22;
      
#line 2046 
      goto return_label;
    }
    ldv_62035: 
#line 2048 
    ;
    
#line 2048 
    goto ldv_62032;
    case (__u32)2: 
#line 2049 
    ;
    
#line 2050 
    switch (nfc->data & 192ULL) {
      case (unsigned long long)0: 
#line 2051 
      ;
      
#line 2052 
      hena &= 18446744002842591231ULL;
      
#line 2054 
      goto ldv_62040;
      case (unsigned long long)192: 
#line 2055 
      ;
      
#line 2056 
      hena |= 70866960384ULL;
      
#line 2058 
      goto ldv_62040;
      default: 
#line 2059 
      ;
      
#line 2060 
      __retres = -22;
      
#line 2060 
      goto return_label;
    }
    ldv_62040: 
#line 2062 
    ;
    
#line 2062 
    goto ldv_62032;
    case (__u32)6: 
#line 2063 
    ;
    
#line 2064 
    switch (nfc->data & 192ULL) {
      case (unsigned long long)0: 
#line 2065 
      ;
      
#line 2066 
      hena &= 18446671505942118399ULL;
      
#line 2068 
      goto ldv_62045;
      case (unsigned long long)192: 
#line 2069 
      ;
      
#line 2070 
      hena |= 72567767433216ULL;
      
#line 2072 
      goto ldv_62045;
      default: 
#line 2073 
      ;
      
#line 2074 
      __retres = -22;
      
#line 2074 
      goto return_label;
    }
    ldv_62045: 
#line 2076 
    ;
    
#line 2076 
    goto ldv_62032;
    case (__u32)4: 
#line 2077 
    ;
    case (__u32)9: 
#line 2078 
    ;
    case (__u32)10: 
#line 2079 
    ;
    case (__u32)3: 
#line 2080 
    ;
    
#line 2081 
    if ((nfc->data & 64ULL) != 0ULL || (nfc->data & 128ULL) != 0ULL) {
      
#line 2083 
      __retres = -22;
      
#line 2083 
      goto return_label;
    }
    else ;
    
#line 2084 
    hena |= 34359738368ULL;
    
#line 2085 
    goto ldv_62032;
    case (__u32)8: 
#line 2086 
    ;
    case (__u32)11: 
#line 2087 
    ;
    case (__u32)12: 
#line 2088 
    ;
    case (__u32)7: 
#line 2089 
    ;
    
#line 2090 
    if ((nfc->data & 64ULL) != 0ULL || (nfc->data & 128ULL) != 0ULL) {
      
#line 2092 
      __retres = -22;
      
#line 2092 
      goto return_label;
    }
    else ;
    
#line 2093 
    hena |= 35184372088832ULL;
    
#line 2094 
    goto ldv_62032;
    case (__u32)16: 
#line 2095 
    ;
    
#line 2096 
    hena |= 103079215104ULL;
    
#line 2098 
    goto ldv_62032;
    case (__u32)17: 
#line 2099 
    ;
    
#line 2100 
    hena |= 105553116266496ULL;
    
#line 2102 
    goto ldv_62032;
    default: 
#line 2103 
    ;
    
#line 2104 
    __retres = -22;
    
#line 2104 
    goto return_label;
  }
  ldv_62032: 
#line 2107 
  ;
  
#line 2107 
  writel((unsigned int)hena,(void volatile *)(hw->hw_addr + 2382080U));
  
#line 2108 
  writel((unsigned int)(hena >> 32),(void volatile *)(hw->hw_addr + 2382208U));
  
#line 2109 
  readl((void const volatile *)(hw->hw_addr + 745772U));
  
#line 2112 
  (*(pf->vsi + (int)pf->lan_vsi))->rxnfc = *nfc;
  
#line 2114 
  __retres = 0;
  return_label: 
#line 2114 
                return __retres;
}


#line 2124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static bool i40e_match_fdir_input_set(struct i40e_fdir_filter *rule, struct i40e_fdir_filter *input)
{
  bool __retres;
  
#line 2127 
  if (((rule->dst_ip[0] != input->dst_ip[0] || rule->src_ip[0] != input->src_ip[0]) || (int)rule->dst_port != (int)input->dst_port) || (int)rule->src_port != (int)input->src_port) {
    
#line 2131 
    __retres = (_Bool)0;
    
#line 2131 
    goto return_label;
  }
  else ;
  
#line 2132 
  __retres = (_Bool)1;
  return_label: 
#line 2132 
                return __retres;
}


#line 2147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_update_ethtool_fdir_entry(struct i40e_vsi *vsi, struct i40e_fdir_filter *input, u16 sw_idx, struct ethtool_rxnfc *cmd)
{
  int __retres;
  struct i40e_fdir_filter *rule;
  struct i40e_fdir_filter *parent;
  struct hlist_node *node2;
  struct i40e_fdir_filter *tmp_1;
  struct i40e_fdir_filter *tmp_4;
  
#line 2153 
  struct i40e_pf *pf = vsi->back;
  
#line 2155 
  int err = -22;
  
#line 2157 
  parent = (struct i40e_fdir_filter *)0;
  
#line 2158 
  rule = (struct i40e_fdir_filter *)0;
  {
    struct i40e_fdir_filter *tmp_0;
    
#line 2160 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    
#line 2160 
    if (____ptr != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp;
      {
        
#line 2160 
        struct hlist_node const *__mptr = (struct hlist_node const *)____ptr;
        
#line 2160 
        tmp = (struct i40e_fdir_filter *)__mptr;
      }
      
#line 2160 
      tmp_0 = tmp;
    }
    else 
#line 2160 
         tmp_0 = (struct i40e_fdir_filter *)0;
    
#line 2160 
    tmp_1 = tmp_0;
  }
  
#line 2160 
  rule = tmp_1;
  
#line 2160 
  goto ldv_62085;
  ldv_62084: 
#line 2161 
  ;
  
#line 2163 
  if (rule->fd_id >= (unsigned int)sw_idx) 
#line 2164 
                                           goto ldv_62083; else ;
  
#line 2165 
  parent = rule;
  {
    struct i40e_fdir_filter *tmp_3;
    
#line 2160 
    struct hlist_node *____ptr_0 = node2;
    
#line 2160 
    if (____ptr_0 != (struct hlist_node *)0) {
      struct i40e_fdir_filter *tmp_2;
      {
        
#line 2160 
        struct hlist_node const *__mptr_0 = (struct hlist_node const *)____ptr_0;
        
#line 2160 
        tmp_2 = (struct i40e_fdir_filter *)__mptr_0;
      }
      
#line 2160 
      tmp_3 = tmp_2;
    }
    else 
#line 2160 
         tmp_3 = (struct i40e_fdir_filter *)0;
    
#line 2160 
    tmp_4 = tmp_3;
  }
  
#line 2160 
  rule = tmp_4;
  ldv_62085: 
#line 2162 
  ;
  
#line 2160 
  if (rule != (struct i40e_fdir_filter *)0) {
    
#line 2160 
    node2 = rule->fdir_node.next;
    
#line 2160 
    if (1 != 0) 
#line 2162 
                goto ldv_62084; else 
#line 2165 
                                     goto ldv_62083;
  }
  else 
#line 2165 
       goto ldv_62083;
  ldv_62083: 
#line 2166 
  ;
  
#line 2169 
  if (rule != (struct i40e_fdir_filter *)0 && rule->fd_id == (unsigned int)sw_idx) {
    
#line 2170 
    if (input != (struct i40e_fdir_filter *)0) {
      int tmp_6;
      bool tmp_5;
      
#line 2170 
      tmp_5 = i40e_match_fdir_input_set(rule,input);
      
#line 2170 
      if (tmp_5) 
#line 2170 
                 tmp_6 = 0; else 
#line 2170 
                                 tmp_6 = 1;
      
#line 2170 
      if (tmp_6) 
#line 2171 
                 err = i40e_add_del_fdir(vsi,rule,(_Bool)0); else 
#line 2170 
                                                                  goto _LAND;
    }
    else {
      _LAND: 
#line 2172 
      ;
      
#line 2172 
      if (input == (struct i40e_fdir_filter *)0) 
#line 2173 
                                                 err = i40e_add_del_fdir(vsi,rule,(_Bool)0); else ;
    }
    
#line 2174 
    hlist_del(& rule->fdir_node);
    
#line 2175 
    kfree((void const *)rule);
    
#line 2176 
    pf->fdir_pf_active_filters = (u16)((int)pf->fdir_pf_active_filters - 1);
  }
  else ;
  
#line 2182 
  if (input == (struct i40e_fdir_filter *)0) {
    
#line 2183 
    __retres = err;
    
#line 2183 
    goto return_label;
  }
  else ;
  
#line 2186 
  INIT_HLIST_NODE(& input->fdir_node);
  
#line 2189 
  if (parent != (struct i40e_fdir_filter *)0) 
#line 2190 
                                              hlist_add_behind(& input->fdir_node,& parent->fdir_node); else 
                                                                    
#line 2192 
                                                                    hlist_add_head(& input->fdir_node,& pf->fdir_filter_list);
  
#line 2196 
  pf->fdir_pf_active_filters = (u16)((int)pf->fdir_pf_active_filters + 1);
  
#line 2198 
  __retres = 0;
  return_label: 
#line 2198 
                return __retres;
}


#line 2211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_del_fdir_entry(struct i40e_vsi *vsi, struct ethtool_rxnfc *cmd)
{
  int __retres;
  int tmp;
  int tmp_1;
  
#line 2214 
  struct ethtool_rx_flow_spec *fsp = & cmd->fs;
  
#line 2216 
  struct i40e_pf *pf = vsi->back;
  
#line 2217 
  int ret = 0;
  
#line 2219 
  tmp = constant_test_bit(9L,(unsigned long const volatile *)(& pf->state));
  
#line 2219 
  if (tmp != 0) {
    
#line 2221 
    __retres = -16;
    
#line 2221 
    goto return_label;
  }
  else {
    int tmp_0;
    
#line 2219 
    tmp_0 = constant_test_bit(10L,(unsigned long const volatile *)(& pf->state));
    
#line 2219 
    if (tmp_0 != 0) {
      
#line 2221 
      __retres = -16;
      
#line 2221 
      goto return_label;
    }
    else ;
  }
  
#line 2223 
  tmp_1 = constant_test_bit(22L,(unsigned long const volatile *)(& pf->state));
  
#line 2223 
  if (tmp_1 != 0) {
    
#line 2224 
    __retres = -16;
    
#line 2224 
    goto return_label;
  }
  else ;
  
#line 2226 
  ret = i40e_update_ethtool_fdir_entry(vsi,(struct i40e_fdir_filter *)0,(unsigned short)((int)((unsigned short)fsp->location)),cmd);
  
#line 2228 
  i40e_fdir_check_and_reenable(pf);
  
#line 2229 
  __retres = ret;
  return_label: 
#line 2229 
                return __retres;
}


#line 2240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_add_fdir_ethtool(struct i40e_vsi *vsi, struct ethtool_rxnfc *cmd)
{
  int __retres;
  struct ethtool_rx_flow_spec *fsp;
  struct i40e_fdir_filter *input;
  struct i40e_pf *pf;
  u16 vf_id;
  int tmp;
  int tmp_1;
  int tmp_7;
  
#line 2246 
  int ret = -22;
  
#line 2249 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 2250 
    __retres = -22;
    
#line 2250 
    goto return_label;
  }
  else ;
  
#line 2252 
  pf = vsi->back;
  
#line 2254 
  if ((pf->flags & 2097152ULL) == 0ULL) {
    
#line 2255 
    __retres = -95;
    
#line 2255 
    goto return_label;
  }
  else ;
  
#line 2257 
  if ((pf->auto_disable_flags & 2097152ULL) != 0ULL) {
    
#line 2258 
    __retres = -28;
    
#line 2258 
    goto return_label;
  }
  else ;
  
#line 2260 
  tmp = constant_test_bit(9L,(unsigned long const volatile *)(& pf->state));
  
#line 2260 
  if (tmp != 0) {
    
#line 2262 
    __retres = -16;
    
#line 2262 
    goto return_label;
  }
  else {
    int tmp_0;
    
#line 2260 
    tmp_0 = constant_test_bit(10L,(unsigned long const volatile *)(& pf->state));
    
#line 2260 
    if (tmp_0 != 0) {
      
#line 2262 
      __retres = -16;
      
#line 2262 
      goto return_label;
    }
    else ;
  }
  
#line 2264 
  tmp_1 = constant_test_bit(22L,(unsigned long const volatile *)(& pf->state));
  
#line 2264 
  if (tmp_1 != 0) {
    
#line 2265 
    __retres = -16;
    
#line 2265 
    goto return_label;
  }
  else ;
  
#line 2267 
  fsp = & cmd->fs;
  
#line 2269 
  if (fsp->location >= pf->hw.func_caps.fd_filters_best_effort + pf->hw.func_caps.fd_filters_guaranteed) {
    
#line 2271 
    __retres = -22;
    
#line 2271 
    goto return_label;
  }
  else ;
  
#line 2274 
  if (fsp->ring_cookie != 18446744073709551615ULL && fsp->ring_cookie >= (unsigned long long)vsi->num_queue_pairs) {
    
#line 2276 
    __retres = -22;
    
#line 2276 
    goto return_label;
  }
  else ;
  
#line 2278 
  input = (struct i40e_fdir_filter *)kzalloc_2(80UL,208U);
  
#line 2280 
  if (input == (struct i40e_fdir_filter *)0) {
    
#line 2281 
    __retres = -12;
    
#line 2281 
    goto return_label;
  }
  else ;
  
#line 2283 
  input->fd_id = fsp->location;
  
#line 2285 
  if (fsp->ring_cookie == 18446744073709551615ULL) 
#line 2286 
                                                   input->dest_ctl = (unsigned char)0U; else 
                                                                    
#line 2288 
                                                                    input->dest_ctl = (unsigned char)1U;
  
#line 2291 
  input->q_index = (unsigned short)fsp->ring_cookie;
  
#line 2292 
  input->flex_off = (unsigned char)0U;
  
#line 2293 
  input->pctype = (unsigned char)0U;
  
#line 2294 
  input->dest_vsi = vsi->id;
  
#line 2295 
  input->fd_status = (unsigned char)1U;
  
#line 2296 
  input->cnt_index = (unsigned short)((unsigned int)((unsigned short)pf->hw.pf_id) * 3U + 1U);
  
#line 2297 
  input->flow_type = (unsigned char)fsp->flow_type;
  
#line 2298 
  input->ip4_proto = fsp->h_u.usr_ip4_spec.proto;
  
#line 2303 
  input->dst_port = fsp->h_u.tcp_ip4_spec.psrc;
  
#line 2304 
  input->src_port = fsp->h_u.tcp_ip4_spec.pdst;
  
#line 2305 
  input->dst_ip[0] = fsp->h_u.tcp_ip4_spec.ip4src;
  
#line 2306 
  input->src_ip[0] = fsp->h_u.tcp_ip4_spec.ip4dst;
  
#line 2308 
  if (0 != 0) 
#line 2308 
              tmp_7 = ((((fsp->m_ext.data[1] << 24) | ((fsp->m_ext.data[1] << 8) & 16711680U)) | ((fsp->m_ext.data[1] >> 8) & 65280U)) | (fsp->m_ext.data[1] >> 24)) != 0U;
  else {
    __u32 tmp_6;
    
#line 2308 
    tmp_6 = __fswab32(fsp->m_ext.data[1]);
    
#line 2308 
    tmp_7 = tmp_6 != 0U;
  }
  
#line 2308 
  if (tmp_7) {
    unsigned int tmp_4;
    
#line 2309 
    if (0 != 0) 
#line 2309 
                tmp_4 = (((fsp->h_ext.data[1] << 24) | ((fsp->h_ext.data[1] << 8) & 16711680U)) | ((fsp->h_ext.data[1] >> 8) & 65280U)) | (fsp->h_ext.data[1] >> 24); else 
                                                                    
#line 2309 
                                                                    tmp_4 = __fswab32(fsp->h_ext.data[1]);
    
#line 2309 
    ;
    
#line 2309 
    if (tmp_4 >= (unsigned int)pf->num_alloc_vfs) {
      
#line 2310 
      if ((pf->msg_enable & 1U) != 0U) 
#line 2310 
                                       netdev_info((struct net_device const *)vsi->netdev,"Invalid VF id\n"); else ;
      
#line 2311 
      goto free_input;
    }
    else ;
    
#line 2313 
    if (0 != 0) 
#line 2313 
                vf_id = (unsigned short)(((unsigned int)((unsigned short)(fsp->h_ext.data[1] >> 8)) & 65280U) | (unsigned int)((unsigned short)(fsp->h_ext.data[1] >> 24)));
    else {
      __u32 tmp_5;
      
#line 2313 
      tmp_5 = __fswab32(fsp->h_ext.data[1]);
      
#line 2313 
      vf_id = (unsigned short)tmp_5;
    }
    
#line 2315 
    input->dest_vsi = (unsigned short)(pf->vf + (int)vf_id)->lan_vsi_id;
    
#line 2316 
    if ((int)input->q_index >= (int)((unsigned short)(pf->vf + (int)vf_id)->num_queue_pairs)) {
      
#line 2317 
      if ((pf->msg_enable & 1U) != 0U) 
#line 2317 
                                       netdev_info((struct net_device const *)vsi->netdev,"Invalid queue id\n"); else ;
      
#line 2318 
      goto free_input;
    }
    else ;
  }
  else ;
  
#line 2322 
  ret = i40e_add_del_fdir(vsi,input,(_Bool)1);
  free_input: 
#line 2323 
  ;
  
#line 2324 
  if (ret != 0) 
#line 2325 
                kfree((void const *)input); else 
#line 2327 
                                                 i40e_update_ethtool_fdir_entry(vsi,input,(unsigned short)((int)((unsigned short)fsp->location)),(struct ethtool_rxnfc *)0);
  
#line 2329 
  __retres = ret;
  return_label: 
#line 2329 
                return __retres;
}


#line 2339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)
{
  
#line 2341 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2342 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2343 
  struct i40e_pf *pf = vsi->back;
  
#line 2344 
  int ret = -95;
  
#line 2346 
  switch (cmd->cmd) {
    case (__u32)42: 
#line 2347 
    ;
    
#line 2348 
    ret = i40e_set_rss_hash_opt(pf,cmd);
    
#line 2349 
    goto ldv_62112;
    case (__u32)50: 
#line 2350 
    ;
    
#line 2351 
    ret = i40e_add_fdir_ethtool(vsi,cmd);
    
#line 2352 
    goto ldv_62112;
    case (__u32)49: 
#line 2353 
    ;
    
#line 2354 
    ret = i40e_del_fdir_entry(vsi,cmd);
    
#line 2355 
    goto ldv_62112;
    default: 
#line 2356 
    ;
    
#line 2357 
    goto ldv_62112;
  }
  ldv_62112: 
#line 2360 
  ;
  
#line 2360 
  return ret;
}


#line 2367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static unsigned int i40e_max_channels(struct i40e_vsi *vsi)
{
  unsigned int __retres;
  
#line 2370 
  __retres = (unsigned int)vsi->alloc_queue_pairs;
  
#line 2370 
  return __retres;
}


#line 2383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_channels(struct net_device *dev, struct ethtool_channels *ch)
{
  
#line 2386 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)dev);
  
#line 2387 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2388 
  struct i40e_pf *pf = vsi->back;
  
#line 2391 
  ch->max_combined = i40e_max_channels(vsi);
  
#line 2394 
  ch->other_count = (unsigned int)(pf->flags >> 21) & 1U;
  
#line 2395 
  ch->max_other = ch->other_count;
  
#line 2398 
  ch->combined_count = (unsigned int)vsi->num_queue_pairs;
  
#line 2399 
  return;
}


#line 2409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_channels(struct net_device *dev, struct ethtool_channels *ch)
{
  int __retres;
  int new_count;
  unsigned int tmp_0;
  
#line 2412 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)dev);
  
#line 2413 
  unsigned int count = ch->combined_count;
  
#line 2414 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2415 
  struct i40e_pf *pf = vsi->back;
  
#line 2419 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) {
    
#line 2420 
    __retres = -22;
    
#line 2420 
    goto return_label;
  }
  else ;
  
#line 2423 
  if ((count == 0U || ch->rx_count != 0U) || ch->tx_count != 0U) {
    
#line 2424 
    __retres = -22;
    
#line 2424 
    goto return_label;
  }
  else ;
  
#line 2427 
  if (ch->other_count != ((unsigned int)(pf->flags >> 21) & 1U)) {
    
#line 2428 
    __retres = -22;
    
#line 2428 
    goto return_label;
  }
  else ;
  
#line 2431 
  tmp_0 = i40e_max_channels(vsi);
  
#line 2431 
  ;
  
#line 2431 
  if (tmp_0 < count) {
    
#line 2432 
    __retres = -22;
    
#line 2432 
    goto return_label;
  }
  else ;
  
#line 2440 
  new_count = i40e_reconfig_rss_queues(pf,(int)count);
  
#line 2441 
  if (new_count > 0) {
    
#line 2442 
    __retres = 0;
    
#line 2442 
    goto return_label;
  }
  else {
    
#line 2444 
    __retres = -22;
    
#line 2444 
    goto return_label;
  }
  return_label: 
#line 2441 
                return __retres;
}


#line 2454  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u32 i40e_get_rxfh_key_size(struct net_device *netdev)
{
  u32 __retres;
  
#line 2456 
  __retres = 52U;
  
#line 2456 
  return __retres;
}


#line 2465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u32 i40e_get_rxfh_indir_size(struct net_device *netdev)
{
  u32 __retres;
  
#line 2467 
  __retres = 512U;
  
#line 2467 
  return __retres;
}


#line 2470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key, u8 *hfunc)
{
  int __retres;
  u32 reg_val;
  int i;
  int j;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  
#line 2473 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2474 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2475 
  struct i40e_pf *pf = vsi->back;
  
#line 2476 
  struct i40e_hw *hw = & pf->hw;
  
#line 2480 
  if (hfunc != (u8 *)0U) 
#line 2481 
                         *hfunc = (unsigned char)1U; else ;
  
#line 2483 
  if (indir == (u32 *)0U) {
    
#line 2484 
    __retres = 0;
    
#line 2484 
    goto return_label;
  }
  else ;
  
#line 2486 
  i = 0;
  
#line 2486 
  j = 0;
  
#line 2486 
  goto ldv_62155;
  ldv_62154: 
#line 2487 
  ;
  
#line 2487 
  reg_val = readl((void const volatile *)(hw->hw_addr + (i + 18432) * 128));
  
#line 2488 
  tmp_0 = j;
  
#line 2488 
  j += 1;
  
#line 2488 
  *(indir + tmp_0) = reg_val & 255U;
  
#line 2489 
  tmp_1 = j;
  
#line 2489 
  j += 1;
  
#line 2489 
  *(indir + tmp_1) = (reg_val >> 8) & 255U;
  
#line 2490 
  tmp_2 = j;
  
#line 2490 
  j += 1;
  
#line 2490 
  *(indir + tmp_2) = (reg_val >> 16) & 255U;
  
#line 2491 
  tmp_3 = j;
  
#line 2491 
  j += 1;
  
#line 2491 
  *(indir + tmp_3) = reg_val >> 24;
  
#line 2486 
  i += 1;
  ldv_62155: 
#line 2487 
  ;
  
#line 2486 
  if (i <= 127) 
#line 2488 
                goto ldv_62154; else 
#line 2491 
                                     goto ldv_62156;
  ldv_62156: 
#line 2492 
  ;
  
#line 2494 
  if (key != (u8 *)0U) {
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    
#line 2495 
    i = 0;
    
#line 2495 
    j = 0;
    
#line 2495 
    goto ldv_62158;
    ldv_62157: 
#line 2496 
    ;
    
#line 2496 
    reg_val = readl((void const volatile *)(hw->hw_addr + (i + 18576) * 128));
    
#line 2497 
    tmp_4 = j;
    
#line 2497 
    j += 1;
    
#line 2497 
    *(key + tmp_4) = (unsigned char)reg_val;
    
#line 2498 
    tmp_5 = j;
    
#line 2498 
    j += 1;
    
#line 2498 
    *(key + tmp_5) = (unsigned char)(reg_val >> 8);
    
#line 2499 
    tmp_6 = j;
    
#line 2499 
    j += 1;
    
#line 2499 
    *(key + tmp_6) = (unsigned char)(reg_val >> 16);
    
#line 2500 
    tmp_7 = j;
    
#line 2500 
    j += 1;
    
#line 2500 
    *(key + tmp_7) = (unsigned char)(reg_val >> 24);
    
#line 2495 
    i += 1;
    ldv_62158: 
#line 2496 
    ;
    
#line 2495 
    if (i <= 12) 
#line 2497 
                 goto ldv_62157; else 
#line 2500 
                                      goto ldv_62159;
    ldv_62159: 
#line 2501 
    ;
  }
  else ;
  
#line 2503 
  __retres = 0;
  return_label: 
#line 2503 
                return __retres;
}


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_rxfh(struct net_device *netdev, u32 const *indir, u8 const *key, u8 const hfunc)
{
  int __retres;
  u32 reg_val;
  int i;
  int j;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  
#line 2518 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2519 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2520 
  struct i40e_pf *pf = vsi->back;
  
#line 2521 
  struct i40e_hw *hw = & pf->hw;
  
#line 2525 
  if ((unsigned int)hfunc > 1U) {
    
#line 2526 
    __retres = -95;
    
#line 2526 
    goto return_label;
  }
  else ;
  
#line 2528 
  if (indir == (u32 const *)0U) {
    
#line 2529 
    __retres = 0;
    
#line 2529 
    goto return_label;
  }
  else ;
  
#line 2531 
  i = 0;
  
#line 2531 
  j = 0;
  
#line 2531 
  goto ldv_62174;
  ldv_62173: 
#line 2532 
  ;
  
#line 2532 
  tmp_0 = j;
  
#line 2532 
  j += 1;
  
#line 2532 
  reg_val = *(indir + tmp_0);
  
#line 2533 
  tmp_1 = j;
  
#line 2533 
  j += 1;
  
#line 2533 
  reg_val = (*(indir + tmp_1) << 8) | reg_val;
  
#line 2534 
  tmp_2 = j;
  
#line 2534 
  j += 1;
  
#line 2534 
  reg_val = (*(indir + tmp_2) << 16) | reg_val;
  
#line 2535 
  tmp_3 = j;
  
#line 2535 
  j += 1;
  
#line 2535 
  reg_val = (*(indir + tmp_3) << 24) | reg_val;
  
#line 2536 
  writel(reg_val,(void volatile *)(hw->hw_addr + (i + 18432) * 128));
  
#line 2531 
  i += 1;
  ldv_62174: 
#line 2532 
  ;
  
#line 2531 
  if (i <= 127) 
#line 2533 
                goto ldv_62173; else 
#line 2536 
                                     goto ldv_62175;
  ldv_62175: 
#line 2537 
  ;
  
#line 2539 
  if (key != (u8 const *)0U) {
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    
#line 2540 
    i = 0;
    
#line 2540 
    j = 0;
    
#line 2540 
    goto ldv_62177;
    ldv_62176: 
#line 2541 
    ;
    
#line 2541 
    tmp_4 = j;
    
#line 2541 
    j += 1;
    
#line 2541 
    reg_val = (unsigned int)*(key + tmp_4);
    
#line 2542 
    tmp_5 = j;
    
#line 2542 
    j += 1;
    
#line 2542 
    reg_val = (unsigned int)((int)*(key + tmp_5) << 8) | reg_val;
    
#line 2543 
    tmp_6 = j;
    
#line 2543 
    j += 1;
    
#line 2543 
    reg_val = (unsigned int)((int)*(key + tmp_6) << 16) | reg_val;
    
#line 2544 
    tmp_7 = j;
    
#line 2544 
    j += 1;
    
#line 2544 
    reg_val = (unsigned int)((int)*(key + tmp_7) << 24) | reg_val;
    
#line 2545 
    writel(reg_val,(void volatile *)(hw->hw_addr + (i + 18576) * 128));
    
#line 2540 
    i += 1;
    ldv_62177: 
#line 2541 
    ;
    
#line 2540 
    if (i <= 12) 
#line 2542 
                 goto ldv_62176; else 
#line 2545 
                                      goto ldv_62178;
    ldv_62178: 
#line 2546 
    ;
  }
  else ;
  
#line 2548 
  __retres = 0;
  return_label: 
#line 2548 
                return __retres;
}


#line 2561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u32 i40e_get_priv_flags(struct net_device *dev)
{
  
#line 2563 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)dev);
  
#line 2564 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2565 
  struct i40e_pf *pf = vsi->back;
  
#line 2566 
  u32 ret_flags = 0U;
  
#line 2568 
  ret_flags = (unsigned int)(pf->hw.func_caps.npar_enable != 0U) | ret_flags;
  
#line 2571 
  return ret_flags;
}


#line 2574  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct ethtool_ops const i40e_ethtool_ops = {.get_settings = & i40e_get_settings, .set_settings = & i40e_set_settings, .get_drvinfo = & i40e_get_drvinfo, .get_regs_len = & i40e_get_regs_len, .get_regs = & i40e_get_regs, .get_wol = & i40e_get_wol, .set_wol = & i40e_set_wol, .get_msglevel = & i40e_get_msglevel, .set_msglevel = & i40e_set_msglevel, .nway_reset = & i40e_nway_reset, .get_link = & ethtool_op_get_link, .get_eeprom_len = & i40e_get_eeprom_len, .get_eeprom = & i40e_get_eeprom, .set_eeprom = & i40e_set_eeprom, .get_coalesce = & i40e_get_coalesce, .set_coalesce = & i40e_set_coalesce, .get_ringparam = & i40e_get_ringparam, .set_ringparam = & i40e_set_ringparam, .get_pauseparam = & i40e_get_pauseparam, .set_pauseparam = & i40e_set_pauseparam, .self_test = & i40e_diag_test, .get_strings = & i40e_get_strings, .set_phys_id = & i40e_set_phys_id, .get_ethtool_stats = & i40e_get_ethtool_stats, .begin = (int (*)(struct net_device *))0, .complete = (void (*)(struct net_device *))0, .get_priv_flags = & i40e_get_priv_flags, .set_priv_flags = (int (*)(struct net_device *, u32 ))0, .get_sset_count = & i40e_get_sset_count, .get_rxnfc = & i40e_get_rxnfc, .set_rxnfc = & i40e_set_rxnfc, .flash_device = (int (*)(struct net_device *, struct ethtool_flash *))0, .reset = (int (*)(struct net_device *, u32 *))0, .get_rxfh_key_size = & i40e_get_rxfh_key_size, .get_rxfh_indir_size = & i40e_get_rxfh_indir_size, .get_rxfh = & i40e_get_rxfh, .set_rxfh = & i40e_set_rxfh, .get_channels = & i40e_get_channels, .set_channels = & i40e_set_channels, .get_dump_flag = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_dump_data = (int (*)(struct net_device *, struct ethtool_dump *, void *))0, .set_dump = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_ts_info = & i40e_get_ts_info, .get_module_info = (int (*)(struct net_device *, struct ethtool_modinfo *))0, .get_module_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .set_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .get_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void *))0, .set_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void const *))0};

#line 2612  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
void i40e_set_ethtool_ops(struct net_device *netdev)
{
  
#line 2614 
  netdev->ethtool_ops = & i40e_ethtool_ops;
  
#line 2615 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
unsigned int (*ldv_emg_alias_ethtool_op_get_link_26)(struct net_device *) = & ethtool_op_get_link;

#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_get_regs_8(struct net_device *arg0, struct ethtool_regs *arg1, void *arg2)
{
  
#line 74 
  i40e_get_regs(arg0,arg1,arg2);
  
#line 75 
  return;
}


#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_pauseparam_47(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  int tmp;
  
#line 79 
  tmp = i40e_set_pauseparam(arg0,arg1);
  
#line 79 
  return tmp;
}


#line 83  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_eeprom_len_33(struct net_device *arg0)
{
  int tmp;
  
#line 84 
  tmp = i40e_get_eeprom_len(arg0);
  
#line 84 
  return tmp;
}


#line 88  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
unsigned int ldv_emg_wrapper_i40e_get_priv_flags_15(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 89 
  tmp = i40e_get_priv_flags(arg0);
  
#line 89 
  return tmp;
}


#line 93  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_rxnfc_21(struct net_device *arg0, struct ethtool_rxnfc *arg1, unsigned int *arg2)
{
  int tmp;
  
#line 94 
  tmp = i40e_get_rxnfc(arg0,arg1,arg2);
  
#line 94 
  return tmp;
}


#line 98  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_sset_count_40(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 99 
  tmp = i40e_get_sset_count(arg0,arg1);
  
#line 99 
  return tmp;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_rxfh_9(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char arg3)
{
  int tmp;
  
#line 104 
  tmp = i40e_set_rxfh(arg0,(u32 const *)arg1,(u8 const *)arg2,(unsigned char)((int)arg3));
  
#line 104 
  return tmp;
}


#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_nway_reset_24(struct net_device *arg0)
{
  int tmp;
  
#line 109 
  tmp = i40e_nway_reset(arg0);
  
#line 109 
  return tmp;
}


#line 113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_get_ringparam_29(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  
#line 114 
  i40e_get_ringparam(arg0,arg1);
  
#line 115 
  return;
}


#line 118  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_eeprom_39(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  int tmp;
  
#line 119 
  tmp = i40e_set_eeprom(arg0,arg1,arg2);
  
#line 119 
  return tmp;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_rxfh_22(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char *arg3)
{
  int tmp;
  
#line 124 
  tmp = i40e_get_rxfh(arg0,arg1,arg2,arg3);
  
#line 124 
  return tmp;
}


#line 128  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_phys_id_3(struct net_device *arg0, enum ethtool_phys_id_state arg1)
{
  int tmp;
  
#line 129 
  tmp = i40e_set_phys_id(arg0,arg1);
  
#line 129 
  return tmp;
}


#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_get_pauseparam_25(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  
#line 134 
  i40e_get_pauseparam(arg0,arg1);
  
#line 135 
  return;
}


#line 138  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_coalesce_46(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 139 
  tmp = i40e_set_coalesce(arg0,arg1);
  
#line 139 
  return tmp;
}


#line 143  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_settings_2(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 144 
  tmp = i40e_set_settings(arg0,arg1);
  
#line 144 
  return tmp;
}


#line 148  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_ringparam_10(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  int tmp;
  
#line 149 
  tmp = i40e_set_ringparam(arg0,arg1);
  
#line 149 
  return tmp;
}


#line 153  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_get_strings_36(struct net_device *arg0, unsigned int arg1, unsigned char *arg2)
{
  
#line 154 
  i40e_get_strings(arg0,arg1,arg2);
  
#line 155 
  return;
}


#line 158  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_regs_len_45(struct net_device *arg0)
{
  int tmp;
  
#line 159 
  tmp = i40e_get_regs_len(arg0);
  
#line 159 
  return tmp;
}


#line 163  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_eeprom_16(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  int tmp;
  
#line 164 
  tmp = i40e_get_eeprom(arg0,arg1,arg2);
  
#line 164 
  return tmp;
}


#line 168  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_get_ethtool_stats_4(struct net_device *arg0, struct ethtool_stats *arg1, unsigned long long *arg2)
{
  
#line 169 
  i40e_get_ethtool_stats(arg0,arg1,arg2);
  
#line 170 
  return;
}


#line 173  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_get_wol_37(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  
#line 174 
  i40e_get_wol(arg0,arg1);
  
#line 175 
  return;
}


#line 178  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_settings_35(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 179 
  tmp = i40e_get_settings(arg0,arg1);
  
#line 179 
  return tmp;
}


#line 183  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_diag_test_17(struct net_device *arg0, struct ethtool_test *arg1, unsigned long long *arg2)
{
  
#line 184 
  i40e_diag_test(arg0,arg1,arg2);
  
#line 185 
  return;
}


#line 188  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_get_drvinfo_7(struct net_device *arg0, struct ethtool_drvinfo *arg1)
{
  
#line 189 
  i40e_get_drvinfo(arg0,arg1);
  
#line 190 
  return;
}


#line 193  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
unsigned int ldv_emg_wrapper_i40e_get_rxfh_indir_size_27(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 194 
  tmp = i40e_get_rxfh_indir_size(arg0);
  
#line 194 
  return tmp;
}


#line 198  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
unsigned int ldv_emg_wrapper_i40e_get_msglevel_13(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 199 
  tmp = i40e_get_msglevel(arg0);
  
#line 199 
  return tmp;
}


#line 203  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_wol_19(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  int tmp;
  
#line 204 
  tmp = i40e_set_wol(arg0,arg1);
  
#line 204 
  return tmp;
}


#line 208  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_coalesce_38(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 209 
  tmp = i40e_get_coalesce(arg0,arg1);
  
#line 209 
  return tmp;
}


#line 213  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_get_channels_41(struct net_device *arg0, struct ethtool_channels *arg1)
{
  
#line 214 
  i40e_get_channels(arg0,arg1);
  
#line 215 
  return;
}


#line 218  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
unsigned int ldv_emg_wrapper_i40e_get_rxfh_key_size_12(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 219 
  tmp = i40e_get_rxfh_key_size(arg0);
  
#line 219 
  return tmp;
}


#line 223  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_channels_32(struct net_device *arg0, struct ethtool_channels *arg1)
{
  int tmp;
  
#line 224 
  tmp = i40e_set_channels(arg0,arg1);
  
#line 224 
  return tmp;
}


#line 228  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
void ldv_emg_wrapper_i40e_set_msglevel_28(struct net_device *arg0, unsigned int arg1)
{
  
#line 229 
  i40e_set_msglevel(arg0,arg1);
  
#line 230 
  return;
}


#line 233  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_set_rxnfc_6(struct net_device *arg0, struct ethtool_rxnfc *arg1)
{
  int tmp;
  
#line 234 
  tmp = i40e_set_rxnfc(arg0,arg1);
  
#line 234 
  return tmp;
}


#line 238  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
int ldv_emg_wrapper_i40e_get_ts_info_43(struct net_device *arg0, struct ethtool_ts_info *arg1)
{
  int tmp;
  
#line 239 
  tmp = i40e_get_ts_info(arg0,arg1);
  
#line 239 
  return tmp;
}


#line 590  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
static void *kcalloc_1(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 593 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 593 
  return tmp;
}


#line 597  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_ethtool.c.aux"
static void *kzalloc_2(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 600 
  tmp = ldv_kzalloc(size,flags);
  
#line 600 
  return tmp;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
int dcb_ieee_setapp(struct net_device *, struct dcb_app *);


#line 34 
int dcb_ieee_delapp(struct net_device *, struct dcb_app *);


#line 37 
int dcbnl_ieee_notify(struct net_device *, int, int, u32, u32);


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static void i40e_get_pfc_delay(struct i40e_hw *hw, u16 *delay)
{
  u32 val;
  
#line 42 
  val = readl((void const volatile *)(hw->hw_addr + 536576U));
  
#line 43 
  *delay = (unsigned short)(val >> 16);
  
#line 44 
  return;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static int i40e_dcbnl_ieee_getets(struct net_device *dev, struct ieee_ets *ets)
{
  int __retres;
  struct i40e_dcbx_config *dcbxcfg;
  
#line 57 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  
#line 59 
  struct i40e_hw *hw = & pf->hw;
  
#line 61 
  if (((int)pf->dcbx_cap & 8) == 0) {
    
#line 62 
    __retres = -22;
    
#line 62 
    goto return_label;
  }
  else ;
  
#line 64 
  dcbxcfg = & hw->local_dcbx_config;
  
#line 65 
  ets->willing = dcbxcfg->etscfg.willing;
  
#line 66 
  ets->ets_cap = dcbxcfg->etscfg.maxtcs;
  
#line 67 
  ets->cbs = dcbxcfg->etscfg.cbs;
  
#line 68 
  memcpy((void *)(& ets->tc_tx_bw),(void const *)(& dcbxcfg->etscfg.tcbwtable),8UL);
  
#line 70 
  memcpy((void *)(& ets->tc_rx_bw),(void const *)(& dcbxcfg->etscfg.tcbwtable),8UL);
  
#line 72 
  memcpy((void *)(& ets->tc_tsa),(void const *)(& dcbxcfg->etscfg.tsatable),8UL);
  
#line 74 
  memcpy((void *)(& ets->prio_tc),(void const *)(& dcbxcfg->etscfg.prioritytable),8UL);
  
#line 76 
  memcpy((void *)(& ets->tc_reco_bw),(void const *)(& dcbxcfg->etsrec.tcbwtable),8UL);
  
#line 78 
  memcpy((void *)(& ets->tc_reco_tsa),(void const *)(& dcbxcfg->etsrec.tsatable),8UL);
  
#line 80 
  memcpy((void *)(& ets->reco_prio_tc),(void const *)(& dcbxcfg->etscfg.prioritytable),8UL);
  
#line 83 
  __retres = 0;
  return_label: 
#line 83 
                return __retres;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static int i40e_dcbnl_ieee_getpfc(struct net_device *dev, struct ieee_pfc *pfc)
{
  int __retres;
  struct i40e_dcbx_config *dcbxcfg;
  int i;
  
#line 96 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  
#line 98 
  struct i40e_hw *hw = & pf->hw;
  
#line 101 
  if (((int)pf->dcbx_cap & 8) == 0) {
    
#line 102 
    __retres = -22;
    
#line 102 
    goto return_label;
  }
  else ;
  
#line 104 
  dcbxcfg = & hw->local_dcbx_config;
  
#line 105 
  pfc->pfc_cap = dcbxcfg->pfc.pfccap;
  
#line 106 
  pfc->pfc_en = dcbxcfg->pfc.pfcenable;
  
#line 107 
  pfc->mbc = dcbxcfg->pfc.mbc;
  
#line 108 
  i40e_get_pfc_delay(hw,& pfc->delay);
  
#line 111 
  i = 0;
  
#line 111 
  goto ldv_61397;
  ldv_61396: 
#line 112 
  ;
  
#line 112 
  pfc->requests[i] = pf->stats.priority_xoff_tx[i];
  
#line 113 
  pfc->indications[i] = pf->stats.priority_xoff_rx[i];
  
#line 111 
  i += 1;
  ldv_61397: 
#line 112 
  ;
  
#line 111 
  if (i <= 7) 
#line 113 
              goto ldv_61396; else 
#line 116 
                                   goto ldv_61398;
  ldv_61398: 
#line 117 
  ;
  
#line 116 
  __retres = 0;
  return_label: 
#line 116 
                return __retres;
}


#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static u8 i40e_dcbnl_getdcbx(struct net_device *dev)
{
  u8 __retres;
  
#line 127 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  
#line 129 
  __retres = (unsigned char)pf->dcbx_cap;
  
#line 129 
  return __retres;
}


#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static void i40e_dcbnl_get_perm_hw_addr(struct net_device *dev, u8 *perm_addr)
{
  int i;
  int j;
  
#line 141 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  
#line 144 
  memset((void *)perm_addr,255,32UL);
  
#line 146 
  i = 0;
  
#line 146 
  goto ldv_61411;
  ldv_61410: 
#line 147 
  ;
  
#line 147 
  *(perm_addr + i) = pf->hw.mac.perm_addr[i];
  
#line 146 
  i += 1;
  ldv_61411: 
#line 147 
  ;
  
#line 146 
  if ((int)dev->addr_len > i) 
#line 148 
                              goto ldv_61410; else 
#line 151 
                                                   goto ldv_61412;
  ldv_61412: 
#line 152 
  ;
  
#line 149 
  j = 0;
  
#line 149 
  goto ldv_61414;
  ldv_61413: 
#line 150 
  ;
  
#line 150 
  *(perm_addr + i) = pf->hw.mac.san_addr[j];
  
#line 149 
  j += 1;
  
#line 149 
  i += 1;
  ldv_61414: 
#line 150 
  ;
  
#line 149 
  if ((int)dev->addr_len > j) 
#line 151 
                              goto ldv_61413; else 
#line 154 
                                                   goto ldv_61415;
  ldv_61415: 
#line 155 
  ;
  
#line 156 
  return;
}


#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static struct dcbnl_rtnl_ops const dcbnl_ops = {.ieee_getets = & i40e_dcbnl_ieee_getets, .ieee_setets = (int (*)(struct net_device *, struct ieee_ets *))0, .ieee_getmaxrate = (int (*)(struct net_device *, struct ieee_maxrate *))0, .ieee_setmaxrate = (int (*)(struct net_device *, struct ieee_maxrate *))0, .ieee_getqcn = (int (*)(struct net_device *, struct ieee_qcn *))0, .ieee_setqcn = (int (*)(struct net_device *, struct ieee_qcn *))0, .ieee_getqcnstats = (int (*)(struct net_device *, struct ieee_qcn_stats *))0, .ieee_getpfc = & i40e_dcbnl_ieee_getpfc, .ieee_setpfc = (int (*)(struct net_device *, struct ieee_pfc *))0, .ieee_getapp = (int (*)(struct net_device *, struct dcb_app *))0, .ieee_setapp = (int (*)(struct net_device *, struct dcb_app *))0, .ieee_delapp = (int (*)(struct net_device *, struct dcb_app *))0, .ieee_peer_getets = (int (*)(struct net_device *, struct ieee_ets *))0, .ieee_peer_getpfc = (int (*)(struct net_device *, struct ieee_pfc *))0, .getstate = (u8 (*)(struct net_device *))0, .setstate = (u8 (*)(struct net_device *, u8 ))0, .getpermhwaddr = & i40e_dcbnl_get_perm_hw_addr, .setpgtccfgtx = (void (*)(struct net_device *, int , u8 , u8 , u8 , u8 ))0, .setpgbwgcfgtx = (void (*)(struct net_device *, int , u8 ))0, .setpgtccfgrx = (void (*)(struct net_device *, int , u8 , u8 , u8 , u8 ))0, .setpgbwgcfgrx = (void (*)(struct net_device *, int , u8 ))0, .getpgtccfgtx = (void (*)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *))0, .getpgbwgcfgtx = (void (*)(struct net_device *, int , u8 *))0, .getpgtccfgrx = (void (*)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *))0, .getpgbwgcfgrx = (void (*)(struct net_device *, int , u8 *))0, .setpfccfg = (void (*)(struct net_device *, int , u8 ))0, .getpfccfg = (void (*)(struct net_device *, int , u8 *))0, .setall = (u8 (*)(struct net_device *))0, .getcap = (u8 (*)(struct net_device *, int , u8 *))0, .getnumtcs = (int (*)(struct net_device *, int , u8 *))0, .setnumtcs = (int (*)(struct net_device *, int , u8 ))0, .getpfcstate = (u8 (*)(struct net_device *))0, .setpfcstate = (void (*)(struct net_device *, u8 ))0, .getbcncfg = (void (*)(struct net_device *, int , u32 *))0, .setbcncfg = (void (*)(struct net_device *, int , u32 ))0, .getbcnrp = (void (*)(struct net_device *, int , u8 *))0, .setbcnrp = (void (*)(struct net_device *, int , u8 ))0, .setapp = (int (*)(struct net_device *, u8 , u16 , u8 ))0, .getapp = (int (*)(struct net_device *, u8 , u16 ))0, .getfeatcfg = (u8 (*)(struct net_device *, int , u8 *))0, .setfeatcfg = (u8 (*)(struct net_device *, int , u8 ))0, .getdcbx = & i40e_dcbnl_getdcbx, .setdcbx = (u8 (*)(struct net_device *, u8 ))0, .peer_getappinfo = (int (*)(struct net_device *, struct dcb_peer_app_info *, u16 *))0, .peer_getapptable = (int (*)(struct net_device *, struct dcb_app *))0, .cee_peer_getpg = (int (*)(struct net_device *, struct cee_pg *))0, .cee_peer_getpfc = (int (*)(struct net_device *, struct cee_pfc *))0};

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
void i40e_dcbnl_set_all(struct i40e_vsi *vsi)
{
  struct i40e_dcbx_config *dcbxcfg;
  struct dcb_app sapp;
  u8 prio;
  u8 tc_map;
  int i;
  
#line 169 
  struct net_device *dev = vsi->netdev;
  
#line 170 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  
#line 172 
  struct i40e_hw *hw = & pf->hw;
  
#line 178 
  if ((pf->flags & 1048576ULL) == 0ULL) 
#line 179 
                                        goto return_label; else ;
  
#line 182 
  if ((pf->flags & 67108864ULL) != 0ULL && ! pf->hw.func_caps.iscsi) 
    
#line 183 
    goto return_label; else ;
  
#line 185 
  dcbxcfg = & hw->local_dcbx_config;
  
#line 188 
  i = 0;
  
#line 188 
  goto ldv_61429;
  ldv_61428: 
#line 189 
  ;
  
#line 189 
  prio = dcbxcfg->app[i].priority;
  
#line 190 
  tc_map = (unsigned char)(1 << (int)dcbxcfg->etscfg.prioritytable[(int)prio]);
  
#line 193 
  if ((unsigned int)((int)vsi->tc_config.enabled_tc & (int)tc_map) != 0U) {
    
#line 194 
    sapp.selector = dcbxcfg->app[i].selector;
    
#line 195 
    sapp.protocol = dcbxcfg->app[i].protocolid;
    
#line 196 
    sapp.priority = prio;
    
#line 197 
    dcb_ieee_setapp(dev,& sapp);
  }
  else ;
  
#line 188 
  i += 1;
  ldv_61429: 
#line 189 
  ;
  
#line 188 
  if (dcbxcfg->numapps > (unsigned int)i) 
#line 190 
                                          goto ldv_61428; else 
#line 193 
                                                               goto ldv_61430;
  ldv_61430: 
#line 194 
  ;
  
#line 202 
  dcbnl_ieee_notify(dev,79,20,0U,0U);
  return_label: 
#line 203 
                return;
}


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static int i40e_dcbnl_vsi_del_app(struct i40e_vsi *vsi, struct i40e_dcb_app_priority_table *app)
{
  int __retres;
  struct dcb_app sapp;
  int tmp;
  
#line 216 
  struct net_device *dev = vsi->netdev;
  
#line 219 
  if (dev == (struct net_device *)0) {
    
#line 220 
    __retres = -22;
    
#line 220 
    goto return_label;
  }
  else ;
  
#line 222 
  sapp.selector = app->selector;
  
#line 223 
  sapp.protocol = app->protocolid;
  
#line 224 
  sapp.priority = app->priority;
  
#line 225 
  tmp = dcb_ieee_delapp(dev,& sapp);
  
#line 225 
  __retres = tmp;
  return_label: 
#line 225 
                return __retres;
}


#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static void i40e_dcbnl_del_app(struct i40e_pf *pf, struct i40e_dcb_app_priority_table *app)
{
  int v;
  int err;
  
#line 239 
  v = 0;
  
#line 239 
  goto ldv_61445;
  ldv_61444: 
#line 240 
  ;
  
#line 240 
  if (*(pf->vsi + v) != (struct i40e_vsi *)0 && (*(pf->vsi + v))->netdev != (struct net_device *)0) {
    
#line 241 
    err = i40e_dcbnl_vsi_del_app(*(pf->vsi + v),app);
    
#line 242 
    if (err != 0) 
#line 243 
                  _dev_info((struct device const *)(& (pf->pdev)->dev),"%s: Failed deleting app for VSI seid=%d err=%d sel=%d proto=0x%x prio=%d\n","i40e_dcbnl_del_app",(int)(*(pf->vsi + v))->seid,err,(int)app->selector,(int)app->protocolid,(int)app->priority); else ;
  }
  else ;
  
#line 239 
  v += 1;
  ldv_61445: 
#line 240 
  ;
  
#line 239 
  if ((int)pf->num_alloc_vsi > v) 
#line 241 
                                  goto ldv_61444; else 
#line 244 
                                                       goto ldv_61446;
  ldv_61446: 
#line 245 
  ;
  
#line 246 
  return;
}


#line 258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static bool i40e_dcbnl_find_app(struct i40e_dcbx_config *cfg, struct i40e_dcb_app_priority_table *app)
{
  bool __retres;
  int i;
  
#line 263 
  i = 0;
  
#line 263 
  goto ldv_61453;
  ldv_61452: 
#line 264 
  ;
  
#line 264 
  if (((int)app->selector == (int)cfg->app[i].selector && (int)app->protocolid == (int)cfg->app[i].protocolid) && (int)app->priority == (int)cfg->app[i].priority) {
    
#line 267 
    __retres = (_Bool)1;
    
#line 267 
    goto return_label;
  }
  else ;
  
#line 263 
  i += 1;
  ldv_61453: 
#line 264 
  ;
  
#line 263 
  if (cfg->numapps > (unsigned int)i) 
#line 265 
                                      goto ldv_61452; else 
#line 268 
                                                           goto ldv_61454;
  ldv_61454: 
#line 269 
  ;
  
#line 270 
  __retres = (_Bool)0;
  return_label: 
#line 270 
                return __retres;
}


#line 282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
void i40e_dcbnl_flush_apps(struct i40e_pf *pf, struct i40e_dcbx_config *old_cfg, struct i40e_dcbx_config *new_cfg)
{
  struct i40e_dcb_app_priority_table app;
  int i;
  int tmp_0;
  bool tmp;
  
#line 290 
  if ((pf->flags & 67108864ULL) != 0ULL && ! pf->hw.func_caps.iscsi) 
    
#line 291 
    goto return_label; else ;
  
#line 293 
  i = 0;
  
#line 293 
  goto ldv_61463;
  ldv_61462: 
#line 294 
  ;
  
#line 294 
  app = old_cfg->app[i];
  
#line 296 
  tmp = i40e_dcbnl_find_app(new_cfg,& app);
  
#line 296 
  if (tmp) 
#line 296 
           tmp_0 = 0; else 
#line 296 
                           tmp_0 = 1;
  
#line 296 
  if (tmp_0) 
#line 297 
             i40e_dcbnl_del_app(pf,& app); else ;
  
#line 293 
  i += 1;
  ldv_61463: 
#line 294 
  ;
  
#line 293 
  if (old_cfg->numapps > (unsigned int)i) 
#line 295 
                                          goto ldv_61462; else 
#line 298 
                                                               goto ldv_61464;
  ldv_61464: 
#line 299 
  ;
  return_label: 
#line 300 
                return;
}


#line 307  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
void i40e_dcbnl_setup(struct i40e_vsi *vsi)
{
  
#line 309 
  struct net_device *dev = vsi->netdev;
  
#line 310 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  
#line 313 
  if ((pf->flags & 536870912ULL) == 0ULL) 
#line 314 
                                          goto return_label; else ;
  
#line 316 
  dev->dcbnl_ops = & dcbnl_ops;
  
#line 319 
  i40e_dcbnl_set_all(vsi);
  return_label: 
#line 320 
                return;
}

void __builtin_prefetch(void const * , ...);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_txrx.c.aux"
void ldv_atomic_inc(atomic_t *v);


#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit_lock(long nr, unsigned long volatile *addr)
{
  int tmp;
  
#line 219 
  tmp = test_and_set_bit(nr,addr);
  
#line 219 
  return tmp;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const *v)
{
  int __retres;
  int const volatile *tmp;
  {
    
#line 27 
    int const __var = 0;
    
#line 27 
    tmp = (int const volatile *)(& v->counter);
  }
  
#line 27 
  __retres = *tmp;
  
#line 27 
  return __retres;
}


#line 98 
static void atomic_inc(atomic_t *v);


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
unsigned long msleep_interruptible(unsigned int);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmdebug.h"
void dump_page(struct page *, char const *);


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/topology.h"
__inline static int numa_node_id(void)
{
  int tmp_3;
  {
    int pscr_ret__;
    {
      
#line 77 
      void const *__vpp_verify = (void const *)0;
      
#line 77 
      void const *tmp = __vpp_verify;
    }
    
#line 77 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 77 
      ;
      {
        int pfo_ret__;
        
#line 77 
        switch (4UL) {
          case (unsigned long)1: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15521;
          case (unsigned long)2: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15521;
          case (unsigned long)4: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15521;
          case (unsigned long)8: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15521;
          default: 
#line 77 
          ;
          
#line 77 
          __bad_percpu_size();
        }
        ldv_15521: 
#line 77 
        ;
        
#line 77 
        tmp_0 = pfo_ret__;
      }
      
#line 77 
      pscr_ret__ = tmp_0;
      
#line 77 
      goto ldv_15527;
      case (unsigned long)2: 
#line 77 
      ;
      {
        int pfo_ret___0;
        
#line 77 
        switch (4UL) {
          case (unsigned long)1: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15531;
          case (unsigned long)2: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15531;
          case (unsigned long)4: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15531;
          case (unsigned long)8: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15531;
          default: 
#line 77 
          ;
          
#line 77 
          __bad_percpu_size();
        }
        ldv_15531: 
#line 77 
        ;
        
#line 77 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 77 
      pscr_ret__ = tmp_0_0;
      
#line 77 
      goto ldv_15527;
      case (unsigned long)4: 
#line 77 
      ;
      {
        int pfo_ret___1;
        
#line 77 
        switch (4UL) {
          case (unsigned long)1: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15540;
          case (unsigned long)2: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15540;
          case (unsigned long)4: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15540;
          case (unsigned long)8: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15540;
          default: 
#line 77 
          ;
          
#line 77 
          __bad_percpu_size();
        }
        ldv_15540: 
#line 77 
        ;
        
#line 77 
        tmp_1 = pfo_ret___1;
      }
      
#line 77 
      pscr_ret__ = tmp_1;
      
#line 77 
      goto ldv_15527;
      case (unsigned long)8: 
#line 77 
      ;
      {
        int pfo_ret___2;
        
#line 77 
        switch (4UL) {
          case (unsigned long)1: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15549;
          case (unsigned long)2: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15549;
          case (unsigned long)4: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15549;
          case (unsigned long)8: 
#line 77 
          ;
          
#line 78 
          ldv_inline_asm();
          
#line 77 
          goto ldv_15549;
          default: 
#line 77 
          ;
          
#line 77 
          __bad_percpu_size();
        }
        ldv_15549: 
#line 77 
        ;
        
#line 77 
        tmp_2 = pfo_ret___2;
      }
      
#line 77 
      pscr_ret__ = tmp_2;
      
#line 77 
      goto ldv_15527;
      default: 
#line 77 
      ;
      
#line 77 
      __bad_size_call_parameter();
      
#line 77 
      goto ldv_15527;
    }
    ldv_15527: 
#line 77 
    ;
    
#line 77 
    tmp_3 = pscr_ret__;
  }
  
#line 77 
  return tmp_3;
}


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct page *alloc_pages_current(gfp_t, unsigned int);


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)
{
  struct page *tmp;
  
#line 327 
  tmp = alloc_pages_current(gfp_mask,order);
  
#line 327 
  return tmp;
}


#line 366 
void __free_pages(struct page *, unsigned int);


#line 400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page-flags.h"
__inline static int PageTail(struct page const *page)
{
  int tmp;
  
#line 400 
  tmp = constant_test_bit(15L,(unsigned long const volatile *)(& page->flags));
  
#line 400 
  return tmp;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static struct page *compound_head_by_tail(struct page *tail)
{
  struct page *__retres;
  int tmp;
  
#line 442 
  struct page *head = tail->__anonCompField_page_57.first_page;
  
#line 443 
  ldv_inline_asm();
  
#line 450 
  tmp = PageTail((struct page const *)tail);
  
#line 450 
  if ((long)(tmp != 0) != 0L) {
    
#line 451 
    __retres = head;
    
#line 451 
    goto return_label;
  }
  else ;
  
#line 452 
  __retres = tail;
  return_label: 
#line 452 
                return __retres;
}


#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static struct page *compound_head(struct page *page)
{
  struct page *__retres;
  int tmp_0;
  
#line 463 
  tmp_0 = PageTail((struct page const *)page);
  
#line 463 
  if ((long)(tmp_0 != 0) != 0L) {
    struct page *tmp;
    
#line 464 
    tmp = compound_head_by_tail(page);
    
#line 464 
    __retres = tmp;
    
#line 464 
    goto return_label;
  }
  else ;
  
#line 465 
  __retres = page;
  return_label: 
#line 465 
                return __retres;
}


#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static int page_count(struct page *page)
{
  int tmp_0;
  struct page *tmp;
  
#line 498 
  tmp = compound_head(page);
  
#line 498 
  tmp_0 = atomic_read((atomic_t const *)(& tmp->__anonCompField_page_53.__anonCompField___anonstruct_179_52.__anonCompField___anonunion_181_51._count));
  
#line 498 
  return tmp_0;
}


#line 532 
bool __get_page_tail(struct page *);


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void get_page(struct page *page)
{
  int tmp_0;
  int tmp_1;
  
#line 536 
  tmp_0 = PageTail((struct page const *)page);
  
#line 536 
  if ((long)(tmp_0 != 0) != 0L) {
    bool tmp;
    
#line 537 
    tmp = __get_page_tail(page);
    
#line 537 
    if ((long)((int)tmp != 0) != 0L) 
#line 538 
                                     goto return_label; else ;
  }
  else ;
  
#line 543 
  tmp_1 = atomic_read((atomic_t const *)(& page->__anonCompField_page_53.__anonCompField___anonstruct_179_52.__anonCompField___anonunion_181_51._count));
  
#line 543 
  if ((long)(tmp_1 <= 0) != 0L) {
    
#line 543 
    dump_page(page,"VM_BUG_ON_PAGE(");
    
#line 544 
    ldv_inline_asm();
    
#line 543 
    ;
  }
  else ;
  
#line 544 
  atomic_inc(& page->__anonCompField_page_53.__anonCompField___anonstruct_179_52.__anonCompField___anonunion_181_51._count);
  return_label: 
#line 545 
                return;
}


#line 760  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static int page_to_nid(struct page const *page)
{
  int __retres;
  
#line 762 
  __retres = (int)(page->flags >> 54UL);
  
#line 762 
  return __retres;
}


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page const *page)
{
  void *__retres;
  
#line 947 
  __retres = (void *)((unsigned long)((unsigned long long)(((long)page + 24189255811072L) / 64L) << 12) + 18446612132314218496UL);
  
#line 947 
  return __retres;
}


#line 1031  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static bool page_is_pfmemalloc(struct page *page)
{
  bool __retres;
  
#line 1037 
  __retres = (_Bool)(page->__anonCompField_page_53.__anonCompField___anonstruct_179_48.index == 18446744073709551615UL);
  
#line 1037 
  return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql, unsigned int count)
{
  
#line 74 
  if ((long)(count > 268435455U) != 0L) {
    
#line 76 
    ldv_inline_asm();
    
#line 74 
    ;
  }
  else ;
  
#line 76 
  dql->last_obj_cnt = count;
  
#line 77 
  ldv_inline_asm();
  
#line 85 
  dql->num_queued += count;
  
#line 86 
  return;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql const *dql)
{
  int __retres;
  unsigned int const volatile *tmp;
  unsigned int const volatile *tmp_0;
  {
    
#line 91 
    unsigned int const __var = 0U;
    
#line 91 
    tmp = (unsigned int const volatile *)(& dql->adj_limit);
  }
  {
    
#line 91 
    unsigned int const __var_0 = 0U;
    
#line 91 
    tmp_0 = (unsigned int const volatile *)(& dql->num_queued);
  }
  
#line 91 
  ;
  
#line 91 
  __retres = (int)(*tmp - *tmp_0);
  
#line 91 
  return __retres;
}


#line 95 
void dql_completed(struct dql *, unsigned int);


#line 98 
void dql_reset(struct dql *);


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_3(size_t size, gfp_t flags);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_fold(__wsum sum)
{
  __sum16 __retres;
  
#line 24 
  ldv_inline_asm();
  
#line 29 
  __retres = (unsigned short)(~ sum >> 16);
  
#line 29 
  return __retres;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len, unsigned short proto, __wsum sum)
{
  
#line 89 
  ldv_inline_asm();
  
#line 97 
  return sum;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr, unsigned short len, unsigned short proto, __wsum sum)
{
  __sum16 tmp_0;
  __wsum tmp;
  
#line 116 
  tmp = csum_tcpudp_nofold(saddr,daddr,(unsigned short)((int)len),(unsigned short)((int)proto),sum);
  
#line 116 
  tmp_0 = csum_fold(tmp);
  
#line 116 
  return tmp_0;
}


#line 129 
__wsum csum_partial(void const *, int, __wsum);


#line 179 
__sum16 csum_ipv6_magic(struct in6_addr const *, struct in6_addr const *, __u32, unsigned short, __wsum);


#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static unsigned int add32_with_carry(unsigned int a, unsigned int b)
{
  
#line 184 
  ldv_inline_asm();
  
#line 188 
  return a;
}


#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __wsum csum_add(__wsum csum, __wsum addend)
{
  __wsum tmp;
  
#line 194 
  tmp = add32_with_carry(csum,addend);
  
#line 194 
  return tmp;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 67 
void debug_dma_sync_single_range_for_cpu(struct device *, dma_addr_t, unsigned long, size_t, int);


#line 73 
void debug_dma_sync_single_range_for_device(struct device *, dma_addr_t, unsigned long, size_t, int);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t addr;
  void *tmp_0;
  int tmp_1;
  
#line 80 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 83 
  ;
  
#line 83 
  tmp_0 = lowmem_page_address((struct page const *)page);
  
#line 83 
  ;
  
#line 83 
  kmemcheck_mark_initialized(tmp_0 + offset,(unsigned int)size);
  
#line 84 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 84 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 86 
    ldv_inline_asm();
    
#line 84 
    ;
  }
  else ;
  
#line 85 
  addr = (*(ops->map_page))(dev,page,offset,size,dir,(struct dma_attrs *)0);
  
#line 86 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr,(_Bool)0);
  
#line 88 
  return addr;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 94 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 96 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 96 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 98 
    ldv_inline_asm();
    
#line 96 
    ;
  }
  else ;
  
#line 97 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 98 
    (*(ops->unmap_page))(dev,addr,size,dir,(struct dma_attrs *)0); else ;
  
#line 99 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)0);
  
#line 100 
  return;
}


#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t addr, unsigned long offset, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 132 
  struct dma_map_ops const *ops = get_dma_ops(dev);
  
#line 134 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 134 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 136 
    ldv_inline_asm();
    
#line 134 
    ;
  }
  else ;
  
#line 135 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 136 
    (*(ops->sync_single_for_cpu))(dev,addr + (unsigned long long)offset,size,dir); else ;
  
#line 137 
  debug_dma_sync_single_range_for_cpu(dev,addr,offset,size,(int)dir);
  
#line 138 
  return;
}


#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_device(struct device *dev, dma_addr_t addr, unsigned long offset, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 146 
  struct dma_map_ops const *ops = get_dma_ops(dev);
  
#line 148 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 148 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 150 
    ldv_inline_asm();
    
#line 148 
    ;
  }
  else ;
  
#line 149 
  if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 150 
    (*(ops->sync_single_for_device))(dev,addr + (unsigned long long)offset,size,dir); else ;
  
#line 151 
  debug_dma_sync_single_range_for_device(dev,addr,offset,size,(int)dir);
  
#line 152 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const *frag)
{
  unsigned int __retres;
  
#line 232 
  __retres = frag->size;
  
#line 232 
  return __retres;
}


#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag, unsigned int size)
{
  
#line 237 
  frag->size = size;
  
#line 238 
  return;
}


#line 775 
void consume_skb(struct sk_buff *);


#line 852 
int pskb_expand_head(struct sk_buff *, int, int, gfp_t);


#line 862 
int skb_pad(struct sk_buff *, int);


#line 926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
{
  
#line 928 
  skb->l4_hash = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))(type == (unsigned int)PKT_HASH_TYPE_L4);
  
#line 929 
  skb->sw_hash = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U;
  
#line 930 
  skb->hash = hash;
  
#line 931 
  return;
}


#line 1085  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *skb_get(struct sk_buff *skb)
{
  
#line 1087 
  atomic_inc(& skb->users);
  
#line 1088 
  return skb;
}


#line 1127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff const *skb)
{
  int __retres;
  int dataref;
  unsigned char *tmp;
  
#line 1131 
  if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) {
    
#line 1132 
    __retres = 0;
    
#line 1132 
    goto return_label;
  }
  else ;
  
#line 1134 
  tmp = skb_end_pointer(skb);
  
#line 1134 
  dataref = atomic_read((atomic_t const *)(& ((struct skb_shared_info *)tmp)->dataref));
  
#line 1135 
  dataref = (dataref & 65535) - (dataref >> 16);
  
#line 1136 
  __retres = dataref != 1;
  return_label: 
#line 1136 
                return __retres;
}


#line 1567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff const *skb)
{
  bool __retres;
  
#line 1569 
  __retres = (_Bool)(skb->data_len != 0U);
  
#line 1569 
  return __retres;
}


#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1574 
  __retres = skb->len - skb->data_len;
  
#line 1574 
  return __retres;
}


#line 1599  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size)
{
  unsigned char *tmp;
  bool tmp_0;
  
#line 1602 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1602 
  skb_frag_t *frag = & ((struct skb_shared_info *)tmp)->frags[i];
  
#line 1609 
  frag->page.p = page;
  
#line 1610 
  frag->page_offset = (unsigned int)off;
  
#line 1611 
  skb_frag_size_set(frag,(unsigned int)size);
  
#line 1613 
  page = compound_head(page);
  
#line 1614 
  tmp_0 = page_is_pfmemalloc(page);
  
#line 1614 
  if ((int)tmp_0 != 0) 
#line 1615 
                       skb->pfmemalloc = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U; else ;
  
#line 1616 
  return;
}


#line 1632  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size)
{
  unsigned char *tmp;
  
#line 1635 
  __skb_fill_page_desc(skb,i,page,off,size);
  
#line 1636 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1636 
  ((struct skb_shared_info *)tmp)->nr_frags = (unsigned char)((unsigned int)((unsigned char)i) + 1U);
  
#line 1637 
  return;
}


#line 1650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1652 
  __retres = skb->head + skb->tail;
  
#line 1652 
  return __retres;
}


#line 1688 
unsigned char *skb_put(struct sk_buff *, unsigned int);


#line 1689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
  bool tmp_1;
  
#line 1691 
  unsigned char *tmp = skb_tail_pointer((struct sk_buff const *)skb);
  
#line 1692 
  tmp_1 = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 1692 
  if ((long)((int)tmp_1 != 0) != 0L) {
    
#line 1694 
    ldv_inline_asm();
    
#line 1692 
    ;
  }
  else ;
  
#line 1693 
  skb->tail += len;
  
#line 1694 
  skb->len += len;
  
#line 1695 
  return tmp;
}


#line 1719 
unsigned char *__pskb_pull_tail(struct sk_buff *, int);


#line 1735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  unsigned int tmp;
  unsigned char *tmp_1;
  unsigned int tmp_0;
  
#line 1737 
  tmp = skb_headlen((struct sk_buff const *)skb);
  
#line 1737 
  ;
  
#line 1737 
  if ((long)(tmp >= len) != 0L) {
    
#line 1738 
    __retres = 1;
    
#line 1738 
    goto return_label;
  }
  else ;
  
#line 1739 
  if ((long)(skb->len < len) != 0L) {
    
#line 1740 
    __retres = 0;
    
#line 1740 
    goto return_label;
  }
  else ;
  
#line 1741 
  tmp_0 = skb_headlen((struct sk_buff const *)skb);
  
#line 1741 
  ;
  
#line 1741 
  ;
  
#line 1741 
  tmp_1 = __pskb_pull_tail(skb,(int)(len - tmp_0));
  
#line 1741 
  __retres = tmp_1 != (unsigned char *)0U;
  return_label: 
#line 1741 
                return __retres;
}


#line 1750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1752 
  __retres = (unsigned int)((long)skb->data - (long)skb->head);
  
#line 1752 
  return __retres;
}


#line 1824  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_inner_transport_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1827 
  __retres = skb->head + (int)skb->inner_transport_header;
  
#line 1827 
  return __retres;
}


#line 1842  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_inner_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1844 
  __retres = skb->head + (int)skb->inner_network_header;
  
#line 1844 
  return __retres;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1882 
  __retres = skb->head + (int)skb->transport_header;
  
#line 1882 
  return __retres;
}


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1899 
  __retres = skb->head + (int)skb->network_header;
  
#line 1899 
  return __retres;
}


#line 1967  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_transport_offset(struct sk_buff const *skb)
{
  int __retres;
  unsigned char *tmp;
  
#line 1969 
  tmp = skb_transport_header(skb);
  
#line 1969 
  ;
  
#line 1969 
  __retres = (int)((long)tmp - (long)skb->data);
  
#line 1969 
  return __retres;
}


#line 1972  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u32 skb_network_header_len(struct sk_buff const *skb)
{
  u32 __retres;
  
#line 1974 
  __retres = (unsigned int)((int)skb->transport_header - (int)skb->network_header);
  
#line 1974 
  return __retres;
}


#line 1977  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static u32 skb_inner_network_header_len(struct sk_buff const *skb)
{
  u32 __retres;
  
#line 1979 
  __retres = (unsigned int)((int)skb->inner_transport_header - (int)skb->inner_network_header);
  
#line 1979 
  return __retres;
}


#line 1982  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_network_offset(struct sk_buff const *skb)
{
  int __retres;
  unsigned char *tmp;
  
#line 1984 
  tmp = skb_network_header(skb);
  
#line 1984 
  ;
  
#line 1984 
  __retres = (int)((long)tmp - (long)skb->data);
  
#line 1984 
  return __retres;
}


#line 1987  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_inner_network_offset(struct sk_buff const *skb)
{
  int __retres;
  unsigned char *tmp;
  
#line 1989 
  tmp = skb_inner_network_header(skb);
  
#line 1989 
  ;
  
#line 1989 
  __retres = (int)((long)tmp - (long)skb->data);
  
#line 1989 
  return __retres;
}


#line 2140 
struct sk_buff *__netdev_alloc_skb(struct net_device *, unsigned int, gfp_t);


#line 2176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev, unsigned int length, gfp_t gfp)
{
  
#line 2179 
  struct sk_buff *skb = __netdev_alloc_skb(dev,length,gfp);
  
#line 2183 
  return skb;
}


#line 2186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev, unsigned int length)
{
  struct sk_buff *tmp;
  
#line 2189 
  tmp = __netdev_alloc_skb_ip_align(dev,length,32U);
  
#line 2189 
  return tmp;
}


#line 2272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const *frag)
{
  struct page *__retres;
  
#line 2274 
  __retres = frag->page.p;
  
#line 2274 
  return __retres;
}


#line 2390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev, skb_frag_t const *frag, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t tmp_0;
  struct page *tmp;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  tmp = skb_frag_page(frag);
  
#line 2395 
  ;
  
#line 2395 
  tmp_0 = dma_map_page(dev,tmp,(unsigned long)frag->page_offset + offset,size,dir);
  
#line 2395 
  return tmp_0;
}


#line 2427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb, unsigned int headroom, int cloned)
{
  int __retres;
  unsigned int tmp_0;
  
#line 2430 
  int delta = 0;
  
#line 2432 
  tmp_0 = skb_headroom((struct sk_buff const *)skb);
  
#line 2432 
  ;
  
#line 2432 
  if (tmp_0 < headroom) {
    unsigned int tmp;
    
#line 2433 
    tmp = skb_headroom((struct sk_buff const *)skb);
    
#line 2433 
    delta = (int)(headroom - tmp);
  }
  else ;
  
#line 2435 
  if (delta != 0 || cloned != 0) {
    int tmp_5;
    int tmp_2;
    int tmp_4;
    {
      int tmp_1;
      
#line 2436 
      int _max1 = 32;
      
#line 2436 
      int _max2 = 64;
      
#line 2436 
      if (_max1 > _max2) 
#line 2436 
                         tmp_1 = _max1; else 
#line 2436 
                                             tmp_1 = _max2;
      
#line 2436 
      tmp_2 = tmp_1;
    }
    {
      int tmp_3;
      
#line 2436 
      int _max1_0 = 32;
      
#line 2436 
      int _max2_0 = 64;
      
#line 2436 
      if (_max1_0 > _max2_0) 
#line 2436 
                             tmp_3 = _max1_0; else 
#line 2436 
                                                   tmp_3 = _max2_0;
      
#line 2436 
      tmp_4 = tmp_3;
    }
    
#line 2436 
    ;
    
#line 2436 
    ;
    
#line 2436 
    tmp_5 = pskb_expand_head(skb,((tmp_2 + -1) + delta) & ~ (tmp_4 + -1),0,32U);
    
#line 2436 
    __retres = tmp_5;
    
#line 2436 
    goto return_label;
  }
  else ;
  
#line 2438 
  __retres = 0;
  return_label: 
#line 2438 
                return __retres;
}


#line 2468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
{
  int tmp_0;
  int tmp;
  
#line 2470 
  tmp = skb_header_cloned((struct sk_buff const *)skb);
  
#line 2470 
  ;
  
#line 2470 
  ;
  
#line 2470 
  tmp_0 = __skb_cow(skb,headroom,tmp);
  
#line 2470 
  return tmp_0;
}


#line 2501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  
#line 2503 
  unsigned int size = skb->len;
  
#line 2505 
  if ((long)(size < len) != 0L) {
    int tmp;
    
#line 2506 
    len -= size;
    
#line 2507 
    tmp = skb_pad(skb,(int)len);
    
#line 2507 
    if (tmp != 0) {
      
#line 2508 
      __retres = -12;
      
#line 2508 
      goto return_label;
    }
    else ;
    
#line 2509 
    __skb_put(skb,len);
  }
  else ;
  
#line 2511 
  __retres = 0;
  return_label: 
#line 2511 
                return __retres;
}


#line 2545  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int __skb_linearize(struct sk_buff *skb)
{
  int tmp_0;
  unsigned char *tmp;
  
#line 2547 
  tmp = __pskb_pull_tail(skb,(int)skb->data_len);
  
#line 2547 
  if (tmp != (unsigned char *)0U) 
#line 2547 
                                  tmp_0 = 0; else 
#line 2547 
                                                  tmp_0 = -12;
  
#line 2547 
  return tmp_0;
}


#line 2557  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_linearize(struct sk_buff *skb)
{
  int tmp_1;
  bool tmp;
  
#line 2559 
  tmp = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 2559 
  if ((int)tmp != 0) 
#line 2559 
                     tmp_1 = __skb_linearize(skb); else 
#line 2559 
                                                        tmp_1 = 0;
  
#line 2559 
  return tmp_1;
}


#line 2703 
int skb_copy_bits(struct sk_buff const *, int, void *, int);


#line 2751  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void *__skb_header_pointer(struct sk_buff const *skb, int offset, int len, void *data, int hlen, void *buffer)
{
  void *__retres;
  
#line 2754 
  if (hlen - offset >= len) {
    
#line 2755 
    __retres = data + offset;
    
#line 2755 
    goto return_label;
  }
  else ;
  
#line 2757 
  if (skb == (struct sk_buff const *)0) {
    
#line 2759 
    __retres = (void *)0;
    
#line 2759 
    goto return_label;
  }
  else {
    int tmp;
    
#line 2757 
    tmp = skb_copy_bits(skb,offset,buffer,len);
    
#line 2757 
    if (tmp < 0) {
      
#line 2759 
      __retres = (void *)0;
      
#line 2759 
      goto return_label;
    }
    else ;
  }
  
#line 2761 
  __retres = buffer;
  return_label: 
#line 2761 
                return __retres;
}


#line 2765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void *skb_header_pointer(struct sk_buff const *skb, int offset, int len, void *buffer)
{
  void *tmp_0;
  unsigned int tmp;
  
#line 2767 
  ;
  
#line 2768 
  tmp = skb_headlen(skb);
  
#line 2767 
  ;
  
#line 2767 
  ;
  
#line 2767 
  ;
  
#line 2767 
  ;
  
#line 2767 
  tmp_0 = __skb_header_pointer(skb,offset,len,(void *)skb->data,(int)tmp,buffer);
  
#line 2767 
  return tmp_0;
}


#line 2865 
void skb_clone_tx_timestamp(struct sk_buff *);


#line 2914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void sw_tx_timestamp(struct sk_buff *skb)
{
  unsigned char *tmp;
  
#line 2916 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2916 
  ;
  
#line 2916 
  if (((int)((struct skb_shared_info *)tmp)->tx_flags & 2) != 0) {
    unsigned char *tmp_0;
    
#line 2917 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2916 
    ;
    
#line 2916 
    if (((int)((struct skb_shared_info *)tmp_0)->tx_flags & 4) == 0) 
      
#line 2918 
      skb_tstamp_tx(skb,(struct skb_shared_hwtstamps *)0); else ;
  }
  else ;
  
#line 2919 
  return;
}


#line 2933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_tx_timestamp(struct sk_buff *skb)
{
  
#line 2935 
  skb_clone_tx_timestamp(skb);
  
#line 2936 
  sw_tx_timestamp(skb);
  
#line 2937 
  return;
}


#line 3305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb, u16 rx_queue)
{
  
#line 3307 
  skb->queue_mapping = (unsigned short)((unsigned int)rx_queue + 1U);
  
#line 3308 
  return;
}


#line 3384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff const *skb)
{
  bool __retres;
  unsigned char *tmp;
  
#line 3386 
  tmp = skb_end_pointer(skb);
  
#line 3386 
  ;
  
#line 3386 
  __retres = (_Bool)((unsigned int)((struct skb_shared_info *)tmp)->gso_size != 0U);
  
#line 3386 
  return __retres;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
__inline static void u64_stats_init(struct u64_stats_sync *syncp)
{
  
#line 73 
  return;
}


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void napi_complete_done(struct napi_struct *, int);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n)
{
  
#line 460 
  napi_complete_done(n,0);
  
#line 461 
  return;
}


#line 2505 
void netif_schedule_queue(struct netdev_queue *);


#line 2584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  int tmp;
  
#line 2586 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev_queue->state));
  
#line 2586 
  __retres = (_Bool)(tmp != 0);
  
#line 2586 
  return __retres;
}


#line 2600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_xmit_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  
#line 2602 
  __retres = (_Bool)((dev_queue->state & 3UL) != 0UL);
  
#line 2602 
  return __retres;
}


#line 2645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2649 
  dql_queued(& dev_queue->dql,bytes);
  
#line 2651 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2651 
  if ((long)(tmp >= 0) != 0L) 
#line 2652 
                              goto return_label; else ;
  
#line 2654 
  clear_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2655 
  ldv_inline_asm();
  
#line 2664 
  tmp_0 = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2664 
  if ((long)(tmp_0 >= 0) != 0L) 
#line 2665 
                                clear_bit(1L,(unsigned long volatile *)(& dev_queue->state)); else ;
  return_label: 
#line 2666 
                return;
}


#line 2683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue, unsigned int pkts, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2687 
  if ((long)(bytes == 0U) != 0L) 
#line 2688 
                                 goto return_label; else ;
  
#line 2690 
  dql_completed(& dev_queue->dql,bytes);
  
#line 2691 
  ldv_inline_asm();
  
#line 2699 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2699 
  if (tmp < 0) 
#line 2700 
               goto return_label; else ;
  
#line 2702 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2702 
  if (tmp_0 != 0) 
#line 2703 
                  netif_schedule_queue(dev_queue); else ;
  return_label: 
#line 2704 
                return;
}


#line 2723  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q)
{
  
#line 2726 
  clear_bit(1L,(unsigned long volatile *)(& q->state));
  
#line 2727 
  dql_reset(& q->dql);
  
#line 2728 
  return;
}


#line 2788  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_start_subqueue(struct net_device *dev, u16 queue_index)
{
  
#line 2790 
  struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,(unsigned int)queue_index);
  
#line 2792 
  netif_tx_start_queue(txq);
  
#line 2793 
  return;
}


#line 2815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device const *dev, u16 queue_index)
{
  bool tmp_0;
  
#line 2818 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  
#line 2820 
  tmp_0 = netif_tx_queue_stopped((struct netdev_queue const *)txq);
  
#line 2820 
  return tmp_0;
}


#line 2829 
void netif_wake_subqueue(struct net_device *, u16);


#line 2936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_consume_skb_any(struct sk_buff *skb)
{
  
#line 2938 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_CONSUMED);
  
#line 2939 
  return;
}


#line 2941 
int netif_rx(struct sk_buff *);


#line 2948 
gro_result_t napi_gro_receive(struct napi_struct *, struct sk_buff *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 25 
  tmp = (struct iphdr *)skb_network_header(skb);
  
#line 25 
  return tmp;
}


#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *inner_ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 30 
  tmp = (struct iphdr *)skb_inner_network_header(skb);
  
#line 30 
  return tmp;
}


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static struct tcphdr *tcp_hdr(struct sk_buff const *skb)
{
  struct tcphdr *tmp;
  
#line 29 
  tmp = (struct tcphdr *)skb_transport_header(skb);
  
#line 29 
  return tmp;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static unsigned int tcp_hdrlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  struct tcphdr *tmp;
  
#line 34 
  tmp = tcp_hdr(skb);
  
#line 34 
  ;
  
#line 34 
  __retres = (unsigned int)((int)tmp->doff * 4);
  
#line 34 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static struct tcphdr *inner_tcp_hdr(struct sk_buff const *skb)
{
  struct tcphdr *tmp;
  
#line 39 
  tmp = (struct tcphdr *)skb_inner_transport_header(skb);
  
#line 39 
  return tmp;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static unsigned int inner_tcp_hdrlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  struct tcphdr *tmp;
  
#line 44 
  tmp = inner_tcp_hdr(skb);
  
#line 44 
  ;
  
#line 44 
  __retres = (unsigned int)((int)tmp->doff * 4);
  
#line 44 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/udp.h"
__inline static struct udphdr *udp_hdr(struct sk_buff const *skb)
{
  struct udphdr *tmp;
  
#line 27 
  tmp = (struct udphdr *)skb_transport_header(skb);
  
#line 27 
  return tmp;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff const *skb)
{
  struct ipv6hdr *tmp;
  
#line 76 
  tmp = (struct ipv6hdr *)skb_network_header(skb);
  
#line 76 
  return tmp;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
__inline static struct ipv6hdr *inner_ipv6_hdr(struct sk_buff const *skb)
{
  struct ipv6hdr *tmp;
  
#line 81 
  tmp = (struct ipv6hdr *)skb_inner_network_header(skb);
  
#line 81 
  return tmp;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/busy_poll.h"
__inline static void skb_mark_napi_id(struct sk_buff *skb, struct napi_struct *napi)
{
  
#line 124 
  skb->__anonCompField_sk_buff_81.napi_id = napi->napi_id;
  
#line 125 
  return;
}


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/udp.h"
__inline static __wsum udp_csum(struct sk_buff *skb)
{
  __wsum tmp_0;
  unsigned char *tmp;
  unsigned char *tmp_1;
  
#line 143 
  ;
  
#line 143 
  tmp = skb_transport_header((struct sk_buff const *)skb);
  
#line 143 
  tmp_0 = csum_partial((void const *)tmp,8,skb->__anonCompField_sk_buff_80.csum);
  
#line 143 
  __wsum csum = tmp_0;
  
#line 146 
  tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 146 
  skb = ((struct skb_shared_info *)tmp_1)->frag_list;
  
#line 146 
  goto ldv_52590;
  ldv_52589: 
#line 147 
  ;
  
#line 147 
  csum = csum_add(csum,skb->__anonCompField_sk_buff_80.csum);
  
#line 146 
  skb = skb->__anonCompField_sk_buff_78.__anonCompField___anonunion_241_77.next;
  ldv_52590: 
#line 147 
  ;
  
#line 146 
  if (skb != (struct sk_buff *)0) 
#line 148 
                                  goto ldv_52589; else 
#line 151 
                                                       goto ldv_52591;
  ldv_52591: 
#line 152 
  ;
  
#line 149 
  return csum;
}


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__be16 eth_type_trans(struct sk_buff *, struct net_device *);


#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)
{
  
#line 412 
  skb->vlan_proto = vlan_proto;
  
#line 413 
  skb->vlan_tci = (unsigned short)((unsigned int)vlan_tci | 4096U);
  
#line 414 
  return;
}


#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static __be16 __vlan_get_protocol(struct sk_buff *skb, __be16 type, int *depth)
{
  __be16 __retres;
  
#line 484 
  unsigned int vlan_depth = (unsigned int)skb->mac_len;
  
#line 490 
  if ((unsigned int)type == 129U || (unsigned int)type == 43144U) {
    
#line 491 
    if (vlan_depth != 0U) {
      int tmp;
      {
        
#line 492 
        int __ret_warn_on = vlan_depth <= 3U;
        
#line 492 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 492 
                                              warn_slowpath_null("include/linux/if_vlan.h",492); else ;
        
#line 492 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 492 
      if ((long)tmp != 0L) {
        
#line 493 
        __retres = (unsigned short)0U;
        
#line 493 
        goto return_label;
      }
      else ;
      
#line 494 
      vlan_depth += 4294967292U;
    }
    else 
#line 496 
         vlan_depth = 14U;
    ldv_57504: 
#line 497 
    ;
    {
      struct vlan_hdr *vh;
      int tmp_0;
      
#line 501 
      tmp_0 = pskb_may_pull(skb,vlan_depth + 4U);
      
#line 501 
      if ((long)(tmp_0 == 0) != 0L) {
        
#line 503 
        __retres = (unsigned short)0U;
        
#line 503 
        goto return_label;
      }
      else ;
      
#line 505 
      vh = (struct vlan_hdr *)(skb->data + vlan_depth);
      
#line 506 
      type = vh->h_vlan_encapsulated_proto;
      
#line 507 
      vlan_depth += 4U;
    }
    
#line 509 
    if ((unsigned int)type == 129U || (unsigned int)type == 43144U) 
#line 511 
                                                                    goto ldv_57504; else 
                                                                    
#line 514 
                                                                    goto ldv_57505;
    ldv_57505: 
#line 515 
    ;
  }
  else ;
  
#line 512 
  if (depth != (int *)0) 
#line 513 
                         *depth = (int)vlan_depth; else ;
  
#line 515 
  __retres = type;
  return_label: 
#line 515 
                return __retres;
}


#line 525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static __be16 vlan_get_protocol(struct sk_buff *skb)
{
  __be16 tmp;
  
#line 527 
  tmp = __vlan_get_protocol(skb,(unsigned short)((int)skb->protocol),(int *)0);
  
#line 527 
  return tmp;
}


#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
struct i40e_rx_ptype_decoded i40e_ptype_lookup[256U];


#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
__inline static struct i40e_rx_ptype_decoded decode_rx_desc_ptype(u8 ptype)
{
  struct i40e_rx_ptype_decoded __retres;
  
#line 285 
  __retres = i40e_ptype_lookup[(int)ptype];
  
#line 285 
  return __retres;
}


#line 305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
void i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb, struct i40e_tx_buffer *first, u32 tx_flags, u8 const hdr_len, u32 td_cmd, u32 td_offset);


#line 308 
int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size);


#line 309 
int i40e_xmit_descriptor_count(struct sk_buff *skb, struct i40e_ring *tx_ring);


#line 310 
int i40e_tx_prepare_vlan_flags(struct sk_buff *skb, struct i40e_ring *tx_ring, u32 *flags);


#line 611  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static bool i40e_rx_is_programming_status(u64 qw)
{
  bool __retres;
  
#line 613 
  __retres = (_Bool)(qw >> 38 == 33554432ULL);
  
#line 613 
  return __retres;
}


#line 731 
int i40e_fcoe_handle_offload(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, struct sk_buff *skb);


#line 734 
void i40e_fcoe_handle_status(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, u8 prog_id);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static __le64 build_ctob(u32 td_cmd, u32 td_offset, unsigned int size, u32 td_tag)
{
  __le64 __retres;
  
#line 35 
  __retres = ((((unsigned long long)td_cmd << 4) | ((unsigned long long)td_offset << 16)) | ((unsigned long long)size << 34)) | ((unsigned long long)td_tag << 48);
  
#line 35 
  return __retres;
}


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_program_fdir_filter(struct i40e_fdir_filter *fdir_data, u8 *raw_packet, struct i40e_pf *pf, bool add)
{
  int __retres;
  struct i40e_filter_program_desc *fdir_desc;
  struct i40e_tx_buffer *tx_buf;
  struct i40e_tx_buffer *first;
  struct i40e_tx_desc *tx_desc;
  struct i40e_ring *tx_ring;
  unsigned int fpt;
  unsigned int dcc;
  struct i40e_vsi *vsi;
  struct device *dev;
  dma_addr_t dma;
  u16 i;
  int tmp;
  int tmp_0;
  int tmp_1;
  
#line 62 
  u32 td_cmd = 0U;
  
#line 63 
  u16 delay = (unsigned short)0U;
  
#line 67 
  vsi = (struct i40e_vsi *)0;
  
#line 68 
  i = (unsigned short)0U;
  
#line 68 
  goto ldv_61495;
  ldv_61494: 
#line 69 
  ;
  
#line 69 
  if (*(pf->vsi + (int)i) != (struct i40e_vsi *)0 && (*(pf->vsi + (int)i))->type == (unsigned int)I40E_VSI_FDIR) 
    
#line 70 
    vsi = *(pf->vsi + (int)i); else ;
  
#line 68 
  i = (u16)((int)i + 1);
  ldv_61495: 
#line 69 
  ;
  
#line 68 
  if ((int)pf->num_alloc_vsi > (int)i) 
#line 70 
                                       goto ldv_61494; else 
#line 73 
                                                            goto ldv_61496;
  ldv_61496: 
#line 74 
  ;
  
#line 71 
  if (vsi == (struct i40e_vsi *)0) {
    
#line 72 
    __retres = -2;
    
#line 72 
    goto return_label;
  }
  else ;
  
#line 74 
  tx_ring = *(vsi->tx_rings);
  
#line 75 
  dev = tx_ring->dev;
  ldv_61498: 
#line 76 
  ;
  
#line 79 
  if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
#line 79 
                                                                tmp = (int)tx_ring->count; else 
                                                                    
#line 79 
                                                                    tmp = 0;
  
#line 79 
  ;
  
#line 79 
  if (((tmp + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use) + -1 > 1) 
    
#line 80 
    goto ldv_61497; else ;
  
#line 81 
  msleep_interruptible(1U);
  
#line 82 
  delay = (u16)((int)delay + 1);
  
#line 83 
  if ((unsigned int)delay <= 9U) 
#line 85 
                                 goto ldv_61498; else 
#line 88 
                                                      goto ldv_61497;
  ldv_61497: 
#line 89 
  ;
  
#line 85 
  if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
#line 85 
                                                                tmp_0 = (int)tx_ring->count; else 
                                                                    
#line 85 
                                                                    tmp_0 = 0;
  
#line 85 
  ;
  
#line 85 
  if (((tmp_0 + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use) + -1 <= 1) {
    
#line 86 
    __retres = -11;
    
#line 86 
    goto return_label;
  }
  else ;
  
#line 88 
  dma = dma_map_single_attrs(dev,(void *)raw_packet,512UL,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 90 
  tmp_1 = dma_mapping_error(dev,dma);
  
#line 90 
  if (tmp_1 != 0) 
#line 91 
                  goto dma_fail; else ;
  
#line 94 
  i = tx_ring->next_to_use;
  
#line 95 
  fdir_desc = (struct i40e_filter_program_desc *)tx_ring->desc + (int)i;
  
#line 96 
  first = tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)i;
  
#line 97 
  memset((void *)first,0,40UL);
  
#line 99 
  if ((int)i + 1 < (int)tx_ring->count) 
#line 99 
                                        tx_ring->next_to_use = (unsigned short)((unsigned int)i + 1U); else 
                                                                    
#line 99 
                                                                    tx_ring->next_to_use = (unsigned short)0U;
  
#line 101 
  fpt = (unsigned int)fdir_data->q_index & 2047U;
  
#line 104 
  fpt = ((unsigned int)((int)fdir_data->flex_off << 11) & 14336U) | fpt;
  
#line 107 
  fpt = ((unsigned int)((int)fdir_data->pctype << 17) & 8257536U) | fpt;
  
#line 111 
  if ((unsigned int)fdir_data->dest_vsi == 0U) 
#line 112 
                                               fpt = (unsigned int)((int)(*(pf->vsi + (int)pf->lan_vsi))->id << 23) | fpt; else 
                                                                    
#line 115 
                                                                    fpt = ((unsigned int)fdir_data->dest_vsi << 23) | fpt;
  
#line 119 
  dcc = 8U;
  
#line 121 
  if ((int)add != 0) 
#line 122 
                     dcc |= 16U; else 
#line 125 
                                      dcc |= 32U;
  
#line 128 
  dcc = ((unsigned int)((int)fdir_data->dest_ctl << 7ULL) & 384U) | dcc;
  
#line 131 
  dcc = ((unsigned int)((int)fdir_data->fd_status << 13ULL) & 24576U) | dcc;
  
#line 134 
  if ((unsigned int)fdir_data->cnt_index != 0U) {
    
#line 135 
    dcc |= 2048U;
    
#line 136 
    dcc = (((unsigned int)fdir_data->cnt_index << 20) & 535822336U) | dcc;
  }
  else ;
  
#line 141 
  fdir_desc->qindex_flex_ptype_vsi = fpt;
  
#line 142 
  fdir_desc->rsvd = 0U;
  
#line 143 
  fdir_desc->dtype_cmd_cntindex = dcc;
  
#line 144 
  fdir_desc->fd_id = fdir_data->fd_id;
  
#line 147 
  i = tx_ring->next_to_use;
  
#line 148 
  tx_desc = (struct i40e_tx_desc *)tx_ring->desc + (int)i;
  
#line 149 
  tx_buf = tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)i;
  
#line 151 
  if ((int)i + 1 < (int)tx_ring->count) 
#line 151 
                                        tx_ring->next_to_use = (unsigned short)((unsigned int)i + 1U); else 
                                                                    
#line 151 
                                                                    tx_ring->next_to_use = (unsigned short)0U;
  
#line 153 
  memset((void *)tx_buf,0,40UL);
  
#line 156 
  tx_buf->len = 512U;
  
#line 157 
  tx_buf->dma = dma;
  
#line 159 
  tx_desc->buffer_addr = dma;
  
#line 160 
  td_cmd = 19U;
  
#line 162 
  tx_buf->tx_flags = 512U;
  
#line 163 
  tx_buf->__anonCompField_i40e_tx_buffer_120.raw_buf = (void *)raw_packet;
  
#line 165 
  tx_desc->cmd_type_offset_bsz = build_ctob(td_cmd,0U,512U,0U);
  
#line 167 
  ldv_inline_asm();
  
#line 174 
  first->next_to_watch = tx_desc;
  
#line 176 
  writel((unsigned int)tx_ring->next_to_use,(void volatile *)tx_ring->tail);
  
#line 177 
  __retres = 0;
  
#line 177 
  goto return_label;
  dma_fail: 
#line 179 
  ;
  
#line 180 
  __retres = -1;
  return_label: 
#line 180 
                return __retres;
}


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_add_del_fdir_udpv4(struct i40e_vsi *vsi, struct i40e_fdir_filter *fd_data, bool add)
{
  int __retres;
  struct udphdr *udp;
  struct iphdr *ip;
  u8 *raw_packet;
  int ret;
  int tmp_0;
  
#line 197 
  struct i40e_pf *pf = vsi->back;
  
#line 200 
  bool err = (_Bool)0;
  
#line 203 
  char packet[42U] = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)8, (char)0, (char)69, (char)0, (char)0, (char)28, (char)0, (char)0, (char)64, (char)0, (char)64, (char)17, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0};
  
#line 207 
  raw_packet = (u8 *)kzalloc_3(512UL,208U);
  
#line 208 
  if (raw_packet == (u8 *)0U) {
    
#line 209 
    __retres = -12;
    
#line 209 
    goto return_label;
  }
  else ;
  
#line 210 
  memcpy((void *)raw_packet,(void const *)(& packet),42UL);
  
#line 212 
  ip = (struct iphdr *)(raw_packet + 14U);
  
#line 213 
  udp = (struct udphdr *)(raw_packet + 34U);
  
#line 216 
  ip->daddr = fd_data->dst_ip[0];
  
#line 217 
  udp->dest = fd_data->dst_port;
  
#line 218 
  ip->saddr = fd_data->src_ip[0];
  
#line 219 
  udp->source = fd_data->src_port;
  
#line 221 
  fd_data->pctype = (unsigned char)31U;
  
#line 222 
  ret = i40e_program_fdir_filter(fd_data,raw_packet,pf,(_Bool)((bool)((int)add) != 0));
  
#line 223 
  if (ret != 0) {
    
#line 224 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"PCTYPE:%d, Filter command send failed for fd_id:%d (ret = %d)\n",(int)fd_data->pctype,fd_data->fd_id,ret);
    
#line 227 
    err = (_Bool)1;
  }
  else 
    
#line 228 
    if ((pf->hw.debug_mask & 4096U) != 0U) 
      
#line 229 
      if ((int)add != 0) 
#line 230 
                         _dev_info((struct device const *)(& (pf->pdev)->dev),"Filter OK for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id); else 
                                                                    
#line 234 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"Filter deleted for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id);
    else ;
  
#line 238 
  if ((int)err != 0) 
#line 238 
                     tmp_0 = -95; else 
#line 238 
                                       tmp_0 = 0;
  
#line 238 
  __retres = tmp_0;
  return_label: 
#line 238 
                return __retres;
}


#line 250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_add_del_fdir_tcpv4(struct i40e_vsi *vsi, struct i40e_fdir_filter *fd_data, bool add)
{
  int __retres;
  struct tcphdr *tcp;
  struct iphdr *ip;
  u8 *raw_packet;
  int ret;
  int tmp_0;
  
#line 254 
  struct i40e_pf *pf = vsi->back;
  
#line 257 
  bool err = (_Bool)0;
  
#line 261 
  char packet[54U] = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)8, (char)0, (char)69, (char)0, (char)0, (char)40, (char)0, (char)0, (char)64, (char)0, (char)64, (char)6, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)(-128), (char)17, (char)0, (char)114, (char)0, (char)0, (char)0, (char)0};
  
#line 266 
  raw_packet = (u8 *)kzalloc_3(512UL,208U);
  
#line 267 
  if (raw_packet == (u8 *)0U) {
    
#line 268 
    __retres = -12;
    
#line 268 
    goto return_label;
  }
  else ;
  
#line 269 
  memcpy((void *)raw_packet,(void const *)(& packet),54UL);
  
#line 271 
  ip = (struct iphdr *)(raw_packet + 14U);
  
#line 272 
  tcp = (struct tcphdr *)(raw_packet + 34U);
  
#line 275 
  ip->daddr = fd_data->dst_ip[0];
  
#line 276 
  tcp->dest = fd_data->dst_port;
  
#line 277 
  ip->saddr = fd_data->src_ip[0];
  
#line 278 
  tcp->source = fd_data->src_port;
  
#line 280 
  if ((int)add != 0) {
    
#line 281 
    pf->fd_tcp_rule += 1U;
    
#line 282 
    if ((pf->flags & 4194304ULL) != 0ULL) {
      
#line 283 
      if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 284 
                                             _dev_info((struct device const *)(& (pf->pdev)->dev),"Forcing ATR off, sideband rules for TCP/IPv4 flow being applied\n"); else ;
      
#line 285 
      pf->flags &= 18446744073705357311ULL;
    }
    else ;
  }
  else {
    
#line 288 
    if (pf->fd_tcp_rule != 0U) 
#line 288 
                               pf->fd_tcp_rule += 4294967295U; else 
#line 288 
                                                                    pf->fd_tcp_rule = 0U;
    
#line 290 
    if (pf->fd_tcp_rule == 0U) {
      
#line 291 
      pf->flags |= 4194304ULL;
      
#line 292 
      if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 293 
                                             _dev_info((struct device const *)(& (pf->pdev)->dev),"ATR re-enabled due to no sideband TCP/IPv4 rules\n"); else ;
    }
    else ;
  }
  
#line 297 
  fd_data->pctype = (unsigned char)33U;
  
#line 298 
  ret = i40e_program_fdir_filter(fd_data,raw_packet,pf,(_Bool)((bool)((int)add) != 0));
  
#line 300 
  if (ret != 0) {
    
#line 301 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"PCTYPE:%d, Filter command send failed for fd_id:%d (ret = %d)\n",(int)fd_data->pctype,fd_data->fd_id,ret);
    
#line 304 
    err = (_Bool)1;
  }
  else 
    
#line 305 
    if ((pf->hw.debug_mask & 4096U) != 0U) 
      
#line 306 
      if ((int)add != 0) 
#line 307 
                         _dev_info((struct device const *)(& (pf->pdev)->dev),"Filter OK for PCTYPE %d loc = %d)\n",(int)fd_data->pctype,fd_data->fd_id); else 
                                                                    
#line 310 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"Filter deleted for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id);
    else ;
  
#line 315 
  if ((int)err != 0) 
#line 315 
                     tmp_0 = -95; else 
#line 315 
                                       tmp_0 = 0;
  
#line 315 
  __retres = tmp_0;
  return_label: 
#line 315 
                return __retres;
}


#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_add_del_fdir_sctpv4(struct i40e_vsi *vsi, struct i40e_fdir_filter *fd_data, bool add)
{
  int __retres;
  
#line 331 
  __retres = -95;
  
#line 331 
  return __retres;
}


#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_add_del_fdir_ipv4(struct i40e_vsi *vsi, struct i40e_fdir_filter *fd_data, bool add)
{
  int __retres;
  struct iphdr *ip;
  u8 *raw_packet;
  int ret;
  int i;
  int tmp_0;
  
#line 348 
  struct i40e_pf *pf = vsi->back;
  
#line 350 
  bool err = (_Bool)0;
  
#line 354 
  char packet[34U] = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)8, (char)0, (char)69, (char)0, (char)0, (char)20, (char)0, (char)0, (char)64, (char)0, (char)64, (char)16, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0};
  
#line 358 
  i = 35;
  
#line 358 
  goto ldv_61542;
  ldv_61541: 
#line 359 
  ;
  
#line 360 
  raw_packet = (u8 *)kzalloc_3(512UL,208U);
  
#line 361 
  if (raw_packet == (u8 *)0U) {
    
#line 362 
    __retres = -12;
    
#line 362 
    goto return_label;
  }
  else ;
  
#line 363 
  memcpy((void *)raw_packet,(void const *)(& packet),34UL);
  
#line 364 
  ip = (struct iphdr *)(raw_packet + 14U);
  
#line 366 
  ip->saddr = fd_data->src_ip[0];
  
#line 367 
  ip->daddr = fd_data->dst_ip[0];
  
#line 368 
  ip->protocol = (unsigned char)0U;
  
#line 370 
  fd_data->pctype = (unsigned char)i;
  
#line 371 
  ret = i40e_program_fdir_filter(fd_data,raw_packet,pf,(_Bool)((bool)((int)add) != 0));
  
#line 373 
  if (ret != 0) {
    
#line 374 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"PCTYPE:%d, Filter command send failed for fd_id:%d (ret = %d)\n",(int)fd_data->pctype,fd_data->fd_id,ret);
    
#line 377 
    err = (_Bool)1;
  }
  else 
    
#line 378 
    if ((pf->hw.debug_mask & 4096U) != 0U) 
      
#line 379 
      if ((int)add != 0) 
#line 380 
                         _dev_info((struct device const *)(& (pf->pdev)->dev),"Filter OK for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id); else 
                                                                    
#line 384 
                                                                    _dev_info((struct device const *)(& (pf->pdev)->dev),"Filter deleted for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id);
    else ;
  
#line 359 
  i += 1;
  ldv_61542: 
#line 360 
  ;
  
#line 358 
  if (i <= 36) 
#line 361 
               goto ldv_61541; else 
#line 364 
                                    goto ldv_61543;
  ldv_61543: 
#line 365 
  ;
  
#line 390 
  if ((int)err != 0) 
#line 390 
                     tmp_0 = -95; else 
#line 390 
                                       tmp_0 = 0;
  
#line 390 
  __retres = tmp_0;
  return_label: 
#line 390 
                return __retres;
}


#line 400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_add_del_fdir(struct i40e_vsi *vsi, struct i40e_fdir_filter *input, bool add)
{
  int ret;
  
#line 403 
  struct i40e_pf *pf = vsi->back;
  
#line 406 
  switch ((unsigned int)input->flow_type) {
    case (unsigned int)1: 
#line 407 
    ;
    
#line 408 
    ret = i40e_add_del_fdir_tcpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
    
#line 409 
    goto ldv_61552;
    case (unsigned int)2: 
#line 410 
    ;
    
#line 411 
    ret = i40e_add_del_fdir_udpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
    
#line 412 
    goto ldv_61552;
    case (unsigned int)3: 
#line 413 
    ;
    
#line 414 
    ret = i40e_add_del_fdir_sctpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
    
#line 415 
    goto ldv_61552;
    case (unsigned int)16: 
#line 416 
    ;
    
#line 417 
    ret = i40e_add_del_fdir_ipv4(vsi,input,(_Bool)((bool)((int)add) != 0));
    
#line 418 
    goto ldv_61552;
    case (unsigned int)13: 
#line 419 
    ;
    
#line 420 
    switch ((int)input->ip4_proto) {
      case 6: 
#line 421 
      ;
      
#line 422 
      ret = i40e_add_del_fdir_tcpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
      
#line 423 
      goto ldv_61558;
      case 17: 
#line 424 
      ;
      
#line 425 
      ret = i40e_add_del_fdir_udpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
      
#line 426 
      goto ldv_61558;
      case 132: 
#line 427 
      ;
      
#line 428 
      ret = i40e_add_del_fdir_sctpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
      
#line 429 
      goto ldv_61558;
      default: 
#line 430 
      ;
      
#line 431 
      ret = i40e_add_del_fdir_ipv4(vsi,input,(_Bool)((bool)((int)add) != 0));
      
#line 432 
      goto ldv_61558;
    }
    ldv_61558: 
#line 434 
    ;
    
#line 434 
    goto ldv_61552;
    default: 
#line 435 
    ;
    
#line 436 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Could not specify spec type %d\n",(int)input->flow_type);
    
#line 438 
    ret = -22;
  }
  ldv_61552: 
#line 442 
  ;
  
#line 442 
  return ret;
}


#line 454  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_fd_handle_status(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, u8 prog_id)
{
  u32 fcnt_prog;
  u32 fcnt_avail;
  u32 error;
  u64 qw;
  
#line 457 
  struct i40e_pf *pf = (rx_ring->vsi)->back;
  
#line 458 
  struct pci_dev *pdev = pf->pdev;
  
#line 463 
  qw = rx_desc->wb.qword1.status_error_len;
  
#line 464 
  error = (unsigned int)(qw >> 19) & 63U;
  
#line 467 
  if (error == 1U) {
    int tmp;
    
#line 468 
    if (rx_desc->wb.qword0.hi_dword.fd_id != 0U || (pf->hw.debug_mask & 4096U) != 0U) 
      
#line 470 
      dev_warn((struct device const *)(& pdev->dev),"ntuple filter loc = %d, could not be added\n",rx_desc->wb.qword0.hi_dword.fd_id); else ;
    
#line 479 
    tmp = constant_test_bit(22L,(unsigned long const volatile *)(& pf->state));
    
#line 479 
    if (tmp != 0) 
#line 480 
                  goto return_label; else ;
    
#line 482 
    pf->fd_add_err += 1U;
    
#line 484 
    pf->fd_atr_cnt = i40e_get_current_atr_cnt(pf);
    
#line 486 
    if (rx_desc->wb.qword0.hi_dword.fd_id == 0U && (pf->auto_disable_flags & 2097152ULL) != 0ULL) {
      
#line 488 
      pf->auto_disable_flags |= 4194304ULL;
      
#line 489 
      clear_bit(22L,(unsigned long volatile *)(& pf->state));
    }
    else ;
    
#line 493 
    fcnt_prog = i40e_get_global_fd_count(pf);
    
#line 494 
    fcnt_avail = (unsigned int)pf->fdir_pf_filter_count;
    
#line 499 
    if (fcnt_avail + 4294967286U <= fcnt_prog) {
      
#line 500 
      if ((pf->flags & 2097152ULL) != 0ULL && (pf->auto_disable_flags & 2097152ULL) == 0ULL) {
        
#line 503 
        if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 504 
                                               dev_warn((struct device const *)(& pdev->dev),"FD filter space full, new ntuple rules will not be added\n"); else ;
        
#line 505 
        pf->auto_disable_flags |= 2097152ULL;
      }
      else ;
    }
    else 
#line 509 
         _dev_info((struct device const *)(& pdev->dev),"FD filter programming failed due to incorrect filter parameters\n");
  }
  else 
    
#line 512 
    if (error == 2U) {
      
#line 514 
      if ((pf->hw.debug_mask & 4096U) != 0U) 
#line 515 
                                             _dev_info((struct device const *)(& pdev->dev),"ntuple filter fd_id = %d, could not be removed\n",rx_desc->wb.qword0.hi_dword.fd_id); else ;
    }
    else ;
  return_label: 
#line 516 
                return;
}


#line 525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_unmap_and_free_tx_resource(struct i40e_ring *ring, struct i40e_tx_buffer *tx_buffer)
{
  
#line 528 
  if (tx_buffer->__anonCompField_i40e_tx_buffer_120.skb != (struct sk_buff *)0) {
    
#line 529 
    if ((tx_buffer->tx_flags & 512U) != 0U) 
#line 530 
                                            kfree((void const *)tx_buffer->__anonCompField_i40e_tx_buffer_120.raw_buf); else 
                                                                    
#line 532 
                                                                    dev_kfree_skb_any(tx_buffer->__anonCompField_i40e_tx_buffer_120.skb);
    
#line 534 
    if (tx_buffer->len != 0U) 
#line 535 
                              dma_unmap_single_attrs(ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0); else ;
  }
  else 
    
#line 539 
    if (tx_buffer->len != 0U) 
#line 540 
                              dma_unmap_page(ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE); else ;
  
#line 545 
  tx_buffer->next_to_watch = (struct i40e_tx_desc *)0;
  
#line 546 
  tx_buffer->__anonCompField_i40e_tx_buffer_120.skb = (struct sk_buff *)0;
  
#line 547 
  tx_buffer->len = 0U;
  
#line 548 
  return;
}


#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_clean_tx_ring(struct i40e_ring *tx_ring)
{
  unsigned long bi_size;
  u16 i;
  struct netdev_queue *tmp;
  
#line 561 
  if (tx_ring->__anonCompField_i40e_ring_121.tx_bi == (struct i40e_tx_buffer *)0) 
    
#line 562 
    goto return_label; else ;
  
#line 565 
  i = (unsigned short)0U;
  
#line 565 
  goto ldv_61584;
  ldv_61583: 
#line 566 
  ;
  
#line 566 
  i40e_unmap_and_free_tx_resource(tx_ring,tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)i);
  
#line 565 
  i = (u16)((int)i + 1);
  ldv_61584: 
#line 566 
  ;
  
#line 565 
  if ((int)tx_ring->count > (int)i) 
#line 567 
                                    goto ldv_61583; else 
#line 570 
                                                         goto ldv_61585;
  ldv_61585: 
#line 571 
  ;
  
#line 568 
  bi_size = (unsigned long)tx_ring->count * 40UL;
  
#line 569 
  memset((void *)tx_ring->__anonCompField_i40e_ring_121.tx_bi,0,bi_size);
  
#line 572 
  memset(tx_ring->desc,0,(unsigned long)tx_ring->size);
  
#line 574 
  tx_ring->next_to_use = (unsigned short)0U;
  
#line 575 
  tx_ring->next_to_clean = (unsigned short)0U;
  
#line 577 
  if (tx_ring->netdev == (struct net_device *)0) 
#line 578 
                                                 goto return_label; else ;
  
#line 581 
  tmp = netdev_get_tx_queue((struct net_device const *)tx_ring->netdev,(unsigned int)tx_ring->queue_index);
  
#line 581 
  netdev_tx_reset_queue(tmp);
  return_label: 
#line 583 
                return;
}


#line 591  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_free_tx_resources(struct i40e_ring *tx_ring)
{
  
#line 593 
  i40e_clean_tx_ring(tx_ring);
  
#line 594 
  kfree((void const *)tx_ring->__anonCompField_i40e_ring_121.tx_bi);
  
#line 595 
  tx_ring->__anonCompField_i40e_ring_121.tx_bi = (struct i40e_tx_buffer *)0;
  
#line 597 
  if (tx_ring->desc != (void *)0) {
    
#line 598 
    dma_free_attrs(tx_ring->dev,(unsigned long)tx_ring->size,tx_ring->desc,tx_ring->dma,(struct dma_attrs *)0);
    
#line 600 
    tx_ring->desc = (void *)0;
  }
  else ;
  
#line 602 
  return;
}


#line 611  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static u32 i40e_get_head(struct i40e_ring *tx_ring)
{
  u32 __retres;
  
#line 613 
  void *head = tx_ring->desc + (int)tx_ring->count;
  
#line 615 
  __retres = *((__le32 volatile *)head);
  
#line 615 
  return __retres;
}


#line 625  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static u32 i40e_get_tx_pending(struct i40e_ring *ring)
{
  u32 __retres;
  u32 head;
  u32 tail;
  
#line 629 
  head = i40e_get_head(ring);
  
#line 630 
  tail = readl((void const volatile *)ring->tail);
  
#line 632 
  if (head != tail) {
    u32 tmp;
    
#line 634 
    if (head < tail) 
#line 634 
                     tmp = tail - head; else 
#line 634 
                                             tmp = ((unsigned int)ring->count + tail) - head;
    
#line 634 
    __retres = tmp;
    
#line 634 
    goto return_label;
  }
  else ;
  
#line 636 
  __retres = 0U;
  return_label: 
#line 636 
                return __retres;
}


#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static bool i40e_check_tx_hang(struct i40e_ring *tx_ring)
{
  
#line 645 
  u32 tx_done = (unsigned int)tx_ring->stats.packets;
  
#line 646 
  u32 tx_done_old = (unsigned int)tx_ring->__anonCompField_i40e_ring_122.tx_stats.tx_done_old;
  
#line 647 
  u32 tx_pending = i40e_get_tx_pending(tx_ring);
  
#line 648 
  struct i40e_pf *pf = (tx_ring->vsi)->back;
  
#line 649 
  bool ret = (_Bool)0;
  
#line 651 
  clear_bit(2L,(unsigned long volatile *)(& tx_ring->state));
  
#line 664 
  if (tx_done_old == tx_done && tx_pending != 0U) {
    int tmp_0;
    
#line 666 
    tmp_0 = test_and_set_bit(3L,(unsigned long volatile *)(& tx_ring->state));
    
#line 666 
    ret = (_Bool)(tmp_0 != 0);
  }
  else 
    
#line 668 
    if ((tx_done_old == tx_done && tx_pending <= 3U) && tx_pending != 0U) {
      
#line 670 
      if ((pf->hw.debug_mask & 512U) != 0U) 
#line 671 
                                            _dev_info((struct device const *)tx_ring->dev,"HW needs some more descs to do a cacheline flush. tx_pending %d, queue %d",tx_pending,(int)tx_ring->queue_index); else ;
      
#line 673 
      pf->tx_sluggish_count += 1U;
    }
    else {
      
#line 676 
      tx_ring->__anonCompField_i40e_ring_122.tx_stats.tx_done_old = (unsigned long long)tx_done;
      
#line 677 
      clear_bit(3L,(unsigned long volatile *)(& tx_ring->state));
    }
  
#line 680 
  return ret;
}


#line 692  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static bool i40e_clean_tx_irq(struct i40e_ring *tx_ring, int budget)
{
  bool __retres;
  struct i40e_tx_buffer *tx_buf;
  struct i40e_tx_desc *tx_head;
  struct i40e_tx_desc *tx_desc;
  u32 tmp;
  int tmp_2;
  struct netdev_queue *tmp_4;
  int tmp_8;
  
#line 694 
  u16 i = tx_ring->next_to_clean;
  
#line 698 
  unsigned int total_packets = 0U;
  
#line 699 
  unsigned int total_bytes = 0U;
  
#line 701 
  tx_buf = tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)i;
  
#line 702 
  tx_desc = (struct i40e_tx_desc *)tx_ring->desc + (int)i;
  
#line 703 
  i = (unsigned short)((int)i - (int)tx_ring->count);
  
#line 705 
  tmp = i40e_get_head(tx_ring);
  
#line 705 
  tx_head = (struct i40e_tx_desc *)tx_ring->desc + tmp;
  ldv_61621: 
#line 706 
  ;
  {
    
#line 708 
    struct i40e_tx_desc *eop_desc = tx_buf->next_to_watch;
    
#line 711 
    if (eop_desc == (struct i40e_tx_desc *)0) 
#line 712 
                                              goto ldv_61617; else ;
    
#line 718 
    if (tx_head == tx_desc) 
#line 719 
                            goto ldv_61617; else ;
    
#line 722 
    tx_buf->next_to_watch = (struct i40e_tx_desc *)0;
    
#line 725 
    total_bytes = tx_buf->bytecount + total_bytes;
    
#line 726 
    total_packets = (unsigned int)tx_buf->gso_segs + total_packets;
    
#line 729 
    dev_consume_skb_any(tx_buf->__anonCompField_i40e_tx_buffer_120.skb);
    
#line 732 
    dma_unmap_single_attrs(tx_ring->dev,tx_buf->dma,(unsigned long)tx_buf->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 738 
    tx_buf->__anonCompField_i40e_tx_buffer_120.skb = (struct sk_buff *)0;
    
#line 739 
    tx_buf->len = 0U;
    
#line 742 
    goto ldv_61619;
    ldv_61618: 
#line 743 
    ;
    
#line 744 
    tx_buf += 1;
    
#line 745 
    tx_desc += 1;
    
#line 746 
    i = (u16)((int)i + 1);
    
#line 747 
    if ((long)((unsigned int)i == 0U) != 0L) {
      
#line 748 
      i = (unsigned short)((int)i - (int)tx_ring->count);
      
#line 749 
      tx_buf = tx_ring->__anonCompField_i40e_ring_121.tx_bi;
      
#line 750 
      tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
    }
    else ;
    
#line 754 
    if (tx_buf->len != 0U) {
      
#line 755 
      dma_unmap_page(tx_ring->dev,tx_buf->dma,(unsigned long)tx_buf->len,(enum dma_data_direction)DMA_TO_DEVICE);
      
#line 759 
      tx_buf->len = 0U;
    }
    else ;
    ldv_61619: 
#line 761 
    ;
    
#line 742 
    if (tx_desc != eop_desc) 
#line 744 
                             goto ldv_61618; else 
#line 747 
                                                  goto ldv_61620;
    ldv_61620: 
#line 748 
    ;
    
#line 764 
    tx_buf += 1;
    
#line 765 
    tx_desc += 1;
    
#line 766 
    i = (u16)((int)i + 1);
    
#line 767 
    if ((long)((unsigned int)i == 0U) != 0L) {
      
#line 768 
      i = (unsigned short)((int)i - (int)tx_ring->count);
      
#line 769 
      tx_buf = tx_ring->__anonCompField_i40e_ring_121.tx_bi;
      
#line 770 
      tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
    }
    else ;
    
#line 773 
    __builtin_prefetch((void const *)tx_desc);
    
#line 776 
    budget -= 1;
  }
  
#line 777 
  if ((long)(budget != 0) != 0L) 
#line 779 
                                 goto ldv_61621; else 
#line 782 
                                                      goto ldv_61617;
  ldv_61617: 
#line 783 
  ;
  
#line 779 
  i = (unsigned short)((int)tx_ring->count + (int)i);
  
#line 780 
  tx_ring->next_to_clean = i;
  
#line 781 
  u64_stats_init(& tx_ring->syncp);
  
#line 782 
  tx_ring->stats.bytes += (unsigned long long)total_bytes;
  
#line 783 
  tx_ring->stats.packets += (unsigned long long)total_packets;
  
#line 784 
  u64_stats_init(& tx_ring->syncp);
  
#line 785 
  (tx_ring->q_vector)->tx.total_bytes += total_bytes;
  
#line 786 
  (tx_ring->q_vector)->tx.total_packets += total_packets;
  
#line 792 
  if (budget != 0 && ((int)i & 3) != 3) {
    int tmp_0;
    
#line 793 
    tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& (tx_ring->vsi)->state));
    
#line 793 
    if (tmp_0 == 0) {
      int tmp_1;
      
#line 794 
      if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
#line 794 
                                                                    tmp_1 = (int)tx_ring->count; else 
                                                                    
#line 794 
                                                                    tmp_1 = 0;
      
#line 794 
      ;
      
#line 794 
      if (((tmp_1 + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use) + -1 != (int)tx_ring->count) 
        
#line 796 
        tx_ring->arm_wb = (_Bool)1; else 
#line 798 
                                         tx_ring->arm_wb = (_Bool)0;
    }
    else 
#line 798 
         tx_ring->arm_wb = (_Bool)0;
  }
  else 
#line 798 
       tx_ring->arm_wb = (_Bool)0;
  
#line 800 
  tmp_2 = constant_test_bit(2L,(unsigned long const volatile *)(& tx_ring->state));
  
#line 800 
  if (tmp_2 != 0) {
    bool tmp_3;
    
#line 800 
    tmp_3 = i40e_check_tx_hang(tx_ring);
    
#line 800 
    if ((int)tmp_3 != 0) {
      
#line 802 
      _dev_info((struct device const *)tx_ring->dev,"Detected Tx Unit Hang\n",(int)(tx_ring->vsi)->seid,(int)tx_ring->queue_index,(int)tx_ring->next_to_use,(int)i);
      
#line 811 
      netif_start_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
      
#line 813 
      _dev_info((struct device const *)tx_ring->dev,"tx hang detected on queue %d, reset requested\n",(int)tx_ring->queue_index);
      
#line 823 
      budget = 1;
    }
    else ;
  }
  else ;
  
#line 826 
  ;
  
#line 826 
  ;
  
#line 826 
  tmp_4 = netdev_get_tx_queue((struct net_device const *)tx_ring->netdev,(unsigned int)tx_ring->queue_index);
  
#line 826 
  netdev_tx_completed_queue(tmp_4,total_packets,total_bytes);
  
#line 831 
  if ((long)(total_packets != 0U) != 0L) {
    bool tmp_7;
    
#line 831 
    tmp_7 = netif_carrier_ok((struct net_device const *)tx_ring->netdev);
    
#line 831 
    if ((long)((int)tmp_7 != 0) != 0L) 
#line 831 
                                       tmp_8 = 1; else 
#line 831 
                                                       tmp_8 = 0;
  }
  else 
#line 831 
       tmp_8 = 0;
  
#line 831 
  if (tmp_8 != 0) {
    int tmp_9;
    
#line 831 
    if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
#line 831 
                                                                  tmp_9 = (int)tx_ring->count; else 
                                                                    
#line 831 
                                                                    tmp_9 = 0;
    
#line 831 
    ;
    
#line 831 
    if ((long)((unsigned int)(((tmp_9 + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use) + -1) > 41U) != 0L) {
      bool tmp_5;
      
#line 833 
      ldv_inline_asm();
      
#line 837 
      tmp_5 = __netif_subqueue_stopped((struct net_device const *)tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
      
#line 837 
      if ((int)tmp_5 != 0) {
        int tmp_6;
        
#line 838 
        tmp_6 = constant_test_bit(3L,(unsigned long const volatile *)(& (tx_ring->vsi)->state));
        
#line 838 
        if (tmp_6 == 0) {
          
#line 840 
          netif_wake_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
          
#line 842 
          tx_ring->__anonCompField_i40e_ring_122.tx_stats.restart_queue += 1ULL;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 846 
  __retres = (_Bool)(budget != 0);
  
#line 846 
  return __retres;
}


#line 855  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_force_wb(struct i40e_vsi *vsi, struct i40e_q_vector *q_vector)
{
  
#line 857 
  u32 val = 16777245U;
  
#line 863 
  writel(val,(void volatile *)((vsi->back)->hw.hw_addr + (((int)q_vector->v_idx + vsi->base_vector) + 53759) * 4));
  
#line 864 
  return;
}


#line 880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_set_new_dynamic_itr(struct i40e_ring_container *rc)
{
  int bytes_per_int;
  
#line 882 
  enum i40e_latency_range new_latency_range = rc->latency_range;
  
#line 883 
  u32 new_itr = (unsigned int)rc->itr;
  
#line 886 
  if (rc->total_packets == 0U || (unsigned int)rc->itr == 0U) 
#line 887 
                                                              goto return_label; else ;
  
#line 894 
  bytes_per_int = (int)(rc->total_bytes / (unsigned int)rc->itr);
  
#line 895 
  switch ((int)rc->itr) {
    case 0: 
#line 896 
    ;
    
#line 897 
    if (bytes_per_int > 10) 
#line 898 
                            new_latency_range = I40E_LOW_LATENCY; else ;
    
#line 899 
    goto ldv_61634;
    case 1: 
#line 900 
    ;
    
#line 901 
    if (bytes_per_int > 20) 
#line 902 
                            new_latency_range = I40E_BULK_LATENCY;
    else 
      
#line 903 
      if (bytes_per_int <= 10) 
#line 904 
                               new_latency_range = I40E_LOWEST_LATENCY; else ;
    
#line 905 
    goto ldv_61634;
    case 2: 
#line 906 
    ;
    
#line 907 
    if (bytes_per_int <= 20) 
#line 908 
                             rc->latency_range = I40E_LOW_LATENCY; else ;
    
#line 909 
    goto ldv_61634;
  }
  ldv_61634: 
#line 912 
  ;
  
#line 912 
  switch ((unsigned int)new_latency_range) {
    case (unsigned int)0: 
#line 913 
    ;
    
#line 914 
    new_itr = 5U;
    
#line 915 
    goto ldv_61638;
    case (unsigned int)1: 
#line 916 
    ;
    
#line 917 
    new_itr = 25U;
    
#line 918 
    goto ldv_61638;
    case (unsigned int)2: 
#line 919 
    ;
    
#line 920 
    new_itr = 62U;
    
#line 921 
    goto ldv_61638;
    default: 
#line 922 
    ;
    
#line 923 
    goto ldv_61638;
  }
  ldv_61638: 
#line 926 
  ;
  
#line 926 
  if ((unsigned int)rc->itr != new_itr) {
    
#line 928 
    new_itr = (((unsigned int)rc->itr * new_itr) * 10U) / (new_itr * 9U + (unsigned int)rc->itr);
    
#line 930 
    rc->itr = (unsigned short)((unsigned int)((unsigned short)new_itr) & 4080U);
  }
  else ;
  
#line 933 
  rc->total_bytes = 0U;
  
#line 934 
  rc->total_packets = 0U;
  return_label: 
#line 935 
                return;
}


#line 941  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_update_dynamic_itr(struct i40e_q_vector *q_vector)
{
  u32 reg_addr;
  u16 old_itr;
  
#line 943 
  u16 vector = (unsigned short)((int)((unsigned short)(q_vector->vsi)->base_vector) + (int)q_vector->v_idx);
  
#line 944 
  struct i40e_hw *hw = & ((q_vector->vsi)->back)->hw;
  
#line 948 
  reg_addr = (unsigned int)(((int)vector + 49151) * 4);
  
#line 949 
  old_itr = q_vector->rx.itr;
  
#line 950 
  i40e_set_new_dynamic_itr(& q_vector->rx);
  
#line 951 
  if ((int)q_vector->rx.itr != (int)old_itr) 
#line 952 
                                             writel((unsigned int)q_vector->rx.itr,(void volatile *)(hw->hw_addr + reg_addr)); else ;
  
#line 954 
  reg_addr = (unsigned int)(((int)vector + 49663) * 4);
  
#line 955 
  old_itr = q_vector->tx.itr;
  
#line 956 
  i40e_set_new_dynamic_itr(& q_vector->tx);
  
#line 957 
  if ((int)q_vector->tx.itr != (int)old_itr) 
#line 958 
                                             writel((unsigned int)q_vector->tx.itr,(void volatile *)(hw->hw_addr + reg_addr)); else ;
  
#line 959 
  return;
}


#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_clean_programming_status(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc)
{
  u64 qw;
  u8 id;
  
#line 977 
  qw = rx_desc->wb.qword1.status_error_len;
  
#line 978 
  id = (unsigned char)((unsigned int)((unsigned char)(qw >> 2)) & 7U);
  
#line 981 
  if ((unsigned int)id == 1U) 
#line 982 
                              i40e_fd_handle_status(rx_ring,rx_desc,(unsigned char)((int)id));
  else 
    
#line 984 
    if ((unsigned int)id == 2U || (unsigned int)id == 4U) 
#line 986 
                                                          i40e_fcoe_handle_status(rx_ring,rx_desc,(unsigned char)((int)id)); else ;
  
#line 987 
  return;
}


#line 996  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_setup_tx_descriptors(struct i40e_ring *tx_ring)
{
  int __retres;
  int bi_size;
  
#line 998 
  struct device *dev = tx_ring->dev;
  
#line 1001 
  if (dev == (struct device *)0) {
    
#line 1002 
    __retres = -12;
    
#line 1002 
    goto return_label;
  }
  else ;
  
#line 1004 
  bi_size = (int)((unsigned int)tx_ring->count * 40U);
  
#line 1005 
  tx_ring->__anonCompField_i40e_ring_121.tx_bi = (struct i40e_tx_buffer *)kzalloc_3((unsigned long)bi_size,208U);
  
#line 1006 
  if (tx_ring->__anonCompField_i40e_ring_121.tx_bi == (struct i40e_tx_buffer *)0) 
    
#line 1007 
    goto err; else ;
  
#line 1010 
  tx_ring->size = (unsigned int)tx_ring->count * 16U;
  
#line 1014 
  tx_ring->size += 4U;
  
#line 1015 
  tx_ring->size = (tx_ring->size + 4095U) & 4294963200U;
  
#line 1016 
  tx_ring->desc = dma_alloc_attrs(dev,(unsigned long)tx_ring->size,& tx_ring->dma,208U,(struct dma_attrs *)0);
  
#line 1018 
  if (tx_ring->desc == (void *)0) {
    
#line 1019 
    _dev_info((struct device const *)dev,"Unable to allocate memory for the Tx descriptor ring, size=%d\n",tx_ring->size);
    
#line 1021 
    goto err;
  }
  else ;
  
#line 1024 
  tx_ring->next_to_use = (unsigned short)0U;
  
#line 1025 
  tx_ring->next_to_clean = (unsigned short)0U;
  
#line 1026 
  __retres = 0;
  
#line 1026 
  goto return_label;
  err: 
#line 1028 
  ;
  
#line 1029 
  kfree((void const *)tx_ring->__anonCompField_i40e_ring_121.tx_bi);
  
#line 1030 
  tx_ring->__anonCompField_i40e_ring_121.tx_bi = (struct i40e_tx_buffer *)0;
  
#line 1031 
  __retres = -12;
  return_label: 
#line 1031 
                return __retres;
}


#line 1038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_clean_rx_ring(struct i40e_ring *rx_ring)
{
  struct i40e_rx_buffer *rx_bi;
  unsigned long bi_size;
  u16 i;
  int tmp;
  
#line 1040 
  struct device *dev = rx_ring->dev;
  
#line 1046 
  if (rx_ring->__anonCompField_i40e_ring_121.rx_bi == (struct i40e_rx_buffer *)0) 
    
#line 1047 
    goto return_label; else ;
  
#line 1049 
  tmp = constant_test_bit(4L,(unsigned long const volatile *)(& rx_ring->state));
  
#line 1049 
  if (tmp != 0) {
    
#line 1050 
    int bufsz = (((int)rx_ring->rx_hdr_len + 255) & -256) * (int)rx_ring->count;
    
#line 1052 
    rx_bi = rx_ring->__anonCompField_i40e_ring_121.rx_bi;
    
#line 1053 
    if (rx_bi->hdr_buf != (void *)0) {
      
#line 1054 
      dma_free_attrs(dev,(unsigned long)bufsz,rx_bi->hdr_buf,rx_bi->dma,(struct dma_attrs *)0);
      
#line 1058 
      i = (unsigned short)0U;
      
#line 1058 
      goto ldv_61670;
      ldv_61669: 
#line 1059 
      ;
      
#line 1059 
      rx_bi = rx_ring->__anonCompField_i40e_ring_121.rx_bi + (int)i;
      
#line 1060 
      rx_bi->dma = 0ULL;
      
#line 1061 
      rx_bi->hdr_buf = (void *)0;
      
#line 1058 
      i = (u16)((int)i + 1);
      ldv_61670: 
#line 1059 
      ;
      
#line 1058 
      if ((int)rx_ring->count > (int)i) 
#line 1060 
                                        goto ldv_61669; else 
#line 1063 
                                                             goto ldv_61671;
      ldv_61671: 
#line 1064 
      ;
    }
    else ;
  }
  else ;
  
#line 1066 
  i = (unsigned short)0U;
  
#line 1066 
  goto ldv_61673;
  ldv_61672: 
#line 1067 
  ;
  
#line 1067 
  rx_bi = rx_ring->__anonCompField_i40e_ring_121.rx_bi + (int)i;
  
#line 1068 
  if (rx_bi->dma != 0ULL) {
    
#line 1069 
    dma_unmap_single_attrs(dev,rx_bi->dma,(unsigned long)rx_ring->rx_buf_len,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
    
#line 1073 
    rx_bi->dma = 0ULL;
  }
  else ;
  
#line 1075 
  if (rx_bi->skb != (struct sk_buff *)0) {
    
#line 1076 
    consume_skb(rx_bi->skb);
    
#line 1077 
    rx_bi->skb = (struct sk_buff *)0;
  }
  else ;
  
#line 1079 
  if (rx_bi->page != (struct page *)0) {
    
#line 1080 
    if (rx_bi->page_dma != 0ULL) {
      
#line 1081 
      dma_unmap_page(dev,rx_bi->page_dma,2048UL,(enum dma_data_direction)DMA_FROM_DEVICE);
      
#line 1085 
      rx_bi->page_dma = 0ULL;
    }
    else ;
    
#line 1087 
    __free_pages(rx_bi->page,0U);
    
#line 1088 
    rx_bi->page = (struct page *)0;
    
#line 1089 
    rx_bi->page_offset = 0U;
  }
  else ;
  
#line 1066 
  i = (u16)((int)i + 1);
  ldv_61673: 
#line 1067 
  ;
  
#line 1066 
  if ((int)rx_ring->count > (int)i) 
#line 1068 
                                    goto ldv_61672; else 
#line 1071 
                                                         goto ldv_61674;
  ldv_61674: 
#line 1072 
  ;
  
#line 1093 
  bi_size = (unsigned long)rx_ring->count * 48UL;
  
#line 1094 
  memset((void *)rx_ring->__anonCompField_i40e_ring_121.rx_bi,0,bi_size);
  
#line 1097 
  memset(rx_ring->desc,0,(unsigned long)rx_ring->size);
  
#line 1099 
  rx_ring->next_to_clean = (unsigned short)0U;
  
#line 1100 
  rx_ring->next_to_use = (unsigned short)0U;
  return_label: 
#line 1101 
                return;
}


#line 1109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_free_rx_resources(struct i40e_ring *rx_ring)
{
  
#line 1111 
  i40e_clean_rx_ring(rx_ring);
  
#line 1112 
  kfree((void const *)rx_ring->__anonCompField_i40e_ring_121.rx_bi);
  
#line 1113 
  rx_ring->__anonCompField_i40e_ring_121.rx_bi = (struct i40e_rx_buffer *)0;
  
#line 1115 
  if (rx_ring->desc != (void *)0) {
    
#line 1116 
    dma_free_attrs(rx_ring->dev,(unsigned long)rx_ring->size,rx_ring->desc,rx_ring->dma,(struct dma_attrs *)0);
    
#line 1118 
    rx_ring->desc = (void *)0;
  }
  else ;
  
#line 1120 
  return;
}


#line 1129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_alloc_rx_headers(struct i40e_ring *rx_ring)
{
  struct i40e_rx_buffer *rx_bi;
  dma_addr_t dma;
  void *buffer;
  int buf_size;
  int i;
  
#line 1131 
  struct device *dev = rx_ring->dev;
  
#line 1138 
  if ((rx_ring->__anonCompField_i40e_ring_121.rx_bi)->hdr_buf != (void *)0) 
    
#line 1139 
    goto return_label; else ;
  
#line 1141 
  buf_size = ((int)rx_ring->rx_hdr_len + 255) & -256;
  
#line 1142 
  buffer = dma_alloc_attrs(dev,(unsigned long)((int)rx_ring->count * buf_size),& dma,208U,(struct dma_attrs *)0);
  
#line 1144 
  if (buffer == (void *)0) 
#line 1145 
                           goto return_label; else ;
  
#line 1146 
  i = 0;
  
#line 1146 
  goto ldv_61688;
  ldv_61687: 
#line 1147 
  ;
  
#line 1147 
  rx_bi = rx_ring->__anonCompField_i40e_ring_121.rx_bi + i;
  
#line 1148 
  rx_bi->dma = (unsigned long long)(i * buf_size) + dma;
  
#line 1149 
  rx_bi->hdr_buf = buffer + i * buf_size;
  
#line 1146 
  i += 1;
  ldv_61688: 
#line 1147 
  ;
  
#line 1146 
  if ((int)rx_ring->count > i) 
#line 1148 
                               goto ldv_61687; else 
#line 1151 
                                                    goto ldv_61689;
  ldv_61689: 
#line 1152 
  ;
  return_label: 
#line 1153 
                return;
}


#line 1159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_setup_rx_descriptors(struct i40e_ring *rx_ring)
{
  int __retres;
  int bi_size;
  int tmp_0;
  
#line 1161 
  struct device *dev = rx_ring->dev;
  
#line 1164 
  bi_size = (int)((unsigned int)rx_ring->count * 48U);
  
#line 1165 
  rx_ring->__anonCompField_i40e_ring_121.rx_bi = (struct i40e_rx_buffer *)kzalloc_3((unsigned long)bi_size,208U);
  
#line 1166 
  if (rx_ring->__anonCompField_i40e_ring_121.rx_bi == (struct i40e_rx_buffer *)0) 
    
#line 1167 
    goto err; else ;
  
#line 1169 
  u64_stats_init(& rx_ring->syncp);
  
#line 1172 
  tmp_0 = constant_test_bit(5L,(unsigned long const volatile *)(& rx_ring->state));
  
#line 1172 
  if (tmp_0 != 0) 
#line 1172 
                  rx_ring->size = (unsigned int)rx_ring->count * 16U; else 
                                                                    
#line 1172 
                                                                    rx_ring->size = (unsigned int)rx_ring->count * 32U;
  
#line 1175 
  rx_ring->size = (rx_ring->size + 4095U) & 4294963200U;
  
#line 1176 
  rx_ring->desc = dma_alloc_attrs(dev,(unsigned long)rx_ring->size,& rx_ring->dma,208U,(struct dma_attrs *)0);
  
#line 1179 
  if (rx_ring->desc == (void *)0) {
    
#line 1180 
    _dev_info((struct device const *)dev,"Unable to allocate memory for the Rx descriptor ring, size=%d\n",rx_ring->size);
    
#line 1182 
    goto err;
  }
  else ;
  
#line 1185 
  rx_ring->next_to_clean = (unsigned short)0U;
  
#line 1186 
  rx_ring->next_to_use = (unsigned short)0U;
  
#line 1188 
  __retres = 0;
  
#line 1188 
  goto return_label;
  err: 
#line 1189 
  ;
  
#line 1190 
  kfree((void const *)rx_ring->__anonCompField_i40e_ring_121.rx_bi);
  
#line 1191 
  rx_ring->__anonCompField_i40e_ring_121.rx_bi = (struct i40e_rx_buffer *)0;
  
#line 1192 
  __retres = -12;
  return_label: 
#line 1192 
                return __retres;
}


#line 1200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static void i40e_release_rx_desc(struct i40e_ring *rx_ring, u32 val)
{
  
#line 1202 
  rx_ring->next_to_use = (unsigned short)val;
  
#line 1203 
  ldv_inline_asm();
  
#line 1209 
  writel(val,(void volatile *)rx_ring->tail);
  
#line 1210 
  return;
}


#line 1217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_alloc_rx_buffers_ps(struct i40e_ring *rx_ring, u16 cleaned_count)
{
  union i40e_32byte_rx_desc *rx_desc;
  struct i40e_rx_buffer *bi;
  u16 tmp_0;
  
#line 1219 
  u16 i = rx_ring->next_to_use;
  
#line 1224 
  if (rx_ring->netdev == (struct net_device *)0 || (unsigned int)cleaned_count == 0U) 
    
#line 1225 
    goto return_label; else ;
  
#line 1227 
  goto ldv_61709;
  ldv_61708: 
#line 1228 
  ;
  
#line 1228 
  constant_test_bit(5L,(unsigned long const volatile *)(& rx_ring->state));
  
#line 1228 
  rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc + (int)i;
  
#line 1229 
  bi = rx_ring->__anonCompField_i40e_ring_121.rx_bi + (int)i;
  
#line 1231 
  if (bi->skb != (struct sk_buff *)0) 
#line 1232 
                                      goto no_buffers; else ;
  
#line 1233 
  if (bi->page == (struct page *)0) {
    
#line 1234 
    bi->page = alloc_pages(32U,0U);
    
#line 1235 
    if (bi->page == (struct page *)0) {
      
#line 1236 
      rx_ring->__anonCompField_i40e_ring_122.rx_stats.alloc_page_failed += 1ULL;
      
#line 1237 
      goto no_buffers;
    }
    else ;
  }
  else ;
  
#line 1241 
  if (bi->page_dma == 0ULL) {
    int tmp;
    
#line 1243 
    bi->page_offset ^= 2048U;
    
#line 1244 
    bi->page_dma = dma_map_page(rx_ring->dev,bi->page,(unsigned long)bi->page_offset,2048UL,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 1249 
    tmp = dma_mapping_error(rx_ring->dev,bi->page_dma);
    
#line 1249 
    if (tmp != 0) {
      
#line 1251 
      rx_ring->__anonCompField_i40e_ring_122.rx_stats.alloc_page_failed += 1ULL;
      
#line 1252 
      bi->page_dma = 0ULL;
      
#line 1253 
      goto no_buffers;
    }
    else ;
  }
  else ;
  
#line 1257 
  dma_sync_single_range_for_device(rx_ring->dev,bi->dma,0UL,(unsigned long)rx_ring->rx_hdr_len,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 1265 
  rx_desc->read.pkt_addr = bi->page_dma;
  
#line 1266 
  rx_desc->read.hdr_addr = bi->dma;
  
#line 1267 
  i = (u16)((int)i + 1);
  
#line 1268 
  if ((int)rx_ring->count == (int)i) 
#line 1269 
                                     i = (unsigned short)0U; else ;
  ldv_61709: 
#line 1270 
  ;
  
#line 1227 
  tmp_0 = cleaned_count;
  
#line 1227 
  cleaned_count = (u16)((int)cleaned_count - 1);
  
#line 1227 
  ;
  
#line 1227 
  if ((unsigned int)tmp_0 != 0U) 
#line 1229 
                                 goto ldv_61708; else 
#line 1232 
                                                      goto ldv_61710;
  ldv_61710: 
#line 1233 
  ;
  no_buffers: 
#line 1272 
  ;
  
#line 1273 
  if ((int)rx_ring->next_to_use != (int)i) 
#line 1274 
                                           i40e_release_rx_desc(rx_ring,(unsigned int)i); else ;
  return_label: 
#line 1275 
                return;
}


#line 1282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_alloc_rx_buffers_1buf(struct i40e_ring *rx_ring, u16 cleaned_count)
{
  union i40e_32byte_rx_desc *rx_desc;
  struct i40e_rx_buffer *bi;
  struct sk_buff *skb;
  u16 tmp_0;
  
#line 1284 
  u16 i = rx_ring->next_to_use;
  
#line 1290 
  if (rx_ring->netdev == (struct net_device *)0 || (unsigned int)cleaned_count == 0U) 
    
#line 1291 
    goto return_label; else ;
  
#line 1293 
  goto ldv_61721;
  ldv_61720: 
#line 1294 
  ;
  
#line 1294 
  constant_test_bit(5L,(unsigned long const volatile *)(& rx_ring->state));
  
#line 1294 
  rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc + (int)i;
  
#line 1295 
  bi = rx_ring->__anonCompField_i40e_ring_121.rx_bi + (int)i;
  
#line 1296 
  skb = bi->skb;
  
#line 1298 
  if (skb == (struct sk_buff *)0) {
    
#line 1299 
    skb = netdev_alloc_skb_ip_align(rx_ring->netdev,(unsigned int)rx_ring->rx_buf_len);
    
#line 1301 
    if (skb == (struct sk_buff *)0) {
      
#line 1302 
      rx_ring->__anonCompField_i40e_ring_122.rx_stats.alloc_buff_failed += 1ULL;
      
#line 1303 
      goto no_buffers;
    }
    else ;
    
#line 1306 
    skb_record_rx_queue(skb,(unsigned short)((int)rx_ring->queue_index));
    
#line 1307 
    bi->skb = skb;
  }
  else ;
  
#line 1310 
  if (bi->dma == 0ULL) {
    int tmp;
    
#line 1311 
    bi->dma = dma_map_single_attrs(rx_ring->dev,(void *)skb->data,(unsigned long)rx_ring->rx_buf_len,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
    
#line 1315 
    tmp = dma_mapping_error(rx_ring->dev,bi->dma);
    
#line 1315 
    if (tmp != 0) {
      
#line 1316 
      rx_ring->__anonCompField_i40e_ring_122.rx_stats.alloc_buff_failed += 1ULL;
      
#line 1317 
      bi->dma = 0ULL;
      
#line 1318 
      goto no_buffers;
    }
    else ;
  }
  else ;
  
#line 1322 
  rx_desc->read.pkt_addr = bi->dma;
  
#line 1323 
  rx_desc->read.hdr_addr = 0ULL;
  
#line 1324 
  i = (u16)((int)i + 1);
  
#line 1325 
  if ((int)rx_ring->count == (int)i) 
#line 1326 
                                     i = (unsigned short)0U; else ;
  ldv_61721: 
#line 1327 
  ;
  
#line 1293 
  tmp_0 = cleaned_count;
  
#line 1293 
  cleaned_count = (u16)((int)cleaned_count - 1);
  
#line 1293 
  ;
  
#line 1293 
  if ((unsigned int)tmp_0 != 0U) 
#line 1295 
                                 goto ldv_61720; else 
#line 1298 
                                                      goto ldv_61722;
  ldv_61722: 
#line 1299 
  ;
  no_buffers: 
#line 1329 
  ;
  
#line 1330 
  if ((int)rx_ring->next_to_use != (int)i) 
#line 1331 
                                           i40e_release_rx_desc(rx_ring,(unsigned int)i); else ;
  return_label: 
#line 1332 
                return;
}


#line 1340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_receive_skb(struct i40e_ring *rx_ring, struct sk_buff *skb, u16 vlan_tag)
{
  
#line 1343 
  struct i40e_q_vector *q_vector = rx_ring->q_vector;
  
#line 1344 
  struct i40e_vsi *vsi = rx_ring->vsi;
  
#line 1345 
  u64 flags = (vsi->back)->flags;
  
#line 1347 
  if (((int)vlan_tag & 4095) != 0) 
#line 1348 
                                   __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)((int)vlan_tag)); else ;
  
#line 1350 
  if ((flags & 4096ULL) != 0ULL) 
#line 1351 
                                 netif_rx(skb); else 
#line 1353 
                                                     napi_gro_receive(& q_vector->napi,skb);
  
#line 1354 
  return;
}


#line 1364  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static void i40e_rx_checksum(struct i40e_vsi *vsi, struct sk_buff *skb, u32 rx_status, u32 rx_error, u16 rx_ptype)
{
  bool ipv4_tunnel;
  bool ipv6_tunnel;
  __wsum rx_udp_csum;
  struct iphdr *iph;
  __sum16 csum;
  
#line 1370 
  struct i40e_rx_ptype_decoded decoded = decode_rx_desc_ptype((unsigned char)((int)((unsigned char)rx_ptype)));
  
#line 1371 
  bool ipv4 = (_Bool)0;
  
#line 1371 
  bool ipv6 = (_Bool)0;
  
#line 1377 
  ipv4_tunnel = (_Bool)((unsigned int)rx_ptype + 65478U <= 29U);
  
#line 1379 
  ipv6_tunnel = (_Bool)((unsigned int)rx_ptype + 65412U <= 29U);
  
#line 1382 
  skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
  
#line 1385 
  if (((vsi->netdev)->features & 17179869184ULL) == 0ULL) 
#line 1386 
                                                          goto return_label; else ;
  
#line 1389 
  if ((rx_status & 8U) == 0U) 
#line 1390 
                              goto return_label; else ;
  
#line 1393 
  if ((unsigned int)*((unsigned char *)(& decoded) + 1UL) == 0U || (unsigned int)*((unsigned char *)(& decoded) + 1UL) == 0U) 
    
#line 1394 
    goto return_label; else ;
  
#line 1396 
  if ((unsigned int)*((unsigned char *)(& decoded) + 1UL) != 0U && (unsigned int)*((unsigned char *)(& decoded) + 1UL) == 0U) 
    
#line 1398 
    ipv4 = (_Bool)1;
  else 
    
#line 1399 
    if ((unsigned int)*((unsigned char *)(& decoded) + 1UL) != 0U && (unsigned int)*((unsigned char *)(& decoded) + 1UL) != 0U) 
      
#line 1401 
      ipv6 = (_Bool)1; else ;
  
#line 1403 
  if ((int)ipv4 != 0 && (rx_error & 40U) != 0U) 
#line 1406 
                                                goto checksum_fail; else ;
  
#line 1409 
  if ((int)ipv6 != 0 && (rx_status & 32768U) != 0U) 
#line 1412 
                                                    goto return_label; else ;
  
#line 1415 
  if ((rx_error & 16U) != 0U) 
#line 1416 
                              goto checksum_fail; else ;
  
#line 1422 
  if ((rx_error & 128U) != 0U) 
#line 1423 
                               goto return_label; else ;
  
#line 1431 
  if ((int)ipv4_tunnel != 0) {
    struct iphdr *tmp_0;
    unsigned int tmp_1;
    struct iphdr *tmp_4;
    
#line 1434 
    tmp_0 = ip_hdr((struct sk_buff const *)skb);
    
#line 1432 
    skb->transport_header = (unsigned short)(((unsigned int)skb->mac_header + (unsigned int)((unsigned short)tmp_0->ihl) * 4U) + 14U);
    
#line 1437 
    if ((unsigned int)skb->protocol == 129U || (unsigned int)skb->protocol == 43144U) 
      
#line 1437 
      tmp_1 = 4U; else 
#line 1437 
                       tmp_1 = 0U;
    
#line 1437 
    skb->transport_header = (unsigned short)((unsigned int)skb->transport_header + tmp_1);
    
#line 1441 
    tmp_4 = ip_hdr((struct sk_buff const *)skb);
    
#line 1441 
    ;
    
#line 1441 
    if ((unsigned int)tmp_4->protocol == 17U) {
      struct udphdr *tmp_5;
      
#line 1442 
      tmp_5 = udp_hdr((struct sk_buff const *)skb);
      
#line 1441 
      ;
      
#line 1441 
      if ((unsigned int)tmp_5->check != 0U) {
        int tmp_2;
        struct udphdr *tmp_3;
        
#line 1443 
        rx_udp_csum = udp_csum(skb);
        
#line 1444 
        iph = ip_hdr((struct sk_buff const *)skb);
        
#line 1445 
        ;
        
#line 1447 
        tmp_2 = skb_transport_offset((struct sk_buff const *)skb);
        
#line 1445 
        ;
        
#line 1445 
        ;
        
#line 1445 
        ;
        
#line 1445 
        csum = csum_tcpudp_magic(iph->saddr,iph->daddr,(unsigned short)((int)((unsigned short)skb->len) - (int)((unsigned short)tmp_2)),(unsigned short)17,rx_udp_csum);
        
#line 1450 
        tmp_3 = udp_hdr((struct sk_buff const *)skb);
        
#line 1450 
        ;
        
#line 1450 
        if ((int)tmp_3->check != (int)csum) 
#line 1451 
                                            goto checksum_fail; else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1456 
  skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U;
  
#line 1457 
  skb->csum_level = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))(((int)ipv4_tunnel != 0 || (int)ipv6_tunnel != 0) != 0);
  
#line 1459 
  goto return_label;
  checksum_fail: 
#line 1461 
  ;
  
#line 1462 
  (vsi->back)->hw_csum_rx_error += 1U;
  return_label: 
#line 1463 
                return;
}


#line 1470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static u32 i40e_rx_hash(struct i40e_ring *ring, union i40e_32byte_rx_desc *rx_desc)
{
  u32 __retres;
  
#line 1473 
  __le64 const rss_mask = 12288ULL;
  
#line 1477 
  if (((ring->netdev)->features & 8589934592ULL) != 0ULL && (rx_desc->wb.qword1.status_error_len & 12288ULL) == 12288ULL) {
    
#line 1479 
    __retres = rx_desc->wb.qword0.hi_dword.rss;
    
#line 1479 
    goto return_label;
  }
  else {
    
#line 1481 
    __retres = 0U;
    
#line 1481 
    goto return_label;
  }
  return_label: 
#line 1477 
                return __retres;
}


#line 1490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static enum pkt_hash_types i40e_ptype_to_hash(u8 ptype)
{
  enum pkt_hash_types __retres;
  
#line 1492 
  struct i40e_rx_ptype_decoded decoded = decode_rx_desc_ptype((unsigned char)((int)ptype));
  
#line 1494 
  if ((unsigned int)*((unsigned char *)(& decoded) + 1UL) == 0U) {
    
#line 1495 
    __retres = PKT_HASH_TYPE_NONE;
    
#line 1495 
    goto return_label;
  }
  else ;
  
#line 1497 
  if ((unsigned int)*((unsigned char *)(& decoded) + 1UL) != 0U && (unsigned int)*((unsigned short *)(& decoded) + 1UL) == 192U) {
    
#line 1499 
    __retres = PKT_HASH_TYPE_L4;
    
#line 1499 
    goto return_label;
  }
  else 
    
#line 1500 
    if ((unsigned int)*((unsigned char *)(& decoded) + 1UL) != 0U && (unsigned int)*((unsigned short *)(& decoded) + 1UL) == 128U) {
      
#line 1502 
      __retres = PKT_HASH_TYPE_L3;
      
#line 1502 
      goto return_label;
    }
    else {
      
#line 1504 
      __retres = PKT_HASH_TYPE_L2;
      
#line 1504 
      goto return_label;
    }
  return_label: 
#line 1497 
                return __retres;
}


#line 1514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_clean_rx_irq_ps(struct i40e_ring *rx_ring, int budget)
{
  int __retres;
  u16 rx_packet_len;
  u16 rx_header_len;
  u16 rx_sph;
  u16 rx_hbo;
  unsigned int tmp;
  union i40e_32byte_rx_desc *rx_desc;
  u32 rx_error;
  u32 rx_status;
  u8 rx_ptype;
  u64 qword;
  
#line 1516 
  unsigned int total_rx_bytes = 0U;
  
#line 1516 
  unsigned int total_rx_packets = 0U;
  
#line 1518 
  if ((int)rx_ring->next_to_clean <= (int)rx_ring->next_to_use) 
#line 1518 
                                                                tmp = (unsigned int)rx_ring->count; else 
                                                                    
#line 1518 
                                                                    tmp = 0U;
  
#line 1518 
  u16 cleaned_count = (unsigned short)(((tmp + (unsigned int)rx_ring->next_to_clean) - (unsigned int)rx_ring->next_to_use) + 65535U);
  
#line 1519 
  int const current_node = numa_node_id();
  
#line 1520 
  struct i40e_vsi *vsi = rx_ring->vsi;
  
#line 1521 
  u16 i = rx_ring->next_to_clean;
  
#line 1527 
  if (budget <= 0) {
    
#line 1528 
    __retres = 0;
    
#line 1528 
    goto return_label;
  }
  else ;
  ldv_61783: 
#line 1529 
  ;
  {
    struct i40e_rx_buffer *rx_bi;
    struct sk_buff *skb;
    u16 vlan_tag;
    bool tmp_1;
    enum pkt_hash_types tmp_10;
    u32 tmp_11;
    int tmp_12;
    
#line 1535 
    if ((unsigned int)cleaned_count > 15U) {
      
#line 1536 
      i40e_alloc_rx_buffers_ps(rx_ring,(unsigned short)((int)cleaned_count));
      
#line 1537 
      cleaned_count = (unsigned short)0U;
    }
    else ;
    
#line 1540 
    i = rx_ring->next_to_clean;
    
#line 1541 
    constant_test_bit(5L,(unsigned long const volatile *)(& rx_ring->state));
    
#line 1541 
    rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc + (int)i;
    
#line 1542 
    qword = rx_desc->wb.qword1.status_error_len;
    
#line 1543 
    rx_status = (unsigned int)qword & 524287U;
    
#line 1546 
    if ((rx_status & 1U) == 0U) 
#line 1547 
                                goto ldv_61778; else ;
    
#line 1548 
    ldv_inline_asm();
    
#line 1554 
    tmp_1 = i40e_rx_is_programming_status(qword);
    
#line 1554 
    if ((int)tmp_1 != 0) {
      
#line 1555 
      i40e_clean_programming_status(rx_ring,rx_desc);
      
#line 1556 
      i = (u16)((int)i + 1);
      
#line 1556 
      if ((int)rx_ring->count == (int)i) 
#line 1556 
                                         i = (unsigned short)0U; else ;
      
#line 1556 
      rx_ring->next_to_clean = i;
      
#line 1557 
      goto ldv_61779;
    }
    else ;
    
#line 1559 
    rx_bi = rx_ring->__anonCompField_i40e_ring_121.rx_bi + (int)i;
    
#line 1560 
    skb = rx_bi->skb;
    
#line 1561 
    if ((long)(skb == (struct sk_buff *)0) != 0L) {
      
#line 1562 
      skb = netdev_alloc_skb_ip_align(rx_ring->netdev,(unsigned int)rx_ring->rx_hdr_len);
      
#line 1564 
      if (skb == (struct sk_buff *)0) {
        
#line 1565 
        rx_ring->__anonCompField_i40e_ring_122.rx_stats.alloc_buff_failed += 1ULL;
        
#line 1566 
        goto ldv_61778;
      }
      else ;
      
#line 1570 
      skb_record_rx_queue(skb,(unsigned short)((int)rx_ring->queue_index));
      
#line 1572 
      dma_sync_single_range_for_cpu(rx_ring->dev,rx_bi->dma,0UL,(unsigned long)rx_ring->rx_hdr_len,(enum dma_data_direction)DMA_FROM_DEVICE);
    }
    else ;
    
#line 1578 
    rx_packet_len = (unsigned short)((unsigned int)((unsigned short)(qword >> 38)) & 16383U);
    
#line 1580 
    rx_header_len = (unsigned short)((unsigned int)((unsigned short)(qword >> 52)) & 2047U);
    
#line 1582 
    rx_sph = (unsigned short)(qword >> 63);
    
#line 1585 
    rx_error = (unsigned int)(qword >> 19) & 255U;
    
#line 1587 
    rx_hbo = (unsigned short)((unsigned int)((unsigned short)rx_error) & 4U);
    
#line 1588 
    rx_error &= 4294967291U;
    
#line 1590 
    rx_ptype = (unsigned char)(qword >> 30);
    
#line 1592 
    __builtin_prefetch((void const *)rx_bi->page);
    
#line 1593 
    rx_bi->skb = (struct sk_buff *)0;
    
#line 1594 
    cleaned_count = (u16)((int)cleaned_count + 1);
    
#line 1595 
    if ((unsigned int)rx_hbo != 0U || (unsigned int)rx_sph != 0U) {
      int len;
      unsigned char *tmp_2;
      
#line 1597 
      if ((unsigned int)rx_hbo != 0U) 
#line 1598 
                                      len = 512; else 
#line 1600 
                                                      len = (int)rx_header_len;
      
#line 1601 
      ;
      
#line 1601 
      ;
      
#line 1601 
      tmp_2 = __skb_put(skb,(unsigned int)len);
      
#line 1601 
      memcpy((void *)tmp_2,(void const *)rx_bi->hdr_buf,(unsigned long)len);
    }
    else 
      
#line 1602 
      if (skb->len == 0U) {
        int len_0;
        unsigned int tmp_5;
        unsigned int tmp_3;
        unsigned char *tmp_6;
        
#line 1605 
        tmp_3 = skb_headlen((struct sk_buff const *)skb);
        
#line 1606 
        ;
        
#line 1606 
        if ((unsigned int)rx_packet_len > tmp_3) 
#line 1605 
                                                 tmp_5 = skb_headlen((struct sk_buff const *)skb); else 
                                                                    
#line 1606 
                                                                    tmp_5 = (unsigned int)rx_packet_len;
        
#line 1605 
        len_0 = (int)tmp_5;
        
#line 1607 
        ;
        
#line 1607 
        ;
        
#line 1607 
        tmp_6 = __skb_put(skb,(unsigned int)len_0);
        
#line 1607 
        memcpy((void *)tmp_6,(void const *)(rx_bi->page + rx_bi->page_offset),(unsigned long)len_0);
        
#line 1610 
        rx_bi->page_offset += (unsigned int)len_0;
        
#line 1611 
        rx_packet_len = (unsigned short)((int)rx_packet_len - (int)((unsigned short)len_0));
      }
      else ;
    
#line 1615 
    if ((unsigned int)rx_packet_len != 0U) {
      unsigned char *tmp_7;
      int tmp_8;
      
#line 1616 
      ;
      
#line 1616 
      ;
      
#line 1616 
      ;
      
#line 1616 
      tmp_7 = skb_end_pointer((struct sk_buff const *)skb);
      
#line 1616 
      ;
      
#line 1616 
      skb_fill_page_desc(skb,(int)((struct skb_shared_info *)tmp_7)->nr_frags,rx_bi->page,(int)rx_bi->page_offset,(int)rx_packet_len);
      
#line 1621 
      skb->len += (unsigned int)rx_packet_len;
      
#line 1622 
      skb->data_len += (unsigned int)rx_packet_len;
      
#line 1623 
      skb->truesize += (unsigned int)rx_packet_len;
      
#line 1625 
      tmp_8 = page_count(rx_bi->page);
      
#line 1625 
      if (tmp_8 == 1) {
        int tmp_9;
        
#line 1625 
        tmp_9 = page_to_nid((struct page const *)rx_bi->page);
        
#line 1625 
        ;
        
#line 1625 
        if (tmp_9 == current_node) 
#line 1627 
                                   get_page(rx_bi->page); else 
#line 1629 
                                                               rx_bi->page = (struct page *)0;
      }
      else 
#line 1629 
           rx_bi->page = (struct page *)0;
      
#line 1631 
      dma_unmap_page(rx_ring->dev,rx_bi->page_dma,2048UL,(enum dma_data_direction)DMA_FROM_DEVICE);
      
#line 1635 
      rx_bi->page_dma = 0ULL;
    }
    else ;
    
#line 1637 
    i = (u16)((int)i + 1);
    
#line 1637 
    if ((int)rx_ring->count == (int)i) 
#line 1637 
                                       i = (unsigned short)0U; else ;
    
#line 1637 
    rx_ring->next_to_clean = i;
    
#line 1639 
    if ((long)((rx_status & 2U) == 0U) != 0L) {
      struct i40e_rx_buffer *next_buffer;
      
#line 1643 
      next_buffer = rx_ring->__anonCompField_i40e_ring_121.rx_bi + (int)i;
      
#line 1644 
      next_buffer->skb = skb;
      
#line 1645 
      rx_ring->__anonCompField_i40e_ring_122.rx_stats.non_eop_descs += 1ULL;
      
#line 1646 
      goto ldv_61779;
    }
    else ;
    
#line 1650 
    if ((long)((rx_error & 1U) != 0U) != 0L) {
      
#line 1651 
      dev_kfree_skb_any(skb);
      
#line 1652 
      goto ldv_61779;
    }
    else ;
    
#line 1655 
    tmp_10 = i40e_ptype_to_hash((unsigned char)((int)rx_ptype));
    
#line 1655 
    tmp_11 = i40e_rx_hash(rx_ring,rx_desc);
    
#line 1655 
    ;
    
#line 1655 
    skb_set_hash(skb,tmp_11,tmp_10);
    
#line 1657 
    if ((long)(((unsigned long)rx_status & 128UL) != 0UL) != 0L) {
      
#line 1658 
      i40e_ptp_rx_hwtstamp(vsi->back,skb,(unsigned char)((int)((unsigned char)((unsigned long)rx_status >> 5)) & 3));
      
#line 1661 
      rx_ring->last_rx_timestamp = jiffies;
    }
    else ;
    
#line 1665 
    total_rx_bytes = skb->len + total_rx_bytes;
    
#line 1666 
    total_rx_packets += 1U;
    
#line 1668 
    skb->protocol = eth_type_trans(skb,rx_ring->netdev);
    
#line 1670 
    i40e_rx_checksum(vsi,skb,rx_status,rx_error,(unsigned short)((int)rx_ptype));
    
#line 1672 
    if ((rx_status & 4U) != 0U) 
#line 1672 
                                vlan_tag = rx_desc->wb.qword0.lo_dword.l2tag1; else 
                                                                    
#line 1672 
                                                                    vlan_tag = (unsigned short)0U;
    
#line 1676 
    tmp_12 = i40e_fcoe_handle_offload(rx_ring,rx_desc,skb);
    
#line 1676 
    if (tmp_12 == 0) {
      
#line 1677 
      dev_kfree_skb_any(skb);
      
#line 1678 
      goto ldv_61779;
    }
    else ;
    
#line 1681 
    skb_mark_napi_id(skb,& (rx_ring->q_vector)->napi);
    
#line 1682 
    i40e_receive_skb(rx_ring,skb,(unsigned short)((int)vlan_tag));
    
#line 1684 
    rx_desc->wb.qword1.status_error_len = 0ULL;
  }
  ldv_61779: 
#line 1686 
  ;
  
#line 1686 
  if ((long)(total_rx_packets < (unsigned int)budget) != 0L) 
#line 1688 
                                                             goto ldv_61783; else 
                                                                    
#line 1691 
                                                                    goto ldv_61778;
  ldv_61778: 
#line 1692 
  ;
  
#line 1688 
  u64_stats_init(& rx_ring->syncp);
  
#line 1689 
  rx_ring->stats.packets += (unsigned long long)total_rx_packets;
  
#line 1690 
  rx_ring->stats.bytes += (unsigned long long)total_rx_bytes;
  
#line 1691 
  u64_stats_init(& rx_ring->syncp);
  
#line 1692 
  (rx_ring->q_vector)->rx.total_packets += total_rx_packets;
  
#line 1693 
  (rx_ring->q_vector)->rx.total_bytes += total_rx_bytes;
  
#line 1695 
  __retres = (int)total_rx_packets;
  return_label: 
#line 1695 
                return __retres;
}


#line 1705  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_clean_rx_irq_1buf(struct i40e_ring *rx_ring, int budget)
{
  int __retres;
  unsigned int tmp;
  union i40e_32byte_rx_desc *rx_desc;
  u32 rx_error;
  u32 rx_status;
  u16 rx_packet_len;
  u8 rx_ptype;
  u64 qword;
  u16 i;
  
#line 1707 
  unsigned int total_rx_bytes = 0U;
  
#line 1707 
  unsigned int total_rx_packets = 0U;
  
#line 1708 
  if ((int)rx_ring->next_to_clean <= (int)rx_ring->next_to_use) 
#line 1708 
                                                                tmp = (unsigned int)rx_ring->count; else 
                                                                    
#line 1708 
                                                                    tmp = 0U;
  
#line 1708 
  u16 cleaned_count = (unsigned short)(((tmp + (unsigned int)rx_ring->next_to_clean) - (unsigned int)rx_ring->next_to_use) + 65535U);
  
#line 1709 
  struct i40e_vsi *vsi = rx_ring->vsi;
  ldv_61804: 
#line 1716 
  ;
  {
    struct i40e_rx_buffer *rx_bi;
    struct sk_buff *skb;
    u16 vlan_tag;
    bool tmp_0;
    enum pkt_hash_types tmp_1;
    u32 tmp_2;
    int tmp_3;
    
#line 1722 
    if ((unsigned int)cleaned_count > 15U) {
      
#line 1723 
      i40e_alloc_rx_buffers_1buf(rx_ring,(unsigned short)((int)cleaned_count));
      
#line 1724 
      cleaned_count = (unsigned short)0U;
    }
    else ;
    
#line 1727 
    i = rx_ring->next_to_clean;
    
#line 1728 
    constant_test_bit(5L,(unsigned long const volatile *)(& rx_ring->state));
    
#line 1728 
    rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc + (int)i;
    
#line 1729 
    qword = rx_desc->wb.qword1.status_error_len;
    
#line 1730 
    rx_status = (unsigned int)qword & 524287U;
    
#line 1733 
    if ((rx_status & 1U) == 0U) 
#line 1734 
                                goto ldv_61802; else ;
    
#line 1735 
    ldv_inline_asm();
    
#line 1742 
    tmp_0 = i40e_rx_is_programming_status(qword);
    
#line 1742 
    if ((int)tmp_0 != 0) {
      
#line 1743 
      i40e_clean_programming_status(rx_ring,rx_desc);
      
#line 1744 
      i = (u16)((int)i + 1);
      
#line 1744 
      if ((int)rx_ring->count == (int)i) 
#line 1744 
                                         i = (unsigned short)0U; else ;
      
#line 1744 
      rx_ring->next_to_clean = i;
      
#line 1745 
      goto ldv_61803;
    }
    else ;
    
#line 1747 
    rx_bi = rx_ring->__anonCompField_i40e_ring_121.rx_bi + (int)i;
    
#line 1748 
    skb = rx_bi->skb;
    
#line 1749 
    __builtin_prefetch((void const *)skb->data);
    
#line 1751 
    rx_packet_len = (unsigned short)((unsigned int)((unsigned short)(qword >> 38)) & 16383U);
    
#line 1754 
    rx_error = (unsigned int)(qword >> 19) & 255U;
    
#line 1756 
    rx_error &= 4294967291U;
    
#line 1758 
    rx_ptype = (unsigned char)(qword >> 30);
    
#line 1760 
    rx_bi->skb = (struct sk_buff *)0;
    
#line 1761 
    cleaned_count = (u16)((int)cleaned_count + 1);
    
#line 1766 
    skb_put(skb,(unsigned int)rx_packet_len);
    
#line 1767 
    dma_unmap_single_attrs(rx_ring->dev,rx_bi->dma,(unsigned long)rx_ring->rx_buf_len,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
    
#line 1769 
    rx_bi->dma = 0ULL;
    
#line 1771 
    i = (u16)((int)i + 1);
    
#line 1771 
    if ((int)rx_ring->count == (int)i) 
#line 1771 
                                       i = (unsigned short)0U; else ;
    
#line 1771 
    rx_ring->next_to_clean = i;
    
#line 1773 
    if ((long)((rx_status & 2U) == 0U) != 0L) {
      
#line 1775 
      rx_ring->__anonCompField_i40e_ring_122.rx_stats.non_eop_descs += 1ULL;
      
#line 1776 
      goto ldv_61803;
    }
    else ;
    
#line 1780 
    if ((long)((rx_error & 1U) != 0U) != 0L) {
      
#line 1781 
      dev_kfree_skb_any(skb);
      
#line 1785 
      goto ldv_61803;
    }
    else ;
    
#line 1788 
    tmp_1 = i40e_ptype_to_hash((unsigned char)((int)rx_ptype));
    
#line 1788 
    tmp_2 = i40e_rx_hash(rx_ring,rx_desc);
    
#line 1788 
    ;
    
#line 1788 
    skb_set_hash(skb,tmp_2,tmp_1);
    
#line 1790 
    if ((long)(((unsigned long)rx_status & 128UL) != 0UL) != 0L) {
      
#line 1791 
      i40e_ptp_rx_hwtstamp(vsi->back,skb,(unsigned char)((int)((unsigned char)((unsigned long)rx_status >> 5)) & 3));
      
#line 1794 
      rx_ring->last_rx_timestamp = jiffies;
    }
    else ;
    
#line 1798 
    total_rx_bytes = skb->len + total_rx_bytes;
    
#line 1799 
    total_rx_packets += 1U;
    
#line 1801 
    skb->protocol = eth_type_trans(skb,rx_ring->netdev);
    
#line 1803 
    i40e_rx_checksum(vsi,skb,rx_status,rx_error,(unsigned short)((int)rx_ptype));
    
#line 1805 
    if ((rx_status & 4U) != 0U) 
#line 1805 
                                vlan_tag = rx_desc->wb.qword0.lo_dword.l2tag1; else 
                                                                    
#line 1805 
                                                                    vlan_tag = (unsigned short)0U;
    
#line 1809 
    tmp_3 = i40e_fcoe_handle_offload(rx_ring,rx_desc,skb);
    
#line 1809 
    if (tmp_3 == 0) {
      
#line 1810 
      dev_kfree_skb_any(skb);
      
#line 1811 
      goto ldv_61803;
    }
    else ;
    
#line 1814 
    i40e_receive_skb(rx_ring,skb,(unsigned short)((int)vlan_tag));
    
#line 1816 
    rx_desc->wb.qword1.status_error_len = 0ULL;
  }
  ldv_61803: 
#line 1818 
  ;
  
#line 1817 
  if ((long)(total_rx_packets < (unsigned int)budget) != 0L) 
#line 1819 
                                                             goto ldv_61804; else 
                                                                    
#line 1822 
                                                                    goto ldv_61802;
  ldv_61802: 
#line 1823 
  ;
  
#line 1819 
  u64_stats_init(& rx_ring->syncp);
  
#line 1820 
  rx_ring->stats.packets += (unsigned long long)total_rx_packets;
  
#line 1821 
  rx_ring->stats.bytes += (unsigned long long)total_rx_bytes;
  
#line 1822 
  u64_stats_init(& rx_ring->syncp);
  
#line 1823 
  (rx_ring->q_vector)->rx.total_packets += total_rx_packets;
  
#line 1824 
  (rx_ring->q_vector)->rx.total_bytes += total_rx_bytes;
  
#line 1826 
  __retres = (int)total_rx_packets;
  
#line 1826 
  return __retres;
}


#line 1838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_napi_poll(struct napi_struct *napi, int budget)
{
  int __retres;
  struct i40e_q_vector *tmp;
  struct i40e_ring *ring;
  int budget_per_ring;
  int cleaned;
  int tmp_0;
  bool tmp_1;
  int tmp_3;
  int tmp_4;
  int tmp_6;
  {
    
#line 1841 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 1841 
    tmp = (struct i40e_q_vector *)__mptr + 18446744073709551600U;
  }
  
#line 1840 
  struct i40e_q_vector *q_vector = tmp;
  
#line 1842 
  struct i40e_vsi *vsi = q_vector->vsi;
  
#line 1844 
  bool clean_complete = (_Bool)1;
  
#line 1845 
  bool arm_wb = (_Bool)0;
  
#line 1849 
  tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
  
#line 1849 
  if (tmp_0 != 0) {
    
#line 1850 
    napi_complete(napi);
    
#line 1851 
    __retres = 0;
    
#line 1851 
    goto return_label;
  }
  else ;
  
#line 1857 
  ring = q_vector->tx.ring;
  
#line 1857 
  goto ldv_61819;
  ldv_61818: 
#line 1858 
  ;
  
#line 1858 
  tmp_1 = i40e_clean_tx_irq(ring,(int)vsi->work_limit);
  
#line 1858 
  clean_complete = (_Bool)(((int)clean_complete & (int)tmp_1) != 0);
  
#line 1859 
  arm_wb = (_Bool)(((int)ring->arm_wb | (int)arm_wb) != 0);
  
#line 1857 
  ring = ring->next;
  ldv_61819: 
#line 1858 
  ;
  
#line 1857 
  if (ring != (struct i40e_ring *)0) 
#line 1859 
                                     goto ldv_61818; else 
#line 1862 
                                                          goto ldv_61820;
  ldv_61820: 
#line 1863 
  ;
  {
    int tmp_2;
    
#line 1865 
    int _max1 = budget / (int)q_vector->num_ringpairs;
    
#line 1865 
    int _max2 = 1;
    
#line 1865 
    if (_max1 > _max2) 
#line 1865 
                       tmp_2 = _max1; else 
#line 1865 
                                           tmp_2 = _max2;
    
#line 1865 
    tmp_3 = tmp_2;
  }
  
#line 1865 
  budget_per_ring = tmp_3;
  
#line 1867 
  ring = q_vector->rx.ring;
  
#line 1867 
  goto ldv_61825;
  ldv_61824: 
#line 1868 
  ;
  
#line 1868 
  tmp_4 = constant_test_bit(4L,(unsigned long const volatile *)(& ring->state));
  
#line 1868 
  if (tmp_4 != 0) 
#line 1869 
                  cleaned = i40e_clean_rx_irq_ps(ring,budget_per_ring); else 
                                                                    
#line 1871 
                                                                    cleaned = i40e_clean_rx_irq_1buf(ring,budget_per_ring);
  
#line 1873 
  clean_complete = (_Bool)(((int)clean_complete & (budget_per_ring != cleaned)) != 0);
  
#line 1867 
  ring = ring->next;
  ldv_61825: 
#line 1868 
  ;
  
#line 1867 
  if (ring != (struct i40e_ring *)0) 
#line 1869 
                                     goto ldv_61824; else 
#line 1872 
                                                          goto ldv_61826;
  ldv_61826: 
#line 1873 
  ;
  
#line 1877 
  if (! clean_complete) {
    
#line 1878 
    if ((int)arm_wb != 0) 
#line 1879 
                          i40e_force_wb(vsi,q_vector); else ;
    
#line 1880 
    __retres = budget;
    
#line 1880 
    goto return_label;
  }
  else ;
  
#line 1884 
  napi_complete(napi);
  
#line 1885 
  if ((int)vsi->rx_itr_setting < 0 || (int)vsi->tx_itr_setting < 0) 
#line 1887 
                                                                    i40e_update_dynamic_itr(q_vector); else ;
  
#line 1889 
  tmp_6 = constant_test_bit(3L,(unsigned long const volatile *)(& vsi->state));
  
#line 1889 
  if (tmp_6 == 0) 
    
#line 1890 
    if (((vsi->back)->flags & 8ULL) != 0ULL) 
#line 1891 
                                             i40e_irq_dynamic_enable(vsi,(int)q_vector->v_idx + vsi->base_vector);
    else {
      
#line 1894 
      struct i40e_hw *hw = & (vsi->back)->hw;
      
#line 1900 
      u32 qval = readl((void const volatile *)(hw->hw_addr + 237568U));
      
#line 1901 
      qval |= 1073741824U;
      
#line 1902 
      writel(qval,(void volatile *)(hw->hw_addr + 237568U));
      
#line 1904 
      qval = readl((void const volatile *)(hw->hw_addr + 245760U));
      
#line 1905 
      qval |= 1073741824U;
      
#line 1906 
      writel(qval,(void volatile *)(hw->hw_addr + 245760U));
      
#line 1908 
      i40e_irq_dynamic_enable_icr0(vsi->back);
    }
  else ;
  
#line 1912 
  __retres = 0;
  return_label: 
#line 1912 
                return __retres;
}


#line 1922  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_atr(struct i40e_ring *tx_ring, struct sk_buff *skb, u32 tx_flags, __be16 protocol)
{
  struct i40e_filter_program_desc *fdir_desc;
  union __anonunion_hdr_3223 hdr;
  struct tcphdr *th;
  unsigned int hlen;
  u32 flex_ptype;
  u32 dtype_cmd;
  u16 i;
  int tmp;
  int tmp_0;
  
#line 1926 
  struct i40e_pf *pf = (tx_ring->vsi)->back;
  
#line 1938 
  if ((pf->flags & 4194304ULL) == 0ULL) 
#line 1939 
                                        goto return_label; else ;
  
#line 1941 
  if ((pf->auto_disable_flags & 4194304ULL) != 0ULL) 
#line 1942 
                                                     goto return_label; else ;
  
#line 1945 
  if ((unsigned int)tx_ring->atr_sample_rate == 0U) 
#line 1946 
                                                    goto return_label; else ;
  
#line 1948 
  if ((tx_flags & 48U) == 0U) 
#line 1949 
                              goto return_label; else ;
  
#line 1951 
  if ((tx_flags & 1024U) == 0U) {
    
#line 1953 
    hdr.network = skb_network_header((struct sk_buff const *)skb);
    
#line 1958 
    if ((tx_flags & 16U) != 0U) 
#line 1959 
                                hlen = (unsigned int)((int)*(hdr.network) << 2) & 60U;
    else 
      
#line 1960 
      if ((unsigned int)protocol == 56710U) 
#line 1961 
                                            hlen = 40U; else 
#line 1963 
                                                             goto return_label;
  }
  else {
    
#line 1965 
    hdr.network = skb_inner_network_header((struct sk_buff const *)skb);
    
#line 1966 
    hlen = skb_inner_network_header_len((struct sk_buff const *)skb);
  }
  
#line 1973 
  if ((tx_flags & 16U) != 0U && (unsigned int)(hdr.ipv4)->protocol != 6U) 
    
#line 1975 
    goto return_label;
  else 
    
#line 1976 
    if ((tx_flags & 32U) != 0U && (unsigned int)(hdr.ipv6)->nexthdr != 6U) 
      
#line 1978 
      goto return_label; else ;
  
#line 1980 
  th = (struct tcphdr *)(hdr.network + hlen);
  
#line 1983 
  if ((unsigned int)*((unsigned char *)th + 13UL) != 0U && (pf->auto_disable_flags & 4194304ULL) != 0ULL) 
    
#line 1984 
    goto return_label; else ;
  
#line 1986 
  tx_ring->atr_count = (u8)((int)tx_ring->atr_count + 1);
  
#line 1989 
  if ((((unsigned int)*((unsigned char *)th + 13UL) == 0U && (unsigned int)*((unsigned char *)th + 13UL) == 0U) && (unsigned int)*((unsigned char *)th + 13UL) == 0U) && (int)tx_ring->atr_count < (int)tx_ring->atr_sample_rate) 
    
#line 1993 
    goto return_label; else ;
  
#line 1995 
  tx_ring->atr_count = (unsigned char)0U;
  
#line 1998 
  i = tx_ring->next_to_use;
  
#line 1999 
  fdir_desc = (struct i40e_filter_program_desc *)tx_ring->desc + (int)i;
  
#line 2001 
  i = (u16)((int)i + 1);
  
#line 2002 
  if ((int)tx_ring->count > (int)i) 
#line 2002 
                                    tx_ring->next_to_use = i; else 
#line 2002 
                                                                   tx_ring->next_to_use = (unsigned short)0U;
  
#line 2004 
  flex_ptype = (unsigned int)tx_ring->queue_index & 2047U;
  
#line 2008 
  if ((unsigned int)protocol == 8U) 
#line 2008 
                                    tmp = 4325376; else 
#line 2008 
                                                        tmp = 5636096;
  
#line 2006 
  flex_ptype = (unsigned int)tmp | flex_ptype;
  
#line 2012 
  flex_ptype = (unsigned int)((int)(tx_ring->vsi)->id << 23) | flex_ptype;
  
#line 2014 
  dtype_cmd = 8U;
  
#line 2018 
  if ((unsigned int)*((unsigned char *)th + 13UL) != 0U || (unsigned int)*((unsigned char *)th + 13UL) != 0U) 
    
#line 2018 
    tmp_0 = 32; else 
#line 2018 
                     tmp_0 = 16;
  
#line 2016 
  dtype_cmd = (unsigned int)tmp_0 | dtype_cmd;
  
#line 2022 
  dtype_cmd |= 128U;
  
#line 2025 
  dtype_cmd |= 8192U;
  
#line 2028 
  dtype_cmd |= 2048U;
  
#line 2029 
  if ((tx_flags & 1024U) == 0U) 
#line 2030 
                                dtype_cmd = (((unsigned int)((int)pf->hw.pf_id * 3) << 20) & 535822336U) | dtype_cmd; else 
                                                                    
#line 2035 
                                                                    dtype_cmd = (((unsigned int)((int)pf->hw.pf_id * 3 + 2) << 20) & 535822336U) | dtype_cmd;
  
#line 2040 
  fdir_desc->qindex_flex_ptype_vsi = flex_ptype;
  
#line 2041 
  fdir_desc->rsvd = 0U;
  
#line 2042 
  fdir_desc->dtype_cmd_cntindex = dtype_cmd;
  
#line 2043 
  fdir_desc->fd_id = 0U;
  return_label: 
#line 2044 
                return;
}


#line 2059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_tx_prepare_vlan_flags(struct sk_buff *skb, struct i40e_ring *tx_ring, u32 *flags)
{
  int __retres;
  
#line 2068 
  __be16 protocol = skb->protocol;
  
#line 2069 
  u32 tx_flags = 0U;
  
#line 2071 
  if ((unsigned int)protocol == 129U && ((tx_ring->netdev)->features & 128ULL) == 0ULL) {
    
#line 2080 
    skb->protocol = vlan_get_protocol(skb);
    
#line 2081 
    goto out;
  }
  else ;
  
#line 2085 
  if (((int)skb->vlan_tci & 4096) != 0) {
    
#line 2086 
    tx_flags = ((unsigned int)((int)skb->vlan_tci << 16) & 4026466304U) | tx_flags;
    
#line 2087 
    tx_flags |= 2U;
  }
  else 
    
#line 2089 
    if ((unsigned int)protocol == 129U) {
      struct vlan_hdr *vhdr;
      struct vlan_hdr _vhdr;
      int tmp_1;
      
#line 2091 
      vhdr = (struct vlan_hdr *)skb_header_pointer((struct sk_buff const *)skb,14,4,(void *)(& _vhdr));
      
#line 2092 
      if (vhdr == (struct vlan_hdr *)0) {
        
#line 2093 
        __retres = -22;
        
#line 2093 
        goto return_label;
      }
      else ;
      
#line 2095 
      protocol = vhdr->h_vlan_encapsulated_proto;
      
#line 2096 
      if (0 != 0) 
#line 2096 
                  tmp_1 = (int)((unsigned short)(((int)vhdr->h_vlan_TCI << 8) | ((int)vhdr->h_vlan_TCI >> 8))) << 16;
      else {
        __u16 tmp_0;
        
#line 2096 
        tmp_0 = __fswab16((unsigned short)((int)vhdr->h_vlan_TCI));
        
#line 2096 
        tmp_1 = (int)tmp_0 << 16;
      }
      
#line 2096 
      tx_flags = (unsigned int)tmp_1 | tx_flags;
      
#line 2097 
      tx_flags |= 4U;
    }
    else ;
  
#line 2100 
  if ((((tx_ring->vsi)->back)->flags & 1048576ULL) == 0ULL) 
#line 2101 
                                                            goto out; else ;
  
#line 2104 
  if ((tx_flags & 6U) != 0U || skb->priority != 7U) {
    
#line 2106 
    tx_flags &= 536870911U;
    
#line 2107 
    tx_flags = (skb->priority << 29) | tx_flags;
    
#line 2109 
    if ((tx_flags & 4U) != 0U) {
      struct vlan_ethhdr *vhdr_0;
      int rc;
      
#line 2113 
      rc = skb_cow_head(skb,0U);
      
#line 2114 
      if (rc < 0) {
        
#line 2115 
        __retres = rc;
        
#line 2115 
        goto return_label;
      }
      else ;
      
#line 2116 
      vhdr_0 = (struct vlan_ethhdr *)skb->data;
      
#line 2117 
      if (0 != 0) 
#line 2117 
                  vhdr_0->h_vlan_TCI = (unsigned short)(((int)((unsigned short)(tx_flags >> 16)) << 8) | ((int)((unsigned short)(tx_flags >> 16)) >> 8)); else 
                                                                    
#line 2117 
                                                                    vhdr_0->h_vlan_TCI = __fswab16((unsigned short)((int)((unsigned short)(tx_flags >> 16))));
    }
    else 
#line 2120 
         tx_flags |= 2U;
  }
  else ;
  out: 
#line 2124 
  ;
  
#line 2125 
  *flags = tx_flags;
  
#line 2126 
  __retres = 0;
  return_label: 
#line 2126 
                return __retres;
}


#line 2138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_tso(struct i40e_ring *tx_ring, struct sk_buff *skb, u8 *hdr_len, u64 *cd_type_cmd_tso_mss, u32 *cd_tunneling)
{
  int __retres;
  u32 cd_cmd;
  u32 cd_tso_len;
  u32 cd_mss;
  struct ipv6hdr *ipv6h;
  struct tcphdr *tcph;
  struct iphdr *iph;
  u32 l4len;
  int err;
  int tmp_0;
  bool tmp;
  int tmp_15;
  unsigned char *tmp_16;
  
#line 2149 
  tmp = skb_is_gso((struct sk_buff const *)skb);
  
#line 2149 
  if (tmp) 
#line 2149 
           tmp_0 = 0; else 
#line 2149 
                           tmp_0 = 1;
  
#line 2149 
  if (tmp_0) {
    
#line 2150 
    __retres = 0;
    
#line 2150 
    goto return_label;
  }
  else ;
  
#line 2152 
  err = skb_cow_head(skb,0U);
  
#line 2153 
  if (err < 0) {
    
#line 2154 
    __retres = err;
    
#line 2154 
    goto return_label;
  }
  else ;
  
#line 2156 
  if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) 
#line 2156 
                                                           iph = inner_ip_hdr((struct sk_buff const *)skb); else 
                                                                    
#line 2156 
                                                                    iph = ip_hdr((struct sk_buff const *)skb);
  
#line 2157 
  if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) 
#line 2157 
                                                           ipv6h = inner_ipv6_hdr((struct sk_buff const *)skb); else 
                                                                    
#line 2157 
                                                                    ipv6h = ipv6_hdr((struct sk_buff const *)skb);
  
#line 2159 
  if ((unsigned int)*((unsigned char *)iph + 0UL) == 64U) {
    __sum16 tmp_7;
    
#line 2160 
    if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) 
#line 2160 
                                                             tcph = inner_tcp_hdr((struct sk_buff const *)skb); else 
                                                                    
#line 2160 
                                                                    tcph = tcp_hdr((struct sk_buff const *)skb);
    
#line 2161 
    iph->tot_len = (unsigned short)0U;
    
#line 2162 
    iph->check = (unsigned short)0U;
    
#line 2163 
    tmp_7 = csum_tcpudp_magic(iph->saddr,iph->daddr,(unsigned short)0,(unsigned short)6,0U);
    
#line 2163 
    tcph->check = (unsigned short)(~ ((int)tmp_7));
  }
  else 
    
#line 2165 
    if ((unsigned int)*((unsigned char *)ipv6h + 0UL) == 96U) {
      __sum16 tmp_10;
      
#line 2166 
      if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) 
#line 2166 
                                                               tcph = inner_tcp_hdr((struct sk_buff const *)skb); else 
                                                                    
#line 2166 
                                                                    tcph = tcp_hdr((struct sk_buff const *)skb);
      
#line 2167 
      ipv6h->payload_len = (unsigned short)0U;
      
#line 2168 
      tmp_10 = csum_ipv6_magic((struct in6_addr const *)(& ipv6h->saddr),(struct in6_addr const *)(& ipv6h->daddr),0U,(unsigned short)6,0U);
      
#line 2168 
      tcph->check = (unsigned short)(~ ((int)tmp_10));
    }
    else ;
  
#line 2172 
  if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) 
#line 2172 
                                                           l4len = inner_tcp_hdrlen((struct sk_buff const *)skb); else 
                                                                    
#line 2172 
                                                                    l4len = tcp_hdrlen((struct sk_buff const *)skb);
  
#line 2173 
  if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) {
    unsigned char *tmp_13;
    
#line 2174 
    tmp_13 = skb_inner_transport_header((struct sk_buff const *)skb);
    
#line 2173 
    tmp_15 = (int)((unsigned char)((long)tmp_13 - (long)skb->data));
  }
  else {
    int tmp_14;
    
#line 2174 
    tmp_14 = skb_transport_offset((struct sk_buff const *)skb);
    
#line 2173 
    tmp_15 = (int)((unsigned char)tmp_14);
  }
  
#line 2173 
  *hdr_len = (unsigned char)(tmp_15 + (int)((unsigned char)l4len));
  
#line 2178 
  cd_cmd = 1U;
  
#line 2179 
  cd_tso_len = skb->len - (unsigned int)*hdr_len;
  
#line 2180 
  tmp_16 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2180 
  cd_mss = (unsigned int)((struct skb_shared_info *)tmp_16)->gso_size;
  
#line 2181 
  *cd_type_cmd_tso_mss |= (((unsigned long long)cd_cmd << 4) | ((unsigned long long)cd_tso_len << 30)) | ((unsigned long long)cd_mss << 50);
  
#line 2185 
  __retres = 1;
  return_label: 
#line 2185 
                return __retres;
}


#line 2196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_tsyn(struct i40e_ring *tx_ring, struct sk_buff *skb, u32 tx_flags, u64 *cd_type_cmd_tso_mss)
{
  int __retres;
  struct i40e_pf *pf;
  unsigned char *tmp;
  
#line 2201 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2201 
  ;
  
#line 2201 
  if ((long)(((int)((struct skb_shared_info *)tmp)->tx_flags & 1) == 0) != 0L) {
    
#line 2202 
    __retres = 0;
    
#line 2202 
    goto return_label;
  }
  else ;
  
#line 2205 
  if ((tx_flags & 8U) != 0U) {
    
#line 2206 
    __retres = 0;
    
#line 2206 
    goto return_label;
  }
  else ;
  
#line 2211 
  pf = i40e_netdev_to_pf(tx_ring->netdev);
  
#line 2212 
  if ((pf->flags & 33554432ULL) == 0ULL) {
    
#line 2213 
    __retres = 0;
    
#line 2213 
    goto return_label;
  }
  else ;
  
#line 2215 
  if ((int)pf->ptp_tx != 0) {
    int tmp_2;
    
#line 2215 
    tmp_2 = test_and_set_bit_lock(19L,(unsigned long volatile *)(& pf->state));
    
#line 2215 
    if (tmp_2 == 0) {
      unsigned char *tmp_0;
      unsigned char *tmp_1;
      
#line 2217 
      tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
      
#line 2217 
      tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
      
#line 2217 
      ((struct skb_shared_info *)tmp_0)->tx_flags = (unsigned char)((unsigned int)((struct skb_shared_info *)tmp_1)->tx_flags | 4U);
      
#line 2218 
      pf->ptp_tx_skb = skb_get(skb);
    }
    else {
      
#line 2220 
      __retres = 0;
      
#line 2220 
      goto return_label;
    }
  }
  else {
    
#line 2220 
    __retres = 0;
    
#line 2220 
    goto return_label;
  }
  
#line 2223 
  *cd_type_cmd_tso_mss |= 32ULL;
  
#line 2226 
  __retres = 1;
  return_label: 
#line 2226 
                return __retres;
}


#line 2237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags, u32 *td_cmd, u32 *td_offset, struct i40e_ring *tx_ring, u32 *cd_tunneling)
{
  struct ipv6hdr *this_ipv6_hdr;
  unsigned int this_tcp_hdrlen;
  struct iphdr *this_ip_hdr;
  u32 network_hdr_len;
  int tmp_5;
  
#line 2246 
  u8 l4_hdr = (unsigned char)0U;
  
#line 2247 
  u32 l4_tunnel = 0U;
  
#line 2249 
  if ((unsigned int)*((unsigned char *)skb + 146UL) != 0U) {
    struct iphdr *tmp;
    u32 tmp_2;
    int tmp_3;
    int tmp_4;
    
#line 2250 
    tmp = ip_hdr((struct sk_buff const *)skb);
    
#line 2250 
    switch ((int)tmp->protocol) {
      case 17: 
#line 2251 
      ;
      
#line 2252 
      l4_tunnel = 512U;
      
#line 2253 
      *tx_flags |= 1024U;
      
#line 2254 
      goto ldv_61896;
      default: 
#line 2255 
      ;
      
#line 2256 
      goto return_label;
    }
    ldv_61896: 
#line 2258 
    ;
    
#line 2258 
    network_hdr_len = skb_inner_network_header_len((struct sk_buff const *)skb);
    
#line 2259 
    this_ip_hdr = inner_ip_hdr((struct sk_buff const *)skb);
    
#line 2260 
    this_ipv6_hdr = inner_ipv6_hdr((struct sk_buff const *)skb);
    
#line 2261 
    this_tcp_hdrlen = inner_tcp_hdrlen((struct sk_buff const *)skb);
    
#line 2263 
    if ((*tx_flags & 16U) != 0U) 
      
#line 2264 
      if ((*tx_flags & 8U) != 0U) {
        struct iphdr *tmp_0;
        
#line 2265 
        *cd_tunneling |= 3U;
        
#line 2266 
        tmp_0 = ip_hdr((struct sk_buff const *)skb);
        
#line 2266 
        tmp_0->check = (unsigned short)0U;
      }
      else 
#line 2268 
           *cd_tunneling |= 2U;
    else 
      
#line 2271 
      if ((*tx_flags & 32U) != 0U) {
        
#line 2272 
        *cd_tunneling |= 1U;
        
#line 2273 
        if ((*tx_flags & 8U) != 0U) {
          struct iphdr *tmp_1;
          
#line 2274 
          tmp_1 = ip_hdr((struct sk_buff const *)skb);
          
#line 2274 
          tmp_1->check = (unsigned short)0U;
        }
        else ;
      }
      else ;
    
#line 2278 
    tmp_2 = skb_network_header_len((struct sk_buff const *)skb);
    
#line 2282 
    tmp_3 = skb_inner_network_offset((struct sk_buff const *)skb);
    
#line 2281 
    tmp_4 = skb_transport_offset((struct sk_buff const *)skb);
    
#line 2283 
    *cd_tunneling |= (((tmp_2 >> 2) << 2) | l4_tunnel) | (unsigned int)(((tmp_3 - tmp_4) >> 1) << 12);
    
#line 2284 
    if ((unsigned int)*((unsigned char *)this_ip_hdr + 0UL) == 96U) {
      
#line 2285 
      *tx_flags &= 4294967279U;
      
#line 2286 
      *tx_flags |= 32U;
    }
    else ;
  }
  else {
    
#line 2289 
    network_hdr_len = skb_network_header_len((struct sk_buff const *)skb);
    
#line 2290 
    this_ip_hdr = ip_hdr((struct sk_buff const *)skb);
    
#line 2291 
    this_ipv6_hdr = ipv6_hdr((struct sk_buff const *)skb);
    
#line 2292 
    this_tcp_hdrlen = tcp_hdrlen((struct sk_buff const *)skb);
  }
  
#line 2296 
  if ((*tx_flags & 16U) != 0U) {
    
#line 2297 
    l4_hdr = this_ip_hdr->protocol;
    
#line 2301 
    if ((*tx_flags & 8U) != 0U) {
      
#line 2302 
      *td_cmd |= 96U;
      
#line 2303 
      this_ip_hdr->check = (unsigned short)0U;
    }
    else 
#line 2305 
         *td_cmd |= 64U;
    
#line 2308 
    *td_offset = (network_hdr_len >> 2) << 7;
  }
  else 
    
#line 2310 
    if ((*tx_flags & 32U) != 0U) {
      
#line 2311 
      l4_hdr = this_ipv6_hdr->nexthdr;
      
#line 2312 
      *td_cmd |= 32U;
      
#line 2314 
      *td_offset = (network_hdr_len >> 2) << 7;
    }
    else ;
  
#line 2318 
  tmp_5 = skb_network_offset((struct sk_buff const *)skb);
  
#line 2319 
  *td_offset |= (unsigned int)(tmp_5 >> 1);
  
#line 2322 
  switch ((int)l4_hdr) {
    case 6: 
#line 2323 
    ;
    
#line 2325 
    *td_cmd |= 256U;
    
#line 2326 
    *td_offset |= (this_tcp_hdrlen >> 2) << 14;
    
#line 2328 
    goto ldv_61899;
    case 132: 
#line 2329 
    ;
    
#line 2331 
    *td_cmd |= 512U;
    
#line 2332 
    *td_offset |= 49152U;
    
#line 2334 
    goto ldv_61899;
    case 17: 
#line 2335 
    ;
    
#line 2337 
    *td_cmd |= 768U;
    
#line 2338 
    *td_offset |= 32768U;
    
#line 2340 
    goto ldv_61899;
    default: 
#line 2341 
    ;
    
#line 2342 
    goto ldv_61899;
  }
  ldv_61899: 
#line 2344 
  ;
  return_label: 
#line 2345 
                return;
}


#line 2353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_create_tx_ctx(struct i40e_ring *tx_ring, u64 const cd_type_cmd_tso_mss, u32 const cd_tunneling, u32 const cd_l2tag2)
{
  struct i40e_tx_context_desc *context_desc;
  
#line 2358 
  int i = (int)tx_ring->next_to_use;
  
#line 2360 
  if ((cd_type_cmd_tso_mss == 1ULL && cd_tunneling == 0U) && cd_l2tag2 == 0U) 
    
#line 2362 
    goto return_label; else ;
  
#line 2365 
  context_desc = (struct i40e_tx_context_desc *)tx_ring->desc + i;
  
#line 2367 
  i += 1;
  
#line 2368 
  if ((int)tx_ring->count > i) 
#line 2368 
                               tx_ring->next_to_use = (unsigned short)i; else 
                                                                    
#line 2368 
                                                                    tx_ring->next_to_use = (unsigned short)0U;
  
#line 2371 
  context_desc->tunneling_params = cd_tunneling;
  
#line 2372 
  context_desc->l2tag2 = (unsigned short)cd_l2tag2;
  
#line 2373 
  context_desc->rsvd = (unsigned short)0U;
  
#line 2374 
  context_desc->type_cmd_tso_mss = cd_type_cmd_tso_mss;
  return_label: 
#line 2375 
                return;
}


#line 2384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static int __i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
{
  int __retres;
  int tmp;
  
#line 2386 
  netif_start_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
  
#line 2387 
  ldv_inline_asm();
  
#line 2391 
  if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
#line 2391 
                                                                tmp = (int)tx_ring->count; else 
                                                                    
#line 2391 
                                                                    tmp = 0;
  
#line 2391 
  ;
  
#line 2391 
  if ((long)(((tmp + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use) + -1 < size) != 0L) {
    
#line 2392 
    __retres = -16;
    
#line 2392 
    goto return_label;
  }
  else ;
  
#line 2395 
  netif_start_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
  
#line 2396 
  tx_ring->__anonCompField_i40e_ring_122.tx_stats.restart_queue += 1ULL;
  
#line 2397 
  __retres = 0;
  return_label: 
#line 2397 
                return __retres;
}


#line 2408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
{
  int __retres;
  int tmp;
  int tmp_0;
  
#line 2413 
  if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
#line 2413 
                                                                tmp = (int)tx_ring->count; else 
                                                                    
#line 2413 
                                                                    tmp = 0;
  
#line 2413 
  ;
  
#line 2413 
  if ((long)(((tmp + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use) + -1 >= size) != 0L) {
    
#line 2414 
    __retres = 0;
    
#line 2414 
    goto return_label;
  }
  else ;
  
#line 2415 
  tmp_0 = __i40e_maybe_stop_tx(tx_ring,size);
  
#line 2415 
  __retres = tmp_0;
  return_label: 
#line 2415 
                return __retres;
}


#line 2427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static bool i40e_chk_linearize(struct sk_buff *skb, u32 tx_flags)
{
  struct skb_frag_struct *frag;
  u16 num_frags;
  u16 gso_segs;
  unsigned char *tmp;
  unsigned char *tmp_0;
  
#line 2430 
  bool linearize = (_Bool)0;
  
#line 2431 
  unsigned int size = 0U;
  
#line 2435 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2435 
  num_frags = (unsigned short)((struct skb_shared_info *)tmp)->nr_frags;
  
#line 2436 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2436 
  gso_segs = ((struct skb_shared_info *)tmp_0)->gso_segs;
  
#line 2438 
  if ((tx_flags & 136U) != 0U) {
    unsigned char *tmp_1;
    unsigned int tmp_2;
    unsigned char *tmp_4;
    
#line 2439 
    u16 j = (unsigned short)0U;
    
#line 2441 
    if ((unsigned int)num_frags <= 7U) 
#line 2442 
                                       goto linearize_chk_done; else ;
    
#line 2444 
    if (((((int)num_frags + (int)gso_segs) + (int)gso_segs) + -1) / (int)gso_segs > 8) {
      
#line 2446 
      linearize = (_Bool)1;
      
#line 2447 
      goto linearize_chk_done;
    }
    else ;
    
#line 2449 
    tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2449 
    frag = & ((struct skb_shared_info *)tmp_1)->frags[0];
    ldv_61931: 
#line 2450 
    ;
    
#line 2452 
    tmp_2 = skb_frag_size((skb_frag_t const *)frag);
    
#line 2452 
    size = tmp_2 + size;
    
#line 2453 
    frag += 1;
    
#line 2453 
    j = (u16)((int)j + 1);
    
#line 2454 
    tmp_4 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2454 
    ;
    
#line 2454 
    if ((unsigned int)((struct skb_shared_info *)tmp_4)->gso_size <= size) {
      
#line 2454 
      if ((unsigned int)j <= 7U) {
        unsigned char *tmp_3;
        
#line 2456 
        tmp_3 = skb_end_pointer((struct sk_buff const *)skb);
        
#line 2456 
        size %= (unsigned int)((struct skb_shared_info *)tmp_3)->gso_size;
        
#line 2457 
        j = (unsigned short)(size != 0U);
      }
      else ;
    }
    else ;
    
#line 2459 
    if ((unsigned int)j == 8U) {
      
#line 2460 
      linearize = (_Bool)1;
      
#line 2461 
      goto ldv_61930;
    }
    else ;
    
#line 2463 
    num_frags = (u16)((int)num_frags - 1);
    
#line 2464 
    if ((unsigned int)num_frags != 0U) 
#line 2466 
                                       goto ldv_61931; else 
#line 2469 
                                                            goto ldv_61930;
    ldv_61930: 
#line 2470 
    ;
  }
  else 
    
#line 2466 
    if ((unsigned int)num_frags > 7U) 
#line 2467 
                                      linearize = (_Bool)1; else ;
  linearize_chk_done: 
#line 2470 
  ;
  
#line 2471 
  return linearize;
}


#line 2485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb, struct i40e_tx_buffer *first, u32 tx_flags, u8 const hdr_len, u32 td_cmd, u32 td_offset)
{
  struct skb_frag_struct *frag;
  struct i40e_tx_buffer *tx_bi;
  struct i40e_tx_desc *tx_desc;
  dma_addr_t dma;
  u16 gso_segs;
  unsigned char *tmp_1;
  int tmp_2;
  struct netdev_queue *tmp_5;
  
#line 2494 
  unsigned int data_len = skb->data_len;
  
#line 2495 
  unsigned int size = skb_headlen((struct sk_buff const *)skb);
  
#line 2499 
  u16 i = tx_ring->next_to_use;
  
#line 2500 
  u32 td_tag = 0U;
  
#line 2504 
  if ((tx_flags & 2U) != 0U) {
    
#line 2505 
    td_cmd |= 8U;
    
#line 2506 
    td_tag = tx_flags >> 16;
  }
  else ;
  
#line 2510 
  if ((tx_flags & 136U) != 0U) {
    unsigned char *tmp_0;
    
#line 2511 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2511 
    gso_segs = ((struct skb_shared_info *)tmp_0)->gso_segs;
  }
  else 
#line 2513 
       gso_segs = (unsigned short)1U;
  
#line 2516 
  first->bytecount = (skb->len - (unsigned int)hdr_len) + (unsigned int)((int)gso_segs * (int)hdr_len);
  
#line 2517 
  first->gso_segs = gso_segs;
  
#line 2518 
  first->__anonCompField_i40e_tx_buffer_120.skb = skb;
  
#line 2519 
  first->tx_flags = tx_flags;
  
#line 2521 
  dma = dma_map_single_attrs(tx_ring->dev,(void *)skb->data,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 2523 
  tx_desc = (struct i40e_tx_desc *)tx_ring->desc + (int)i;
  
#line 2524 
  tx_bi = first;
  
#line 2526 
  tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2526 
  frag = & ((struct skb_shared_info *)tmp_1)->frags[0];
  ldv_61955: 
#line 2527 
  ;
  
#line 2527 
  tmp_2 = dma_mapping_error(tx_ring->dev,dma);
  
#line 2527 
  if (tmp_2 != 0) 
#line 2528 
                  goto dma_error; else ;
  
#line 2531 
  tx_bi->len = size;
  
#line 2532 
  tx_bi->dma = dma;
  
#line 2534 
  tx_desc->buffer_addr = dma;
  
#line 2536 
  goto ldv_61952;
  ldv_61951: 
#line 2537 
  ;
  
#line 2537 
  tx_desc->cmd_type_offset_bsz = build_ctob(td_cmd,td_offset,8192U,td_tag);
  
#line 2541 
  tx_desc += 1;
  
#line 2542 
  i = (u16)((int)i + 1);
  
#line 2543 
  if ((int)tx_ring->count == (int)i) {
    
#line 2544 
    tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
    
#line 2545 
    i = (unsigned short)0U;
  }
  else ;
  
#line 2548 
  dma += 8192ULL;
  
#line 2549 
  size += 4294959104U;
  
#line 2551 
  tx_desc->buffer_addr = dma;
  ldv_61952: 
#line 2552 
  ;
  
#line 2536 
  if ((long)(size > 8192U) != 0L) 
#line 2538 
                                  goto ldv_61951; else 
#line 2541 
                                                       goto ldv_61953;
  ldv_61953: 
#line 2542 
  ;
  
#line 2554 
  if ((long)(data_len == 0U) != 0L) 
#line 2555 
                                    goto ldv_61954; else ;
  
#line 2557 
  tx_desc->cmd_type_offset_bsz = build_ctob(td_cmd,td_offset,size,td_tag);
  
#line 2560 
  tx_desc += 1;
  
#line 2561 
  i = (u16)((int)i + 1);
  
#line 2562 
  if ((int)tx_ring->count == (int)i) {
    
#line 2563 
    tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
    
#line 2564 
    i = (unsigned short)0U;
  }
  else ;
  
#line 2567 
  size = skb_frag_size((skb_frag_t const *)frag);
  
#line 2568 
  data_len -= size;
  
#line 2570 
  dma = skb_frag_dma_map(tx_ring->dev,(skb_frag_t const *)frag,0UL,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE);
  
#line 2573 
  tx_bi = tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)i;
  
#line 2526 
  frag += 1;
  
#line 2527 
  goto ldv_61955;
  ldv_61954: 
#line 2528 
  ;
  
#line 2579 
  if ((((int)i & 3) != 3 && tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)i >= first) && tx_ring->__anonCompField_i40e_ring_121.tx_bi + ((int)i & -4) <= first) {
    __le64 tmp_3;
    
#line 2583 
    tmp_3 = build_ctob(td_cmd,td_offset,size,td_tag);
    
#line 2582 
    tx_desc->cmd_type_offset_bsz = tmp_3 | 16ULL;
  }
  else {
    __le64 tmp_4;
    
#line 2588 
    tmp_4 = build_ctob(td_cmd,td_offset,size,td_tag);
    
#line 2587 
    tx_desc->cmd_type_offset_bsz = tmp_4 | 48ULL;
  }
  
#line 2593 
  ;
  
#line 2593 
  tmp_5 = netdev_get_tx_queue((struct net_device const *)tx_ring->netdev,(unsigned int)tx_ring->queue_index);
  
#line 2593 
  netdev_tx_sent_queue(tmp_5,first->bytecount);
  
#line 2596 
  ldv_inline_asm();
  
#line 2605 
  first->next_to_watch = tx_desc;
  
#line 2607 
  i = (u16)((int)i + 1);
  
#line 2608 
  if ((int)tx_ring->count == (int)i) 
#line 2609 
                                     i = (unsigned short)0U; else ;
  
#line 2611 
  tx_ring->next_to_use = i;
  
#line 2613 
  i40e_maybe_stop_tx(tx_ring,21);
  
#line 2615 
  if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) 
#line 2618 
                                                           writel((unsigned int)i,(void volatile *)tx_ring->tail);
  else {
    bool tmp_7;
    struct netdev_queue *tmp_6;
    
#line 2616 
    tmp_6 = netdev_get_tx_queue((struct net_device const *)tx_ring->netdev,(unsigned int)tx_ring->queue_index);
    
#line 2615 
    tmp_7 = netif_xmit_stopped((struct netdev_queue const *)tmp_6);
    
#line 2615 
    if ((int)tmp_7 != 0) 
#line 2618 
                         writel((unsigned int)i,(void volatile *)tx_ring->tail); else ;
  }
  
#line 2620 
  goto return_label;
  dma_error: 
#line 2622 
  ;
  
#line 2623 
  _dev_info((struct device const *)tx_ring->dev,"TX DMA map failed\n");
  ldv_61957: 
#line 2624 
  ;
  
#line 2627 
  tx_bi = tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)i;
  
#line 2628 
  i40e_unmap_and_free_tx_resource(tx_ring,tx_bi);
  
#line 2629 
  if (tx_bi == first) 
#line 2630 
                      goto ldv_61956; else ;
  
#line 2631 
  if ((unsigned int)i == 0U) 
#line 2632 
                             i = tx_ring->count; else ;
  
#line 2633 
  i = (u16)((int)i - 1);
  
#line 2627 
  goto ldv_61957;
  ldv_61956: 
#line 2628 
  ;
  
#line 2636 
  tx_ring->next_to_use = i;
  return_label: 
#line 2637 
                return;
}


#line 2649  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_xmit_descriptor_count(struct sk_buff *skb, struct i40e_ring *tx_ring)
{
  int __retres;
  unsigned int f;
  unsigned char *tmp;
  unsigned char *tmp_0;
  unsigned int tmp_1;
  int tmp_2;
  
#line 2657 
  int count = 0;
  
#line 2665 
  f = 0U;
  
#line 2665 
  goto ldv_61965;
  ldv_61964: 
#line 2666 
  ;
  
#line 2666 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2666 
  count = (int)((((struct skb_shared_info *)tmp)->frags[f].size + 8191U) / 8192U + (unsigned int)count);
  
#line 2665 
  f += 1U;
  ldv_61965: 
#line 2666 
  ;
  
#line 2665 
  tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2665 
  ;
  
#line 2665 
  if ((unsigned int)((struct skb_shared_info *)tmp_0)->nr_frags > f) 
    
#line 2667 
    goto ldv_61964; else 
#line 2670 
                         goto ldv_61966;
  ldv_61966: 
#line 2671 
  ;
  
#line 2668 
  tmp_1 = skb_headlen((struct sk_buff const *)skb);
  
#line 2668 
  count = (int)((tmp_1 + 8191U) / 8192U + (unsigned int)count);
  
#line 2669 
  tmp_2 = i40e_maybe_stop_tx(tx_ring,count + 5);
  
#line 2669 
  if (tmp_2 != 0) {
    
#line 2670 
    tx_ring->__anonCompField_i40e_ring_122.tx_stats.tx_busy += 1ULL;
    
#line 2671 
    __retres = 0;
    
#line 2671 
    goto return_label;
  }
  else ;
  
#line 2673 
  __retres = count;
  return_label: 
#line 2673 
                return __retres;
}


#line 2683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static netdev_tx_t i40e_xmit_frame_ring(struct sk_buff *skb, struct i40e_ring *tx_ring)
{
  netdev_tx_t __retres;
  struct i40e_tx_buffer *first;
  __be16 protocol;
  int tsyn;
  int tso;
  int tmp;
  int tmp_0;
  bool tmp_2;
  
#line 2686 
  u64 cd_type_cmd_tso_mss = 1ULL;
  
#line 2687 
  u32 cd_tunneling = 0U;
  
#line 2687 
  u32 cd_l2tag2 = 0U;
  
#line 2689 
  u32 td_offset = 0U;
  
#line 2690 
  u32 tx_flags = 0U;
  
#line 2692 
  u32 td_cmd = 0U;
  
#line 2693 
  u8 hdr_len = (unsigned char)0U;
  
#line 2696 
  tmp = i40e_xmit_descriptor_count(skb,tx_ring);
  
#line 2696 
  if (tmp == 0) {
    
#line 2697 
    __retres = NETDEV_TX_BUSY;
    
#line 2697 
    goto return_label;
  }
  else ;
  
#line 2700 
  tmp_0 = i40e_tx_prepare_vlan_flags(skb,tx_ring,& tx_flags);
  
#line 2700 
  if (tmp_0 != 0) 
#line 2701 
                  goto out_drop; else ;
  
#line 2704 
  protocol = vlan_get_protocol(skb);
  
#line 2707 
  first = tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)tx_ring->next_to_use;
  
#line 2710 
  if ((unsigned int)protocol == 8U) 
#line 2711 
                                    tx_flags |= 16U;
  else 
    
#line 2712 
    if ((unsigned int)protocol == 56710U) 
#line 2713 
                                          tx_flags |= 32U; else ;
  
#line 2715 
  tso = i40e_tso(tx_ring,skb,& hdr_len,& cd_type_cmd_tso_mss,& cd_tunneling);
  
#line 2718 
  if (tso < 0) 
#line 2719 
               goto out_drop;
  else 
    
#line 2720 
    if (tso != 0) 
#line 2721 
                  tx_flags |= 8U; else ;
  
#line 2723 
  tsyn = i40e_tsyn(tx_ring,skb,tx_flags,& cd_type_cmd_tso_mss);
  
#line 2725 
  if (tsyn != 0) 
#line 2726 
                 tx_flags |= 256U; else ;
  
#line 2728 
  tmp_2 = i40e_chk_linearize(skb,tx_flags);
  
#line 2728 
  if ((int)tmp_2 != 0) {
    int tmp_1;
    
#line 2729 
    tmp_1 = skb_linearize(skb);
    
#line 2729 
    if (tmp_1 != 0) 
#line 2730 
                    goto out_drop; else ;
  }
  else ;
  
#line 2732 
  skb_tx_timestamp(skb);
  
#line 2735 
  td_cmd |= 4U;
  
#line 2738 
  if ((unsigned int)*((unsigned char *)skb + 145UL) == 6U) {
    
#line 2739 
    tx_flags |= 1U;
    
#line 2741 
    i40e_tx_enable_csum(skb,& tx_flags,& td_cmd,& td_offset,tx_ring,& cd_tunneling);
  }
  else ;
  
#line 2745 
  i40e_create_tx_ctx(tx_ring,cd_type_cmd_tso_mss,cd_tunneling,cd_l2tag2);
  
#line 2752 
  i40e_atr(tx_ring,skb,tx_flags,(unsigned short)((int)protocol));
  
#line 2754 
  i40e_tx_map(tx_ring,skb,first,tx_flags,(unsigned char)((int)hdr_len),td_cmd,td_offset);
  
#line 2757 
  __retres = NETDEV_TX_OK;
  
#line 2757 
  goto return_label;
  out_drop: 
#line 2759 
  ;
  
#line 2760 
  dev_kfree_skb_any(skb);
  
#line 2761 
  __retres = NETDEV_TX_OK;
  return_label: 
#line 2761 
                return __retres;
}


#line 2771  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
netdev_tx_t i40e_lan_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
{
  netdev_tx_t __retres;
  int tmp_0;
  netdev_tx_t tmp_1;
  
#line 2773 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 2774 
  struct i40e_vsi *vsi = np->vsi;
  
#line 2775 
  struct i40e_ring *tx_ring = *(vsi->tx_rings + (int)skb->queue_mapping);
  
#line 2780 
  tmp_0 = skb_put_padto(skb,17U);
  
#line 2780 
  if (tmp_0 != 0) {
    
#line 2781 
    __retres = NETDEV_TX_OK;
    
#line 2781 
    goto return_label;
  }
  else ;
  
#line 2783 
  tmp_1 = i40e_xmit_frame_ring(skb,tx_ring);
  
#line 2783 
  __retres = tmp_1;
  return_label: 
#line 2783 
                return __retres;
}


#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_txrx.c.aux"
static void atomic_inc(atomic_t *v)
{
  
#line 125 
  ldv_atomic_inc(v);
  
#line 126 
  return;
}


#line 599  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_txrx.c.aux"
static void *kzalloc_3(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 602 
  tmp = ldv_kzalloc(size,flags);
  
#line 602 
  return tmp;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
__inline static int i40e_aq_rc_to_posix(u32 aq_ret, u16 aq_rc)
{
  int __retres;
  
#line 115 
  int aq_to_posix[23U] = {0, -1, -2, -3, -4, -5, -6, -7, -11, -12, -13, -14, -16, -17, -22, -25, -28, -38, -34, -32, -29, -30, -27};
  
#line 142 
  if (aq_ret == 4294967242U) {
    
#line 143 
    __retres = -11;
    
#line 143 
    goto return_label;
  }
  else ;
  
#line 145 
  if ((unsigned int)aq_rc > 22U) {
    
#line 146 
    __retres = -34;
    
#line 146 
    goto return_label;
  }
  else ;
  
#line 147 
  __retres = aq_to_posix[(int)aq_rc];
  return_label: 
#line 147 
                return __retres;
}


#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
i40e_status i40e_aq_request_resource(struct i40e_hw *hw, enum i40e_aq_resources_ids resource, enum i40e_aq_resource_access_type access, u8 sdp_number, u64 *timeout, struct i40e_asq_cmd_details *cmd_details);


#line 151 
i40e_status i40e_aq_release_resource(struct i40e_hw *hw, enum i40e_aq_resources_ids resource, u8 sdp_number, struct i40e_asq_cmd_details *cmd_details);


#line 159 
i40e_status i40e_aq_erase_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, bool last_command, struct i40e_asq_cmd_details *cmd_details);


#line 265 
i40e_status i40e_init_nvm(struct i40e_hw *hw);


#line 271 
i40e_status i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset, u16 *words, u16 *data);


#line 273 
i40e_status i40e_update_nvm_checksum(struct i40e_hw *hw);


#line 274 
i40e_status i40e_validate_nvm_checksum(struct i40e_hw *hw, u16 *checksum);


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_init_nvm(struct i40e_hw *hw)
{
  u32 fla;
  u32 gens;
  u8 sr_size;
  
#line 41 
  struct i40e_nvm_info *nvm = & hw->nvm;
  
#line 42 
  i40e_status ret_code = 0;
  
#line 49 
  gens = readl((void const volatile *)(hw->hw_addr + 745728U));
  
#line 50 
  sr_size = (unsigned char)((unsigned int)((unsigned char)(gens >> 5)) & 7U);
  
#line 53 
  nvm->sr_size = (unsigned short)(512 << (int)sr_size);
  
#line 56 
  fla = readl((void const volatile *)(hw->hw_addr + 745736U));
  
#line 57 
  if ((fla & 64U) != 0U) {
    
#line 59 
    nvm->timeout = 18000U;
    
#line 60 
    nvm->blank_nvm_mode = (_Bool)0;
  }
  else {
    
#line 62 
    nvm->blank_nvm_mode = (_Bool)1;
    
#line 63 
    ret_code = I40E_ERR_NVM_BLANK_MODE;
    
#line 64 
    if ((hw->debug_mask & 128U) != 0U) 
#line 64 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
  }
  
#line 67 
  return ret_code;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_acquire_nvm(struct i40e_hw *hw, enum i40e_aq_resource_access_type access)
{
  u64 gtime;
  u64 timeout;
  unsigned int tmp;
  
#line 81 
  i40e_status ret_code = 0;
  
#line 83 
  u64 time_left = 0ULL;
  
#line 85 
  if ((int)hw->nvm.blank_nvm_mode != 0) 
#line 86 
                                        goto i40e_i40e_acquire_nvm_exit; else ;
  
#line 88 
  ret_code = i40e_aq_request_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,access,(unsigned char)0,& time_left,(struct i40e_asq_cmd_details *)0);
  
#line 91 
  tmp = readl((void const volatile *)(hw->hw_addr + 557500U));
  
#line 91 
  gtime = (unsigned long long)tmp;
  
#line 94 
  hw->nvm.hw_semaphore_timeout = time_left * 1000ULL + gtime;
  
#line 96 
  if (ret_code != I40E_SUCCESS) {
    
#line 97 
    if ((hw->debug_mask & 128U) != 0U) 
#line 97 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(unsigned int)access,time_left,(int)ret_code,(unsigned int)hw->aq.asq_last_status); else ;
  }
  else ;
  
#line 101 
  if (ret_code != I40E_SUCCESS && time_left != 0ULL) {
    unsigned int tmp_0;
    
#line 103 
    timeout = gtime + 18000000ULL;
    
#line 104 
    goto ldv_52933;
    ldv_52932: 
#line 105 
    ;
    
#line 105 
    usleep_range(10000UL,20000UL);
    
#line 106 
    tmp_0 = readl((void const volatile *)(hw->hw_addr + 557500U));
    
#line 106 
    gtime = (unsigned long long)tmp_0;
    
#line 107 
    ret_code = i40e_aq_request_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,access,(unsigned char)0,& time_left,(struct i40e_asq_cmd_details *)0);
    
#line 111 
    if (ret_code == I40E_SUCCESS) {
      
#line 112 
      hw->nvm.hw_semaphore_timeout = time_left * 1000ULL + gtime;
      
#line 114 
      goto ldv_52931;
    }
    else ;
    ldv_52933: 
#line 116 
    ;
    
#line 104 
    if (gtime < timeout && time_left != 0ULL) 
#line 106 
                                              goto ldv_52932; else 
#line 109 
                                                                   goto ldv_52931;
    ldv_52931: 
#line 110 
    ;
    
#line 117 
    if (ret_code != I40E_SUCCESS) {
      
#line 118 
      hw->nvm.hw_semaphore_timeout = 0ULL;
      
#line 119 
      if ((hw->debug_mask & 128U) != 0U) 
#line 119 
                                         printk("\001",(int)hw->bus.device,(int)hw->bus.func,time_left,(int)ret_code,(unsigned int)hw->aq.asq_last_status); else ;
    }
    else ;
  }
  else ;
  i40e_i40e_acquire_nvm_exit: 
#line 125 
  ;
  
#line 126 
  return ret_code;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
void i40e_release_nvm(struct i40e_hw *hw)
{
  
#line 137 
  if (! hw->nvm.blank_nvm_mode) 
#line 138 
                                i40e_aq_release_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,(unsigned char)0,(struct i40e_asq_cmd_details *)0); else ;
  
#line 139 
  return;
}


#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_poll_sr_srctl_done_bit(struct i40e_hw *hw)
{
  u32 srctl;
  u32 wait_cnt;
  
#line 149 
  i40e_status ret_code = -37;
  
#line 153 
  wait_cnt = 0U;
  
#line 153 
  goto ldv_52945;
  ldv_52944: 
#line 154 
  ;
  
#line 154 
  srctl = readl((void const volatile *)(hw->hw_addr + 745744U));
  
#line 155 
  if (srctl < (u32)0) {
    
#line 156 
    ret_code = I40E_SUCCESS;
    
#line 157 
    goto ldv_52943;
  }
  else ;
  
#line 159 
  __const_udelay(21475UL);
  
#line 153 
  wait_cnt += 1U;
  ldv_52945: 
#line 154 
  ;
  
#line 153 
  if (wait_cnt <= 99999U) 
#line 155 
                          goto ldv_52944; else 
#line 158 
                                               goto ldv_52943;
  ldv_52943: 
#line 159 
  ;
  
#line 161 
  if (ret_code == I40E_ERR_TIMEOUT) {
    
#line 162 
    if ((hw->debug_mask & 128U) != 0U) 
#line 162 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
  }
  else ;
  
#line 163 
  return ret_code;
}


#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_read_nvm_word_srctl(struct i40e_hw *hw, u16 offset, u16 *data)
{
  u32 sr_reg;
  
#line 177 
  i40e_status ret_code = -37;
  
#line 180 
  if ((int)hw->nvm.sr_size <= (int)offset) {
    
#line 181 
    if ((hw->debug_mask & 128U) != 0U) 
#line 181 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)offset,(int)hw->nvm.sr_size); else ;
    
#line 184 
    ret_code = I40E_ERR_PARAM;
    
#line 185 
    goto read_nvm_exit;
  }
  else ;
  
#line 189 
  ret_code = i40e_poll_sr_srctl_done_bit(hw);
  
#line 190 
  if (ret_code == I40E_SUCCESS) {
    
#line 192 
    sr_reg = (unsigned int)((int)offset << 14) | 1073741824U;
    
#line 194 
    writel(sr_reg,(void volatile *)(hw->hw_addr + 745744U));
    
#line 197 
    ret_code = i40e_poll_sr_srctl_done_bit(hw);
    
#line 198 
    if (ret_code == I40E_SUCCESS) {
      
#line 199 
      sr_reg = readl((void const volatile *)(hw->hw_addr + 745748U));
      
#line 200 
      *data = (unsigned short)(sr_reg >> 16);
    }
    else ;
  }
  else ;
  
#line 205 
  if (ret_code != I40E_SUCCESS) {
    
#line 206 
    if ((hw->debug_mask & 128U) != 0U) 
#line 206 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)offset); else ;
  }
  else ;
  read_nvm_exit: 
#line 210 
  ;
  
#line 211 
  return ret_code;
}


#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_read_nvm_word(struct i40e_hw *hw, u16 offset, u16 *data)
{
  i40e_status tmp;
  
#line 225 
  tmp = i40e_read_nvm_word_srctl(hw,(unsigned short)((int)offset),data);
  
#line 225 
  return tmp;
}


#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_read_nvm_buffer_srctl(struct i40e_hw *hw, u16 offset, u16 *words, u16 *data)
{
  u16 index;
  u16 word;
  
#line 242 
  i40e_status ret_code = 0;
  
#line 246 
  word = (unsigned short)0U;
  
#line 246 
  goto ldv_52970;
  ldv_52969: 
#line 247 
  ;
  
#line 247 
  index = (unsigned short)((int)offset + (int)word);
  
#line 248 
  ret_code = i40e_read_nvm_word_srctl(hw,(unsigned short)((int)index),data + (int)word);
  
#line 249 
  if (ret_code != I40E_SUCCESS) 
#line 250 
                                goto ldv_52968; else ;
  
#line 246 
  word = (u16)((int)word + 1);
  ldv_52970: 
#line 247 
  ;
  
#line 246 
  if ((int)*words > (int)word) 
#line 248 
                               goto ldv_52969; else 
#line 251 
                                                    goto ldv_52968;
  ldv_52968: 
#line 252 
  ;
  
#line 254 
  *words = word;
  
#line 256 
  return ret_code;
}


#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset, u16 *words, u16 *data)
{
  i40e_status tmp;
  
#line 273 
  tmp = i40e_read_nvm_buffer_srctl(hw,(unsigned short)((int)offset),words,data);
  
#line 273 
  return tmp;
}


#line 287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_write_nvm_aq(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 words, void *data, bool last_command)
{
  
#line 291 
  i40e_status ret_code = -1;
  
#line 298 
  if ((unsigned int)words + offset > (unsigned int)hw->nvm.sr_size) {
    
#line 299 
    if ((hw->debug_mask & 128U) != 0U) 
#line 299 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(unsigned int)words + offset,(int)hw->nvm.sr_size); else ;
  }
  else 
    
#line 302 
    if ((unsigned int)words > 2048U) {
      
#line 304 
      if ((hw->debug_mask & 128U) != 0U) 
#line 304 
                                         printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)words,2048); else ;
    }
    else 
      
#line 307 
      if ((((unsigned int)words + offset) + 4294967295U) / 2048U != offset / 2048U) {
        
#line 310 
        if ((hw->debug_mask & 128U) != 0U) 
#line 310 
                                           printk("\001",(int)hw->bus.device,(int)hw->bus.func,offset,(int)words); else ;
      }
      else 
#line 314 
           ret_code = i40e_aq_update_nvm(hw,(unsigned char)((int)module_pointer),offset * 2U,(unsigned short)((int)((unsigned int)words * 2U)),data,(_Bool)((bool)((int)last_command) != 0),(struct i40e_asq_cmd_details *)0);
  
#line 319 
  return ret_code;
}


#line 332  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_calc_nvm_checksum(struct i40e_hw *hw, u16 *checksum)
{
  struct i40e_virt_mem vmem;
  u16 *data;
  
#line 335 
  i40e_status ret_code = 0;
  
#line 337 
  u16 pcie_alt_module = (unsigned short)0U;
  
#line 338 
  u16 checksum_local = (unsigned short)0U;
  
#line 339 
  u16 vpd_module = (unsigned short)0U;
  
#line 341 
  u16 i = (unsigned short)0U;
  
#line 343 
  ret_code = i40e_allocate_virt_mem_d(hw,& vmem,4096U);
  
#line 345 
  if (ret_code != I40E_SUCCESS) 
#line 346 
                                goto i40e_calc_nvm_checksum_exit; else ;
  
#line 347 
  data = (u16 *)vmem.va;
  
#line 350 
  ret_code = i40e_read_nvm_word(hw,(unsigned short)47,& vpd_module);
  
#line 351 
  if (ret_code != I40E_SUCCESS) {
    
#line 352 
    ret_code = I40E_ERR_NVM_CHECKSUM;
    
#line 353 
    goto i40e_calc_nvm_checksum_exit;
  }
  else ;
  
#line 357 
  ret_code = i40e_read_nvm_word(hw,(unsigned short)62,& pcie_alt_module);
  
#line 359 
  if (ret_code != I40E_SUCCESS) {
    
#line 360 
    ret_code = I40E_ERR_NVM_CHECKSUM;
    
#line 361 
    goto i40e_calc_nvm_checksum_exit;
  }
  else ;
  
#line 367 
  i = (unsigned short)0U;
  
#line 367 
  goto ldv_53001;
  ldv_53000: 
#line 368 
  ;
  
#line 369 
  if (((unsigned int)i & 2047U) == 0U) {
    
#line 370 
    u16 words = (unsigned short)2048U;
    
#line 372 
    ret_code = i40e_read_nvm_buffer(hw,(unsigned short)((int)i),& words,data);
    
#line 373 
    if (ret_code != I40E_SUCCESS) {
      
#line 374 
      ret_code = I40E_ERR_NVM_CHECKSUM;
      
#line 375 
      goto i40e_calc_nvm_checksum_exit;
    }
    else ;
  }
  else ;
  
#line 380 
  if ((unsigned int)i == 63U) 
#line 381 
                              goto ldv_52999; else ;
  
#line 383 
  if ((int)i >= (int)vpd_module && (unsigned int)i < (unsigned int)vpd_module + 512U) 
    
#line 386 
    goto ldv_52999; else ;
  
#line 389 
  if ((int)i >= (int)pcie_alt_module && (unsigned int)i < (unsigned int)pcie_alt_module + 512U) 
    
#line 392 
    goto ldv_52999; else ;
  
#line 395 
  checksum_local = (unsigned short)((int)*(data + ((unsigned int)i & 2047U)) + (int)checksum_local);
  ldv_52999: 
#line 396 
  ;
  
#line 367 
  i = (u16)((int)i + 1);
  ldv_53001: 
#line 368 
  ;
  
#line 367 
  if ((int)hw->nvm.sr_size > (int)i) 
#line 369 
                                     goto ldv_53000; else 
#line 372 
                                                          goto ldv_53002;
  ldv_53002: 
#line 373 
  ;
  
#line 398 
  *checksum = (unsigned short)(47802U - (unsigned int)checksum_local);
  i40e_calc_nvm_checksum_exit: 
#line 400 
  ;
  
#line 401 
  i40e_free_virt_mem_d(hw,& vmem);
  
#line 402 
  return ret_code;
}


#line 413  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_update_nvm_checksum(struct i40e_hw *hw)
{
  u16 checksum;
  
#line 415 
  i40e_status ret_code = 0;
  
#line 418 
  ret_code = i40e_calc_nvm_checksum(hw,& checksum);
  
#line 419 
  if (ret_code == I40E_SUCCESS) 
#line 420 
                                ret_code = i40e_write_nvm_aq(hw,(unsigned char)0,63U,(unsigned short)1,(void *)(& checksum),(_Bool)1); else ;
  
#line 423 
  return ret_code;
}


#line 434  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_validate_nvm_checksum(struct i40e_hw *hw, u16 *checksum)
{
  
#line 437 
  i40e_status ret_code = 0;
  
#line 438 
  u16 checksum_sr = (unsigned short)0U;
  
#line 439 
  u16 checksum_local = (unsigned short)0U;
  
#line 441 
  ret_code = i40e_calc_nvm_checksum(hw,& checksum_local);
  
#line 442 
  if (ret_code != I40E_SUCCESS) 
#line 443 
                                goto i40e_validate_nvm_checksum_exit; else ;
  
#line 448 
  i40e_read_nvm_word(hw,(unsigned short)63,& checksum_sr);
  
#line 453 
  if ((int)checksum_local != (int)checksum_sr) 
#line 454 
                                               ret_code = I40E_ERR_NVM_CHECKSUM; else ;
  
#line 457 
  if (checksum != (u16 *)0U) 
#line 458 
                             *checksum = checksum_local; else ;
  i40e_validate_nvm_checksum_exit: 
#line 460 
  ;
  
#line 461 
  return ret_code;
}


#line 464 
static i40e_status i40e_nvmupd_state_init(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno);


#line 467 
static i40e_status i40e_nvmupd_state_reading(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno);


#line 470 
static i40e_status i40e_nvmupd_state_writing(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno);


#line 473 
static enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw, struct i40e_nvm_access *cmd, int *errno);


#line 476 
static i40e_status i40e_nvmupd_nvm_erase(struct i40e_hw *hw, struct i40e_nvm_access *cmd, int *errno);


#line 479 
static i40e_status i40e_nvmupd_nvm_write(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno);


#line 482 
static i40e_status i40e_nvmupd_nvm_read(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno);


#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
__inline static u8 i40e_nvmupd_get_module(u32 val)
{
  u8 __retres;
  
#line 487 
  __retres = (unsigned char)val;
  
#line 487 
  return __retres;
}


#line 489  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
__inline static u8 i40e_nvmupd_get_transaction(u32 val)
{
  u8 __retres;
  
#line 491 
  __retres = (unsigned char)((unsigned int)((unsigned char)(val >> 8)) & 15U);
  
#line 491 
  return __retres;
}


#line 494  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static char *i40e_nvm_update_state_str[13U] = {(char *)"I40E_NVMUPD_INVALID", (char *)"I40E_NVMUPD_READ_CON", (char *)"I40E_NVMUPD_READ_SNT", (char *)"I40E_NVMUPD_READ_LCB", (char *)"I40E_NVMUPD_READ_SA", (char *)"I40E_NVMUPD_WRITE_ERA", (char *)"I40E_NVMUPD_WRITE_CON", (char *)"I40E_NVMUPD_WRITE_SNT", (char *)"I40E_NVMUPD_WRITE_LCB", (char *)"I40E_NVMUPD_WRITE_SA", (char *)"I40E_NVMUPD_CSUM_CON", (char *)"I40E_NVMUPD_CSUM_SA", (char *)"I40E_NVMUPD_CSUM_LCB"};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_nvmupd_command(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno)
{
  i40e_status status;
  
#line 526 
  *errno = 0;
  
#line 528 
  switch ((unsigned int)hw->nvmupd_state) {
    case (unsigned int)0: 
#line 529 
    ;
    
#line 530 
    status = i40e_nvmupd_state_init(hw,cmd,bytes,errno);
    
#line 531 
    goto ldv_53064;
    case (unsigned int)1: 
#line 533 
    ;
    
#line 534 
    status = i40e_nvmupd_state_reading(hw,cmd,bytes,errno);
    
#line 535 
    goto ldv_53064;
    case (unsigned int)2: 
#line 537 
    ;
    
#line 538 
    status = i40e_nvmupd_state_writing(hw,cmd,bytes,errno);
    
#line 539 
    goto ldv_53064;
    default: 
#line 541 
    ;
    
#line 543 
    if ((hw->debug_mask & 128U) != 0U) 
#line 543 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(unsigned int)hw->nvmupd_state); else ;
    
#line 545 
    status = I40E_NOT_SUPPORTED;
    
#line 546 
    *errno = -3;
    
#line 547 
    goto ldv_53064;
  }
  ldv_53064: 
#line 549 
  ;
  
#line 549 
  return status;
}


#line 562  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_state_init(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno)
{
  enum i40e_nvmupd_cmd upd_cmd;
  
#line 566 
  i40e_status status = 0;
  
#line 569 
  upd_cmd = i40e_nvmupd_validate_command(hw,cmd,errno);
  
#line 571 
  switch ((unsigned int)upd_cmd) {
    case (unsigned int)4: 
#line 572 
    ;
    
#line 573 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
    
#line 574 
    if (status != I40E_SUCCESS) 
#line 575 
                                *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
    else {
      
#line 578 
      status = i40e_nvmupd_nvm_read(hw,cmd,bytes,errno);
      
#line 579 
      i40e_release_nvm(hw);
    }
    
#line 581 
    goto ldv_53077;
    case (unsigned int)2: 
#line 583 
    ;
    
#line 584 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
    
#line 585 
    if (status != I40E_SUCCESS) 
#line 586 
                                *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
    else {
      
#line 589 
      status = i40e_nvmupd_nvm_read(hw,cmd,bytes,errno);
      
#line 590 
      if (status != I40E_SUCCESS) 
#line 591 
                                  i40e_release_nvm(hw); else 
#line 593 
                                                             hw->nvmupd_state = I40E_NVMUPD_STATE_READING;
    }
    
#line 595 
    goto ldv_53077;
    case (unsigned int)5: 
#line 597 
    ;
    
#line 598 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
    
#line 599 
    if (status != I40E_SUCCESS) 
#line 600 
                                *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
    else {
      
#line 603 
      status = i40e_nvmupd_nvm_erase(hw,cmd,errno);
      
#line 604 
      if (status != I40E_SUCCESS) 
#line 605 
                                  i40e_release_nvm(hw); else 
#line 607 
                                                             hw->aq.nvm_release_on_done = (_Bool)1;
    }
    
#line 609 
    goto ldv_53077;
    case (unsigned int)9: 
#line 611 
    ;
    
#line 612 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
    
#line 613 
    if (status != I40E_SUCCESS) 
#line 614 
                                *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
    else {
      
#line 617 
      status = i40e_nvmupd_nvm_write(hw,cmd,bytes,errno);
      
#line 618 
      if (status != I40E_SUCCESS) 
#line 619 
                                  i40e_release_nvm(hw); else 
#line 621 
                                                             hw->aq.nvm_release_on_done = (_Bool)1;
    }
    
#line 623 
    goto ldv_53077;
    case (unsigned int)7: 
#line 625 
    ;
    
#line 626 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
    
#line 627 
    if (status != I40E_SUCCESS) 
#line 628 
                                *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
    else {
      
#line 631 
      status = i40e_nvmupd_nvm_write(hw,cmd,bytes,errno);
      
#line 632 
      if (status != I40E_SUCCESS) 
#line 633 
                                  i40e_release_nvm(hw); else 
#line 635 
                                                             hw->nvmupd_state = I40E_NVMUPD_STATE_WRITING;
    }
    
#line 637 
    goto ldv_53077;
    case (unsigned int)11: 
#line 639 
    ;
    
#line 640 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
    
#line 641 
    if (status != I40E_SUCCESS) 
#line 642 
                                *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
    else {
      
#line 645 
      status = i40e_update_nvm_checksum(hw);
      
#line 646 
      if (status != I40E_SUCCESS) {
        
#line 647 
        if (hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) 
#line 647 
                                                                   *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status))); else 
                                                                    
#line 647 
                                                                    *errno = -5;
        
#line 651 
        i40e_release_nvm(hw);
      }
      else 
#line 653 
           hw->aq.nvm_release_on_done = (_Bool)1;
    }
    
#line 656 
    goto ldv_53077;
    default: 
#line 658 
    ;
    
#line 659 
    if ((hw->debug_mask & 128U) != 0U) 
#line 659 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,i40e_nvm_update_state_str[(unsigned int)upd_cmd]); else ;
    
#line 662 
    status = I40E_ERR_NVM;
    
#line 663 
    *errno = -3;
    
#line 664 
    goto ldv_53077;
  }
  ldv_53077: 
#line 666 
  ;
  
#line 666 
  return status;
}


#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_state_reading(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno)
{
  i40e_status status;
  enum i40e_nvmupd_cmd upd_cmd;
  
#line 686 
  upd_cmd = i40e_nvmupd_validate_command(hw,cmd,errno);
  
#line 688 
  switch ((unsigned int)upd_cmd) {
    case (unsigned int)4: 
#line 689 
    ;
    case (unsigned int)1: 
#line 690 
    ;
    
#line 691 
    status = i40e_nvmupd_nvm_read(hw,cmd,bytes,errno);
    
#line 692 
    goto ldv_53094;
    case (unsigned int)3: 
#line 694 
    ;
    
#line 695 
    status = i40e_nvmupd_nvm_read(hw,cmd,bytes,errno);
    
#line 696 
    i40e_release_nvm(hw);
    
#line 697 
    hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    
#line 698 
    goto ldv_53094;
    default: 
#line 700 
    ;
    
#line 701 
    if ((hw->debug_mask & 128U) != 0U) 
#line 701 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,i40e_nvm_update_state_str[(unsigned int)upd_cmd]); else ;
    
#line 704 
    status = I40E_NOT_SUPPORTED;
    
#line 705 
    *errno = -3;
    
#line 706 
    goto ldv_53094;
  }
  ldv_53094: 
#line 708 
  ;
  
#line 708 
  return status;
}


#line 721  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_state_writing(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno)
{
  i40e_status status;
  enum i40e_nvmupd_cmd upd_cmd;
  
#line 727 
  bool retry_attempt = (_Bool)0;
  
#line 729 
  upd_cmd = i40e_nvmupd_validate_command(hw,cmd,errno);
  retry: 
#line 731 
  ;
  
#line 732 
  switch ((unsigned int)upd_cmd) {
    case (unsigned int)6: 
#line 733 
    ;
    
#line 734 
    status = i40e_nvmupd_nvm_write(hw,cmd,bytes,errno);
    
#line 735 
    goto ldv_53108;
    case (unsigned int)8: 
#line 737 
    ;
    
#line 738 
    status = i40e_nvmupd_nvm_write(hw,cmd,bytes,errno);
    
#line 739 
    if (status == I40E_SUCCESS) 
#line 740 
                                hw->aq.nvm_release_on_done = (_Bool)1; else ;
    
#line 741 
    hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    
#line 742 
    goto ldv_53108;
    case (unsigned int)10: 
#line 744 
    ;
    
#line 745 
    status = i40e_update_nvm_checksum(hw);
    
#line 746 
    if (status != I40E_SUCCESS) {
      
#line 747 
      if (hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) 
#line 747 
                                                                 *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status))); else 
                                                                    
#line 747 
                                                                    *errno = -5;
      
#line 751 
      hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    }
    else ;
    
#line 753 
    goto ldv_53108;
    case (unsigned int)12: 
#line 755 
    ;
    
#line 756 
    status = i40e_update_nvm_checksum(hw);
    
#line 757 
    if (status != I40E_SUCCESS) 
      
#line 758 
      if (hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) 
#line 758 
                                                                 *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status))); else 
                                                                    
#line 758 
                                                                    *errno = -5;
    else 
#line 763 
         hw->aq.nvm_release_on_done = (_Bool)1;
    
#line 764 
    hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    
#line 765 
    goto ldv_53108;
    default: 
#line 767 
    ;
    
#line 768 
    if ((hw->debug_mask & 128U) != 0U) 
#line 768 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,i40e_nvm_update_state_str[(unsigned int)upd_cmd]); else ;
    
#line 771 
    status = I40E_NOT_SUPPORTED;
    
#line 772 
    *errno = -3;
    
#line 773 
    goto ldv_53108;
  }
  ldv_53108: 
#line 782 
  ;
  
#line 782 
  if ((status != I40E_SUCCESS && hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EBUSY) && ! retry_attempt) {
    u32 gtime;
    
#line 784 
    i40e_status old_status = status;
    
#line 785 
    u32 old_asq_status = hw->aq.asq_last_status;
    
#line 788 
    gtime = readl((void const volatile *)(hw->hw_addr + 557500U));
    
#line 789 
    if ((unsigned long long)gtime >= hw->nvm.hw_semaphore_timeout) {
      
#line 790 
      if (hw->debug_mask != 0U) 
#line 790 
                                printk("\001",(int)hw->bus.device,(int)hw->bus.func,gtime,hw->nvm.hw_semaphore_timeout); else ;
      
#line 793 
      i40e_release_nvm(hw);
      
#line 794 
      status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
      
#line 795 
      if (status != I40E_SUCCESS) {
        
#line 796 
        if (hw->debug_mask != 0U) 
#line 796 
                                  printk("\001",(int)hw->bus.device,(int)hw->bus.func,(unsigned int)hw->aq.asq_last_status); else ;
        
#line 799 
        status = old_status;
        
#line 800 
        hw->aq.asq_last_status = (enum i40e_admin_queue_err)old_asq_status;
      }
      else {
        
#line 802 
        retry_attempt = (_Bool)1;
        
#line 803 
        goto retry;
      }
    }
    else ;
  }
  else ;
  
#line 808 
  return status;
}


#line 819  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw, struct i40e_nvm_access *cmd, int *errno)
{
  enum i40e_nvmupd_cmd __retres;
  enum i40e_nvmupd_cmd upd_cmd;
  u8 transaction;
  
#line 827 
  upd_cmd = I40E_NVMUPD_INVALID;
  
#line 829 
  transaction = i40e_nvmupd_get_transaction(cmd->config);
  
#line 832 
  if (cmd->data_size + 4294967295U > 4095U) {
    
#line 834 
    if ((hw->debug_mask & 128U) != 0U) 
#line 834 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,cmd->data_size); else ;
    
#line 837 
    *errno = -14;
    
#line 838 
    __retres = I40E_NVMUPD_INVALID;
    
#line 838 
    goto return_label;
  }
  else ;
  
#line 841 
  switch (cmd->command) {
    case (u32)11: 
#line 842 
    ;
    
#line 843 
    switch ((int)transaction) {
      case 0: 
#line 844 
      ;
      
#line 845 
      upd_cmd = I40E_NVMUPD_READ_CON;
      
#line 846 
      goto ldv_53125;
      case 1: 
#line 847 
      ;
      
#line 848 
      upd_cmd = I40E_NVMUPD_READ_SNT;
      
#line 849 
      goto ldv_53125;
      case 2: 
#line 850 
      ;
      
#line 851 
      upd_cmd = I40E_NVMUPD_READ_LCB;
      
#line 852 
      goto ldv_53125;
      case 3: 
#line 853 
      ;
      
#line 854 
      upd_cmd = I40E_NVMUPD_READ_SA;
      
#line 855 
      goto ldv_53125;
    }
    ldv_53125: 
#line 857 
    ;
    
#line 857 
    goto ldv_53129;
    case (u32)12: 
#line 859 
    ;
    
#line 860 
    switch ((int)transaction) {
      case 0: 
#line 861 
      ;
      
#line 862 
      upd_cmd = I40E_NVMUPD_WRITE_CON;
      
#line 863 
      goto ldv_53132;
      case 1: 
#line 864 
      ;
      
#line 865 
      upd_cmd = I40E_NVMUPD_WRITE_SNT;
      
#line 866 
      goto ldv_53132;
      case 2: 
#line 867 
      ;
      
#line 868 
      upd_cmd = I40E_NVMUPD_WRITE_LCB;
      
#line 869 
      goto ldv_53132;
      case 3: 
#line 870 
      ;
      
#line 871 
      upd_cmd = I40E_NVMUPD_WRITE_SA;
      
#line 872 
      goto ldv_53132;
      case 4: 
#line 873 
      ;
      
#line 874 
      upd_cmd = I40E_NVMUPD_WRITE_ERA;
      
#line 875 
      goto ldv_53132;
      case 8: 
#line 876 
      ;
      
#line 877 
      upd_cmd = I40E_NVMUPD_CSUM_CON;
      
#line 878 
      goto ldv_53132;
      case 11: 
#line 879 
      ;
      
#line 880 
      upd_cmd = I40E_NVMUPD_CSUM_SA;
      
#line 881 
      goto ldv_53132;
      case 10: 
#line 882 
      ;
      
#line 883 
      upd_cmd = I40E_NVMUPD_CSUM_LCB;
      
#line 884 
      goto ldv_53132;
    }
    ldv_53132: 
#line 886 
    ;
    
#line 886 
    goto ldv_53129;
  }
  ldv_53129: 
#line 888 
  ;
  
#line 888 
  if ((hw->debug_mask & 128U) != 0U) 
#line 888 
                                     printk("\001",(int)hw->bus.device,(int)hw->bus.func,i40e_nvm_update_state_str[(unsigned int)upd_cmd],(unsigned int)hw->nvmupd_state,(int)hw->aq.nvm_release_on_done); else ;
  
#line 893 
  if (upd_cmd == (unsigned int)I40E_NVMUPD_INVALID) {
    
#line 894 
    *errno = -14;
    
#line 895 
    if ((hw->debug_mask & 128U) != 0U) 
#line 895 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(unsigned int)upd_cmd,*errno); else ;
  }
  else ;
  
#line 899 
  __retres = upd_cmd;
  return_label: 
#line 899 
                return __retres;
}


#line 911  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_nvm_read(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno)
{
  i40e_status status;
  u8 module;
  u8 transaction;
  bool last;
  
#line 919 
  transaction = i40e_nvmupd_get_transaction(cmd->config);
  
#line 920 
  module = i40e_nvmupd_get_module(cmd->config);
  
#line 921 
  last = (_Bool)((unsigned int)transaction + 254U <= 1U);
  
#line 923 
  status = i40e_aq_read_nvm(hw,(unsigned char)((int)module),cmd->offset,(unsigned short)((int)((unsigned short)cmd->data_size)),(void *)bytes,(_Bool)((bool)((int)last) != 0),(struct i40e_asq_cmd_details *)0);
  
#line 925 
  if (status != I40E_SUCCESS) {
    
#line 926 
    if ((hw->debug_mask & 128U) != 0U) 
#line 926 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)module,cmd->offset,cmd->data_size); else ;
    
#line 929 
    if ((hw->debug_mask & 128U) != 0U) 
#line 929 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)status,(unsigned int)hw->aq.asq_last_status); else ;
    
#line 932 
    *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
  }
  else ;
  
#line 935 
  return status;
}


#line 946  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_nvm_erase(struct i40e_hw *hw, struct i40e_nvm_access *cmd, int *errno)
{
  u8 module;
  u8 transaction;
  bool last;
  
#line 950 
  i40e_status status = 0;
  
#line 954 
  transaction = i40e_nvmupd_get_transaction(cmd->config);
  
#line 955 
  module = i40e_nvmupd_get_module(cmd->config);
  
#line 956 
  last = (_Bool)(((int)transaction & 2) != 0);
  
#line 957 
  status = i40e_aq_erase_nvm(hw,(unsigned char)((int)module),cmd->offset,(unsigned short)((int)((unsigned short)cmd->data_size)),(_Bool)((bool)((int)last) != 0),(struct i40e_asq_cmd_details *)0);
  
#line 959 
  if (status != I40E_SUCCESS) {
    
#line 960 
    if ((hw->debug_mask & 128U) != 0U) 
#line 960 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)module,cmd->offset,cmd->data_size); else ;
    
#line 963 
    if ((hw->debug_mask & 128U) != 0U) 
#line 963 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)status,(unsigned int)hw->aq.asq_last_status); else ;
    
#line 966 
    *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
  }
  else ;
  
#line 969 
  return status;
}


#line 981  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_nvm_write(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *errno)
{
  u8 module;
  u8 transaction;
  bool last;
  
#line 985 
  i40e_status status = 0;
  
#line 989 
  transaction = i40e_nvmupd_get_transaction(cmd->config);
  
#line 990 
  module = i40e_nvmupd_get_module(cmd->config);
  
#line 991 
  last = (_Bool)(((int)transaction & 2) != 0);
  
#line 993 
  status = i40e_aq_update_nvm(hw,(unsigned char)((int)module),cmd->offset,(unsigned short)((int)((unsigned short)cmd->data_size)),(void *)bytes,(_Bool)((bool)((int)last) != 0),(struct i40e_asq_cmd_details *)0);
  
#line 995 
  if (status != I40E_SUCCESS) {
    
#line 996 
    if ((hw->debug_mask & 128U) != 0U) 
#line 996 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)module,cmd->offset,cmd->data_size); else ;
    
#line 999 
    if ((hw->debug_mask & 128U) != 0U) 
#line 999 
                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)status,(unsigned int)hw->aq.asq_last_status); else ;
    
#line 1002 
    *errno = i40e_aq_rc_to_posix((unsigned int)status,(unsigned short)((int)((unsigned short)hw->aq.asq_last_status)));
  }
  else ;
  
#line 1005 
  return status;
}


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_diag.c"
static i40e_status i40e_diag_reg_pattern_test(struct i40e_hw *hw, u32 reg, u32 mask)
{
  i40e_status __retres;
  u32 pat;
  u32 val;
  u32 orig_val;
  int i;
  
#line 39 
  u32 const patterns[4U] = {1515870810U, 2779096485U, 0U, 4294967295U};
  
#line 43 
  orig_val = readl((void const volatile *)(hw->hw_addr + reg));
  
#line 44 
  i = 0;
  
#line 44 
  goto ldv_52944;
  ldv_52943: 
#line 45 
  ;
  
#line 45 
  pat = patterns[i];
  
#line 46 
  writel(pat & mask,(void volatile *)(hw->hw_addr + reg));
  
#line 47 
  val = readl((void const volatile *)(hw->hw_addr + reg));
  
#line 48 
  if (((val ^ pat) & mask) != 0U) {
    
#line 49 
    if ((hw->debug_mask & 2048U) != 0U) 
#line 49 
                                        printk("\001",(int)hw->bus.device,(int)hw->bus.func,"i40e_diag_reg_pattern_test",reg,pat,val); else ;
    
#line 52 
    __retres = I40E_ERR_DIAG_TEST_FAILED;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 44 
  i += 1;
  ldv_52944: 
#line 45 
  ;
  
#line 44 
  if ((unsigned int)i <= 3U) 
#line 46 
                             goto ldv_52943; else 
#line 49 
                                                  goto ldv_52945;
  ldv_52945: 
#line 50 
  ;
  
#line 56 
  writel(orig_val,(void volatile *)(hw->hw_addr + reg));
  
#line 57 
  val = readl((void const volatile *)(hw->hw_addr + reg));
  
#line 58 
  if (val != orig_val) {
    
#line 59 
    if ((hw->debug_mask & 2048U) != 0U) 
#line 59 
                                        printk("\001",(int)hw->bus.device,(int)hw->bus.func,"i40e_diag_reg_pattern_test",reg,orig_val,val); else ;
    
#line 62 
    __retres = I40E_ERR_DIAG_TEST_FAILED;
    
#line 62 
    goto return_label;
  }
  else ;
  
#line 65 
  __retres = I40E_SUCCESS;
  return_label: 
#line 65 
                return __retres;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_diag.c"
struct i40e_diag_reg_test_info i40e_reg_list[12U] = {{.offset = 1064960U, .mask = 65471U, .elements = 1U, .stride = 4U}, {.offset = 229376U, .mask = 4095U, .elements = 3U, .stride = 128U}, {.offset = 196608U, .mask = 4095U, .elements = 1U, .stride = 4U}, {.offset = 198656U, .mask = 4095U, .elements = 1U, .stride = 4U}, {.offset = 200704U, .mask = 4095U, .elements = 1U, .stride = 4U}, {.offset = 230400U, .mask = 12U, .elements = 1U, .stride = 0U}, {.offset = 230656U, .mask = 8191U, .elements = 1U, .stride = 0U}, {.offset = 217088U, .mask = 2047U, .elements = 1U, .stride = 4U}, {.offset = 245760U, .mask = 255U, .elements = 1U, .stride = 4U}, {.offset = 237568U, .mask = 255U, .elements = 1U, .stride = 4U}, {.offset = 231424U, .mask = 4159832064U, .elements = 1U, .stride = 0U}, {.offset = 0U, .mask = 0U, .elements = 0U, .stride = 0U}};

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_diag.c"
i40e_status i40e_diag_reg_test(struct i40e_hw *hw)
{
  u32 reg;
  u32 mask;
  u32 i;
  u32 j;
  
#line 100 
  i40e_status ret_code = 0;
  
#line 104 
  i = 0U;
  
#line 104 
  goto ldv_52959;
  ldv_52958: 
#line 105 
  ;
  
#line 108 
  if (i40e_reg_list[i].offset == 1064960U && hw->func_caps.num_tx_qp != 0U) 
    
#line 110 
    i40e_reg_list[i].elements = hw->func_caps.num_tx_qp; else ;
  
#line 111 
  if (((((i40e_reg_list[i].offset == 196608U || i40e_reg_list[i].offset == 198656U) || i40e_reg_list[i].offset == 200704U) || i40e_reg_list[i].offset == 245760U) || i40e_reg_list[i].offset == 237568U) && hw->func_caps.num_msix_vectors != 0U) 
    
#line 117 
    i40e_reg_list[i].elements = hw->func_caps.num_msix_vectors + 4294967295U; else ;
  
#line 121 
  mask = i40e_reg_list[i].mask;
  
#line 122 
  j = 0U;
  
#line 122 
  goto ldv_52956;
  ldv_52955: 
#line 123 
  ;
  
#line 123 
  reg = i40e_reg_list[i].offset + i40e_reg_list[i].stride * j;
  
#line 125 
  ret_code = i40e_diag_reg_pattern_test(hw,reg,mask);
  
#line 122 
  j += 1U;
  ldv_52956: 
#line 123 
  ;
  
#line 122 
  if (i40e_reg_list[i].elements > j && ret_code == I40E_SUCCESS) 
#line 124 
                                                                 goto ldv_52955; else 
                                                                    
#line 127 
                                                                    goto ldv_52957;
  ldv_52957: 
#line 128 
  ;
  
#line 105 
  i += 1U;
  ldv_52959: 
#line 106 
  ;
  
#line 104 
  if (i40e_reg_list[i].offset != 0U && ret_code == I40E_SUCCESS) 
#line 107 
                                                                 goto ldv_52958; else 
                                                                    
#line 110 
                                                                    goto ldv_52960;
  ldv_52960: 
#line 111 
  ;
  
#line 129 
  return ret_code;
}


#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_diag.c"
i40e_status i40e_diag_eeprom_test(struct i40e_hw *hw)
{
  i40e_status ret_code;
  u16 reg_val;
  
#line 144 
  ret_code = i40e_read_nvm_word(hw,(unsigned short)0,& reg_val);
  
#line 145 
  if (ret_code == I40E_SUCCESS && ((int)reg_val & 192) == 64) 
#line 148 
                                                              ret_code = i40e_validate_nvm_checksum(hw,(u16 *)0U); else 
                                                                    
#line 150 
                                                                    ret_code = I40E_ERR_DIAG_TEST_FAILED;
  
#line 153 
  return ret_code;
}


#line 9  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
int ldv_atomic_dec_and_test(atomic_t *v);


#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8192U];


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
extern struct cpumask const * const cpu_possible_mask;


#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n, struct cpumask const *srcp)
{
  unsigned int __retres;
  unsigned long tmp;
  
#line 187 
  if (n != -1) 
#line 188 
               cpumask_check((unsigned int)n); else ;
  
#line 189 
  tmp = find_next_bit((unsigned long const *)(& srcp->bits),(unsigned long)nr_cpu_ids,(unsigned long)(n + 1));
  
#line 189 
  __retres = (unsigned int)tmp;
  
#line 189 
  return __retres;
}


#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
static void atomic_inc_0(atomic_t *v);


#line 120 
static int atomic_dec_and_test(atomic_t *v);


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu.h"
void *__alloc_percpu(size_t, size_t);


#line 128 
void free_percpu(void *);


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg)
{
  struct page *__retres;
  
#line 123 
  if ((long)(sg->sg_magic != 2271560481UL) != 0L) {
    
#line 125 
    ldv_inline_asm();
    
#line 123 
    ;
  }
  else ;
  
#line 124 
  if ((long)((sg->page_link & 1UL) != 0UL) != 0L) {
    
#line 126 
    ldv_inline_asm();
    
#line 124 
    ;
  }
  else ;
  
#line 126 
  __retres = (struct page *)(sg->page_link & 18446744073709551612UL);
  
#line 126 
  return __retres;
}


#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg)
{
  void *__retres;
  void *tmp_0;
  struct page *tmp;
  
#line 245 
  tmp = sg_page(sg);
  
#line 245 
  tmp_0 = lowmem_page_address((struct page const *)tmp);
  
#line 245 
  ;
  
#line 245 
  __retres = tmp_0 + sg->offset;
  
#line 245 
  return __retres;
}


#line 250 
struct scatterlist *sg_next(struct scatterlist *);


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_sg(struct device *, struct scatterlist *, int, int, int);


#line 50 
void debug_dma_unmap_sg(struct device *, struct scatterlist *, int, int);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg, int nents, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int i;
  int ents;
  struct scatterlist *s;
  void *tmp_0;
  int tmp_1;
  
#line 50 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 54 
  i = 0;
  
#line 54 
  s = sg;
  
#line 54 
  goto ldv_25468;
  ldv_25467: 
#line 55 
  ;
  
#line 55 
  ;
  
#line 55 
  tmp_0 = sg_virt(s);
  
#line 55 
  kmemcheck_mark_initialized(tmp_0,s->length);
  
#line 54 
  i += 1;
  
#line 54 
  s = sg_next(s);
  ldv_25468: 
#line 55 
  ;
  
#line 54 
  if (i < nents) 
#line 56 
                 goto ldv_25467; else 
#line 59 
                                      goto ldv_25469;
  ldv_25469: 
#line 60 
  ;
  
#line 56 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 56 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 58 
    ldv_inline_asm();
    
#line 56 
    ;
  }
  else ;
  
#line 57 
  ents = (*(ops->map_sg))(dev,sg,nents,dir,attrs);
  
#line 58 
  if ((long)(ents < 0) != 0L) {
    
#line 60 
    ldv_inline_asm();
    
#line 58 
    ;
  }
  else ;
  
#line 59 
  debug_dma_map_sg(dev,sg,nents,ents,(int)dir);
  
#line 61 
  return ents;
}


#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg, int nents, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 68 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 70 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 70 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 72 
    ldv_inline_asm();
    
#line 70 
    ;
  }
  else ;
  
#line 71 
  debug_dma_unmap_sg(dev,sg,nents,(int)dir);
  
#line 72 
  if (ops->unmap_sg != (void (*)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 73 
    (*(ops->unmap_sg))(dev,sg,nents,dir,attrs); else ;
  
#line 74 
  return;
}


#line 1655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb)
{
  
#line 1657 
  skb->tail = (unsigned int)((long)skb->data - (long)skb->head);
  
#line 1658 
  return;
}


#line 1660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb, int const offset)
{
  
#line 1662 
  skb_reset_tail_pointer(skb);
  
#line 1663 
  skb->tail += (unsigned int)offset;
  
#line 1664 
  return;
}


#line 1885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reset_transport_header(struct sk_buff *skb)
{
  
#line 1887 
  skb->transport_header = (unsigned short)((long)skb->data - (long)skb->head);
  
#line 1888 
  return;
}


#line 1890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_transport_header(struct sk_buff *skb, int const offset)
{
  
#line 1893 
  skb_reset_transport_header(skb);
  
#line 1894 
  skb->transport_header = (unsigned short)((int)skb->transport_header + (int)((unsigned short)offset));
  
#line 1895 
  return;
}


#line 1902  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reset_network_header(struct sk_buff *skb)
{
  
#line 1904 
  skb->network_header = (unsigned short)((long)skb->data - (long)skb->head);
  
#line 1905 
  return;
}


#line 1907  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_network_header(struct sk_buff *skb, int const offset)
{
  
#line 1909 
  skb_reset_network_header(skb);
  
#line 1910 
  skb->network_header = (unsigned short)((int)skb->network_header + (int)((unsigned short)offset));
  
#line 1911 
  return;
}


#line 1913  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1915 
  __retres = skb->head + (int)skb->mac_header;
  
#line 1915 
  return __retres;
}


#line 1923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reset_mac_header(struct sk_buff *skb)
{
  
#line 1925 
  skb->mac_header = (unsigned short)((long)skb->data - (long)skb->head);
  
#line 1926 
  return;
}


#line 2045 
int ___pskb_trim(struct sk_buff *, unsigned int);


#line 2047  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_trim(struct sk_buff *skb, unsigned int len)
{
  bool tmp_0;
  
#line 2049 
  tmp_0 = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 2049 
  if ((long)((int)tmp_0 != 0) != 0L) {
    {
      
#line 2050 
      int __ret_warn_on = 1;
      
#line 2050 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 2050 
                                            warn_slowpath_null("include/linux/skbuff.h",2050); else ;
      
#line 2050 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 2051 
    goto return_label;
  }
  else ;
  
#line 2053 
  skb->len = len;
  
#line 2054 
  skb_set_tail_pointer(skb,(int)len);
  return_label: 
#line 2055 
                return;
}


#line 2059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int __pskb_trim(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  
#line 2061 
  if (skb->data_len != 0U) {
    int tmp;
    
#line 2062 
    tmp = ___pskb_trim(skb,len);
    
#line 2062 
    __retres = tmp;
    
#line 2062 
    goto return_label;
  }
  else ;
  
#line 2063 
  __skb_trim(skb,len);
  
#line 2064 
  __retres = 0;
  return_label: 
#line 2064 
                return __retres;
}


#line 2067  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int pskb_trim(struct sk_buff *skb, unsigned int len)
{
  int tmp_0;
  
#line 2069 
  if (skb->len > len) 
#line 2069 
                      tmp_0 = __pskb_trim(skb,len); else 
#line 2069 
                                                         tmp_0 = 0;
  
#line 2069 
  return tmp_0;
}


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_ether.h"
__inline static struct ethhdr *eth_hdr(struct sk_buff const *skb)
{
  struct ethhdr *tmp;
  
#line 28 
  tmp = (struct ethhdr *)skb_mac_header(skb);
  
#line 28 
  return tmp;
}


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/scsi/fc_frame.h"
__inline static u32 ntoh24(u8 const *p)
{
  u32 __retres;
  
#line 40 
  __retres = (unsigned int)((((int)*p << 16) | ((int)*(p + 1U) << 8)) | (int)*(p + 2U));
  
#line 40 
  return __retres;
}


#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmapool.h"
struct dma_pool *dma_pool_create(char const *, struct device *, size_t, size_t, size_t);


#line 22 
void dma_pool_destroy(struct dma_pool *);


#line 24 
void *dma_pool_alloc(struct dma_pool *, gfp_t, dma_addr_t *);


#line 27 
void dma_pool_free(struct dma_pool *, void *, dma_addr_t);


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static bool i40e_rx_is_fcoe(u16 ptype)
{
  bool __retres;
  
#line 46 
  __retres = (_Bool)((unsigned int)ptype + 65524U <= 9U);
  
#line 46 
  return __retres;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static bool i40e_fcoe_sof_is_class2(u8 sof)
{
  bool __retres;
  
#line 56 
  __retres = (_Bool)(((unsigned int)sof == 45U || (unsigned int)sof == 53U) != 0);
  
#line 56 
  return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static bool i40e_fcoe_sof_is_class3(u8 sof)
{
  bool __retres;
  
#line 65 
  __retres = (_Bool)(((unsigned int)sof == 46U || (unsigned int)sof == 54U) != 0);
  
#line 65 
  return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static bool i40e_fcoe_sof_is_supported(u8 sof)
{
  bool __retres;
  int tmp_1;
  bool tmp;
  
#line 74 
  tmp = i40e_fcoe_sof_is_class2((unsigned char)((int)sof));
  
#line 74 
  if ((int)tmp != 0) 
#line 74 
                     tmp_1 = 1;
  else {
    bool tmp_0;
    
#line 74 
    tmp_0 = i40e_fcoe_sof_is_class3((unsigned char)((int)sof));
    
#line 74 
    if ((int)tmp_0 != 0) 
#line 74 
                         tmp_1 = 1; else 
#line 74 
                                         tmp_1 = 0;
  }
  
#line 74 
  __retres = (_Bool)(tmp_1 != 0);
  
#line 74 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static int i40e_fcoe_fc_sof(struct sk_buff *skb, u8 *sof)
{
  int __retres;
  unsigned char *tmp;
  int tmp_1;
  bool tmp_0;
  
#line 84 
  tmp = skb_network_header((struct sk_buff const *)skb);
  
#line 84 
  *sof = ((struct fcoe_hdr *)tmp)->fcoe_sof;
  
#line 86 
  tmp_0 = i40e_fcoe_sof_is_supported((unsigned char)((int)*sof));
  
#line 86 
  if (tmp_0) 
#line 86 
             tmp_1 = 0; else 
#line 86 
                             tmp_1 = 1;
  
#line 86 
  if (tmp_1) {
    
#line 87 
    __retres = -22;
    
#line 87 
    goto return_label;
  }
  else ;
  
#line 88 
  __retres = 0;
  return_label: 
#line 88 
                return __retres;
}


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static bool i40e_fcoe_eof_is_supported(u8 eof)
{
  bool __retres;
  
#line 98 
  __retres = (_Bool)((((unsigned int)eof + 191U <= 1U || (unsigned int)eof == 73U) || (unsigned int)eof == 80U) != 0);
  
#line 98 
  return __retres;
}


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static int i40e_fcoe_fc_eof(struct sk_buff *skb, u8 *eof)
{
  int __retres;
  int tmp_0;
  bool tmp;
  
#line 108 
  skb_copy_bits((struct sk_buff const *)skb,(int)(skb->len + 4294967292U),(void *)eof,1);
  
#line 110 
  tmp = i40e_fcoe_eof_is_supported((unsigned char)((int)*eof));
  
#line 110 
  if (tmp) 
#line 110 
           tmp_0 = 0; else 
#line 110 
                           tmp_0 = 1;
  
#line 110 
  if (tmp_0) {
    
#line 111 
    __retres = -22;
    
#line 111 
    goto return_label;
  }
  else ;
  
#line 112 
  __retres = 0;
  return_label: 
#line 112 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static u32 i40e_fcoe_ctxt_eof(u8 eof)
{
  u32 __retres;
  
#line 125 
  switch ((int)eof) {
    case 65: 
#line 126 
    ;
    
#line 127 
    __retres = 0U;
    
#line 127 
    goto return_label;
    case 66: 
#line 128 
    ;
    
#line 129 
    __retres = 256U;
    
#line 129 
    goto return_label;
    case 73: 
#line 130 
    ;
    
#line 131 
    __retres = 512U;
    
#line 131 
    goto return_label;
    case 80: 
#line 132 
    ;
    
#line 133 
    __retres = 768U;
    
#line 133 
    goto return_label;
    default: 
#line 134 
    ;
    {
      
#line 139 
      int __ret_warn_on = 1;
      
#line 139 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 139 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c",139); else ;
      
#line 139 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 140 
    __retres = 4294967274U;
    
#line 140 
    goto return_label;
  }
  return_label: 
#line 125 
                return __retres;
}


#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static bool i40e_fcoe_xid_is_valid(u16 xid)
{
  bool __retres;
  
#line 150 
  __retres = (_Bool)((unsigned int)xid <= 2047U);
  
#line 150 
  return __retres;
}


#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static void i40e_fcoe_ddp_unmap(struct i40e_pf *pf, struct i40e_fcoe_ddp *ddp)
{
  int tmp;
  
#line 166 
  tmp = test_and_set_bit(7L,(unsigned long volatile *)(& ddp->flags));
  
#line 166 
  if (tmp != 0) 
#line 167 
                goto return_label; else ;
  
#line 169 
  if (ddp->sgl != (struct scatterlist *)0) {
    
#line 170 
    dma_unmap_sg_attrs(& (pf->pdev)->dev,ddp->sgl,(int)ddp->sgc,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
    
#line 172 
    ddp->sgl = (struct scatterlist *)0;
    
#line 173 
    ddp->sgc = 0U;
  }
  else ;
  
#line 176 
  if (ddp->pool != (struct dma_pool *)0) {
    
#line 177 
    dma_pool_free(ddp->pool,(void *)ddp->udl,ddp->udp);
    
#line 178 
    ddp->pool = (struct dma_pool *)0;
  }
  else ;
  return_label: 
#line 180 
                return;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static void i40e_fcoe_ddp_clear(struct i40e_fcoe_ddp *ddp)
{
  
#line 188 
  memset((void *)ddp,0,64UL);
  
#line 189 
  ddp->xid = (unsigned short)65535U;
  
#line 190 
  ddp->flags = 1UL;
  
#line 191 
  return;
}


#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static bool i40e_fcoe_progid_is_fcoe(u8 id)
{
  bool __retres;
  
#line 199 
  __retres = (_Bool)(((unsigned int)id == 2U || (unsigned int)id == 4U) != 0);
  
#line 199 
  return __retres;
}


#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static u16 i40e_fcoe_fc_get_xid(struct fc_frame_header *fh)
{
  u16 __retres;
  int tmp_4;
  
#line 216 
  u32 f_ctl = ntoh24((u8 const *)(& fh->fh_f_ctl));
  
#line 219 
  if ((f_ctl & 8388608U) != 0U) {
    int tmp_1;
    
#line 218 
    if (0 != 0) 
#line 218 
                tmp_1 = (int)((unsigned short)(((int)fh->fh_ox_id << 8) | ((int)fh->fh_ox_id >> 8)));
    else {
      __u16 tmp_0;
      
#line 219 
      tmp_0 = __fswab16((unsigned short)((int)fh->fh_ox_id));
      
#line 218 
      tmp_1 = (int)tmp_0;
    }
    
#line 219 
    tmp_4 = tmp_1;
  }
  else {
    int tmp_3;
    
#line 219 
    if (0 != 0) 
#line 219 
                tmp_3 = (int)((unsigned short)(((int)fh->fh_rx_id << 8) | ((int)fh->fh_rx_id >> 8)));
    else {
      __u16 tmp_2;
      
#line 220 
      tmp_2 = __fswab16((unsigned short)((int)fh->fh_rx_id));
      
#line 219 
      tmp_3 = (int)tmp_2;
    }
    
#line 219 
    tmp_4 = tmp_3;
  }
  
#line 219 
  __retres = (unsigned short)tmp_4;
  
#line 219 
  return __retres;
}


#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static struct fc_frame_header *i40e_fcoe_fc_frame_header(struct sk_buff *skb)
{
  struct fc_frame_header *__retres;
  struct ethhdr *tmp;
  
#line 235 
  void *fh = (void *)(skb->data + 14U);
  
#line 237 
  tmp = eth_hdr((struct sk_buff const *)skb);
  
#line 237 
  ;
  
#line 237 
  if ((unsigned int)tmp->h_proto == 129U) 
#line 238 
                                          fh += 4U; else ;
  
#line 240 
  __retres = (struct fc_frame_header *)fh;
  
#line 240 
  return __retres;
}


#line 254  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static int i40e_fcoe_ddp_put(struct net_device *netdev, u16 xid)
{
  int tmp_0;
  
#line 256 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 257 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 258 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 259 
  int len = 0;
  
#line 260 
  struct i40e_fcoe_ddp *ddp = & fcoe->ddp[(int)xid];
  
#line 262 
  if (fcoe == (struct i40e_fcoe *)0 || ddp == (struct i40e_fcoe_ddp *)0) 
    
#line 263 
    goto out; else ;
  
#line 265 
  tmp_0 = constant_test_bit(5L,(unsigned long const volatile *)(& ddp->flags));
  
#line 265 
  if (tmp_0 != 0) 
#line 266 
                  len = ddp->len; else ;
  
#line 267 
  i40e_fcoe_ddp_unmap(pf,ddp);
  out: 
#line 268 
  ;
  
#line 269 
  return len;
}


#line 278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
int i40e_init_pf_fcoe(struct i40e_pf *pf)
{
  int __retres;
  u32 val;
  
#line 280 
  struct i40e_hw *hw = & pf->hw;
  
#line 283 
  pf->flags &= 18446744073709549567ULL;
  
#line 284 
  pf->num_fcoe_qps = (unsigned short)0U;
  
#line 285 
  pf->fcoe_hmc_cntx_num = 0U;
  
#line 286 
  pf->fcoe_hmc_filt_num = 0U;
  
#line 288 
  if (! pf->hw.func_caps.fcoe) {
    
#line 289 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"FCoE capability is disabled\n");
    
#line 290 
    __retres = 0;
    
#line 290 
    goto return_label;
  }
  else ;
  
#line 293 
  if (! pf->hw.func_caps.dcb) {
    
#line 294 
    dev_warn((struct device const *)(& (pf->pdev)->dev),"Hardware is not DCB capable not enabling FCoE.\n");
    
#line 296 
    __retres = 0;
    
#line 296 
    goto return_label;
  }
  else ;
  
#line 300 
  val = readl((void const volatile *)(hw->hw_addr + 2382208U));
  
#line 301 
  val |= 65536U;
  
#line 302 
  val |= 131072U;
  
#line 303 
  val = val;
  
#line 304 
  writel(val,(void volatile *)(hw->hw_addr + 2382208U));
  
#line 307 
  pf->flags |= 2048ULL;
  
#line 308 
  pf->num_fcoe_qps = (unsigned short)8U;
  
#line 311 
  pf->fcoe_hmc_cntx_num = 4096U;
  
#line 313 
  pf->fcoe_hmc_filt_num = pf->fcoe_hmc_cntx_num + 16384U;
  
#line 318 
  pf->filter_settings.fcoe_filt_num = I40E_HASH_FILTER_SIZE_16K;
  
#line 319 
  pf->filter_settings.fcoe_cntx_num = I40E_DMA_CNTX_SIZE_4K;
  
#line 322 
  val = readl((void const volatile *)(hw->hw_addr + 2530196U));
  
#line 323 
  val &= 3221291007U;
  
#line 324 
  val |= 142868480U;
  
#line 326 
  writel(val,(void volatile *)(hw->hw_addr + 2530196U));
  
#line 328 
  _dev_info((struct device const *)(& (pf->pdev)->dev),"FCoE is supported.\n");
  
#line 329 
  __retres = 0;
  return_label: 
#line 329 
                return __retres;
}


#line 337  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
u8 i40e_get_fcoe_tc_map(struct i40e_pf *pf)
{
  struct i40e_dcb_app_priority_table app;
  u8 tc;
  u8 i;
  
#line 340 
  struct i40e_hw *hw = & pf->hw;
  
#line 341 
  u8 enabled_tc = (unsigned char)0U;
  
#line 344 
  struct i40e_dcbx_config *dcbcfg = & hw->local_dcbx_config;
  
#line 346 
  i = (unsigned char)0U;
  
#line 346 
  goto ldv_68126;
  ldv_68125: 
#line 347 
  ;
  
#line 347 
  app = dcbcfg->app[(int)i];
  
#line 348 
  if ((unsigned int)app.selector == 1U && (unsigned int)app.protocolid == 35078U) {
    
#line 350 
    tc = dcbcfg->etscfg.prioritytable[(int)app.priority];
    
#line 351 
    enabled_tc = (unsigned char)((1 << (int)tc) | (int)enabled_tc);
    
#line 352 
    goto ldv_68124;
  }
  else ;
  
#line 346 
  i = (u8)((int)i + 1);
  ldv_68126: 
#line 347 
  ;
  
#line 346 
  if ((unsigned int)i < dcbcfg->numapps) 
#line 348 
                                         goto ldv_68125; else 
#line 351 
                                                              goto ldv_68124;
  ldv_68124: 
#line 352 
  ;
  
#line 357 
  if ((unsigned int)enabled_tc != 0U) 
#line 357 
                                      enabled_tc = enabled_tc; else 
#line 357 
                                                                    enabled_tc = (unsigned char)1U;
  
#line 359 
  return enabled_tc;
}


#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
int i40e_fcoe_vsi_init(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt)
{
  int __retres;
  int tmp;
  
#line 371 
  struct i40e_aqc_vsi_properties_data *info = & ctxt->info;
  
#line 372 
  struct i40e_pf *pf = vsi->back;
  
#line 373 
  struct i40e_hw *hw = & pf->hw;
  
#line 374 
  u8 enabled_tc = (unsigned char)0U;
  
#line 376 
  if ((pf->flags & 2048ULL) == 0ULL) {
    
#line 377 
    dev_err((struct device const *)(& (pf->pdev)->dev),"FCoE is not enabled for this device\n");
    
#line 379 
    __retres = -1;
    
#line 379 
    goto return_label;
  }
  else ;
  
#line 383 
  ctxt->pf_num = hw->pf_id;
  
#line 384 
  ctxt->vf_num = (unsigned char)0U;
  
#line 385 
  ctxt->uplink_seid = vsi->uplink_seid;
  
#line 386 
  ctxt->connection_type = (unsigned char)1U;
  
#line 387 
  ctxt->flags = (unsigned short)2U;
  
#line 390 
  info->valid_sections = (unsigned short)((unsigned int)info->valid_sections | 128U);
  
#line 393 
  info->valid_sections = (unsigned short)((unsigned int)info->valid_sections & 65473U);
  
#line 399 
  tmp = i40e_is_vsi_uplink_mode_veb(vsi);
  
#line 399 
  if (tmp != 0) {
    
#line 400 
    info->valid_sections = (unsigned short)((unsigned int)info->valid_sections | 1U);
    
#line 402 
    info->switch_id = (unsigned short)8192U;
  }
  else ;
  
#line 405 
  enabled_tc = i40e_get_fcoe_tc_map(pf);
  
#line 406 
  i40e_vsi_setup_queue_map(vsi,ctxt,(unsigned char)((int)enabled_tc),(_Bool)1);
  
#line 409 
  info->queueing_opt_flags = (unsigned char)32U;
  
#line 411 
  __retres = 0;
  return_label: 
#line 411 
                return __retres;
}


#line 426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
int i40e_fcoe_enable(struct net_device *netdev)
{
  int __retres;
  
#line 428 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 429 
  struct i40e_vsi *vsi = np->vsi;
  
#line 430 
  struct i40e_pf *pf = vsi->back;
  
#line 431 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 433 
  if ((pf->flags & 2048ULL) == 0ULL) {
    
#line 434 
    netdev_err((struct net_device const *)netdev,"HW does not support FCoE.\n");
    
#line 435 
    __retres = -19;
    
#line 435 
    goto return_label;
  }
  else ;
  
#line 438 
  if (vsi->type != (unsigned int)I40E_VSI_FCOE) {
    
#line 439 
    netdev_err((struct net_device const *)netdev,"interface does not support FCoE.\n");
    
#line 440 
    __retres = -16;
    
#line 440 
    goto return_label;
  }
  else ;
  
#line 443 
  atomic_inc_0(& fcoe->refcnt);
  
#line 445 
  __retres = 0;
  return_label: 
#line 445 
                return __retres;
}


#line 455  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
int i40e_fcoe_disable(struct net_device *netdev)
{
  int __retres;
  int tmp_0;
  
#line 457 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 458 
  struct i40e_vsi *vsi = np->vsi;
  
#line 459 
  struct i40e_pf *pf = vsi->back;
  
#line 460 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 462 
  if ((pf->flags & 2048ULL) == 0ULL) {
    
#line 463 
    netdev_err((struct net_device const *)netdev,"device does not support FCoE\n");
    
#line 464 
    __retres = -19;
    
#line 464 
    goto return_label;
  }
  else ;
  
#line 466 
  if (vsi->type != (unsigned int)I40E_VSI_FCOE) {
    
#line 467 
    __retres = -16;
    
#line 467 
    goto return_label;
  }
  else ;
  
#line 469 
  tmp_0 = atomic_dec_and_test(& fcoe->refcnt);
  
#line 469 
  if (tmp_0 == 0) {
    
#line 470 
    __retres = -22;
    
#line 470 
    goto return_label;
  }
  else ;
  
#line 472 
  netdev_info((struct net_device const *)netdev,"FCoE disabled\n");
  
#line 474 
  __retres = 0;
  return_label: 
#line 474 
                return __retres;
}


#line 484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static void i40e_fcoe_dma_pool_free(struct i40e_fcoe *fcoe, struct device *dev, unsigned int cpu)
{
  struct i40e_fcoe_ddp_pool *ddp_pool;
  struct i40e_fcoe_ddp_pool *tmp_0_0;
  {
    struct i40e_fcoe_ddp_pool *tmp_0;
    {
      
#line 490 
      void const *__vpp_verify = (void const *)0;
      
#line 490 
      void const *tmp = __vpp_verify;
    }
    {
      unsigned long __ptr;
      
#line 491 
      ldv_inline_asm();
      
#line 490 
      tmp_0 = (struct i40e_fcoe_ddp_pool *)(__per_cpu_offset[cpu] + __ptr);
    }
    
#line 490 
    tmp_0_0 = tmp_0;
  }
  
#line 490 
  ddp_pool = tmp_0_0;
  
#line 491 
  if (ddp_pool->pool == (struct dma_pool *)0) {
    
#line 492 
    dev_warn((struct device const *)dev,"DDP pool already freed for cpu %d\n",cpu);
    
#line 493 
    goto return_label;
  }
  else ;
  
#line 495 
  dma_pool_destroy(ddp_pool->pool);
  
#line 496 
  ddp_pool->pool = (struct dma_pool *)0;
  return_label: 
#line 497 
                return;
}


#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static int i40e_fcoe_dma_pool_create(struct i40e_fcoe *fcoe, struct device *dev, unsigned int cpu)
{
  int __retres;
  struct i40e_fcoe_ddp_pool *ddp_pool;
  struct dma_pool *pool;
  char pool_name[32U];
  struct i40e_fcoe_ddp_pool *tmp_0_0;
  {
    struct i40e_fcoe_ddp_pool *tmp_0;
    {
      
#line 516 
      void const *__vpp_verify = (void const *)0;
      
#line 516 
      void const *tmp = __vpp_verify;
    }
    {
      unsigned long __ptr;
      
#line 517 
      ldv_inline_asm();
      
#line 516 
      tmp_0 = (struct i40e_fcoe_ddp_pool *)(__per_cpu_offset[cpu] + __ptr);
    }
    
#line 516 
    tmp_0_0 = tmp_0;
  }
  
#line 516 
  ddp_pool = tmp_0_0;
  
#line 517 
  if (ddp_pool != (struct i40e_fcoe_ddp_pool *)0 && ddp_pool->pool != (struct dma_pool *)0) {
    
#line 518 
    dev_warn((struct device const *)dev,"DDP pool already allocated for cpu %d\n",cpu);
    
#line 519 
    __retres = 0;
    
#line 519 
    goto return_label;
  }
  else ;
  
#line 521 
  snprintf((char *)(& pool_name),32UL,"i40e_fcoe_ddp_%d",cpu);
  
#line 522 
  pool = dma_pool_create((char const *)(& pool_name),dev,4096UL,16UL,4096UL);
  
#line 524 
  if (pool == (struct dma_pool *)0) {
    
#line 525 
    dev_err((struct device const *)dev,"dma_pool_create %s failed\n",(char *)(& pool_name));
    
#line 526 
    __retres = -12;
    
#line 526 
    goto return_label;
  }
  else ;
  
#line 528 
  ddp_pool->pool = pool;
  
#line 529 
  __retres = 0;
  return_label: 
#line 529 
                return __retres;
}


#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
void i40e_fcoe_free_ddp_resources(struct i40e_vsi *vsi)
{
  int cpu;
  int i;
  unsigned int tmp;
  
#line 539 
  struct i40e_pf *pf = vsi->back;
  
#line 540 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 544 
  if (vsi->type != (unsigned int)I40E_VSI_FCOE) 
#line 545 
                                                goto return_label; else ;
  
#line 548 
  if (fcoe->ddp_pool == (struct i40e_fcoe_ddp_pool *)0) 
#line 549 
                                                        goto return_label; else ;
  
#line 551 
  i = 0;
  
#line 551 
  goto ldv_68179;
  ldv_68178: 
#line 552 
  ;
  
#line 552 
  i40e_fcoe_ddp_put(vsi->netdev,(unsigned short)((int)((unsigned short)i)));
  
#line 551 
  i += 1;
  ldv_68179: 
#line 552 
  ;
  
#line 551 
  if (i <= 2047) 
#line 553 
                 goto ldv_68178; else 
#line 556 
                                      goto ldv_68180;
  ldv_68180: 
#line 557 
  ;
  
#line 554 
  cpu = -1;
  
#line 554 
  goto ldv_68182;
  ldv_68181: 
#line 555 
  ;
  
#line 555 
  i40e_fcoe_dma_pool_free(fcoe,& (pf->pdev)->dev,(unsigned int)cpu);
  ldv_68182: 
#line 556 
  ;
  
#line 554 
  tmp = cpumask_next(cpu,cpu_possible_mask);
  
#line 554 
  cpu = (int)tmp;
  
#line 554 
  if (cpu < nr_cpu_ids) 
#line 556 
                        goto ldv_68181; else 
#line 559 
                                             goto ldv_68183;
  ldv_68183: 
#line 560 
  ;
  
#line 557 
  free_percpu((void *)fcoe->ddp_pool);
  
#line 558 
  fcoe->ddp_pool = (struct i40e_fcoe_ddp_pool *)0;
  
#line 560 
  netdev_info((struct net_device const *)vsi->netdev,"VSI %d,%d FCoE DDP resources released\n",(int)vsi->id,(int)vsi->seid);
  return_label: 
#line 562 
                return;
}


#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
int i40e_fcoe_setup_ddp_resources(struct i40e_vsi *vsi)
{
  int __retres;
  unsigned int cpu;
  int i;
  int tmp_0;
  
#line 573 
  struct i40e_pf *pf = vsi->back;
  
#line 574 
  struct device *dev = & (pf->pdev)->dev;
  
#line 575 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 579 
  if (vsi->type != (unsigned int)I40E_VSI_FCOE) {
    
#line 580 
    __retres = -19;
    
#line 580 
    goto return_label;
  }
  else ;
  
#line 583 
  if (fcoe->ddp_pool != (struct i40e_fcoe_ddp_pool *)0) {
    
#line 584 
    __retres = -17;
    
#line 584 
    goto return_label;
  }
  else ;
  
#line 587 
  fcoe->ddp_pool = (struct i40e_fcoe_ddp_pool *)__alloc_percpu(8UL,8UL);
  
#line 588 
  if (fcoe->ddp_pool == (struct i40e_fcoe_ddp_pool *)0) {
    
#line 589 
    dev_err((struct device const *)(& (pf->pdev)->dev),"failed to allocate percpu DDP\n");
    
#line 590 
    __retres = -12;
    
#line 590 
    goto return_label;
  }
  else ;
  
#line 594 
  cpu = 4294967295U;
  
#line 594 
  goto ldv_68192;
  ldv_68193: 
#line 595 
  ;
  
#line 595 
  tmp_0 = i40e_fcoe_dma_pool_create(fcoe,dev,cpu);
  
#line 595 
  if (tmp_0 == 0) 
#line 596 
                  goto ldv_68192; else ;
  
#line 598 
  dev_err((struct device const *)dev,"failed to alloc DDP pool on cpu:%d\n",cpu);
  
#line 599 
  i40e_fcoe_free_ddp_resources(vsi);
  
#line 600 
  __retres = -12;
  
#line 600 
  goto return_label;
  ldv_68192: 
#line 601 
  ;
  
#line 594 
  cpu = cpumask_next((int)cpu,cpu_possible_mask);
  
#line 594 
  if (cpu < (unsigned int)nr_cpu_ids) 
#line 596 
                                      goto ldv_68193; else 
#line 599 
                                                           goto ldv_68194;
  ldv_68194: 
#line 600 
  ;
  
#line 604 
  i = 0;
  
#line 604 
  goto ldv_68196;
  ldv_68195: 
#line 605 
  ;
  
#line 605 
  i40e_fcoe_ddp_clear(& fcoe->ddp[i]);
  
#line 604 
  i += 1;
  ldv_68196: 
#line 605 
  ;
  
#line 604 
  if (i <= 2047) 
#line 606 
                 goto ldv_68195; else 
#line 609 
                                      goto ldv_68197;
  ldv_68197: 
#line 610 
  ;
  
#line 607 
  netdev_info((struct net_device const *)vsi->netdev,"VSI %d,%d FCoE DDP resources allocated\n",(int)vsi->id,(int)vsi->seid);
  
#line 610 
  __retres = 0;
  return_label: 
#line 610 
                return __retres;
}


#line 622  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
void i40e_fcoe_handle_status(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, u8 prog_id)
{
  struct i40e_fcoe_ddp *ddp;
  u32 error;
  u16 xid;
  u64 qw;
  int tmp_0;
  bool tmp;
  int tmp_2;
  bool tmp_1;
  
#line 625 
  struct i40e_pf *pf = (rx_ring->vsi)->back;
  
#line 626 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 633 
  tmp = i40e_fcoe_progid_is_fcoe((unsigned char)((int)prog_id));
  
#line 633 
  if (tmp) 
#line 633 
           tmp_0 = 0; else 
#line 633 
                           tmp_0 = 1;
  
#line 633 
  if (tmp_0) 
#line 634 
             goto return_label; else ;
  
#line 636 
  xid = (unsigned short)((unsigned int)((unsigned short)rx_desc->wb.qword0.hi_dword.fcoe_param) & 2047U);
  
#line 639 
  tmp_1 = i40e_fcoe_xid_is_valid((unsigned short)((int)xid));
  
#line 639 
  if (tmp_1) 
#line 639 
             tmp_2 = 0; else 
#line 639 
                             tmp_2 = 1;
  
#line 639 
  if (tmp_2) 
#line 640 
             goto return_label; else ;
  
#line 642 
  ddp = & fcoe->ddp[(int)xid];
  {
    
#line 643 
    int __ret_warn_on = (int)ddp->xid != (int)xid;
    
#line 643 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 643 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c",643); else ;
    
#line 643 
    long tmp_3 = (long)(__ret_warn_on != 0);
  }
  
#line 645 
  qw = rx_desc->wb.qword1.status_error_len;
  
#line 646 
  error = (unsigned int)(qw >> 19) & 63U;
  
#line 650 
  if ((unsigned int)prog_id == 2U) {
    
#line 651 
    if ((error & 4U) != 0U) {
      
#line 652 
      dev_err((struct device const *)(& (pf->pdev)->dev),"xid %x ddp->xid %x TABLE FULL\n",(int)xid,(int)ddp->xid);
      
#line 654 
      ddp->prerr = (unsigned char)((unsigned int)ddp->prerr | 4U);
    }
    else ;
    
#line 656 
    if ((error & 8U) != 0U) {
      
#line 657 
      dev_err((struct device const *)(& (pf->pdev)->dev),"xid %x ddp->xid %x CONFLICT\n",(int)xid,(int)ddp->xid);
      
#line 659 
      ddp->prerr = (unsigned char)((unsigned int)ddp->prerr | 8U);
    }
    else ;
  }
  else ;
  
#line 664 
  if ((unsigned int)prog_id == 4U) {
    
#line 665 
    if ((error & 8U) != 0U) {
      
#line 666 
      dev_err((struct device const *)(& (pf->pdev)->dev),"xid %x ddp->xid %x INVALIDATION FAILURE\n",(int)xid,(int)ddp->xid);
      
#line 668 
      ddp->prerr = (unsigned char)((unsigned int)ddp->prerr | 8U);
    }
    else ;
    
#line 671 
    clear_bit(6L,(unsigned long volatile *)(& ddp->flags));
  }
  else ;
  
#line 675 
  i40e_fcoe_ddp_unmap(pf,ddp);
  
#line 676 
  i40e_fcoe_ddp_clear(ddp);
  return_label: 
#line 677 
                return;
}


#line 692  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
int i40e_fcoe_handle_offload(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, struct sk_buff *skb)
{
  u32 status;
  u32 fltstat;
  u32 error;
  u32 fcerr;
  u16 ptype;
  u16 xid;
  u64 qw;
  int tmp_0;
  bool tmp;
  int tmp_2;
  bool tmp_1;
  
#line 696 
  struct i40e_pf *pf = (rx_ring->vsi)->back;
  
#line 697 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 698 
  struct fc_frame_header *fh = (struct fc_frame_header *)0;
  
#line 699 
  struct i40e_fcoe_ddp *ddp = (struct i40e_fcoe_ddp *)0;
  
#line 702 
  int rc = -22;
  
#line 708 
  qw = rx_desc->wb.qword1.status_error_len;
  
#line 710 
  ptype = (unsigned short)((unsigned int)((unsigned short)(qw >> 30)) & 255U);
  
#line 711 
  tmp = i40e_rx_is_fcoe((unsigned short)((int)ptype));
  
#line 711 
  if (tmp) 
#line 711 
           tmp_0 = 0; else 
#line 711 
                           tmp_0 = 1;
  
#line 711 
  if (tmp_0) 
#line 712 
             goto out_no_ddp; else ;
  
#line 714 
  error = (unsigned int)(qw >> 19) & 255U;
  
#line 715 
  fcerr = (error >> 3) & 7U;
  
#line 719 
  if ((long)(fcerr == 1U) != 0L) {
    
#line 720 
    dev_err((struct device const *)(& (pf->pdev)->dev),"Protocol Error\n");
    
#line 721 
    skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U;
  }
  else 
#line 723 
       skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U;
  
#line 727 
  status = (unsigned int)qw & 524287U;
  
#line 728 
  fltstat = (status >> 12) & 3U;
  
#line 732 
  fh = i40e_fcoe_fc_frame_header(skb);
  
#line 733 
  xid = i40e_fcoe_fc_get_xid(fh);
  
#line 734 
  tmp_1 = i40e_fcoe_xid_is_valid((unsigned short)((int)xid));
  
#line 734 
  if (tmp_1) 
#line 734 
             tmp_2 = 0; else 
#line 734 
                             tmp_2 = 1;
  
#line 734 
  if (tmp_2) 
#line 735 
             goto out_no_ddp; else ;
  
#line 738 
  if (fltstat == 0U) 
#line 739 
                     goto out_no_ddp; else ;
  
#line 742 
  ddp = & fcoe->ddp[(int)xid];
  
#line 743 
  if (ddp->sgl == (struct scatterlist *)0) 
#line 744 
                                           goto out_no_ddp; else ;
  
#line 747 
  xid = rx_desc->wb.qword0.lo_dword.mirr_fcoe.fcoe_ctx_id;
  
#line 748 
  if ((int)ddp->xid != (int)xid) {
    
#line 749 
    dev_err((struct device const *)(& (pf->pdev)->dev),"xid 0x%x does not match ctx_xid 0x%x\n",(int)ddp->xid,(int)xid);
    
#line 751 
    goto out_put_ddp;
  }
  else ;
  
#line 755 
  if ((unsigned int)ddp->fcerr != 0U) {
    
#line 756 
    dev_err((struct device const *)(& (pf->pdev)->dev),"xid 0x%x fcerr 0x%x reported fcer 0x%x\n",(int)xid,(int)ddp->fcerr,fcerr);
    
#line 758 
    goto out_put_ddp;
  }
  else ;
  
#line 762 
  ddp->len = (int)rx_desc->wb.qword0.hi_dword.fcoe_param;
  
#line 763 
  ddp->fcerr = (unsigned char)fcerr;
  
#line 765 
  if (fltstat == 2U) {
    
#line 772 
    u32 f_ctl = ntoh24((u8 const *)(& fh->fh_f_ctl));
    
#line 774 
    if ((f_ctl & 524288U) != 0U && (unsigned int)fh->fh_r_ctl == 1U) {
      
#line 776 
      struct fcoe_crc_eof *crc = (struct fcoe_crc_eof *)0;
      
#line 778 
      crc = (struct fcoe_crc_eof *)skb_put(skb,8U);
      
#line 779 
      crc->fcoe_eof = (unsigned char)66U;
    }
    else {
      
#line 782 
      rc = 0;
      
#line 783 
      goto out_no_ddp;
    }
  }
  else ;
  out_put_ddp: 
#line 787 
  ;
  
#line 789 
  i40e_fcoe_ddp_unmap(pf,ddp);
  
#line 790 
  if (ddp->len != 0 && (unsigned int)ddp->fcerr == 0U) {
    int pkts;
    
#line 793 
    rc = ddp->len;
    
#line 794 
    i40e_fcoe_ddp_clear(ddp);
    
#line 795 
    ddp->len = rc;
    
#line 796 
    pkts = (rc + 2047) / 2048;
    
#line 797 
    rx_ring->stats.bytes += (unsigned long long)rc;
    
#line 798 
    rx_ring->stats.packets += (unsigned long long)pkts;
    
#line 799 
    (rx_ring->q_vector)->rx.total_bytes += (unsigned int)rc;
    
#line 800 
    (rx_ring->q_vector)->rx.total_packets += (unsigned int)pkts;
    
#line 801 
    clear_bit(5L,(unsigned long volatile *)(& ddp->flags));
  }
  else ;
  out_no_ddp: 
#line 804 
  ;
  
#line 805 
  return rc;
}


#line 818  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static int i40e_fcoe_ddp_setup(struct net_device *netdev, u16 xid, struct scatterlist *sgl, unsigned int sgc, int target_mode)
{
  int __retres;
  struct i40e_fcoe_ddp_pool *ddp_pool;
  unsigned int i;
  unsigned int j;
  unsigned int dmacount;
  struct i40e_fcoe_ddp *ddp;
  struct scatterlist *sg;
  unsigned int len;
  int tmp_0;
  struct i40e_fcoe_ddp_pool *tmp_9;
  int tmp_10;
  unsigned int tmp_13;
  
#line 822 
  unsigned int const bufflen = 4096U;
  
#line 823 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 825 
  struct i40e_pf *pf = (np->vsi)->back;
  
#line 826 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 829 
  unsigned int firstoff = 0U;
  
#line 830 
  unsigned int thisoff = 0U;
  
#line 831 
  unsigned int thislen = 0U;
  
#line 833 
  dma_addr_t addr = 0ULL;
  
#line 836 
  if ((unsigned int)xid > 2047U) {
    
#line 837 
    dev_warn((struct device const *)(& (pf->pdev)->dev),"xid=0x%x out-of-range\n",(int)xid);
    
#line 838 
    __retres = 0;
    
#line 838 
    goto return_label;
  }
  else ;
  
#line 842 
  tmp_0 = constant_test_bit(3L,(unsigned long const volatile *)(& pf->state));
  
#line 842 
  if (tmp_0 != 0) 
#line 842 
                  goto _LOR;
  else {
    int tmp_1;
    
#line 842 
    tmp_1 = constant_test_bit(4L,(unsigned long const volatile *)(& pf->state));
    
#line 842 
    if (tmp_1 != 0) {
      _LOR: {
              
#line 844 
              _dev_info((struct device const *)(& (pf->pdev)->dev),"xid=0x%x device in reset/down\n",(int)xid);
              
#line 846 
              __retres = 0;
              
#line 846 
              goto return_label;
            }
    }
    else ;
  }
  
#line 849 
  ddp = & fcoe->ddp[(int)xid];
  
#line 850 
  if (ddp->sgl != (struct scatterlist *)0) {
    
#line 851 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"xid 0x%x w/ non-null sgl=%p nents=%d\n",(int)xid,ddp->sgl,ddp->sgc);
    
#line 853 
    __retres = 0;
    
#line 853 
    goto return_label;
  }
  else ;
  
#line 855 
  i40e_fcoe_ddp_clear(ddp);
  
#line 857 
  if (fcoe->ddp_pool == (struct i40e_fcoe_ddp_pool *)0) {
    
#line 858 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"No DDP pool, xid 0x%x\n",(int)xid);
    
#line 859 
    __retres = 0;
    
#line 859 
    goto return_label;
  }
  else ;
  {
    struct i40e_fcoe_ddp_pool *tmp_8;
    {
      
#line 862 
      void const *__vpp_verify = (void const *)0;
      
#line 862 
      void const *tmp_2 = __vpp_verify;
    }
    {
      unsigned long __ptr;
      int tmp_7;
      
#line 863 
      ldv_inline_asm();
      {
        int tmp_6;
        
#line 862 
        __preempt_count_add(1);
        
#line 863 
        ldv_inline_asm();
        {
          int pscr_ret__;
          {
            
#line 862 
            void const *__vpp_verify_0 = (void const *)0;
            
#line 862 
            void const *tmp_4 = __vpp_verify_0;
          }
          
#line 862 
          switch (4UL) {
            int tmp_2_0;
            int tmp_3;
            int tmp_4_0;
            int tmp_5;
            case (unsigned long)1: 
#line 862 
            ;
            {
              int pfo_ret__;
              
#line 862 
              switch (4UL) {
                case (unsigned long)1: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68262;
                case (unsigned long)2: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68262;
                case (unsigned long)4: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68262;
                case (unsigned long)8: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68262;
                default: 
#line 862 
                ;
                
#line 862 
                __bad_percpu_size();
              }
              ldv_68262: 
#line 862 
              ;
              
#line 862 
              tmp_2_0 = pfo_ret__;
            }
            
#line 862 
            pscr_ret__ = tmp_2_0;
            
#line 862 
            goto ldv_68268;
            case (unsigned long)2: 
#line 862 
            ;
            {
              int pfo_ret___0;
              
#line 862 
              switch (4UL) {
                case (unsigned long)1: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68272;
                case (unsigned long)2: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68272;
                case (unsigned long)4: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68272;
                case (unsigned long)8: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68272;
                default: 
#line 862 
                ;
                
#line 862 
                __bad_percpu_size();
              }
              ldv_68272: 
#line 862 
              ;
              
#line 862 
              tmp_3 = pfo_ret___0;
            }
            
#line 862 
            pscr_ret__ = tmp_3;
            
#line 862 
            goto ldv_68268;
            case (unsigned long)4: 
#line 862 
            ;
            {
              int pfo_ret___1;
              
#line 862 
              switch (4UL) {
                case (unsigned long)1: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68281;
                case (unsigned long)2: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68281;
                case (unsigned long)4: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68281;
                case (unsigned long)8: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68281;
                default: 
#line 862 
                ;
                
#line 862 
                __bad_percpu_size();
              }
              ldv_68281: 
#line 862 
              ;
              
#line 862 
              tmp_4_0 = pfo_ret___1;
            }
            
#line 862 
            pscr_ret__ = tmp_4_0;
            
#line 862 
            goto ldv_68268;
            case (unsigned long)8: 
#line 862 
            ;
            {
              int pfo_ret___2;
              
#line 862 
              switch (4UL) {
                case (unsigned long)1: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68290;
                case (unsigned long)2: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68290;
                case (unsigned long)4: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68290;
                case (unsigned long)8: 
#line 862 
                ;
                
#line 863 
                ldv_inline_asm();
                
#line 862 
                goto ldv_68290;
                default: 
#line 862 
                ;
                
#line 862 
                __bad_percpu_size();
              }
              ldv_68290: 
#line 862 
              ;
              
#line 862 
              tmp_5 = pfo_ret___2;
            }
            
#line 862 
            pscr_ret__ = tmp_5;
            
#line 862 
            goto ldv_68268;
            default: 
#line 862 
            ;
            
#line 862 
            __bad_size_call_parameter();
            
#line 862 
            goto ldv_68268;
          }
          ldv_68268: 
#line 862 
          ;
          
#line 862 
          tmp_6 = pscr_ret__;
        }
        
#line 862 
        tmp_7 = tmp_6;
      }
      
#line 862 
      ;
      
#line 862 
      tmp_8 = (struct i40e_fcoe_ddp_pool *)(__per_cpu_offset[tmp_7] + __ptr);
    }
    
#line 862 
    tmp_9 = tmp_8;
  }
  
#line 862 
  ddp_pool = tmp_9;
  
#line 863 
  if (ddp_pool->pool == (struct dma_pool *)0) {
    
#line 864 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"No percpu ddp pool, xid 0x%x\n",(int)xid);
    
#line 865 
    goto out_noddp;
  }
  else ;
  
#line 869 
  tmp_10 = dma_map_sg_attrs(& (pf->pdev)->dev,sgl,(int)sgc,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
  
#line 869 
  dmacount = (unsigned int)tmp_10;
  
#line 870 
  if (dmacount == 0U) {
    
#line 871 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"dma_map_sg for sgl %p, sgc %d failed\n",sgl,sgc);
    
#line 873 
    goto out_noddp_unmap;
  }
  else ;
  
#line 877 
  ddp->udl = (u64 *)dma_pool_alloc(ddp_pool->pool,32U,& ddp->udp);
  
#line 878 
  if (ddp->udl == (u64 *)0ULL) {
    
#line 879 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"Failed allocated ddp context, xid 0x%x\n",(int)xid);
    
#line 881 
    goto out_noddp_unmap;
  }
  else ;
  
#line 884 
  j = 0U;
  
#line 885 
  ddp->len = 0;
  
#line 886 
  i = 0U;
  
#line 886 
  sg = sgl;
  
#line 886 
  goto ldv_68311;
  ldv_68310: 
#line 887 
  ;
  
#line 887 
  addr = sg->dma_address;
  
#line 888 
  len = sg->dma_length;
  
#line 889 
  ddp->len = (int)((unsigned int)ddp->len + len);
  
#line 890 
  goto ldv_68308;
  ldv_68307: 
#line 891 
  ;
  
#line 892 
  if (j > 511U) {
    
#line 893 
    _dev_info((struct device const *)(& (pf->pdev)->dev),"xid=%x:%d,%d,%d:addr=%llx not enough descriptors\n",(int)xid,i,j,dmacount,addr);
    
#line 896 
    goto out_noddp_free;
  }
  else ;
  
#line 900 
  thisoff = (unsigned int)addr & 4095U;
  {
    unsigned int tmp_12;
    
#line 901 
    unsigned int __min1 = 4096U - thisoff;
    
#line 901 
    unsigned int __min2 = len;
    
#line 901 
    if (__min1 < __min2) 
#line 901 
                         tmp_12 = __min1; else 
#line 901 
                                               tmp_12 = __min2;
    
#line 901 
    tmp_13 = tmp_12;
  }
  
#line 901 
  thislen = tmp_13;
  
#line 905 
  if (j != 0U && thisoff != 0U) 
#line 906 
                                goto out_noddp_free; else ;
  
#line 912 
  if ((dmacount + 4294967295U != i || thislen != len) && thislen + thisoff != 4096U) 
    
#line 914 
    goto out_noddp_free; else ;
  
#line 916 
  *(ddp->udl + j) = addr - (unsigned long long)thisoff;
  
#line 918 
  if (j == 0U) 
#line 919 
               firstoff = thisoff; else ;
  
#line 920 
  len -= thislen;
  
#line 921 
  addr = (unsigned long long)thislen + addr;
  
#line 922 
  j += 1U;
  ldv_68308: 
#line 923 
  ;
  
#line 890 
  if (len != 0U) 
#line 892 
                 goto ldv_68307; else 
#line 895 
                                      goto ldv_68309;
  ldv_68309: 
#line 896 
  ;
  
#line 886 
  i += 1U;
  
#line 886 
  sg = sg_next(sg);
  ldv_68311: 
#line 887 
  ;
  
#line 886 
  if (i < dmacount) 
#line 888 
                    goto ldv_68310; else 
#line 891 
                                         goto ldv_68312;
  ldv_68312: 
#line 892 
  ;
  
#line 926 
  ddp->lastsize = (unsigned short)((int)((unsigned short)thisoff) + (int)((unsigned short)thislen));
  
#line 927 
  ddp->firstoff = (unsigned short)firstoff;
  
#line 928 
  ddp->list_len = (unsigned short)j;
  
#line 929 
  ddp->pool = ddp_pool->pool;
  
#line 930 
  ddp->sgl = sgl;
  
#line 931 
  ddp->sgc = sgc;
  
#line 932 
  ddp->xid = xid;
  
#line 933 
  if (target_mode != 0) 
#line 934 
                        clear_bit(2L,(unsigned long volatile *)(& ddp->flags)); else ;
  
#line 935 
  clear_bit(3L,(unsigned long volatile *)(& ddp->flags));
  
#line 936 
  ldv_inline_asm();
  
#line 937 
  __preempt_count_sub(1);
  
#line 938 
  __retres = 1;
  
#line 938 
  goto return_label;
  out_noddp_free: 
#line 940 
  ;
  
#line 941 
  dma_pool_free(ddp->pool,(void *)ddp->udl,ddp->udp);
  
#line 942 
  i40e_fcoe_ddp_clear(ddp);
  out_noddp_unmap: 
#line 944 
  ;
  
#line 945 
  dma_unmap_sg_attrs(& (pf->pdev)->dev,sgl,(int)sgc,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
  out_noddp: 
#line 946 
  ;
  
#line 947 
  ldv_inline_asm();
  
#line 947 
  __preempt_count_sub(1);
  
#line 948 
  __retres = 0;
  return_label: 
#line 948 
                return __retres;
}


#line 965  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static int i40e_fcoe_ddp_get(struct net_device *netdev, u16 xid, struct scatterlist *sgl, unsigned int sgc)
{
  int tmp;
  
#line 968 
  tmp = i40e_fcoe_ddp_setup(netdev,(unsigned short)((int)xid),sgl,sgc,0);
  
#line 968 
  return tmp;
}


#line 986  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static int i40e_fcoe_ddp_target(struct net_device *netdev, u16 xid, struct scatterlist *sgl, unsigned int sgc)
{
  int tmp;
  
#line 989 
  tmp = i40e_fcoe_ddp_setup(netdev,(unsigned short)((int)xid),sgl,sgc,1);
  
#line 989 
  return tmp;
}


#line 1008  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static void i40e_fcoe_program_ddp(struct i40e_ring *tx_ring, struct sk_buff *skb, struct i40e_fcoe_ddp *ddp, u8 sof)
{
  struct fc_frame_header *fh;
  bool target_mode;
  int tmp;
  int tmp_0;
  int tmp_1;
  u16 tmp_2;
  int tmp_6;
  int tmp_7;
  
#line 1012 
  struct i40e_fcoe_filter_context_desc *filter_desc = (struct i40e_fcoe_filter_context_desc *)0;
  
#line 1013 
  struct i40e_fcoe_queue_context_desc *queue_desc = (struct i40e_fcoe_queue_context_desc *)0;
  
#line 1014 
  struct i40e_fcoe_ddp_context_desc *ddp_desc = (struct i40e_fcoe_ddp_context_desc *)0;
  
#line 1015 
  struct i40e_pf *pf = (tx_ring->vsi)->back;
  
#line 1016 
  u16 i = tx_ring->next_to_use;
  
#line 1018 
  u64 flags_rsvd_lanq = 0ULL;
  
#line 1022 
  tmp = constant_test_bit(6L,(unsigned long const volatile *)(& ddp->flags));
  
#line 1022 
  if (tmp != 0) {
    
#line 1023 
    dev_warn((struct device const *)(& (pf->pdev)->dev),"DDP abort is still pending xid:%hx and ddp->flags:%lx:\n",(int)ddp->xid,ddp->flags);
    
#line 1026 
    goto return_label;
  }
  else ;
  
#line 1030 
  tmp_0 = test_and_set_bit(4L,(unsigned long volatile *)(& ddp->flags));
  
#line 1030 
  if (tmp_0 != 0) {
    
#line 1031 
    dev_warn((struct device const *)(& (pf->pdev)->dev),"DDP is already programmed for xid:%hx and ddp->flags:%lx:\n",(int)ddp->xid,ddp->flags);
    
#line 1034 
    goto return_label;
  }
  else ;
  
#line 1038 
  ddp_desc = (struct i40e_fcoe_ddp_context_desc *)tx_ring->desc + (int)i;
  
#line 1039 
  i = (u16)((int)i + 1);
  
#line 1040 
  if ((int)tx_ring->count == (int)i) 
#line 1041 
                                     i = (unsigned short)0U; else ;
  
#line 1043 
  ddp_desc->type_cmd_foff_lsize = (((unsigned long long)ddp->firstoff << 16) | ((unsigned long long)ddp->lastsize << 32)) | 25ULL;
  
#line 1051 
  ddp_desc->rsvd = 0ULL;
  
#line 1054 
  tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& ddp->flags));
  
#line 1054 
  target_mode = (_Bool)(tmp_1 != 0);
  
#line 1055 
  if ((int)target_mode != 0) 
#line 1056 
                             ddp_desc->type_cmd_foff_lsize |= 8ULL; else ;
  
#line 1060 
  tmp_2 = i;
  
#line 1060 
  i = (u16)((int)i + 1);
  
#line 1060 
  queue_desc = (struct i40e_fcoe_queue_context_desc *)tx_ring->desc + (int)tmp_2;
  
#line 1061 
  if ((int)tx_ring->count == (int)i) 
#line 1062 
                                     i = (unsigned short)0U; else ;
  
#line 1063 
  queue_desc->dmaindx_fbase = (unsigned long long)ddp->xid | ddp->udp;
  
#line 1064 
  queue_desc->flen_tph = (unsigned long long)((unsigned int)ddp->list_len | 24576U);
  
#line 1070 
  filter_desc = (struct i40e_fcoe_filter_context_desc *)tx_ring->desc + (int)i;
  
#line 1071 
  i = (u16)((int)i + 1);
  
#line 1072 
  if ((int)tx_ring->count == (int)i) 
#line 1073 
                                     i = (unsigned short)0U; else ;
  
#line 1075 
  fh = (struct fc_frame_header *)skb_transport_header((struct sk_buff const *)skb);
  
#line 1076 
  if (0 != 0) 
#line 1076 
              filter_desc->param = (((fh->fh_parm_offset << 24) | ((fh->fh_parm_offset << 8) & 16711680U)) | ((fh->fh_parm_offset >> 8) & 65280U)) | (fh->fh_parm_offset >> 24); else 
                                                                    
#line 1076 
                                                                    filter_desc->param = __fswab32(fh->fh_parm_offset);
  
#line 1077 
  if (0 != 0) 
#line 1077 
              filter_desc->seqn = (unsigned short)(((int)fh->fh_seq_cnt << 8) | ((int)fh->fh_seq_cnt >> 8)); else 
                                                                    
#line 1077 
                                                                    filter_desc->seqn = __fswab16((unsigned short)((int)fh->fh_seq_cnt));
  
#line 1078 
  filter_desc->rsvd_dmaindx = (unsigned short)((int)ddp->xid << 4U);
  
#line 1081 
  flags_rsvd_lanq = 0ULL;
  
#line 1082 
  if ((int)target_mode != 0) 
#line 1082 
                             tmp_6 = 2; else 
#line 1082 
                                             tmp_6 = 0;
  
#line 1082 
  flags_rsvd_lanq = (unsigned long long)tmp_6 | flags_rsvd_lanq;
  
#line 1086 
  if ((unsigned int)sof == 45U || (unsigned int)sof == 53U) 
#line 1086 
                                                            tmp_7 = 0; else 
                                                                    
#line 1086 
                                                                    tmp_7 = 4;
  
#line 1086 
  flags_rsvd_lanq = (unsigned long long)tmp_7 | flags_rsvd_lanq;
  
#line 1090 
  flags_rsvd_lanq = ((unsigned long long)skb->queue_mapping << 53) | flags_rsvd_lanq;
  
#line 1092 
  filter_desc->flags_rsvd_lanq = flags_rsvd_lanq;
  
#line 1095 
  tx_ring->next_to_use = i;
  return_label: 
#line 1096 
                return;
}


#line 1106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static void i40e_fcoe_invalidate_ddp(struct i40e_ring *tx_ring, struct sk_buff *skb, struct i40e_fcoe_ddp *ddp)
{
  struct i40e_tx_context_desc *context_desc;
  int i;
  int tmp;
  
#line 1113 
  tmp = test_and_set_bit(6L,(unsigned long volatile *)(& ddp->flags));
  
#line 1113 
  if (tmp != 0) 
#line 1114 
                goto return_label; else ;
  
#line 1116 
  i = (int)tx_ring->next_to_use;
  
#line 1117 
  context_desc = (struct i40e_tx_context_desc *)tx_ring->desc + i;
  
#line 1118 
  i += 1;
  
#line 1119 
  if ((int)tx_ring->count == i) 
#line 1120 
                                i = 0; else ;
  
#line 1122 
  context_desc->tunneling_params = 0U;
  
#line 1123 
  context_desc->l2tag2 = (unsigned short)0U;
  
#line 1124 
  context_desc->rsvd = (unsigned short)0U;
  
#line 1125 
  context_desc->type_cmd_tso_mss = 130ULL;
  
#line 1131 
  tx_ring->next_to_use = (unsigned short)i;
  return_label: 
#line 1132 
                return;
}


#line 1146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static void i40e_fcoe_handle_ddp(struct i40e_ring *tx_ring, struct sk_buff *skb, u8 sof)
{
  struct fc_frame_header *fh;
  struct i40e_fcoe_ddp *ddp;
  u32 f_ctl;
  u8 r_ctl;
  u16 xid;
  
#line 1149 
  struct i40e_pf *pf = (tx_ring->vsi)->back;
  
#line 1150 
  struct i40e_fcoe *fcoe = & pf->fcoe;
  
#line 1157 
  fh = (struct fc_frame_header *)skb_transport_header((struct sk_buff const *)skb);
  
#line 1158 
  f_ctl = ntoh24((u8 const *)(& fh->fh_f_ctl));
  
#line 1159 
  r_ctl = fh->fh_r_ctl;
  
#line 1160 
  ddp = (struct i40e_fcoe_ddp *)0;
  
#line 1162 
  if ((unsigned int)r_ctl == 5U && (f_ctl & 8388608U) != 0U) {
    bool tmp_2;
    
#line 1164 
    if (0 != 0) 
#line 1164 
                xid = (unsigned short)(((int)fh->fh_rx_id << 8) | ((int)fh->fh_rx_id >> 8)); else 
                                                                    
#line 1164 
                                                                    xid = __fswab16((unsigned short)((int)fh->fh_rx_id));
    
#line 1165 
    tmp_2 = i40e_fcoe_xid_is_valid((unsigned short)((int)xid));
    
#line 1165 
    if ((int)tmp_2 != 0) {
      
#line 1166 
      ddp = & fcoe->ddp[(int)xid];
      
#line 1167 
      if ((int)ddp->xid == (int)xid) {
        int tmp_1;
        
#line 1167 
        tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& ddp->flags));
        
#line 1167 
        if (tmp_1 != 0) 
#line 1169 
                        i40e_fcoe_program_ddp(tx_ring,skb,ddp,(unsigned char)((int)sof)); else ;
      }
      else ;
    }
    else ;
  }
  else 
    
#line 1171 
    if ((unsigned int)r_ctl == 6U) {
      bool tmp_5;
      
#line 1173 
      if (0 != 0) 
#line 1173 
                  xid = (unsigned short)(((int)fh->fh_ox_id << 8) | ((int)fh->fh_ox_id >> 8)); else 
                                                                    
#line 1173 
                                                                    xid = __fswab16((unsigned short)((int)fh->fh_ox_id));
      
#line 1174 
      tmp_5 = i40e_fcoe_xid_is_valid((unsigned short)((int)xid));
      
#line 1174 
      if ((int)tmp_5 != 0) {
        
#line 1175 
        ddp = & fcoe->ddp[(int)xid];
        
#line 1176 
        if ((int)ddp->xid == (int)xid) {
          int tmp_4;
          
#line 1176 
          tmp_4 = constant_test_bit(2L,(unsigned long const volatile *)(& ddp->flags));
          
#line 1176 
          if (tmp_4 == 0) 
#line 1178 
                          i40e_fcoe_program_ddp(tx_ring,skb,ddp,(unsigned char)((int)sof)); else ;
        }
        else ;
      }
      else ;
    }
    else 
      
#line 1180 
      if ((unsigned int)r_ctl == 129U) {
        bool tmp_8;
        
#line 1182 
        if (0 != 0) 
#line 1182 
                    xid = (unsigned short)(((int)fh->fh_ox_id << 8) | ((int)fh->fh_ox_id >> 8)); else 
                                                                    
#line 1182 
                                                                    xid = __fswab16((unsigned short)((int)fh->fh_ox_id));
        
#line 1183 
        tmp_8 = i40e_fcoe_xid_is_valid((unsigned short)((int)xid));
        
#line 1183 
        if ((int)tmp_8 != 0) {
          
#line 1184 
          ddp = & fcoe->ddp[(int)xid];
          
#line 1185 
          if ((int)ddp->xid == (int)xid) {
            int tmp_7;
            
#line 1185 
            tmp_7 = constant_test_bit(2L,(unsigned long const volatile *)(& ddp->flags));
            
#line 1185 
            if (tmp_7 == 0) 
#line 1187 
                            i40e_fcoe_invalidate_ddp(tx_ring,skb,ddp); else ;
          }
          else ;
        }
        else ;
      }
      else ;
  
#line 1190 
  return;
}


#line 1207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static int i40e_fcoe_tso(struct i40e_ring *tx_ring, struct sk_buff *skb, u32 tx_flags, u8 *hdr_len, u8 sof)
{
  int __retres;
  struct i40e_tx_context_desc *context_desc;
  u32 cd_type;
  u32 cd_cmd;
  u32 cd_tso_len;
  u32 cd_mss;
  struct fc_frame_header *fh;
  u64 cd_type_cmd_tso_mss;
  int tmp_0;
  bool tmp;
  unsigned char *tmp_2;
  int tmp_3;
  bool tmp_4;
  unsigned char *tmp_6;
  
#line 1217 
  tmp = skb_is_gso((struct sk_buff const *)skb);
  
#line 1217 
  if (tmp) 
#line 1217 
           tmp_0 = 0; else 
#line 1217 
                           tmp_0 = 1;
  
#line 1217 
  if (tmp_0) {
    
#line 1218 
    __retres = 0;
    
#line 1218 
    goto return_label;
  }
  else ;
  
#line 1221 
  tmp_2 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1221 
  ;
  
#line 1221 
  if ((unsigned int)((struct skb_shared_info *)tmp_2)->gso_type != 32U) {
    unsigned char *tmp_1;
    
#line 1224 
    tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 1222 
    ;
    
#line 1222 
    netdev_err((struct net_device const *)skb->dev,"wrong gso type %d:expecting SKB_GSO_FCOE\n",(int)((struct skb_shared_info *)tmp_1)->gso_type);
    
#line 1225 
    __retres = -22;
    
#line 1225 
    goto return_label;
  }
  else ;
  
#line 1229 
  tmp_3 = skb_transport_offset((struct sk_buff const *)skb);
  
#line 1229 
  *hdr_len = (unsigned char)((unsigned int)((unsigned char)tmp_3) + 32U);
  
#line 1233 
  tmp_4 = i40e_fcoe_sof_is_class3((unsigned char)((int)sof));
  
#line 1233 
  if ((long)((int)tmp_4 != 0) != 0L) 
#line 1234 
                                     cd_cmd = 5U; else 
#line 1236 
                                                       cd_cmd = 1U;
  
#line 1239 
  fh = (struct fc_frame_header *)skb_transport_header((struct sk_buff const *)skb);
  
#line 1240 
  if (((int)fh->fh_f_ctl[2] & 8) != 0) 
#line 1241 
                                       cd_cmd |= 16U; else ;
  
#line 1244 
  cd_type = 2U;
  
#line 1245 
  cd_tso_len = skb->len - (unsigned int)*hdr_len;
  
#line 1246 
  tmp_6 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1246 
  cd_mss = (unsigned int)((struct skb_shared_info *)tmp_6)->gso_size;
  
#line 1247 
  cd_type_cmd_tso_mss = (((unsigned long long)cd_type | ((unsigned long long)cd_cmd << 4)) | ((unsigned long long)cd_tso_len << 30)) | ((unsigned long long)cd_mss << 50);
  
#line 1254 
  context_desc = (struct i40e_tx_context_desc *)tx_ring->desc + (int)tx_ring->next_to_use;
  
#line 1255 
  tx_ring->next_to_use = (u16)((int)tx_ring->next_to_use + 1);
  
#line 1256 
  if ((int)tx_ring->next_to_use == (int)tx_ring->count) 
#line 1257 
                                                        tx_ring->next_to_use = (unsigned short)0U; else ;
  
#line 1259 
  context_desc->tunneling_params = 0U;
  
#line 1260 
  context_desc->l2tag2 = (unsigned short)(tx_flags >> 16);
  
#line 1262 
  context_desc->type_cmd_tso_mss = cd_type_cmd_tso_mss;
  
#line 1264 
  __retres = 1;
  return_label: 
#line 1264 
                return __retres;
}


#line 1278  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static void i40e_fcoe_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb, struct i40e_tx_buffer *first, u32 tx_flags, u8 hdr_len, u8 eof)
{
  u32 maclen;
  int tmp;
  
#line 1283 
  u32 td_offset = 0U;
  
#line 1284 
  u32 td_cmd = 0U;
  
#line 1288 
  td_cmd = 4U;
  
#line 1291 
  tmp = skb_network_offset((struct sk_buff const *)skb);
  
#line 1291 
  maclen = (unsigned int)tmp;
  
#line 1292 
  if ((tx_flags & 4U) != 0U) 
#line 1293 
                             maclen += 4U; else ;
  
#line 1295 
  if ((unsigned int)skb->protocol == 1673U) {
    u32 tmp_0;
    
#line 1297 
    maclen += 4294967294U;
    
#line 1299 
    tmp_0 = i40e_fcoe_ctxt_eof((unsigned char)((int)eof));
    
#line 1299 
    td_cmd = (tmp_0 | 128U) | td_cmd;
    
#line 1301 
    td_offset |= 98816U;
    
#line 1306 
    pskb_trim(skb,skb->len + 4294967288U);
  }
  else ;
  
#line 1310 
  td_offset = (maclen >> 1) | td_offset;
  
#line 1312 
  i40e_tx_map(tx_ring,skb,first,tx_flags,(unsigned char)((int)hdr_len),td_cmd,td_offset);
  
#line 1313 
  return;
}


#line 1322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
__inline static int i40e_fcoe_set_skb_header(struct sk_buff *skb)
{
  int __retres;
  
#line 1324 
  __be16 protocol = skb->protocol;
  
#line 1326 
  skb_reset_mac_header(skb);
  
#line 1327 
  skb->mac_len = (unsigned short)14U;
  
#line 1328 
  if ((unsigned int)protocol == 129U) {
    
#line 1329 
    struct vlan_ethhdr *veth = eth_hdr((struct sk_buff const *)skb);
    
#line 1331 
    protocol = veth->h_vlan_encapsulated_proto;
    
#line 1332 
    skb->mac_len = (unsigned short)((unsigned int)skb->mac_len + 4U);
  }
  else ;
  
#line 1336 
  if ((unsigned int)protocol != 5257U && (unsigned int)protocol != 1673U) {
    
#line 1338 
    __retres = -22;
    
#line 1338 
    goto return_label;
  }
  else ;
  
#line 1341 
  skb_set_network_header(skb,(int)skb->mac_len);
  
#line 1342 
  if ((unsigned int)protocol == 5257U) {
    
#line 1343 
    __retres = 0;
    
#line 1343 
    goto return_label;
  }
  else ;
  
#line 1346 
  skb_set_transport_header(skb,(int)((unsigned int)skb->mac_len + 14U));
  
#line 1347 
  __retres = 0;
  return_label: 
#line 1347 
                return __retres;
}


#line 1357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static netdev_tx_t i40e_fcoe_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
{
  netdev_tx_t __retres;
  struct i40e_tx_buffer *first;
  int fso;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  
#line 1360 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)skb->dev);
  
#line 1361 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1362 
  struct i40e_ring *tx_ring = *(vsi->tx_rings + (int)skb->queue_mapping);
  
#line 1364 
  u32 tx_flags = 0U;
  
#line 1365 
  u8 hdr_len = (unsigned char)0U;
  
#line 1366 
  u8 sof = (unsigned char)0U;
  
#line 1367 
  u8 eof = (unsigned char)0U;
  
#line 1370 
  tmp_0 = i40e_fcoe_set_skb_header(skb);
  
#line 1370 
  if (tmp_0 != 0) 
#line 1371 
                  goto out_drop; else ;
  
#line 1373 
  tmp_1 = i40e_xmit_descriptor_count(skb,tx_ring);
  
#line 1373 
  if (tmp_1 == 0) {
    
#line 1374 
    __retres = NETDEV_TX_BUSY;
    
#line 1374 
    goto return_label;
  }
  else ;
  
#line 1377 
  tmp_2 = i40e_tx_prepare_vlan_flags(skb,tx_ring,& tx_flags);
  
#line 1377 
  if (tmp_2 != 0) 
#line 1378 
                  goto out_drop; else ;
  
#line 1381 
  first = tx_ring->__anonCompField_i40e_ring_121.tx_bi + (int)tx_ring->next_to_use;
  
#line 1384 
  if ((unsigned int)skb->protocol == 5257U) 
#line 1385 
                                            goto out_send; else ;
  
#line 1388 
  tmp_3 = i40e_fcoe_fc_sof(skb,& sof);
  
#line 1388 
  if (tmp_3 != 0) 
#line 1388 
                  goto _LOR;
  else {
    int tmp_4;
    
#line 1388 
    tmp_4 = i40e_fcoe_fc_eof(skb,& eof);
    
#line 1388 
    if (tmp_4 != 0) {
      _LOR: {
              
#line 1389 
              netdev_err((struct net_device const *)netdev,"SOF/EOF error:%02x - %02x\n",(int)sof,(int)eof);
              
#line 1390 
              goto out_drop;
            }
    }
    else ;
  }
  
#line 1394 
  tx_flags |= 64U;
  
#line 1397 
  fso = i40e_fcoe_tso(tx_ring,skb,tx_flags,& hdr_len,(unsigned char)((int)sof));
  
#line 1398 
  if (fso < 0) 
#line 1399 
               goto out_drop;
  else 
    
#line 1400 
    if (fso != 0) 
#line 1401 
                  tx_flags |= 128U; else 
#line 1403 
                                         i40e_fcoe_handle_ddp(tx_ring,skb,(unsigned char)((int)sof));
  out_send: 
#line 1405 
  ;
  
#line 1407 
  i40e_fcoe_tx_map(tx_ring,skb,first,tx_flags,(unsigned char)((int)hdr_len),(unsigned char)((int)eof));
  
#line 1409 
  i40e_maybe_stop_tx(tx_ring,21);
  
#line 1410 
  __retres = NETDEV_TX_OK;
  
#line 1410 
  goto return_label;
  out_drop: 
#line 1412 
  ;
  
#line 1413 
  dev_kfree_skb_any(skb);
  
#line 1414 
  __retres = NETDEV_TX_OK;
  return_label: 
#line 1414 
                return __retres;
}


#line 1425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static int i40e_fcoe_change_mtu(struct net_device *netdev, int new_mtu)
{
  int __retres;
  
#line 1427 
  netdev_warn((struct net_device const *)netdev,"MTU change is not supported on FCoE interfaces\n");
  
#line 1428 
  __retres = -1;
  
#line 1428 
  return __retres;
}


#line 1437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static int i40e_fcoe_set_features(struct net_device *netdev, netdev_features_t features)
{
  int __retres;
  
#line 1440 
  struct i40e_netdev_priv *np = netdev_priv((struct net_device const *)netdev);
  
#line 1441 
  struct i40e_vsi *vsi = np->vsi;
  
#line 1443 
  if ((features & 256ULL) != 0ULL) 
#line 1444 
                                   i40e_vlan_stripping_enable(vsi); else 
                                                                    
#line 1446 
                                                                    i40e_vlan_stripping_disable(vsi);
  
#line 1448 
  __retres = 0;
  
#line 1448 
  return __retres;
}


#line 1451  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static struct net_device_ops const i40e_fcoe_netdev_ops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & i40e_open, .ndo_stop = & i40e_close, .ndo_start_xmit = & i40e_fcoe_xmit_frame, .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & i40e_set_rx_mode, .ndo_set_mac_address = & i40e_set_mac, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & i40e_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & i40e_fcoe_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = & i40e_tx_timeout, .ndo_get_stats64 = & i40e_get_netdev_stats_struct, .ndo_get_stats = (struct net_device_stats *(*)(struct net_device *))0, .ndo_vlan_rx_add_vid = & i40e_vlan_rx_add_vid, .ndo_vlan_rx_kill_vid = & i40e_vlan_rx_kill_vid, .ndo_poll_controller = & i40e_netpoll, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = (int (*)(struct napi_struct *))0, .ndo_set_vf_mac = (int (*)(struct net_device *, int , u8 *))0, .ndo_set_vf_vlan = (int (*)(struct net_device *, int , u16 , u8 ))0, .ndo_set_vf_rate = (int (*)(struct net_device *, int , int , int ))0, .ndo_set_vf_spoofchk = (int (*)(struct net_device *, int , bool ))0, .ndo_get_vf_config = (int (*)(struct net_device *, int , struct ifla_vf_info *))0, .ndo_set_vf_link_state = (int (*)(struct net_device *, int , int ))0, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = & i40e_setup_tc, .ndo_fcoe_enable = & i40e_fcoe_enable, .ndo_fcoe_disable = & i40e_fcoe_disable, .ndo_fcoe_ddp_setup = & i40e_fcoe_ddp_get, .ndo_fcoe_ddp_done = & i40e_fcoe_ddp_put, .ndo_fcoe_ddp_target = & i40e_fcoe_ddp_target, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = (int (*)(struct net_device *, struct sk_buff const *, u16 , u32 ))0, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = (netdev_features_t (*)(struct net_device *, netdev_features_t ))0, .ndo_set_features = & i40e_fcoe_set_features, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ))0, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = (int (*)(struct net_device *, struct netdev_phys_item_id *))0, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_del_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_dfwd_add_station = (void *(*)(struct net_device *, struct net_device *))0, .ndo_dfwd_del_station = (void (*)(struct net_device *, void *))0, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = (netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t ))0, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 1478  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
static struct device_type fcoe_netdev_type = {.name = "fcoe", .groups = (struct attribute_group const **)0, .uevent = (int (*)(struct device *, struct kobj_uevent_env *))0, .devnode = (char *(*)(struct device *, umode_t *, kuid_t *, kgid_t *))0, .release = (void (*)(struct device *))0, .pm = (struct dev_pm_ops const *)0};

#line 1489  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
void i40e_fcoe_config_netdev(struct net_device *netdev, struct i40e_vsi *vsi)
{
  
#line 1491 
  struct i40e_hw *hw = & (vsi->back)->hw;
  
#line 1492 
  struct i40e_pf *pf = vsi->back;
  
#line 1494 
  if (vsi->type != (unsigned int)I40E_VSI_FCOE) 
#line 1495 
                                                goto return_label; else ;
  
#line 1497 
  netdev->features = 896ULL;
  
#line 1501 
  netdev->vlan_features = netdev->features;
  
#line 1502 
  netdev->vlan_features &= 18446744073709550719ULL;
  
#line 1505 
  netdev->fcoe_ddp_xid = 2047U;
  
#line 1506 
  netdev->features |= 2686451712ULL;
  
#line 1507 
  netdev->vlan_features |= 2686451712ULL;
  
#line 1508 
  netdev->hw_features |= netdev->features;
  
#line 1509 
  netdev->priv_flags |= 131072U;
  
#line 1510 
  netdev->priv_flags |= 524288U;
  
#line 1512 
  strlcpy((char *)(& netdev->name),"fcoe%d",15UL);
  
#line 1513 
  netdev->mtu = 2158U;
  
#line 1514 
  netdev->dev.parent = & (pf->pdev)->dev;
  
#line 1515 
  netdev->dev.type = (struct device_type const *)(& fcoe_netdev_type);
  
#line 1521 
  netdev->dev_port = (unsigned short)1U;
  
#line 1522 
  i40e_add_filter(vsi,(u8 *)(& hw->mac.san_addr),(short)0,(_Bool)0,(_Bool)0);
  
#line 1523 
  u8 __constr_expr_40[6U] = {(unsigned char)14U, (unsigned char)252U, (unsigned char)0U, (unsigned char)255U, (unsigned char)255U, (unsigned char)254U};
  
#line 1523 
  ;
  
#line 1523 
  i40e_add_filter(vsi,(u8 *)(& __constr_expr_40),(short)0,(_Bool)0,(_Bool)0);
  
#line 1524 
  __u8 __constr_expr_41[6U] = {(unsigned char)1U, (unsigned char)16U, (unsigned char)24U, (unsigned char)1U, (unsigned char)0U, (unsigned char)0U};
  
#line 1524 
  ;
  
#line 1524 
  i40e_add_filter(vsi,(u8 *)(& __constr_expr_41),(short)0,(_Bool)0,(_Bool)0);
  
#line 1525 
  __u8 __constr_expr_42[6U] = {(unsigned char)1U, (unsigned char)16U, (unsigned char)24U, (unsigned char)1U, (unsigned char)0U, (unsigned char)1U};
  
#line 1525 
  ;
  
#line 1525 
  i40e_add_filter(vsi,(u8 *)(& __constr_expr_42),(short)0,(_Bool)0,(_Bool)0);
  
#line 1528 
  ether_addr_copy(netdev->dev_addr,(u8 const *)(& hw->mac.san_addr));
  
#line 1529 
  ether_addr_copy((u8 *)(& netdev->perm_addr),(u8 const *)(& hw->mac.san_addr));
  
#line 1531 
  netdev->netdev_ops = & i40e_fcoe_netdev_ops;
  return_label: 
#line 1532 
                return;
}


#line 1539  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c"
void i40e_fcoe_vsi_setup(struct i40e_pf *pf)
{
  struct i40e_vsi *vsi;
  u16 seid;
  int i;
  
#line 1545 
  if ((pf->flags & 2048ULL) == 0ULL) 
#line 1546 
                                     goto return_label; else ;
  
#line 1548 
  if ((long)(*(pf->vsi + (int)pf->lan_vsi) == (struct i40e_vsi *)0) != 0L) {
    
#line 1550 
    ldv_inline_asm();
    
#line 1548 
    ;
  }
  else ;
  
#line 1550 
  i = 0;
  
#line 1550 
  goto ldv_68431;
  ldv_68430: 
#line 1551 
  ;
  
#line 1551 
  vsi = *(pf->vsi + i);
  
#line 1552 
  if (vsi != (struct i40e_vsi *)0 && vsi->type == (unsigned int)I40E_VSI_FCOE) {
    
#line 1553 
    dev_warn((struct device const *)(& (pf->pdev)->dev),"FCoE VSI already created\n");
    
#line 1555 
    goto return_label;
  }
  else ;
  
#line 1550 
  i += 1;
  ldv_68431: 
#line 1551 
  ;
  
#line 1550 
  if ((int)pf->num_alloc_vsi > i) 
#line 1552 
                                  goto ldv_68430; else 
#line 1555 
                                                       goto ldv_68432;
  ldv_68432: 
#line 1556 
  ;
  
#line 1559 
  seid = (*(pf->vsi + (int)pf->lan_vsi))->seid;
  
#line 1560 
  vsi = i40e_vsi_setup(pf,(unsigned char)4,(unsigned short)((int)seid),0U);
  
#line 1561 
  if (vsi != (struct i40e_vsi *)0) {
    
#line 1562 
    struct _ddebug descriptor = {.modname = "i40e", .function = "i40e_fcoe_vsi_setup", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_fcoe.c", .format = "Successfully created FCoE VSI seid %d id %d uplink_seid %d PF seid %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1564U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1562 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 1562 
                                                        __dynamic_dev_dbg(& descriptor,(struct device const *)(& (pf->pdev)->dev),"Successfully created FCoE VSI seid %d id %d uplink_seid %d PF seid %d\n",(int)vsi->seid,(int)vsi->id,(int)vsi->uplink_seid,(int)seid); else ;
  }
  else 
#line 1566 
       _dev_info((struct device const *)(& (pf->pdev)->dev),"Failed to create FCoE VSI\n");
  return_label: 
#line 1567 
                return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
int (*ldv_emg_alias_eth_validate_addr_30)(struct net_device *) = & eth_validate_addr;

#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
int ldv_emg_wrapper_i40e_fcoe_ddp_put_44(struct net_device *arg0, unsigned short arg1)
{
  int tmp;
  
#line 74 
  tmp = i40e_fcoe_ddp_put(arg0,(unsigned short)((int)arg1));
  
#line 74 
  return tmp;
}


#line 78  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
int ldv_emg_wrapper_i40e_fcoe_ddp_get_11(struct net_device *arg0, unsigned short arg1, struct scatterlist *arg2, unsigned int arg3)
{
  int tmp;
  
#line 79 
  tmp = i40e_fcoe_ddp_get(arg0,(unsigned short)((int)arg1),arg2,arg3);
  
#line 79 
  return tmp;
}


#line 83  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
int ldv_emg_wrapper_i40e_fcoe_change_mtu_5(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 84 
  tmp = i40e_fcoe_change_mtu(arg0,arg1);
  
#line 84 
  return tmp;
}


#line 88  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
enum netdev_tx ldv_emg_wrapper_i40e_fcoe_xmit_frame_14(struct sk_buff *arg0, struct net_device *arg1)
{
  enum netdev_tx tmp;
  
#line 89 
  tmp = i40e_fcoe_xmit_frame(arg0,arg1);
  
#line 89 
  return tmp;
}


#line 93  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
int ldv_emg_wrapper_i40e_fcoe_ddp_target_20(struct net_device *arg0, unsigned short arg1, struct scatterlist *arg2, unsigned int arg3)
{
  int tmp;
  
#line 94 
  tmp = i40e_fcoe_ddp_target(arg0,(unsigned short)((int)arg1),arg2,arg3);
  
#line 94 
  return tmp;
}


#line 152  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
static void atomic_inc_0(atomic_t *v)
{
  
#line 155 
  ldv_atomic_inc(v);
  
#line 156 
  return;
}


#line 166  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_fcoe.c.aux"
static int atomic_dec_and_test(atomic_t *v)
{
  int tmp;
  
#line 169 
  tmp = ldv_atomic_dec_and_test(v);
  
#line 169 
  return tmp;
}


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
i40e_status i40e_add_sd_table_entry(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 sd_index, enum i40e_sd_entry_type type, u64 direct_mode_sz);


#line 219 
i40e_status i40e_add_pd_table_entry(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 pd_index);


#line 222 
i40e_status i40e_remove_pd_bp(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx);


#line 225 
i40e_status i40e_prep_remove_sd_bp(struct i40e_hmc_info *hmc_info, u32 idx);


#line 227 
i40e_status i40e_remove_sd_bp_new(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx, bool is_pf);


#line 230 
i40e_status i40e_prep_remove_pd_page(struct i40e_hmc_info *hmc_info, u32 idx);


#line 232 
i40e_status i40e_remove_pd_page_new(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx, bool is_pf);


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static u64 i40e_align_l2obj_base(u64 offset)
{
  
#line 44 
  u64 aligned_offset = offset;
  
#line 46 
  if ((offset & 511ULL) != 0ULL) 
#line 47 
                                 aligned_offset = (aligned_offset - (offset & 511ULL)) + 512ULL; else ;
  
#line 50 
  return aligned_offset;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static u64 i40e_calculate_l2fpm_size(u32 txq_num, u32 rxq_num, u32 fcoe_cntx_num, u32 fcoe_filt_num)
{
  
#line 66 
  u64 fpm_size = 0ULL;
  
#line 68 
  fpm_size = (unsigned long long)(txq_num * 128U);
  
#line 69 
  fpm_size = i40e_align_l2obj_base(fpm_size);
  
#line 71 
  fpm_size = (unsigned long long)(rxq_num * 32U) + fpm_size;
  
#line 72 
  fpm_size = i40e_align_l2obj_base(fpm_size);
  
#line 74 
  fpm_size = (unsigned long long)(fcoe_cntx_num * 64U) + fpm_size;
  
#line 75 
  fpm_size = i40e_align_l2obj_base(fpm_size);
  
#line 77 
  fpm_size = (unsigned long long)(fcoe_filt_num * 64U) + fpm_size;
  
#line 78 
  fpm_size = i40e_align_l2obj_base(fpm_size);
  
#line 80 
  return fpm_size;
}


#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_init_lan_hmc(struct i40e_hw *hw, u32 txq_num, u32 rxq_num, u32 fcoe_cntx_num, u32 fcoe_filt_num)
{
  struct i40e_hmc_obj_info *obj;
  struct i40e_hmc_obj_info *full_obj;
  u64 l2fpm_size;
  u32 size_exp;
  
#line 104 
  i40e_status ret_code = 0;
  
#line 108 
  hw->hmc.signature = 1213027143U;
  
#line 109 
  hw->hmc.hmc_fn_id = hw->pf_id;
  
#line 112 
  ret_code = i40e_allocate_virt_mem_d(hw,& hw->hmc.hmc_obj_virt_mem,120U);
  
#line 114 
  if (ret_code != I40E_SUCCESS) 
#line 115 
                                goto init_lan_hmc_out; else ;
  
#line 116 
  hw->hmc.hmc_obj = (struct i40e_hmc_obj_info *)hw->hmc.hmc_obj_virt_mem.va;
  
#line 120 
  full_obj = hw->hmc.hmc_obj;
  
#line 121 
  full_obj->max_cnt = 0U;
  
#line 122 
  full_obj->cnt = 0U;
  
#line 123 
  full_obj->base = 0ULL;
  
#line 124 
  full_obj->size = 0ULL;
  
#line 127 
  obj = hw->hmc.hmc_obj + 1U;
  
#line 128 
  obj->max_cnt = readl((void const volatile *)(hw->hw_addr + 794632U));
  
#line 129 
  obj->cnt = txq_num;
  
#line 130 
  obj->base = 0ULL;
  
#line 131 
  size_exp = readl((void const volatile *)(hw->hw_addr + 794628U));
  
#line 132 
  obj->size = 1ULL << size_exp;
  
#line 135 
  if (obj->max_cnt < txq_num) {
    
#line 136 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    
#line 139 
    goto init_lan_hmc_out;
  }
  else ;
  
#line 143 
  full_obj->max_cnt += obj->max_cnt;
  
#line 144 
  full_obj->cnt += obj->cnt;
  
#line 147 
  obj = hw->hmc.hmc_obj + 2U;
  
#line 148 
  obj->max_cnt = readl((void const volatile *)(hw->hw_addr + 794632U));
  
#line 149 
  obj->cnt = rxq_num;
  
#line 150 
  obj->base = (hw->hmc.hmc_obj + 1U)->base + (unsigned long long)(hw->hmc.hmc_obj + 1U)->cnt * (hw->hmc.hmc_obj + 1U)->size;
  
#line 153 
  obj->base = i40e_align_l2obj_base(obj->base);
  
#line 154 
  size_exp = readl((void const volatile *)(hw->hw_addr + 794636U));
  
#line 155 
  obj->size = 1ULL << size_exp;
  
#line 158 
  if (obj->max_cnt < rxq_num) {
    
#line 159 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    
#line 162 
    goto init_lan_hmc_out;
  }
  else ;
  
#line 166 
  full_obj->max_cnt += obj->max_cnt;
  
#line 167 
  full_obj->cnt += obj->cnt;
  
#line 170 
  obj = hw->hmc.hmc_obj + 3U;
  
#line 171 
  obj->max_cnt = readl((void const volatile *)(hw->hw_addr + 794644U));
  
#line 172 
  obj->cnt = fcoe_cntx_num;
  
#line 173 
  obj->base = (hw->hmc.hmc_obj + 2U)->base + (unsigned long long)(hw->hmc.hmc_obj + 2U)->cnt * (hw->hmc.hmc_obj + 2U)->size;
  
#line 176 
  obj->base = i40e_align_l2obj_base(obj->base);
  
#line 177 
  size_exp = readl((void const volatile *)(hw->hw_addr + 794640U));
  
#line 178 
  obj->size = 1ULL << size_exp;
  
#line 181 
  if (obj->max_cnt < fcoe_cntx_num) {
    
#line 182 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    
#line 185 
    goto init_lan_hmc_out;
  }
  else ;
  
#line 189 
  full_obj->max_cnt += obj->max_cnt;
  
#line 190 
  full_obj->cnt += obj->cnt;
  
#line 193 
  obj = hw->hmc.hmc_obj + 4U;
  
#line 194 
  obj->max_cnt = readl((void const volatile *)(hw->hw_addr + 794832U));
  
#line 195 
  obj->cnt = fcoe_filt_num;
  
#line 196 
  obj->base = (hw->hmc.hmc_obj + 3U)->base + (unsigned long long)(hw->hmc.hmc_obj + 3U)->cnt * (hw->hmc.hmc_obj + 3U)->size;
  
#line 199 
  obj->base = i40e_align_l2obj_base(obj->base);
  
#line 200 
  size_exp = readl((void const volatile *)(hw->hw_addr + 794648U));
  
#line 201 
  obj->size = 1ULL << size_exp;
  
#line 204 
  if (obj->max_cnt < fcoe_filt_num) {
    
#line 205 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    
#line 208 
    goto init_lan_hmc_out;
  }
  else ;
  
#line 212 
  full_obj->max_cnt += obj->max_cnt;
  
#line 213 
  full_obj->cnt += obj->cnt;
  
#line 215 
  hw->hmc.first_sd_index = (unsigned short)0U;
  
#line 216 
  hw->hmc.sd_table.ref_cnt = 0U;
  
#line 217 
  l2fpm_size = i40e_calculate_l2fpm_size(txq_num,rxq_num,fcoe_cntx_num,fcoe_filt_num);
  
#line 219 
  if (hw->hmc.sd_table.sd_entry == (struct i40e_hmc_sd_entry *)0) {
    
#line 220 
    hw->hmc.sd_table.sd_cnt = ((unsigned int)l2fpm_size + 2097151U) / 2097152U;
    
#line 225 
    ret_code = i40e_allocate_virt_mem_d(hw,& hw->hmc.sd_table.addr,hw->hmc.sd_table.sd_cnt * 64U);
    
#line 228 
    if (ret_code != I40E_SUCCESS) 
#line 229 
                                  goto init_lan_hmc_out; else ;
    
#line 230 
    hw->hmc.sd_table.sd_entry = (struct i40e_hmc_sd_entry *)hw->hmc.sd_table.addr.va;
  }
  else ;
  
#line 234 
  full_obj->size = l2fpm_size;
  init_lan_hmc_out: 
#line 236 
  ;
  
#line 237 
  return ret_code;
}


#line 254  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_remove_pd_page(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx)
{
  i40e_status tmp;
  
#line 258 
  i40e_status ret_code = 0;
  
#line 260 
  tmp = i40e_prep_remove_pd_page(hmc_info,idx);
  
#line 260 
  if (tmp == I40E_SUCCESS) 
#line 261 
                           ret_code = i40e_remove_pd_page_new(hw,hmc_info,idx,(_Bool)1); else ;
  
#line 263 
  return ret_code;
}


#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_remove_sd_bp(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx)
{
  i40e_status tmp;
  
#line 285 
  i40e_status ret_code = 0;
  
#line 287 
  tmp = i40e_prep_remove_sd_bp(hmc_info,idx);
  
#line 287 
  if (tmp == I40E_SUCCESS) 
#line 288 
                           ret_code = i40e_remove_sd_bp_new(hw,hmc_info,idx,(_Bool)1); else ;
  
#line 290 
  return ret_code;
}


#line 301  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_create_lan_hmc_object(struct i40e_hw *hw, struct i40e_hmc_lan_create_obj_info *info)
{
  struct i40e_hmc_sd_entry *sd_entry;
  u32 sd_idx;
  u32 sd_lmt;
  u64 sd_size;
  u32 i;
  u32 j;
  
#line 304 
  i40e_status ret_code = 0;
  
#line 306 
  u32 pd_idx1 = 0U;
  
#line 306 
  u32 pd_lmt1 = 0U;
  
#line 307 
  u32 pd_idx = 0U;
  
#line 307 
  u32 pd_lmt = 0U;
  
#line 308 
  bool pd_error = (_Bool)0;
  
#line 313 
  if (info == (struct i40e_hmc_lan_create_obj_info *)0) {
    
#line 314 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 316 
    goto exit;
  }
  else ;
  
#line 318 
  if (info->hmc_info == (struct i40e_hmc_info *)0) {
    
#line 319 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 321 
    goto exit;
  }
  else ;
  
#line 323 
  if ((info->hmc_info)->signature != 1213027143U) {
    
#line 324 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 326 
    goto exit;
  }
  else ;
  
#line 329 
  if (info->start_idx >= ((info->hmc_info)->hmc_obj + info->rsrc_type)->cnt) {
    
#line 330 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_INDEX;
    
#line 333 
    goto exit;
  }
  else ;
  
#line 335 
  if (info->start_idx + info->count > ((info->hmc_info)->hmc_obj + info->rsrc_type)->cnt) {
    
#line 337 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    
#line 340 
    goto exit;
  }
  else ;
  {
    u64 fpm_addr;
    u64 fpm_limit;
    
#line 344 
    fpm_addr = ((info->hmc_info)->hmc_obj + info->rsrc_type)->base + ((info->hmc_info)->hmc_obj + info->rsrc_type)->size * (unsigned long long)info->start_idx;
    
#line 344 
    fpm_limit = ((info->hmc_info)->hmc_obj + info->rsrc_type)->size * (unsigned long long)info->count + fpm_addr;
    
#line 344 
    sd_idx = (unsigned int)(fpm_addr / 2097152ULL);
    
#line 344 
    sd_lmt = (unsigned int)((fpm_limit + 18446744073709551615ULL) / 2097152ULL);
    
#line 344 
    sd_lmt += 1U;
  }
  
#line 347 
  if ((info->hmc_info)->sd_table.sd_cnt <= sd_idx || (info->hmc_info)->sd_table.sd_cnt < sd_lmt) {
    
#line 349 
    ret_code = I40E_ERR_INVALID_SD_INDEX;
    
#line 350 
    goto exit;
  }
  else ;
  {
    u64 fpm_adr;
    u64 fpm_limit_0;
    
#line 353 
    fpm_adr = ((info->hmc_info)->hmc_obj + info->rsrc_type)->base + ((info->hmc_info)->hmc_obj + info->rsrc_type)->size * (unsigned long long)info->start_idx;
    
#line 353 
    fpm_limit_0 = ((info->hmc_info)->hmc_obj + info->rsrc_type)->size * (unsigned long long)info->count + fpm_adr;
    
#line 353 
    pd_idx = (unsigned int)(fpm_adr / 4096ULL);
    
#line 353 
    pd_lmt = (unsigned int)((fpm_limit_0 + 18446744073709551615ULL) / 4096ULL);
    
#line 353 
    pd_lmt += 1U;
  }
  
#line 361 
  if (info->direct_mode_sz == 0ULL) 
#line 362 
                                    sd_size = 2097152ULL; else 
#line 364 
                                                               sd_size = info->direct_mode_sz;
  
#line 369 
  j = sd_idx;
  
#line 369 
  goto ldv_52995;
  ldv_52994: 
#line 370 
  ;
  
#line 371 
  ret_code = i40e_add_sd_table_entry(hw,info->hmc_info,j,info->entry_type,sd_size);
  
#line 374 
  if (ret_code != I40E_SUCCESS) 
#line 375 
                                goto exit_sd_error; else ;
  
#line 376 
  sd_entry = (info->hmc_info)->sd_table.sd_entry + j;
  
#line 377 
  if (sd_entry->entry_type == (unsigned int)I40E_SD_TYPE_PAGED) {
    u32 tmp_0;
    u32 tmp_2;
    {
      u32 tmp;
      
#line 383 
      u32 _max1 = pd_idx;
      
#line 383 
      u32 _max2 = j * 512U;
      
#line 383 
      if (_max1 > _max2) 
#line 383 
                         tmp = _max1; else 
#line 383 
                                           tmp = _max2;
      
#line 383 
      tmp_0 = tmp;
    }
    
#line 383 
    pd_idx1 = tmp_0;
    {
      u32 tmp_1;
      
#line 384 
      u32 _min1 = pd_lmt;
      
#line 384 
      u32 _min2 = (j + 1U) * 512U;
      
#line 384 
      if (_min1 < _min2) 
#line 384 
                         tmp_1 = _min1; else 
#line 384 
                                             tmp_1 = _min2;
      
#line 384 
      tmp_2 = tmp_1;
    }
    
#line 384 
    pd_lmt1 = tmp_2;
    
#line 386 
    i = pd_idx1;
    
#line 386 
    goto ldv_52980;
    ldv_52979: 
#line 387 
    ;
    
#line 388 
    ret_code = i40e_add_pd_table_entry(hw,info->hmc_info,i);
    
#line 391 
    if (ret_code != I40E_SUCCESS) {
      
#line 392 
      pd_error = (_Bool)1;
      
#line 393 
      goto ldv_52978;
    }
    else ;
    
#line 386 
    i += 1U;
    ldv_52980: 
#line 387 
    ;
    
#line 386 
    if (i < pd_lmt1) 
#line 388 
                     goto ldv_52979; else 
#line 391 
                                          goto ldv_52978;
    ldv_52978: 
#line 392 
    ;
    
#line 396 
    if ((int)pd_error != 0) {
      
#line 398 
      goto ldv_52982;
      ldv_52981: 
#line 399 
      ;
      
#line 399 
      i40e_remove_pd_bp(hw,info->hmc_info,i + 4294967295U);
      
#line 401 
      i -= 1U;
      ldv_52982: 
#line 402 
      ;
      
#line 398 
      if (i != 0U && i > pd_idx1) 
#line 400 
                                  goto ldv_52981; else 
#line 403 
                                                       goto ldv_52983;
      ldv_52983: 
#line 404 
      ;
    }
    else ;
  }
  else ;
  
#line 405 
  if (! sd_entry->valid) {
    
#line 406 
    sd_entry->valid = (_Bool)1;
    
#line 407 
    switch ((unsigned int)sd_entry->entry_type) {
      case (unsigned int)1: 
#line 408 
      ;
      {
        u32 val1;
        u32 val2;
        u32 val3;
        int tmp_3;
        
#line 409 
        val1 = (unsigned int)(sd_entry->u.pd_table.pd_page_addr.pa >> 32);
        
#line 409 
        if (sd_entry->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) 
          
#line 409 
          tmp_3 = 2; else 
#line 409 
                          tmp_3 = 0;
        
#line 409 
        val2 = ((unsigned int)sd_entry->u.pd_table.pd_page_addr.pa | (unsigned int)tmp_3) | 2049U;
        
#line 409 
        val3 = j | 2147483648U;
        
#line 409 
        writel(val1,(void volatile *)(hw->hw_addr + 786944U));
        
#line 409 
        writel(val2,(void volatile *)(hw->hw_addr + 786688U));
        
#line 409 
        writel(val3,(void volatile *)(hw->hw_addr + 786432U));
      }
      
#line 412 
      goto ldv_52988;
      case (unsigned int)2: 
#line 413 
      ;
      {
        u32 val1_0;
        u32 val2_0;
        u32 val3_0;
        int tmp_4;
        
#line 414 
        val1_0 = (unsigned int)(sd_entry->u.bp.addr.pa >> 32);
        
#line 414 
        if (sd_entry->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) 
          
#line 414 
          tmp_4 = 2; else 
#line 414 
                          tmp_4 = 0;
        
#line 414 
        val2_0 = ((unsigned int)sd_entry->u.bp.addr.pa | (unsigned int)tmp_4) | 2049U;
        
#line 414 
        val3_0 = j | 2147483648U;
        
#line 414 
        writel(val1_0,(void volatile *)(hw->hw_addr + 786944U));
        
#line 414 
        writel(val2_0,(void volatile *)(hw->hw_addr + 786688U));
        
#line 414 
        writel(val3_0,(void volatile *)(hw->hw_addr + 786432U));
      }
      
#line 416 
      goto ldv_52988;
      default: 
#line 417 
      ;
      
#line 418 
      ret_code = I40E_ERR_INVALID_SD_TYPE;
      
#line 419 
      goto exit;
    }
    ldv_52988: 
#line 421 
    ;
  }
  else ;
  
#line 369 
  j += 1U;
  ldv_52995: 
#line 370 
  ;
  
#line 369 
  if (j < sd_lmt) 
#line 371 
                  goto ldv_52994; else 
#line 374 
                                       goto ldv_52996;
  ldv_52996: 
#line 375 
  ;
  
#line 423 
  goto exit;
  exit_sd_error: 
#line 425 
  ;
  
#line 427 
  goto ldv_53011;
  ldv_53010: 
#line 428 
  ;
  
#line 428 
  sd_entry = (info->hmc_info)->sd_table.sd_entry + (j + 4294967295U);
  
#line 429 
  switch ((unsigned int)sd_entry->entry_type) {
    u32 tmp_6;
    u32 tmp_8;
    case (unsigned int)1: 
#line 430 
    ;
    {
      u32 tmp_5;
      
#line 431 
      u32 _max1_0 = pd_idx;
      
#line 431 
      u32 _max2_0 = (j + 8388607U) * 512U;
      
#line 431 
      if (_max1_0 > _max2_0) 
#line 431 
                             tmp_5 = _max1_0; else 
#line 431 
                                                   tmp_5 = _max2_0;
      
#line 431 
      tmp_6 = tmp_5;
    }
    
#line 431 
    pd_idx1 = tmp_6;
    {
      u32 tmp_7;
      
#line 433 
      u32 _min1_0 = pd_lmt;
      
#line 433 
      u32 _min2_0 = j * 512U;
      
#line 433 
      if (_min1_0 < _min2_0) 
#line 433 
                             tmp_7 = _min1_0; else 
#line 433 
                                                   tmp_7 = _min2_0;
      
#line 433 
      tmp_8 = tmp_7;
    }
    
#line 433 
    pd_lmt1 = tmp_8;
    
#line 434 
    i = pd_idx1;
    
#line 434 
    goto ldv_53005;
    ldv_53004: 
#line 435 
    ;
    
#line 435 
    i40e_remove_pd_bp(hw,info->hmc_info,i);
    
#line 434 
    i += 1U;
    ldv_53005: 
#line 435 
    ;
    
#line 434 
    if (i < pd_lmt1) 
#line 436 
                     goto ldv_53004; else 
#line 439 
                                          goto ldv_53006;
    ldv_53006: 
#line 440 
    ;
    
#line 437 
    i40e_remove_pd_page(hw,info->hmc_info,j + 4294967295U);
    
#line 438 
    goto ldv_53007;
    case (unsigned int)2: 
#line 439 
    ;
    
#line 440 
    i40e_remove_sd_bp(hw,info->hmc_info,j + 4294967295U);
    
#line 441 
    goto ldv_53007;
    default: 
#line 442 
    ;
    
#line 443 
    ret_code = I40E_ERR_INVALID_SD_TYPE;
    
#line 444 
    goto ldv_53007;
  }
  ldv_53007: 
#line 446 
  ;
  
#line 446 
  j -= 1U;
  ldv_53011: 
#line 447 
  ;
  
#line 427 
  if (j != 0U && j > sd_idx) 
#line 429 
                             goto ldv_53010; else 
#line 432 
                                                  goto ldv_53012;
  ldv_53012: 
#line 433 
  ;
  exit: 
#line 448 
  ;
  
#line 449 
  return ret_code;
}


#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_configure_lan_hmc(struct i40e_hw *hw, enum i40e_hmc_model model)
{
  struct i40e_hmc_lan_create_obj_info info;
  struct i40e_hmc_obj_info *obj;
  
#line 465 
  i40e_status ret_code = 0;
  
#line 466 
  u8 hmc_fn_id = hw->hmc.hmc_fn_id;
  
#line 470 
  info.hmc_info = & hw->hmc;
  
#line 471 
  info.rsrc_type = 0U;
  
#line 472 
  info.start_idx = 0U;
  
#line 473 
  info.direct_mode_sz = (hw->hmc.hmc_obj)->size;
  
#line 476 
  switch ((unsigned int)model) {
    case (unsigned int)0: 
#line 477 
    ;
    case (unsigned int)1: 
#line 478 
    ;
    
#line 479 
    info.entry_type = I40E_SD_TYPE_DIRECT;
    
#line 481 
    info.count = 1U;
    
#line 482 
    ret_code = i40e_create_lan_hmc_object(hw,& info);
    
#line 483 
    if (ret_code != I40E_SUCCESS && model == (unsigned int)I40E_HMC_MODEL_DIRECT_PREFERRED) 
      
#line 484 
      goto try_type_paged;
    else 
      
#line 485 
      if (ret_code != I40E_SUCCESS) 
#line 486 
                                    goto configure_lan_hmc_out; else ;
    
#line 488 
    goto ldv_53025;
    case (unsigned int)2: 
#line 489 
    ;
    try_type_paged: 
#line 490 
    ;
    
#line 491 
    info.entry_type = I40E_SD_TYPE_PAGED;
    
#line 493 
    info.count = 1U;
    
#line 494 
    ret_code = i40e_create_lan_hmc_object(hw,& info);
    
#line 495 
    if (ret_code != I40E_SUCCESS) 
#line 496 
                                  goto configure_lan_hmc_out; else ;
    
#line 497 
    goto ldv_53025;
    default: 
#line 498 
    ;
    
#line 500 
    ret_code = I40E_ERR_INVALID_SD_TYPE;
    
#line 503 
    goto configure_lan_hmc_out;
  }
  ldv_53025: 
#line 509 
  ;
  
#line 509 
  obj = hw->hmc.hmc_obj + 1U;
  
#line 510 
  writel((unsigned int)((obj->base & 16777215ULL) / 512ULL),(void volatile *)(hw->hw_addr + ((int)hmc_fn_id + 202880) * 4));
  
#line 512 
  writel(obj->cnt,(void volatile *)(hw->hw_addr + ((int)hmc_fn_id + 202944) * 4));
  
#line 515 
  obj = hw->hmc.hmc_obj + 2U;
  
#line 516 
  writel((unsigned int)((obj->base & 16777215ULL) / 512ULL),(void volatile *)(hw->hw_addr + ((int)hmc_fn_id + 203008) * 4));
  
#line 518 
  writel(obj->cnt,(void volatile *)(hw->hw_addr + ((int)hmc_fn_id + 203072) * 4));
  
#line 521 
  obj = hw->hmc.hmc_obj + 3U;
  
#line 522 
  writel((unsigned int)((obj->base & 16777215ULL) / 512ULL),(void volatile *)(hw->hw_addr + ((int)hmc_fn_id + 203136) * 4));
  
#line 524 
  writel(obj->cnt,(void volatile *)(hw->hw_addr + ((int)hmc_fn_id + 203200) * 4));
  
#line 527 
  obj = hw->hmc.hmc_obj + 4U;
  
#line 528 
  writel((unsigned int)((obj->base & 16777215ULL) / 512ULL),(void volatile *)(hw->hw_addr + ((int)hmc_fn_id + 203264) * 4));
  
#line 530 
  writel(obj->cnt,(void volatile *)(hw->hw_addr + ((int)hmc_fn_id + 203328) * 4));
  configure_lan_hmc_out: 
#line 532 
  ;
  
#line 533 
  return ret_code;
}


#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_delete_lan_hmc_object(struct i40e_hw *hw, struct i40e_hmc_lan_delete_obj_info *info)
{
  struct i40e_hmc_pd_table *pd_table;
  u32 pd_idx;
  u32 pd_lmt;
  u32 rel_pd_idx;
  u32 sd_idx;
  u32 sd_lmt;
  u32 i;
  u32 j;
  
#line 549 
  i40e_status ret_code = 0;
  
#line 555 
  if (info == (struct i40e_hmc_lan_delete_obj_info *)0) {
    
#line 556 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 558 
    goto exit;
  }
  else ;
  
#line 560 
  if (info->hmc_info == (struct i40e_hmc_info *)0) {
    
#line 561 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 563 
    goto exit;
  }
  else ;
  
#line 565 
  if ((info->hmc_info)->signature != 1213027143U) {
    
#line 566 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 568 
    goto exit;
  }
  else ;
  
#line 571 
  if ((info->hmc_info)->sd_table.sd_entry == (struct i40e_hmc_sd_entry *)0) {
    
#line 572 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 574 
    goto exit;
  }
  else ;
  
#line 577 
  if ((info->hmc_info)->hmc_obj == (struct i40e_hmc_obj_info *)0) {
    
#line 578 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 580 
    goto exit;
  }
  else ;
  
#line 582 
  if (info->start_idx >= ((info->hmc_info)->hmc_obj + info->rsrc_type)->cnt) {
    
#line 583 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_INDEX;
    
#line 586 
    goto exit;
  }
  else ;
  
#line 589 
  if (info->start_idx + info->count > ((info->hmc_info)->hmc_obj + info->rsrc_type)->cnt) {
    
#line 591 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    
#line 594 
    goto exit;
  }
  else ;
  {
    u64 fpm_adr;
    u64 fpm_limit;
    
#line 597 
    fpm_adr = ((info->hmc_info)->hmc_obj + info->rsrc_type)->base + ((info->hmc_info)->hmc_obj + info->rsrc_type)->size * (unsigned long long)info->start_idx;
    
#line 597 
    fpm_limit = ((info->hmc_info)->hmc_obj + info->rsrc_type)->size * (unsigned long long)info->count + fpm_adr;
    
#line 597 
    pd_idx = (unsigned int)(fpm_adr / 4096ULL);
    
#line 597 
    pd_lmt = (unsigned int)((fpm_limit + 18446744073709551615ULL) / 4096ULL);
    
#line 597 
    pd_lmt += 1U;
  }
  
#line 601 
  j = pd_idx;
  
#line 601 
  goto ldv_53046;
  ldv_53045: 
#line 602 
  ;
  
#line 602 
  sd_idx = j / 512U;
  
#line 604 
  if (((info->hmc_info)->sd_table.sd_entry + sd_idx)->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) 
    
#line 606 
    goto ldv_53044; else ;
  
#line 608 
  rel_pd_idx = j & 511U;
  
#line 610 
  pd_table = & ((info->hmc_info)->sd_table.sd_entry + sd_idx)->u.pd_table;
  
#line 612 
  if ((int)(pd_table->pd_entry + rel_pd_idx)->valid != 0) {
    
#line 613 
    ret_code = i40e_remove_pd_bp(hw,info->hmc_info,j);
    
#line 614 
    if (ret_code != I40E_SUCCESS) 
#line 615 
                                  goto exit; else ;
  }
  else ;
  ldv_53044: 
#line 617 
  ;
  
#line 601 
  j += 1U;
  ldv_53046: 
#line 602 
  ;
  
#line 601 
  if (j < pd_lmt) 
#line 603 
                  goto ldv_53045; else 
#line 606 
                                       goto ldv_53047;
  ldv_53047: 
#line 607 
  ;
  {
    u64 fpm_addr;
    u64 fpm_limit_0;
    
#line 620 
    fpm_addr = ((info->hmc_info)->hmc_obj + info->rsrc_type)->base + ((info->hmc_info)->hmc_obj + info->rsrc_type)->size * (unsigned long long)info->start_idx;
    
#line 620 
    fpm_limit_0 = ((info->hmc_info)->hmc_obj + info->rsrc_type)->size * (unsigned long long)info->count + fpm_addr;
    
#line 620 
    sd_idx = (unsigned int)(fpm_addr / 2097152ULL);
    
#line 620 
    sd_lmt = (unsigned int)((fpm_limit_0 + 18446744073709551615ULL) / 2097152ULL);
    
#line 620 
    sd_lmt += 1U;
  }
  
#line 623 
  if ((info->hmc_info)->sd_table.sd_cnt <= sd_idx || (info->hmc_info)->sd_table.sd_cnt < sd_lmt) {
    
#line 625 
    ret_code = I40E_ERR_INVALID_SD_INDEX;
    
#line 626 
    goto exit;
  }
  else ;
  
#line 629 
  i = sd_idx;
  
#line 629 
  goto ldv_53056;
  ldv_53055: 
#line 630 
  ;
  
#line 630 
  if (! ((info->hmc_info)->sd_table.sd_entry + i)->valid) 
#line 631 
                                                          goto ldv_53050; else ;
  
#line 632 
  switch ((unsigned int)((info->hmc_info)->sd_table.sd_entry + i)->entry_type) {
    case (unsigned int)2: 
#line 633 
    ;
    
#line 634 
    ret_code = i40e_remove_sd_bp(hw,info->hmc_info,i);
    
#line 635 
    if (ret_code != I40E_SUCCESS) 
#line 636 
                                  goto exit; else ;
    
#line 637 
    goto ldv_53052;
    case (unsigned int)1: 
#line 638 
    ;
    
#line 639 
    ret_code = i40e_remove_pd_page(hw,info->hmc_info,i);
    
#line 640 
    if (ret_code != I40E_SUCCESS) 
#line 641 
                                  goto exit; else ;
    
#line 642 
    goto ldv_53052;
    default: 
#line 643 
    ;
    
#line 644 
    goto ldv_53052;
  }
  ldv_53052: 
#line 646 
  ;
  ldv_53050: 
#line 647 
  ;
  
#line 629 
  i += 1U;
  ldv_53056: 
#line 630 
  ;
  
#line 629 
  if (i < sd_lmt) 
#line 631 
                  goto ldv_53055; else 
#line 634 
                                       goto ldv_53057;
  ldv_53057: 
#line 635 
  ;
  exit: 
#line 647 
  ;
  
#line 648 
  return ret_code;
}


#line 658  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_shutdown_lan_hmc(struct i40e_hw *hw)
{
  struct i40e_hmc_lan_delete_obj_info info;
  i40e_status ret_code;
  
#line 663 
  info.hmc_info = & hw->hmc;
  
#line 664 
  info.rsrc_type = 0U;
  
#line 665 
  info.start_idx = 0U;
  
#line 666 
  info.count = 1U;
  
#line 669 
  ret_code = i40e_delete_lan_hmc_object(hw,& info);
  
#line 672 
  i40e_free_virt_mem_d(hw,& hw->hmc.sd_table.addr);
  
#line 673 
  hw->hmc.sd_table.sd_cnt = 0U;
  
#line 674 
  hw->hmc.sd_table.sd_entry = (struct i40e_hmc_sd_entry *)0;
  
#line 677 
  i40e_free_virt_mem_d(hw,& hw->hmc.hmc_obj_virt_mem);
  
#line 678 
  hw->hmc.hmc_obj = (struct i40e_hmc_obj_info *)0;
  
#line 680 
  return ret_code;
}


#line 695  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static struct i40e_context_ele i40e_hmc_txq_ce_info[19U] = {{.offset = (unsigned short)0U, .size_of = (unsigned short)2U, .width = (unsigned short)13U, .lsb = (unsigned short)0U}, {.offset = (unsigned short)2U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)30U}, {.offset = (unsigned short)8U, .size_of = (unsigned short)8U, .width = (unsigned short)57U, .lsb = (unsigned short)32U}, {.offset = (unsigned short)16U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)89U}, {.offset = (unsigned short)17U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)90U}, {.offset = (unsigned short)18U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)91U}, {.offset = (unsigned short)19U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)92U}, {.offset = (unsigned short)22U, .size_of = (unsigned short)1U, .width = (unsigned short)8U, .lsb = (unsigned short)96U}, {.offset = (unsigned short)20U, .size_of = (unsigned short)2U, .width = (unsigned short)13U, .lsb = (unsigned short)128U}, {.offset = (unsigned short)23U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)160U}, {.offset = (unsigned short)24U, .size_of = (unsigned short)2U, .width = (unsigned short)13U, .lsb = (unsigned short)161U}, {.offset = (unsigned short)26U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)174U}, {.offset = (unsigned short)27U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)175U}, {.offset = (unsigned short)28U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)176U}, {.offset = (unsigned short)32U, .size_of = (unsigned short)8U, .width = (unsigned short)64U, .lsb = (unsigned short)192U}, {.offset = (unsigned short)40U, .size_of = (unsigned short)4U, .width = (unsigned short)32U, .lsb = (unsigned short)896U}, {.offset = (unsigned short)44U, .size_of = (unsigned short)2U, .width = (unsigned short)10U, .lsb = (unsigned short)980U}, {.offset = (unsigned short)46U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)990U}, {.offset = (unsigned short)0U, .size_of = (unsigned short)0, .width = (unsigned short)0, .lsb = (unsigned short)0}};

#line 721  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static struct i40e_context_ele i40e_hmc_rxq_ce_info[22U] = {{.offset = (unsigned short)0U, .size_of = (unsigned short)2U, .width = (unsigned short)13U, .lsb = (unsigned short)0U}, {.offset = (unsigned short)2U, .size_of = (unsigned short)2U, .width = (unsigned short)8U, .lsb = (unsigned short)13U}, {.offset = (unsigned short)8U, .size_of = (unsigned short)8U, .width = (unsigned short)57U, .lsb = (unsigned short)32U}, {.offset = (unsigned short)16U, .size_of = (unsigned short)2U, .width = (unsigned short)13U, .lsb = (unsigned short)89U}, {.offset = (unsigned short)18U, .size_of = (unsigned short)2U, .width = (unsigned short)7U, .lsb = (unsigned short)102U}, {.offset = (unsigned short)20U, .size_of = (unsigned short)2U, .width = (unsigned short)5U, .lsb = (unsigned short)109U}, {.offset = (unsigned short)22U, .size_of = (unsigned short)1U, .width = (unsigned short)2U, .lsb = (unsigned short)114U}, {.offset = (unsigned short)23U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)116U}, {.offset = (unsigned short)24U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)117U}, {.offset = (unsigned short)25U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)118U}, {.offset = (unsigned short)26U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)119U}, {.offset = (unsigned short)27U, .size_of = (unsigned short)1U, .width = (unsigned short)4U, .lsb = (unsigned short)120U}, {.offset = (unsigned short)28U, .size_of = (unsigned short)1U, .width = (unsigned short)2U, .lsb = (unsigned short)124U}, {.offset = (unsigned short)29U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)127U}, {.offset = (unsigned short)32U, .size_of = (unsigned short)4U, .width = (unsigned short)14U, .lsb = (unsigned short)174U}, {.offset = (unsigned short)36U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)193U}, {.offset = (unsigned short)37U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)194U}, {.offset = (unsigned short)38U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)195U}, {.offset = (unsigned short)39U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)196U}, {.offset = (unsigned short)40U, .size_of = (unsigned short)2U, .width = (unsigned short)3U, .lsb = (unsigned short)198U}, {.offset = (unsigned short)42U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)201U}, {.offset = (unsigned short)0U, .size_of = (unsigned short)0, .width = (unsigned short)0, .lsb = (unsigned short)0}};

#line 753  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static void i40e_write_byte(u8 *hmc_bits, struct i40e_context_ele *ce_info, u8 *src)
{
  u8 src_byte;
  u8 dest_byte;
  u8 mask;
  u8 *from;
  u8 *dest;
  u16 shift_width;
  
#line 762 
  from = src + (int)ce_info->offset;
  
#line 765 
  shift_width = (unsigned short)((unsigned int)ce_info->lsb & 7U);
  
#line 766 
  mask = (unsigned char)((unsigned int)((unsigned char)(1 << (int)ce_info->width)) + 255U);
  
#line 768 
  src_byte = *from;
  
#line 769 
  src_byte = (unsigned char)((int)src_byte & (int)mask);
  
#line 772 
  mask = (unsigned char)((int)mask << (int)shift_width);
  
#line 773 
  src_byte = (unsigned char)((int)src_byte << (int)shift_width);
  
#line 776 
  dest = hmc_bits + (unsigned int)ce_info->lsb / 8U;
  
#line 778 
  memcpy((void *)(& dest_byte),(void const *)dest,1UL);
  
#line 780 
  dest_byte = (unsigned char)(~ ((int)mask) & (int)dest_byte);
  
#line 781 
  dest_byte = (unsigned char)((int)dest_byte | (int)src_byte);
  
#line 784 
  memcpy((void *)dest,(void const *)(& dest_byte),1UL);
  
#line 785 
  return;
}


#line 793  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static void i40e_write_word(u8 *hmc_bits, struct i40e_context_ele *ce_info, u8 *src)
{
  u16 src_word;
  u16 mask;
  u8 *from;
  u8 *dest;
  u16 shift_width;
  __le16 dest_word;
  
#line 803 
  from = src + (int)ce_info->offset;
  
#line 806 
  shift_width = (unsigned short)((unsigned int)ce_info->lsb & 7U);
  
#line 807 
  mask = (unsigned short)((unsigned int)((unsigned short)(1 << (int)ce_info->width)) + 65535U);
  
#line 812 
  src_word = *((u16 *)from);
  
#line 813 
  src_word = (unsigned short)((int)src_word & (int)mask);
  
#line 816 
  mask = (unsigned short)((int)mask << (int)shift_width);
  
#line 817 
  src_word = (unsigned short)((int)src_word << (int)shift_width);
  
#line 820 
  dest = hmc_bits + (unsigned int)ce_info->lsb / 8U;
  
#line 822 
  memcpy((void *)(& dest_word),(void const *)dest,2UL);
  
#line 824 
  dest_word = (unsigned short)(~ ((int)mask) & (int)dest_word);
  
#line 825 
  dest_word = (unsigned short)((int)dest_word | (int)src_word);
  
#line 828 
  memcpy((void *)dest,(void const *)(& dest_word),2UL);
  
#line 829 
  return;
}


#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static void i40e_write_dword(u8 *hmc_bits, struct i40e_context_ele *ce_info, u8 *src)
{
  u32 src_dword;
  u32 mask;
  u8 *from;
  u8 *dest;
  u16 shift_width;
  __le32 dest_dword;
  
#line 847 
  from = src + (int)ce_info->offset;
  
#line 850 
  shift_width = (unsigned short)((unsigned int)ce_info->lsb & 7U);
  
#line 856 
  if ((unsigned int)ce_info->width <= 31U) 
#line 857 
                                           mask = (1U << (int)ce_info->width) + 4294967295U; else 
                                                                    
#line 859 
                                                                    mask = 4294967295U;
  
#line 864 
  src_dword = *((u32 *)from);
  
#line 865 
  src_dword &= mask;
  
#line 868 
  mask <<= (int)shift_width;
  
#line 869 
  src_dword <<= (int)shift_width;
  
#line 872 
  dest = hmc_bits + (unsigned int)ce_info->lsb / 8U;
  
#line 874 
  memcpy((void *)(& dest_dword),(void const *)dest,4UL);
  
#line 876 
  dest_dword = ~ mask & dest_dword;
  
#line 877 
  dest_dword |= src_dword;
  
#line 880 
  memcpy((void *)dest,(void const *)(& dest_dword),4UL);
  
#line 881 
  return;
}


#line 889  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static void i40e_write_qword(u8 *hmc_bits, struct i40e_context_ele *ce_info, u8 *src)
{
  u64 src_qword;
  u64 mask;
  u8 *from;
  u8 *dest;
  u16 shift_width;
  __le64 dest_qword;
  
#line 899 
  from = src + (int)ce_info->offset;
  
#line 902 
  shift_width = (unsigned short)((unsigned int)ce_info->lsb & 7U);
  
#line 908 
  if ((unsigned int)ce_info->width <= 63U) 
#line 909 
                                           mask = (1ULL << (int)ce_info->width) + 18446744073709551615ULL; else 
                                                                    
#line 911 
                                                                    mask = 18446744073709551615ULL;
  
#line 916 
  src_qword = *((u64 *)from);
  
#line 917 
  src_qword &= mask;
  
#line 920 
  mask <<= (int)shift_width;
  
#line 921 
  src_qword <<= (int)shift_width;
  
#line 924 
  dest = hmc_bits + (unsigned int)ce_info->lsb / 8U;
  
#line 926 
  memcpy((void *)(& dest_qword),(void const *)dest,8UL);
  
#line 928 
  dest_qword = ~ mask & dest_qword;
  
#line 929 
  dest_qword |= src_qword;
  
#line 932 
  memcpy((void *)dest,(void const *)(& dest_qword),8UL);
  
#line 933 
  return;
}


#line 941  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_clear_hmc_context(struct i40e_hw *hw, u8 *context_bytes, enum i40e_hmc_lan_rsrc_type hmc_type)
{
  i40e_status __retres;
  
#line 946 
  memset((void *)context_bytes,0,(unsigned long)((unsigned int)(hw->hmc.hmc_obj + hmc_type)->size));
  
#line 948 
  __retres = I40E_SUCCESS;
  
#line 948 
  return __retres;
}


#line 957  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_set_hmc_context(u8 *context_bytes, struct i40e_context_ele *ce_info, u8 *dest)
{
  i40e_status __retres;
  int f;
  
#line 963 
  f = 0;
  
#line 963 
  goto ldv_53131;
  ldv_53130: 
#line 964 
  ;
  
#line 969 
  switch ((int)(ce_info + f)->size_of) {
    case 1: 
#line 970 
    ;
    
#line 971 
    i40e_write_byte(context_bytes,ce_info + f,dest);
    
#line 972 
    goto ldv_53126;
    case 2: 
#line 973 
    ;
    
#line 974 
    i40e_write_word(context_bytes,ce_info + f,dest);
    
#line 975 
    goto ldv_53126;
    case 4: 
#line 976 
    ;
    
#line 977 
    i40e_write_dword(context_bytes,ce_info + f,dest);
    
#line 978 
    goto ldv_53126;
    case 8: 
#line 979 
    ;
    
#line 980 
    i40e_write_qword(context_bytes,ce_info + f,dest);
    
#line 981 
    goto ldv_53126;
  }
  ldv_53126: 
#line 983 
  ;
  
#line 963 
  f += 1;
  ldv_53131: 
#line 964 
  ;
  
#line 963 
  if ((unsigned int)(ce_info + f)->width != 0U) 
#line 965 
                                                goto ldv_53130; else 
                                                                  
#line 968 
                                                                  goto ldv_53132;
  ldv_53132: 
#line 969 
  ;
  
#line 985 
  __retres = I40E_SUCCESS;
  
#line 985 
  return __retres;
}


#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_hmc_get_object_va(struct i40e_hmc_info *hmc_info, u8 **object_base, enum i40e_hmc_lan_rsrc_type rsrc_type, u32 obj_idx)
{
  u32 obj_offset_in_sd;
  u32 obj_offset_in_pd;
  struct i40e_hmc_sd_entry *sd_entry;
  struct i40e_hmc_pd_entry *pd_entry;
  u32 pd_idx;
  u32 pd_lmt;
  u32 rel_pd_idx;
  u64 obj_offset_in_fpm;
  u32 sd_idx;
  u32 sd_lmt;
  
#line 1005 
  i40e_status ret_code = 0;
  
#line 1012 
  if (hmc_info == (struct i40e_hmc_info *)0) {
    
#line 1013 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 1015 
    goto exit;
  }
  else ;
  
#line 1017 
  if (hmc_info->hmc_obj == (struct i40e_hmc_obj_info *)0) {
    
#line 1018 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 1020 
    goto exit;
  }
  else ;
  
#line 1022 
  if (object_base == (u8 **)0U) {
    
#line 1023 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 1025 
    goto exit;
  }
  else ;
  
#line 1027 
  if (hmc_info->signature != 1213027143U) {
    
#line 1028 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 1030 
    goto exit;
  }
  else ;
  
#line 1032 
  if ((hmc_info->hmc_obj + rsrc_type)->cnt <= obj_idx) {
    
#line 1035 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_INDEX;
    
#line 1036 
    goto exit;
  }
  else ;
  {
    u64 fpm_addr;
    u64 fpm_limit;
    
#line 1039 
    fpm_addr = (hmc_info->hmc_obj + rsrc_type)->base + (hmc_info->hmc_obj + rsrc_type)->size * (unsigned long long)obj_idx;
    
#line 1039 
    fpm_limit = (hmc_info->hmc_obj + rsrc_type)->size + fpm_addr;
    
#line 1039 
    sd_idx = (unsigned int)(fpm_addr / 2097152ULL);
    
#line 1039 
    sd_lmt = (unsigned int)((fpm_limit + 18446744073709551615ULL) / 2097152ULL);
    
#line 1039 
    sd_lmt += 1U;
  }
  
#line 1042 
  sd_entry = hmc_info->sd_table.sd_entry + sd_idx;
  
#line 1043 
  obj_offset_in_fpm = (hmc_info->hmc_obj + rsrc_type)->base + (hmc_info->hmc_obj + rsrc_type)->size * (unsigned long long)obj_idx;
  
#line 1046 
  if (sd_entry->entry_type == (unsigned int)I40E_SD_TYPE_PAGED) {
    {
      u64 fpm_adr;
      u64 fpm_limit_0;
      
#line 1047 
      fpm_adr = (hmc_info->hmc_obj + rsrc_type)->base + (hmc_info->hmc_obj + rsrc_type)->size * (unsigned long long)obj_idx;
      
#line 1047 
      fpm_limit_0 = (hmc_info->hmc_obj + rsrc_type)->size + fpm_adr;
      
#line 1047 
      pd_idx = (unsigned int)(fpm_adr / 4096ULL);
      
#line 1047 
      pd_lmt = (unsigned int)((fpm_limit_0 + 18446744073709551615ULL) / 4096ULL);
      
#line 1047 
      pd_lmt += 1U;
    }
    
#line 1049 
    rel_pd_idx = pd_idx & 511U;
    
#line 1050 
    pd_entry = sd_entry->u.pd_table.pd_entry + rel_pd_idx;
    
#line 1051 
    obj_offset_in_pd = (unsigned int)obj_offset_in_fpm & 4095U;
    
#line 1053 
    *object_base = (u8 *)pd_entry->bp.addr.va + obj_offset_in_pd;
  }
  else {
    
#line 1055 
    obj_offset_in_sd = (unsigned int)obj_offset_in_fpm & 2097151U;
    
#line 1057 
    *object_base = (u8 *)sd_entry->u.bp.addr.va + obj_offset_in_sd;
  }
  exit: 
#line 1059 
  ;
  
#line 1060 
  return ret_code;
}


#line 1068  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_clear_lan_tx_queue_context(struct i40e_hw *hw, u16 queue)
{
  i40e_status __retres;
  i40e_status err;
  u8 *context_bytes;
  i40e_status tmp;
  
#line 1074 
  err = i40e_hmc_get_object_va(& hw->hmc,& context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_TX,(unsigned int)queue);
  
#line 1076 
  if (err < I40E_SUCCESS) {
    
#line 1077 
    __retres = err;
    
#line 1077 
    goto return_label;
  }
  else ;
  
#line 1079 
  tmp = i40e_clear_hmc_context(hw,context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_TX);
  
#line 1079 
  __retres = tmp;
  return_label: 
#line 1079 
                return __retres;
}


#line 1088  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_set_lan_tx_queue_context(struct i40e_hw *hw, u16 queue, struct i40e_hmc_obj_txq *s)
{
  i40e_status __retres;
  i40e_status err;
  u8 *context_bytes;
  i40e_status tmp;
  
#line 1095 
  err = i40e_hmc_get_object_va(& hw->hmc,& context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_TX,(unsigned int)queue);
  
#line 1097 
  if (err < I40E_SUCCESS) {
    
#line 1098 
    __retres = err;
    
#line 1098 
    goto return_label;
  }
  else ;
  
#line 1100 
  tmp = i40e_set_hmc_context(context_bytes,(struct i40e_context_ele *)(& i40e_hmc_txq_ce_info),(u8 *)s);
  
#line 1100 
  __retres = tmp;
  return_label: 
#line 1100 
                return __retres;
}


#line 1109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_clear_lan_rx_queue_context(struct i40e_hw *hw, u16 queue)
{
  i40e_status __retres;
  i40e_status err;
  u8 *context_bytes;
  i40e_status tmp;
  
#line 1115 
  err = i40e_hmc_get_object_va(& hw->hmc,& context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_RX,(unsigned int)queue);
  
#line 1117 
  if (err < I40E_SUCCESS) {
    
#line 1118 
    __retres = err;
    
#line 1118 
    goto return_label;
  }
  else ;
  
#line 1120 
  tmp = i40e_clear_hmc_context(hw,context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_RX);
  
#line 1120 
  __retres = tmp;
  return_label: 
#line 1120 
                return __retres;
}


#line 1129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_set_lan_rx_queue_context(struct i40e_hw *hw, u16 queue, struct i40e_hmc_obj_rxq *s)
{
  i40e_status __retres;
  i40e_status err;
  u8 *context_bytes;
  i40e_status tmp;
  
#line 1136 
  err = i40e_hmc_get_object_va(& hw->hmc,& context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_RX,(unsigned int)queue);
  
#line 1138 
  if (err < I40E_SUCCESS) {
    
#line 1139 
    __retres = err;
    
#line 1139 
    goto return_label;
  }
  else ;
  
#line 1141 
  tmp = i40e_set_hmc_context(context_bytes,(struct i40e_context_ele *)(& i40e_hmc_rxq_ce_info),(u8 *)s);
  
#line 1141 
  __retres = tmp;
  return_label: 
#line 1141 
                return __retres;
}


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
i40e_status i40e_aq_get_cee_dcb_config(struct i40e_hw *hw, void *buff, u16 buff_size, struct i40e_asq_cmd_details *cmd_details);


#line 241 
i40e_status i40e_read_lldp_cfg(struct i40e_hw *hw, struct i40e_lldp_variables *lldp_cfg);


#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
i40e_status i40e_get_dcbx_status(struct i40e_hw *hw, u16 *status);


#line 105 
i40e_status i40e_lldp_to_dcb_config(u8 *lldpmib, struct i40e_dcbx_config *dcbcfg);


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_get_dcbx_status(struct i40e_hw *hw, u16 *status)
{
  i40e_status __retres;
  u32 reg;
  
#line 42 
  if (status == (u16 *)0U) {
    
#line 43 
    __retres = I40E_ERR_PARAM;
    
#line 43 
    goto return_label;
  }
  else ;
  
#line 45 
  reg = readl((void const volatile *)(hw->hw_addr + 536608U));
  
#line 46 
  *status = (unsigned short)((unsigned int)((unsigned short)reg) & 7U);
  
#line 49 
  __retres = I40E_SUCCESS;
  return_label: 
#line 49 
                return __retres;
}


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_etscfg_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  struct i40e_dcb_ets_config *etscfg;
  u8 priority;
  int i;
  u16 tmp;
  u16 tmp_0;
  
#line 63 
  u8 *buf = (u8 *)(& tlv->tlvinfo);
  
#line 64 
  u16 offset = (unsigned short)0U;
  
#line 75 
  etscfg = & dcbcfg->etscfg;
  
#line 76 
  etscfg->willing = (unsigned char)((int)*(buf + (int)offset) >> 7);
  
#line 78 
  etscfg->cbs = (unsigned char)((unsigned int)((unsigned char)((int)*(buf + (int)offset) >> 6)) & 1U);
  
#line 80 
  etscfg->maxtcs = (unsigned char)((unsigned int)*(buf + (int)offset) & 7U);
  
#line 84 
  offset = (u16)((int)offset + 1);
  
#line 94 
  i = 0;
  
#line 94 
  goto ldv_52948;
  ldv_52947: 
#line 95 
  ;
  
#line 95 
  priority = (unsigned char)((unsigned int)((unsigned char)((int)*(buf + (int)offset) >> 4)) & 7U);
  
#line 97 
  etscfg->prioritytable[i * 2] = priority;
  
#line 98 
  priority = (unsigned char)((unsigned int)*(buf + (int)offset) & 7U);
  
#line 100 
  etscfg->prioritytable[i * 2 + 1] = priority;
  
#line 101 
  offset = (u16)((int)offset + 1);
  
#line 94 
  i += 1;
  ldv_52948: 
#line 95 
  ;
  
#line 94 
  if (i <= 3) 
#line 96 
              goto ldv_52947; else 
#line 99 
                                   goto ldv_52949;
  ldv_52949: 
#line 100 
  ;
  
#line 110 
  i = 0;
  
#line 110 
  goto ldv_52951;
  ldv_52950: 
#line 111 
  ;
  
#line 111 
  tmp = offset;
  
#line 111 
  offset = (u16)((int)offset + 1);
  
#line 111 
  etscfg->tcbwtable[i] = *(buf + (int)tmp);
  
#line 110 
  i += 1;
  ldv_52951: 
#line 111 
  ;
  
#line 110 
  if (i <= 7) 
#line 112 
              goto ldv_52950; else 
#line 115 
                                   goto ldv_52952;
  ldv_52952: 
#line 116 
  ;
  
#line 119 
  i = 0;
  
#line 119 
  goto ldv_52954;
  ldv_52953: 
#line 120 
  ;
  
#line 120 
  tmp_0 = offset;
  
#line 120 
  offset = (u16)((int)offset + 1);
  
#line 120 
  etscfg->tsatable[i] = *(buf + (int)tmp_0);
  
#line 119 
  i += 1;
  ldv_52954: 
#line 120 
  ;
  
#line 119 
  if (i <= 7) 
#line 121 
              goto ldv_52953; else 
#line 124 
                                   goto ldv_52955;
  ldv_52955: 
#line 125 
  ;
  
#line 126 
  return;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_etsrec_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  u8 priority;
  int i;
  u16 tmp;
  u16 tmp_0;
  
#line 133 
  u8 *buf = (u8 *)(& tlv->tlvinfo);
  
#line 134 
  u16 offset = (unsigned short)0U;
  
#line 139 
  offset = (u16)((int)offset + 1);
  
#line 149 
  i = 0;
  
#line 149 
  goto ldv_52965;
  ldv_52964: 
#line 150 
  ;
  
#line 150 
  priority = (unsigned char)((unsigned int)((unsigned char)((int)*(buf + (int)offset) >> 4)) & 7U);
  
#line 152 
  dcbcfg->etsrec.prioritytable[i * 2] = priority;
  
#line 153 
  priority = (unsigned char)((unsigned int)*(buf + (int)offset) & 7U);
  
#line 155 
  dcbcfg->etsrec.prioritytable[i * 2 + 1] = priority;
  
#line 156 
  offset = (u16)((int)offset + 1);
  
#line 149 
  i += 1;
  ldv_52965: 
#line 150 
  ;
  
#line 149 
  if (i <= 3) 
#line 151 
              goto ldv_52964; else 
#line 154 
                                   goto ldv_52966;
  ldv_52966: 
#line 155 
  ;
  
#line 165 
  i = 0;
  
#line 165 
  goto ldv_52968;
  ldv_52967: 
#line 166 
  ;
  
#line 166 
  tmp = offset;
  
#line 166 
  offset = (u16)((int)offset + 1);
  
#line 166 
  dcbcfg->etsrec.tcbwtable[i] = *(buf + (int)tmp);
  
#line 165 
  i += 1;
  ldv_52968: 
#line 166 
  ;
  
#line 165 
  if (i <= 7) 
#line 167 
              goto ldv_52967; else 
#line 170 
                                   goto ldv_52969;
  ldv_52969: 
#line 171 
  ;
  
#line 174 
  i = 0;
  
#line 174 
  goto ldv_52971;
  ldv_52970: 
#line 175 
  ;
  
#line 175 
  tmp_0 = offset;
  
#line 175 
  offset = (u16)((int)offset + 1);
  
#line 175 
  dcbcfg->etsrec.tsatable[i] = *(buf + (int)tmp_0);
  
#line 174 
  i += 1;
  ldv_52971: 
#line 175 
  ;
  
#line 174 
  if (i <= 7) 
#line 176 
              goto ldv_52970; else 
#line 179 
                                   goto ldv_52972;
  ldv_52972: 
#line 180 
  ;
  
#line 181 
  return;
}


#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_pfccfg_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  
#line 188 
  u8 *buf = (u8 *)(& tlv->tlvinfo);
  
#line 196 
  dcbcfg->pfc.willing = (unsigned char)((int)*buf >> 7);
  
#line 198 
  dcbcfg->pfc.mbc = (unsigned char)((unsigned int)((unsigned char)((int)*buf >> 6)) & 1U);
  
#line 200 
  dcbcfg->pfc.pfccap = (unsigned char)((unsigned int)*buf & 15U);
  
#line 202 
  dcbcfg->pfc.pfcenable = *(buf + 1U);
  
#line 203 
  return;
}


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_app_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  u16 typelength;
  u16 length;
  u8 *buf;
  
#line 216 
  u16 offset = (unsigned short)0U;
  
#line 218 
  int i = 0;
  
#line 221 
  if (0 != 0) 
#line 221 
              typelength = (unsigned short)(((int)tlv->typelength << 8) | ((int)tlv->typelength >> 8)); else 
                                                                    
#line 221 
                                                                    typelength = __fswab16((unsigned short)((int)tlv->typelength));
  
#line 222 
  length = (unsigned short)((unsigned int)typelength & 511U);
  
#line 224 
  buf = (u8 *)(& tlv->tlvinfo);
  
#line 227 
  length = (unsigned short)((unsigned int)length + 65531U);
  
#line 230 
  offset = (u16)((int)offset + 1);
  
#line 240 
  goto ldv_52989;
  ldv_52988: 
#line 241 
  ;
  
#line 241 
  dcbcfg->app[i].priority = (unsigned char)((int)*(buf + (int)offset) >> 5);
  
#line 244 
  dcbcfg->app[i].selector = (unsigned char)((unsigned int)*(buf + (int)offset) & 7U);
  
#line 247 
  dcbcfg->app[i].protocolid = (unsigned short)(((int)*(buf + ((unsigned int)offset + 1U)) << 8) | (int)*(buf + ((unsigned int)offset + 2U)));
  
#line 250 
  offset = (unsigned short)((unsigned int)offset + 3U);
  
#line 251 
  i += 1;
  
#line 252 
  if (i > 31) 
#line 253 
              goto ldv_52987; else ;
  ldv_52989: 
#line 254 
  ;
  
#line 240 
  if ((int)offset < (int)length) 
#line 242 
                                 goto ldv_52988; else 
#line 245 
                                                      goto ldv_52987;
  ldv_52987: 
#line 246 
  ;
  
#line 256 
  dcbcfg->numapps = (unsigned int)i;
  
#line 257 
  return;
}


#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  u32 ouisubtype;
  u8 subtype;
  
#line 273 
  if (0 != 0) 
#line 273 
              ouisubtype = (((tlv->ouisubtype << 24) | ((tlv->ouisubtype << 8) & 16711680U)) | ((tlv->ouisubtype >> 8) & 65280U)) | (tlv->ouisubtype >> 24); else 
                                                                    
#line 273 
                                                                    ouisubtype = __fswab32(tlv->ouisubtype);
  
#line 274 
  subtype = (unsigned char)ouisubtype;
  
#line 276 
  switch ((int)subtype) {
    case 9: 
#line 277 
    ;
    
#line 278 
    i40e_parse_ieee_etscfg_tlv(tlv,dcbcfg);
    
#line 279 
    goto ldv_52997;
    case 10: 
#line 280 
    ;
    
#line 281 
    i40e_parse_ieee_etsrec_tlv(tlv,dcbcfg);
    
#line 282 
    goto ldv_52997;
    case 11: 
#line 283 
    ;
    
#line 284 
    i40e_parse_ieee_pfccfg_tlv(tlv,dcbcfg);
    
#line 285 
    goto ldv_52997;
    case 12: 
#line 286 
    ;
    
#line 287 
    i40e_parse_ieee_app_tlv(tlv,dcbcfg);
    
#line 288 
    goto ldv_52997;
    default: 
#line 289 
    ;
    
#line 290 
    goto ldv_52997;
  }
  ldv_52997: 
#line 292 
  ;
  
#line 293 
  return;
}


#line 302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_org_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  u32 ouisubtype;
  u32 oui;
  
#line 308 
  if (0 != 0) 
#line 308 
              ouisubtype = (((tlv->ouisubtype << 24) | ((tlv->ouisubtype << 8) & 16711680U)) | ((tlv->ouisubtype >> 8) & 65280U)) | (tlv->ouisubtype >> 24); else 
                                                                    
#line 308 
                                                                    ouisubtype = __fswab32(tlv->ouisubtype);
  
#line 309 
  oui = ouisubtype >> 8;
  
#line 311 
  switch (oui) {
    case (u32)32962: 
#line 312 
    ;
    
#line 313 
    i40e_parse_ieee_tlv(tlv,dcbcfg);
    
#line 314 
    goto ldv_53009;
    default: 
#line 315 
    ;
    
#line 316 
    goto ldv_53009;
  }
  ldv_53009: 
#line 318 
  ;
  
#line 319 
  return;
}


#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_lldp_to_dcb_config(u8 *lldpmib, struct i40e_dcbx_config *dcbcfg)
{
  i40e_status __retres;
  struct i40e_lldp_org_tlv *tlv;
  u16 type;
  u16 length;
  u16 typelength;
  
#line 330 
  i40e_status ret = 0;
  
#line 335 
  u16 offset = (unsigned short)0U;
  
#line 337 
  if (lldpmib == (u8 *)0U || dcbcfg == (struct i40e_dcbx_config *)0) {
    
#line 338 
    __retres = I40E_ERR_PARAM;
    
#line 338 
    goto return_label;
  }
  else ;
  
#line 341 
  lldpmib += 14U;
  
#line 342 
  tlv = (struct i40e_lldp_org_tlv *)lldpmib;
  ldv_53025: 
#line 343 
  ;
  
#line 344 
  if (0 != 0) 
#line 344 
              typelength = (unsigned short)(((int)tlv->typelength << 8) | ((int)tlv->typelength >> 8)); else 
                                                                    
#line 344 
                                                                    typelength = __fswab16((unsigned short)((int)tlv->typelength));
  
#line 345 
  type = (unsigned short)((int)typelength >> 9);
  
#line 347 
  length = (unsigned short)((unsigned int)typelength & 511U);
  
#line 349 
  offset = (unsigned short)((unsigned int)((int)offset + (int)length) + 2U);
  
#line 352 
  if ((unsigned int)type == 0U || (unsigned int)offset > 1500U) 
#line 353 
                                                                goto ldv_53021; else ;
  
#line 355 
  switch ((int)type) {
    case 127: 
#line 356 
    ;
    
#line 357 
    i40e_parse_org_tlv(tlv,dcbcfg);
    
#line 358 
    goto ldv_53023;
    default: 
#line 359 
    ;
    
#line 360 
    goto ldv_53023;
  }
  ldv_53023: 
#line 364 
  ;
  
#line 364 
  tlv += (unsigned int)length + 2U;
  
#line 344 
  goto ldv_53025;
  ldv_53021: 
#line 345 
  ;
  
#line 369 
  __retres = ret;
  return_label: 
#line 369 
                return __retres;
}


#line 381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_aq_get_dcb_config(struct i40e_hw *hw, u8 mib_type, u8 bridgetype, struct i40e_dcbx_config *dcbcfg)
{
  i40e_status __retres;
  struct i40e_virt_mem mem;
  u8 *lldpmib;
  
#line 385 
  i40e_status ret = 0;
  
#line 390 
  ret = i40e_allocate_virt_mem_d(hw,& mem,1500U);
  
#line 391 
  if (ret != I40E_SUCCESS) {
    
#line 392 
    __retres = ret;
    
#line 392 
    goto return_label;
  }
  else ;
  
#line 394 
  lldpmib = (u8 *)mem.va;
  
#line 395 
  ret = i40e_aq_get_lldp_mib(hw,(unsigned char)((int)bridgetype),(unsigned char)((int)mib_type),(void *)lldpmib,(unsigned short)1500,(u16 *)0U,(u16 *)0U,(struct i40e_asq_cmd_details *)0);
  
#line 398 
  if (ret != I40E_SUCCESS) 
#line 399 
                           goto free_mem; else ;
  
#line 402 
  ret = i40e_lldp_to_dcb_config(lldpmib,dcbcfg);
  free_mem: 
#line 404 
  ;
  
#line 405 
  i40e_free_virt_mem_d(hw,& mem);
  
#line 406 
  __retres = ret;
  return_label: 
#line 406 
                return __retres;
}


#line 416  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_cee_to_dcb_v1_config(struct i40e_aqc_get_cee_dcb_cfg_v1_resp *cee_cfg, struct i40e_dcbx_config *dcbcfg)
{
  u16 status;
  u8 i;
  u8 tc;
  u8 err;
  
#line 420 
  u16 tlv_status = cee_cfg->tlv_status;
  
#line 421 
  u16 app_prio = cee_cfg->oper_app_prio;
  
#line 425 
  dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
  
#line 427 
  i = (unsigned char)0U;
  
#line 427 
  goto ldv_53047;
  ldv_53046: 
#line 428 
  ;
  
#line 428 
  tc = (unsigned char)((int)cee_cfg->oper_prio_tc[(int)i] >> 4);
  
#line 431 
  dcbcfg->etscfg.prioritytable[(int)i * 2] = tc;
  
#line 432 
  tc = (unsigned char)((unsigned int)cee_cfg->oper_prio_tc[(int)i] & 15U);
  
#line 435 
  dcbcfg->etscfg.prioritytable[(int)i * 2 + 1] = tc;
  
#line 427 
  i = (u8)((int)i + 1);
  ldv_53047: 
#line 428 
  ;
  
#line 427 
  if ((unsigned int)i <= 3U) 
#line 429 
                             goto ldv_53046; else 
#line 432 
                                                  goto ldv_53048;
  ldv_53048: 
#line 433 
  ;
  
#line 438 
  i = (unsigned char)0U;
  
#line 438 
  goto ldv_53050;
  ldv_53049: 
#line 439 
  ;
  
#line 439 
  dcbcfg->etscfg.tcbwtable[(int)i] = cee_cfg->oper_tc_bw[(int)i];
  
#line 438 
  i = (u8)((int)i + 1);
  ldv_53050: 
#line 439 
  ;
  
#line 438 
  if ((unsigned int)i <= 7U) 
#line 440 
                             goto ldv_53049; else 
#line 443 
                                                  goto ldv_53051;
  ldv_53051: 
#line 444 
  ;
  
#line 441 
  i = (unsigned char)0U;
  
#line 441 
  goto ldv_53053;
  ldv_53052: 
#line 442 
  ;
  
#line 442 
  if ((unsigned int)dcbcfg->etscfg.prioritytable[(int)i] == 15U) {
    
#line 444 
    dcbcfg->etscfg.prioritytable[(int)i] = (unsigned char)((unsigned int)cee_cfg->oper_num_tc + 255U);
    
#line 446 
    dcbcfg->etscfg.tsatable[(int)i] = (unsigned char)0U;
  }
  else 
#line 448 
       dcbcfg->etscfg.tsatable[(int)i] = (unsigned char)2U;
  
#line 441 
  i = (u8)((int)i + 1);
  ldv_53053: 
#line 442 
  ;
  
#line 441 
  if ((unsigned int)i <= 7U) 
#line 443 
                             goto ldv_53052; else 
#line 446 
                                                  goto ldv_53054;
  ldv_53054: 
#line 447 
  ;
  
#line 453 
  dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
  
#line 454 
  dcbcfg->pfc.pfccap = (unsigned char)8U;
  
#line 456 
  status = (unsigned short)((unsigned int)((unsigned short)((int)tlv_status >> 8)) & 7U);
  
#line 458 
  err = (unsigned char)((unsigned int)((unsigned char)((int)status >> 2)) & 1U);
  
#line 460 
  if ((unsigned int)err == 0U) {
    
#line 462 
    dcbcfg->numapps = 3U;
    
#line 465 
    dcbcfg->app[0].priority = (unsigned char)((unsigned int)((unsigned char)app_prio) & 7U);
    
#line 468 
    dcbcfg->app[0].selector = (unsigned char)1U;
    
#line 469 
    dcbcfg->app[0].protocolid = (unsigned short)35078U;
    
#line 472 
    dcbcfg->app[1].priority = (unsigned char)((unsigned int)((unsigned char)((int)app_prio >> 3)) & 7U);
    
#line 475 
    dcbcfg->app[1].selector = (unsigned char)2U;
    
#line 476 
    dcbcfg->app[1].protocolid = (unsigned short)3260U;
    
#line 479 
    dcbcfg->app[2].priority = (unsigned char)((unsigned int)((unsigned char)((int)app_prio >> 8)) & 7U);
    
#line 482 
    dcbcfg->app[2].selector = (unsigned char)1U;
    
#line 483 
    dcbcfg->app[2].protocolid = (unsigned short)35092U;
  }
  else ;
  
#line 485 
  return;
}


#line 494  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_cee_to_dcb_config(struct i40e_aqc_get_cee_dcb_cfg_resp *cee_cfg, struct i40e_dcbx_config *dcbcfg)
{
  u32 status;
  u8 i;
  u8 tc;
  u8 err;
  u8 sync;
  u8 oper;
  
#line 498 
  u32 tlv_status = cee_cfg->tlv_status;
  
#line 499 
  u16 app_prio = cee_cfg->oper_app_prio;
  
#line 503 
  dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
  
#line 505 
  i = (unsigned char)0U;
  
#line 505 
  goto ldv_53068;
  ldv_53067: 
#line 506 
  ;
  
#line 506 
  tc = (unsigned char)((int)cee_cfg->oper_prio_tc[(int)i] >> 4);
  
#line 509 
  dcbcfg->etscfg.prioritytable[(int)i * 2] = tc;
  
#line 510 
  tc = (unsigned char)((unsigned int)cee_cfg->oper_prio_tc[(int)i] & 15U);
  
#line 513 
  dcbcfg->etscfg.prioritytable[(int)i * 2 + 1] = tc;
  
#line 505 
  i = (u8)((int)i + 1);
  ldv_53068: 
#line 506 
  ;
  
#line 505 
  if ((unsigned int)i <= 3U) 
#line 507 
                             goto ldv_53067; else 
#line 510 
                                                  goto ldv_53069;
  ldv_53069: 
#line 511 
  ;
  
#line 516 
  i = (unsigned char)0U;
  
#line 516 
  goto ldv_53071;
  ldv_53070: 
#line 517 
  ;
  
#line 517 
  dcbcfg->etscfg.tcbwtable[(int)i] = cee_cfg->oper_tc_bw[(int)i];
  
#line 516 
  i = (u8)((int)i + 1);
  ldv_53071: 
#line 517 
  ;
  
#line 516 
  if ((unsigned int)i <= 7U) 
#line 518 
                             goto ldv_53070; else 
#line 521 
                                                  goto ldv_53072;
  ldv_53072: 
#line 522 
  ;
  
#line 519 
  i = (unsigned char)0U;
  
#line 519 
  goto ldv_53074;
  ldv_53073: 
#line 520 
  ;
  
#line 520 
  if ((unsigned int)dcbcfg->etscfg.prioritytable[(int)i] == 15U) {
    
#line 522 
    dcbcfg->etscfg.prioritytable[(int)i] = (unsigned char)((unsigned int)cee_cfg->oper_num_tc + 255U);
    
#line 524 
    dcbcfg->etscfg.tsatable[(int)i] = (unsigned char)0U;
  }
  else 
#line 526 
       dcbcfg->etscfg.tsatable[(int)i] = (unsigned char)2U;
  
#line 519 
  i = (u8)((int)i + 1);
  ldv_53074: 
#line 520 
  ;
  
#line 519 
  if ((unsigned int)i <= 7U) 
#line 521 
                             goto ldv_53073; else 
#line 524 
                                                  goto ldv_53075;
  ldv_53075: 
#line 525 
  ;
  
#line 531 
  dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
  
#line 532 
  dcbcfg->pfc.pfccap = (unsigned char)8U;
  
#line 534 
  status = (tlv_status >> 8) & 7U;
  
#line 536 
  err = (unsigned char)((unsigned int)((unsigned char)(status >> 2)) & 1U);
  
#line 537 
  sync = (unsigned char)((unsigned int)((unsigned char)(status >> 1)) & 1U);
  
#line 538 
  oper = (unsigned char)((unsigned int)((unsigned char)status) & 1U);
  
#line 540 
  if (((unsigned int)err == 0U && (unsigned int)sync != 0U) && (unsigned int)oper != 0U) {
    
#line 542 
    dcbcfg->numapps = 3U;
    
#line 545 
    dcbcfg->app[0].priority = (unsigned char)((unsigned int)((unsigned char)app_prio) & 7U);
    
#line 548 
    dcbcfg->app[0].selector = (unsigned char)1U;
    
#line 549 
    dcbcfg->app[0].protocolid = (unsigned short)35078U;
    
#line 552 
    dcbcfg->app[1].priority = (unsigned char)((unsigned int)((unsigned char)((int)app_prio >> 3)) & 7U);
    
#line 555 
    dcbcfg->app[1].selector = (unsigned char)2U;
    
#line 556 
    dcbcfg->app[1].protocolid = (unsigned short)3260U;
    
#line 559 
    dcbcfg->app[2].priority = (unsigned char)((unsigned int)((unsigned char)((int)app_prio >> 8)) & 7U);
    
#line 562 
    dcbcfg->app[2].selector = (unsigned char)1U;
    
#line 563 
    dcbcfg->app[2].protocolid = (unsigned short)35092U;
  }
  else ;
  
#line 565 
  return;
}


#line 573  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_get_dcb_config(struct i40e_hw *hw)
{
  struct i40e_aqc_get_cee_dcb_cfg_resp cee_cfg;
  struct i40e_aqc_get_cee_dcb_cfg_v1_resp cee_v1_cfg;
  
#line 575 
  i40e_status ret = 0;
  
#line 580 
  if (((unsigned int)hw->aq.fw_maj_ver == 4U && (unsigned int)hw->aq.fw_min_ver <= 32U) || (unsigned int)hw->aq.fw_maj_ver <= 3U) 
    
#line 582 
    goto ieee; else ;
  
#line 585 
  if ((unsigned int)hw->aq.fw_maj_ver == 4U && (unsigned int)hw->aq.fw_min_ver == 33U) {
    
#line 586 
    ret = i40e_aq_get_cee_dcb_config(hw,(void *)(& cee_v1_cfg),(unsigned short)24,(struct i40e_asq_cmd_details *)0);
    
#line 588 
    if (ret == I40E_SUCCESS) {
      
#line 590 
      hw->local_dcbx_config.dcbx_mode = (unsigned char)1U;
      
#line 591 
      i40e_cee_to_dcb_v1_config(& cee_v1_cfg,& hw->local_dcbx_config);
    }
    else ;
  }
  else {
    
#line 595 
    ret = i40e_aq_get_cee_dcb_config(hw,(void *)(& cee_cfg),(unsigned short)32,(struct i40e_asq_cmd_details *)0);
    
#line 597 
    if (ret == I40E_SUCCESS) {
      
#line 599 
      hw->local_dcbx_config.dcbx_mode = (unsigned char)1U;
      
#line 600 
      i40e_cee_to_dcb_config(& cee_cfg,& hw->local_dcbx_config);
    }
    else ;
  }
  
#line 606 
  if (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOENT) 
#line 607 
                                                                 goto ieee; else 
                                                                    
#line 609 
                                                                    goto out;
  ieee: 
#line 611 
  ;
  
#line 613 
  hw->local_dcbx_config.dcbx_mode = (unsigned char)2U;
  
#line 615 
  ret = i40e_aq_get_dcb_config(hw,(unsigned char)0,(unsigned char)0,& hw->local_dcbx_config);
  
#line 617 
  if (ret != I40E_SUCCESS) 
#line 618 
                           goto out; else ;
  
#line 621 
  ret = i40e_aq_get_dcb_config(hw,(unsigned char)1,(unsigned char)0,& hw->remote_dcbx_config);
  
#line 625 
  if (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOENT) 
#line 626 
                                                                 ret = I40E_SUCCESS; else ;
  out: 
#line 628 
  ;
  
#line 629 
  return ret;
}


#line 638  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_init_dcb(struct i40e_hw *hw)
{
  i40e_status __retres;
  struct i40e_lldp_variables lldp_cfg;
  
#line 640 
  i40e_status ret = 0;
  
#line 642 
  u8 adminstatus = (unsigned char)0U;
  
#line 644 
  if (! hw->func_caps.dcb) {
    
#line 645 
    __retres = ret;
    
#line 645 
    goto return_label;
  }
  else ;
  
#line 648 
  ret = i40e_read_lldp_cfg(hw,& lldp_cfg);
  
#line 649 
  if (ret != I40E_SUCCESS) {
    
#line 650 
    __retres = ret;
    
#line 650 
    goto return_label;
  }
  else ;
  
#line 653 
  adminstatus = (unsigned char)((int)lldp_cfg.adminstatus >> (int)hw->port * 4);
  
#line 654 
  adminstatus = (unsigned char)((unsigned int)adminstatus & 15U);
  
#line 657 
  if ((unsigned int)adminstatus == 0U) {
    
#line 658 
    hw->dcbx_status = (unsigned short)7U;
    
#line 659 
    __retres = ret;
    
#line 659 
    goto return_label;
  }
  else ;
  
#line 663 
  ret = i40e_get_dcbx_status(hw,& hw->dcbx_status);
  
#line 664 
  if (ret != I40E_SUCCESS) {
    
#line 665 
    __retres = ret;
    
#line 665 
    goto return_label;
  }
  else ;
  
#line 668 
  switch ((int)hw->dcbx_status) {
    case 2: 
#line 669 
    ;
    case 1: 
#line 670 
    ;
    
#line 672 
    ret = i40e_get_dcb_config(hw);
    
#line 673 
    if (ret != I40E_SUCCESS) {
      
#line 674 
      __retres = ret;
      
#line 674 
      goto return_label;
    }
    else ;
    
#line 675 
    goto ldv_53092;
    case 7: 
#line 676 
    ;
    
#line 677 
    __retres = ret;
    
#line 677 
    goto return_label;
    case 0: 
#line 678 
    ;
    case 3: 
#line 679 
    ;
    default: 
#line 680 
    ;
    
#line 681 
    goto ldv_53092;
  }
  ldv_53092: 
#line 685 
  ;
  
#line 685 
  ret = i40e_aq_cfg_lldp_mib_change_event(hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
  
#line 686 
  if (ret != I40E_SUCCESS) {
    
#line 687 
    __retres = ret;
    
#line 687 
    goto return_label;
  }
  else ;
  
#line 689 
  __retres = ret;
  return_label: 
#line 689 
                return __retres;
}


#line 699  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_read_lldp_cfg(struct i40e_hw *hw, struct i40e_lldp_variables *lldp_cfg)
{
  i40e_status __retres;
  
#line 702 
  i40e_status ret = 0;
  
#line 703 
  u32 offset = 26U;
  
#line 705 
  if (lldp_cfg == (struct i40e_lldp_variables *)0) {
    
#line 706 
    __retres = I40E_ERR_PARAM;
    
#line 706 
    goto return_label;
  }
  else ;
  
#line 708 
  ret = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  
#line 709 
  if (ret != I40E_SUCCESS) 
#line 710 
                           goto err_lldp_cfg; else ;
  
#line 712 
  ret = i40e_aq_read_nvm(hw,(unsigned char)15,offset,(unsigned short)14,(void *)lldp_cfg,(_Bool)1,(struct i40e_asq_cmd_details *)0);
  
#line 716 
  i40e_release_nvm(hw);
  err_lldp_cfg: 
#line 718 
  ;
  
#line 719 
  __retres = ret;
  return_label: 
#line 719 
                return __retres;
}


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_lock_73_0(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_75(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_77(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_79(struct mutex *ldv_func_arg1);


#line 193  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
static void ldv_mutex_unlock_74_0(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_78_0(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1);


#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
void i40e_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc, u16 opcode);


#line 492  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_type.h"
__inline static bool i40e_is_vf(struct i40e_hw *hw)
{
  bool __retres;
  
#line 494 
  __retres = (_Bool)(hw->mac.type == (unsigned int)I40E_MAC_VF);
  
#line 494 
  return __retres;
}


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
void i40e_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc, void *buffer, u16 buf_len);


#line 60 
i40e_status i40e_aq_queue_shutdown(struct i40e_hw *hw, bool unloading);


#line 67 
i40e_status i40e_aq_get_firmware_version(struct i40e_hw *hw, u16 *fw_major_version, u16 *fw_minor_version, u32 *fw_build, u16 *api_major_version, u16 *api_minor_version, struct i40e_asq_cmd_details *cmd_details);


#line 200 
i40e_status i40e_aq_set_hmc_resource_profile(struct i40e_hw *hw, enum i40e_aq_hmc_profile profile, u8 pe_vf_enabled_count, struct i40e_asq_cmd_details *cmd_details);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_resume_aq(struct i40e_hw *hw);


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
__inline static bool i40e_is_nvm_update_op(struct i40e_aq_desc *desc)
{
  bool __retres;
  
#line 41 
  __retres = (_Bool)((unsigned int)desc->opcode + 63742U <= 1U);
  
#line 41 
  return __retres;
}


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_adminq_init_regs(struct i40e_hw *hw)
{
  bool tmp;
  
#line 54 
  tmp = i40e_is_vf(hw);
  
#line 54 
  if ((int)tmp != 0) {
    
#line 55 
    hw->aq.asq.tail = 33792U;
    
#line 56 
    hw->aq.asq.head = 25600U;
    
#line 57 
    hw->aq.asq.len = 26624U;
    
#line 58 
    hw->aq.asq.bal = 31744U;
    
#line 59 
    hw->aq.asq.bah = 30720U;
    
#line 60 
    hw->aq.arq.tail = 28672U;
    
#line 61 
    hw->aq.arq.head = 29696U;
    
#line 62 
    hw->aq.arq.len = 32768U;
    
#line 63 
    hw->aq.arq.bal = 27648U;
    
#line 64 
    hw->aq.arq.bah = 24576U;
  }
  else {
    
#line 66 
    hw->aq.asq.tail = 525312U;
    
#line 67 
    hw->aq.asq.head = 525056U;
    
#line 68 
    hw->aq.asq.len = 524800U;
    
#line 69 
    hw->aq.asq.bal = 524288U;
    
#line 70 
    hw->aq.asq.bah = 524544U;
    
#line 71 
    hw->aq.arq.tail = 525440U;
    
#line 72 
    hw->aq.arq.head = 525184U;
    
#line 73 
    hw->aq.arq.len = 524928U;
    
#line 74 
    hw->aq.arq.bal = 524416U;
    
#line 75 
    hw->aq.arq.bah = 524672U;
  }
  
#line 77 
  return;
}


#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_alloc_adminq_asq_ring(struct i40e_hw *hw)
{
  i40e_status __retres;
  i40e_status ret_code;
  
#line 87 
  ret_code = i40e_allocate_dma_mem_d(hw,& hw->aq.asq.desc_buf,(unsigned long long)((unsigned long)hw->aq.num_asq_entries * 32UL),4096U);
  
#line 92 
  if (ret_code != I40E_SUCCESS) {
    
#line 93 
    __retres = ret_code;
    
#line 93 
    goto return_label;
  }
  else ;
  
#line 95 
  ret_code = i40e_allocate_virt_mem_d(hw,& hw->aq.asq.cmd_buf,(unsigned int)hw->aq.num_asq_entries * 24U);
  
#line 98 
  if (ret_code != I40E_SUCCESS) {
    
#line 99 
    i40e_free_dma_mem_d(hw,& hw->aq.asq.desc_buf);
    
#line 100 
    __retres = ret_code;
    
#line 100 
    goto return_label;
  }
  else ;
  
#line 103 
  __retres = ret_code;
  return_label: 
#line 103 
                return __retres;
}


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_alloc_adminq_arq_ring(struct i40e_hw *hw)
{
  i40e_status ret_code;
  
#line 114 
  ret_code = i40e_allocate_dma_mem_d(hw,& hw->aq.arq.desc_buf,(unsigned long long)((unsigned long)hw->aq.num_arq_entries * 32UL),4096U);
  
#line 120 
  return ret_code;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_free_adminq_asq(struct i40e_hw *hw)
{
  
#line 132 
  i40e_free_dma_mem_d(hw,& hw->aq.asq.desc_buf);
  
#line 133 
  return;
}


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_free_adminq_arq(struct i40e_hw *hw)
{
  
#line 144 
  i40e_free_dma_mem_d(hw,& hw->aq.arq.desc_buf);
  
#line 145 
  return;
}


#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_alloc_arq_bufs(struct i40e_hw *hw)
{
  i40e_status __retres;
  i40e_status ret_code;
  struct i40e_aq_desc *desc;
  struct i40e_dma_mem *bi;
  int i;
  
#line 163 
  ret_code = i40e_allocate_virt_mem_d(hw,& hw->aq.arq.dma_head,(unsigned int)hw->aq.num_arq_entries * 20U);
  
#line 165 
  if (ret_code != I40E_SUCCESS) 
#line 166 
                                goto alloc_arq_bufs; else ;
  
#line 167 
  hw->aq.arq.r.arq_bi = (struct i40e_dma_mem *)hw->aq.arq.dma_head.va;
  
#line 170 
  i = 0;
  
#line 170 
  goto ldv_52978;
  ldv_52977: 
#line 171 
  ;
  
#line 171 
  bi = hw->aq.arq.r.arq_bi + i;
  
#line 172 
  ret_code = i40e_allocate_dma_mem_d(hw,bi,(unsigned long long)hw->aq.arq_buf_size,4096U);
  
#line 176 
  if (ret_code != I40E_SUCCESS) 
#line 177 
                                goto unwind_alloc_arq_bufs; else ;
  
#line 180 
  desc = (struct i40e_aq_desc *)hw->aq.arq.desc_buf.va + i;
  
#line 182 
  desc->flags = (unsigned short)4096U;
  
#line 183 
  if ((unsigned int)hw->aq.arq_buf_size > 512U) 
#line 184 
                                                desc->flags = (unsigned short)((unsigned int)desc->flags | 512U); else ;
  
#line 185 
  desc->opcode = (unsigned short)0U;
  
#line 189 
  desc->datalen = (unsigned short)bi->size;
  
#line 190 
  desc->retval = (unsigned short)0U;
  
#line 191 
  desc->cookie_high = 0U;
  
#line 192 
  desc->cookie_low = 0U;
  
#line 193 
  desc->params.external.addr_high = (unsigned int)(bi->pa >> 32);
  
#line 195 
  desc->params.external.addr_low = (unsigned int)bi->pa;
  
#line 197 
  desc->params.external.param0 = 0U;
  
#line 198 
  desc->params.external.param1 = 0U;
  
#line 170 
  i += 1;
  ldv_52978: 
#line 171 
  ;
  
#line 170 
  if ((int)hw->aq.num_arq_entries > i) 
#line 172 
                                       goto ldv_52977; else 
#line 175 
                                                            goto ldv_52979;
  ldv_52979: 
#line 176 
  ;
  alloc_arq_bufs: 
#line 201 
  ;
  
#line 202 
  __retres = ret_code;
  
#line 202 
  goto return_label;
  unwind_alloc_arq_bufs: 
#line 204 
  ;
  
#line 206 
  i -= 1;
  
#line 207 
  goto ldv_52981;
  ldv_52980: 
#line 208 
  ;
  
#line 208 
  i40e_free_dma_mem_d(hw,hw->aq.arq.r.arq_bi + i);
  
#line 207 
  i -= 1;
  ldv_52981: 
#line 208 
  ;
  
#line 207 
  if (i >= 0) 
#line 209 
              goto ldv_52980; else 
#line 212 
                                   goto ldv_52982;
  ldv_52982: 
#line 213 
  ;
  
#line 209 
  i40e_free_virt_mem_d(hw,& hw->aq.arq.dma_head);
  
#line 211 
  __retres = ret_code;
  return_label: 
#line 211 
                return __retres;
}


#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_alloc_asq_bufs(struct i40e_hw *hw)
{
  i40e_status __retres;
  i40e_status ret_code;
  struct i40e_dma_mem *bi;
  int i;
  
#line 225 
  ret_code = i40e_allocate_virt_mem_d(hw,& hw->aq.asq.dma_head,(unsigned int)hw->aq.num_asq_entries * 20U);
  
#line 227 
  if (ret_code != I40E_SUCCESS) 
#line 228 
                                goto alloc_asq_bufs; else ;
  
#line 229 
  hw->aq.asq.r.asq_bi = (struct i40e_dma_mem *)hw->aq.asq.dma_head.va;
  
#line 232 
  i = 0;
  
#line 232 
  goto ldv_52992;
  ldv_52991: 
#line 233 
  ;
  
#line 233 
  bi = hw->aq.asq.r.asq_bi + i;
  
#line 234 
  ret_code = i40e_allocate_dma_mem_d(hw,bi,(unsigned long long)hw->aq.asq_buf_size,4096U);
  
#line 238 
  if (ret_code != I40E_SUCCESS) 
#line 239 
                                goto unwind_alloc_asq_bufs; else ;
  
#line 232 
  i += 1;
  ldv_52992: 
#line 233 
  ;
  
#line 232 
  if ((int)hw->aq.num_asq_entries > i) 
#line 234 
                                       goto ldv_52991; else 
#line 237 
                                                            goto ldv_52993;
  ldv_52993: 
#line 238 
  ;
  alloc_asq_bufs: 
#line 241 
  ;
  
#line 242 
  __retres = ret_code;
  
#line 242 
  goto return_label;
  unwind_alloc_asq_bufs: 
#line 244 
  ;
  
#line 246 
  i -= 1;
  
#line 247 
  goto ldv_52995;
  ldv_52994: 
#line 248 
  ;
  
#line 248 
  i40e_free_dma_mem_d(hw,hw->aq.asq.r.asq_bi + i);
  
#line 247 
  i -= 1;
  ldv_52995: 
#line 248 
  ;
  
#line 247 
  if (i >= 0) 
#line 249 
              goto ldv_52994; else 
#line 252 
                                   goto ldv_52996;
  ldv_52996: 
#line 253 
  ;
  
#line 249 
  i40e_free_virt_mem_d(hw,& hw->aq.asq.dma_head);
  
#line 251 
  __retres = ret_code;
  return_label: 
#line 251 
                return __retres;
}


#line 258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_free_arq_bufs(struct i40e_hw *hw)
{
  int i;
  
#line 263 
  i = 0;
  
#line 263 
  goto ldv_53002;
  ldv_53001: 
#line 264 
  ;
  
#line 264 
  i40e_free_dma_mem_d(hw,hw->aq.arq.r.arq_bi + i);
  
#line 263 
  i += 1;
  ldv_53002: 
#line 264 
  ;
  
#line 263 
  if ((int)hw->aq.num_arq_entries > i) 
#line 265 
                                       goto ldv_53001; else 
#line 268 
                                                            goto ldv_53003;
  ldv_53003: 
#line 269 
  ;
  
#line 267 
  i40e_free_dma_mem_d(hw,& hw->aq.arq.desc_buf);
  
#line 270 
  i40e_free_virt_mem_d(hw,& hw->aq.arq.dma_head);
  
#line 271 
  return;
}


#line 277  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_free_asq_bufs(struct i40e_hw *hw)
{
  int i;
  
#line 282 
  i = 0;
  
#line 282 
  goto ldv_53009;
  ldv_53008: 
#line 283 
  ;
  
#line 283 
  if ((hw->aq.asq.r.asq_bi + i)->pa != 0ULL) 
#line 284 
                                             i40e_free_dma_mem_d(hw,hw->aq.asq.r.asq_bi + i); else ;
  
#line 282 
  i += 1;
  ldv_53009: 
#line 283 
  ;
  
#line 282 
  if ((int)hw->aq.num_asq_entries > i) 
#line 284 
                                       goto ldv_53008; else 
#line 287 
                                                            goto ldv_53010;
  ldv_53010: 
#line 288 
  ;
  
#line 287 
  i40e_free_virt_mem_d(hw,& hw->aq.asq.cmd_buf);
  
#line 290 
  i40e_free_dma_mem_d(hw,& hw->aq.asq.desc_buf);
  
#line 293 
  i40e_free_virt_mem_d(hw,& hw->aq.asq.dma_head);
  
#line 294 
  return;
}


#line 302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_config_asq_regs(struct i40e_hw *hw)
{
  
#line 304 
  i40e_status ret_code = 0;
  
#line 305 
  u32 reg = 0U;
  
#line 308 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.asq.head));
  
#line 309 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.asq.tail));
  
#line 312 
  writel((unsigned int)((int)hw->aq.num_asq_entries) | -2147483648,(void volatile *)(hw->hw_addr + hw->aq.asq.len));
  
#line 314 
  writel((unsigned int)hw->aq.asq.desc_buf.pa,(void volatile *)(hw->hw_addr + hw->aq.asq.bal));
  
#line 315 
  writel((unsigned int)(hw->aq.asq.desc_buf.pa >> 32),(void volatile *)(hw->hw_addr + hw->aq.asq.bah));
  
#line 318 
  reg = readl((void const volatile *)(hw->hw_addr + hw->aq.asq.bal));
  
#line 319 
  if ((unsigned int)hw->aq.asq.desc_buf.pa != reg) 
#line 320 
                                                   ret_code = I40E_ERR_ADMIN_QUEUE_ERROR; else ;
  
#line 322 
  return ret_code;
}


#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_config_arq_regs(struct i40e_hw *hw)
{
  
#line 333 
  i40e_status ret_code = 0;
  
#line 334 
  u32 reg = 0U;
  
#line 337 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.arq.head));
  
#line 338 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.arq.tail));
  
#line 341 
  writel((unsigned int)((int)hw->aq.num_arq_entries) | -2147483648,(void volatile *)(hw->hw_addr + hw->aq.arq.len));
  
#line 343 
  writel((unsigned int)hw->aq.arq.desc_buf.pa,(void volatile *)(hw->hw_addr + hw->aq.arq.bal));
  
#line 344 
  writel((unsigned int)(hw->aq.arq.desc_buf.pa >> 32),(void volatile *)(hw->hw_addr + hw->aq.arq.bah));
  
#line 347 
  writel((unsigned int)((int)hw->aq.num_arq_entries + -1),(void volatile *)(hw->hw_addr + hw->aq.arq.tail));
  
#line 350 
  reg = readl((void const volatile *)(hw->hw_addr + hw->aq.arq.bal));
  
#line 351 
  if ((unsigned int)hw->aq.arq.desc_buf.pa != reg) 
#line 352 
                                                   ret_code = I40E_ERR_ADMIN_QUEUE_ERROR; else ;
  
#line 354 
  return ret_code;
}


#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_init_asq(struct i40e_hw *hw)
{
  
#line 372 
  i40e_status ret_code = 0;
  
#line 374 
  if ((unsigned int)hw->aq.asq.count != 0U) {
    
#line 376 
    ret_code = I40E_ERR_NOT_READY;
    
#line 377 
    goto init_adminq_exit;
  }
  else ;
  
#line 381 
  if ((unsigned int)hw->aq.num_asq_entries == 0U || (unsigned int)hw->aq.asq_buf_size == 0U) {
    
#line 383 
    ret_code = I40E_ERR_CONFIG;
    
#line 384 
    goto init_adminq_exit;
  }
  else ;
  
#line 387 
  hw->aq.asq.next_to_use = (unsigned short)0U;
  
#line 388 
  hw->aq.asq.next_to_clean = (unsigned short)0U;
  
#line 389 
  hw->aq.asq.count = hw->aq.num_asq_entries;
  
#line 392 
  ret_code = i40e_alloc_adminq_asq_ring(hw);
  
#line 393 
  if (ret_code != I40E_SUCCESS) 
#line 394 
                                goto init_adminq_exit; else ;
  
#line 397 
  ret_code = i40e_alloc_asq_bufs(hw);
  
#line 398 
  if (ret_code != I40E_SUCCESS) 
#line 399 
                                goto init_adminq_free_rings; else ;
  
#line 402 
  ret_code = i40e_config_asq_regs(hw);
  
#line 403 
  if (ret_code != I40E_SUCCESS) 
#line 404 
                                goto init_adminq_free_rings; else ;
  
#line 407 
  goto init_adminq_exit;
  init_adminq_free_rings: 
#line 409 
  ;
  
#line 410 
  i40e_free_adminq_asq(hw);
  init_adminq_exit: 
#line 412 
  ;
  
#line 413 
  return ret_code;
}


#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_init_arq(struct i40e_hw *hw)
{
  
#line 431 
  i40e_status ret_code = 0;
  
#line 433 
  if ((unsigned int)hw->aq.arq.count != 0U) {
    
#line 435 
    ret_code = I40E_ERR_NOT_READY;
    
#line 436 
    goto init_adminq_exit;
  }
  else ;
  
#line 440 
  if ((unsigned int)hw->aq.num_arq_entries == 0U || (unsigned int)hw->aq.arq_buf_size == 0U) {
    
#line 442 
    ret_code = I40E_ERR_CONFIG;
    
#line 443 
    goto init_adminq_exit;
  }
  else ;
  
#line 446 
  hw->aq.arq.next_to_use = (unsigned short)0U;
  
#line 447 
  hw->aq.arq.next_to_clean = (unsigned short)0U;
  
#line 448 
  hw->aq.arq.count = hw->aq.num_arq_entries;
  
#line 451 
  ret_code = i40e_alloc_adminq_arq_ring(hw);
  
#line 452 
  if (ret_code != I40E_SUCCESS) 
#line 453 
                                goto init_adminq_exit; else ;
  
#line 456 
  ret_code = i40e_alloc_arq_bufs(hw);
  
#line 457 
  if (ret_code != I40E_SUCCESS) 
#line 458 
                                goto init_adminq_free_rings; else ;
  
#line 461 
  ret_code = i40e_config_arq_regs(hw);
  
#line 462 
  if (ret_code != I40E_SUCCESS) 
#line 463 
                                goto init_adminq_free_rings; else ;
  
#line 466 
  goto init_adminq_exit;
  init_adminq_free_rings: 
#line 468 
  ;
  
#line 469 
  i40e_free_adminq_arq(hw);
  init_adminq_exit: 
#line 471 
  ;
  
#line 472 
  return ret_code;
}


#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_shutdown_asq(struct i40e_hw *hw)
{
  i40e_status __retres;
  
#line 483 
  i40e_status ret_code = 0;
  
#line 485 
  if ((unsigned int)hw->aq.asq.count == 0U) {
    
#line 486 
    __retres = I40E_ERR_NOT_READY;
    
#line 486 
    goto return_label;
  }
  else ;
  
#line 489 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.asq.head));
  
#line 490 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.asq.tail));
  
#line 491 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.asq.len));
  
#line 492 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.asq.bal));
  
#line 493 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.asq.bah));
  
#line 496 
  ldv_mutex_lock_73_0(& hw->aq.asq_mutex);
  
#line 498 
  hw->aq.asq.count = (unsigned short)0U;
  
#line 501 
  i40e_free_asq_bufs(hw);
  
#line 503 
  ldv_mutex_unlock_74_0(& hw->aq.asq_mutex);
  
#line 505 
  __retres = ret_code;
  return_label: 
#line 505 
                return __retres;
}


#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_shutdown_arq(struct i40e_hw *hw)
{
  i40e_status __retres;
  
#line 516 
  i40e_status ret_code = 0;
  
#line 518 
  if ((unsigned int)hw->aq.arq.count == 0U) {
    
#line 519 
    __retres = I40E_ERR_NOT_READY;
    
#line 519 
    goto return_label;
  }
  else ;
  
#line 522 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.arq.head));
  
#line 523 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.arq.tail));
  
#line 524 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.arq.len));
  
#line 525 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.arq.bal));
  
#line 526 
  writel(0U,(void volatile *)(hw->hw_addr + hw->aq.arq.bah));
  
#line 529 
  ldv_mutex_lock_75(& hw->aq.arq_mutex);
  
#line 531 
  hw->aq.arq.count = (unsigned short)0U;
  
#line 534 
  i40e_free_arq_bufs(hw);
  
#line 536 
  ldv_mutex_unlock_76(& hw->aq.arq_mutex);
  
#line 538 
  __retres = ret_code;
  return_label: 
#line 538 
                return __retres;
}


#line 552  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
i40e_status i40e_init_adminq(struct i40e_hw *hw)
{
  i40e_status ret_code;
  u16 eetrack_lo;
  u16 eetrack_hi;
  
#line 556 
  int retry = 0;
  
#line 559 
  if ((((unsigned int)hw->aq.num_arq_entries == 0U || (unsigned int)hw->aq.num_asq_entries == 0U) || (unsigned int)hw->aq.arq_buf_size == 0U) || (unsigned int)hw->aq.asq_buf_size == 0U) {
    
#line 563 
    ret_code = I40E_ERR_CONFIG;
    
#line 564 
    goto init_adminq_exit;
  }
  else ;
  {
    struct lock_class_key __key;
    
#line 568 
    __mutex_init(& hw->aq.asq_mutex,"&hw->aq.asq_mutex",& __key);
  }
  {
    struct lock_class_key __key_0;
    
#line 569 
    __mutex_init(& hw->aq.arq_mutex,"&hw->aq.arq_mutex",& __key_0);
  }
  
#line 572 
  i40e_adminq_init_regs(hw);
  
#line 575 
  hw->aq.asq_cmd_timeout = 250U;
  
#line 578 
  ret_code = i40e_init_asq(hw);
  
#line 579 
  if (ret_code != I40E_SUCCESS) 
#line 580 
                                goto init_adminq_destroy_locks; else ;
  
#line 583 
  ret_code = i40e_init_arq(hw);
  
#line 584 
  if (ret_code != I40E_SUCCESS) 
#line 585 
                                goto init_adminq_free_asq; else ;
  ldv_53054: 
#line 586 
  ;
  
#line 592 
  ret_code = i40e_aq_get_firmware_version(hw,& hw->aq.fw_maj_ver,& hw->aq.fw_min_ver,& hw->aq.fw_build,& hw->aq.api_maj_ver,& hw->aq.api_min_ver,(struct i40e_asq_cmd_details *)0);
  
#line 599 
  if (ret_code != I40E_ERR_ADMIN_QUEUE_TIMEOUT) 
#line 600 
                                                goto ldv_53053; else ;
  
#line 601 
  retry += 1;
  
#line 602 
  msleep(100U);
  
#line 603 
  i40e_resume_aq(hw);
  
#line 604 
  if (retry <= 9) 
#line 606 
                  goto ldv_53054; else 
#line 609 
                                       goto ldv_53053;
  ldv_53053: 
#line 610 
  ;
  
#line 605 
  if (ret_code != I40E_SUCCESS) 
#line 606 
                                goto init_adminq_free_arq; else ;
  
#line 609 
  i40e_read_nvm_word(hw,(unsigned short)24,& hw->nvm.version);
  
#line 611 
  i40e_read_nvm_word(hw,(unsigned short)45,& eetrack_lo);
  
#line 612 
  i40e_read_nvm_word(hw,(unsigned short)46,& eetrack_hi);
  
#line 613 
  hw->nvm.eetrack = (unsigned int)(((int)eetrack_hi << 16) | (int)eetrack_lo);
  
#line 615 
  if ((unsigned int)hw->aq.api_maj_ver > 1U) {
    
#line 616 
    ret_code = I40E_ERR_FIRMWARE_API_VERSION;
    
#line 617 
    goto init_adminq_free_arq;
  }
  else ;
  
#line 621 
  i40e_aq_release_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
  
#line 622 
  hw->aq.nvm_release_on_done = (_Bool)0;
  
#line 623 
  hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
  
#line 625 
  ret_code = i40e_aq_set_hmc_resource_profile(hw,(enum i40e_aq_hmc_profile)I40E_HMC_PROFILE_DEFAULT,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
  
#line 629 
  ret_code = I40E_SUCCESS;
  
#line 632 
  goto init_adminq_exit;
  init_adminq_free_arq: 
#line 634 
  ;
  
#line 635 
  i40e_shutdown_arq(hw);
  init_adminq_free_asq: 
#line 636 
  ;
  
#line 637 
  i40e_shutdown_asq(hw);
  init_adminq_destroy_locks: 
#line 638 
  ;
  init_adminq_exit: 
#line 640 
  ;
  
#line 641 
  return ret_code;
}


#line 648  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
i40e_status i40e_shutdown_adminq(struct i40e_hw *hw)
{
  bool tmp;
  
#line 650 
  i40e_status ret_code = 0;
  
#line 652 
  tmp = i40e_check_asq_alive(hw);
  
#line 652 
  if ((int)tmp != 0) 
#line 653 
                     i40e_aq_queue_shutdown(hw,(_Bool)1); else ;
  
#line 655 
  i40e_shutdown_asq(hw);
  
#line 656 
  i40e_shutdown_arq(hw);
  
#line 660 
  return ret_code;
}


#line 669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static u16 i40e_clean_asq(struct i40e_hw *hw)
{
  u16 __retres;
  struct i40e_asq_cmd_details *details;
  struct i40e_aq_desc desc_cb;
  struct i40e_aq_desc *desc;
  unsigned int tmp_0;
  unsigned int tmp_1;
  
#line 671 
  struct i40e_adminq_ring *asq = & hw->aq.asq;
  
#line 673 
  u16 ntc = asq->next_to_clean;
  
#line 677 
  desc = (struct i40e_aq_desc *)asq->desc_buf.va + (int)ntc;
  
#line 678 
  details = (struct i40e_asq_cmd_details *)asq->cmd_buf.va + (int)ntc;
  
#line 679 
  goto ldv_53071;
  ldv_53070: 
#line 680 
  ;
  
#line 680 
  if ((hw->debug_mask & 16777216U) != 0U) {
    unsigned int tmp;
    
#line 680 
    tmp = readl((void const volatile *)(hw->hw_addr + hw->aq.asq.head));
    
#line 680 
    ;
    
#line 680 
    ;
    
#line 680 
    ;
    
#line 680 
    printk("\001",(int)hw->bus.device,(int)hw->bus.func,"i40e_clean_asq",(int)ntc,tmp);
  }
  else ;
  
#line 684 
  if (details->callback != (void *)0) {
    
#line 685 
    void (*cb_func)(struct i40e_hw *, struct i40e_aq_desc *) = (void (*)(struct i40e_hw *, struct i40e_aq_desc *))details->callback;
    
#line 687 
    desc_cb = *desc;
    
#line 688 
    (*cb_func)(hw,& desc_cb);
  }
  else ;
  
#line 690 
  memset((void *)desc,0,32UL);
  
#line 691 
  memset((void *)details,0,24UL);
  
#line 692 
  ntc = (u16)((int)ntc + 1);
  
#line 693 
  if ((int)asq->count == (int)ntc) 
#line 694 
                                   ntc = (unsigned short)0U; else ;
  
#line 695 
  desc = (struct i40e_aq_desc *)asq->desc_buf.va + (int)ntc;
  
#line 696 
  details = (struct i40e_asq_cmd_details *)asq->cmd_buf.va + (int)ntc;
  ldv_53071: 
#line 697 
  ;
  
#line 679 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + hw->aq.asq.head));
  
#line 679 
  ;
  
#line 679 
  if (tmp_0 != (unsigned int)ntc) 
#line 681 
                                  goto ldv_53070; else 
#line 684 
                                                       goto ldv_53072;
  ldv_53072: 
#line 685 
  ;
  
#line 699 
  asq->next_to_clean = ntc;
  
#line 701 
  if ((int)asq->next_to_clean <= (int)asq->next_to_use) 
#line 701 
                                                        tmp_1 = (unsigned int)asq->count; else 
                                                                    
#line 701 
                                                                    tmp_1 = 0U;
  
#line 701 
  ;
  
#line 701 
  __retres = (unsigned short)(((tmp_1 + (unsigned int)asq->next_to_clean) - (unsigned int)asq->next_to_use) + 65535U);
  
#line 701 
  return __retres;
}


#line 711  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static bool i40e_asq_done(struct i40e_hw *hw)
{
  bool __retres;
  unsigned int tmp;
  
#line 716 
  tmp = readl((void const volatile *)(hw->hw_addr + hw->aq.asq.head));
  
#line 716 
  ;
  
#line 716 
  __retres = (_Bool)(tmp == (unsigned int)hw->aq.asq.next_to_use);
  
#line 716 
  return __retres;
}


#line 731  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
i40e_status i40e_asq_send_command(struct i40e_hw *hw, struct i40e_aq_desc *desc, void *buff, u16 buff_size, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_asq_cmd_details *details;
  struct i40e_aq_desc *desc_on_ring;
  u16 tmp;
  bool tmp_1;
  
#line 737 
  i40e_status status = 0;
  
#line 738 
  struct i40e_dma_mem *dma_buff = (struct i40e_dma_mem *)0;
  
#line 741 
  bool cmd_completed = (_Bool)0;
  
#line 742 
  u16 retval = (unsigned short)0U;
  
#line 743 
  u32 val = 0U;
  
#line 745 
  val = readl((void const volatile *)(hw->hw_addr + hw->aq.asq.head));
  
#line 746 
  if ((unsigned int)hw->aq.num_asq_entries <= val) {
    
#line 747 
    if ((hw->debug_mask & 16777216U) != 0U) 
#line 747 
                                            printk("\001",(int)hw->bus.device,(int)hw->bus.func,val); else ;
    
#line 749 
    status = I40E_ERR_QUEUE_EMPTY;
    
#line 750 
    goto asq_send_command_exit;
  }
  else ;
  
#line 753 
  if ((unsigned int)hw->aq.asq.count == 0U) {
    
#line 754 
    if ((hw->debug_mask & 16777216U) != 0U) 
#line 754 
                                            printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
    
#line 756 
    status = I40E_ERR_QUEUE_EMPTY;
    
#line 757 
    goto asq_send_command_exit;
  }
  else ;
  
#line 760 
  details = (struct i40e_asq_cmd_details *)hw->aq.asq.cmd_buf.va + (int)hw->aq.asq.next_to_use;
  
#line 761 
  if (cmd_details != (struct i40e_asq_cmd_details *)0) {
    
#line 762 
    *details = *cmd_details;
    
#line 768 
    if (details->cookie != 0ULL) {
      
#line 769 
      desc->cookie_high = (unsigned int)(details->cookie >> 32);
      
#line 771 
      desc->cookie_low = (unsigned int)details->cookie;
    }
    else ;
  }
  else 
#line 775 
       memset((void *)details,0,24UL);
  
#line 779 
  desc->flags = (unsigned short)((int)desc->flags & ~ ((int)details->flags_dis));
  
#line 780 
  desc->flags = (unsigned short)((int)desc->flags | (int)details->flags_ena);
  
#line 782 
  ldv_mutex_lock_77(& hw->aq.asq_mutex);
  
#line 784 
  if ((int)hw->aq.asq_buf_size < (int)buff_size) {
    
#line 785 
    if ((hw->debug_mask & 16777216U) != 0U) 
#line 785 
                                            printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)buff_size); else ;
    
#line 789 
    status = I40E_ERR_INVALID_SIZE;
    
#line 790 
    goto asq_send_command_error;
  }
  else ;
  
#line 793 
  if ((int)details->postpone != 0 && ! details->async) {
    
#line 794 
    if ((hw->debug_mask & 16777216U) != 0U) 
#line 794 
                                            printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
    
#line 797 
    status = I40E_ERR_PARAM;
    
#line 798 
    goto asq_send_command_error;
  }
  else ;
  
#line 808 
  tmp = i40e_clean_asq(hw);
  
#line 808 
  if ((unsigned int)tmp == 0U) {
    
#line 809 
    if ((hw->debug_mask & 16777216U) != 0U) 
#line 809 
                                            printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
    
#line 812 
    status = I40E_ERR_ADMIN_QUEUE_FULL;
    
#line 813 
    goto asq_send_command_error;
  }
  else ;
  
#line 817 
  desc_on_ring = (struct i40e_aq_desc *)hw->aq.asq.desc_buf.va + (int)hw->aq.asq.next_to_use;
  
#line 820 
  *desc_on_ring = *desc;
  
#line 823 
  if (buff != (void *)0) {
    
#line 824 
    dma_buff = hw->aq.asq.r.asq_bi + (int)hw->aq.asq.next_to_use;
    
#line 826 
    memcpy(dma_buff->va,(void const *)buff,(unsigned long)buff_size);
    
#line 827 
    desc_on_ring->datalen = buff_size;
    
#line 832 
    desc_on_ring->params.external.addr_high = (unsigned int)(dma_buff->pa >> 32);
    
#line 834 
    desc_on_ring->params.external.addr_low = (unsigned int)dma_buff->pa;
  }
  else ;
  
#line 839 
  if ((hw->debug_mask & 16777216U) != 0U) 
#line 839 
                                          printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
  
#line 840 
  i40e_debug_aq(hw,(enum i40e_debug_mask)I40E_DEBUG_AQ_COMMAND,(void *)desc_on_ring,buff,(unsigned short)((int)buff_size));
  
#line 842 
  hw->aq.asq.next_to_use = (u16)((int)hw->aq.asq.next_to_use + 1);
  
#line 843 
  if ((int)hw->aq.asq.next_to_use == (int)hw->aq.asq.count) 
#line 844 
                                                            hw->aq.asq.next_to_use = (unsigned short)0U; else ;
  
#line 845 
  if (! details->postpone) 
#line 846 
                           writel((unsigned int)hw->aq.asq.next_to_use,(void volatile *)(hw->hw_addr + hw->aq.asq.tail)); else ;
  
#line 851 
  if (! details->async && ! details->postpone) {
    bool tmp_0;
    
#line 852 
    u32 total_delay = 0U;
    ldv_53094: 
#line 853 
    ;
    
#line 858 
    tmp_0 = i40e_asq_done(hw);
    
#line 858 
    if ((int)tmp_0 != 0) 
#line 859 
                         goto ldv_53093; else ;
    
#line 860 
    usleep_range(1000UL,2000UL);
    
#line 861 
    total_delay += 1U;
    
#line 862 
    if (hw->aq.asq_cmd_timeout > total_delay) 
#line 864 
                                              goto ldv_53094; else 
#line 867 
                                                                   goto ldv_53093;
    ldv_53093: 
#line 868 
    ;
  }
  else ;
  
#line 866 
  tmp_1 = i40e_asq_done(hw);
  
#line 866 
  if ((int)tmp_1 != 0) {
    
#line 867 
    *desc = *desc_on_ring;
    
#line 868 
    if (buff != (void *)0) 
#line 869 
                           memcpy(buff,(void const *)dma_buff->va,(unsigned long)buff_size); else ;
    
#line 870 
    retval = desc->retval;
    
#line 871 
    if ((unsigned int)retval != 0U) {
      
#line 872 
      if ((hw->debug_mask & 16777216U) != 0U) 
#line 872 
                                              printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)retval); else ;
      
#line 878 
      retval = (unsigned short)((unsigned int)retval & 255U);
    }
    else ;
    
#line 880 
    cmd_completed = (_Bool)1;
    
#line 881 
    if ((unsigned int)retval == 0U) 
#line 882 
                                    status = I40E_SUCCESS; else 
#line 884 
                                                                status = I40E_ERR_ADMIN_QUEUE_ERROR;
    
#line 885 
    hw->aq.asq_last_status = (enum i40e_admin_queue_err)retval;
  }
  else ;
  
#line 888 
  if ((hw->debug_mask & 16777216U) != 0U) 
#line 888 
                                          printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
  
#line 890 
  i40e_debug_aq(hw,(enum i40e_debug_mask)I40E_DEBUG_AQ_COMMAND,(void *)desc,buff,(unsigned short)((int)buff_size));
  
#line 893 
  if (! cmd_completed && (! details->async && ! details->postpone)) {
    
#line 895 
    if ((hw->debug_mask & 16777216U) != 0U) 
#line 895 
                                            printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
    
#line 898 
    status = I40E_ERR_ADMIN_QUEUE_TIMEOUT;
  }
  else ;
  asq_send_command_error: 
#line 901 
  ;
  
#line 902 
  ldv_mutex_unlock_78_0(& hw->aq.asq_mutex);
  asq_send_command_exit: 
#line 903 
  ;
  
#line 904 
  return status;
}


#line 914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
void i40e_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc, u16 opcode)
{
  
#line 918 
  memset((void *)desc,0,32UL);
  
#line 919 
  desc->opcode = opcode;
  
#line 920 
  desc->flags = (unsigned short)8192U;
  
#line 921 
  return;
}


#line 933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
i40e_status i40e_clean_arq_element(struct i40e_hw *hw, struct i40e_arq_event_info *e, u16 *pending)
{
  struct i40e_aq_desc *desc;
  struct i40e_dma_mem *bi;
  u16 desc_idx;
  u16 datalen;
  u16 flags;
  u16 ntu;
  unsigned int tmp;
  int tmp_1;
  bool tmp_3;
  
#line 937 
  i40e_status ret_code = 0;
  
#line 938 
  u16 ntc = hw->aq.arq.next_to_clean;
  
#line 947 
  ldv_mutex_lock_79(& hw->aq.arq_mutex);
  
#line 950 
  tmp = readl((void const volatile *)(hw->hw_addr + hw->aq.arq.head));
  
#line 950 
  ntu = (unsigned short)((unsigned int)((unsigned short)tmp) & 1023U);
  
#line 951 
  if ((int)ntu == (int)ntc) {
    
#line 953 
    ret_code = I40E_ERR_ADMIN_QUEUE_NO_WORK;
    
#line 954 
    goto clean_arq_element_out;
  }
  else ;
  
#line 958 
  desc = (struct i40e_aq_desc *)hw->aq.arq.desc_buf.va + (int)ntc;
  
#line 959 
  desc_idx = ntc;
  
#line 961 
  flags = desc->flags;
  
#line 962 
  if (((int)flags & 4) != 0) {
    
#line 963 
    ret_code = I40E_ERR_ADMIN_QUEUE_ERROR;
    
#line 964 
    hw->aq.arq_last_status = (enum i40e_admin_queue_err)desc->retval;
    
#line 966 
    if ((hw->debug_mask & 16777216U) != 0U) 
#line 966 
                                            printk("\001",(int)hw->bus.device,(int)hw->bus.func,(unsigned int)hw->aq.arq_last_status); else ;
  }
  else ;
  
#line 972 
  e->desc = *desc;
  
#line 973 
  datalen = desc->datalen;
  {
    int tmp_0;
    
#line 974 
    u16 _min1 = datalen;
    
#line 974 
    u16 _min2 = e->buf_len;
    
#line 974 
    if ((int)_min1 < (int)_min2) 
#line 974 
                                 tmp_0 = (int)_min1; else 
#line 974 
                                                          tmp_0 = (int)_min2;
    
#line 974 
    tmp_1 = tmp_0;
  }
  
#line 974 
  e->msg_len = (unsigned short)tmp_1;
  
#line 975 
  if (e->msg_buf != (u8 *)0U && (unsigned int)e->msg_len != 0U) 
#line 976 
                                                                memcpy((void *)e->msg_buf,(void const *)(hw->aq.arq.r.arq_bi + (int)desc_idx)->va,(unsigned long)e->msg_len); else ;
  
#line 979 
  if ((hw->debug_mask & 16777216U) != 0U) 
#line 979 
                                          printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
  
#line 980 
  i40e_debug_aq(hw,(enum i40e_debug_mask)I40E_DEBUG_AQ_COMMAND,(void *)desc,(void *)e->msg_buf,(unsigned short)((int)hw->aq.arq_buf_size));
  
#line 987 
  bi = hw->aq.arq.r.arq_bi + (int)ntc;
  
#line 988 
  memset((void *)desc,0,32UL);
  
#line 990 
  desc->flags = (unsigned short)4096U;
  
#line 991 
  if ((unsigned int)hw->aq.arq_buf_size > 512U) 
#line 992 
                                                desc->flags = (unsigned short)((unsigned int)desc->flags | 512U); else ;
  
#line 993 
  desc->datalen = (unsigned short)bi->size;
  
#line 994 
  desc->params.external.addr_high = (unsigned int)(bi->pa >> 32);
  
#line 995 
  desc->params.external.addr_low = (unsigned int)bi->pa;
  
#line 998 
  writel((unsigned int)ntc,(void volatile *)(hw->hw_addr + hw->aq.arq.tail));
  
#line 1000 
  ntc = (u16)((int)ntc + 1);
  
#line 1001 
  if ((int)hw->aq.num_arq_entries == (int)ntc) 
#line 1002 
                                               ntc = (unsigned short)0U; else ;
  
#line 1003 
  hw->aq.arq.next_to_clean = ntc;
  
#line 1004 
  hw->aq.arq.next_to_use = ntu;
  clean_arq_element_out: 
#line 1006 
  ;
  
#line 1008 
  if (pending != (u16 *)0U) {
    unsigned int tmp_2;
    
#line 1009 
    if ((int)ntc > (int)ntu) 
#line 1009 
                             tmp_2 = (unsigned int)hw->aq.arq.count; else 
                                                                    
#line 1009 
                                                                    tmp_2 = 0U;
    
#line 1009 
    *pending = (unsigned short)(tmp_2 + (unsigned int)((int)ntu - (int)ntc));
  }
  else ;
  
#line 1010 
  ldv_mutex_unlock_80(& hw->aq.arq_mutex);
  
#line 1012 
  tmp_3 = i40e_is_nvm_update_op(& e->desc);
  
#line 1012 
  if ((int)tmp_3 != 0) {
    
#line 1013 
    if ((int)hw->aq.nvm_release_on_done != 0) {
      
#line 1014 
      i40e_release_nvm(hw);
      
#line 1015 
      hw->aq.nvm_release_on_done = (_Bool)0;
    }
    else ;
  }
  else ;
  
#line 1019 
  return ret_code;
}


#line 1022  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_resume_aq(struct i40e_hw *hw)
{
  
#line 1025 
  hw->aq.asq.next_to_use = (unsigned short)0U;
  
#line 1026 
  hw->aq.asq.next_to_clean = (unsigned short)0U;
  
#line 1028 
  i40e_config_asq_regs(hw);
  
#line 1030 
  hw->aq.arq.next_to_use = (unsigned short)0U;
  
#line 1031 
  hw->aq.arq.next_to_clean = (unsigned short)0U;
  
#line 1033 
  i40e_config_arq_regs(hw);
  
#line 1034 
  return;
}


#line 749  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_lock_73_0(struct mutex *ldv_func_arg1)
{
  
#line 753 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"asq_mutex_of_i40e_adminq_info");
  
#line 754 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_unlock_74_0(struct mutex *ldv_func_arg1)
{
  
#line 761 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"asq_mutex_of_i40e_adminq_info");
  
#line 762 
  return;
}


#line 765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_lock_75(struct mutex *ldv_func_arg1)
{
  
#line 769 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"arq_mutex_of_i40e_adminq_info");
  
#line 770 
  return;
}


#line 773  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1)
{
  
#line 777 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"arq_mutex_of_i40e_adminq_info");
  
#line 778 
  return;
}


#line 781  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_lock_77(struct mutex *ldv_func_arg1)
{
  
#line 785 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"asq_mutex_of_i40e_adminq_info");
  
#line 786 
  return;
}


#line 789  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_unlock_78_0(struct mutex *ldv_func_arg1)
{
  
#line 793 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"asq_mutex_of_i40e_adminq_info");
  
#line 794 
  return;
}


#line 797  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_lock_79(struct mutex *ldv_func_arg1)
{
  
#line 801 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"arq_mutex_of_i40e_adminq_info");
  
#line 802 
  return;
}


#line 805  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/weaver/.tmp_i40e_adminq.c.aux"
static void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1)
{
  
#line 809 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"arq_mutex_of_i40e_adminq_info");
  
#line 810 
  return;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
i40e_status i40e_aq_debug_write_register(struct i40e_hw *hw, u32 reg_addr, u64 reg_val, struct i40e_asq_cmd_details *cmd_details);


#line 75 
i40e_status i40e_aq_debug_read_register(struct i40e_hw *hw, u32 reg_addr, u64 *reg_val, struct i40e_asq_cmd_details *cmd_details);


#line 93 
i40e_status i40e_aq_clear_pxe_mode(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details);


#line 198 
i40e_status i40e_aq_dcb_updated(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details);


#line 210 
i40e_status i40e_aq_config_switch_comp_ets(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_switching_comp_ets_data *ets_data, enum i40e_admin_queue_opc opcode, struct i40e_asq_cmd_details *cmd_details);


#line 257 
i40e_status i40e_read_pba_string(struct i40e_hw *hw, u8 *pba_num, u32 pba_num_size);


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_set_mac_type(struct i40e_hw *hw)
{
  
#line 41 
  i40e_status status = 0;
  
#line 43 
  if ((unsigned int)hw->vendor_id == 32902U) {
    
#line 44 
    switch ((int)hw->device_id) {
      case 5490: 
#line 45 
      ;
      case 5492: 
#line 46 
      ;
      case 5503: 
#line 47 
      ;
      case 5504: 
#line 48 
      ;
      case 5505: 
#line 49 
      ;
      case 5507: 
#line 50 
      ;
      case 5508: 
#line 51 
      ;
      case 5509: 
#line 52 
      ;
      case 5510: 
#line 53 
      ;
      case 5511: 
#line 54 
      ;
      
#line 55 
      hw->mac.type = I40E_MAC_XL710;
      
#line 56 
      goto ldv_52928;
      case 5452: 
#line 57 
      ;
      case 5489: 
#line 58 
      ;
      
#line 59 
      hw->mac.type = I40E_MAC_VF;
      
#line 60 
      goto ldv_52928;
      default: 
#line 61 
      ;
      
#line 62 
      hw->mac.type = I40E_MAC_GENERIC;
      
#line 63 
      goto ldv_52928;
    }
    ldv_52928: 
#line 65 
    ;
  }
  else 
#line 66 
       status = I40E_ERR_DEVICE_NOT_SUPPORTED;
  
#line 71 
  return status;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc, void *buffer, u16 buf_len)
{
  
#line 87 
  struct i40e_aq_desc *aq_desc = (struct i40e_aq_desc *)desc;
  
#line 88 
  u16 len = aq_desc->datalen;
  
#line 89 
  u8 *buf = (u8 *)buffer;
  
#line 90 
  u16 i = (unsigned short)0U;
  
#line 92 
  if ((hw->debug_mask & (unsigned int)mask) == 0U || desc == (void *)0) 
    
#line 93 
    goto return_label; else ;
  
#line 95 
  if ((hw->debug_mask & (unsigned int)mask) != 0U) 
#line 95 
                                                   printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)aq_desc->opcode,(int)aq_desc->flags,(int)aq_desc->datalen,(int)aq_desc->retval); else ;
  
#line 101 
  if ((hw->debug_mask & (unsigned int)mask) != 0U) 
#line 101 
                                                   printk("\001",(int)hw->bus.device,(int)hw->bus.func,aq_desc->cookie_high,aq_desc->cookie_low); else ;
  
#line 104 
  if ((hw->debug_mask & (unsigned int)mask) != 0U) 
#line 104 
                                                   printk("\001",(int)hw->bus.device,(int)hw->bus.func,aq_desc->params.internal.param0,aq_desc->params.internal.param1); else ;
  
#line 107 
  if ((hw->debug_mask & (unsigned int)mask) != 0U) 
#line 107 
                                                   printk("\001",(int)hw->bus.device,(int)hw->bus.func,aq_desc->params.external.addr_high,aq_desc->params.external.addr_low); else ;
  
#line 111 
  if (buffer != (void *)0 && (unsigned int)aq_desc->datalen != 0U) {
    
#line 112 
    if ((hw->debug_mask & (unsigned int)mask) != 0U) 
#line 112 
                                                     printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
    
#line 113 
    if ((int)buf_len < (int)len) 
#line 114 
                                 len = buf_len; else ;
    
#line 116 
    i = (unsigned short)0U;
    
#line 116 
    goto ldv_52944;
    ldv_52943: 
#line 117 
    ;
    
#line 117 
    if ((hw->debug_mask & (unsigned int)mask) != 0U) 
#line 117 
                                                     printk("\001",(int)hw->bus.device,(int)hw->bus.func,(int)i,(int)*(buf + (int)i),(int)*(buf + ((unsigned int)i + 1U)),(int)*(buf + ((unsigned int)i + 2U)),(int)*(buf + ((unsigned int)i + 3U)),(int)*(buf + ((unsigned int)i + 4U)),(int)*(buf + ((unsigned int)i + 5U)),(int)*(buf + ((unsigned int)i + 6U)),(int)*(buf + ((unsigned int)i + 7U)),(int)*(buf + ((unsigned int)i + 8U)),(int)*(buf + ((unsigned int)i + 9U)),(int)*(buf + ((unsigned int)i + 10U)),(int)*(buf + ((unsigned int)i + 11U)),(int)*(buf + ((unsigned int)i + 12U)),(int)*(buf + ((unsigned int)i + 13U)),(int)*(buf + ((unsigned int)i + 14U)),(int)*(buf + ((unsigned int)i + 15U))); else ;
    
#line 116 
    i = (unsigned short)((unsigned int)i + 16U);
    ldv_52944: 
#line 117 
    ;
    
#line 116 
    if ((int)i < (int)len + -16) 
#line 118 
                                 goto ldv_52943; else 
#line 121 
                                                      goto ldv_52945;
    ldv_52945: 
#line 122 
    ;
    
#line 126 
    if ((int)i < (int)len) {
      char d_buf[80U];
      int tmp;
      int tmp_1;
      u16 tmp_0;
      
#line 128 
      int j = 0;
      
#line 130 
      memset((void *)(& d_buf),0,80UL);
      
#line 131 
      tmp = sprintf((char *)(& d_buf),"\t0x%04X ",(int)i);
      
#line 131 
      j = tmp + j;
      
#line 132 
      goto ldv_52949;
      ldv_52948: 
#line 133 
      ;
      
#line 133 
      tmp_0 = i;
      
#line 133 
      i = (u16)((int)i + 1);
      
#line 133 
      ;
      
#line 133 
      tmp_1 = sprintf(& d_buf[j]," %02X",(int)*(buf + (int)tmp_0));
      
#line 133 
      j = tmp_1 + j;
      ldv_52949: 
#line 134 
      ;
      
#line 132 
      if ((int)i < (int)len) 
#line 134 
                             goto ldv_52948; else 
#line 137 
                                                  goto ldv_52950;
      ldv_52950: 
#line 138 
      ;
      
#line 134 
      if ((hw->debug_mask & (unsigned int)mask) != 0U) 
#line 134 
                                                       printk("\001",(int)hw->bus.device,(int)hw->bus.func,(char *)(& d_buf)); else ;
    }
    else ;
  }
  else ;
  return_label: 
#line 137 
                return;
}


#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
bool i40e_check_asq_alive(struct i40e_hw *hw)
{
  bool __retres;
  
#line 147 
  if (hw->aq.asq.len != 0U) {
    unsigned int tmp;
    
#line 148 
    tmp = readl((void const volatile *)(hw->hw_addr + hw->aq.asq.len));
    
#line 148 
    __retres = (_Bool)(tmp < (unsigned int)0);
    
#line 148 
    goto return_label;
  }
  else {
    
#line 151 
    __retres = (_Bool)0;
    
#line 151 
    goto return_label;
  }
  return_label: 
#line 147 
                return __retres;
}


#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_queue_shutdown(struct i40e_hw *hw, bool unloading)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 166 
  struct i40e_aqc_queue_shutdown *cmd = (struct i40e_aqc_queue_shutdown *)(& desc.params.raw);
  
#line 170 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)3);
  
#line 173 
  if ((int)unloading != 0) 
#line 174 
                           cmd->driver_unloading = 1U; else ;
  
#line 175 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,(struct i40e_asq_cmd_details *)0);
  
#line 177 
  return status;
}


#line 225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
struct i40e_rx_ptype_decoded i40e_ptype_lookup[256U] = {{.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))1U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))2U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))5U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))3U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))4U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))5U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))6U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))7U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))8U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))9U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))10U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))11U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))12U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))13U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))14U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))15U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))16U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))17U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))18U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))19U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))20U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))21U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))22U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))23U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))24U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))25U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))26U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))27U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))28U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))29U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))30U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))31U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))32U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))33U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))34U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))35U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))36U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))37U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))38U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))39U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))40U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))41U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))42U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))43U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))44U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))45U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))46U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))47U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))48U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))49U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))50U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))51U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))52U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))53U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))54U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))55U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))56U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))57U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))58U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))59U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))60U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))61U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))62U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))63U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))64U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))65U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))66U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))67U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))68U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))69U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))70U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))71U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))72U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))73U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))74U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))75U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))76U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))77U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))78U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))79U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))80U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))81U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))82U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))83U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))84U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))85U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))86U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))87U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))88U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))89U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))90U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))91U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))92U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))93U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))94U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))95U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))96U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))97U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))98U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))99U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))100U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))101U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))102U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))103U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))104U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))105U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))106U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))107U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))108U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))1U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))109U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))110U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))111U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))112U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))113U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))114U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))115U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))116U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))117U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))118U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))119U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))120U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))121U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))122U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))123U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))124U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))125U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))126U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))127U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))128U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))129U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))130U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))131U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))132U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))133U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))134U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))135U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))136U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))137U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))138U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))139U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))140U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))141U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))142U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))143U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))144U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))145U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))146U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))147U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))148U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))2U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))149U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))1U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))150U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))151U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))2U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))152U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))3U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))153U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))4U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))2U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))4U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))3U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))154U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))155U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))156U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))157U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))158U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))159U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))160U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))161U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))162U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))163U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))164U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))165U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))166U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))167U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))168U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))169U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))170U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))171U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))172U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))173U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))174U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))175U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))176U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))177U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))178U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))179U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))180U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))181U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))182U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))183U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))184U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))185U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))186U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))187U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))188U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))189U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))190U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))191U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))192U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))193U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))194U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))195U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))196U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))197U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))198U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))199U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))200U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))201U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))202U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))203U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))204U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))205U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))206U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))207U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))208U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))209U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))210U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))211U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))212U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))213U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))214U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))215U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))216U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))217U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))218U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))219U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))220U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))221U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))222U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))223U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))224U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))225U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))226U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))227U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))228U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))229U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))230U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))231U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))232U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))233U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))234U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))235U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))236U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))237U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))238U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))239U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))240U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))241U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))242U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))243U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))244U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))245U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))246U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))247U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))248U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))249U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))250U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))251U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))252U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))253U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))254U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}, {.ptype = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))255U, .known = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_ip_ver = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .outer_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .tunnel_type = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U, .tunnel_end_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))0U, .tunnel_end_frag = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))0U, .inner_prot = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))))0U, .payload_layer = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))))0U}};

#line 557  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_init_shared_code(struct i40e_hw *hw)
{
  i40e_status __retres;
  u32 port;
  u32 ari;
  u32 func_rid;
  unsigned int tmp;
  unsigned int tmp_0;
  
#line 559 
  i40e_status status = 0;
  
#line 562 
  i40e_set_mac_type(hw);
  
#line 564 
  switch ((unsigned int)hw->mac.type) {
    case (unsigned int)2: 
#line 565 
    ;
    
#line 566 
    goto ldv_52970;
    default: 
#line 567 
    ;
    
#line 568 
    __retres = I40E_ERR_DEVICE_NOT_SUPPORTED;
    
#line 568 
    goto return_label;
  }
  ldv_52970: 
#line 571 
  ;
  
#line 571 
  hw->phy.get_link_info = (_Bool)1;
  
#line 574 
  tmp = readl((void const volatile *)(hw->hw_addr + 1836160U));
  
#line 574 
  port = tmp & 3U;
  
#line 576 
  hw->port = (unsigned char)port;
  
#line 577 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + 779432U));
  
#line 577 
  ari = (tmp_0 >> 4) & 1U;
  
#line 579 
  func_rid = readl((void const volatile *)(hw->hw_addr + 638976U));
  
#line 580 
  if (ari != 0U) 
#line 581 
                 hw->pf_id = (unsigned char)func_rid; else 
#line 583 
                                                           hw->pf_id = (unsigned char)((unsigned int)((unsigned char)func_rid) & 7U);
  
#line 585 
  status = i40e_init_nvm(hw);
  
#line 586 
  __retres = status;
  return_label: 
#line 586 
                return __retres;
}


#line 596  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_aq_mac_address_read(struct i40e_hw *hw, u16 *flags, struct i40e_aqc_mac_address_read_data *addrs, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 602 
  struct i40e_aqc_mac_address_read *cmd_data = (struct i40e_aqc_mac_address_read *)(& desc.params.raw);
  
#line 606 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)263);
  
#line 607 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 609 
  status = i40e_asq_send_command(hw,& desc,(void *)addrs,(unsigned short)24,cmd_details);
  
#line 611 
  *flags = cmd_data->command_flags;
  
#line 613 
  return status;
}


#line 623  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_mac_address_write(struct i40e_hw *hw, u16 flags, u8 *mac_addr, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 628 
  struct i40e_aqc_mac_address_write *cmd_data = (struct i40e_aqc_mac_address_write *)(& desc.params.raw);
  
#line 632 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)264);
  
#line 634 
  cmd_data->command_flags = flags;
  
#line 635 
  cmd_data->mac_sah = (unsigned short)(((int)*mac_addr << 8) | (int)*(mac_addr + 1U));
  
#line 636 
  cmd_data->mac_sal = ((((unsigned int)*(mac_addr + 2U) << 24) | ((unsigned int)*(mac_addr + 3U) << 16)) | ((unsigned int)*(mac_addr + 4U) << 8)) | (unsigned int)*(mac_addr + 5U);
  
#line 641 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 643 
  return status;
}


#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_mac_addr(struct i40e_hw *hw, u8 *mac_addr)
{
  struct i40e_aqc_mac_address_read_data addrs;
  i40e_status status;
  
#line 657 
  u16 flags = (unsigned short)0U;
  
#line 659 
  status = i40e_aq_mac_address_read(hw,& flags,& addrs,(struct i40e_asq_cmd_details *)0);
  
#line 661 
  if (((int)flags & 16) != 0) 
#line 662 
                              memcpy((void *)mac_addr,(void const *)(& addrs.pf_lan_mac),6UL); else ;
  
#line 664 
  return status;
}


#line 674  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr)
{
  i40e_status __retres;
  struct i40e_aqc_mac_address_read_data addrs;
  i40e_status status;
  
#line 678 
  u16 flags = (unsigned short)0U;
  
#line 680 
  status = i40e_aq_mac_address_read(hw,& flags,& addrs,(struct i40e_asq_cmd_details *)0);
  
#line 681 
  if (status != I40E_SUCCESS) {
    
#line 682 
    __retres = status;
    
#line 682 
    goto return_label;
  }
  else ;
  
#line 684 
  if (((int)flags & 64) != 0) 
#line 685 
                              memcpy((void *)mac_addr,(void const *)(& addrs.port_mac),6UL); else 
                                                                    
#line 687 
                                                                    status = I40E_ERR_INVALID_MAC_ADDR;
  
#line 689 
  __retres = status;
  return_label: 
#line 689 
                return __retres;
}


#line 701  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_pre_tx_queue_cfg(struct i40e_hw *hw, u32 queue, bool enable)
{
  u32 reg_val;
  
#line 703 
  u32 abs_queue_idx = hw->func_caps.base_queue + queue;
  
#line 704 
  u32 reg_block = 0U;
  
#line 707 
  if (abs_queue_idx > 127U) {
    
#line 708 
    reg_block = abs_queue_idx / 128U;
    
#line 709 
    abs_queue_idx &= 127U;
  }
  else ;
  
#line 712 
  reg_val = readl((void const volatile *)(hw->hw_addr + (reg_block + 235840U) * 4U));
  
#line 713 
  reg_val &= 4294965248U;
  
#line 714 
  reg_val |= abs_queue_idx;
  
#line 716 
  if ((int)enable != 0) 
#line 717 
                        reg_val |= 2147483648U; else 
#line 719 
                                                     reg_val |= 1073741824U;
  
#line 721 
  writel(reg_val,(void volatile *)(hw->hw_addr + (reg_block + 235840U) * 4U));
  
#line 722 
  return;
}


#line 732  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_san_mac_addr(struct i40e_hw *hw, u8 *mac_addr)
{
  i40e_status __retres;
  struct i40e_aqc_mac_address_read_data addrs;
  i40e_status status;
  
#line 736 
  u16 flags = (unsigned short)0U;
  
#line 738 
  status = i40e_aq_mac_address_read(hw,& flags,& addrs,(struct i40e_asq_cmd_details *)0);
  
#line 739 
  if (status != I40E_SUCCESS) {
    
#line 740 
    __retres = status;
    
#line 740 
    goto return_label;
  }
  else ;
  
#line 742 
  if (((int)flags & 32) != 0) 
#line 743 
                              memcpy((void *)mac_addr,(void const *)(& addrs.pf_san_mac),6UL); else 
                                                                    
#line 745 
                                                                    status = I40E_ERR_INVALID_MAC_ADDR;
  
#line 747 
  __retres = status;
  return_label: 
#line 747 
                return __retres;
}


#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_pba_string(struct i40e_hw *hw, u8 *pba_num, u32 pba_num_size)
{
  i40e_status __retres;
  
#line 762 
  i40e_status status = 0;
  
#line 763 
  u16 pba_word = (unsigned short)0U;
  
#line 764 
  u16 pba_size = (unsigned short)0U;
  
#line 765 
  u16 pba_ptr = (unsigned short)0U;
  
#line 766 
  u16 i = (unsigned short)0U;
  
#line 768 
  status = i40e_read_nvm_word(hw,(unsigned short)21,& pba_word);
  
#line 769 
  if (status != I40E_SUCCESS || (unsigned int)pba_word != 64250U) {
    
#line 771 
    __retres = status;
    
#line 771 
    goto return_label;
  }
  else ;
  
#line 774 
  status = i40e_read_nvm_word(hw,(unsigned short)22,& pba_ptr);
  
#line 775 
  if (status != I40E_SUCCESS) {
    
#line 777 
    __retres = status;
    
#line 777 
    goto return_label;
  }
  else ;
  
#line 780 
  status = i40e_read_nvm_word(hw,(unsigned short)((int)pba_ptr),& pba_size);
  
#line 781 
  if (status != I40E_SUCCESS) {
    
#line 783 
    __retres = status;
    
#line 783 
    goto return_label;
  }
  else ;
  
#line 789 
  pba_size = (u16)((int)pba_size - 1);
  
#line 790 
  if ((unsigned int)pba_size * 2U + 1U > pba_num_size) {
    
#line 792 
    __retres = I40E_ERR_PARAM;
    
#line 792 
    goto return_label;
  }
  else ;
  
#line 795 
  i = (unsigned short)0U;
  
#line 795 
  goto ldv_53030;
  ldv_53029: 
#line 796 
  ;
  
#line 796 
  status = i40e_read_nvm_word(hw,(unsigned short)((int)((unsigned int)((int)pba_ptr + (int)i) + 1U)),& pba_word);
  
#line 797 
  if (status != I40E_SUCCESS) {
    
#line 799 
    __retres = status;
    
#line 799 
    goto return_label;
  }
  else ;
  
#line 802 
  *(pba_num + (int)i * 2) = (unsigned char)((int)pba_word >> 8);
  
#line 803 
  *(pba_num + ((unsigned int)((int)i * 2) + 1U)) = (unsigned char)pba_word;
  
#line 795 
  i = (u16)((int)i + 1);
  ldv_53030: 
#line 796 
  ;
  
#line 795 
  if ((int)i < (int)pba_size) 
#line 797 
                              goto ldv_53029; else 
#line 800 
                                                   goto ldv_53031;
  ldv_53031: 
#line 801 
  ;
  
#line 805 
  *(pba_num + (int)pba_size * 2) = (unsigned char)0U;
  
#line 807 
  __retres = status;
  return_label: 
#line 807 
                return __retres;
}


#line 814  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
static enum i40e_media_type i40e_get_media_type(struct i40e_hw *hw)
{
  enum i40e_media_type media;
  
#line 818 
  switch ((unsigned int)hw->phy.link_info.phy_type) {
    case (unsigned int)20: 
#line 819 
    ;
    case (unsigned int)21: 
#line 820 
    ;
    case (unsigned int)27: 
#line 821 
    ;
    case (unsigned int)28: 
#line 822 
    ;
    case (unsigned int)25: 
#line 823 
    ;
    case (unsigned int)26: 
#line 824 
    ;
    
#line 825 
    media = I40E_MEDIA_TYPE_FIBER;
    
#line 826 
    goto ldv_53042;
    case (unsigned int)17: 
#line 827 
    ;
    case (unsigned int)18: 
#line 828 
    ;
    case (unsigned int)19: 
#line 829 
    ;
    
#line 830 
    media = I40E_MEDIA_TYPE_BASET;
    
#line 831 
    goto ldv_53042;
    case (unsigned int)11: 
#line 832 
    ;
    case (unsigned int)10: 
#line 833 
    ;
    case (unsigned int)23: 
#line 834 
    ;
    case (unsigned int)24: 
#line 835 
    ;
    case (unsigned int)22: 
#line 836 
    ;
    case (unsigned int)13: 
#line 837 
    ;
    case (unsigned int)12: 
#line 838 
    ;
    
#line 839 
    media = I40E_MEDIA_TYPE_DA;
    
#line 840 
    goto ldv_53042;
    case (unsigned int)1: 
#line 841 
    ;
    case (unsigned int)2: 
#line 842 
    ;
    case (unsigned int)3: 
#line 843 
    ;
    case (unsigned int)4: 
#line 844 
    ;
    case (unsigned int)30: 
#line 845 
    ;
    
#line 846 
    media = I40E_MEDIA_TYPE_BACKPLANE;
    
#line 847 
    goto ldv_53042;
    case (unsigned int)0: 
#line 848 
    ;
    case (unsigned int)5: 
#line 849 
    ;
    case (unsigned int)6: 
#line 850 
    ;
    case (unsigned int)8: 
#line 851 
    ;
    case (unsigned int)9: 
#line 852 
    ;
    default: 
#line 853 
    ;
    
#line 854 
    media = I40E_MEDIA_TYPE_UNKNOWN;
    
#line 855 
    goto ldv_53042;
  }
  ldv_53042: 
#line 858 
  ;
  
#line 858 
  return media;
}


#line 870  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_pf_reset(struct i40e_hw *hw)
{
  i40e_status __retres;
  u32 grst_del;
  unsigned int tmp;
  
#line 872 
  u32 cnt = 0U;
  
#line 873 
  u32 cnt1 = 0U;
  
#line 874 
  u32 reg = 0U;
  
#line 881 
  tmp = readl((void const volatile *)(hw->hw_addr + 754048U));
  
#line 881 
  grst_del = tmp & 63U;
  
#line 884 
  cnt = 0U;
  
#line 884 
  goto ldv_53073;
  ldv_53072: 
#line 885 
  ;
  
#line 885 
  reg = readl((void const volatile *)(hw->hw_addr + 754056U));
  
#line 886 
  if ((reg & 3U) == 0U) 
#line 887 
                        goto ldv_53071; else ;
  
#line 888 
  msleep(100U);
  
#line 884 
  cnt += 1U;
  ldv_53073: 
#line 885 
  ;
  
#line 884 
  if (grst_del + 2U > cnt) 
#line 886 
                           goto ldv_53072; else 
#line 889 
                                                goto ldv_53071;
  ldv_53071: 
#line 890 
  ;
  
#line 890 
  if ((reg & 3U) != 0U) {
    
#line 892 
    __retres = I40E_ERR_RESET_FAILED;
    
#line 892 
    goto return_label;
  }
  else ;
  
#line 896 
  cnt1 = 0U;
  
#line 896 
  goto ldv_53076;
  ldv_53075: 
#line 897 
  ;
  
#line 897 
  reg = readl((void const volatile *)(hw->hw_addr + 745480U));
  
#line 898 
  reg &= 24U;
  
#line 900 
  if (reg == 24U) 
#line 903 
                  goto ldv_53074; else ;
  
#line 905 
  usleep_range(10000UL,20000UL);
  
#line 896 
  cnt1 += 1U;
  ldv_53076: 
#line 897 
  ;
  
#line 896 
  if (cnt1 <= 199U) 
#line 898 
                    goto ldv_53075; else 
#line 901 
                                         goto ldv_53074;
  ldv_53074: 
#line 902 
  ;
  
#line 907 
  if ((reg & 24U) == 0U) {
    
#line 911 
    __retres = I40E_ERR_RESET_FAILED;
    
#line 911 
    goto return_label;
  }
  else ;
  
#line 917 
  if (cnt == 0U) {
    
#line 918 
    if ((unsigned int)hw->revision_id == 0U) 
#line 919 
                                             cnt = 200U; else 
#line 921 
                                                              cnt = 200U;
    
#line 922 
    reg = readl((void const volatile *)(hw->hw_addr + 599040U));
    
#line 923 
    writel(reg | 1U,(void volatile *)(hw->hw_addr + 599040U));
    
#line 925 
    goto ldv_53079;
    ldv_53078: 
#line 926 
    ;
    
#line 926 
    reg = readl((void const volatile *)(hw->hw_addr + 599040U));
    
#line 927 
    if ((reg & 1U) == 0U) 
#line 928 
                          goto ldv_53077; else ;
    
#line 929 
    usleep_range(1000UL,2000UL);
    
#line 925 
    cnt -= 1U;
    ldv_53079: 
#line 926 
    ;
    
#line 925 
    if (cnt != 0U) 
#line 927 
                   goto ldv_53078; else 
#line 930 
                                        goto ldv_53077;
    ldv_53077: 
#line 931 
    ;
    
#line 931 
    if ((reg & 1U) != 0U) {
      
#line 933 
      __retres = I40E_ERR_RESET_FAILED;
      
#line 933 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 937 
  i40e_clear_pxe_mode(hw);
  
#line 939 
  __retres = I40E_SUCCESS;
  return_label: 
#line 939 
                return __retres;
}


#line 950  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_clear_hw(struct i40e_hw *hw)
{
  u32 num_queues;
  u32 base_queue;
  u32 num_pf_int;
  u32 num_vf_int;
  u32 num_vfs;
  u32 i;
  u32 j;
  u32 val;
  
#line 958 
  u32 eol = 2047U;
  
#line 961 
  val = readl((void const volatile *)(hw->hw_addr + 779412U));
  
#line 962 
  num_pf_int = (val >> 2) & 2047U;
  
#line 964 
  num_vf_int = (val >> 13) & 2047U;
  
#line 967 
  val = readl((void const volatile *)(hw->hw_addr + 1836032U));
  
#line 968 
  base_queue = val & 2047U;
  
#line 970 
  j = (val >> 16) & 2047U;
  
#line 972 
  if (val < (u32)0) 
#line 973 
                    num_queues = (j - base_queue) + 1U; else 
#line 975 
                                                             num_queues = 0U;
  
#line 977 
  val = readl((void const volatile *)(hw->hw_addr + 1836288U));
  
#line 978 
  i = val & 255U;
  
#line 980 
  j = (val >> 8) & 255U;
  
#line 982 
  if (val < (u32)0) 
#line 983 
                    num_vfs = (j - i) + 1U; else 
#line 985 
                                                 num_vfs = 0U;
  
#line 988 
  writel(0U,(void volatile *)(hw->hw_addr + 231424U));
  
#line 989 
  val = 24U;
  
#line 990 
  i = 0U;
  
#line 990 
  goto ldv_53093;
  ldv_53092: 
#line 991 
  ;
  
#line 991 
  writel(val,(void volatile *)(hw->hw_addr + (i + 53760U) * 4U));
  
#line 990 
  i += 1U;
  ldv_53093: 
#line 991 
  ;
  
#line 990 
  if (num_pf_int + 4294967294U > i) 
#line 992 
                                    goto ldv_53092; else 
#line 995 
                                                         goto ldv_53094;
  ldv_53094: 
#line 996 
  ;
  
#line 994 
  val = eol;
  
#line 995 
  writel(val,(void volatile *)(hw->hw_addr + 230656U));
  
#line 996 
  i = 0U;
  
#line 996 
  goto ldv_53096;
  ldv_53095: 
#line 997 
  ;
  
#line 997 
  writel(val,(void volatile *)(hw->hw_addr + (i + 54272U) * 4U));
  
#line 996 
  i += 1U;
  ldv_53096: 
#line 997 
  ;
  
#line 996 
  if (num_pf_int + 4294967294U > i) 
#line 998 
                                    goto ldv_53095; else 
#line 1001 
                                                         goto ldv_53097;
  ldv_53097: 
#line 1002 
  ;
  
#line 998 
  val = eol;
  
#line 999 
  i = 0U;
  
#line 999 
  goto ldv_53099;
  ldv_53098: 
#line 1000 
  ;
  
#line 1000 
  writel(val,(void volatile *)(hw->hw_addr + (i + 43520U) * 4U));
  
#line 999 
  i += 1U;
  ldv_53099: 
#line 1000 
  ;
  
#line 999 
  if (i < num_vfs) 
#line 1001 
                   goto ldv_53098; else 
#line 1004 
                                        goto ldv_53100;
  ldv_53100: 
#line 1005 
  ;
  
#line 1001 
  i = 0U;
  
#line 1001 
  goto ldv_53102;
  ldv_53101: 
#line 1002 
  ;
  
#line 1002 
  writel(val,(void volatile *)(hw->hw_addr + (i + 37888U) * 4U));
  
#line 1001 
  i += 1U;
  ldv_53102: 
#line 1002 
  ;
  
#line 1001 
  if (num_vf_int + 4294967294U > i) 
#line 1003 
                                    goto ldv_53101; else 
#line 1006 
                                                         goto ldv_53103;
  ldv_53103: 
#line 1007 
  ;
  
#line 1005 
  i = 0U;
  
#line 1005 
  goto ldv_53107;
  ldv_53106: 
#line 1006 
  ;
  {
    
#line 1006 
    u32 abs_queue_idx = base_queue + i;
    
#line 1007 
    u32 reg_block = 0U;
    
#line 1009 
    if (abs_queue_idx > 127U) {
      
#line 1010 
      reg_block = abs_queue_idx / 128U;
      
#line 1011 
      abs_queue_idx &= 127U;
    }
    else ;
    
#line 1014 
    val = readl((void const volatile *)(hw->hw_addr + (reg_block + 235840U) * 4U));
    
#line 1015 
    val &= 4294965248U;
    
#line 1016 
    val |= abs_queue_idx;
    
#line 1017 
    val |= 1073741824U;
    
#line 1019 
    writel(val,(void volatile *)(hw->hw_addr + (reg_block + 235840U) * 4U));
  }
  
#line 1005 
  i += 1U;
  ldv_53107: 
#line 1006 
  ;
  
#line 1005 
  if (i < num_queues) 
#line 1007 
                      goto ldv_53106; else 
#line 1010 
                                           goto ldv_53108;
  ldv_53108: 
#line 1011 
  ;
  
#line 1021 
  __const_udelay(1718000UL);
  
#line 1024 
  i = 0U;
  
#line 1024 
  goto ldv_53110;
  ldv_53109: 
#line 1025 
  ;
  
#line 1025 
  writel(0U,(void volatile *)(hw->hw_addr + (i + 61440U) * 4U));
  
#line 1026 
  writel(0U,(void volatile *)(hw->hw_addr + (i + 262144U) * 4U));
  
#line 1027 
  writel(0U,(void volatile *)(hw->hw_addr + (i + 59392U) * 4U));
  
#line 1028 
  writel(0U,(void volatile *)(hw->hw_addr + (i + 294912U) * 4U));
  
#line 1024 
  i += 1U;
  ldv_53110: 
#line 1025 
  ;
  
#line 1024 
  if (i < num_queues) 
#line 1026 
                      goto ldv_53109; else 
#line 1029 
                                           goto ldv_53111;
  ldv_53111: 
#line 1030 
  ;
  
#line 1032 
  __const_udelay(214750UL);
  
#line 1034 
  return;
}


#line 1042  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_clear_pxe_mode(struct i40e_hw *hw)
{
  u32 reg;
  bool tmp;
  
#line 1046 
  tmp = i40e_check_asq_alive(hw);
  
#line 1046 
  if ((int)tmp != 0) 
#line 1047 
                     i40e_aq_clear_pxe_mode(hw,(struct i40e_asq_cmd_details *)0); else ;
  
#line 1050 
  reg = readl((void const volatile *)(hw->hw_addr + 1221888U));
  
#line 1052 
  if ((unsigned int)hw->revision_id == 0U) 
#line 1054 
                                           writel(reg & 4294967294U,(void volatile *)(hw->hw_addr + 1221888U)); else 
                                                                    
#line 1056 
                                                                    writel(reg | 1U,(void volatile *)(hw->hw_addr + 1221888U));
  
#line 1057 
  return;
}


#line 1067  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
static u32 i40e_led_is_mine(struct i40e_hw *hw, int idx)
{
  u32 __retres;
  u32 port;
  
#line 1069 
  u32 gpio_val = 0U;
  
#line 1072 
  if (! hw->func_caps.led[idx]) {
    
#line 1073 
    __retres = 0U;
    
#line 1073 
    goto return_label;
  }
  else ;
  
#line 1075 
  gpio_val = readl((void const volatile *)(hw->hw_addr + (idx + 139328) * 4));
  
#line 1076 
  port = gpio_val & 3U;
  
#line 1082 
  if ((gpio_val & 8U) != 0U || (unsigned int)hw->port != port) {
    
#line 1084 
    __retres = 0U;
    
#line 1084 
    goto return_label;
  }
  else ;
  
#line 1086 
  __retres = gpio_val;
  return_label: 
#line 1086 
                return __retres;
}


#line 1104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
u32 i40e_led_get(struct i40e_hw *hw)
{
  int i;
  
#line 1106 
  u32 current_mode = 0U;
  
#line 1107 
  u32 mode = 0U;
  
#line 1113 
  i = 22;
  
#line 1113 
  goto ldv_53137;
  ldv_53136: 
#line 1114 
  ;
  {
    
#line 1114 
    u32 gpio_val = i40e_led_is_mine(hw,i);
    
#line 1116 
    if (gpio_val == 0U) 
#line 1117 
                        goto ldv_53129; else ;
    
#line 1122 
    current_mode = (gpio_val >> 12) & 31U;
    
#line 1124 
    switch (current_mode) {
      case (u32)10: 
#line 1125 
      ;
      case (u32)14: 
#line 1126 
      ;
      case (u32)13: 
#line 1127 
      ;
      
#line 1128 
      goto ldv_53129;
      default: 
#line 1129 
      ;
      
#line 1130 
      goto ldv_53134;
    }
    ldv_53134: 
#line 1133 
    ;
    
#line 1133 
    mode = (gpio_val >> 12) & 31U;
    
#line 1135 
    goto ldv_53135;
  }
  ldv_53129: 
#line 1137 
  ;
  
#line 1113 
  i += 1;
  ldv_53137: 
#line 1114 
  ;
  
#line 1113 
  if (i <= 29) 
#line 1115 
               goto ldv_53136; else 
#line 1118 
                                    goto ldv_53135;
  ldv_53135: 
#line 1119 
  ;
  
#line 1138 
  return mode;
}


#line 1150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_led_set(struct i40e_hw *hw, u32 mode, bool blink)
{
  int i;
  
#line 1152 
  u32 current_mode = 0U;
  
#line 1155 
  if ((mode & 4294967280U) != 0U) ; else ;
  
#line 1161 
  i = 22;
  
#line 1161 
  goto ldv_53154;
  ldv_53153: 
#line 1162 
  ;
  {
    
#line 1162 
    u32 gpio_val = i40e_led_is_mine(hw,i);
    
#line 1164 
    if (gpio_val == 0U) 
#line 1165 
                        goto ldv_53146; else ;
    
#line 1170 
    current_mode = (gpio_val >> 12) & 31U;
    
#line 1172 
    switch (current_mode) {
      case (u32)10: 
#line 1173 
      ;
      case (u32)14: 
#line 1174 
      ;
      case (u32)13: 
#line 1175 
      ;
      
#line 1176 
      goto ldv_53146;
      default: 
#line 1177 
      ;
      
#line 1178 
      goto ldv_53151;
    }
    ldv_53151: 
#line 1181 
    ;
    
#line 1181 
    gpio_val &= 4294840319U;
    
#line 1183 
    gpio_val = ((mode << 12) & 126976U) | gpio_val;
    
#line 1186 
    if (mode == 12U) 
#line 1187 
                     blink = (_Bool)0; else ;
    
#line 1189 
    if ((int)blink != 0) 
#line 1190 
                         gpio_val |= 2048U; else 
#line 1192 
                                                 gpio_val &= 4294965247U;
    
#line 1194 
    writel(gpio_val,(void volatile *)(hw->hw_addr + (i + 139328) * 4));
    
#line 1195 
    goto ldv_53152;
  }
  ldv_53146: 
#line 1197 
  ;
  
#line 1161 
  i += 1;
  ldv_53154: 
#line 1162 
  ;
  
#line 1161 
  if (i <= 29) 
#line 1163 
               goto ldv_53153; else 
#line 1166 
                                    goto ldv_53152;
  ldv_53152: 
#line 1167 
  ;
  
#line 1168 
  return;
}


#line 1211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_get_phy_capabilities(struct i40e_hw *hw, bool qualified_modules, bool report_init, struct i40e_aq_get_phy_abilities_resp *abilities, struct i40e_asq_cmd_details *cmd_details)
{
  enum i40e_status_code __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1218 
  u16 abilities_size = (unsigned short)536U;
  
#line 1220 
  if (abilities == (struct i40e_aq_get_phy_abilities_resp *)0) {
    
#line 1221 
    __retres = I40E_ERR_PARAM;
    
#line 1221 
    goto return_label;
  }
  else ;
  
#line 1223 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1536);
  
#line 1226 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 1227 
  if ((unsigned int)abilities_size > 512U) 
#line 1228 
                                           desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 1230 
  if ((int)qualified_modules != 0) 
#line 1231 
                                   desc.params.external.param0 |= 1U; else ;
  
#line 1234 
  if ((int)report_init != 0) 
#line 1235 
                             desc.params.external.param0 |= 2U; else ;
  
#line 1238 
  status = i40e_asq_send_command(hw,& desc,(void *)abilities,(unsigned short)((int)abilities_size),cmd_details);
  
#line 1241 
  if (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EIO) 
#line 1242 
                                                              status = I40E_ERR_UNKNOWN_PHY; else ;
  
#line 1244 
  __retres = status;
  return_label: 
#line 1244 
                return __retres;
}


#line 1259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_phy_config(struct i40e_hw *hw, struct i40e_aq_set_phy_config *config, struct i40e_asq_cmd_details *cmd_details)
{
  enum i40e_status_code __retres;
  struct i40e_aq_desc desc;
  enum i40e_status_code status;
  
#line 1264 
  struct i40e_aq_set_phy_config *cmd = (struct i40e_aq_set_phy_config *)(& desc.params.raw);
  
#line 1268 
  if (config == (struct i40e_aq_set_phy_config *)0) {
    
#line 1269 
    __retres = I40E_ERR_PARAM;
    
#line 1269 
    goto return_label;
  }
  else ;
  
#line 1271 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1537);
  
#line 1274 
  *cmd = *config;
  
#line 1276 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1278 
  __retres = status;
  return_label: 
#line 1278 
                return __retres;
}


#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_set_fc(struct i40e_hw *hw, u8 *aq_failures, bool atomic_restart)
{
  enum i40e_status_code __retres;
  struct i40e_aq_get_phy_abilities_resp abilities;
  struct i40e_aq_set_phy_config config;
  enum i40e_status_code status;
  
#line 1290 
  enum i40e_fc_mode fc_mode = hw->fc.requested_mode;
  
#line 1294 
  u8 pause_mask = (unsigned char)0U;
  
#line 1296 
  *aq_failures = (unsigned char)0U;
  
#line 1298 
  switch ((unsigned int)fc_mode) {
    case (unsigned int)3: 
#line 1299 
    ;
    
#line 1300 
    pause_mask = (unsigned char)((unsigned int)pause_mask | 1U);
    
#line 1301 
    pause_mask = (unsigned char)((unsigned int)pause_mask | 2U);
    
#line 1302 
    goto ldv_53184;
    case (unsigned int)1: 
#line 1303 
    ;
    
#line 1304 
    pause_mask = (unsigned char)((unsigned int)pause_mask | 2U);
    
#line 1305 
    goto ldv_53184;
    case (unsigned int)2: 
#line 1306 
    ;
    
#line 1307 
    pause_mask = (unsigned char)((unsigned int)pause_mask | 1U);
    
#line 1308 
    goto ldv_53184;
    default: 
#line 1309 
    ;
    
#line 1310 
    goto ldv_53184;
  }
  ldv_53184: 
#line 1314 
  ;
  
#line 1314 
  status = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
  
#line 1316 
  if (status != I40E_SUCCESS) {
    
#line 1317 
    *aq_failures = (unsigned char)((unsigned int)*aq_failures | 1U);
    
#line 1318 
    __retres = status;
    
#line 1318 
    goto return_label;
  }
  else ;
  
#line 1321 
  memset((void *)(& config),0,16UL);
  
#line 1323 
  config.abilities = (unsigned char)((unsigned int)abilities.abilities & 252U);
  
#line 1326 
  config.abilities = (unsigned char)((int)config.abilities | (int)pause_mask);
  
#line 1328 
  if ((int)config.abilities != (int)abilities.abilities) {
    
#line 1330 
    if ((int)atomic_restart != 0) 
#line 1331 
                                  config.abilities = (unsigned char)((unsigned int)config.abilities | 32U); else ;
    
#line 1333 
    config.phy_type = abilities.phy_type;
    
#line 1334 
    config.link_speed = abilities.link_speed;
    
#line 1335 
    config.eee_capability = abilities.eee_capability;
    
#line 1336 
    config.eeer = abilities.eeer_val;
    
#line 1337 
    config.low_power_ctrl = abilities.d3_lpan;
    
#line 1338 
    status = i40e_aq_set_phy_config(hw,& config,(struct i40e_asq_cmd_details *)0);
    
#line 1340 
    if (status != I40E_SUCCESS) 
#line 1341 
                                *aq_failures = (unsigned char)((unsigned int)*aq_failures | 2U); else ;
  }
  else ;
  
#line 1344 
  status = i40e_aq_get_link_info(hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
  
#line 1345 
  if (status != I40E_SUCCESS) {
    
#line 1350 
    msleep(1000U);
    
#line 1351 
    status = i40e_aq_get_link_info(hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
  }
  else ;
  
#line 1353 
  if (status != I40E_SUCCESS) 
#line 1354 
                              *aq_failures = (unsigned char)((unsigned int)*aq_failures | 4U); else ;
  
#line 1356 
  __retres = status;
  return_label: 
#line 1356 
                return __retres;
}


#line 1366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_clear_pxe_mode(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status status;
  struct i40e_aq_desc desc;
  
#line 1371 
  struct i40e_aqc_clear_pxe *cmd = (struct i40e_aqc_clear_pxe *)(& desc.params.raw);
  
#line 1374 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)272);
  
#line 1377 
  cmd->rx_cnt = (unsigned char)2U;
  
#line 1379 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1381 
  writel(1U,(void volatile *)(hw->hw_addr + 1221888U));
  
#line 1383 
  return status;
}


#line 1394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_link_restart_an(struct i40e_hw *hw, bool enable_link, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1399 
  struct i40e_aqc_set_link_restart_an *cmd = (struct i40e_aqc_set_link_restart_an *)(& desc.params.raw);
  
#line 1403 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1541);
  
#line 1406 
  cmd->command = (unsigned char)2U;
  
#line 1407 
  if ((int)enable_link != 0) 
#line 1408 
                             cmd->command = (unsigned char)((unsigned int)cmd->command | 4U); else 
                                                                    
#line 1410 
                                                                    cmd->command = (unsigned char)((unsigned int)cmd->command & 251U);
  
#line 1412 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1414 
  return status;
}


#line 1426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_link_info(struct i40e_hw *hw, bool enable_lse, struct i40e_link_status *link, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  bool tx_pause;
  bool rx_pause;
  u16 command_flags;
  
#line 1431 
  struct i40e_aqc_get_link_status *resp = (struct i40e_aqc_get_link_status *)(& desc.params.raw);
  
#line 1433 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  
#line 1438 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1543);
  
#line 1440 
  if ((int)enable_lse != 0) 
#line 1441 
                            command_flags = (unsigned short)3U; else 
                                                                  
#line 1443 
                                                                  command_flags = (unsigned short)2U;
  
#line 1444 
  resp->command_flags = command_flags;
  
#line 1446 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1448 
  if (status != I40E_SUCCESS) 
#line 1449 
                              goto aq_get_link_info_exit; else ;
  
#line 1452 
  hw->phy.link_info_old = *hw_link_info;
  
#line 1455 
  hw_link_info->phy_type = (enum i40e_aq_phy_type)resp->phy_type;
  
#line 1456 
  hw->phy.media_type = i40e_get_media_type(hw);
  
#line 1457 
  hw_link_info->link_speed = (enum i40e_aq_link_speed)resp->link_speed;
  
#line 1458 
  hw_link_info->link_info = resp->link_info;
  
#line 1459 
  hw_link_info->an_info = resp->an_info;
  
#line 1460 
  hw_link_info->ext_info = resp->ext_info;
  
#line 1461 
  hw_link_info->loopback = resp->loopback;
  
#line 1462 
  hw_link_info->max_frame_size = resp->max_frame_size;
  
#line 1463 
  hw_link_info->pacing = (unsigned char)((unsigned int)resp->config & 120U);
  
#line 1466 
  tx_pause = (_Bool)(((int)resp->an_info & 32) != 0);
  
#line 1467 
  rx_pause = (_Bool)(((int)resp->an_info & 64) != 0);
  
#line 1468 
  if (((int)tx_pause & (int)rx_pause) != 0) 
#line 1469 
                                            hw->fc.current_mode = I40E_FC_FULL;
  else 
    
#line 1470 
    if ((int)tx_pause != 0) 
#line 1471 
                            hw->fc.current_mode = I40E_FC_TX_PAUSE;
    else 
      
#line 1472 
      if ((int)rx_pause != 0) 
#line 1473 
                              hw->fc.current_mode = I40E_FC_RX_PAUSE; else 
                                                                    
#line 1475 
                                                                    hw->fc.current_mode = I40E_FC_NONE;
  
#line 1477 
  if (((int)resp->config & 4) != 0) 
#line 1478 
                                    hw_link_info->crc_enable = (_Bool)1; else 
                                                                    
#line 1480 
                                                                    hw_link_info->crc_enable = (_Bool)0;
  
#line 1482 
  if (((int)resp->command_flags & 3) != 0) 
#line 1483 
                                           hw_link_info->lse_enable = (_Bool)1; else 
                                                                    
#line 1485 
                                                                    hw_link_info->lse_enable = (_Bool)0;
  
#line 1487 
  if (((unsigned int)hw->aq.fw_maj_ver <= 3U || ((unsigned int)hw->aq.fw_maj_ver == 4U && (unsigned int)hw->aq.fw_min_ver <= 39U)) && hw_link_info->phy_type == (unsigned int)14) 
    
#line 1489 
    hw_link_info->phy_type = I40E_PHY_TYPE_10GBASE_SFPP_CU; else ;
  
#line 1492 
  if (link != (struct i40e_link_status *)0) 
#line 1493 
                                            *link = *hw_link_info; else ;
  
#line 1496 
  hw->phy.get_link_info = (_Bool)0;
  aq_get_link_info_exit: 
#line 1498 
  ;
  
#line 1499 
  return status;
}


#line 1510  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_phy_int_mask(struct i40e_hw *hw, u16 mask, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1515 
  struct i40e_aqc_set_phy_int_mask *cmd = (struct i40e_aqc_set_phy_int_mask *)(& desc.params.raw);
  
#line 1519 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1555);
  
#line 1522 
  cmd->event_mask = mask;
  
#line 1524 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1526 
  return status;
}


#line 1537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_vsi(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1542 
  struct i40e_aqc_add_get_update_vsi *cmd = (struct i40e_aqc_add_get_update_vsi *)(& desc.params.raw);
  
#line 1544 
  struct i40e_aqc_add_get_update_vsi_completion *resp = (struct i40e_aqc_add_get_update_vsi_completion *)(& desc.params.raw);
  
#line 1549 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)528);
  
#line 1552 
  cmd->uplink_seid = vsi_ctx->uplink_seid;
  
#line 1553 
  cmd->connection_type = vsi_ctx->connection_type;
  
#line 1554 
  cmd->vf_id = vsi_ctx->vf_num;
  
#line 1555 
  cmd->vsi_flags = vsi_ctx->flags;
  
#line 1557 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  
#line 1559 
  status = i40e_asq_send_command(hw,& desc,(void *)(& vsi_ctx->info),(unsigned short)128,cmd_details);
  
#line 1562 
  if (status != I40E_SUCCESS) 
#line 1563 
                              goto aq_add_vsi_exit; else ;
  
#line 1565 
  vsi_ctx->seid = resp->seid;
  
#line 1566 
  vsi_ctx->vsi_number = resp->vsi_number;
  
#line 1567 
  vsi_ctx->vsis_allocated = resp->vsi_used;
  
#line 1568 
  vsi_ctx->vsis_unallocated = resp->vsi_free;
  aq_add_vsi_exit: 
#line 1570 
  ;
  
#line 1571 
  return status;
}


#line 1581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_unicast_promiscuous(struct i40e_hw *hw, u16 seid, bool set, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1586 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  
#line 1589 
  u16 flags = (unsigned short)0U;
  
#line 1591 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  
#line 1594 
  if ((int)set != 0) 
#line 1595 
                     flags = (unsigned short)((unsigned int)flags | 1U); else ;
  
#line 1597 
  cmd->promiscuous_flags = flags;
  
#line 1599 
  cmd->valid_flags = (unsigned short)1U;
  
#line 1601 
  cmd->seid = seid;
  
#line 1602 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1604 
  return status;
}


#line 1614  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_multicast_promiscuous(struct i40e_hw *hw, u16 seid, bool set, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1618 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  
#line 1621 
  u16 flags = (unsigned short)0U;
  
#line 1623 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  
#line 1626 
  if ((int)set != 0) 
#line 1627 
                     flags = (unsigned short)((unsigned int)flags | 2U); else ;
  
#line 1629 
  cmd->promiscuous_flags = flags;
  
#line 1631 
  cmd->valid_flags = (unsigned short)2U;
  
#line 1633 
  cmd->seid = seid;
  
#line 1634 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1636 
  return status;
}


#line 1648  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_broadcast(struct i40e_hw *hw, u16 seid, bool set_filter, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1653 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  
#line 1657 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  
#line 1660 
  if ((int)set_filter != 0) 
#line 1662 
                            cmd->promiscuous_flags = (unsigned short)((unsigned int)cmd->promiscuous_flags | 4U); else 
                                                                    
#line 1665 
                                                                    cmd->promiscuous_flags = (unsigned short)((unsigned int)cmd->promiscuous_flags & 65531U);
  
#line 1667 
  cmd->valid_flags = (unsigned short)4U;
  
#line 1668 
  cmd->seid = seid;
  
#line 1669 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1671 
  return status;
}


#line 1680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_vsi_params(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1685 
  struct i40e_aqc_add_get_update_vsi *cmd = (struct i40e_aqc_add_get_update_vsi *)(& desc.params.raw);
  
#line 1687 
  struct i40e_aqc_add_get_update_vsi_completion *resp = (struct i40e_aqc_add_get_update_vsi_completion *)(& desc.params.raw);
  
#line 1692 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)530);
  
#line 1695 
  cmd->uplink_seid = vsi_ctx->seid;
  
#line 1697 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 1699 
  status = i40e_asq_send_command(hw,& desc,(void *)(& vsi_ctx->info),(unsigned short)128,(struct i40e_asq_cmd_details *)0);
  
#line 1702 
  if (status != I40E_SUCCESS) 
#line 1703 
                              goto aq_get_vsi_params_exit; else ;
  
#line 1705 
  vsi_ctx->seid = resp->seid;
  
#line 1706 
  vsi_ctx->vsi_number = resp->vsi_number;
  
#line 1707 
  vsi_ctx->vsis_allocated = resp->vsi_used;
  
#line 1708 
  vsi_ctx->vsis_unallocated = resp->vsi_free;
  aq_get_vsi_params_exit: 
#line 1710 
  ;
  
#line 1711 
  return status;
}


#line 1722  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_update_vsi_params(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1727 
  struct i40e_aqc_add_get_update_vsi *cmd = (struct i40e_aqc_add_get_update_vsi *)(& desc.params.raw);
  
#line 1731 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)529);
  
#line 1733 
  cmd->uplink_seid = vsi_ctx->seid;
  
#line 1735 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  
#line 1737 
  status = i40e_asq_send_command(hw,& desc,(void *)(& vsi_ctx->info),(unsigned short)128,cmd_details);
  
#line 1740 
  return status;
}


#line 1753  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_switch_config(struct i40e_hw *hw, struct i40e_aqc_get_switch_config_resp *buf, u16 buf_size, u16 *start_seid, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1759 
  struct i40e_aqc_switch_seid *scfg = (struct i40e_aqc_switch_seid *)(& desc.params.raw);
  
#line 1763 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)512);
  
#line 1765 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 1766 
  if ((unsigned int)buf_size > 512U) 
#line 1767 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 1768 
  scfg->seid = *start_seid;
  
#line 1770 
  status = i40e_asq_send_command(hw,& desc,(void *)buf,(unsigned short)((int)buf_size),cmd_details);
  
#line 1771 
  *start_seid = scfg->seid;
  
#line 1773 
  return status;
}


#line 1788  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_firmware_version(struct i40e_hw *hw, u16 *fw_major_version, u16 *fw_minor_version, u32 *fw_build, u16 *api_major_version, u16 *api_minor_version, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1795 
  struct i40e_aqc_get_version *resp = (struct i40e_aqc_get_version *)(& desc.params.raw);
  
#line 1799 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1);
  
#line 1801 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1803 
  if (status == I40E_SUCCESS) {
    
#line 1804 
    if (fw_major_version != (u16 *)0U) 
#line 1805 
                                       *fw_major_version = resp->fw_major; else ;
    
#line 1806 
    if (fw_minor_version != (u16 *)0U) 
#line 1807 
                                       *fw_minor_version = resp->fw_minor; else ;
    
#line 1808 
    if (fw_build != (u32 *)0U) 
#line 1809 
                               *fw_build = resp->fw_build; else ;
    
#line 1810 
    if (api_major_version != (u16 *)0U) 
#line 1811 
                                        *api_major_version = resp->api_major; else ;
    
#line 1812 
    if (api_minor_version != (u16 *)0U) 
#line 1813 
                                        *api_minor_version = resp->api_minor; else ;
  }
  else ;
  
#line 1816 
  return status;
}


#line 1827  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_send_driver_version(struct i40e_hw *hw, struct i40e_driver_version *dv, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  u16 len;
  
#line 1832 
  struct i40e_aqc_driver_version *cmd = (struct i40e_aqc_driver_version *)(& desc.params.raw);
  
#line 1837 
  if (dv == (struct i40e_driver_version *)0) {
    
#line 1838 
    __retres = I40E_ERR_PARAM;
    
#line 1838 
    goto return_label;
  }
  else ;
  
#line 1840 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2);
  
#line 1842 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  
#line 1843 
  cmd->driver_major_ver = dv->major_version;
  
#line 1844 
  cmd->driver_minor_ver = dv->minor_version;
  
#line 1845 
  cmd->driver_build_ver = dv->build_version;
  
#line 1846 
  cmd->driver_subbuild_ver = dv->subbuild_version;
  
#line 1848 
  len = (unsigned short)0U;
  
#line 1849 
  goto ldv_53314;
  ldv_53313: 
#line 1850 
  ;
  
#line 1852 
  len = (u16)((int)len + 1);
  ldv_53314: 
#line 1853 
  ;
  
#line 1849 
  if (((unsigned int)len <= 31U && (int)dv->driver_string[(int)len] >= 0) && (unsigned int)dv->driver_string[(int)len] != 0U) 
    
#line 1852 
    goto ldv_53313; else 
#line 1855 
                         goto ldv_53315;
  ldv_53315: 
#line 1856 
  ;
  
#line 1853 
  status = i40e_asq_send_command(hw,& desc,(void *)(& dv->driver_string),(unsigned short)((int)len),cmd_details);
  
#line 1856 
  __retres = status;
  return_label: 
#line 1856 
                return __retres;
}


#line 1867  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
bool i40e_get_link_status(struct i40e_hw *hw)
{
  
#line 1869 
  i40e_status status = 0;
  
#line 1870 
  bool link_status = (_Bool)0;
  
#line 1872 
  if ((int)hw->phy.get_link_info != 0) {
    
#line 1873 
    status = i40e_aq_get_link_info(hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
    
#line 1875 
    if (status != I40E_SUCCESS) 
#line 1876 
                                goto i40e_get_link_status_exit; else ;
  }
  else ;
  
#line 1879 
  link_status = (_Bool)(((int)hw->phy.link_info.link_info & 1) != 0);
  i40e_get_link_status_exit: 
#line 1881 
  ;
  
#line 1882 
  return link_status;
}


#line 1899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_veb(struct i40e_hw *hw, u16 uplink_seid, u16 downlink_seid, u8 enabled_tc, bool default_port, bool enable_l2_filtering, u16 *veb_seid, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1906 
  struct i40e_aqc_add_veb *cmd = (struct i40e_aqc_add_veb *)(& desc.params.raw);
  
#line 1908 
  struct i40e_aqc_add_veb_completion *resp = (struct i40e_aqc_add_veb_completion *)(& desc.params.raw);
  
#line 1911 
  u16 veb_flags = (unsigned short)0U;
  
#line 1914 
  if (((unsigned int)uplink_seid != 0U) ^ ((unsigned int)downlink_seid != 0U)) {
    
#line 1915 
    __retres = I40E_ERR_PARAM;
    
#line 1915 
    goto return_label;
  }
  else ;
  
#line 1917 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)560);
  
#line 1919 
  cmd->uplink_seid = uplink_seid;
  
#line 1920 
  cmd->downlink_seid = downlink_seid;
  
#line 1921 
  cmd->enable_tcs = enabled_tc;
  
#line 1922 
  if ((unsigned int)uplink_seid == 0U) 
#line 1923 
                                       veb_flags = (unsigned short)((unsigned int)veb_flags | 1U); else ;
  
#line 1924 
  if ((int)default_port != 0) 
#line 1925 
                              veb_flags = (unsigned short)((unsigned int)veb_flags | 2U); else 
                                                                    
#line 1927 
                                                                    veb_flags = (unsigned short)((unsigned int)veb_flags | 4U);
  
#line 1929 
  if ((int)enable_l2_filtering != 0) 
#line 1930 
                                     veb_flags = (unsigned short)((unsigned int)veb_flags | 8U); else ;
  
#line 1932 
  cmd->veb_flags = veb_flags;
  
#line 1934 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1936 
  if (status == I40E_SUCCESS && veb_seid != (u16 *)0U) 
#line 1937 
                                                       *veb_seid = resp->veb_seid; else ;
  
#line 1939 
  __retres = status;
  return_label: 
#line 1939 
                return __retres;
}


#line 1956  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_veb_parameters(struct i40e_hw *hw, u16 veb_seid, u16 *switch_id, bool *floating, u16 *statistic_index, u16 *vebs_used, u16 *vebs_free, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 1963 
  struct i40e_aqc_get_veb_parameters_completion *cmd_resp = (struct i40e_aqc_get_veb_parameters_completion *)(& desc.params.raw);
  
#line 1968 
  if ((unsigned int)veb_seid == 0U) {
    
#line 1969 
    __retres = I40E_ERR_PARAM;
    
#line 1969 
    goto return_label;
  }
  else ;
  
#line 1971 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)562);
  
#line 1973 
  cmd_resp->seid = veb_seid;
  
#line 1975 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 1976 
  if (status != I40E_SUCCESS) 
#line 1977 
                              goto get_veb_exit; else ;
  
#line 1979 
  if (switch_id != (u16 *)0U) 
#line 1980 
                              *switch_id = cmd_resp->switch_id; else ;
  
#line 1981 
  if (statistic_index != (u16 *)0U) 
#line 1982 
                                    *statistic_index = cmd_resp->statistic_index; else ;
  
#line 1983 
  if (vebs_used != (u16 *)0U) 
#line 1984 
                              *vebs_used = cmd_resp->vebs_used; else ;
  
#line 1985 
  if (vebs_free != (u16 *)0U) 
#line 1986 
                              *vebs_free = cmd_resp->vebs_free; else ;
  
#line 1987 
  if (floating != (bool *)0) {
    
#line 1988 
    u16 flags = cmd_resp->veb_flags;
    
#line 1989 
    if (((int)flags & 1) != 0) 
#line 1990 
                               *floating = (_Bool)1; else 
#line 1992 
                                                          *floating = (_Bool)0;
  }
  else ;
  get_veb_exit: 
#line 1995 
  ;
  
#line 1996 
  __retres = status;
  return_label: 
#line 1996 
                return __retres;
}


#line 2009  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_macvlan(struct i40e_hw *hw, u16 seid, struct i40e_aqc_add_macvlan_element_data *mv_list, u16 count, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  u16 buf_size;
  
#line 2014 
  struct i40e_aqc_macvlan *cmd = (struct i40e_aqc_macvlan *)(& desc.params.raw);
  
#line 2019 
  if (((unsigned int)count == 0U || mv_list == (struct i40e_aqc_add_macvlan_element_data *)0) || hw == (struct i40e_hw *)0) {
    
#line 2020 
    __retres = I40E_ERR_PARAM;
    
#line 2020 
    goto return_label;
  }
  else ;
  
#line 2022 
  buf_size = (unsigned short)((unsigned int)count * 16U);
  
#line 2025 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)592);
  
#line 2026 
  cmd->num_addresses = count;
  
#line 2027 
  cmd->seid[0] = (unsigned short)((unsigned int)seid | 32768U);
  
#line 2028 
  cmd->seid[1] = (unsigned short)0U;
  
#line 2029 
  cmd->seid[2] = (unsigned short)0U;
  
#line 2031 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  
#line 2032 
  if ((unsigned int)buf_size > 512U) 
#line 2033 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 2035 
  status = i40e_asq_send_command(hw,& desc,(void *)mv_list,(unsigned short)((int)buf_size),cmd_details);
  
#line 2038 
  __retres = status;
  return_label: 
#line 2038 
                return __retres;
}


#line 2051  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_remove_macvlan(struct i40e_hw *hw, u16 seid, struct i40e_aqc_remove_macvlan_element_data *mv_list, u16 count, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  u16 buf_size;
  
#line 2056 
  struct i40e_aqc_macvlan *cmd = (struct i40e_aqc_macvlan *)(& desc.params.raw);
  
#line 2061 
  if (((unsigned int)count == 0U || mv_list == (struct i40e_aqc_remove_macvlan_element_data *)0) || hw == (struct i40e_hw *)0) {
    
#line 2062 
    __retres = I40E_ERR_PARAM;
    
#line 2062 
    goto return_label;
  }
  else ;
  
#line 2064 
  buf_size = (unsigned short)((unsigned int)count * 16U);
  
#line 2067 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)593);
  
#line 2068 
  cmd->num_addresses = count;
  
#line 2069 
  cmd->seid[0] = (unsigned short)((unsigned int)seid | 32768U);
  
#line 2070 
  cmd->seid[1] = (unsigned short)0U;
  
#line 2071 
  cmd->seid[2] = (unsigned short)0U;
  
#line 2073 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  
#line 2074 
  if ((unsigned int)buf_size > 512U) 
#line 2075 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 2077 
  status = i40e_asq_send_command(hw,& desc,(void *)mv_list,(unsigned short)((int)buf_size),cmd_details);
  
#line 2080 
  __retres = status;
  return_label: 
#line 2080 
                return __retres;
}


#line 2095  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_send_msg_to_vf(struct i40e_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2100 
  struct i40e_aqc_pf_vf_message *cmd = (struct i40e_aqc_pf_vf_message *)(& desc.params.raw);
  
#line 2104 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2050);
  
#line 2105 
  cmd->id = (unsigned int)vfid;
  
#line 2106 
  desc.cookie_high = v_opcode;
  
#line 2107 
  desc.cookie_low = v_retval;
  
#line 2108 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 8192U);
  
#line 2109 
  if ((unsigned int)msglen != 0U) {
    
#line 2110 
    desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
    
#line 2112 
    if ((unsigned int)msglen > 512U) 
#line 2113 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
    
#line 2114 
    desc.datalen = msglen;
  }
  else ;
  
#line 2116 
  status = i40e_asq_send_command(hw,& desc,(void *)msg,(unsigned short)((int)msglen),cmd_details);
  
#line 2118 
  return status;
}


#line 2130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_read_register(struct i40e_hw *hw, u32 reg_addr, u64 *reg_val, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2135 
  struct i40e_aqc_debug_reg_read_write *cmd_resp = (struct i40e_aqc_debug_reg_read_write *)(& desc.params.raw);
  
#line 2139 
  if (reg_val == (u64 *)0ULL) {
    
#line 2140 
    __retres = I40E_ERR_PARAM;
    
#line 2140 
    goto return_label;
  }
  else ;
  
#line 2142 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)65283);
  
#line 2144 
  cmd_resp->address = reg_addr;
  
#line 2146 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2148 
  if (status == I40E_SUCCESS) 
#line 2149 
                              *reg_val = ((unsigned long long)cmd_resp->value_high << 32) | (unsigned long long)cmd_resp->value_low; else ;
  
#line 2153 
  __retres = status;
  return_label: 
#line 2153 
                return __retres;
}


#line 2165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_write_register(struct i40e_hw *hw, u32 reg_addr, u64 reg_val, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2170 
  struct i40e_aqc_debug_reg_read_write *cmd = (struct i40e_aqc_debug_reg_read_write *)(& desc.params.raw);
  
#line 2174 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)65284);
  
#line 2176 
  cmd->address = reg_addr;
  
#line 2177 
  cmd->value_high = (unsigned int)(reg_val >> 32);
  
#line 2178 
  cmd->value_low = (unsigned int)reg_val;
  
#line 2180 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2182 
  return status;
}


#line 2194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_hmc_resource_profile(struct i40e_hw *hw, enum i40e_aq_hmc_profile profile, u8 pe_vf_enabled_count, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2200 
  struct i40e_aq_get_set_hmc_resource_profile *cmd = (struct i40e_aq_get_set_hmc_resource_profile *)(& desc.params.raw);
  
#line 2204 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1281);
  
#line 2207 
  cmd->pm_profile = (unsigned char)profile;
  
#line 2208 
  cmd->pe_vf_enabled = pe_vf_enabled_count;
  
#line 2210 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2212 
  return status;
}


#line 2226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_request_resource(struct i40e_hw *hw, enum i40e_aq_resources_ids resource, enum i40e_aq_resource_access_type access, u8 sdp_number, u64 *timeout, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2233 
  struct i40e_aqc_request_resource *cmd_resp = (struct i40e_aqc_request_resource *)(& desc.params.raw);
  
#line 2237 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)8);
  
#line 2239 
  cmd_resp->resource_id = (unsigned short)resource;
  
#line 2240 
  cmd_resp->access_type = (unsigned short)access;
  
#line 2241 
  cmd_resp->resource_number = (unsigned int)sdp_number;
  
#line 2243 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2250 
  if (status == I40E_SUCCESS || hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EBUSY) 
    
#line 2251 
    *timeout = (unsigned long long)cmd_resp->timeout; else ;
  
#line 2253 
  return status;
}


#line 2265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_release_resource(struct i40e_hw *hw, enum i40e_aq_resources_ids resource, u8 sdp_number, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2271 
  struct i40e_aqc_request_resource *cmd = (struct i40e_aqc_request_resource *)(& desc.params.raw);
  
#line 2275 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)9);
  
#line 2277 
  cmd->resource_id = (unsigned short)resource;
  
#line 2278 
  cmd->resource_number = (unsigned int)sdp_number;
  
#line 2280 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2282 
  return status;
}


#line 2297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_read_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, void *data, bool last_command, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2303 
  struct i40e_aqc_nvm_update *cmd = (struct i40e_aqc_nvm_update *)(& desc.params.raw);
  
#line 2308 
  if ((offset & 4278190080U) != 0U) {
    
#line 2309 
    status = I40E_ERR_PARAM;
    
#line 2310 
    goto i40e_aq_read_nvm_exit;
  }
  else ;
  
#line 2313 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1793);
  
#line 2316 
  if ((int)last_command != 0) 
#line 2317 
                              cmd->command_flags = (unsigned char)((unsigned int)cmd->command_flags | 1U); else ;
  
#line 2318 
  cmd->module_pointer = module_pointer;
  
#line 2319 
  cmd->offset = offset;
  
#line 2320 
  cmd->length = length;
  
#line 2322 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 2323 
  if ((unsigned int)length > 512U) 
#line 2324 
                                   desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 2326 
  status = i40e_asq_send_command(hw,& desc,data,(unsigned short)((int)length),cmd_details);
  i40e_aq_read_nvm_exit: 
#line 2328 
  ;
  
#line 2329 
  return status;
}


#line 2343  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_erase_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, bool last_command, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2348 
  struct i40e_aqc_nvm_update *cmd = (struct i40e_aqc_nvm_update *)(& desc.params.raw);
  
#line 2353 
  if ((offset & 4278190080U) != 0U) {
    
#line 2354 
    status = I40E_ERR_PARAM;
    
#line 2355 
    goto i40e_aq_erase_nvm_exit;
  }
  else ;
  
#line 2358 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1794);
  
#line 2361 
  if ((int)last_command != 0) 
#line 2362 
                              cmd->command_flags = (unsigned char)((unsigned int)cmd->command_flags | 1U); else ;
  
#line 2363 
  cmd->module_pointer = module_pointer;
  
#line 2364 
  cmd->offset = offset;
  
#line 2365 
  cmd->length = length;
  
#line 2367 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  i40e_aq_erase_nvm_exit: 
#line 2369 
  ;
  
#line 2370 
  return status;
}


#line 2411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
static void i40e_parse_discover_capabilities(struct i40e_hw *hw, void *buff, u32 cap_count, enum i40e_admin_queue_opc list_type_opc)
{
  struct i40e_aqc_list_capabilities_element_resp *cap;
  u32 valid_functions;
  u32 num_functions;
  u32 number;
  u32 logical_id;
  u32 phys_id;
  struct i40e_hw_capabilities *p;
  u16 id;
  
#line 2419 
  u32 i = 0U;
  
#line 2422 
  cap = (struct i40e_aqc_list_capabilities_element_resp *)buff;
  
#line 2424 
  if (list_type_opc == (unsigned int)i40e_aqc_opc_list_dev_capabilities) 
    
#line 2425 
    p = & hw->dev_caps;
  else 
    
#line 2426 
    if (list_type_opc == (unsigned int)i40e_aqc_opc_list_func_capabilities) 
      
#line 2427 
      p = & hw->func_caps; else 
#line 2429 
                                goto return_label;
  
#line 2431 
  i = 0U;
  
#line 2431 
  goto ldv_53504;
  ldv_53503: 
#line 2432 
  ;
  
#line 2432 
  id = cap->id;
  
#line 2433 
  number = cap->number;
  
#line 2434 
  logical_id = cap->logical_id;
  
#line 2435 
  phys_id = cap->phys_id;
  
#line 2437 
  switch ((int)id) {
    case 1: 
#line 2438 
    ;
    
#line 2439 
    p->switch_mode = number;
    
#line 2440 
    goto ldv_53474;
    case 2: 
#line 2441 
    ;
    
#line 2442 
    p->management_mode = number;
    
#line 2443 
    goto ldv_53474;
    case 3: 
#line 2444 
    ;
    
#line 2445 
    p->npar_enable = number;
    
#line 2446 
    goto ldv_53474;
    case 4: 
#line 2447 
    ;
    
#line 2448 
    p->os2bmc = number;
    
#line 2449 
    goto ldv_53474;
    case 5: 
#line 2450 
    ;
    
#line 2451 
    p->valid_functions = number;
    
#line 2452 
    goto ldv_53474;
    case 18: 
#line 2453 
    ;
    
#line 2454 
    if (number == 1U) 
#line 2455 
                      p->sr_iov_1_1 = (_Bool)1; else ;
    
#line 2456 
    goto ldv_53474;
    case 19: 
#line 2457 
    ;
    
#line 2458 
    p->num_vfs = number;
    
#line 2459 
    p->vf_base_id = logical_id;
    
#line 2460 
    goto ldv_53474;
    case 20: 
#line 2461 
    ;
    
#line 2462 
    if (number == 1U) 
#line 2463 
                      p->vmdq = (_Bool)1; else ;
    
#line 2464 
    goto ldv_53474;
    case 21: 
#line 2465 
    ;
    
#line 2466 
    if (number == 1U) 
#line 2467 
                      p->evb_802_1_qbg = (_Bool)1; else ;
    
#line 2468 
    goto ldv_53474;
    case 22: 
#line 2469 
    ;
    
#line 2470 
    if (number == 1U) 
#line 2471 
                      p->evb_802_1_qbh = (_Bool)1; else ;
    
#line 2472 
    goto ldv_53474;
    case 23: 
#line 2473 
    ;
    
#line 2474 
    p->num_vsis = number;
    
#line 2475 
    goto ldv_53474;
    case 24: 
#line 2476 
    ;
    
#line 2477 
    if (number == 1U) {
      
#line 2478 
      p->dcb = (_Bool)1;
      
#line 2479 
      p->enabled_tcmap = logical_id;
      
#line 2480 
      p->maxtc = phys_id;
    }
    else ;
    
#line 2482 
    goto ldv_53474;
    case 33: 
#line 2483 
    ;
    
#line 2484 
    if (number == 1U) 
#line 2485 
                      p->fcoe = (_Bool)1; else ;
    
#line 2486 
    goto ldv_53474;
    case 34: 
#line 2487 
    ;
    
#line 2488 
    if (number == 1U) 
#line 2489 
                      p->iscsi = (_Bool)1; else ;
    
#line 2490 
    goto ldv_53474;
    case 64: 
#line 2491 
    ;
    
#line 2492 
    p->rss = (_Bool)1;
    
#line 2493 
    p->rss_table_size = number;
    
#line 2494 
    p->rss_table_entry_width = logical_id;
    
#line 2495 
    goto ldv_53474;
    case 65: 
#line 2496 
    ;
    
#line 2497 
    p->num_rx_qp = number;
    
#line 2498 
    p->base_queue = phys_id;
    
#line 2499 
    goto ldv_53474;
    case 66: 
#line 2500 
    ;
    
#line 2501 
    p->num_tx_qp = number;
    
#line 2502 
    p->base_queue = phys_id;
    
#line 2503 
    goto ldv_53474;
    case 67: 
#line 2504 
    ;
    
#line 2505 
    p->num_msix_vectors = number;
    
#line 2506 
    goto ldv_53474;
    case 68: 
#line 2507 
    ;
    
#line 2508 
    p->num_msix_vectors_vf = number;
    
#line 2509 
    goto ldv_53474;
    case 241: 
#line 2510 
    ;
    
#line 2511 
    if (number == 1U) 
#line 2512 
                      p->mfp_mode_1 = (_Bool)1; else ;
    
#line 2513 
    goto ldv_53474;
    case 242: 
#line 2514 
    ;
    
#line 2515 
    if (number == 1U) 
#line 2516 
                      p->mgmt_cem = (_Bool)1; else ;
    
#line 2517 
    goto ldv_53474;
    case 81: 
#line 2518 
    ;
    
#line 2519 
    if (number == 1U) 
#line 2520 
                      p->iwarp = (_Bool)1; else ;
    
#line 2521 
    goto ldv_53474;
    case 97: 
#line 2522 
    ;
    
#line 2523 
    if (phys_id <= 29U) 
#line 2524 
                        p->led[phys_id] = (_Bool)1; else ;
    
#line 2525 
    goto ldv_53474;
    case 98: 
#line 2526 
    ;
    
#line 2527 
    if (phys_id <= 29U) 
#line 2528 
                        p->sdp[phys_id] = (_Bool)1; else ;
    
#line 2529 
    goto ldv_53474;
    case 99: 
#line 2530 
    ;
    
#line 2531 
    if (number == 1U) {
      
#line 2532 
      p->mdio_port_num = phys_id;
      
#line 2533 
      p->mdio_port_mode = logical_id;
    }
    else ;
    
#line 2535 
    goto ldv_53474;
    case 70: 
#line 2536 
    ;
    
#line 2537 
    if (number == 1U) 
#line 2538 
                      p->ieee_1588 = (_Bool)1; else ;
    
#line 2539 
    goto ldv_53474;
    case 69: 
#line 2540 
    ;
    
#line 2541 
    p->fd = (_Bool)1;
    
#line 2542 
    p->fd_filters_guaranteed = number;
    
#line 2543 
    p->fd_filters_best_effort = logical_id;
    
#line 2544 
    goto ldv_53474;
    case 100: 
#line 2545 
    ;
    
#line 2546 
    p->wr_csr_prot = (unsigned long long)number;
    
#line 2547 
    p->wr_csr_prot |= (unsigned long long)logical_id << 32;
    
#line 2548 
    goto ldv_53474;
    default: 
#line 2549 
    ;
    
#line 2550 
    goto ldv_53474;
  }
  ldv_53474: 
#line 2552 
  ;
  
#line 2431 
  i += 1U;
  
#line 2431 
  cap += 1;
  ldv_53504: 
#line 2432 
  ;
  
#line 2431 
  if (i < cap_count) 
#line 2433 
                     goto ldv_53503; else 
#line 2436 
                                          goto ldv_53505;
  ldv_53505: 
#line 2437 
  ;
  
#line 2554 
  if ((int)p->fcoe != 0) {
    
#line 2555 
    if (hw->debug_mask != 0U) 
#line 2555 
                              printk("\001",(int)hw->bus.device,(int)hw->bus.func); else ;
  }
  else ;
  
#line 2560 
  if (p->npar_enable != 0U || (int)p->mfp_mode_1 != 0) 
#line 2561 
                                                       p->fcoe = (_Bool)0; else ;
  
#line 2564 
  hw->num_ports = (unsigned short)0U;
  
#line 2565 
  i = 0U;
  
#line 2565 
  goto ldv_53509;
  ldv_53508: 
#line 2566 
  ;
  {
    
#line 2566 
    u32 port_cfg_reg = (i + 188488U) * 4U;
    
#line 2567 
    u64 port_cfg = 0ULL;
    
#line 2572 
    i40e_aq_debug_read_register(hw,port_cfg_reg,& port_cfg,(struct i40e_asq_cmd_details *)0);
    
#line 2573 
    if ((port_cfg & 1ULL) == 0ULL) 
#line 2574 
                                   hw->num_ports = (u16)((int)hw->num_ports + 1); else ;
  }
  
#line 2565 
  i += 1U;
  ldv_53509: 
#line 2566 
  ;
  
#line 2565 
  if (i <= 3U) 
#line 2567 
               goto ldv_53508; else 
#line 2570 
                                    goto ldv_53510;
  ldv_53510: 
#line 2571 
  ;
  
#line 2577 
  valid_functions = p->valid_functions;
  
#line 2578 
  num_functions = 0U;
  
#line 2579 
  goto ldv_53512;
  ldv_53511: 
#line 2580 
  ;
  
#line 2580 
  if ((valid_functions & 1U) != 0U) 
#line 2581 
                                    num_functions += 1U; else ;
  
#line 2582 
  valid_functions >>= 1;
  ldv_53512: 
#line 2583 
  ;
  
#line 2579 
  if (valid_functions != 0U) 
#line 2581 
                             goto ldv_53511; else 
#line 2584 
                                                  goto ldv_53513;
  ldv_53513: 
#line 2585 
  ;
  
#line 2588 
  hw->partition_id = (unsigned short)((unsigned int)((unsigned short)((int)hw->pf_id / (int)hw->num_ports)) + 1U);
  
#line 2589 
  hw->num_partitions = (unsigned short)(num_functions / (unsigned int)hw->num_ports);
  
#line 2594 
  p->rx_buf_chain_len = (unsigned char)5U;
  return_label: 
#line 2595 
                return;
}


#line 2608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_discover_capabilities(struct i40e_hw *hw, void *buff, u16 buff_size, u16 *data_size, enum i40e_admin_queue_opc list_type_opc, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aqc_list_capabilites *cmd;
  struct i40e_aq_desc desc;
  
#line 2615 
  i40e_status status = 0;
  
#line 2617 
  cmd = (struct i40e_aqc_list_capabilites *)(& desc.params.raw);
  
#line 2619 
  if ((unsigned int)list_type_opc + 4294967286U > 1U) {
    
#line 2621 
    status = I40E_ERR_PARAM;
    
#line 2622 
    goto exit;
  }
  else ;
  
#line 2625 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)((int)((unsigned short)list_type_opc)));
  
#line 2627 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 2628 
  if ((unsigned int)buff_size > 512U) 
#line 2629 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 2631 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  
#line 2632 
  *data_size = desc.datalen;
  
#line 2634 
  if (status != I40E_SUCCESS) 
#line 2635 
                              goto exit; else ;
  
#line 2637 
  i40e_parse_discover_capabilities(hw,buff,cmd->count,list_type_opc);
  exit: 
#line 2640 
  ;
  
#line 2641 
  return status;
}


#line 2656  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_update_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, void *data, bool last_command, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2662 
  struct i40e_aqc_nvm_update *cmd = (struct i40e_aqc_nvm_update *)(& desc.params.raw);
  
#line 2667 
  if ((offset & 4278190080U) != 0U) {
    
#line 2668 
    status = I40E_ERR_PARAM;
    
#line 2669 
    goto i40e_aq_update_nvm_exit;
  }
  else ;
  
#line 2672 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1795);
  
#line 2675 
  if ((int)last_command != 0) 
#line 2676 
                              cmd->command_flags = (unsigned char)((unsigned int)cmd->command_flags | 1U); else ;
  
#line 2677 
  cmd->module_pointer = module_pointer;
  
#line 2678 
  cmd->offset = offset;
  
#line 2679 
  cmd->length = length;
  
#line 2681 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  
#line 2682 
  if ((unsigned int)length > 512U) 
#line 2683 
                                   desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 2685 
  status = i40e_asq_send_command(hw,& desc,data,(unsigned short)((int)length),cmd_details);
  i40e_aq_update_nvm_exit: 
#line 2687 
  ;
  
#line 2688 
  return status;
}


#line 2704  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_lldp_mib(struct i40e_hw *hw, u8 bridge_type, u8 mib_type, void *buff, u16 buff_size, u16 *local_len, u16 *remote_len, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2710 
  struct i40e_aqc_lldp_get_mib *cmd = (struct i40e_aqc_lldp_get_mib *)(& desc.params.raw);
  
#line 2712 
  struct i40e_aqc_lldp_get_mib *resp = (struct i40e_aqc_lldp_get_mib *)(& desc.params.raw);
  
#line 2716 
  if ((unsigned int)buff_size == 0U || buff == (void *)0) {
    
#line 2717 
    __retres = I40E_ERR_PARAM;
    
#line 2717 
    goto return_label;
  }
  else ;
  
#line 2719 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2560);
  
#line 2721 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 2723 
  cmd->type = (unsigned char)((unsigned int)mib_type & 3U);
  
#line 2724 
  cmd->type = (unsigned char)((int)cmd->type | (((int)bridge_type << 2) & 12));
  
#line 2727 
  desc.datalen = buff_size;
  
#line 2729 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 2730 
  if ((unsigned int)buff_size > 512U) 
#line 2731 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 2733 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  
#line 2734 
  if (status == I40E_SUCCESS) {
    
#line 2735 
    if (local_len != (u16 *)0U) 
#line 2736 
                                *local_len = resp->local_len; else ;
    
#line 2737 
    if (remote_len != (u16 *)0U) 
#line 2738 
                                 *remote_len = resp->remote_len; else ;
  }
  else ;
  
#line 2741 
  __retres = status;
  return_label: 
#line 2741 
                return __retres;
}


#line 2753  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_cfg_lldp_mib_change_event(struct i40e_hw *hw, bool enable_update, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2758 
  struct i40e_aqc_lldp_update_mib *cmd = (struct i40e_aqc_lldp_update_mib *)(& desc.params.raw);
  
#line 2762 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2561);
  
#line 2764 
  if (! enable_update) 
#line 2765 
                       cmd->command = (unsigned char)((unsigned int)cmd->command | 1U); else ;
  
#line 2767 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2769 
  return status;
}


#line 2780  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_stop_lldp(struct i40e_hw *hw, bool shutdown_agent, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2784 
  struct i40e_aqc_lldp_stop *cmd = (struct i40e_aqc_lldp_stop *)(& desc.params.raw);
  
#line 2788 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2565);
  
#line 2790 
  if ((int)shutdown_agent != 0) 
#line 2791 
                                cmd->command = (unsigned char)((unsigned int)cmd->command | 1U); else ;
  
#line 2793 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2795 
  return status;
}


#line 2805  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_start_lldp(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2809 
  struct i40e_aqc_lldp_start *cmd = (struct i40e_aqc_lldp_start *)(& desc.params.raw);
  
#line 2813 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2566);
  
#line 2815 
  cmd->command = (unsigned char)1U;
  
#line 2817 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2819 
  return status;
}


#line 2831  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_cee_dcb_config(struct i40e_hw *hw, void *buff, u16 buff_size, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2838 
  if ((unsigned int)buff_size == 0U || buff == (void *)0) {
    
#line 2839 
    __retres = I40E_ERR_PARAM;
    
#line 2839 
    goto return_label;
  }
  else ;
  
#line 2841 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2567);
  
#line 2843 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 2844 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  
#line 2847 
  __retres = status;
  return_label: 
#line 2847 
                return __retres;
}


#line 2859  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_udp_tunnel(struct i40e_hw *hw, u16 udp_port, u8 protocol_index, u8 *filter_index, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2865 
  struct i40e_aqc_add_udp_tunnel *cmd = (struct i40e_aqc_add_udp_tunnel *)(& desc.params.raw);
  
#line 2867 
  struct i40e_aqc_del_udp_tunnel_completion *resp = (struct i40e_aqc_del_udp_tunnel_completion *)(& desc.params.raw);
  
#line 2871 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2816);
  
#line 2873 
  cmd->udp_port = udp_port;
  
#line 2874 
  cmd->protocol_type = protocol_index;
  
#line 2876 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2878 
  if (status == I40E_SUCCESS && filter_index != (u8 *)0U) 
#line 2879 
                                                          *filter_index = resp->index; else ;
  
#line 2881 
  return status;
}


#line 2890  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_del_udp_tunnel(struct i40e_hw *hw, u8 index, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2894 
  struct i40e_aqc_remove_udp_tunnel *cmd = (struct i40e_aqc_remove_udp_tunnel *)(& desc.params.raw);
  
#line 2898 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2817);
  
#line 2900 
  cmd->index = index;
  
#line 2902 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2904 
  return status;
}


#line 2915  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_delete_element(struct i40e_hw *hw, u16 seid, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2919 
  struct i40e_aqc_switch_seid *cmd = (struct i40e_aqc_switch_seid *)(& desc.params.raw);
  
#line 2923 
  if ((unsigned int)seid == 0U) {
    
#line 2924 
    __retres = I40E_ERR_PARAM;
    
#line 2924 
    goto return_label;
  }
  else ;
  
#line 2926 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)579);
  
#line 2928 
  cmd->seid = seid;
  
#line 2930 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2932 
  __retres = status;
  return_label: 
#line 2932 
                return __retres;
}


#line 2944  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_dcb_updated(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2950 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)770);
  
#line 2952 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 2954 
  return status;
}


#line 2968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_aq_tx_sched_cmd(struct i40e_hw *hw, u16 seid, void *buff, u16 buff_size, enum i40e_admin_queue_opc opcode, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 2974 
  struct i40e_aqc_tx_sched_ind *cmd = (struct i40e_aqc_tx_sched_ind *)(& desc.params.raw);
  
#line 2977 
  bool cmd_param_flag = (_Bool)0;
  
#line 2979 
  switch ((unsigned int)opcode) {
    case (unsigned int)1030: 
#line 2980 
    ;
    case (unsigned int)1031: 
#line 2981 
    ;
    case (unsigned int)1043: 
#line 2982 
    ;
    case (unsigned int)1044: 
#line 2983 
    ;
    case (unsigned int)1045: 
#line 2984 
    ;
    case (unsigned int)1046: 
#line 2985 
    ;
    case (unsigned int)1047: 
#line 2986 
    ;
    
#line 2987 
    cmd_param_flag = (_Bool)1;
    
#line 2988 
    goto ldv_53636;
    case (unsigned int)1032: 
#line 2989 
    ;
    case (unsigned int)1034: 
#line 2990 
    ;
    case (unsigned int)1048: 
#line 2991 
    ;
    case (unsigned int)1049: 
#line 2992 
    ;
    case (unsigned int)1050: 
#line 2993 
    ;
    
#line 2994 
    cmd_param_flag = (_Bool)0;
    
#line 2995 
    goto ldv_53636;
    default: 
#line 2996 
    ;
    
#line 2997 
    __retres = I40E_ERR_PARAM;
    
#line 2997 
    goto return_label;
  }
  ldv_53636: 
#line 3000 
  ;
  
#line 3000 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)((int)((unsigned short)opcode)));
  
#line 3003 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 3004 
  if ((int)cmd_param_flag != 0) 
#line 3005 
                                desc.flags = (unsigned short)((unsigned int)desc.flags | 1024U); else ;
  
#line 3006 
  if ((unsigned int)buff_size > 512U) 
#line 3007 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 3009 
  desc.datalen = buff_size;
  
#line 3011 
  cmd->vsi_seid = seid;
  
#line 3013 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  
#line 3015 
  __retres = status;
  return_label: 
#line 3015 
                return __retres;
}


#line 3026  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_vsi_bw_limit(struct i40e_hw *hw, u16 seid, u16 credit, u8 max_credit, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 3031 
  struct i40e_aqc_configure_vsi_bw_limit *cmd = (struct i40e_aqc_configure_vsi_bw_limit *)(& desc.params.raw);
  
#line 3035 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1024);
  
#line 3038 
  cmd->vsi_seid = seid;
  
#line 3039 
  cmd->credit = credit;
  
#line 3040 
  cmd->max_credit = max_credit;
  
#line 3042 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 3044 
  return status;
}


#line 3054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_vsi_tc_bw(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_vsi_tc_bw_data *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status tmp;
  
#line 3059 
  tmp = i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,(unsigned short)32,(enum i40e_admin_queue_opc)i40e_aqc_opc_configure_vsi_tc_bw,cmd_details);
  
#line 3059 
  return tmp;
}


#line 3071  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_switch_comp_ets(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_switching_comp_ets_data *ets_data, enum i40e_admin_queue_opc opcode, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status tmp;
  
#line 3077 
  tmp = i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)ets_data,(unsigned short)128,opcode,cmd_details);
  
#line 3077 
  return tmp;
}


#line 3088  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_switch_comp_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_switching_comp_bw_config_data *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status tmp;
  
#line 3093 
  tmp = i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,(unsigned short)32,(enum i40e_admin_queue_opc)i40e_aqc_opc_configure_switching_comp_bw_config,cmd_details);
  
#line 3093 
  return tmp;
}


#line 3105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_vsi_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_vsi_bw_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status tmp;
  
#line 3110 
  tmp = i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,(unsigned short)64,(enum i40e_admin_queue_opc)i40e_aqc_opc_query_vsi_bw_config,cmd_details);
  
#line 3110 
  return tmp;
}


#line 3122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_vsi_ets_sla_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_vsi_ets_sla_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status tmp;
  
#line 3127 
  tmp = i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,(unsigned short)32,(enum i40e_admin_queue_opc)i40e_aqc_opc_query_vsi_ets_sla_config,cmd_details);
  
#line 3127 
  return tmp;
}


#line 3139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_switch_comp_ets_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_switching_comp_ets_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status tmp;
  
#line 3144 
  tmp = i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,(unsigned short)64,(enum i40e_admin_queue_opc)i40e_aqc_opc_query_switching_comp_ets_config,cmd_details);
  
#line 3144 
  return tmp;
}


#line 3156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_port_ets_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_port_ets_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status tmp;
  
#line 3161 
  tmp = i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,(unsigned short)68,(enum i40e_admin_queue_opc)i40e_aqc_opc_query_port_ets_config,cmd_details);
  
#line 3161 
  return tmp;
}


#line 3173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_switch_comp_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_switching_comp_bw_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status tmp;
  
#line 3178 
  tmp = i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,(unsigned short)32,(enum i40e_admin_queue_opc)i40e_aqc_opc_query_switching_comp_bw_config,cmd_details);
  
#line 3178 
  return tmp;
}


#line 3195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_validate_filter_settings(struct i40e_hw *hw, struct i40e_filter_control_settings *settings)
{
  i40e_status __retres;
  u32 fcoe_cntx_size;
  u32 fcoe_filt_size;
  u32 pe_cntx_size;
  u32 pe_filt_size;
  u32 fcoe_fmax;
  u32 val;
  
#line 3204 
  switch ((unsigned int)settings->fcoe_filt_num) {
    case (unsigned int)0: 
#line 3205 
    ;
    case (unsigned int)1: 
#line 3206 
    ;
    case (unsigned int)2: 
#line 3207 
    ;
    case (unsigned int)3: 
#line 3208 
    ;
    case (unsigned int)4: 
#line 3209 
    ;
    case (unsigned int)5: 
#line 3210 
    ;
    
#line 3211 
    fcoe_filt_size = 1024U;
    
#line 3212 
    fcoe_filt_size <<= (unsigned int)settings->fcoe_filt_num;
    
#line 3213 
    goto ldv_53718;
    default: 
#line 3214 
    ;
    
#line 3215 
    __retres = I40E_ERR_PARAM;
    
#line 3215 
    goto return_label;
  }
  ldv_53718: 
#line 3218 
  ;
  
#line 3218 
  switch ((unsigned int)settings->fcoe_cntx_num) {
    case (unsigned int)0: 
#line 3219 
    ;
    case (unsigned int)1: 
#line 3220 
    ;
    case (unsigned int)2: 
#line 3221 
    ;
    case (unsigned int)3: 
#line 3222 
    ;
    
#line 3223 
    fcoe_cntx_size = 512U;
    
#line 3224 
    fcoe_cntx_size <<= (unsigned int)settings->fcoe_cntx_num;
    
#line 3225 
    goto ldv_53724;
    default: 
#line 3226 
    ;
    
#line 3227 
    __retres = I40E_ERR_PARAM;
    
#line 3227 
    goto return_label;
  }
  ldv_53724: 
#line 3231 
  ;
  
#line 3231 
  switch ((unsigned int)settings->pe_filt_num) {
    case (unsigned int)0: 
#line 3232 
    ;
    case (unsigned int)1: 
#line 3233 
    ;
    case (unsigned int)2: 
#line 3234 
    ;
    case (unsigned int)3: 
#line 3235 
    ;
    case (unsigned int)4: 
#line 3236 
    ;
    case (unsigned int)5: 
#line 3237 
    ;
    case (unsigned int)6: 
#line 3238 
    ;
    case (unsigned int)7: 
#line 3239 
    ;
    case (unsigned int)8: 
#line 3240 
    ;
    case (unsigned int)9: 
#line 3241 
    ;
    case (unsigned int)10: 
#line 3242 
    ;
    
#line 3243 
    pe_filt_size = 1024U;
    
#line 3244 
    pe_filt_size <<= (unsigned int)settings->pe_filt_num;
    
#line 3245 
    goto ldv_53737;
    default: 
#line 3246 
    ;
    
#line 3247 
    __retres = I40E_ERR_PARAM;
    
#line 3247 
    goto return_label;
  }
  ldv_53737: 
#line 3250 
  ;
  
#line 3250 
  switch ((unsigned int)settings->pe_cntx_num) {
    case (unsigned int)0: 
#line 3251 
    ;
    case (unsigned int)1: 
#line 3252 
    ;
    case (unsigned int)2: 
#line 3253 
    ;
    case (unsigned int)3: 
#line 3254 
    ;
    case (unsigned int)4: 
#line 3255 
    ;
    case (unsigned int)5: 
#line 3256 
    ;
    case (unsigned int)6: 
#line 3257 
    ;
    case (unsigned int)7: 
#line 3258 
    ;
    case (unsigned int)8: 
#line 3259 
    ;
    case (unsigned int)9: 
#line 3260 
    ;
    
#line 3261 
    pe_cntx_size = 512U;
    
#line 3262 
    pe_cntx_size <<= (unsigned int)settings->pe_cntx_num;
    
#line 3263 
    goto ldv_53749;
    default: 
#line 3264 
    ;
    
#line 3265 
    __retres = I40E_ERR_PARAM;
    
#line 3265 
    goto return_label;
  }
  ldv_53749: 
#line 3269 
  ;
  
#line 3269 
  val = readl((void const volatile *)(hw->hw_addr + 794832U));
  
#line 3270 
  fcoe_fmax = val & 65535U;
  
#line 3272 
  if (fcoe_filt_size + fcoe_cntx_size > fcoe_fmax) {
    
#line 3273 
    __retres = I40E_ERR_INVALID_SIZE;
    
#line 3273 
    goto return_label;
  }
  else ;
  
#line 3275 
  __retres = I40E_SUCCESS;
  return_label: 
#line 3275 
                return __retres;
}


#line 3287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_set_filter_control(struct i40e_hw *hw, struct i40e_filter_control_settings *settings)
{
  i40e_status __retres;
  u32 val;
  
#line 3290 
  i40e_status ret = 0;
  
#line 3291 
  u32 hash_lut_size = 0U;
  
#line 3294 
  if (settings == (struct i40e_filter_control_settings *)0) {
    
#line 3295 
    __retres = I40E_ERR_PARAM;
    
#line 3295 
    goto return_label;
  }
  else ;
  
#line 3298 
  ret = i40e_validate_filter_settings(hw,settings);
  
#line 3299 
  if (ret != I40E_SUCCESS) {
    
#line 3300 
    __retres = ret;
    
#line 3300 
    goto return_label;
  }
  else ;
  
#line 3303 
  val = readl((void const volatile *)(hw->hw_addr + 1837760U));
  
#line 3306 
  val &= 4294967264U;
  
#line 3307 
  val = ((unsigned int)settings->pe_filt_num & 31U) | val;
  
#line 3310 
  val &= 4294966303U;
  
#line 3311 
  val = (((unsigned int)settings->pe_cntx_num << 5) & 992U) | val;
  
#line 3315 
  val &= 4294951935U;
  
#line 3316 
  val = (((unsigned int)settings->fcoe_filt_num << 10) & 15360U) | val;
  
#line 3320 
  val &= 4294918143U;
  
#line 3321 
  val = (((unsigned int)settings->fcoe_cntx_num << 14) & 65535U) | val;
  
#line 3326 
  val &= 4294901759U;
  
#line 3327 
  if (settings->hash_lut_size == (unsigned int)I40E_HASH_LUT_SIZE_512) 
    
#line 3328 
    hash_lut_size = 1U; else ;
  
#line 3329 
  val = ((hash_lut_size << 16) & 65536U) | val;
  
#line 3333 
  if ((int)settings->enable_fdir != 0) 
#line 3334 
                                       val |= 131072U; else ;
  
#line 3335 
  if ((int)settings->enable_ethtype != 0) 
#line 3336 
                                          val |= 262144U; else ;
  
#line 3337 
  if ((int)settings->enable_macvlan != 0) 
#line 3338 
                                          val |= 524288U; else ;
  
#line 3340 
  writel(val,(void volatile *)(hw->hw_addr + 1837760U));
  
#line 3342 
  __retres = I40E_SUCCESS;
  return_label: 
#line 3342 
                return __retres;
}


#line 3361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_rem_control_packet_filter(struct i40e_hw *hw, u8 *mac_addr, u16 ethtype, u16 flags, u16 vsi_seid, u16 queue, bool is_add, struct i40e_control_filter_stats *stats, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 3368 
  struct i40e_aqc_add_remove_control_packet_filter *cmd = (struct i40e_aqc_add_remove_control_packet_filter *)(& desc.params.raw);
  
#line 3371 
  struct i40e_aqc_add_remove_control_packet_filter_completion *resp = (struct i40e_aqc_add_remove_control_packet_filter_completion *)(& desc.params.raw);
  
#line 3376 
  if ((unsigned int)vsi_seid == 0U) {
    
#line 3377 
    __retres = I40E_ERR_PARAM;
    
#line 3377 
    goto return_label;
  }
  else ;
  
#line 3379 
  if ((int)is_add != 0) {
    
#line 3380 
    i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)602);
    
#line 3382 
    cmd->queue = queue;
  }
  else 
#line 3384 
       i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)603);
  
#line 3388 
  if (mac_addr != (u8 *)0U) 
#line 3389 
                            memcpy((void *)(& cmd->mac),(void const *)mac_addr,6UL); else ;
  
#line 3391 
  cmd->etype = ethtype;
  
#line 3392 
  cmd->flags = flags;
  
#line 3393 
  cmd->seid = vsi_seid;
  
#line 3395 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 3397 
  if (status == I40E_SUCCESS && stats != (struct i40e_control_filter_stats *)0) {
    
#line 3398 
    stats->mac_etype_used = resp->mac_etype_used;
    
#line 3399 
    stats->etype_used = resp->etype_used;
    
#line 3400 
    stats->mac_etype_free = resp->mac_etype_free;
    
#line 3401 
    stats->etype_free = resp->etype_free;
  }
  else ;
  
#line 3404 
  __retres = status;
  return_label: 
#line 3404 
                return __retres;
}


#line 3420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_aq_alternate_read(struct i40e_hw *hw, u32 reg_addr0, u32 *reg_val0, u32 reg_addr1, u32 *reg_val1)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 3425 
  struct i40e_aqc_alternate_write *cmd_resp = (struct i40e_aqc_alternate_write *)(& desc.params.raw);
  
#line 3429 
  if (reg_val0 == (u32 *)0U) {
    
#line 3430 
    __retres = I40E_ERR_PARAM;
    
#line 3430 
    goto return_label;
  }
  else ;
  
#line 3432 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2306);
  
#line 3433 
  cmd_resp->address0 = reg_addr0;
  
#line 3434 
  cmd_resp->address1 = reg_addr1;
  
#line 3436 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,(struct i40e_asq_cmd_details *)0);
  
#line 3438 
  if (status == I40E_SUCCESS) {
    
#line 3439 
    *reg_val0 = cmd_resp->data0;
    
#line 3441 
    if (reg_val1 != (u32 *)0U) 
#line 3442 
                               *reg_val1 = cmd_resp->data1; else ;
  }
  else ;
  
#line 3445 
  __retres = status;
  return_label: 
#line 3445 
                return __retres;
}


#line 3455  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_resume_port_tx(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details)
{
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 3461 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1052);
  
#line 3463 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  
#line 3465 
  return status;
}


#line 3475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_set_pci_config_data(struct i40e_hw *hw, u16 link_status)
{
  
#line 3477 
  hw->bus.type = i40e_bus_type_pci_express;
  
#line 3479 
  switch ((int)link_status & 1008) {
    case 16: 
#line 3480 
    ;
    
#line 3481 
    hw->bus.width = i40e_bus_width_pcie_x1;
    
#line 3482 
    goto ldv_53794;
    case 32: 
#line 3483 
    ;
    
#line 3484 
    hw->bus.width = i40e_bus_width_pcie_x2;
    
#line 3485 
    goto ldv_53794;
    case 64: 
#line 3486 
    ;
    
#line 3487 
    hw->bus.width = i40e_bus_width_pcie_x4;
    
#line 3488 
    goto ldv_53794;
    case 128: 
#line 3489 
    ;
    
#line 3490 
    hw->bus.width = i40e_bus_width_pcie_x8;
    
#line 3491 
    goto ldv_53794;
    default: 
#line 3492 
    ;
    
#line 3493 
    hw->bus.width = i40e_bus_width_unknown;
    
#line 3494 
    goto ldv_53794;
  }
  ldv_53794: 
#line 3497 
  ;
  
#line 3497 
  switch ((int)link_status & 15) {
    case 1: 
#line 3498 
    ;
    
#line 3499 
    hw->bus.speed = i40e_bus_speed_2500;
    
#line 3500 
    goto ldv_53800;
    case 2: 
#line 3501 
    ;
    
#line 3502 
    hw->bus.speed = i40e_bus_speed_5000;
    
#line 3503 
    goto ldv_53800;
    case 3: 
#line 3504 
    ;
    
#line 3505 
    hw->bus.speed = i40e_bus_speed_8000;
    
#line 3506 
    goto ldv_53800;
    default: 
#line 3507 
    ;
    
#line 3508 
    hw->bus.speed = i40e_bus_speed_unknown;
    
#line 3509 
    goto ldv_53800;
  }
  ldv_53800: 
#line 3511 
  ;
  
#line 3512 
  return;
}


#line 3528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_dump(struct i40e_hw *hw, u8 cluster_id, u8 table_id, u32 start_index, u16 buff_size, void *buff, u16 *ret_buff_size, u8 *ret_next_table, u32 *ret_next_index, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status __retres;
  struct i40e_aq_desc desc;
  i40e_status status;
  
#line 3535 
  struct i40e_aqc_debug_dump_internals *cmd = (struct i40e_aqc_debug_dump_internals *)(& desc.params.raw);
  
#line 3537 
  struct i40e_aqc_debug_dump_internals *resp = (struct i40e_aqc_debug_dump_internals *)(& desc.params.raw);
  
#line 3541 
  if ((unsigned int)buff_size == 0U || buff == (void *)0) {
    
#line 3542 
    __retres = I40E_ERR_PARAM;
    
#line 3542 
    goto return_label;
  }
  else ;
  
#line 3544 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)65288);
  
#line 3547 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 3548 
  if ((unsigned int)buff_size > 512U) 
#line 3549 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 3551 
  cmd->cluster_id = cluster_id;
  
#line 3552 
  cmd->table_id = table_id;
  
#line 3553 
  cmd->idx = start_index;
  
#line 3555 
  desc.datalen = buff_size;
  
#line 3557 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  
#line 3558 
  if (status == I40E_SUCCESS) {
    
#line 3559 
    if (ret_buff_size != (u16 *)0U) 
#line 3560 
                                    *ret_buff_size = desc.datalen; else ;
    
#line 3561 
    if (ret_next_table != (u8 *)0U) 
#line 3562 
                                    *ret_next_table = resp->table_id; else ;
    
#line 3563 
    if (ret_next_index != (u32 *)0U) 
#line 3564 
                                     *ret_next_index = resp->idx; else ;
  }
  else ;
  
#line 3567 
  __retres = status;
  return_label: 
#line 3567 
                return __retres;
}


#line 3580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_bw_from_alt_ram(struct i40e_hw *hw, u32 *max_bw, u32 *min_bw, bool *min_valid, bool *max_valid)
{
  i40e_status status;
  u32 max_bw_addr;
  u32 min_bw_addr;
  
#line 3588 
  max_bw_addr = (unsigned int)((int)hw->pf_id * 64 + 15);
  
#line 3591 
  min_bw_addr = (unsigned int)((int)hw->pf_id * 64 + 14);
  
#line 3596 
  status = i40e_aq_alternate_read(hw,max_bw_addr,max_bw,min_bw_addr,min_bw);
  
#line 3599 
  if (*min_bw < (u32)0) 
#line 3600 
                        *min_valid = (_Bool)1; else 
#line 3602 
                                                    *min_valid = (_Bool)0;
  
#line 3604 
  if (*max_bw < (u32)0) 
#line 3605 
                        *max_valid = (_Bool)1; else 
#line 3607 
                                                    *max_valid = (_Bool)0;
  
#line 3609 
  return status;
}


#line 3620  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_configure_partition_bw(struct i40e_hw *hw, struct i40e_aqc_configure_partition_bw_data *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  i40e_status status;
  struct i40e_aq_desc desc;
  
#line 3626 
  u16 bwd_size = (unsigned short)34U;
  
#line 3628 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1053);
  
#line 3632 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  
#line 3633 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 1024U);
  
#line 3635 
  if ((unsigned int)bwd_size > 512U) 
#line 3636 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U); else ;
  
#line 3638 
  desc.datalen = bwd_size;
  
#line 3640 
  status = i40e_asq_send_command(hw,& desc,(void *)bw_data,(unsigned short)((int)bwd_size),cmd_details);
  
#line 3643 
  return status;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_add_sd_table_entry(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 sd_index, enum i40e_sd_entry_type type, u64 direct_mode_sz)
{
  enum i40e_memory_type mem_type;
  struct i40e_hmc_sd_entry *sd_entry;
  struct i40e_dma_mem mem;
  i40e_status ret_code;
  u64 alloc_len;
  
#line 50 
  bool dma_mem_alloc_done = (_Bool)0;
  
#line 55 
  if (hmc_info->sd_table.sd_entry == (struct i40e_hmc_sd_entry *)0) {
    
#line 56 
    ret_code = I40E_ERR_BAD_PTR;
    
#line 58 
    goto exit;
  }
  else ;
  
#line 61 
  if (hmc_info->sd_table.sd_cnt <= sd_index) {
    
#line 62 
    ret_code = I40E_ERR_INVALID_SD_INDEX;
    
#line 64 
    goto exit;
  }
  else ;
  
#line 67 
  sd_entry = hmc_info->sd_table.sd_entry + sd_index;
  
#line 68 
  if (! sd_entry->valid) {
    
#line 69 
    if (type == (unsigned int)I40E_SD_TYPE_PAGED) {
      
#line 70 
      mem_type = i40e_mem_pd;
      
#line 71 
      alloc_len = 4096ULL;
    }
    else {
      
#line 73 
      mem_type = i40e_mem_bp_jumbo;
      
#line 74 
      alloc_len = direct_mode_sz;
    }
    
#line 78 
    ret_code = i40e_allocate_dma_mem_d(hw,& mem,alloc_len,4096U);
    
#line 80 
    if (ret_code != I40E_SUCCESS) 
#line 81 
                                  goto exit; else ;
    
#line 82 
    dma_mem_alloc_done = (_Bool)1;
    
#line 83 
    if (type == (unsigned int)I40E_SD_TYPE_PAGED) {
      
#line 84 
      ret_code = i40e_allocate_virt_mem_d(hw,& sd_entry->u.pd_table.pd_entry_virt_mem,20480U);
      
#line 87 
      if (ret_code != I40E_SUCCESS) 
#line 88 
                                    goto exit; else ;
      
#line 89 
      sd_entry->u.pd_table.pd_entry = (struct i40e_hmc_pd_entry *)sd_entry->u.pd_table.pd_entry_virt_mem.va;
      
#line 92 
      sd_entry->u.pd_table.pd_page_addr = mem;
    }
    else {
      
#line 94 
      sd_entry->u.bp.addr = mem;
      
#line 95 
      sd_entry->u.bp.sd_pd_index = sd_index;
    }
    
#line 98 
    (hmc_info->sd_table.sd_entry + sd_index)->entry_type = type;
    
#line 101 
    hmc_info->sd_table.ref_cnt += 1U;
  }
  else ;
  
#line 104 
  if (sd_entry->entry_type == (unsigned int)I40E_SD_TYPE_DIRECT) 
#line 105 
                                                                 sd_entry->u.bp.ref_cnt += 1U; else ;
  exit: 
#line 106 
  ;
  
#line 107 
  if (ret_code != I40E_SUCCESS) {
    
#line 108 
    if ((int)dma_mem_alloc_done != 0) 
#line 109 
                                      i40e_free_dma_mem_d(hw,& mem); else ;
  }
  else ;
  
#line 111 
  return ret_code;
}


#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_add_pd_table_entry(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 pd_index)
{
  struct i40e_hmc_pd_table *pd_table;
  struct i40e_hmc_pd_entry *pd_entry;
  struct i40e_dma_mem mem;
  u32 sd_idx;
  u32 rel_pd_idx;
  u64 *pd_addr;
  u64 page_desc;
  
#line 134 
  i40e_status ret_code = 0;
  
#line 142 
  if (pd_index / 512U >= hmc_info->sd_table.sd_cnt) {
    
#line 143 
    ret_code = I40E_ERR_INVALID_PAGE_DESC_INDEX;
    
#line 145 
    goto exit;
  }
  else ;
  
#line 149 
  sd_idx = pd_index / 512U;
  
#line 150 
  if ((hmc_info->sd_table.sd_entry + sd_idx)->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) 
    
#line 152 
    goto exit; else ;
  
#line 154 
  rel_pd_idx = pd_index & 511U;
  
#line 155 
  pd_table = & (hmc_info->sd_table.sd_entry + sd_idx)->u.pd_table;
  
#line 156 
  pd_entry = pd_table->pd_entry + rel_pd_idx;
  
#line 157 
  if (! pd_entry->valid) {
    
#line 159 
    ret_code = i40e_allocate_dma_mem_d(hw,& mem,4096ULL,4096U);
    
#line 162 
    if (ret_code != I40E_SUCCESS) 
#line 163 
                                  goto exit; else ;
    
#line 165 
    pd_entry->bp.addr = mem;
    
#line 166 
    pd_entry->bp.sd_pd_index = pd_index;
    
#line 167 
    pd_entry->bp.entry_type = I40E_SD_TYPE_PAGED;
    
#line 169 
    page_desc = mem.pa | 1ULL;
    
#line 171 
    pd_addr = (u64 *)pd_table->pd_page_addr.va;
    
#line 172 
    pd_addr += rel_pd_idx;
    
#line 175 
    memcpy((void *)pd_addr,(void const *)(& page_desc),8UL);
    
#line 177 
    pd_entry->sd_index = sd_idx;
    
#line 178 
    pd_entry->valid = (_Bool)1;
    
#line 179 
    pd_table->ref_cnt += 1U;
  }
  else ;
  
#line 181 
  pd_entry->bp.ref_cnt += 1U;
  exit: 
#line 182 
  ;
  
#line 183 
  return ret_code;
}


#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_pd_bp(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx)
{
  struct i40e_hmc_pd_entry *pd_entry;
  struct i40e_hmc_pd_table *pd_table;
  struct i40e_hmc_sd_entry *sd_entry;
  u32 sd_idx;
  u32 rel_pd_idx;
  u64 *pd_addr;
  
#line 206 
  i40e_status ret_code = 0;
  
#line 214 
  sd_idx = idx / 512U;
  
#line 215 
  rel_pd_idx = idx & 511U;
  
#line 216 
  if (hmc_info->sd_table.sd_cnt <= sd_idx) {
    
#line 217 
    ret_code = I40E_ERR_INVALID_PAGE_DESC_INDEX;
    
#line 219 
    goto exit;
  }
  else ;
  
#line 221 
  sd_entry = hmc_info->sd_table.sd_entry + sd_idx;
  
#line 222 
  if (sd_entry->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) {
    
#line 223 
    ret_code = I40E_ERR_INVALID_SD_TYPE;
    
#line 225 
    goto exit;
  }
  else ;
  
#line 228 
  pd_table = & (hmc_info->sd_table.sd_entry + sd_idx)->u.pd_table;
  
#line 229 
  pd_entry = pd_table->pd_entry + rel_pd_idx;
  
#line 230 
  pd_entry->bp.ref_cnt -= 1U;
  
#line 231 
  if (pd_entry->bp.ref_cnt != 0U) 
#line 232 
                                  goto exit; else ;
  
#line 235 
  pd_entry->valid = (_Bool)0;
  
#line 236 
  pd_table->ref_cnt -= 1U;
  
#line 237 
  pd_addr = (u64 *)pd_table->pd_page_addr.va;
  
#line 238 
  pd_addr += rel_pd_idx;
  
#line 239 
  memset((void *)pd_addr,0,8UL);
  
#line 240 
  writel((idx << 16) | sd_idx,(void volatile *)(hw->hw_addr + 787200U));
  
#line 243 
  ret_code = i40e_free_dma_mem_d(hw,& pd_entry->bp.addr);
  
#line 244 
  if (ret_code != I40E_SUCCESS) 
#line 245 
                                goto exit; else ;
  
#line 246 
  if (pd_table->ref_cnt == 0U) 
#line 247 
                               i40e_free_virt_mem_d(hw,& pd_table->pd_entry_virt_mem); else ;
  exit: 
#line 248 
  ;
  
#line 249 
  return ret_code;
}


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_prep_remove_sd_bp(struct i40e_hmc_info *hmc_info, u32 idx)
{
  struct i40e_hmc_sd_entry *sd_entry;
  
#line 260 
  i40e_status ret_code = 0;
  
#line 264 
  sd_entry = hmc_info->sd_table.sd_entry + idx;
  
#line 265 
  sd_entry->u.bp.ref_cnt -= 1U;
  
#line 266 
  if (sd_entry->u.bp.ref_cnt != 0U) {
    
#line 267 
    ret_code = I40E_ERR_NOT_READY;
    
#line 268 
    goto exit;
  }
  else ;
  
#line 270 
  hmc_info->sd_table.ref_cnt -= 1U;
  
#line 273 
  sd_entry->valid = (_Bool)0;
  exit: 
#line 274 
  ;
  
#line 275 
  return ret_code;
}


#line 285  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_sd_bp_new(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx, bool is_pf)
{
  struct i40e_hmc_sd_entry *sd_entry;
  
#line 290 
  i40e_status ret_code = 0;
  
#line 293 
  sd_entry = hmc_info->sd_table.sd_entry + idx;
  
#line 294 
  if ((int)is_pf != 0) {
    u32 val2;
    u32 val3;
    
#line 295 
    val2 = 2050U;
    
#line 295 
    val3 = idx | 2147483648U;
    
#line 295 
    writel(0U,(void volatile *)(hw->hw_addr + 786944U));
    
#line 295 
    writel(val2,(void volatile *)(hw->hw_addr + 786688U));
    
#line 295 
    writel(val3,(void volatile *)(hw->hw_addr + 786432U));
  }
  else {
    
#line 297 
    ret_code = I40E_NOT_SUPPORTED;
    
#line 298 
    goto exit;
  }
  
#line 300 
  ret_code = i40e_free_dma_mem_d(hw,& sd_entry->u.bp.addr);
  
#line 301 
  if (ret_code != I40E_SUCCESS) 
#line 302 
                                goto exit; else ;
  exit: 
#line 303 
  ;
  
#line 304 
  return ret_code;
}


#line 312  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_prep_remove_pd_page(struct i40e_hmc_info *hmc_info, u32 idx)
{
  struct i40e_hmc_sd_entry *sd_entry;
  
#line 315 
  i40e_status ret_code = 0;
  
#line 318 
  sd_entry = hmc_info->sd_table.sd_entry + idx;
  
#line 320 
  if (sd_entry->u.pd_table.ref_cnt != 0U) {
    
#line 321 
    ret_code = I40E_ERR_NOT_READY;
    
#line 322 
    goto exit;
  }
  else ;
  
#line 326 
  sd_entry->valid = (_Bool)0;
  
#line 328 
  hmc_info->sd_table.ref_cnt -= 1U;
  exit: 
#line 329 
  ;
  
#line 330 
  return ret_code;
}


#line 340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_pd_page_new(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx, bool is_pf)
{
  struct i40e_hmc_sd_entry *sd_entry;
  
#line 344 
  i40e_status ret_code = 0;
  
#line 347 
  sd_entry = hmc_info->sd_table.sd_entry + idx;
  
#line 348 
  if ((int)is_pf != 0) {
    u32 val2;
    u32 val3;
    
#line 349 
    val2 = 2048U;
    
#line 349 
    val3 = idx | 2147483648U;
    
#line 349 
    writel(0U,(void volatile *)(hw->hw_addr + 786944U));
    
#line 349 
    writel(val2,(void volatile *)(hw->hw_addr + 786688U));
    
#line 349 
    writel(val3,(void volatile *)(hw->hw_addr + 786432U));
  }
  else {
    
#line 351 
    ret_code = I40E_NOT_SUPPORTED;
    
#line 352 
    goto exit;
  }
  
#line 355 
  ret_code = i40e_free_dma_mem_d(hw,& sd_entry->u.pd_table.pd_page_addr);
  
#line 356 
  if (ret_code != I40E_SUCCESS) 
#line 357 
                                goto exit; else ;
  exit: 
#line 358 
  ;
  
#line 359 
  return ret_code;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
void *ldv_err_ptr(long error);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 97 
void ldv_failed_register_netdev(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
__inline static void *ERR_PTR(long error)
{
  void *__retres;
  
#line 25 
  __retres = (void *)error;
  
#line 25 
  return __retres;
}


#line 140  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0);


#line 142 
void *ldv_random_allocationless_scenario_18(void *arg0);


#line 144 
void ldv_dispatch_register_9_3(struct pci_driver *arg0);


#line 146 
void *ldv_timer_scenario_15(void *arg0);


#line 147 
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0);


#line 148 
void *ldv_character_driver_scenario_19(void *arg0);


#line 150 
void *ldv_character_driver_scenario_17(void *arg0);


#line 151 
void ldv_dispatch_register_8_4(struct net_device *arg0);


#line 152 
void *ldv_character_driver_scenario_20(void *arg0);


#line 154 
void *ldv_pci_scenario_14(void *arg0);


#line 155 
void *ldv_interrupt_scenario_16(void *arg0);


#line 157 
void ldv_dispatch_irq_register_13_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 158 
void ldv_dispatch_register_12_3(struct file_operations *arg0);


#line 159 
int main(void);


#line 161 
void ldv_dispatch_instance_register_3_3(struct timer_list *arg0);


#line 162 
void ldv_dispatch_irq_deregister_6_1(int arg0);


#line 163 
void *ldv_initialization_1(void *arg0);


#line 168 
void ldv_dispatch_instance_deregister_11_1(struct timer_list *arg0);


#line 172  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_14;

#line 173  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_19;

#line 174  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 175  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_17;

#line 176  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 177  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_18;

#line 178  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_20;

#line 182  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_5_1(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_18 *cf_arg_18;
  int tmp;
  
#line 185 
  tmp = ldv_undef_int();
  
#line 185 
  switch (tmp) {
    case 0: 
#line 186 
    ;
    
#line 187 
    ret = pthread_join(ldv_thread_18,(void **)0);
    
#line 188 
    __VERIFIER_assume(ret == 0);
    
#line 189 
    goto ldv_45639;
    default: 
#line 191 
    ;
    
#line 191 
    __VERIFIER_assume(0);
  }
  ldv_45639: 
#line 192 
  ;
  
#line 193 
  return;
}


#line 197  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_del_timer_sync(struct timer_list *arg0)
{
  int __retres;
  struct timer_list *ldv_11_timer_list;
  
#line 203 
  ldv_11_timer_list = arg0;
  
#line 207 
  ldv_dispatch_instance_deregister_11_1(ldv_11_timer_list);
  
#line 208 
  ;
  
#line 208 
  __retres = 0;
  
#line 208 
  return __retres;
}


#line 216  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_random_allocationless_scenario_18(void *arg0)
{
  void *__retres;
  int ldv_18_ldv_param_1_40;
  struct ethtool_drvinfo *ldv_18_ldv_param_1_10;
  unsigned short ldv_18_ldv_param_1_80;
  unsigned char *ldv_18_ldv_param_2_17;
  unsigned long long ldv_18_ldv_param_1_57;
  struct ethtool_channels *ldv_18_ldv_param_1_60;
  unsigned char *ldv_18_ldv_param_2_43;
  struct ethtool_regs *ldv_18_ldv_param_1_72;
  unsigned char *ldv_18_ldv_param_2_76;
  unsigned int ldv_18_ldv_param_1_75;
  int ldv_18_ldv_param_3_36;
  enum ethtool_phys_id_state *ldv_18_ldv_param_1_4;
  unsigned long long *ldv_18_ldv_param_2_7;
  struct ethtool_ringparam *ldv_18_ldv_param_1_19;
  unsigned short ldv_18_ldv_param_2_12;
  struct nlattr **ldv_18_ldv_param_1_26;
  struct ethtool_eeprom *ldv_18_ldv_param_1_61;
  unsigned char *ldv_18_ldv_param_3_27;
  struct netdev_phys_item_id *ldv_18_ldv_param_1_82;
  unsigned int *ldv_18_ldv_param_1_16;
  struct sk_buff *ldv_18_ldv_param_0_20;
  unsigned int ldv_18_ldv_param_3_15;
  _Bool ldv_18_ldv_param_2_51;
  struct ethtool_wolinfo *ldv_18_ldv_param_1_68;
  int ldv_18_ldv_param_1_21;
  struct ethtool_test *ldv_18_ldv_param_1_58;
  struct ethtool_rxnfc *ldv_18_ldv_param_1_37;
  int ldv_18_ldv_param_1_63;
  unsigned short ldv_18_ldv_param_2_46;
  void *ldv_18_ldv_param_1_39;
  struct net_device *ldv_18_container;
  struct ethtool_wolinfo *ldv_18_ldv_param_1_30;
  unsigned short ldv_18_ldv_param_2_55;
  unsigned short ldv_18_ldv_param_2_81;
  struct ndmsg *ldv_18_ldv_param_0_25;
  unsigned char ldv_18_ldv_param_3_56;
  struct ethtool_coalesce *ldv_18_ldv_param_1_71;
  struct ethtool_channels *ldv_18_ldv_param_1_74;
  unsigned short ldv_18_ldv_param_1_69;
  struct ethtool_pauseparam *ldv_18_ldv_param_1_49;
  unsigned short ldv_18_ldv_param_1_13;
  unsigned char *ldv_18_ldv_param_2_67;
  void *ldv_18_ldv_param_2_73;
  struct ethtool_coalesce *ldv_18_ldv_param_1_78;
  unsigned short ldv_18_ldv_param_4_28;
  int ldv_18_ldv_param_2_24;
  int ldv_18_ldv_param_1_8;
  unsigned int *ldv_18_ldv_param_1_42;
  unsigned char ldv_18_ldv_param_1_2;
  unsigned short ldv_18_ldv_param_2_70;
  struct rtnl_link_stats64 *ldv_18_ldv_param_1_5;
  unsigned short ldv_18_ldv_param_1_11;
  int ldv_18_ldv_param_2_48;
  unsigned char *ldv_18_ldv_param_2_62;
  struct ethtool_cmd *ldv_18_ldv_param_1_65;
  unsigned short ldv_18_ldv_param_5_29;
  int ldv_18_ldv_param_1_34;
  struct ifreq *ldv_18_ldv_param_1_23;
  struct ethtool_pauseparam *ldv_18_ldv_param_1_79;
  unsigned char *ldv_18_ldv_param_2_41;
  unsigned char ldv_18_ldv_param_3_18;
  unsigned short ldv_18_ldv_param_1_77;
  int ldv_18_ldv_param_1_47;
  unsigned short ldv_18_ldv_param_1_45;
  struct ifla_vf_info *ldv_18_ldv_param_2_64;
  struct ethtool_ringparam *ldv_18_ldv_param_1_53;
  struct ethtool_stats *ldv_18_ldv_param_1_6;
  unsigned short ldv_18_ldv_param_1_31;
  struct ethtool_cmd *ldv_18_ldv_param_1_3;
  struct ethtool_rxnfc *ldv_18_ldv_param_1_9;
  struct ethtool_eeprom *ldv_18_ldv_param_1_66;
  int ldv_18_ldv_param_2_35;
  struct ethtool_ts_info *ldv_18_ldv_param_1_52;
  unsigned int *ldv_18_ldv_param_2_38;
  struct scatterlist *ldv_18_ldv_param_2_32;
  struct scatterlist *ldv_18_ldv_param_2_14;
  unsigned long long *ldv_18_ldv_param_2_59;
  unsigned int ldv_18_ldv_param_1_22;
  int ldv_18_ldv_param_1_50;
  unsigned int ldv_18_ldv_param_3_33;
  unsigned char *ldv_18_ldv_param_3_44;
  int ldv_18_ldv_param_1_54;
  int tmp_44;
  
#line 302 
  struct ldv_struct_random_allocationless_scenario_18 *data = (struct ldv_struct_random_allocationless_scenario_18 *)arg0;
  
#line 307 
  if (data != (struct ldv_struct_random_allocationless_scenario_18 *)0) {
    
#line 308 
    ldv_18_container = data->arg0;
    
#line 309 
    ldv_free((void *)data);
  }
  else ;
  
#line 317 
  goto ldv_call_18;
  
#line 319 
  __retres = (void *)0;
  
#line 319 
  goto return_label;
  ldv_call_18: 
#line 322 
  ;
  
#line 325 
  tmp_44 = ldv_undef_int();
  
#line 325 
  if (tmp_44 != 0) {
    int tmp;
    
#line 329 
    tmp = ldv_undef_int();
    
#line 329 
    switch (tmp) {
      case 1: 
#line 330 
      ;
      
#line 333 
      i40e_setup_tc(ldv_18_container,(unsigned char)((int)ldv_18_ldv_param_1_2));
      
#line 336 
      goto ldv_45733;
      case 2: 
#line 338 
      ;
      
#line 341 
      ldv_emg_wrapper_i40e_get_eeprom_len_33(ldv_18_container);
      
#line 344 
      goto ldv_45733;
      case 3: 
#line 346 
      ;
      
#line 348 
      ldv_18_ldv_param_1_82 = (struct netdev_phys_item_id *)ldv_xmalloc_unknown_size(0UL);
      
#line 353 
      ldv_emg_wrapper_i40e_get_phys_port_id_42(ldv_18_container,ldv_18_ldv_param_1_82);
      
#line 357 
      ldv_free((void *)ldv_18_ldv_param_1_82);
      
#line 360 
      goto ldv_45733;
      case 4: 
#line 362 
      ;
      
#line 368 
      i40e_vlan_rx_kill_vid(ldv_18_container,(unsigned short)((int)ldv_18_ldv_param_1_80),(unsigned short)((int)ldv_18_ldv_param_2_81));
      
#line 374 
      goto ldv_45733;
      case 5: 
#line 376 
      ;
      
#line 378 
      ldv_18_ldv_param_1_79 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 383 
      ldv_emg_wrapper_i40e_set_pauseparam_47(ldv_18_container,ldv_18_ldv_param_1_79);
      
#line 387 
      ldv_free((void *)ldv_18_ldv_param_1_79);
      
#line 390 
      goto ldv_45733;
      case 6: 
#line 392 
      ;
      
#line 394 
      ldv_18_ldv_param_1_78 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 399 
      ldv_emg_wrapper_i40e_set_coalesce_46(ldv_18_container,ldv_18_ldv_param_1_78);
      
#line 403 
      ldv_free((void *)ldv_18_ldv_param_1_78);
      
#line 406 
      goto ldv_45733;
      case 7: 
#line 408 
      ;
      
#line 411 
      ldv_emg_wrapper_i40e_get_regs_len_45(ldv_18_container);
      
#line 414 
      goto ldv_45733;
      case 8: 
#line 416 
      ;
      
#line 422 
      ldv_emg_wrapper_i40e_fcoe_ddp_put_44(ldv_18_container,(unsigned short)((int)ldv_18_ldv_param_1_77));
      
#line 428 
      goto ldv_45733;
      case 9: 
#line 430 
      ;
      
#line 432 
      ldv_18_ldv_param_2_76 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 437 
      ldv_emg_wrapper_i40e_get_strings_36(ldv_18_container,ldv_18_ldv_param_1_75,ldv_18_ldv_param_2_76);
      
#line 441 
      ldv_free((void *)ldv_18_ldv_param_2_76);
      
#line 444 
      goto ldv_45733;
      case 10: 
#line 446 
      ;
      
#line 449 
      i40e_netpoll(ldv_18_container);
      
#line 452 
      goto ldv_45733;
      case 11: 
#line 454 
      ;
      
#line 456 
      ldv_18_ldv_param_1_74 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
      
#line 461 
      ldv_emg_wrapper_i40e_get_channels_41(ldv_18_container,ldv_18_ldv_param_1_74);
      
#line 465 
      ldv_free((void *)ldv_18_ldv_param_1_74);
      
#line 468 
      goto ldv_45733;
      case 12: 
#line 470 
      ;
      
#line 473 
      i40e_tx_timeout(ldv_18_container);
      
#line 476 
      goto ldv_45733;
      case 13: 
#line 478 
      ;
      
#line 480 
      ldv_18_ldv_param_2_73 = ldv_xmalloc_unknown_size(0UL);
      
#line 481 
      ldv_18_ldv_param_1_72 = (struct ethtool_regs *)ldv_xmalloc_unknown_size(0UL);
      
#line 486 
      ldv_emg_wrapper_i40e_get_regs_8(ldv_18_container,ldv_18_ldv_param_1_72,ldv_18_ldv_param_2_73);
      
#line 490 
      ldv_free(ldv_18_ldv_param_2_73);
      
#line 491 
      ldv_free((void *)ldv_18_ldv_param_1_72);
      
#line 494 
      goto ldv_45733;
      case 14: 
#line 496 
      ;
      
#line 498 
      ldv_18_ldv_param_1_71 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 503 
      ldv_emg_wrapper_i40e_get_coalesce_38(ldv_18_container,ldv_18_ldv_param_1_71);
      
#line 507 
      ldv_free((void *)ldv_18_ldv_param_1_71);
      
#line 510 
      goto ldv_45733;
      case 15: 
#line 512 
      ;
      
#line 518 
      i40e_vlan_rx_add_vid(ldv_18_container,(unsigned short)((int)ldv_18_ldv_param_1_69),(unsigned short)((int)ldv_18_ldv_param_2_70));
      
#line 524 
      goto ldv_45733;
      case 16: 
#line 526 
      ;
      
#line 529 
      i40e_fcoe_disable(ldv_18_container);
      
#line 532 
      goto ldv_45733;
      case 17: 
#line 534 
      ;
      
#line 536 
      ldv_18_ldv_param_1_68 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 541 
      ldv_emg_wrapper_i40e_get_wol_37(ldv_18_container,ldv_18_ldv_param_1_68);
      
#line 545 
      ldv_free((void *)ldv_18_ldv_param_1_68);
      
#line 548 
      goto ldv_45733;
      case 18: 
#line 550 
      ;
      
#line 552 
      ldv_18_ldv_param_1_66 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
      
#line 553 
      ldv_18_ldv_param_2_67 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 558 
      ldv_emg_wrapper_i40e_get_eeprom_16(ldv_18_container,ldv_18_ldv_param_1_66,ldv_18_ldv_param_2_67);
      
#line 562 
      ldv_free((void *)ldv_18_ldv_param_1_66);
      
#line 563 
      ldv_free((void *)ldv_18_ldv_param_2_67);
      
#line 566 
      goto ldv_45733;
      case 19: 
#line 568 
      ;
      
#line 570 
      ldv_18_ldv_param_1_65 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 575 
      ldv_emg_wrapper_i40e_get_settings_35(ldv_18_container,ldv_18_ldv_param_1_65);
      
#line 579 
      ldv_free((void *)ldv_18_ldv_param_1_65);
      
#line 582 
      goto ldv_45733;
      case 20: 
#line 584 
      ;
      
#line 586 
      ldv_18_ldv_param_2_64 = (struct ifla_vf_info *)ldv_xmalloc_unknown_size(0UL);
      
#line 591 
      i40e_ndo_get_vf_config(ldv_18_container,ldv_18_ldv_param_1_63,ldv_18_ldv_param_2_64);
      
#line 595 
      ldv_free((void *)ldv_18_ldv_param_2_64);
      
#line 598 
      goto ldv_45733;
      case 21: 
#line 600 
      ;
      
#line 602 
      ldv_18_ldv_param_2_62 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 603 
      ldv_18_ldv_param_1_61 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
      
#line 608 
      ldv_emg_wrapper_i40e_set_eeprom_39(ldv_18_container,ldv_18_ldv_param_1_61,ldv_18_ldv_param_2_62);
      
#line 612 
      ldv_free((void *)ldv_18_ldv_param_2_62);
      
#line 613 
      ldv_free((void *)ldv_18_ldv_param_1_61);
      
#line 616 
      goto ldv_45733;
      case 22: 
#line 618 
      ;
      
#line 620 
      ldv_18_ldv_param_1_60 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
      
#line 625 
      ldv_emg_wrapper_i40e_set_channels_32(ldv_18_container,ldv_18_ldv_param_1_60);
      
#line 629 
      ldv_free((void *)ldv_18_ldv_param_1_60);
      
#line 632 
      goto ldv_45733;
      case 23: 
#line 634 
      ;
      
#line 636 
      ldv_18_ldv_param_2_59 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 637 
      ldv_18_ldv_param_1_58 = (struct ethtool_test *)ldv_xmalloc_unknown_size(0UL);
      
#line 642 
      ldv_emg_wrapper_i40e_diag_test_17(ldv_18_container,ldv_18_ldv_param_1_58,ldv_18_ldv_param_2_59);
      
#line 646 
      ldv_free((void *)ldv_18_ldv_param_2_59);
      
#line 647 
      ldv_free((void *)ldv_18_ldv_param_1_58);
      
#line 650 
      goto ldv_45733;
      case 24: 
#line 652 
      ;
      
#line 658 
      ldv_emg_wrapper_i40e_set_features_31(ldv_18_container,ldv_18_ldv_param_1_57);
      
#line 664 
      goto ldv_45733;
      case 25: 
#line 666 
      ;
      
#line 672 
      i40e_ndo_set_vf_port_vlan(ldv_18_container,ldv_18_ldv_param_1_54,(unsigned short)((int)ldv_18_ldv_param_2_55),(unsigned char)((int)ldv_18_ldv_param_3_56));
      
#line 678 
      goto ldv_45733;
      case 26: 
#line 680 
      ;
      
#line 683 
      (*ldv_emg_alias_eth_validate_addr_30)(ldv_18_container);
      
#line 686 
      goto ldv_45733;
      case 27: 
#line 688 
      ;
      
#line 690 
      ldv_18_ldv_param_1_53 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 695 
      ldv_emg_wrapper_i40e_get_ringparam_29(ldv_18_container,ldv_18_ldv_param_1_53);
      
#line 699 
      ldv_free((void *)ldv_18_ldv_param_1_53);
      
#line 702 
      goto ldv_45733;
      case 28: 
#line 704 
      ;
      
#line 706 
      ldv_18_ldv_param_1_52 = (struct ethtool_ts_info *)ldv_xmalloc_unknown_size(0UL);
      
#line 711 
      ldv_emg_wrapper_i40e_get_ts_info_43(ldv_18_container,ldv_18_ldv_param_1_52);
      
#line 715 
      ldv_free((void *)ldv_18_ldv_param_1_52);
      
#line 718 
      goto ldv_45733;
      case 29: 
#line 720 
      ;
      
#line 723 
      ldv_emg_wrapper_i40e_get_rxfh_indir_size_27(ldv_18_container);
      
#line 726 
      goto ldv_45733;
      case 30: 
#line 728 
      ;
      
#line 731 
      (*ldv_emg_alias_ethtool_op_get_link_26)(ldv_18_container);
      
#line 734 
      goto ldv_45733;
      case 31: 
#line 736 
      ;
      
#line 742 
      i40e_ndo_set_vf_spoofchk(ldv_18_container,ldv_18_ldv_param_1_50,(_Bool)((bool)((int)ldv_18_ldv_param_2_51) != 0));
      
#line 748 
      goto ldv_45733;
      case 32: 
#line 750 
      ;
      
#line 752 
      ldv_18_ldv_param_1_49 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 757 
      ldv_emg_wrapper_i40e_get_pauseparam_25(ldv_18_container,ldv_18_ldv_param_1_49);
      
#line 761 
      ldv_free((void *)ldv_18_ldv_param_1_49);
      
#line 764 
      goto ldv_45733;
      case 33: 
#line 766 
      ;
      
#line 769 
      i40e_set_rx_mode(ldv_18_container);
      
#line 772 
      goto ldv_45733;
      case 34: 
#line 774 
      ;
      
#line 777 
      ldv_emg_wrapper_i40e_nway_reset_24(ldv_18_container);
      
#line 780 
      goto ldv_45733;
      case 35: 
#line 782 
      ;
      
#line 788 
      i40e_ndo_set_vf_link_state(ldv_18_container,ldv_18_ldv_param_1_47,ldv_18_ldv_param_2_48);
      
#line 794 
      goto ldv_45733;
      case 36: 
#line 796 
      ;
      
#line 802 
      ldv_emg_wrapper_i40e_del_vxlan_port_23(ldv_18_container,(unsigned short)((int)ldv_18_ldv_param_1_45),(unsigned short)((int)ldv_18_ldv_param_2_46));
      
#line 808 
      goto ldv_45733;
      case 37: 
#line 810 
      ;
      
#line 812 
      ldv_18_ldv_param_1_42 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 813 
      ldv_18_ldv_param_2_43 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 814 
      ldv_18_ldv_param_3_44 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 819 
      ldv_emg_wrapper_i40e_get_rxfh_22(ldv_18_container,ldv_18_ldv_param_1_42,ldv_18_ldv_param_2_43,ldv_18_ldv_param_3_44);
      
#line 823 
      ldv_free((void *)ldv_18_ldv_param_1_42);
      
#line 824 
      ldv_free((void *)ldv_18_ldv_param_2_43);
      
#line 825 
      ldv_free((void *)ldv_18_ldv_param_3_44);
      
#line 828 
      goto ldv_45733;
      case 38: 
#line 830 
      ;
      
#line 832 
      ldv_18_ldv_param_2_41 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 837 
      i40e_ndo_set_vf_mac(ldv_18_container,ldv_18_ldv_param_1_40,ldv_18_ldv_param_2_41);
      
#line 841 
      ldv_free((void *)ldv_18_ldv_param_2_41);
      
#line 844 
      goto ldv_45733;
      case 39: 
#line 846 
      ;
      
#line 848 
      ldv_18_ldv_param_1_39 = ldv_xmalloc_unknown_size(0UL);
      
#line 853 
      i40e_set_mac(ldv_18_container,ldv_18_ldv_param_1_39);
      
#line 857 
      ldv_free(ldv_18_ldv_param_1_39);
      
#line 860 
      goto ldv_45733;
      case 40: 
#line 862 
      ;
      
#line 864 
      ldv_18_ldv_param_2_38 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 865 
      ldv_18_ldv_param_1_37 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
      
#line 870 
      ldv_emg_wrapper_i40e_get_rxnfc_21(ldv_18_container,ldv_18_ldv_param_1_37,ldv_18_ldv_param_2_38);
      
#line 874 
      ldv_free((void *)ldv_18_ldv_param_2_38);
      
#line 875 
      ldv_free((void *)ldv_18_ldv_param_1_37);
      
#line 878 
      goto ldv_45733;
      case 41: 
#line 880 
      ;
      
#line 886 
      i40e_ndo_set_vf_bw(ldv_18_container,ldv_18_ldv_param_1_34,ldv_18_ldv_param_2_35,ldv_18_ldv_param_3_36);
      
#line 892 
      goto ldv_45733;
      case 42: 
#line 894 
      ;
      
#line 896 
      ldv_18_ldv_param_2_32 = (struct scatterlist *)ldv_xmalloc_unknown_size(0UL);
      
#line 901 
      ldv_emg_wrapper_i40e_fcoe_ddp_target_20(ldv_18_container,(unsigned short)((int)ldv_18_ldv_param_1_31),ldv_18_ldv_param_2_32,ldv_18_ldv_param_3_33);
      
#line 905 
      ldv_free((void *)ldv_18_ldv_param_2_32);
      
#line 908 
      goto ldv_45733;
      case 43: 
#line 910 
      ;
      
#line 912 
      ldv_18_ldv_param_1_30 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 917 
      ldv_emg_wrapper_i40e_set_wol_19(ldv_18_container,ldv_18_ldv_param_1_30);
      
#line 921 
      ldv_free((void *)ldv_18_ldv_param_1_30);
      
#line 924 
      goto ldv_45733;
      case 44: 
#line 926 
      ;
      
#line 928 
      ldv_18_ldv_param_1_26 = (struct nlattr **)ldv_xmalloc_unknown_size(0UL);
      
#line 929 
      ldv_18_ldv_param_0_25 = (struct ndmsg *)ldv_xmalloc_unknown_size(0UL);
      
#line 930 
      ldv_18_ldv_param_3_27 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 935 
      ldv_emg_wrapper_i40e_ndo_fdb_add_18(ldv_18_ldv_param_0_25,ldv_18_ldv_param_1_26,ldv_18_container,ldv_18_ldv_param_3_27,(unsigned short)((int)ldv_18_ldv_param_4_28),(unsigned short)((int)ldv_18_ldv_param_5_29));
      
#line 939 
      ldv_free((void *)ldv_18_ldv_param_1_26);
      
#line 940 
      ldv_free((void *)ldv_18_ldv_param_0_25);
      
#line 941 
      ldv_free((void *)ldv_18_ldv_param_3_27);
      
#line 944 
      goto ldv_45733;
      case 45: 
#line 946 
      ;
      
#line 948 
      ldv_18_ldv_param_1_23 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
      
#line 953 
      i40e_ioctl(ldv_18_container,ldv_18_ldv_param_1_23,ldv_18_ldv_param_2_24);
      
#line 957 
      ldv_free((void *)ldv_18_ldv_param_1_23);
      
#line 960 
      goto ldv_45733;
      case 46: 
#line 962 
      ;
      
#line 968 
      ldv_emg_wrapper_i40e_set_msglevel_28(ldv_18_container,ldv_18_ldv_param_1_22);
      
#line 974 
      goto ldv_45733;
      case 47: 
#line 976 
      ;
      
#line 979 
      ldv_emg_wrapper_i40e_get_rxfh_key_size_12(ldv_18_container);
      
#line 982 
      goto ldv_45733;
      case 48: 
#line 984 
      ;
      
#line 990 
      ldv_emg_wrapper_i40e_get_sset_count_40(ldv_18_container,ldv_18_ldv_param_1_21);
      
#line 996 
      goto ldv_45733;
      case 49: 
#line 998 
      ;
      
#line 1001 
      ldv_emg_wrapper_i40e_get_priv_flags_15(ldv_18_container);
      
#line 1004 
      goto ldv_45733;
      case 50: 
#line 1006 
      ;
      
#line 1008 
      ldv_18_ldv_param_0_20 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
      
#line 1013 
      ldv_emg_wrapper_i40e_fcoe_xmit_frame_14(ldv_18_ldv_param_0_20,ldv_18_container);
      
#line 1017 
      ldv_free((void *)ldv_18_ldv_param_0_20);
      
#line 1020 
      goto ldv_45733;
      case 51: 
#line 1022 
      ;
      
#line 1025 
      ldv_emg_wrapper_i40e_get_msglevel_13(ldv_18_container);
      
#line 1028 
      goto ldv_45733;
      case 52: 
#line 1030 
      ;
      
#line 1032 
      ldv_18_ldv_param_1_19 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 1037 
      ldv_emg_wrapper_i40e_set_ringparam_10(ldv_18_container,ldv_18_ldv_param_1_19);
      
#line 1041 
      ldv_free((void *)ldv_18_ldv_param_1_19);
      
#line 1044 
      goto ldv_45733;
      case 53: 
#line 1046 
      ;
      
#line 1048 
      ldv_18_ldv_param_1_16 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
      
#line 1049 
      ldv_18_ldv_param_2_17 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1054 
      ldv_emg_wrapper_i40e_set_rxfh_9(ldv_18_container,ldv_18_ldv_param_1_16,ldv_18_ldv_param_2_17,(unsigned char)((int)ldv_18_ldv_param_3_18));
      
#line 1058 
      ldv_free((void *)ldv_18_ldv_param_1_16);
      
#line 1059 
      ldv_free((void *)ldv_18_ldv_param_2_17);
      
#line 1062 
      goto ldv_45733;
      case 54: 
#line 1064 
      ;
      
#line 1066 
      ldv_18_ldv_param_2_14 = (struct scatterlist *)ldv_xmalloc_unknown_size(0UL);
      
#line 1071 
      ldv_emg_wrapper_i40e_fcoe_ddp_get_11(ldv_18_container,(unsigned short)((int)ldv_18_ldv_param_1_13),ldv_18_ldv_param_2_14,ldv_18_ldv_param_3_15);
      
#line 1075 
      ldv_free((void *)ldv_18_ldv_param_2_14);
      
#line 1078 
      goto ldv_45733;
      case 55: 
#line 1080 
      ;
      
#line 1086 
      ldv_emg_wrapper_i40e_add_vxlan_port_34(ldv_18_container,(unsigned short)((int)ldv_18_ldv_param_1_11),(unsigned short)((int)ldv_18_ldv_param_2_12));
      
#line 1092 
      goto ldv_45733;
      case 56: 
#line 1094 
      ;
      
#line 1096 
      ldv_18_ldv_param_1_10 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 1101 
      ldv_emg_wrapper_i40e_get_drvinfo_7(ldv_18_container,ldv_18_ldv_param_1_10);
      
#line 1105 
      ldv_free((void *)ldv_18_ldv_param_1_10);
      
#line 1108 
      goto ldv_45733;
      case 57: 
#line 1110 
      ;
      
#line 1112 
      ldv_18_ldv_param_1_9 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
      
#line 1117 
      ldv_emg_wrapper_i40e_set_rxnfc_6(ldv_18_container,ldv_18_ldv_param_1_9);
      
#line 1121 
      ldv_free((void *)ldv_18_ldv_param_1_9);
      
#line 1124 
      goto ldv_45733;
      case 58: 
#line 1126 
      ;
      
#line 1132 
      ldv_emg_wrapper_i40e_fcoe_change_mtu_5(ldv_18_container,ldv_18_ldv_param_1_8);
      
#line 1138 
      goto ldv_45733;
      case 59: 
#line 1140 
      ;
      
#line 1142 
      ldv_18_ldv_param_2_7 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1143 
      ldv_18_ldv_param_1_6 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
      
#line 1148 
      ldv_emg_wrapper_i40e_get_ethtool_stats_4(ldv_18_container,ldv_18_ldv_param_1_6,ldv_18_ldv_param_2_7);
      
#line 1152 
      ldv_free((void *)ldv_18_ldv_param_2_7);
      
#line 1153 
      ldv_free((void *)ldv_18_ldv_param_1_6);
      
#line 1156 
      goto ldv_45733;
      case 60: 
#line 1158 
      ;
      
#line 1160 
      ldv_18_ldv_param_1_5 = (struct rtnl_link_stats64 *)ldv_xmalloc_unknown_size(0UL);
      
#line 1165 
      i40e_get_netdev_stats_struct(ldv_18_container,ldv_18_ldv_param_1_5);
      
#line 1169 
      ldv_free((void *)ldv_18_ldv_param_1_5);
      
#line 1172 
      goto ldv_45733;
      case 61: 
#line 1174 
      ;
      
#line 1176 
      ldv_18_ldv_param_1_4 = (enum ethtool_phys_id_state *)ldv_xmalloc_unknown_size(0UL);
      
#line 1181 
      ldv_emg_wrapper_i40e_set_phys_id_3(ldv_18_container,*ldv_18_ldv_param_1_4);
      
#line 1185 
      ldv_free((void *)ldv_18_ldv_param_1_4);
      
#line 1188 
      goto ldv_45733;
      case 62: 
#line 1190 
      ;
      
#line 1192 
      ldv_18_ldv_param_1_3 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 1197 
      ldv_emg_wrapper_i40e_set_settings_2(ldv_18_container,ldv_18_ldv_param_1_3);
      
#line 1201 
      ldv_free((void *)ldv_18_ldv_param_1_3);
      
#line 1204 
      goto ldv_45733;
      case 63: 
#line 1206 
      ;
      
#line 1209 
      i40e_fcoe_enable(ldv_18_container);
      
#line 1212 
      goto ldv_45733;
      default: 
#line 1214 
      ;
      
#line 1214 
      __VERIFIER_assume(0);
    }
    ldv_45733: 
#line 1223 
    ;
    
#line 1223 
    goto ldv_call_18;
  }
  else {
    
#line 1231 
    __retres = (void *)0;
    
#line 1231 
    goto return_label;
  }
  
#line 1234 
  __retres = (void *)0;
  return_label: 
#line 1234 
                return __retres;
}


#line 1239  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 1242 
  struct pci_driver *ldv_9_pci_driver = ldv_emg_alias_i40e_driver_2;
  
#line 1246 
  tmp_0 = ldv_undef_int();
  
#line 1246 
  if (tmp_0 != 0) {
    
#line 1248 
    ldv_9_pci_driver = arg0;
    
#line 1252 
    ldv_dispatch_register_9_3(ldv_9_pci_driver);
    
#line 1256 
    __retres = 0;
    
#line 1256 
    goto return_label;
  }
  else {
    int tmp;
    
#line 1263 
    tmp = ldv_undef_int_negative();
    
#line 1263 
    __retres = tmp;
    
#line 1263 
    goto return_label;
  }
  return_label: 
#line 1246 
                return __retres;
}


#line 1273  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_9_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_14 *cf_arg_14;
  int tmp;
  
#line 1276 
  tmp = ldv_undef_int();
  
#line 1276 
  switch (tmp) {
    case 0: 
#line 1277 
    ;
    
#line 1278 
    cf_arg_14 = (struct ldv_struct_pci_scenario_14 *)ldv_xmalloc(16UL);
    
#line 1279 
    cf_arg_14->arg0 = arg0;
    
#line 1280 
    ret = pthread_create(& ldv_thread_14,(pthread_attr_t const *)0,& ldv_pci_scenario_14,(void *)cf_arg_14);
    
#line 1281 
    __VERIFIER_assume(ret == 0);
    
#line 1282 
    goto ldv_45809;
    default: 
#line 1284 
    ;
    
#line 1284 
    __VERIFIER_assume(0);
  }
  ldv_45809: 
#line 1285 
  ;
  
#line 1286 
  return;
}


#line 1290  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4)
{
  struct dentry *__retres;
  struct dentry *ldv_12_dentry;
  struct file_operations *ldv_12_file_operations;
  int tmp_1;
  
#line 1298 
  tmp_1 = ldv_undef_int();
  
#line 1298 
  if (tmp_1 != 0) {
    
#line 1300 
    ldv_12_dentry = (struct dentry *)ldv_xmalloc_unknown_size(0UL);
    
#line 1301 
    ldv_12_file_operations = arg4;
    
#line 1305 
    ldv_dispatch_register_12_3(ldv_12_file_operations);
    
#line 1309 
    __retres = ldv_12_dentry;
    
#line 1309 
    goto return_label;
  }
  else {
    struct dentry *tmp_0;
    
#line 1316 
    tmp_0 = (struct dentry *)ERR_PTR(-19L);
    
#line 1316 
    __retres = tmp_0;
    
#line 1316 
    goto return_label;
  }
  return_label: 
#line 1298 
                return __retres;
}


#line 1326  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_timer_scenario_15(void *arg0)
{
  void *__retres;
  struct timer_list *ldv_15_container;
  
#line 1331 
  struct ldv_struct_timer_scenario_15 *data = (struct ldv_struct_timer_scenario_15 *)arg0;
  
#line 1336 
  if (data != (struct ldv_struct_timer_scenario_15 *)0) {
    
#line 1337 
    ldv_15_container = data->arg0;
    
#line 1338 
    ldv_free((void *)data);
  }
  else ;
  
#line 1343 
  if (ldv_15_container->function != (void (*)(unsigned long ))0) {
    
#line 1345 
    ldv_switch_to_interrupt_context();
    
#line 1347 
    (*(ldv_15_container->function))(ldv_15_container->data);
    
#line 1349 
    ldv_switch_to_process_context();
  }
  else ;
  
#line 1358 
  __retres = (void *)0;
  
#line 1358 
  goto return_label;
  
#line 1360 
  __retres = (void *)0;
  return_label: 
#line 1360 
                return __retres;
}


#line 1365  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_14(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_14_resource_1;
  struct pci_device_id *ldv_14_ldv_param_1_2;
  int ldv_14_ldv_param_1_3;
  struct pm_message ldv_14_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 1371 
  struct pci_driver *ldv_14_container = ldv_emg_alias_i40e_driver_2;
  
#line 1372 
  int ldv_14_ret = ldv_undef_int();
  
#line 1375 
  struct ldv_struct_pci_scenario_14 *data = (struct ldv_struct_pci_scenario_14 *)arg0;
  
#line 1379 
  ldv_14_ret = ldv_undef_int();
  
#line 1382 
  if (data != (struct ldv_struct_pci_scenario_14 *)0) {
    
#line 1383 
    ldv_14_container = data->arg0;
    
#line 1384 
    ldv_free((void *)data);
  }
  else ;
  
#line 1395 
  goto ldv_main_14;
  
#line 1397 
  __retres = (void *)0;
  
#line 1397 
  goto return_label;
  ldv_main_14: 
#line 1400 
  ;
  
#line 1403 
  tmp_2 = ldv_undef_int();
  
#line 1403 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 1405 
    ldv_14_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 1410 
    ldv_pre_probe();
    
#line 1412 
    ldv_14_ret = ldv_emg_wrapper_i40e_probe_3(ldv_14_resource_1,ldv_14_ldv_param_1_2);
    
#line 1414 
    ldv_14_ret = ldv_post_probe(ldv_14_ret);
    
#line 1418 
    ldv_free((void *)ldv_14_ldv_param_1_2);
    
#line 1421 
    tmp_1 = ldv_undef_int();
    
#line 1421 
    if (tmp_1 != 0) {
      
#line 1423 
      __VERIFIER_assume(ldv_14_ret == 0);
      
#line 1430 
      goto ldv_call_14;
    }
    else {
      
#line 1434 
      __VERIFIER_assume(ldv_14_ret != 0);
      
#line 1441 
      goto ldv_main_14;
    }
  }
  else {
    
#line 1453 
    __retres = (void *)0;
    
#line 1453 
    goto return_label;
  }
  
#line 1456 
  __retres = (void *)0;
  
#line 1456 
  goto return_label;
  ldv_call_14: 
#line 1459 
  ;
  
#line 1462 
  tmp_3 = ldv_undef_int();
  
#line 1462 
  switch (tmp_3) {
    case 1: 
#line 1463 
    ;
    
#line 1469 
    i40e_pci_sriov_configure(ldv_14_resource_1,ldv_14_ldv_param_1_3);
    
#line 1479 
    goto ldv_call_14;
    case 2: 
#line 1482 
    ;
    
#line 1485 
    ldv_14_ret = ldv_emg_wrapper_i40e_suspend_4(ldv_14_resource_1,ldv_14_resource_0);
    
#line 1487 
    ldv_14_ret = ldv_filter_err_code(ldv_14_ret);
    
#line 1491 
    if (ldv_14_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 1493 
      ldv_14_ret = (*(ldv_14_container->suspend_late))(ldv_14_resource_1,ldv_14_resource_0);
      
#line 1495 
      ldv_14_ret = ldv_filter_err_code(ldv_14_ret);
    }
    else 
#line 1497 
         ldv_14_ret = ldv_undef_int();
    
#line 1502 
    if (ldv_14_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 1504 
      (*(ldv_14_container->resume_early))(ldv_14_resource_1); else ;
    
#line 1510 
    ldv_emg_wrapper_i40e_resume_6(ldv_14_resource_1);
    
#line 1517 
    goto ldv_call_14;
    case 3: 
#line 1520 
    ;
    
#line 1523 
    ldv_emg_wrapper_i40e_shutdown_2(ldv_14_resource_1);
    
#line 1528 
    ldv_emg_wrapper_i40e_remove_5(ldv_14_resource_1);
    
#line 1535 
    goto ldv_main_14;
    default: 
#line 1538 
    ;
    
#line 1538 
    __VERIFIER_assume(0);
  }
  
#line 1541 
  __retres = (void *)0;
  return_label: 
#line 1541 
                return __retres;
}


#line 1546  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_19(void *arg0)
{
  void *__retres;
  struct file *ldv_19_resource_1;
  char *ldv_19_ldv_param_1_2;
  unsigned long ldv_19_size_cnt;
  char *ldv_19_ldv_param_1_4;
  long long *ldv_19_ldv_param_3_3;
  long long *ldv_19_ldv_param_3_5;
  struct inode *ldv_19_resource_0;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1554 
  struct file_operations *ldv_19_container = ldv_emg_alias_i40e_dbg_command_fops_2;
  
#line 1556 
  int ldv_19_ret = ldv_undef_int();
  
#line 1559 
  struct ldv_struct_character_driver_scenario_17 *data = (struct ldv_struct_character_driver_scenario_17 *)arg0;
  
#line 1563 
  ldv_19_ret = ldv_undef_int();
  
#line 1566 
  if (data != (struct ldv_struct_character_driver_scenario_17 *)0) {
    
#line 1567 
    ldv_19_container = data->arg0;
    
#line 1568 
    ldv_free((void *)data);
  }
  else ;
  
#line 1573 
  ldv_19_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1574 
  tmp_1 = ldv_undef_int();
  
#line 1574 
  ldv_19_size_cnt = (unsigned long)tmp_1;
  
#line 1581 
  goto ldv_main_19;
  
#line 1583 
  __retres = (void *)0;
  
#line 1583 
  goto return_label;
  ldv_main_19: 
#line 1586 
  ;
  
#line 1589 
  tmp_3 = ldv_undef_int();
  
#line 1589 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1592 
    ldv_19_ret = (*ldv_emg_alias_simple_open_5)(ldv_19_resource_0,ldv_19_resource_1);
    
#line 1594 
    ldv_19_ret = ldv_filter_err_code(ldv_19_ret);
    
#line 1597 
    tmp_2 = ldv_undef_int();
    
#line 1597 
    if (tmp_2 != 0) {
      
#line 1599 
      __VERIFIER_assume(ldv_19_ret == 0);
      
#line 1606 
      goto ldv_call_19;
    }
    else {
      
#line 1610 
      __VERIFIER_assume(ldv_19_ret != 0);
      
#line 1617 
      goto ldv_main_19;
    }
  }
  else {
    
#line 1622 
    ldv_free((void *)ldv_19_resource_0);
    
#line 1630 
    __retres = (void *)0;
    
#line 1630 
    goto return_label;
  }
  
#line 1633 
  __retres = (void *)0;
  
#line 1633 
  goto return_label;
  ldv_call_19: 
#line 1636 
  ;
  
#line 1639 
  tmp_4 = ldv_undef_int();
  
#line 1639 
  switch (tmp_4) {
    case 1: 
#line 1640 
    ;
    
#line 1642 
    ldv_19_ldv_param_3_3 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1643 
    ldv_19_ldv_param_1_2 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1648 
    ldv_emg_wrapper_i40e_dbg_command_read_3(ldv_19_resource_1,ldv_19_ldv_param_1_2,ldv_19_size_cnt,ldv_19_ldv_param_3_3);
    
#line 1652 
    ldv_free((void *)ldv_19_ldv_param_3_3);
    
#line 1653 
    ldv_free((void *)ldv_19_ldv_param_1_2);
    
#line 1660 
    goto ldv_call_19;
    case 2: 
#line 1663 
    ;
    
#line 1665 
    ldv_19_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1666 
    ldv_19_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1675 
    __VERIFIER_assume(ldv_19_size_cnt <= 2147479552UL);
    
#line 1677 
    ldv_emg_wrapper_i40e_dbg_command_write_4(ldv_19_resource_1,ldv_19_ldv_param_1_4,ldv_19_size_cnt,ldv_19_ldv_param_3_5);
    
#line 1681 
    ldv_free((void *)ldv_19_ldv_param_1_4);
    
#line 1682 
    ldv_free((void *)ldv_19_ldv_param_3_5);
    
#line 1689 
    goto ldv_call_19;
    case 3: 
#line 1692 
    ;
    
#line 1694 
    if (ldv_19_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1696 
      (*(ldv_19_container->release))(ldv_19_resource_0,ldv_19_resource_1); else ;
    
#line 1704 
    goto ldv_main_19;
    default: 
#line 1707 
    ;
    
#line 1707 
    __VERIFIER_assume(0);
  }
  
#line 1710 
  __retres = (void *)0;
  return_label: 
#line 1710 
                return __retres;
}


#line 1715  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  struct net_device *__retres;
  struct net_device *ldv_4_netdev;
  int tmp_0;
  
#line 1722 
  tmp_0 = ldv_undef_int();
  
#line 1722 
  if (tmp_0 != 0) {
    
#line 1724 
    ldv_4_netdev = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    
#line 1728 
    __retres = ldv_4_netdev;
    
#line 1728 
    goto return_label;
  }
  else {
    
#line 1735 
    __retres = (struct net_device *)0;
    
#line 1735 
    goto return_label;
  }
  return_label: 
#line 1722 
                return __retres;
}


#line 1745  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_17(void *arg0)
{
  void *__retres;
  struct file *ldv_17_resource_1;
  char *ldv_17_ldv_param_1_2;
  unsigned long ldv_17_size_cnt;
  char *ldv_17_ldv_param_1_4;
  long long *ldv_17_ldv_param_3_3;
  long long *ldv_17_ldv_param_3_5;
  struct inode *ldv_17_resource_0;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1753 
  struct file_operations *ldv_17_container = ldv_emg_alias_i40e_dbg_netdev_ops_fops_2;
  
#line 1755 
  int ldv_17_ret = ldv_undef_int();
  
#line 1758 
  struct ldv_struct_character_driver_scenario_17 *data = (struct ldv_struct_character_driver_scenario_17 *)arg0;
  
#line 1762 
  ldv_17_ret = ldv_undef_int();
  
#line 1765 
  if (data != (struct ldv_struct_character_driver_scenario_17 *)0) {
    
#line 1766 
    ldv_17_container = data->arg0;
    
#line 1767 
    ldv_free((void *)data);
  }
  else ;
  
#line 1772 
  ldv_17_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1773 
  tmp_1 = ldv_undef_int();
  
#line 1773 
  ldv_17_size_cnt = (unsigned long)tmp_1;
  
#line 1780 
  goto ldv_main_17;
  
#line 1782 
  __retres = (void *)0;
  
#line 1782 
  goto return_label;
  ldv_main_17: 
#line 1785 
  ;
  
#line 1788 
  tmp_3 = ldv_undef_int();
  
#line 1788 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1791 
    ldv_17_ret = (*ldv_emg_alias_simple_open_5)(ldv_17_resource_0,ldv_17_resource_1);
    
#line 1793 
    ldv_17_ret = ldv_filter_err_code(ldv_17_ret);
    
#line 1796 
    tmp_2 = ldv_undef_int();
    
#line 1796 
    if (tmp_2 != 0) {
      
#line 1798 
      __VERIFIER_assume(ldv_17_ret == 0);
      
#line 1805 
      goto ldv_call_17;
    }
    else {
      
#line 1809 
      __VERIFIER_assume(ldv_17_ret != 0);
      
#line 1816 
      goto ldv_main_17;
    }
  }
  else {
    
#line 1821 
    ldv_free((void *)ldv_17_resource_0);
    
#line 1829 
    __retres = (void *)0;
    
#line 1829 
    goto return_label;
  }
  
#line 1832 
  __retres = (void *)0;
  
#line 1832 
  goto return_label;
  ldv_call_17: 
#line 1835 
  ;
  
#line 1838 
  tmp_4 = ldv_undef_int();
  
#line 1838 
  switch (tmp_4) {
    case 1: 
#line 1839 
    ;
    
#line 1841 
    ldv_17_ldv_param_3_3 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1842 
    ldv_17_ldv_param_1_2 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1847 
    ldv_emg_wrapper_i40e_dbg_netdev_ops_read_3(ldv_17_resource_1,ldv_17_ldv_param_1_2,ldv_17_size_cnt,ldv_17_ldv_param_3_3);
    
#line 1851 
    ldv_free((void *)ldv_17_ldv_param_3_3);
    
#line 1852 
    ldv_free((void *)ldv_17_ldv_param_1_2);
    
#line 1859 
    goto ldv_call_17;
    case 2: 
#line 1862 
    ;
    
#line 1864 
    ldv_17_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1865 
    ldv_17_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1874 
    __VERIFIER_assume(ldv_17_size_cnt <= 2147479552UL);
    
#line 1876 
    ldv_emg_wrapper_i40e_dbg_netdev_ops_write_4(ldv_17_resource_1,ldv_17_ldv_param_1_4,ldv_17_size_cnt,ldv_17_ldv_param_3_5);
    
#line 1880 
    ldv_free((void *)ldv_17_ldv_param_3_5);
    
#line 1881 
    ldv_free((void *)ldv_17_ldv_param_1_4);
    
#line 1888 
    goto ldv_call_17;
    case 3: 
#line 1891 
    ;
    
#line 1893 
    if (ldv_17_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1895 
      (*(ldv_17_container->release))(ldv_17_resource_0,ldv_17_resource_1); else ;
    
#line 1903 
    goto ldv_main_17;
    default: 
#line 1906 
    ;
    
#line 1906 
    __VERIFIER_assume(0);
  }
  
#line 1909 
  __retres = (void *)0;
  return_label: 
#line 1909 
                return __retres;
}


#line 1914  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_8_4(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_18 *cf_arg_18;
  int tmp;
  
#line 1917 
  tmp = ldv_undef_int();
  
#line 1917 
  switch (tmp) {
    case 0: 
#line 1918 
    ;
    
#line 1919 
    cf_arg_18 = (struct ldv_struct_random_allocationless_scenario_18 *)ldv_xmalloc(16UL);
    
#line 1920 
    cf_arg_18->arg0 = arg0;
    
#line 1921 
    ret = pthread_create(& ldv_thread_18,(pthread_attr_t const *)0,& ldv_random_allocationless_scenario_18,(void *)cf_arg_18);
    
#line 1922 
    __VERIFIER_assume(ret == 0);
    
#line 1923 
    goto ldv_45891;
    default: 
#line 1925 
    ;
    
#line 1925 
    __VERIFIER_assume(0);
  }
  ldv_45891: 
#line 1926 
  ;
  
#line 1927 
  return;
}


#line 1931  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_20(void *arg0)
{
  void *__retres;
  struct file *ldv_20_resource_1;
  char *ldv_20_ldv_param_1_2;
  unsigned long ldv_20_size_cnt;
  char *ldv_20_ldv_param_1_4;
  long long *ldv_20_ldv_param_3_3;
  long long *ldv_20_ldv_param_3_5;
  struct inode *ldv_20_resource_0;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1939 
  struct file_operations *ldv_20_container = ldv_emg_alias_i40e_dbg_dump_fops_2;
  
#line 1941 
  int ldv_20_ret = ldv_undef_int();
  
#line 1944 
  struct ldv_struct_character_driver_scenario_17 *data = (struct ldv_struct_character_driver_scenario_17 *)arg0;
  
#line 1948 
  ldv_20_ret = ldv_undef_int();
  
#line 1951 
  if (data != (struct ldv_struct_character_driver_scenario_17 *)0) {
    
#line 1952 
    ldv_20_container = data->arg0;
    
#line 1953 
    ldv_free((void *)data);
  }
  else ;
  
#line 1958 
  ldv_20_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1959 
  tmp_1 = ldv_undef_int();
  
#line 1959 
  ldv_20_size_cnt = (unsigned long)tmp_1;
  
#line 1966 
  goto ldv_main_20;
  
#line 1968 
  __retres = (void *)0;
  
#line 1968 
  goto return_label;
  ldv_main_20: 
#line 1971 
  ;
  
#line 1974 
  tmp_3 = ldv_undef_int();
  
#line 1974 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1977 
    ldv_20_ret = (*ldv_emg_alias_simple_open_5)(ldv_20_resource_0,ldv_20_resource_1);
    
#line 1979 
    ldv_20_ret = ldv_filter_err_code(ldv_20_ret);
    
#line 1982 
    tmp_2 = ldv_undef_int();
    
#line 1982 
    if (tmp_2 != 0) {
      
#line 1984 
      __VERIFIER_assume(ldv_20_ret == 0);
      
#line 1991 
      goto ldv_call_20;
    }
    else {
      
#line 1995 
      __VERIFIER_assume(ldv_20_ret != 0);
      
#line 2002 
      goto ldv_main_20;
    }
  }
  else {
    
#line 2007 
    ldv_free((void *)ldv_20_resource_0);
    
#line 2015 
    __retres = (void *)0;
    
#line 2015 
    goto return_label;
  }
  
#line 2018 
  __retres = (void *)0;
  
#line 2018 
  goto return_label;
  ldv_call_20: 
#line 2021 
  ;
  
#line 2024 
  tmp_4 = ldv_undef_int();
  
#line 2024 
  switch (tmp_4) {
    case 1: 
#line 2025 
    ;
    
#line 2027 
    ldv_20_ldv_param_1_2 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2028 
    ldv_20_ldv_param_3_3 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2033 
    ldv_emg_wrapper_i40e_dbg_dump_read_3(ldv_20_resource_1,ldv_20_ldv_param_1_2,ldv_20_size_cnt,ldv_20_ldv_param_3_3);
    
#line 2037 
    ldv_free((void *)ldv_20_ldv_param_1_2);
    
#line 2038 
    ldv_free((void *)ldv_20_ldv_param_3_3);
    
#line 2045 
    goto ldv_call_20;
    case 2: 
#line 2048 
    ;
    
#line 2050 
    ldv_20_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 2051 
    ldv_20_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 2060 
    __VERIFIER_assume(ldv_20_size_cnt <= 2147479552UL);
    
#line 2062 
    ldv_emg_wrapper_i40e_dbg_dump_write_4(ldv_20_resource_1,ldv_20_ldv_param_1_4,ldv_20_size_cnt,ldv_20_ldv_param_3_5);
    
#line 2066 
    ldv_free((void *)ldv_20_ldv_param_3_5);
    
#line 2067 
    ldv_free((void *)ldv_20_ldv_param_1_4);
    
#line 2074 
    goto ldv_call_20;
    case 3: 
#line 2077 
    ;
    
#line 2079 
    if (ldv_20_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 2081 
      (*(ldv_20_container->release))(ldv_20_resource_0,ldv_20_resource_1); else ;
    
#line 2089 
    goto ldv_main_20;
    default: 
#line 2092 
    ;
    
#line 2092 
    __VERIFIER_assume(0);
  }
  
#line 2095 
  __retres = (void *)0;
  return_label: 
#line 2095 
                return __retres;
}


#line 2100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_13_line;
  void *ldv_13_data;
  enum irqreturn (*ldv_13_thread)(int , void *);
  int tmp_0;
  
#line 2105 
  enum irqreturn (*ldv_13_callback)(int , void *) = & ldv_emg_wrapper_i40e_intr_2;
  
#line 2110 
  tmp_0 = ldv_undef_int();
  
#line 2110 
  if (tmp_0 != 0) {
    
#line 2112 
    ldv_13_line = (int)arg0;
    
#line 2113 
    ldv_13_callback = arg1;
    
#line 2114 
    ldv_13_thread = (enum irqreturn (*)(int , void *))0;
    
#line 2115 
    ldv_13_data = arg4;
    
#line 2119 
    ldv_dispatch_irq_register_13_3(ldv_13_line,ldv_13_callback,ldv_13_thread,ldv_13_data);
    
#line 2123 
    __retres = 0;
    
#line 2123 
    goto return_label;
  }
  else {
    int tmp;
    
#line 2130 
    tmp = ldv_undef_int_negative();
    
#line 2130 
    __retres = tmp;
    
#line 2130 
    goto return_label;
  }
  return_label: 
#line 2110 
                return __retres;
}


#line 2140  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_14 *cf_arg_14;
  int tmp;
  
#line 2143 
  tmp = ldv_undef_int();
  
#line 2143 
  switch (tmp) {
    case 0: 
#line 2144 
    ;
    
#line 2145 
    ret = pthread_join(ldv_thread_14,(void **)0);
    
#line 2146 
    __VERIFIER_assume(ret == 0);
    
#line 2147 
    goto ldv_45935;
    default: 
#line 2149 
    ;
    
#line 2149 
    __VERIFIER_assume(0);
  }
  ldv_45935: 
#line 2150 
  ;
  
#line 2151 
  return;
}


#line 2155  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_16(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_16_ret_val;
  int ldv_16_line;
  void *ldv_16_data;
  enum irqreturn (*ldv_16_thread)(int , void *);
  int tmp;
  
#line 2161 
  enum irqreturn (*ldv_16_callback)(int , void *) = & ldv_emg_wrapper_i40e_intr_2;
  
#line 2164 
  struct ldv_struct_interrupt_scenario_16 *data = (struct ldv_struct_interrupt_scenario_16 *)arg0;
  
#line 2169 
  if (data != (struct ldv_struct_interrupt_scenario_16 *)0) {
    
#line 2170 
    ldv_16_line = data->arg0;
    
#line 2171 
    ldv_16_callback = data->arg1;
    
#line 2172 
    ldv_16_thread = data->arg2;
    
#line 2173 
    ldv_16_data = data->arg3;
    
#line 2174 
    ldv_free((void *)data);
  }
  else ;
  
#line 2180 
  ldv_switch_to_interrupt_context();
  
#line 2182 
  ldv_16_ret_val = ldv_emg_wrapper_i40e_intr_2(ldv_16_line,ldv_16_data);
  
#line 2184 
  ldv_switch_to_process_context();
  
#line 2187 
  tmp = ldv_undef_int();
  
#line 2187 
  if (tmp != 0) {
    
#line 2189 
    __VERIFIER_assume(ldv_16_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 2193 
    if (ldv_16_thread != (enum irqreturn (*)(int , void *))0) 
#line 2195 
                                                              (*ldv_16_thread)(ldv_16_line,ldv_16_data); else ;
  }
  else 
#line 2202 
       __VERIFIER_assume(ldv_16_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 2211 
  __retres = (void *)0;
  
#line 2211 
  goto return_label;
  
#line 2213 
  __retres = (void *)0;
  return_label: 
#line 2213 
                return __retres;
}


#line 2218  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_schedule_work(struct work_struct *arg0)
{
  _Bool __retres;
  struct work_struct *ldv_10_work_struct;
  int tmp;
  
#line 2225 
  tmp = ldv_undef_int();
  
#line 2225 
  if (tmp != 0) {
    
#line 2227 
    ldv_10_work_struct = arg0;
    
#line 2231 
    if (ldv_10_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 2233 
      (*(ldv_10_work_struct->func))(ldv_10_work_struct); else ;
    
#line 2238 
    __retres = (_Bool)1;
    
#line 2238 
    goto return_label;
  }
  else {
    
#line 2245 
    __retres = (_Bool)0;
    
#line 2245 
    goto return_label;
  }
  return_label: 
#line 2225 
                return __retres;
}


#line 2255  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_13_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_16 *cf_arg_16;
  int tmp;
  
#line 2258 
  tmp = ldv_undef_int();
  
#line 2258 
  switch (tmp) {
    case 0: 
#line 2259 
    ;
    
#line 2260 
    cf_arg_16 = (struct ldv_struct_interrupt_scenario_16 *)ldv_xmalloc(32UL);
    
#line 2261 
    cf_arg_16->arg0 = arg0;
    
#line 2262 
    cf_arg_16->arg1 = arg1;
    
#line 2263 
    cf_arg_16->arg2 = arg2;
    
#line 2264 
    cf_arg_16->arg3 = arg3;
    
#line 2265 
    ret = pthread_create(& ldv_thread_16,(pthread_attr_t const *)0,& ldv_interrupt_scenario_16,(void *)cf_arg_16);
    
#line 2266 
    __VERIFIER_assume(ret == 0);
    
#line 2267 
    goto ldv_45967;
    default: 
#line 2269 
    ;
    
#line 2269 
    __VERIFIER_assume(0);
  }
  ldv_45967: 
#line 2270 
  ;
  
#line 2271 
  return;
}


#line 2275  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_deregister_11_1(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_15 *cf_arg_15;
  int tmp;
  
#line 2278 
  tmp = ldv_undef_int();
  
#line 2278 
  switch (tmp) {
    case 0: 
#line 2279 
    ;
    
#line 2280 
    ret = pthread_join(ldv_thread_15,(void **)0);
    
#line 2281 
    __VERIFIER_assume(ret == 0);
    
#line 2282 
    goto ldv_45975;
    default: 
#line 2284 
    ;
    
#line 2284 
    __VERIFIER_assume(0);
  }
  ldv_45975: 
#line 2285 
  ;
  
#line 2286 
  return;
}


#line 2290  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 2293 
  ldv_initialize();
  
#line 2296 
  ldv_initialization_1((void *)0);
  
#line 2298 
  __retres = 0;
  
#line 2298 
  return __retres;
}


#line 2303  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_12_3(struct file_operations *arg0)
{
  int ret;
  struct ldv_struct_character_driver_scenario_17 *cf_arg_17;
  struct ldv_struct_character_driver_scenario_17 *cf_arg_19;
  struct ldv_struct_character_driver_scenario_17 *cf_arg_20;
  int tmp;
  
#line 2308 
  tmp = ldv_undef_int();
  
#line 2308 
  switch (tmp) {
    case 0: 
#line 2309 
    ;
    
#line 2310 
    cf_arg_17 = (struct ldv_struct_character_driver_scenario_17 *)ldv_xmalloc(16UL);
    
#line 2311 
    cf_arg_17->arg0 = arg0;
    
#line 2312 
    ret = pthread_create(& ldv_thread_17,(pthread_attr_t const *)0,& ldv_character_driver_scenario_17,(void *)cf_arg_17);
    
#line 2313 
    __VERIFIER_assume(ret == 0);
    
#line 2314 
    goto ldv_45988;
    case 1: 
#line 2316 
    ;
    
#line 2317 
    cf_arg_19 = (struct ldv_struct_character_driver_scenario_17 *)ldv_xmalloc(16UL);
    
#line 2318 
    cf_arg_19->arg0 = arg0;
    
#line 2319 
    ret = pthread_create(& ldv_thread_19,(pthread_attr_t const *)0,& ldv_character_driver_scenario_19,(void *)cf_arg_19);
    
#line 2320 
    __VERIFIER_assume(ret == 0);
    
#line 2321 
    goto ldv_45988;
    case 2: 
#line 2323 
    ;
    
#line 2324 
    cf_arg_20 = (struct ldv_struct_character_driver_scenario_17 *)ldv_xmalloc(16UL);
    
#line 2325 
    cf_arg_20->arg0 = arg0;
    
#line 2326 
    ret = pthread_create(& ldv_thread_20,(pthread_attr_t const *)0,& ldv_character_driver_scenario_20,(void *)cf_arg_20);
    
#line 2327 
    __VERIFIER_assume(ret == 0);
    
#line 2328 
    goto ldv_45988;
    default: 
#line 2330 
    ;
    
#line 2330 
    __VERIFIER_assume(0);
  }
  ldv_45988: 
#line 2331 
  ;
  
#line 2332 
  return;
}


#line 2336  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 2339 
  struct pci_driver *ldv_7_pci_driver = ldv_emg_alias_i40e_driver_2;
  
#line 2342 
  ldv_7_pci_driver = arg0;
  
#line 2346 
  ldv_dispatch_deregister_7_1(ldv_7_pci_driver);
  
#line 2350 
  goto return_label;
  return_label: 
#line 2352 
                return;
}


#line 2357  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_register_3_3(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_15 *cf_arg_15;
  int tmp;
  
#line 2360 
  tmp = ldv_undef_int();
  
#line 2360 
  switch (tmp) {
    case 0: 
#line 2361 
    ;
    
#line 2362 
    cf_arg_15 = (struct ldv_struct_timer_scenario_15 *)ldv_xmalloc(16UL);
    
#line 2363 
    cf_arg_15->arg0 = arg0;
    
#line 2364 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_timer_scenario_15,(void *)cf_arg_15);
    
#line 2365 
    __VERIFIER_assume(ret == 0);
    
#line 2366 
    goto ldv_46002;
    default: 
#line 2368 
    ;
    
#line 2368 
    __VERIFIER_assume(0);
  }
  ldv_46002: 
#line 2369 
  ;
  
#line 2370 
  return;
}


#line 2374  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_6_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_6 *cf_arg_16;
  int tmp;
  
#line 2377 
  tmp = ldv_undef_int();
  
#line 2377 
  switch (tmp) {
    case 0: 
#line 2378 
    ;
    
#line 2379 
    ret = pthread_join(ldv_thread_16,(void **)0);
    
#line 2380 
    __VERIFIER_assume(ret == 0);
    
#line 2381 
    goto ldv_46010;
    default: 
#line 2383 
    ;
    
#line 2383 
    __VERIFIER_assume(0);
  }
  ldv_46010: 
#line 2384 
  ;
  
#line 2385 
  return;
}


#line 2389  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 2396 
  ldv_1_ret = ldv_emg_i40e_init_module();
  
#line 2397 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 2400 
  tmp = ldv_undef_int();
  
#line 2400 
  if (tmp != 0) {
    
#line 2402 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 2406 
    __retres = (void *)0;
    
#line 2406 
    goto return_label;
  }
  else {
    
#line 2410 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 2415 
    ldv_emg_i40e_exit_module();
    
#line 2419 
    __retres = (void *)0;
    
#line 2419 
    goto return_label;
  }
  
#line 2422 
  __retres = (void *)0;
  return_label: 
#line 2422 
                return __retres;
}


#line 2427  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_unregister_netdev(struct net_device *arg0)
{
  struct net_device *ldv_5_netdev;
  
#line 2433 
  ldv_5_netdev = arg0;
  
#line 2438 
  i40e_close(ldv_5_netdev);
  
#line 2442 
  ldv_dispatch_deregister_5_1(ldv_5_netdev);
  
#line 2446 
  goto return_label;
  return_label: 
#line 2448 
                return;
}


#line 2453  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_6_line;
  
#line 2459 
  ldv_6_line = (int)arg0;
  
#line 2463 
  ldv_dispatch_irq_deregister_6_1(ldv_6_line);
  
#line 2467 
  goto return_label;
  return_label: 
#line 2469 
                return;
}


#line 2474  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_register_netdev(struct net_device *arg0)
{
  int __retres;
  struct net_device *ldv_8_netdev;
  int tmp_3;
  
#line 2478 
  int ldv_8_ret = ldv_undef_int();
  
#line 2481 
  ldv_8_ret = ldv_undef_int();
  
#line 2484 
  tmp_3 = ldv_undef_int();
  
#line 2484 
  if (tmp_3 != 0) {
    int tmp_1;
    
#line 2486 
    ldv_8_netdev = arg0;
    
#line 2491 
    ldv_8_ret = i40e_open(ldv_8_netdev);
    
#line 2494 
    tmp_1 = ldv_undef_int();
    
#line 2494 
    if (tmp_1 != 0) {
      
#line 2496 
      __VERIFIER_assume(ldv_8_ret == 0);
      
#line 2500 
      ldv_dispatch_register_8_4(ldv_8_netdev);
      
#line 2504 
      __retres = 0;
      
#line 2504 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 2511 
      __VERIFIER_assume(ldv_8_ret != 0);
      
#line 2512 
      ldv_failed_register_netdev();
      
#line 2513 
      tmp_0 = ldv_undef_int_negative();
      
#line 2513 
      __retres = tmp_0;
      
#line 2513 
      goto return_label;
    }
  }
  else {
    int tmp_2;
    
#line 2521 
    ldv_failed_register_netdev();
    
#line 2522 
    tmp_2 = ldv_undef_int_negative();
    
#line 2522 
    __retres = tmp_2;
    
#line 2522 
    goto return_label;
  }
  return_label: 
#line 2484 
                return __retres;
}


#line 2532  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_netdev(struct net_device *arg0)
{
  struct net_device *ldv_2_netdev;
  
#line 2538 
  ldv_2_netdev = arg0;
  
#line 2539 
  ldv_free((void *)ldv_2_netdev);
  
#line 2543 
  goto return_label;
  return_label: 
#line 2545 
                return;
}


#line 2550  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1)
{
  int __retres;
  struct timer_list *ldv_3_timer_list;
  int tmp_0;
  
#line 2557 
  tmp_0 = ldv_undef_int();
  
#line 2557 
  if (tmp_0 != 0) {
    
#line 2559 
    ldv_3_timer_list = arg0;
    
#line 2563 
    ldv_dispatch_instance_register_3_3(ldv_3_timer_list);
    
#line 2567 
    __retres = 0;
    
#line 2567 
    goto return_label;
  }
  else {
    int tmp;
    
#line 2574 
    tmp = ldv_undef_int_negative();
    
#line 2574 
    __retres = tmp;
    
#line 2574 
    goto return_label;
  }
  return_label: 
#line 2557 
                return __retres;
}


