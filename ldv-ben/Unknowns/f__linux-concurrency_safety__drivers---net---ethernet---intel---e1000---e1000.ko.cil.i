/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_param.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
struct module;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104 
struct pollfd;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/stat.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highuid.h"
struct user_namespace;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct vm_area_struct;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 193 
struct rw_semaphore;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_49 {
   struct __anonstruct_50 __anonCompField___anonunion_49_19 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_49 __anonCompField_ctl_table_header_20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 1281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmzone.h"
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmod.h"
struct cred;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/elf.h"
struct inode;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_147 {
   struct __anonstruct_148 __anonCompField___anonunion_147_33 ;
   struct __anonstruct_149 __anonCompField___anonunion_147_34 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_147 __anonCompField_uprobe_task_35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 133 
struct address_space;

#line 134 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_150 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_152 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_156 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_155 {
   atomic_t _mapcount ;
   struct __anonstruct_156 __anonCompField___anonunion_155_38 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_154 {
   union __anonunion_155 __anonCompField___anonstruct_154_39 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_153 {
   unsigned long counters ;
   struct __anonstruct_154 __anonCompField___anonunion_153_40 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_151 {
   union __anonunion_152 __anonCompField___anonstruct_151_37 ;
   union __anonunion_153 __anonCompField___anonstruct_151_41 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_157 {
   struct list_head lru ;
   struct __anonstruct_158 __anonCompField___anonunion_157_43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_159 __anonCompField___anonunion_157_44 ;
   pgtable_t pmd_huge_pte ;
};

#line 32 
struct kmem_cache;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_150 __anonCompField_page_36 ;
   struct __anonstruct_151 __anonCompField_page_42 ;
   union __anonunion_157 __anonCompField_page_45 ;
   union __anonunion_160 __anonCompField_page_46 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct vm_operations_struct;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
union __anonunion_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_166 __anonCompField_idr_layer_47 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185 
struct dentry;

#line 186 
struct iattr;

#line 187 
struct super_block;

#line 188 
struct file_system_type;

#line 189 
struct kernfs_open_node;

#line 190 
struct kernfs_iattrs;

#line 213 
struct kernfs_root;

#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89 
struct kernfs_ops;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_171 __anonCompField_kernfs_node_48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 477 
struct sock;

#line 478 
struct kobject;

#line 479 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 485  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject_ns.h"
struct bin_attribute;

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject_ns.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct kernel_param;

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_172 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_172 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct tracepoint;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct user_struct;

#line 66 
struct writeback_control;

#line 67 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 1249 
struct kvec;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 67 
struct path;

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dma_map_ops;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_183 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_183 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_186 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_187 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_188 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_190 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_189 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_190 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_191 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_192 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_184 {
   int _pad[28U] ;
   struct __anonstruct__kill_185 _kill ;
   struct __anonstruct__timer_186 _timer ;
   struct __anonstruct__rt_187 _rt ;
   struct __anonstruct__sigchld_188 _sigchld ;
   struct __anonstruct__sigfault_189 _sigfault ;
   struct __anonstruct__sigpoll_191 _sigpoll ;
   struct __anonstruct__sigsys_192 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_184 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct key_type;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_199 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_200 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_202 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_201 {
   struct keyring_index_key index_key ;
   struct __anonstruct_202 __anonCompField___anonunion_201_52 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_203 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_205 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_204 {
   union __anonunion_payload_205 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_199 __anonCompField_key_50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_200 __anonCompField_key_51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_201 __anonCompField_key_53 ;
   union __anonunion_type_data_203 type_data ;
   union __anonunion_204 __anonCompField_key_54 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct pipe_inode_info;

#line 1173 
struct uts_namespace;

#line 1174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct proc_dir_entry;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_220 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_220 __anonCompField_pci_dev_58 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 1189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/prefetch.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_221 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_221 __anonCompField_iov_iter_59 ;
   unsigned long nr_segs ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_223 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_223 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_224 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_224 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_225 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_225 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_226 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_226 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_227 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_227 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_228 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_228 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_229 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_229 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_230 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_230 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_231 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_232 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_231 ifr_ifrn ;
   union __anonunion_ifr_ifru_232 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_237 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_236 {
   struct __anonstruct_237 __anonCompField___anonunion_236_60 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_236 __anonCompField_lockref_61 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_239 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_238 {
   struct __anonstruct_239 __anonCompField___anonunion_238_62 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_238 __anonCompField_qstr_63 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_240 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_240 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_244 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_243 {
   struct __anonstruct_244 __anonCompField___anonunion_243_64 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_243 __anonCompField_radix_tree_node_65 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 62 
struct poll_table_struct;

#line 63 
struct kstatfs;

#line 64 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_248 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_248 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_249 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_249 __anonCompField_kqid_67 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_252 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_253 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_254 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_252 __anonCompField_inode_68 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_253 __anonCompField_inode_69 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_254 __anonCompField_inode_70 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_255 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_255 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 947 
struct net;

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19 
struct fasync_struct;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_257 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_256 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_257 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_256 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/random.h"
enum ldv_25482 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_25482 socket_state;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_272 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_272 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_26328 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_277 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_278 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_26328 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_277 __anonCompField_nf_bridge_info_74 ;
   union __anonunion_278 __anonCompField_nf_bridge_info_75 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_281 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_280 {
   u64 v64 ;
   struct __anonstruct_281 __anonCompField___anonunion_280_76 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_280 __anonCompField_skb_mstamp_77 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_284 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_283 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_284 __anonCompField___anonstruct_283_78 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_282 {
   struct __anonstruct_283 __anonCompField___anonunion_282_79 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_286 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_285 {
   __wsum csum ;
   struct __anonstruct_286 __anonCompField___anonunion_285_81 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_287 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_288 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_289 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_282 __anonCompField_sk_buff_80 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_285 __anonCompField_sk_buff_82 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_287 __anonCompField_sk_buff_83 ;
   __u32 secmark ;
   union __anonunion_288 __anonCompField_sk_buff_84 ;
   union __anonunion_289 __anonCompField_sk_buff_85 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_306 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_306 possible_net_t;

#line 376 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 383  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef int phy_interface_t;

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   int state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct xfrm_policy;

#line 98 
struct xfrm_state;

#line 114 
struct request_sock;

#line 1628 
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_30852 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_30853 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_317 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_318 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_316 adj_list ;
   struct __anonstruct_all_adj_list_317 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_30852 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_30853 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_318 __anonCompField_net_device_95 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   struct ipv6_stable_secret stable_secret ;
   void *sysctl ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/icmpv6.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};

#line 580  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/memcontrol.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) dst_reg : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
};

#line 273 
struct bpf_prog_aux;

#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
union __anonunion_334 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff const *, struct bpf_insn const *) ;
   union __anonunion_334 __anonCompField_bpf_prog_100 ;
};

#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/rtnetlink.h"
struct tcmsg {
   unsigned char tcm_family ;
   unsigned char tcm__pad1 ;
   unsigned short tcm__pad2 ;
   int tcm_ifindex ;
   __u32 tcm_handle ;
   __u32 tcm_parent ;
   __u32 tcm_info ;
};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   int maxtype ;
   struct nla_policy const *policy ;
   int (*validate)(struct nlattr **, struct nlattr **) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device const *) ;
   int (*fill_info)(struct sk_buff *, struct net_device const *) ;
   size_t (*get_xstats_size)(struct net_device const *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device const *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy const *slave_policy ;
   int (*slave_validate)(struct nlattr **, struct nlattr **) ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **) ;
   size_t (*get_slave_size)(struct net_device const *, struct net_device const *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device const *, struct net_device const *) ;
   struct net *(*get_link_net)(struct net_device const *) ;
};

#line 171 
struct neigh_table;

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   void (*neigh_cleanup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};

#line 129 
struct neigh_ops;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops const *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const *, struct net_device const *, __u32 *) ;
   bool (*key_eq)(struct neighbour const *, void const *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};

#line 519 
struct dn_route;

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
union __anonunion_345 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};

#line 519  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion_345 __anonCompField_dst_entry_101 ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_socket_lock_t_346 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_346 socket_lock_t;

#line 124 
struct proto;

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u32 __portpair;

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
typedef __u64 __addrpair;

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_348 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_347 {
   __addrpair skc_addrpair ;
   struct __anonstruct_348 __anonCompField___anonunion_347_102 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_349 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_351 {
   __be16 skc_dport ;
   __u16 skc_num ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_350 {
   __portpair skc_portpair ;
   struct __anonstruct_351 __anonCompField___anonunion_350_105 ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_352 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_353 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock_common {
   union __anonunion_347 __anonCompField_sock_common_103 ;
   union __anonunion_349 __anonCompField_sock_common_104 ;
   union __anonunion_350 __anonCompField_sock_common_106 ;
   unsigned short skc_family ;
   unsigned char volatile skc_state ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) skc_reuse : 4 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_reuseport : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_ipv6only : 1 ;
   unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_352 __anonCompField_sock_common_107 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_353 __anonCompField_sock_common_108 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};

#line 219 
struct cg_proto;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct __anonstruct_sk_backlog_354 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_354 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) sk_shutdown : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_tx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sk_no_check_rx : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) sk_userlocks : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) sk_protocol : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred const *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
};

#line 914 
struct request_sock_ops;

#line 915 
struct timewait_sock_ops;

#line 916 
struct inet_hashinfo;

#line 917 
struct raw_hashinfo;

#line 932 
struct udp_table;

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
union __anonunion_h_357 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};

#line 932  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   void (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   void (*clear_sk)(struct sock *, int ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock const *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_357 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup *, struct cgroup_subsys *) ;
   void (*destroy_cgroup)(struct mem_cgroup *) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup *) ;
};

#line 1054  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock const *) ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cookie_ts : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops const *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};

#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};

#line 646  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
struct tc_stats {
   __u64 bytes ;
   __u32 packets ;
   __u32 drops ;
   __u32 overlimits ;
   __u32 bps ;
   __u32 pps ;
   __u32 qlen ;
   __u32 backlog ;
};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/pkt_sched.h"
struct tc_sizespec {
   unsigned char cell_log ;
   unsigned char size_log ;
   short cell_align ;
   int overhead ;
   unsigned int linklayer ;
   unsigned int mpu ;
   unsigned int mtu ;
   unsigned int tsize ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/gen_stats.h"
struct gnet_stats_basic_packed {
   __u64 bytes ;
   __u32 packets ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/gen_stats.h"
struct gnet_stats_rate_est64 {
   __u64 bps ;
   __u64 pps ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/gen_stats.h"
struct gnet_stats_queue {
   __u32 qlen ;
   __u32 backlog ;
   __u32 drops ;
   __u32 requeues ;
   __u32 overlimits ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/gen_stats.h"
struct gnet_stats_basic_cpu {
   struct gnet_stats_basic_packed bstats ;
   struct u64_stats_sync syncp ;
};

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/gen_stats.h"
struct gnet_dump {
   spinlock_t *lock ;
   struct sk_buff *skb ;
   struct nlattr *tail ;
   int compat_tc_stats ;
   int compat_xstats ;
   void *xstats ;
   int xstats_len ;
   struct tc_stats tc_stats ;
};

#line 61 
struct Qdisc_ops;

#line 62 
struct qdisc_walker;

#line 63 
struct tcf_walker;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sch_generic.h"
struct qdisc_size_table {
   struct callback_head rcu ;
   struct list_head list ;
   struct tc_sizespec szopts ;
   int refcnt ;
   u16 data[] ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sch_generic.h"
struct Qdisc {
   int (*enqueue)(struct sk_buff *, struct Qdisc *) ;
   struct sk_buff *(*dequeue)(struct Qdisc *) ;
   unsigned int flags ;
   u32 limit ;
   struct Qdisc_ops const *ops ;
   struct qdisc_size_table *stab ;
   struct list_head list ;
   u32 handle ;
   u32 parent ;
   int (*reshape_fail)(struct sk_buff *, struct Qdisc *) ;
   void *u32_node ;
   struct Qdisc *__parent ;
   struct netdev_queue *dev_queue ;
   struct gnet_stats_rate_est64 rate_est ;
   struct gnet_stats_basic_cpu *cpu_bstats ;
   struct gnet_stats_queue *cpu_qstats ;
   struct Qdisc *next_sched ;
   struct sk_buff *gso_skb ;
   unsigned long state ;
   struct sk_buff_head q ;
   struct gnet_stats_basic_packed bstats ;
   unsigned int __state ;
   struct gnet_stats_queue qstats ;
   struct callback_head callback_head ;
   int padded ;
   atomic_t refcnt ;
   spinlock_t busylock ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sch_generic.h"
struct Qdisc_class_ops {
   struct netdev_queue *(*select_queue)(struct Qdisc *, struct tcmsg *) ;
   int (*graft)(struct Qdisc *, unsigned long , struct Qdisc *, struct Qdisc **) ;
   struct Qdisc *(*leaf)(struct Qdisc *, unsigned long ) ;
   void (*qlen_notify)(struct Qdisc *, unsigned long ) ;
   unsigned long (*get)(struct Qdisc *, u32 ) ;
   void (*put)(struct Qdisc *, unsigned long ) ;
   int (*change)(struct Qdisc *, u32 , u32 , struct nlattr **, unsigned long *) ;
   int (*delete)(struct Qdisc *, unsigned long ) ;
   void (*walk)(struct Qdisc *, struct qdisc_walker *) ;
   struct tcf_proto **(*tcf_chain)(struct Qdisc *, unsigned long ) ;
   unsigned long (*bind_tcf)(struct Qdisc *, unsigned long , u32 ) ;
   void (*unbind_tcf)(struct Qdisc *, unsigned long ) ;
   int (*dump)(struct Qdisc *, unsigned long , struct sk_buff *, struct tcmsg *) ;
   int (*dump_stats)(struct Qdisc *, unsigned long , struct gnet_dump *) ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sch_generic.h"
struct Qdisc_ops {
   struct Qdisc_ops *next ;
   struct Qdisc_class_ops const *cl_ops ;
   char id[16U] ;
   int priv_size ;
   int (*enqueue)(struct sk_buff *, struct Qdisc *) ;
   struct sk_buff *(*dequeue)(struct Qdisc *) ;
   struct sk_buff *(*peek)(struct Qdisc *) ;
   unsigned int (*drop)(struct Qdisc *) ;
   int (*init)(struct Qdisc *, struct nlattr *) ;
   void (*reset)(struct Qdisc *) ;
   void (*destroy)(struct Qdisc *) ;
   int (*change)(struct Qdisc *, struct nlattr *) ;
   void (*attach)(struct Qdisc *) ;
   int (*dump)(struct Qdisc *, struct sk_buff *) ;
   int (*dump_stats)(struct Qdisc *, struct gnet_dump *) ;
   struct module *owner ;
};

#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sch_generic.h"
struct tcf_result {
   unsigned long class ;
   u32 classid ;
};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sch_generic.h"
struct tcf_proto_ops {
   struct list_head head ;
   char kind[16U] ;
   int (*classify)(struct sk_buff *, struct tcf_proto const *, struct tcf_result *) ;
   int (*init)(struct tcf_proto *) ;
   bool (*destroy)(struct tcf_proto *, bool ) ;
   unsigned long (*get)(struct tcf_proto *, u32 ) ;
   int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, unsigned long , u32 , struct nlattr **, unsigned long *, bool ) ;
   int (*delete)(struct tcf_proto *, unsigned long ) ;
   void (*walk)(struct tcf_proto *, struct tcf_walker *) ;
   int (*dump)(struct net *, struct tcf_proto *, unsigned long , struct sk_buff *, struct tcmsg *) ;
   struct module *owner ;
};

#line 232  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sch_generic.h"
struct tcf_proto {
   struct tcf_proto *next ;
   void *root ;
   int (*classify)(struct sk_buff *, struct tcf_proto const *, struct tcf_result *) ;
   __be16 protocol ;
   u32 prio ;
   u32 classid ;
   struct Qdisc *q ;
   void *data ;
   struct tcf_proto_ops const *ops ;
   struct callback_head rcu ;
};

#line 779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/sch_generic.h"
struct qdisc_walker {
   int stop ;
   int skip ;
   int count ;
   int (*fn)(struct Qdisc *, unsigned long , struct qdisc_walker *) ;
};

#line 5  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/emergency-restart.h"
struct e1000_adapter;

#line 6 
struct e1000_hw;

#line 7 
struct e1000_hw_stats;

#line 8 
enum ldv_36240 {
    e1000_undefined = 0,
    e1000_82542_rev2_0 = 1,
    e1000_82542_rev2_1 = 2,
    e1000_82543 = 3,
    e1000_82544 = 4,
    e1000_82540 = 5,
    e1000_82545 = 6,
    e1000_82545_rev_3 = 7,
    e1000_82546 = 8,
    e1000_ce4100 = 9,
    e1000_82546_rev_3 = 10,
    e1000_82541 = 11,
    e1000_82541_rev_2 = 12,
    e1000_82547 = 13,
    e1000_82547_rev_2 = 14,
    e1000_num_macs = 15
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef enum ldv_36240 e1000_mac_type;

#line 63 
enum ldv_36242 {
    e1000_eeprom_uninitialized = 0,
    e1000_eeprom_spi = 1,
    e1000_eeprom_microwire = 2,
    e1000_eeprom_flash = 3,
    e1000_eeprom_none = 4,
    e1000_num_eeprom_types = 5
};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef enum ldv_36242 e1000_eeprom_type;

#line 72 
enum ldv_36244 {
    e1000_media_type_copper = 0,
    e1000_media_type_fiber = 1,
    e1000_media_type_internal_serdes = 2,
    e1000_num_media_types = 3
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef enum ldv_36244 e1000_media_type;

#line 87 
enum ldv_36248 {
    E1000_FC_NONE = 0,
    E1000_FC_RX_PAUSE = 1,
    E1000_FC_TX_PAUSE = 2,
    E1000_FC_FULL = 3,
    E1000_FC_DEFAULT = 255
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef enum ldv_36248 e1000_fc_type;

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_shadow_ram {
   u16 eeprom_word ;
   bool modified ;
};

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_bus_type;

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_bus_speed;

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_bus_width;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_cable_length;

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_10bt_ext_dist_enable;

#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_rev_polarity;

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_downshift;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_smart_speed;

#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_polarity_reversal;

#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_auto_x_mode;

#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_1000t_rx_status;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_phy_type;

#line 225  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_ms_type;

#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_ffe_config;

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
typedef int e1000_dsp_config;

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_phy_info {
   e1000_cable_length cable_length ;
   e1000_10bt_ext_dist_enable extended_10bt_distance ;
   e1000_rev_polarity cable_polarity ;
   e1000_downshift downshift ;
   e1000_polarity_reversal polarity_correction ;
   e1000_auto_x_mode mdix_mode ;
   e1000_1000t_rx_status local_rx ;
   e1000_1000t_rx_status remote_rx ;
};

#line 250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_phy_stats {
   u32 idle_errors ;
   u32 receive_errors ;
};

#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_eeprom_info {
   e1000_eeprom_type type ;
   u16 word_size ;
   u16 opcode_bits ;
   u16 address_bits ;
   u16 delay_usec ;
   u16 page_size ;
};

#line 347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_host_mng_dhcp_cookie {
   u32 signature ;
   u8 status ;
   u8 reserved0 ;
   u16 vlan_id ;
   u32 reserved1 ;
   u16 reserved2 ;
   u8 reserved3 ;
   u8 checksum ;
};

#line 779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_hw_stats {
   u64 crcerrs ;
   u64 algnerrc ;
   u64 symerrs ;
   u64 rxerrc ;
   u64 txerrc ;
   u64 mpc ;
   u64 scc ;
   u64 ecol ;
   u64 mcc ;
   u64 latecol ;
   u64 colc ;
   u64 dc ;
   u64 tncrs ;
   u64 sec ;
   u64 cexterr ;
   u64 rlec ;
   u64 xonrxc ;
   u64 xontxc ;
   u64 xoffrxc ;
   u64 xofftxc ;
   u64 fcruc ;
   u64 prc64 ;
   u64 prc127 ;
   u64 prc255 ;
   u64 prc511 ;
   u64 prc1023 ;
   u64 prc1522 ;
   u64 gprc ;
   u64 bprc ;
   u64 mprc ;
   u64 gptc ;
   u64 gorcl ;
   u64 gorch ;
   u64 gotcl ;
   u64 gotch ;
   u64 rnbc ;
   u64 ruc ;
   u64 rfc ;
   u64 roc ;
   u64 rlerrc ;
   u64 rjc ;
   u64 mgprc ;
   u64 mgpdc ;
   u64 mgptc ;
   u64 torl ;
   u64 torh ;
   u64 totl ;
   u64 toth ;
   u64 tpr ;
   u64 tpt ;
   u64 ptc64 ;
   u64 ptc127 ;
   u64 ptc255 ;
   u64 ptc511 ;
   u64 ptc1023 ;
   u64 ptc1522 ;
   u64 mptc ;
   u64 bptc ;
   u64 tsctc ;
   u64 tsctfc ;
   u64 iac ;
   u64 icrxptc ;
   u64 icrxatc ;
   u64 ictxptc ;
   u64 ictxatc ;
   u64 ictxqec ;
   u64 ictxqmtc ;
   u64 icrxdmtc ;
   u64 icrxoc ;
};

#line 1348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_hw {
   u8 *hw_addr ;
   u8 *flash_address ;
   void *ce4100_gbe_mdio_base_virt ;
   e1000_mac_type mac_type ;
   e1000_phy_type phy_type ;
   u32 phy_init_script ;
   e1000_media_type media_type ;
   void *back ;
   struct e1000_shadow_ram *eeprom_shadow_ram ;
   u32 flash_bank_size ;
   u32 flash_base_addr ;
   e1000_fc_type fc ;
   e1000_bus_speed bus_speed ;
   e1000_bus_width bus_width ;
   e1000_bus_type bus_type ;
   struct e1000_eeprom_info eeprom ;
   e1000_ms_type master_slave ;
   e1000_ms_type original_master_slave ;
   e1000_ffe_config ffe_config_state ;
   u32 asf_firmware_present ;
   u32 eeprom_semaphore_present ;
   unsigned long io_base ;
   u32 phy_id ;
   u32 phy_revision ;
   u32 phy_addr ;
   u32 original_fc ;
   u32 txcw ;
   u32 autoneg_failed ;
   u32 max_frame_size ;
   u32 min_frame_size ;
   u32 mc_filter_type ;
   u32 num_mc_addrs ;
   u32 collision_delta ;
   u32 tx_packet_delta ;
   u32 ledctl_default ;
   u32 ledctl_mode1 ;
   u32 ledctl_mode2 ;
   bool tx_pkt_filtering ;
   struct e1000_host_mng_dhcp_cookie mng_cookie ;
   u16 phy_spd_default ;
   u16 autoneg_advertised ;
   u16 pci_cmd_word ;
   u16 fc_high_water ;
   u16 fc_low_water ;
   u16 fc_pause_time ;
   u16 current_ifs_val ;
   u16 ifs_min_val ;
   u16 ifs_max_val ;
   u16 ifs_step_size ;
   u16 ifs_ratio ;
   u16 device_id ;
   u16 vendor_id ;
   u16 subsystem_id ;
   u16 subsystem_vendor_id ;
   u8 revision_id ;
   u8 autoneg ;
   u8 mdix ;
   u8 forced_speed_duplex ;
   u8 wait_autoneg_complete ;
   u8 dma_fairness ;
   u8 mac_addr[6U] ;
   u8 perm_mac_addr[6U] ;
   bool disable_polarity_correction ;
   bool speed_downgraded ;
   e1000_smart_speed smart_speed ;
   e1000_dsp_config dsp_config_state ;
   bool get_link_status ;
   bool serdes_has_link ;
   bool tbi_compatibility_en ;
   bool tbi_compatibility_on ;
   bool laa_is_present ;
   bool phy_reset_disable ;
   bool initialize_hw_bits_disable ;
   bool fc_send_xon ;
   bool fc_strict_ieee ;
   bool report_tx_early ;
   bool adaptive_ifs ;
   bool ifs_params_forced ;
   bool in_ifs_mode ;
   bool mng_reg_access_disabled ;
   bool leave_av_bit_off ;
   bool bad_tx_carr_stats_fd ;
   bool has_smbus ;
};

#line 2141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_tx_buffer {
   struct sk_buff *skb ;
   dma_addr_t dma ;
   unsigned long time_stamp ;
   u16 length ;
   u16 next_to_watch ;
   bool mapped_as_page ;
   unsigned short segs ;
   unsigned int bytecount ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000.h"
union __anonunion_rxbuf_414 {
   struct page *page ;
   u8 *data ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000.h"
struct e1000_rx_buffer {
   union __anonunion_rxbuf_414 rxbuf ;
   dma_addr_t dma ;
};

#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000.h"
struct e1000_tx_ring {
   void *desc ;
   dma_addr_t dma ;
   unsigned int size ;
   unsigned int count ;
   unsigned int next_to_use ;
   unsigned int next_to_clean ;
   struct e1000_tx_buffer *buffer_info ;
   u16 tdh ;
   u16 tdt ;
   bool last_tx_tso ;
};

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000.h"
struct e1000_rx_ring {
   void *desc ;
   dma_addr_t dma ;
   unsigned int size ;
   unsigned int count ;
   unsigned int next_to_use ;
   unsigned int next_to_clean ;
   struct e1000_rx_buffer *buffer_info ;
   struct sk_buff *rx_skb_top ;
   int cpu ;
   u16 rdh ;
   u16 rdt ;
};

#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000.h"
struct e1000_adapter {
   unsigned long active_vlans[64U] ;
   u16 mng_vlan_id ;
   u32 bd_number ;
   u32 rx_buffer_len ;
   u32 wol ;
   u32 smartspeed ;
   u32 en_mng_pt ;
   u16 link_speed ;
   u16 link_duplex ;
   spinlock_t stats_lock ;
   unsigned int total_tx_bytes ;
   unsigned int total_tx_packets ;
   unsigned int total_rx_bytes ;
   unsigned int total_rx_packets ;
   u32 itr ;
   u32 itr_setting ;
   u16 tx_itr ;
   u16 rx_itr ;
   u8 fc_autoneg ;
   struct e1000_tx_ring *tx_ring ;
   unsigned int restart_queue ;
   u32 txd_cmd ;
   u32 tx_int_delay ;
   u32 tx_abs_int_delay ;
   u32 gotcl ;
   u64 gotcl_old ;
   u64 tpt_old ;
   u64 colc_old ;
   u32 tx_timeout_count ;
   u32 tx_fifo_head ;
   u32 tx_head_addr ;
   u32 tx_fifo_size ;
   u8 tx_timeout_factor ;
   atomic_t tx_fifo_stall ;
   bool pcix_82544 ;
   bool detect_tx_hung ;
   bool dump_buffers ;
   bool (*clean_rx)(struct e1000_adapter *, struct e1000_rx_ring *, int *, int ) ;
   void (*alloc_rx_buf)(struct e1000_adapter *, struct e1000_rx_ring *, int ) ;
   struct e1000_rx_ring *rx_ring ;
   struct napi_struct napi ;
   int num_tx_queues ;
   int num_rx_queues ;
   u64 hw_csum_err ;
   u64 hw_csum_good ;
   u32 alloc_rx_buff_failed ;
   u32 rx_int_delay ;
   u32 rx_abs_int_delay ;
   bool rx_csum ;
   u32 gorcl ;
   u64 gorcl_old ;
   struct net_device *netdev ;
   struct pci_dev *pdev ;
   struct e1000_hw hw ;
   struct e1000_hw_stats stats ;
   struct e1000_phy_info phy_info ;
   struct e1000_phy_stats phy_stats ;
   u32 test_icr ;
   struct e1000_tx_ring test_tx_ring ;
   struct e1000_rx_ring test_rx_ring ;
   int msg_enable ;
   bool tso_force ;
   bool smart_power_down ;
   bool quad_port_a ;
   unsigned long flags ;
   u32 eeprom_wol ;
   int bars ;
   int need_ioport ;
   bool discarding ;
   struct work_struct reset_task ;
   struct delayed_work watchdog_task ;
   struct delayed_work fifo_stall_task ;
   struct delayed_work phy_info_task ;
};

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
enum ldv_37095 {
    enable_option = 0,
    range_option = 1,
    list_option = 2
};

#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
struct e1000_opt_list {
   int i ;
   char *str ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
struct __anonstruct_r_416 {
   int min ;
   int max ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
struct __anonstruct_l_417 {
   int nr ;
   struct e1000_opt_list const *p ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
union __anonunion_arg_415 {
   struct __anonstruct_r_416 r ;
   struct __anonstruct_l_417 l ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
struct e1000_option {
   enum ldv_37095 type ;
   char const *name ;
   char const *err ;
   int def ;
   union __anonunion_arg_415 arg ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __le16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u64 __le64;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __sum16;

#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct _ddebug {
   char const *modname ;
   char const *function ;
   char const *filename ;
   char const *format ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))) lineno : 18 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) flags : 8 ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
typedef int pao_T__;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11774 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct;

#line 215  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_page_700 {
   struct page *p ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_700 page ;
   __u32 page_offset ;
   __u32 size ;
};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};

#line 319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/xfrm.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 1084  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct mii_ioctl_data {
   __u16 phy_id ;
   __u16 reg_num ;
   __u16 val_in ;
   __u16 val_out ;
};

#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};

#line 331 
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;

#line 2893 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};

#line 678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pagemap.h"
struct iphdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) ihl : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) priority : 4 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) res1 : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) doff : 4 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) fin : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syn : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) rst : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) psh : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ack : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) urg : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ece : 1 ;
   __u16 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_rx_desc {
   __le64 buffer_addr ;
   __le16 length ;
   __le16 csum ;
   u8 status ;
   u8 errors ;
   __le16 special ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct __anonstruct_flags_822 {
   __le16 length ;
   u8 cso ;
   u8 cmd ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
union __anonunion_lower_821 {
   __le32 data ;
   struct __anonstruct_flags_822 flags ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct __anonstruct_fields_824 {
   u8 status ;
   u8 css ;
   __le16 special ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
union __anonunion_upper_823 {
   __le32 data ;
   struct __anonstruct_fields_824 fields ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_tx_desc {
   __le64 buffer_addr ;
   union __anonunion_lower_821 lower ;
   union __anonunion_upper_823 upper ;
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct __anonstruct_ip_fields_826 {
   u8 ipcss ;
   u8 ipcso ;
   __le16 ipcse ;
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
union __anonunion_lower_setup_825 {
   __le32 ip_config ;
   struct __anonstruct_ip_fields_826 ip_fields ;
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct __anonstruct_tcp_fields_828 {
   u8 tucss ;
   u8 tucso ;
   __le16 tucse ;
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
union __anonunion_upper_setup_827 {
   __le32 tcp_config ;
   struct __anonstruct_tcp_fields_828 tcp_fields ;
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct __anonstruct_fields_830 {
   u8 status ;
   u8 hdr_len ;
   __le16 mss ;
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
union __anonunion_tcp_seg_setup_829 {
   __le32 data ;
   struct __anonstruct_fields_830 fields ;
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
struct e1000_context_desc {
   union __anonunion_lower_setup_825 lower_setup ;
   union __anonunion_upper_setup_827 upper_setup ;
   __le32 cmd_and_length ;
   union __anonunion_tcp_seg_setup_829 tcp_seg_setup ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   __u8 addr_gen_mode ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
union __anonunion_837 {
   __be32 a4 ;
   __be32 a6[4U] ;
   struct in6_addr in6 ;
};

#line 971  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion_837 __anonCompField_inetpeer_addr_base_111 ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_838 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct __anonstruct_840 {
   atomic_t rid ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
union __anonunion_839 {
   struct __anonstruct_840 __anonCompField___anonunion_839_113 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[16U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion_838 __anonCompField_inet_peer_112 ;
   union __anonunion_839 __anonCompField_inet_peer_114 ;
   __u32 dtime ;
   atomic_t refcnt ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   int total ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct uncached_list;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};

#line 3401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
struct my_u {
   __le64 a ;
   __le64 b ;
};

#line 3443  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
struct my_u_0 {
   __le64 a ;
   __le64 b ;
};

#line 378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000.h"
struct e1000_stats {
   char stat_string[32U] ;
   int type ;
   int sizeof_stat ;
   int stat_offset ;
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct ldv_struct_free_irq_4 {
   int arg0 ;
   int signal_pending ;
};

#line 18  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_14 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_12 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 31  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_random_allocationless_scenario_13 {
   struct net_device *arg0 ;
   int signal_pending ;
};
void __builtin_unreachable(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/fvtp/.tmp_e1000_param.c"
void ldv_inline_asm(void);


#line 1085  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
void dev_warn(struct device const *, char const * , ...);


#line 1089 
void _dev_info(struct device const *, char const * , ...);


#line 311  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
s32 e1000_validate_mdi_setting(struct e1000_hw *hw);


#line 371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000.h"
void e1000_check_options(struct e1000_adapter *adapter);


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int TxDescriptors[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_TxDescriptors;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int RxDescriptors[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_RxDescriptors;

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int Speed[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_Speed;

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int Duplex[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 92  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_Duplex;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int AutoNeg[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_AutoNeg;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int FlowControl[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_FlowControl;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int XsumRX[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_XsumRX;

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int TxIntDelay[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_TxIntDelay;

#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int TxAbsIntDelay[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_TxAbsIntDelay;

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int RxIntDelay[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_RxIntDelay;

#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int RxAbsIntDelay[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_RxAbsIntDelay;

#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int InterruptThrottleRate[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_InterruptThrottleRate;

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int SmartPowerDownEnable[33U] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static unsigned int num_SmartPowerDownEnable;

#line 208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static int e1000_validate_option(unsigned int *value, struct e1000_option const *opt, struct e1000_adapter *adapter)
{
  int __retres;
  
#line 212 
  if (*value == 4294967295U) {
    
#line 213 
    *value = (unsigned int)opt->def;
    
#line 214 
    __retres = 0;
    
#line 214 
    goto return_label;
  }
  else ;
  
#line 217 
  switch ((unsigned int)opt->type) {
    case (unsigned int)0: 
#line 218 
    ;
    
#line 219 
    switch (*value) {
      case (unsigned int)1: 
#line 220 
      ;
      
#line 221 
      _dev_info((struct device const *)(& (adapter->pdev)->dev),"%s Enabled\n",opt->name);
      
#line 222 
      __retres = 0;
      
#line 222 
      goto return_label;
      case (unsigned int)0: 
#line 223 
      ;
      
#line 224 
      _dev_info((struct device const *)(& (adapter->pdev)->dev),"%s Disabled\n",opt->name);
      
#line 225 
      __retres = 0;
      
#line 225 
      goto return_label;
    }
    
#line 227 
    goto ldv_54841;
    case (unsigned int)1: 
#line 228 
    ;
    
#line 229 
    if (*value >= (unsigned int)opt->arg.r.min && *value <= (unsigned int)opt->arg.r.max) {
      
#line 230 
      _dev_info((struct device const *)(& (adapter->pdev)->dev),"%s set to %i\n",opt->name,*value);
      
#line 231 
      __retres = 0;
      
#line 231 
      goto return_label;
    }
    else ;
    
#line 233 
    goto ldv_54841;
    case (unsigned int)2: 
#line 234 
    ;
    {
      int i;
      struct e1000_opt_list const *ent;
      
#line 238 
      i = 0;
      
#line 238 
      goto ldv_54847;
      ldv_54846: 
#line 239 
      ;
      
#line 239 
      ent = opt->arg.l.p + i;
      
#line 240 
      if (*value == (unsigned int)ent->i) {
        
#line 241 
        if ((int)*(ent->str) != 0) 
#line 242 
                                   _dev_info((struct device const *)(& (adapter->pdev)->dev),"%s\n",ent->str); else ;
        
#line 243 
        __retres = 0;
        
#line 243 
        goto return_label;
      }
      else ;
      
#line 238 
      i += 1;
      ldv_54847: 
#line 239 
      ;
      
#line 238 
      if (opt->arg.l.nr > i) 
#line 240 
                             goto ldv_54846; else 
#line 243 
                                                  goto ldv_54848;
      ldv_54848: 
#line 244 
      ;
    }
    
#line 247 
    goto ldv_54841;
    default: 
#line 248 
    ;
    
#line 249 
    ldv_inline_asm();
    
#line 249 
    ;
  }
  ldv_54841: 
#line 252 
  ;
  
#line 252 
  _dev_info((struct device const *)(& (adapter->pdev)->dev),"Invalid %s value specified (%i) %s\n",opt->name,*value,opt->err);
  
#line 254 
  *value = (unsigned int)opt->def;
  
#line 255 
  __retres = -1;
  return_label: 
#line 255 
                return __retres;
}


#line 258 
static void e1000_check_fiber_options(struct e1000_adapter *adapter);


#line 259 
static void e1000_check_copper_options(struct e1000_adapter *adapter);


#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
void e1000_check_options(struct e1000_adapter *adapter)
{
  struct e1000_option opt;
  
#line 273 
  int bd = (int)adapter->bd_number;
  
#line 275 
  if (bd > 31) 
#line 276 
               dev_warn((struct device const *)(& (adapter->pdev)->dev),"Warning: no configuration for board #%i ",bd); else ;
  {
    int i;
    int tmp;
    
#line 281 
    struct e1000_tx_ring *tx_ring = adapter->tx_ring;
    
#line 283 
    e1000_mac_type mac_type = adapter->hw.mac_type;
    
#line 289 
    if (mac_type <= (unsigned int)e1000_82543) 
#line 289 
                                               tmp = 256; else 
#line 289 
                                                               tmp = 4096;
    
#line 285 
    struct e1000_option __constr_expr_37 = {.type = range_option, .name = "Transmit Descriptors", .err = "using default of ", .def = 256, .arg = {.r = {.min = 48, .max = tmp}}};
    
#line 285 
    opt = __constr_expr_37;
    
#line 297 
    if (num_TxDescriptors > (unsigned int)bd) {
      
#line 298 
      tx_ring->count = (unsigned int)TxDescriptors[bd];
      
#line 299 
      e1000_validate_option(& tx_ring->count,(struct e1000_option const *)(& opt),adapter);
      
#line 300 
      tx_ring->count = (tx_ring->count + 7U) & 4294967288U;
    }
    else 
#line 303 
         tx_ring->count = (unsigned int)opt.def;
    
#line 305 
    i = 0;
    
#line 305 
    goto ldv_54864;
    ldv_54863: 
#line 306 
    ;
    
#line 306 
    (tx_ring + i)->count = tx_ring->count;
    
#line 305 
    i += 1;
    ldv_54864: 
#line 306 
    ;
    
#line 305 
    if (adapter->num_tx_queues > i) 
#line 307 
                                    goto ldv_54863; else 
#line 310 
                                                         goto ldv_54865;
    ldv_54865: 
#line 311 
    ;
  }
  {
    int i_0;
    int tmp_0;
    
#line 309 
    struct e1000_rx_ring *rx_ring = adapter->rx_ring;
    
#line 311 
    e1000_mac_type mac_type_0 = adapter->hw.mac_type;
    
#line 317 
    if (mac_type_0 <= (unsigned int)e1000_82543) 
#line 317 
                                                 tmp_0 = 256; else 
#line 317 
                                                                   tmp_0 = 4096;
    
#line 313 
    struct e1000_option __constr_expr_38 = {.type = range_option, .name = "Receive Descriptors", .err = "using default of ", .def = 256, .arg = {.r = {.min = 48, .max = tmp_0}}};
    
#line 313 
    opt = __constr_expr_38;
    
#line 326 
    if (num_RxDescriptors > (unsigned int)bd) {
      
#line 327 
      rx_ring->count = (unsigned int)RxDescriptors[bd];
      
#line 328 
      e1000_validate_option(& rx_ring->count,(struct e1000_option const *)(& opt),adapter);
      
#line 329 
      rx_ring->count = (rx_ring->count + 7U) & 4294967288U;
    }
    else 
#line 332 
         rx_ring->count = (unsigned int)opt.def;
    
#line 334 
    i_0 = 0;
    
#line 334 
    goto ldv_54871;
    ldv_54870: 
#line 335 
    ;
    
#line 335 
    (rx_ring + i_0)->count = rx_ring->count;
    
#line 334 
    i_0 += 1;
    ldv_54871: 
#line 335 
    ;
    
#line 334 
    if (adapter->num_rx_queues > i_0) 
#line 336 
                                      goto ldv_54870; else 
#line 339 
                                                           goto ldv_54872;
    ldv_54872: 
#line 340 
    ;
  }
  
#line 338 
  struct e1000_option __constr_expr_39 = {.type = enable_option, .name = "Checksum Offload", .err = "defaulting to Enabled", .def = 1, .arg = {.r = {.min = 0, .max = 0}}};
  
#line 338 
  opt = __constr_expr_39;
  
#line 345 
  if (num_XsumRX > (unsigned int)bd) {
    
#line 346 
    unsigned int rx_csum = (unsigned int)XsumRX[bd];
    
#line 347 
    e1000_validate_option(& rx_csum,(struct e1000_option const *)(& opt),adapter);
    
#line 348 
    adapter->rx_csum = (_Bool)(rx_csum != 0U);
  }
  else 
#line 350 
       adapter->rx_csum = (_Bool)(opt.def != 0);
  {
    
#line 355 
    struct e1000_opt_list const fc_list[5U] = {{.i = 0, .str = (char *)"Flow Control Disabled"}, {.i = 1, .str = (char *)"Flow Control Receive Only"}, {.i = 2, .str = (char *)"Flow Control Transmit Only"}, {.i = 3, .str = (char *)"Flow Control Enabled"}, {.i = 255, .str = (char *)"Flow Control Hardware Default"}};
    
#line 363 
    struct e1000_option __constr_expr_40 = {.type = list_option, .name = "Flow Control", .err = "reading default settings from EEPROM", .def = 255, .arg = {.l = {.nr = 5, .p = (struct e1000_opt_list const *)(& fc_list)}}};
    
#line 363 
    opt = __constr_expr_40;
    
#line 372 
    if (num_FlowControl > (unsigned int)bd) {
      u32 tmp_1;
      
#line 373 
      unsigned int fc = (unsigned int)FlowControl[bd];
      
#line 374 
      e1000_validate_option(& fc,(struct e1000_option const *)(& opt),adapter);
      
#line 375 
      tmp_1 = fc;
      
#line 375 
      adapter->hw.original_fc = tmp_1;
      
#line 375 
      adapter->hw.fc = (enum ldv_36248)tmp_1;
    }
    else {
      u32 tmp_2;
      
#line 377 
      tmp_2 = (unsigned int)opt.def;
      
#line 377 
      adapter->hw.original_fc = tmp_2;
      
#line 377 
      adapter->hw.fc = (enum ldv_36248)tmp_2;
    }
  }
  
#line 381 
  struct e1000_option __constr_expr_41 = {.type = range_option, .name = "Transmit Interrupt Delay", .err = "using default of ", .def = 8, .arg = {.r = {.min = 0, .max = 65535}}};
  
#line 381 
  opt = __constr_expr_41;
  
#line 390 
  if (num_TxIntDelay > (unsigned int)bd) {
    
#line 391 
    adapter->tx_int_delay = (unsigned int)TxIntDelay[bd];
    
#line 392 
    e1000_validate_option(& adapter->tx_int_delay,(struct e1000_option const *)(& opt),adapter);
  }
  else 
#line 395 
       adapter->tx_int_delay = (unsigned int)opt.def;
  
#line 399 
  struct e1000_option __constr_expr_42 = {.type = range_option, .name = "Transmit Absolute Interrupt Delay", .err = "using default of ", .def = 32, .arg = {.r = {.min = 0, .max = 65535}}};
  
#line 399 
  opt = __constr_expr_42;
  
#line 408 
  if (num_TxAbsIntDelay > (unsigned int)bd) {
    
#line 409 
    adapter->tx_abs_int_delay = (unsigned int)TxAbsIntDelay[bd];
    
#line 410 
    e1000_validate_option(& adapter->tx_abs_int_delay,(struct e1000_option const *)(& opt),adapter);
  }
  else 
#line 413 
       adapter->tx_abs_int_delay = (unsigned int)opt.def;
  
#line 417 
  struct e1000_option __constr_expr_43 = {.type = range_option, .name = "Receive Interrupt Delay", .err = "using default of ", .def = 0, .arg = {.r = {.min = 0, .max = 65535}}};
  
#line 417 
  opt = __constr_expr_43;
  
#line 426 
  if (num_RxIntDelay > (unsigned int)bd) {
    
#line 427 
    adapter->rx_int_delay = (unsigned int)RxIntDelay[bd];
    
#line 428 
    e1000_validate_option(& adapter->rx_int_delay,(struct e1000_option const *)(& opt),adapter);
  }
  else 
#line 431 
       adapter->rx_int_delay = (unsigned int)opt.def;
  
#line 435 
  struct e1000_option __constr_expr_44 = {.type = range_option, .name = "Receive Absolute Interrupt Delay", .err = "using default of ", .def = 8, .arg = {.r = {.min = 0, .max = 65535}}};
  
#line 435 
  opt = __constr_expr_44;
  
#line 444 
  if (num_RxAbsIntDelay > (unsigned int)bd) {
    
#line 445 
    adapter->rx_abs_int_delay = (unsigned int)RxAbsIntDelay[bd];
    
#line 446 
    e1000_validate_option(& adapter->rx_abs_int_delay,(struct e1000_option const *)(& opt),adapter);
  }
  else 
#line 449 
       adapter->rx_abs_int_delay = (unsigned int)opt.def;
  
#line 453 
  struct e1000_option __constr_expr_45 = {.type = range_option, .name = "Interrupt Throttling Rate (ints/sec)", .err = "using default of ", .def = 3, .arg = {.r = {.min = 100, .max = 100000}}};
  
#line 453 
  opt = __constr_expr_45;
  
#line 462 
  if (num_InterruptThrottleRate > (unsigned int)bd) {
    
#line 463 
    adapter->itr = (unsigned int)InterruptThrottleRate[bd];
    
#line 464 
    switch (adapter->itr) {
      case (u32)0: 
#line 465 
      ;
      
#line 466 
      _dev_info((struct device const *)(& (adapter->pdev)->dev),"%s turned off\n",opt.name);
      
#line 467 
      goto ldv_54887;
      case (u32)1: 
#line 468 
      ;
      
#line 469 
      _dev_info((struct device const *)(& (adapter->pdev)->dev),"%s set to dynamic mode\n",opt.name);
      
#line 471 
      adapter->itr_setting = adapter->itr;
      
#line 472 
      adapter->itr = 20000U;
      
#line 473 
      goto ldv_54887;
      case (u32)3: 
#line 474 
      ;
      
#line 475 
      _dev_info((struct device const *)(& (adapter->pdev)->dev),"%s set to dynamic conservative ",opt.name);
      
#line 477 
      adapter->itr_setting = adapter->itr;
      
#line 478 
      adapter->itr = 20000U;
      
#line 479 
      goto ldv_54887;
      case (u32)4: 
#line 480 
      ;
      
#line 481 
      _dev_info((struct device const *)(& (adapter->pdev)->dev),"%s set to simplified ",opt.name);
      
#line 483 
      adapter->itr_setting = adapter->itr;
      
#line 484 
      goto ldv_54887;
      default: 
#line 485 
      ;
      
#line 486 
      e1000_validate_option(& adapter->itr,(struct e1000_option const *)(& opt),adapter);
      
#line 493 
      adapter->itr_setting = adapter->itr & 4294967292U;
      
#line 494 
      goto ldv_54887;
    }
    ldv_54887: 
#line 496 
    ;
  }
  else {
    
#line 497 
    adapter->itr_setting = (unsigned int)opt.def;
    
#line 498 
    adapter->itr = 20000U;
  }
  
#line 502 
  struct e1000_option __constr_expr_46 = {.type = enable_option, .name = "PHY Smart Power Down", .err = "defaulting to Disabled", .def = 0, .arg = {.r = {.min = 0, .max = 0}}};
  
#line 502 
  opt = __constr_expr_46;
  
#line 509 
  if (num_SmartPowerDownEnable > (unsigned int)bd) {
    
#line 510 
    unsigned int spd = (unsigned int)SmartPowerDownEnable[bd];
    
#line 511 
    e1000_validate_option(& spd,(struct e1000_option const *)(& opt),adapter);
    
#line 512 
    adapter->smart_power_down = (_Bool)(spd != 0U);
  }
  else 
#line 514 
       adapter->smart_power_down = (_Bool)(opt.def != 0);
  
#line 518 
  switch ((unsigned int)adapter->hw.media_type) {
    case (unsigned int)1: 
#line 519 
    ;
    case (unsigned int)2: 
#line 520 
    ;
    
#line 521 
    e1000_check_fiber_options(adapter);
    
#line 522 
    goto ldv_54896;
    case (unsigned int)0: 
#line 523 
    ;
    
#line 524 
    e1000_check_copper_options(adapter);
    
#line 525 
    goto ldv_54896;
    default: 
#line 526 
    ;
    
#line 527 
    ldv_inline_asm();
    
#line 527 
    ;
  }
  ldv_54896: 
#line 529 
  ;
  
#line 530 
  return;
}


#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static void e1000_check_fiber_options(struct e1000_adapter *adapter)
{
  
#line 539 
  int bd = (int)adapter->bd_number;
  
#line 540 
  if (num_Speed > (unsigned int)bd) 
#line 541 
                                    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Speed not valid for fiber adapters, parameter "); else ;
  
#line 545 
  if (num_Duplex > (unsigned int)bd) 
#line 546 
                                     _dev_info((struct device const *)(& (adapter->pdev)->dev),"Duplex not valid for fiber adapters, parameter "); else ;
  
#line 550 
  if (num_AutoNeg > (unsigned int)bd && AutoNeg[bd] != 32) 
#line 551 
                                                           _dev_info((struct device const *)(& (adapter->pdev)->dev),"AutoNeg other than 1000/Full is not valid for fiber"); else ;
  
#line 552 
  return;
}


#line 562  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_param.c"
static void e1000_check_copper_options(struct e1000_adapter *adapter)
{
  struct e1000_option opt;
  unsigned int speed;
  unsigned int dplx;
  unsigned int an;
  s32 tmp_9;
  
#line 566 
  int bd = (int)adapter->bd_number;
  {
    
#line 569 
    struct e1000_opt_list const speed_list[4U] = {{.i = 0, .str = (char *)""}, {.i = 10, .str = (char *)""}, {.i = 100, .str = (char *)""}, {.i = 1000, .str = (char *)""}};
    
#line 575 
    struct e1000_option __constr_expr_47 = {.type = list_option, .name = "Speed", .err = "parameter ignored", .def = 0, .arg = {.l = {.nr = 4, .p = (struct e1000_opt_list const *)(& speed_list)}}};
    
#line 575 
    opt = __constr_expr_47;
    
#line 584 
    if (num_Speed > (unsigned int)bd) {
      
#line 585 
      speed = (unsigned int)Speed[bd];
      
#line 586 
      e1000_validate_option(& speed,(struct e1000_option const *)(& opt),adapter);
    }
    else 
#line 588 
         speed = (unsigned int)opt.def;
  }
  {
    
#line 592 
    struct e1000_opt_list const dplx_list[3U] = {{.i = 0, .str = (char *)""}, {.i = 1, .str = (char *)""}, {.i = 2, .str = (char *)""}};
    
#line 597 
    struct e1000_option __constr_expr_48 = {.type = list_option, .name = "Duplex", .err = "parameter ignored", .def = 0, .arg = {.l = {.nr = 3, .p = (struct e1000_opt_list const *)(& dplx_list)}}};
    
#line 597 
    opt = __constr_expr_48;
    
#line 606 
    if (num_Duplex > (unsigned int)bd) {
      
#line 607 
      dplx = (unsigned int)Duplex[bd];
      
#line 608 
      e1000_validate_option(& dplx,(struct e1000_option const *)(& opt),adapter);
    }
    else 
#line 610 
         dplx = (unsigned int)opt.def;
  }
  
#line 614 
  if (num_AutoNeg > (unsigned int)bd && (speed != 0U || dplx != 0U)) {
    
#line 615 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"AutoNeg specified along with Speed or Duplex, ");
    
#line 617 
    adapter->hw.autoneg_advertised = (unsigned short)47U;
  }
  else {
    
#line 619 
    struct e1000_opt_list const an_list[31U] = {{.i = 1, .str = (char *)"AutoNeg advertising "}, {.i = 2, .str = (char *)"AutoNeg advertising "}, {.i = 3, .str = (char *)"AutoNeg advertising "}, {.i = 4, .str = (char *)"AutoNeg advertising "}, {.i = 5, .str = (char *)"AutoNeg advertising "}, {.i = 6, .str = (char *)"AutoNeg advertising "}, {.i = 7, .str = (char *)"AutoNeg advertising "}, {.i = 8, .str = (char *)"AutoNeg advertising "}, {.i = 9, .str = (char *)"AutoNeg advertising "}, {.i = 10, .str = (char *)"AutoNeg advertising "}, {.i = 11, .str = (char *)"AutoNeg advertising "}, {.i = 12, .str = (char *)"AutoNeg advertising "}, {.i = 13, .str = (char *)"AutoNeg advertising "}, {.i = 14, .str = (char *)"AutoNeg advertising "}, {.i = 15, .str = (char *)"AutoNeg advertising "}, {.i = 32, .str = (char *)"AutoNeg advertising "}, {.i = 33, .str = (char *)"AutoNeg advertising "}, {.i = 34, .str = (char *)"AutoNeg advertising "}, {.i = 35, .str = (char *)"AutoNeg advertising "}, {.i = 36, .str = (char *)"AutoNeg advertising "}, {.i = 37, .str = (char *)"AutoNeg advertising "}, {.i = 38, .str = (char *)"AutoNeg advertising "}, {.i = 39, .str = (char *)"AutoNeg advertising "}, {.i = 40, .str = (char *)"AutoNeg advertising "}, {.i = 41, .str = (char *)"AutoNeg advertising "}, {.i = 42, .str = (char *)"AutoNeg advertising "}, {.i = 43, .str = (char *)"AutoNeg advertising "}, {.i = 44, .str = (char *)"AutoNeg advertising "}, {.i = 45, .str = (char *)"AutoNeg advertising "}, {.i = 46, .str = (char *)"AutoNeg advertising "}, {.i = 47, .str = (char *)"AutoNeg advertising "}};
    
#line 653 
    struct e1000_option __constr_expr_49 = {.type = list_option, .name = "AutoNeg", .err = "parameter ignored", .def = 47, .arg = {.l = {.nr = 31, .p = (struct e1000_opt_list const *)(& an_list)}}};
    
#line 653 
    opt = __constr_expr_49;
    
#line 662 
    if (num_AutoNeg > (unsigned int)bd) {
      
#line 663 
      an = (unsigned int)AutoNeg[bd];
      
#line 664 
      e1000_validate_option(& an,(struct e1000_option const *)(& opt),adapter);
    }
    else 
#line 666 
         an = (unsigned int)opt.def;
    
#line 668 
    adapter->hw.autoneg_advertised = (unsigned short)an;
  }
  
#line 671 
  switch (speed + dplx) {
    u8 tmp;
    u8 tmp_0;
    u8 tmp_1;
    u8 tmp_2;
    u8 tmp_3;
    u8 tmp_4;
    u8 tmp_5;
    u8 tmp_6;
    u8 tmp_7;
    u8 tmp_8;
    case (unsigned int)0: 
#line 672 
    ;
    
#line 673 
    tmp = (unsigned char)1U;
    
#line 673 
    adapter->fc_autoneg = tmp;
    
#line 673 
    adapter->hw.autoneg = tmp;
    
#line 674 
    if (num_Speed > (unsigned int)bd && (speed != 0U || dplx != 0U)) 
      
#line 675 
      _dev_info((struct device const *)(& (adapter->pdev)->dev),"Speed and duplex autonegotiation "); else ;
    
#line 677 
    goto ldv_54927;
    case (unsigned int)1: 
#line 678 
    ;
    
#line 679 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Half Duplex specified without Speed\n");
    
#line 680 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Using Autonegotiation at Half Duplex only\n");
    
#line 681 
    tmp_0 = (unsigned char)1U;
    
#line 681 
    adapter->fc_autoneg = tmp_0;
    
#line 681 
    adapter->hw.autoneg = tmp_0;
    
#line 682 
    adapter->hw.autoneg_advertised = (unsigned short)5U;
    
#line 684 
    goto ldv_54927;
    case (unsigned int)2: 
#line 685 
    ;
    
#line 686 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Full Duplex specified without Speed\n");
    
#line 687 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Using Autonegotiation at Full Duplex only\n");
    
#line 688 
    tmp_1 = (unsigned char)1U;
    
#line 688 
    adapter->fc_autoneg = tmp_1;
    
#line 688 
    adapter->hw.autoneg = tmp_1;
    
#line 689 
    adapter->hw.autoneg_advertised = (unsigned short)42U;
    
#line 692 
    goto ldv_54927;
    case (unsigned int)10: 
#line 693 
    ;
    
#line 694 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"10 Mbps Speed specified without Duplex\n");
    
#line 695 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Using Autonegotiation at 10 Mbps only\n");
    
#line 696 
    tmp_2 = (unsigned char)1U;
    
#line 696 
    adapter->fc_autoneg = tmp_2;
    
#line 696 
    adapter->hw.autoneg = tmp_2;
    
#line 697 
    adapter->hw.autoneg_advertised = (unsigned short)3U;
    
#line 699 
    goto ldv_54927;
    case (unsigned int)11: 
#line 700 
    ;
    
#line 701 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Forcing to 10 Mbps Half Duplex\n");
    
#line 702 
    tmp_3 = (unsigned char)0U;
    
#line 702 
    adapter->fc_autoneg = tmp_3;
    
#line 702 
    adapter->hw.autoneg = tmp_3;
    
#line 703 
    adapter->hw.forced_speed_duplex = (unsigned char)0U;
    
#line 704 
    adapter->hw.autoneg_advertised = (unsigned short)0U;
    
#line 705 
    goto ldv_54927;
    case (unsigned int)12: 
#line 706 
    ;
    
#line 707 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Forcing to 10 Mbps Full Duplex\n");
    
#line 708 
    tmp_4 = (unsigned char)0U;
    
#line 708 
    adapter->fc_autoneg = tmp_4;
    
#line 708 
    adapter->hw.autoneg = tmp_4;
    
#line 709 
    adapter->hw.forced_speed_duplex = (unsigned char)1U;
    
#line 710 
    adapter->hw.autoneg_advertised = (unsigned short)0U;
    
#line 711 
    goto ldv_54927;
    case (unsigned int)100: 
#line 712 
    ;
    
#line 713 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"100 Mbps Speed specified without Duplex\n");
    
#line 714 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Using Autonegotiation at 100 Mbps only\n");
    
#line 715 
    tmp_5 = (unsigned char)1U;
    
#line 715 
    adapter->fc_autoneg = tmp_5;
    
#line 715 
    adapter->hw.autoneg = tmp_5;
    
#line 716 
    adapter->hw.autoneg_advertised = (unsigned short)12U;
    
#line 718 
    goto ldv_54927;
    case (unsigned int)101: 
#line 719 
    ;
    
#line 720 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Forcing to 100 Mbps Half Duplex\n");
    
#line 721 
    tmp_6 = (unsigned char)0U;
    
#line 721 
    adapter->fc_autoneg = tmp_6;
    
#line 721 
    adapter->hw.autoneg = tmp_6;
    
#line 722 
    adapter->hw.forced_speed_duplex = (unsigned char)2U;
    
#line 723 
    adapter->hw.autoneg_advertised = (unsigned short)0U;
    
#line 724 
    goto ldv_54927;
    case (unsigned int)102: 
#line 725 
    ;
    
#line 726 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Forcing to 100 Mbps Full Duplex\n");
    
#line 727 
    tmp_7 = (unsigned char)0U;
    
#line 727 
    adapter->fc_autoneg = tmp_7;
    
#line 727 
    adapter->hw.autoneg = tmp_7;
    
#line 728 
    adapter->hw.forced_speed_duplex = (unsigned char)3U;
    
#line 729 
    adapter->hw.autoneg_advertised = (unsigned short)0U;
    
#line 730 
    goto ldv_54927;
    case (unsigned int)1000: 
#line 731 
    ;
    
#line 732 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"1000 Mbps Speed specified without Duplex\n");
    
#line 733 
    goto full_duplex_only;
    case (unsigned int)1001: 
#line 734 
    ;
    
#line 735 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Half Duplex is not supported at 1000 Mbps\n");
    case (unsigned int)1002: 
#line 737 
    ;
    full_duplex_only: 
#line 738 
    ;
    
#line 739 
    _dev_info((struct device const *)(& (adapter->pdev)->dev),"Using Autonegotiation at 1000 Mbps Full Duplex ");
    
#line 741 
    tmp_8 = (unsigned char)1U;
    
#line 741 
    adapter->fc_autoneg = tmp_8;
    
#line 741 
    adapter->hw.autoneg = tmp_8;
    
#line 742 
    adapter->hw.autoneg_advertised = (unsigned short)32U;
    
#line 743 
    goto ldv_54927;
    default: 
#line 744 
    ;
    
#line 745 
    ldv_inline_asm();
    
#line 745 
    ;
  }
  ldv_54927: 
#line 749 
  ;
  
#line 749 
  tmp_9 = e1000_validate_mdi_setting(& adapter->hw);
  
#line 749 
  if (tmp_9 < 0) 
#line 750 
                 _dev_info((struct device const *)(& (adapter->pdev)->dev),"Speed, AutoNeg and MDI-X specs are incompatible. "); else ;
  
#line 751 
  return;
}

void __builtin_prefetch(void const * , ...);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int fls(int x)
{
  int __retres;
  int r;
  
#line 440 
  ldv_inline_asm();
  
#line 464 
  __retres = r + 1;
  
#line 464 
  return __retres;
}


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bitops/find.h"
unsigned long find_next_bit(unsigned long const *, unsigned long, unsigned long);


#line 42 
unsigned long find_first_bit(unsigned long const *, unsigned long);


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
void __dynamic_netdev_dbg(struct _ddebug *, struct net_device const *, char const * , ...);


#line 431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
void print_hex_dump(char const *, char const *, int, int, int, void const *, size_t, bool);


#line 474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
extern enum system_states system_state;


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-defs.h"
void __bad_size_call_parameter(void);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void)
{
  struct task_struct *tmp;
  {
    struct task_struct *pfo_ret__;
    
#line 14 
    switch (8UL) {
      case (unsigned long)1: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)2: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)4: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      case (unsigned long)8: 
#line 14 
      ;
      
#line 15 
      ldv_inline_asm();
      
#line 14 
      goto ldv_3477;
      default: 
#line 14 
      ;
      
#line 14 
      __bad_percpu_size();
    }
    ldv_3477: 
#line 14 
    ;
    
#line 14 
    tmp = pfo_ret__;
  }
  
#line 14 
  return tmp;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 56 
void *memset(void *, int, size_t);


#line 65 
char *strcpy(char *, char const *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
char *strncpy(char *, char const *, __kernel_size_t);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const *v)
{
  int __retres;
  int const volatile *tmp;
  {
    
#line 27 
    int const __var = 0;
    
#line 27 
    tmp = (int const volatile *)(& v->counter);
  }
  
#line 27 
  __retres = *tmp;
  
#line 27 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v, int i)
{
  
#line 39 
  v->counter = i;
  
#line 40 
  return;
}


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  int __retres;
  int tmp;
  {
    int pfo_ret__;
    
#line 22 
    switch (4UL) {
      case (unsigned long)1: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)2: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)4: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)8: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      default: 
#line 22 
      ;
      
#line 22 
      __bad_percpu_size();
    }
    ldv_6320: 
#line 22 
    ;
    
#line 22 
    tmp = pfo_ret__;
  }
  
#line 22 
  __retres = tmp & 2147483647;
  
#line 22 
  return __retres;
}


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val)
{
  int tmp;
  
#line 72 
  if (0 != 0 && (val == 1 || val == -1)) 
#line 72 
                                         tmp = val; else 
#line 72 
                                                         tmp = 0;
  
#line 72 
  int const pao_ID__ = tmp;
  
#line 72 
  switch (4UL) {
    case (unsigned long)1: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)2: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)4: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)8: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    default: 
#line 72 
    ;
    
#line 72 
    __bad_percpu_size();
  }
  ldv_6377: 
#line 72 
  ;
  
#line 74 
  return;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val)
{
  int tmp;
  
#line 77 
  if (0 != 0 && (- val == 1 || - val == -1)) 
#line 77 
                                             tmp = - val; else 
#line 77 
                                                               tmp = 0;
  
#line 77 
  int const pao_ID__ = tmp;
  
#line 77 
  switch (4UL) {
    case (unsigned long)1: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)2: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)4: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)8: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    default: 
#line 77 
    ;
    
#line 77 
    __bad_percpu_size();
  }
  ldv_6389: 
#line 77 
  ;
  
#line 79 
  return;
}


#line 7  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
void __local_bh_disable_ip(unsigned long, unsigned int);


#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_disable(void)
{
  __here_0: 
#line 18 
  ;
  
#line 18 
  __local_bh_disable_ip((unsigned long)((void *)0),512U);
  
#line 20 
  return;
}


#line 22 
void __local_bh_enable_ip(unsigned long, unsigned int);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_enable(void)
{
  __here_0: 
#line 31 
  ;
  
#line 31 
  __local_bh_enable_ip((unsigned long)((void *)0),512U);
  
#line 33 
  return;
}


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 45 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 346 
static void ldv_spin_lock_60(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 395 
static void ldv_spin_unlock_63(spinlock_t *lock);


#line 454  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 456 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 457 
  return;
}


#line 486 
static void ldv_spin_unlock_irqrestore_94(spinlock_t *lock, unsigned long flags);


#line 490 
static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock, unsigned long flags);


#line 494 
static void ldv_spin_unlock_irqrestore_99(spinlock_t *lock, unsigned long flags);


#line 498 
static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock, unsigned long flags);


#line 502 
static void ldv_spin_unlock_irqrestore_102(spinlock_t *lock, unsigned long flags);


#line 506 
static void ldv_spin_unlock_irqrestore_103(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_93(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_96(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_98(spinlock_t *ldv_func_arg1);


#line 82 
static void ldv___ldv_spin_lock_101(spinlock_t *ldv_func_arg1);


#line 90 
void ldv_spin_model_lock(char *);


#line 91 
void ldv_spin_model_unlock(char *);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 25 
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void delayed_work_timer_fn(unsigned long);


#line 181 
void __init_work(struct work_struct *, int);


#line 444 
bool cancel_work_sync(struct work_struct *);


#line 448 
bool cancel_delayed_work_sync(struct delayed_work *);


#line 560 
static bool ldv_schedule_work_89(struct work_struct *work);


#line 564 
static bool ldv_schedule_work_92(struct work_struct *work);


#line 597 
static bool ldv_schedule_delayed_work_86(struct delayed_work *dwork, unsigned long delay);


#line 601 
static bool ldv_schedule_delayed_work_87(struct delayed_work *dwork, unsigned long delay);


#line 605 
static bool ldv_schedule_delayed_work_88(struct delayed_work *dwork, unsigned long delay);


#line 609 
static bool ldv_schedule_delayed_work_90(struct delayed_work *dwork, unsigned long delay);


#line 613 
static bool ldv_schedule_delayed_work_91(struct delayed_work *dwork, unsigned long delay);


#line 617 
static bool ldv_schedule_delayed_work_95(struct delayed_work *dwork, unsigned long delay);


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile *addr)
{
  unsigned int ret;
  
#line 59 
  ldv_inline_asm();
  
#line 58 
  return ret;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void volatile *addr)
{
  
#line 68 
  ldv_inline_asm();
  
#line 69 
  return;
}


#line 181 
void *ioremap_nocache(resource_size_t, unsigned long);


#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset, unsigned long size)
{
  void *tmp;
  
#line 192 
  tmp = ioremap_nocache(offset,size);
  
#line 192 
  return tmp;
}


#line 195 
void iounmap(void volatile *);


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value, int port)
{
  
#line 324 
  ldv_inline_asm();
  
#line 325 
  return;
}


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct page *alloc_pages_current(gfp_t, unsigned int);


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)
{
  struct page *tmp;
  
#line 327 
  tmp = alloc_pages_current(gfp_mask,order);
  
#line 327 
  return tmp;
}


#line 374 
void __free_page_frag(void *);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page-flags.h"
__inline static int PageTail(struct page const *page)
{
  int tmp;
  
#line 400 
  tmp = constant_test_bit(15L,(unsigned long const volatile *)(& page->flags));
  
#line 400 
  return tmp;
}


#line 440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static struct page *compound_head_by_tail(struct page *tail)
{
  struct page *__retres;
  int tmp;
  
#line 442 
  struct page *head = tail->__anonCompField_page_46.first_page;
  
#line 443 
  ldv_inline_asm();
  
#line 450 
  tmp = PageTail((struct page const *)tail);
  
#line 450 
  if ((long)(tmp != 0) != 0L) {
    
#line 451 
    __retres = head;
    
#line 451 
    goto return_label;
  }
  else ;
  
#line 452 
  __retres = tail;
  return_label: 
#line 452 
                return __retres;
}


#line 461  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static struct page *compound_head(struct page *page)
{
  struct page *__retres;
  int tmp_0;
  
#line 463 
  tmp_0 = PageTail((struct page const *)page);
  
#line 463 
  if ((long)(tmp_0 != 0) != 0L) {
    struct page *tmp;
    
#line 464 
    tmp = compound_head_by_tail(page);
    
#line 464 
    __retres = tmp;
    
#line 464 
    goto return_label;
  }
  else ;
  
#line 465 
  __retres = page;
  return_label: 
#line 465 
                return __retres;
}


#line 569 
void put_page(struct page *);


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page const *page)
{
  void *__retres;
  
#line 947 
  __retres = (void *)((unsigned long)((unsigned long long)(((long)page + 24189255811072L) / 64L) << 12) + 18446612132314218496UL);
  
#line 947 
  return __retres;
}


#line 1031  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static bool page_is_pfmemalloc(struct page *page)
{
  bool __retres;
  
#line 1037 
  __retres = (_Bool)(page->__anonCompField_page_42.__anonCompField___anonstruct_151_37.index == 18446744073709551615UL);
  
#line 1037 
  return __retres;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm_wakeup.h"
int device_set_wakeup_enable(struct device *, bool);


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 1083 
void dev_err(struct device const *, char const * , ...);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 418 
static void *kmalloc(size_t size, gfp_t flags);


#line 542 
static void *kcalloc(size_t n, size_t size, gfp_t flags);


#line 401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev)
{
  int __retres;
  
#line 403 
  __retres = pdev->error_state != 1U;
  
#line 403 
  return __retres;
}


#line 861 
int pci_bus_read_config_word(struct pci_bus *, unsigned int, int, u16 *);


#line 887  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev const *dev, int where, u16 *val)
{
  int tmp;
  
#line 889 
  tmp = pci_bus_read_config_word(dev->bus,dev->devfn,where,val);
  
#line 889 
  return tmp;
}


#line 951 
int pci_enable_device(struct pci_dev *);


#line 953 
int pci_enable_device_mem(struct pci_dev *);


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 977 
int pci_set_mwi(struct pci_dev *);


#line 979 
void pci_clear_mwi(struct pci_dev *);


#line 989 
int pcix_get_mmrbc(struct pci_dev *);


#line 990 
int pcix_set_mmrbc(struct pci_dev *, int);


#line 1013 
int pci_select_bars(struct pci_dev *, unsigned long);


#line 1026 
int pci_save_state(struct pci_dev *);


#line 1027 
void pci_restore_state(struct pci_dev *);


#line 1040 
int pci_set_power_state(struct pci_dev *, pci_power_t);


#line 1044 
int __pci_enable_wake(struct pci_dev *, pci_power_t, bool, bool);


#line 1046 
int pci_wake_from_d3(struct pci_dev *, bool);


#line 1047 
int pci_prepare_to_sleep(struct pci_dev *);


#line 1053  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
{
  int tmp;
  
#line 1056 
  tmp = __pci_enable_wake(dev,state,(_Bool)0,(_Bool)((bool)((int)enable) != 0));
  
#line 1056 
  return tmp;
}


#line 1100 
int pci_request_selected_regions(struct pci_dev *, int, char const *);


#line 1102 
void pci_release_selected_regions(struct pci_dev *, int);


#line 1146 
static int ldv___pci_register_driver_77(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_78(struct pci_driver *ldv_func_arg1);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 44 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 59 
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t addr;
  void *tmp_0;
  int tmp_1;
  
#line 80 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 83 
  ;
  
#line 83 
  tmp_0 = lowmem_page_address((struct page const *)page);
  
#line 83 
  ;
  
#line 83 
  kmemcheck_mark_initialized(tmp_0 + offset,(unsigned int)size);
  
#line 84 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 84 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 86 
    ldv_inline_asm();
    
#line 84 
    ;
  }
  else ;
  
#line 85 
  addr = (*(ops->map_page))(dev,page,offset,size,dir,(struct dma_attrs *)0);
  
#line 86 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr,(_Bool)0);
  
#line 88 
  return addr;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 94 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 96 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 96 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 98 
    ldv_inline_asm();
    
#line 96 
    ;
  }
  else ;
  
#line 97 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 98 
    (*(ops->unmap_page))(dev,addr,size,dir,(struct dma_attrs *)0); else ;
  
#line 99 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)0);
  
#line 100 
  return;
}


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 106 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 108 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 108 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 110 
    ldv_inline_asm();
    
#line 108 
    ;
  }
  else ;
  
#line 109 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 110 
    (*(ops->sync_single_for_cpu))(dev,addr,size,dir); else ;
  
#line 111 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  
#line 112 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 60 
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 131 
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, struct dma_attrs *);


#line 136 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, struct dma_attrs *);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
  
#line 118 
  int rc = dma_set_mask(dev,mask);
  
#line 119 
  if (rc == 0) 
#line 120 
               dma_set_coherent_mask(dev,mask); else ;
  
#line 121 
  return rc;
}


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 1484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static char const *pci_name(struct pci_dev const *pdev)
{
  char const *tmp;
  
#line 1486 
  tmp = dev_name(& pdev->dev);
  
#line 1486 
  return tmp;
}


#line 1666 
void *pci_ioremap_bar(struct pci_dev *, int);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
void msleep(unsigned int);


#line 48 
void usleep_range(unsigned long, unsigned long);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql, unsigned int count)
{
  
#line 74 
  if ((long)(count > 268435455U) != 0L) {
    
#line 76 
    ldv_inline_asm();
    
#line 74 
    ;
  }
  else ;
  
#line 76 
  dql->last_obj_cnt = count;
  
#line 77 
  ldv_inline_asm();
  
#line 85 
  dql->num_queued += count;
  
#line 86 
  return;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql const *dql)
{
  int __retres;
  unsigned int const volatile *tmp;
  unsigned int const volatile *tmp_0;
  {
    
#line 91 
    unsigned int const __var = 0U;
    
#line 91 
    tmp = (unsigned int const volatile *)(& dql->adj_limit);
  }
  {
    
#line 91 
    unsigned int const __var_0 = 0U;
    
#line 91 
    tmp_0 = (unsigned int const volatile *)(& dql->num_queued);
  }
  
#line 91 
  ;
  
#line 91 
  __retres = (int)(*tmp - *tmp_0);
  
#line 91 
  return __retres;
}


#line 95 
void dql_completed(struct dql *, unsigned int);


#line 98 
void dql_reset(struct dql *);


#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
int net_ratelimit(void);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_fold(__wsum sum)
{
  __sum16 __retres;
  
#line 24 
  ldv_inline_asm();
  
#line 29 
  __retres = (unsigned short)(~ sum >> 16);
  
#line 29 
  return __retres;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len, unsigned short proto, __wsum sum)
{
  
#line 89 
  ldv_inline_asm();
  
#line 97 
  return sum;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr, unsigned short len, unsigned short proto, __wsum sum)
{
  __sum16 tmp_0;
  __wsum tmp;
  
#line 116 
  tmp = csum_tcpudp_nofold(saddr,daddr,(unsigned short)((int)len),(unsigned short)((int)proto),sum);
  
#line 116 
  tmp_0 = csum_fold(tmp);
  
#line 116 
  return tmp_0;
}


#line 179 
__sum16 csum_ipv6_magic(struct in6_addr const *, struct in6_addr const *, __u32, unsigned short, __wsum);


#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const *frag)
{
  unsigned int __retres;
  
#line 232 
  __retres = frag->size;
  
#line 232 
  return __retres;
}


#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag, unsigned int size)
{
  
#line 237 
  frag->size = size;
  
#line 238 
  return;
}


#line 772 
void kfree_skb(struct sk_buff *);


#line 775 
void consume_skb(struct sk_buff *);


#line 786 
struct sk_buff *build_skb(void *, unsigned int);


#line 852 
int pskb_expand_head(struct sk_buff *, int, int, gfp_t);


#line 862 
int skb_pad(struct sk_buff *, int);


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 978 
  __retres = skb->head + skb->end;
  
#line 978 
  return __retres;
}


#line 1127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff const *skb)
{
  int __retres;
  int dataref;
  unsigned char *tmp;
  
#line 1131 
  if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) {
    
#line 1132 
    __retres = 0;
    
#line 1132 
    goto return_label;
  }
  else ;
  
#line 1134 
  tmp = skb_end_pointer(skb);
  
#line 1134 
  dataref = atomic_read((atomic_t const *)(& ((struct skb_shared_info *)tmp)->dataref));
  
#line 1135 
  dataref = (dataref & 65535) - (dataref >> 16);
  
#line 1136 
  __retres = dataref != 1;
  return_label: 
#line 1136 
                return __retres;
}


#line 1567  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff const *skb)
{
  bool __retres;
  
#line 1569 
  __retres = (_Bool)(skb->data_len != 0U);
  
#line 1569 
  return __retres;
}


#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1574 
  __retres = skb->len - skb->data_len;
  
#line 1574 
  return __retres;
}


#line 1599  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size)
{
  unsigned char *tmp;
  bool tmp_0;
  
#line 1602 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1602 
  skb_frag_t *frag = & ((struct skb_shared_info *)tmp)->frags[i];
  
#line 1609 
  frag->page.p = page;
  
#line 1610 
  frag->page_offset = (unsigned int)off;
  
#line 1611 
  skb_frag_size_set(frag,(unsigned int)size);
  
#line 1613 
  page = compound_head(page);
  
#line 1614 
  tmp_0 = page_is_pfmemalloc(page);
  
#line 1614 
  if ((int)tmp_0 != 0) 
#line 1615 
                       skb->pfmemalloc = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))))1U; else ;
  
#line 1616 
  return;
}


#line 1632  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size)
{
  unsigned char *tmp;
  
#line 1635 
  __skb_fill_page_desc(skb,i,page,off,size);
  
#line 1636 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 1636 
  ((struct skb_shared_info *)tmp)->nr_frags = (unsigned char)((unsigned int)((unsigned char)i) + 1U);
  
#line 1637 
  return;
}


#line 1650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1652 
  __retres = skb->head + skb->tail;
  
#line 1652 
  return __retres;
}


#line 1655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb)
{
  
#line 1657 
  skb->tail = (unsigned int)((long)skb->data - (long)skb->head);
  
#line 1658 
  return;
}


#line 1660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb, int const offset)
{
  
#line 1662 
  skb_reset_tail_pointer(skb);
  
#line 1663 
  skb->tail += (unsigned int)offset;
  
#line 1664 
  return;
}


#line 1688 
unsigned char *skb_put(struct sk_buff *, unsigned int);


#line 1689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
  bool tmp_1;
  
#line 1691 
  unsigned char *tmp = skb_tail_pointer((struct sk_buff const *)skb);
  
#line 1692 
  tmp_1 = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 1692 
  if ((long)((int)tmp_1 != 0) != 0L) {
    
#line 1694 
    ldv_inline_asm();
    
#line 1692 
    ;
  }
  else ;
  
#line 1693 
  skb->tail += len;
  
#line 1694 
  skb->len += len;
  
#line 1695 
  return tmp;
}


#line 1719 
unsigned char *__pskb_pull_tail(struct sk_buff *, int);


#line 1735  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  unsigned int tmp;
  unsigned char *tmp_1;
  unsigned int tmp_0;
  
#line 1737 
  tmp = skb_headlen((struct sk_buff const *)skb);
  
#line 1737 
  ;
  
#line 1737 
  if ((long)(tmp >= len) != 0L) {
    
#line 1738 
    __retres = 1;
    
#line 1738 
    goto return_label;
  }
  else ;
  
#line 1739 
  if ((long)(skb->len < len) != 0L) {
    
#line 1740 
    __retres = 0;
    
#line 1740 
    goto return_label;
  }
  else ;
  
#line 1741 
  tmp_0 = skb_headlen((struct sk_buff const *)skb);
  
#line 1741 
  ;
  
#line 1741 
  ;
  
#line 1741 
  tmp_1 = __pskb_pull_tail(skb,(int)(len - tmp_0));
  
#line 1741 
  __retres = tmp_1 != (unsigned char *)0U;
  return_label: 
#line 1741 
                return __retres;
}


#line 1750  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff const *skb)
{
  unsigned int __retres;
  
#line 1752 
  __retres = (unsigned int)((long)skb->data - (long)skb->head);
  
#line 1752 
  return __retres;
}


#line 1789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  
#line 1791 
  skb->data += len;
  
#line 1792 
  skb->tail += (unsigned int)len;
  
#line 1793 
  return;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1882 
  __retres = skb->head + (int)skb->transport_header;
  
#line 1882 
  return __retres;
}


#line 1897  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff const *skb)
{
  unsigned char *__retres;
  
#line 1899 
  __retres = skb->head + (int)skb->network_header;
  
#line 1899 
  return __retres;
}


#line 1962  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_checksum_start_offset(struct sk_buff const *skb)
{
  int __retres;
  unsigned int tmp;
  
#line 1964 
  tmp = skb_headroom(skb);
  
#line 1964 
  ;
  
#line 1964 
  __retres = (int)((unsigned int)skb->__anonCompField_sk_buff_82.__anonCompField___anonunion_285_81.csum_start - tmp);
  
#line 1964 
  return __retres;
}


#line 1967  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_transport_offset(struct sk_buff const *skb)
{
  int __retres;
  unsigned char *tmp;
  
#line 1969 
  tmp = skb_transport_header(skb);
  
#line 1969 
  ;
  
#line 1969 
  __retres = (int)((long)tmp - (long)skb->data);
  
#line 1969 
  return __retres;
}


#line 1982  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_network_offset(struct sk_buff const *skb)
{
  int __retres;
  unsigned char *tmp;
  
#line 1984 
  tmp = skb_network_header(skb);
  
#line 1984 
  ;
  
#line 1984 
  __retres = (int)((long)tmp - (long)skb->data);
  
#line 1984 
  return __retres;
}


#line 2045 
int ___pskb_trim(struct sk_buff *, unsigned int);


#line 2047  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_trim(struct sk_buff *skb, unsigned int len)
{
  bool tmp_0;
  
#line 2049 
  tmp_0 = skb_is_nonlinear((struct sk_buff const *)skb);
  
#line 2049 
  if ((long)((int)tmp_0 != 0) != 0L) {
    {
      
#line 2050 
      int __ret_warn_on = 1;
      
#line 2050 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 2050 
                                            warn_slowpath_null("include/linux/skbuff.h",2050); else ;
      
#line 2050 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 2051 
    goto return_label;
  }
  else ;
  
#line 2053 
  skb->len = len;
  
#line 2054 
  skb_set_tail_pointer(skb,(int)len);
  return_label: 
#line 2055 
                return;
}


#line 2057 
void skb_trim(struct sk_buff *, unsigned int);


#line 2059  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int __pskb_trim(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  
#line 2061 
  if (skb->data_len != 0U) {
    int tmp;
    
#line 2062 
    tmp = ___pskb_trim(skb,len);
    
#line 2062 
    __retres = tmp;
    
#line 2062 
    goto return_label;
  }
  else ;
  
#line 2063 
  __skb_trim(skb,len);
  
#line 2064 
  __retres = 0;
  return_label: 
#line 2064 
                return __retres;
}


#line 2067  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int pskb_trim(struct sk_buff *skb, unsigned int len)
{
  int tmp_0;
  
#line 2069 
  if (skb->len > len) 
#line 2069 
                      tmp_0 = __pskb_trim(skb,len); else 
#line 2069 
                                                         tmp_0 = 0;
  
#line 2069 
  return tmp_0;
}


#line 2138 
void *netdev_alloc_frag(unsigned int);


#line 2192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_free_frag(void *addr)
{
  
#line 2194 
  __free_page_frag(addr);
  
#line 2195 
  return;
}


#line 2198 
struct sk_buff *__napi_alloc_skb(struct napi_struct *, unsigned int, gfp_t);


#line 2200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *napi_alloc_skb(struct napi_struct *napi, unsigned int length)
{
  struct sk_buff *tmp;
  
#line 2203 
  tmp = __napi_alloc_skb(napi,length,32U);
  
#line 2203 
  return tmp;
}


#line 2272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const *frag)
{
  struct page *__retres;
  
#line 2274 
  __retres = frag->page.p;
  
#line 2274 
  return __retres;
}


#line 2390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev, skb_frag_t const *frag, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t tmp_0;
  struct page *tmp;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  ;
  
#line 2395 
  tmp = skb_frag_page(frag);
  
#line 2395 
  ;
  
#line 2395 
  tmp_0 = dma_map_page(dev,tmp,(unsigned long)frag->page_offset + offset,size,dir);
  
#line 2395 
  return tmp_0;
}


#line 2427  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb, unsigned int headroom, int cloned)
{
  int __retres;
  unsigned int tmp_0;
  
#line 2430 
  int delta = 0;
  
#line 2432 
  tmp_0 = skb_headroom((struct sk_buff const *)skb);
  
#line 2432 
  ;
  
#line 2432 
  if (tmp_0 < headroom) {
    unsigned int tmp;
    
#line 2433 
    tmp = skb_headroom((struct sk_buff const *)skb);
    
#line 2433 
    delta = (int)(headroom - tmp);
  }
  else ;
  
#line 2435 
  if (delta != 0 || cloned != 0) {
    int tmp_5;
    int tmp_2;
    int tmp_4;
    {
      int tmp_1;
      
#line 2436 
      int _max1 = 32;
      
#line 2436 
      int _max2 = 64;
      
#line 2436 
      if (_max1 > _max2) 
#line 2436 
                         tmp_1 = _max1; else 
#line 2436 
                                             tmp_1 = _max2;
      
#line 2436 
      tmp_2 = tmp_1;
    }
    {
      int tmp_3;
      
#line 2436 
      int _max1_0 = 32;
      
#line 2436 
      int _max2_0 = 64;
      
#line 2436 
      if (_max1_0 > _max2_0) 
#line 2436 
                             tmp_3 = _max1_0; else 
#line 2436 
                                                   tmp_3 = _max2_0;
      
#line 2436 
      tmp_4 = tmp_3;
    }
    
#line 2436 
    ;
    
#line 2436 
    ;
    
#line 2436 
    tmp_5 = pskb_expand_head(skb,((tmp_2 + -1) + delta) & ~ (tmp_4 + -1),0,32U);
    
#line 2436 
    __retres = tmp_5;
    
#line 2436 
    goto return_label;
  }
  else ;
  
#line 2438 
  __retres = 0;
  return_label: 
#line 2438 
                return __retres;
}


#line 2468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
{
  int tmp_0;
  int tmp;
  
#line 2470 
  tmp = skb_header_cloned((struct sk_buff const *)skb);
  
#line 2470 
  ;
  
#line 2470 
  ;
  
#line 2470 
  tmp_0 = __skb_cow(skb,headroom,tmp);
  
#line 2470 
  return tmp_0;
}


#line 2501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
  int __retres;
  
#line 2503 
  unsigned int size = skb->len;
  
#line 2505 
  if ((long)(size < len) != 0L) {
    int tmp;
    
#line 2506 
    len -= size;
    
#line 2507 
    tmp = skb_pad(skb,(int)len);
    
#line 2507 
    if (tmp != 0) {
      
#line 2508 
      __retres = -12;
      
#line 2508 
      goto return_label;
    }
    else ;
    
#line 2509 
    __skb_put(skb,len);
  }
  else ;
  
#line 2511 
  __retres = 0;
  return_label: 
#line 2511 
                return __retres;
}


#line 2865 
void skb_clone_tx_timestamp(struct sk_buff *);


#line 2911 
void skb_tstamp_tx(struct sk_buff *, struct skb_shared_hwtstamps *);


#line 2914  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void sw_tx_timestamp(struct sk_buff *skb)
{
  unsigned char *tmp;
  
#line 2916 
  tmp = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2916 
  ;
  
#line 2916 
  if (((int)((struct skb_shared_info *)tmp)->tx_flags & 2) != 0) {
    unsigned char *tmp_0;
    
#line 2917 
    tmp_0 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2916 
    ;
    
#line 2916 
    if (((int)((struct skb_shared_info *)tmp_0)->tx_flags & 4) == 0) 
      
#line 2918 
      skb_tstamp_tx(skb,(struct skb_shared_hwtstamps *)0); else ;
  }
  else ;
  
#line 2919 
  return;
}


#line 2933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_tx_timestamp(struct sk_buff *skb)
{
  
#line 2935 
  skb_clone_tx_timestamp(skb);
  
#line 2936 
  sw_tx_timestamp(skb);
  
#line 2937 
  return;
}


#line 3384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff const *skb)
{
  bool __retres;
  unsigned char *tmp;
  
#line 3386 
  tmp = skb_end_pointer(skb);
  
#line 3386 
  ;
  
#line 3386 
  __retres = (_Bool)((unsigned int)((struct skb_shared_info *)tmp)->gso_size != 0U);
  
#line 3386 
  return __retres;
}


#line 3390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static bool skb_is_gso_v6(struct sk_buff const *skb)
{
  bool __retres;
  unsigned char *tmp;
  
#line 3392 
  tmp = skb_end_pointer(skb);
  
#line 3392 
  ;
  
#line 3392 
  __retres = (_Bool)(((int)((struct skb_shared_info *)tmp)->gso_type & 16) != 0);
  
#line 3392 
  return __retres;
}


#line 3426  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff const *skb)
{
  
#line 3428 
  return;
}


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
void synchronize_irq(unsigned int);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_79(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 153 
static void ldv_free_irq_80(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 192 
void disable_irq(unsigned int);


#line 194 
void enable_irq(unsigned int);


#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
__inline static struct mii_ioctl_data *if_mii(struct ifreq *rq)
{
  struct mii_ioctl_data *__retres;
  
#line 47 
  __retres = (struct mii_ioctl_data *)(& rq->ifr_ifru);
  
#line 47 
  return __retres;
}


#line 391  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void __napi_schedule(struct napi_struct *);


#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n)
{
  bool __retres;
  int tmp;
  
#line 396 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& n->state));
  
#line 396 
  __retres = (_Bool)(tmp != 0);
  
#line 396 
  return __retres;
}


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n)
{
  bool __retres;
  int tmp_2;
  int tmp_0;
  bool tmp;
  
#line 410 
  tmp = napi_disable_pending(n);
  
#line 410 
  if (tmp) 
#line 410 
           tmp_0 = 0; else 
#line 410 
                           tmp_0 = 1;
  
#line 410 
  if (tmp_0) {
    int tmp_1;
    
#line 410 
    tmp_1 = test_and_set_bit(0L,(unsigned long volatile *)(& n->state));
    
#line 410 
    if (tmp_1 == 0) 
#line 410 
                    tmp_2 = 1; else 
#line 410 
                                    tmp_2 = 0;
  }
  else 
#line 410 
       tmp_2 = 0;
  
#line 410 
  __retres = (_Bool)(tmp_2 != 0);
  
#line 410 
  return __retres;
}


#line 450 
void napi_complete_done(struct napi_struct *, int);


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n)
{
  
#line 460 
  napi_complete_done(n,0);
  
#line 461 
  return;
}


#line 496 
void napi_disable(struct napi_struct *);


#line 505  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  int tmp;
  
#line 507 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& n->state));
  
#line 507 
  if ((long)(tmp == 0) != 0L) {
    
#line 509 
    ldv_inline_asm();
    
#line 507 
    ;
  }
  else ;
  
#line 509 
  ldv_inline_asm();
  
#line 509 
  set_bit(0L,(unsigned long volatile *)(& n->state));
  
#line 510 
  return;
}


#line 1822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev, unsigned int index)
{
  struct netdev_queue *__retres;
  
#line 1825 
  __retres = dev->_tx + index;
  
#line 1825 
  return __retres;
}


#line 1880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device const *dev)
{
  void *__retres;
  
#line 1882 
  __retres = (void *)dev + 3008U;
  
#line 1882 
  return __retres;
}


#line 1911 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);


#line 2205 
static void ldv_free_netdev_83(struct net_device *ldv_func_arg1);


#line 2209 
static void ldv_free_netdev_85(struct net_device *ldv_func_arg1);


#line 2505 
void netif_schedule_queue(struct netdev_queue *);


#line 2515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  
#line 2517 
  set_bit(0L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2518 
  return;
}


#line 2526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_start_queue(struct net_device *dev)
{
  struct netdev_queue *tmp;
  
#line 2528 
  tmp = netdev_get_tx_queue((struct net_device const *)dev,0U);
  
#line 2528 
  netif_tx_start_queue(tmp);
  
#line 2529 
  return;
}


#line 2541 
void netif_tx_wake_queue(struct netdev_queue *);


#line 2550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_wake_queue(struct net_device *dev)
{
  struct netdev_queue *tmp;
  
#line 2552 
  tmp = netdev_get_tx_queue((struct net_device const *)dev,0U);
  
#line 2552 
  netif_tx_wake_queue(tmp);
  
#line 2553 
  return;
}


#line 2584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  int tmp;
  
#line 2586 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev_queue->state));
  
#line 2586 
  __retres = (_Bool)(tmp != 0);
  
#line 2586 
  return __retres;
}


#line 2595  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_queue_stopped(struct net_device const *dev)
{
  bool tmp_0;
  struct netdev_queue *tmp;
  
#line 2597 
  tmp = netdev_get_tx_queue(dev,0U);
  
#line 2597 
  tmp_0 = netif_tx_queue_stopped((struct netdev_queue const *)tmp);
  
#line 2597 
  return tmp_0;
}


#line 2600  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_xmit_stopped(struct netdev_queue const *dev_queue)
{
  bool __retres;
  
#line 2602 
  __retres = (_Bool)((dev_queue->state & 3UL) != 0UL);
  
#line 2602 
  return __retres;
}


#line 2645  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2649 
  dql_queued(& dev_queue->dql,bytes);
  
#line 2651 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2651 
  if ((long)(tmp >= 0) != 0L) 
#line 2652 
                              goto return_label; else ;
  
#line 2654 
  set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2655 
  ldv_inline_asm();
  
#line 2664 
  tmp_0 = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2664 
  if ((long)(tmp_0 >= 0) != 0L) 
#line 2665 
                                set_bit(1L,(unsigned long volatile *)(& dev_queue->state)); else ;
  return_label: 
#line 2666 
                return;
}


#line 2678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_sent_queue(struct net_device *dev, unsigned int bytes)
{
  struct netdev_queue *tmp;
  
#line 2680 
  ;
  
#line 2680 
  tmp = netdev_get_tx_queue((struct net_device const *)dev,0U);
  
#line 2680 
  netdev_tx_sent_queue(tmp,bytes);
  
#line 2681 
  return;
}


#line 2683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue, unsigned int pkts, unsigned int bytes)
{
  int tmp;
  int tmp_0;
  
#line 2687 
  if ((long)(bytes == 0U) != 0L) 
#line 2688 
                                 goto return_label; else ;
  
#line 2690 
  dql_completed(& dev_queue->dql,bytes);
  
#line 2691 
  ldv_inline_asm();
  
#line 2699 
  tmp = dql_avail((struct dql const *)(& dev_queue->dql));
  
#line 2699 
  if (tmp < 0) 
#line 2700 
               goto return_label; else ;
  
#line 2702 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& dev_queue->state));
  
#line 2702 
  if (tmp_0 != 0) 
#line 2703 
                  netif_schedule_queue(dev_queue); else ;
  return_label: 
#line 2704 
                return;
}


#line 2717  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_completed_queue(struct net_device *dev, unsigned int pkts, unsigned int bytes)
{
  struct netdev_queue *tmp;
  
#line 2720 
  ;
  
#line 2720 
  ;
  
#line 2720 
  tmp = netdev_get_tx_queue((struct net_device const *)dev,0U);
  
#line 2720 
  netdev_tx_completed_queue(tmp,pkts,bytes);
  
#line 2721 
  return;
}


#line 2723  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q)
{
  
#line 2726 
  set_bit(1L,(unsigned long volatile *)(& q->state));
  
#line 2727 
  dql_reset(& q->dql);
  
#line 2728 
  return;
}


#line 2738  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netdev_reset_queue(struct net_device *dev_queue)
{
  struct netdev_queue *tmp;
  
#line 2740 
  tmp = netdev_get_tx_queue((struct net_device const *)dev_queue,0U);
  
#line 2740 
  netdev_tx_reset_queue(tmp);
  
#line 2741 
  return;
}


#line 2769  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 2771 
  tmp = constant_test_bit(0L,(unsigned long const volatile *)(& dev->state));
  
#line 2771 
  __retres = (_Bool)(tmp != 0);
  
#line 2771 
  return __retres;
}


#line 2900 
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);


#line 2931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  
#line 2933 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  
#line 2934 
  return;
}


#line 2948 
gro_result_t napi_gro_receive(struct napi_struct *, struct sk_buff *);


#line 2950 
struct sk_buff *napi_get_frags(struct napi_struct *);


#line 2951 
gro_result_t napi_gro_frags(struct napi_struct *);


#line 2955  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void napi_free_frags(struct napi_struct *napi)
{
  
#line 2957 
  kfree_skb(napi->skb);
  
#line 2958 
  napi->skb = (struct sk_buff *)0;
  
#line 2959 
  return;
}


#line 3038  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device const *dev)
{
  bool __retres;
  int tmp;
  
#line 3040 
  tmp = constant_test_bit(2L,(unsigned long const volatile *)(& dev->state));
  
#line 3040 
  __retres = (_Bool)(tmp == 0);
  
#line 3040 
  return __retres;
}


#line 3047 
void netif_carrier_on(struct net_device *);


#line 3049 
void netif_carrier_off(struct net_device *);


#line 3117 
void netif_device_detach(struct net_device *);


#line 3119 
void netif_device_attach(struct net_device *);


#line 3159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
{
  u32 __retres;
  
#line 3162 
  if ((unsigned int)debug_value > 31U) {
    
#line 3163 
    __retres = (unsigned int)default_msg_enable_bits;
    
#line 3163 
    goto return_label;
  }
  else ;
  
#line 3164 
  if (debug_value == 0) {
    
#line 3165 
    __retres = 0U;
    
#line 3165 
    goto return_label;
  }
  else ;
  
#line 3167 
  __retres = (unsigned int)((1 << debug_value) + -1);
  return_label: 
#line 3167 
                return __retres;
}


#line 3170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
  
#line 3172 
  ldv_spin_lock_60(& txq->_xmit_lock);
  
#line 3173 
  txq->xmit_lock_owner = cpu;
  
#line 3174 
  return;
}


#line 3190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq)
{
  
#line 3192 
  txq->xmit_lock_owner = -1;
  
#line 3193 
  ldv_spin_unlock_63(& txq->_xmit_lock);
  
#line 3194 
  return;
}


#line 3282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev)
{
  unsigned int i;
  int cpu;
  int tmp_3;
  
#line 3287 
  local_bh_disable();
  {
    int pscr_ret__;
    {
      
#line 3288 
      void const *__vpp_verify = (void const *)0;
      
#line 3288 
      void const *tmp = __vpp_verify;
    }
    
#line 3288 
    switch (4UL) {
      int tmp_0;
      int tmp_0_0;
      int tmp_1;
      int tmp_2;
      case (unsigned long)1: 
#line 3288 
      ;
      {
        int pfo_ret__;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45463;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45463;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45463;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45463;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45463: 
#line 3288 
        ;
        
#line 3288 
        tmp_0 = pfo_ret__;
      }
      
#line 3288 
      pscr_ret__ = tmp_0;
      
#line 3288 
      goto ldv_45469;
      case (unsigned long)2: 
#line 3288 
      ;
      {
        int pfo_ret___0;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45473;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45473;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45473;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45473;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45473: 
#line 3288 
        ;
        
#line 3288 
        tmp_0_0 = pfo_ret___0;
      }
      
#line 3288 
      pscr_ret__ = tmp_0_0;
      
#line 3288 
      goto ldv_45469;
      case (unsigned long)4: 
#line 3288 
      ;
      {
        int pfo_ret___1;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45482;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45482;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45482;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45482;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45482: 
#line 3288 
        ;
        
#line 3288 
        tmp_1 = pfo_ret___1;
      }
      
#line 3288 
      pscr_ret__ = tmp_1;
      
#line 3288 
      goto ldv_45469;
      case (unsigned long)8: 
#line 3288 
      ;
      {
        int pfo_ret___2;
        
#line 3288 
        switch (4UL) {
          case (unsigned long)1: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45491;
          case (unsigned long)2: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45491;
          case (unsigned long)4: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45491;
          case (unsigned long)8: 
#line 3288 
          ;
          
#line 3289 
          ldv_inline_asm();
          
#line 3288 
          goto ldv_45491;
          default: 
#line 3288 
          ;
          
#line 3288 
          __bad_percpu_size();
        }
        ldv_45491: 
#line 3288 
        ;
        
#line 3288 
        tmp_2 = pfo_ret___2;
      }
      
#line 3288 
      pscr_ret__ = tmp_2;
      
#line 3288 
      goto ldv_45469;
      default: 
#line 3288 
      ;
      
#line 3288 
      __bad_size_call_parameter();
      
#line 3288 
      goto ldv_45469;
    }
    ldv_45469: 
#line 3288 
    ;
    
#line 3288 
    tmp_3 = pscr_ret__;
  }
  
#line 3288 
  cpu = tmp_3;
  
#line 3289 
  i = 0U;
  
#line 3289 
  goto ldv_45501;
  ldv_45500: 
#line 3290 
  ;
  {
    
#line 3290 
    struct netdev_queue *txq = netdev_get_tx_queue((struct net_device const *)dev,i);
    
#line 3292 
    __netif_tx_lock(txq,cpu);
    
#line 3293 
    netif_tx_start_queue(txq);
    
#line 3294 
    __netif_tx_unlock(txq);
  }
  
#line 3289 
  i += 1U;
  ldv_45501: 
#line 3290 
  ;
  
#line 3289 
  if (dev->num_tx_queues > i) 
#line 3291 
                              goto ldv_45500; else 
#line 3294 
                                                   goto ldv_45502;
  ldv_45502: 
#line 3295 
  ;
  
#line 3296 
  local_bh_enable();
  
#line 3297 
  return;
}


#line 3355 
static int ldv_register_netdev_82(struct net_device *ldv_func_arg1);


#line 3360 
static void ldv_unregister_netdev_84(struct net_device *ldv_func_arg1);


#line 3828 
void netdev_err(struct net_device const *, char const * , ...);


#line 3830 
void netdev_warn(struct net_device const *, char const * , ...);


#line 3834 
void netdev_info(struct net_device const *, char const * , ...);


#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__be16 eth_type_trans(struct sk_buff *, struct net_device *);


#line 47 
int eth_validate_addr(struct net_device *);


#line 53 
static struct net_device *ldv_alloc_etherdev_mqs_81(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 96 
  __retres = (_Bool)((*((u32 const *)addr) | (unsigned int)*((u16 const *)(addr + 4U))) == 0U);
  
#line 96 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 161 
  __retres = (_Bool)((unsigned int)(((int)*((u16 const *)addr) & (int)*((u16 const *)(addr + 2U))) & (int)*((u16 const *)(addr + 4U))) == 65535U);
  
#line 161 
  return __retres;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_3;
  int tmp_0;
  bool tmp;
  
#line 190 
  tmp = is_multicast_ether_addr(addr);
  
#line 190 
  if (tmp) 
#line 190 
           tmp_0 = 0; else 
#line 190 
                           tmp_0 = 1;
  
#line 190 
  if (tmp_0) {
    int tmp_2;
    bool tmp_1;
    
#line 190 
    tmp_1 = is_zero_ether_addr(addr);
    
#line 190 
    if (tmp_1) 
#line 190 
               tmp_2 = 0; else 
#line 190 
                               tmp_2 = 1;
    
#line 190 
    if (tmp_2) 
#line 190 
               tmp_3 = 1; else 
#line 190 
                               tmp_3 = 0;
  }
  else 
#line 190 
       tmp_3 = 0;
  
#line 190 
  __retres = (_Bool)(tmp_3 != 0);
  
#line 190 
  return __retres;
}


#line 445  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static int eth_skb_pad(struct sk_buff *skb)
{
  int tmp;
  
#line 447 
  tmp = skb_put_padto(skb,60U);
  
#line 447 
  return tmp;
}


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vzalloc(unsigned long);


#line 83 
void vfree(void const *);


#line 7  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
__inline static void pagefault_disabled_inc(void)
{
  struct task_struct *tmp;
  
#line 9 
  tmp = get_current();
  
#line 9 
  tmp->pagefault_disabled += 1;
  
#line 10 
  return;
}


#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
__inline static void pagefault_disabled_dec(void)
{
  struct task_struct *tmp;
  
#line 14 
  tmp = get_current();
  
#line 14 
  tmp->pagefault_disabled -= 1;
  {
    struct task_struct *tmp_0;
    
#line 15 
    tmp_0 = get_current();
    
#line 15 
    int __ret_warn_on = tmp_0->pagefault_disabled < 0;
    
#line 15 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 15 
                                          warn_slowpath_null("include/linux/uaccess.h",15); else ;
    
#line 15 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 17 
  return;
}


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
__inline static void pagefault_disable(void)
{
  
#line 27 
  pagefault_disabled_inc();
  
#line 28 
  ldv_inline_asm();
  
#line 29 
  return;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uaccess.h"
__inline static void pagefault_enable(void)
{
  
#line 37 
  ldv_inline_asm();
  
#line 42 
  pagefault_disabled_dec();
  
#line 43 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page)
{
  void *tmp;
  
#line 68 
  __preempt_count_add(1);
  
#line 69 
  ldv_inline_asm();
  
#line 69 
  pagefault_disable();
  
#line 70 
  tmp = lowmem_page_address((struct page const *)page);
  
#line 70 
  return tmp;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr)
{
  
#line 76 
  pagefault_enable();
  
#line 77 
  ldv_inline_asm();
  
#line 77 
  __preempt_count_sub(1);
  
#line 78 
  return;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb)
{
  struct iphdr *tmp;
  
#line 25 
  tmp = (struct iphdr *)skb_network_header(skb);
  
#line 25 
  return tmp;
}


#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static struct tcphdr *tcp_hdr(struct sk_buff const *skb)
{
  struct tcphdr *tmp;
  
#line 29 
  tmp = (struct tcphdr *)skb_transport_header(skb);
  
#line 29 
  return tmp;
}


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tcp.h"
__inline static unsigned int tcp_hdrlen(struct sk_buff const *skb)
{
  unsigned int __retres;
  struct tcphdr *tmp;
  
#line 34 
  tmp = tcp_hdr(skb);
  
#line 34 
  ;
  
#line 34 
  __retres = (unsigned int)((int)tmp->doff * 4);
  
#line 34 
  return __retres;
}


#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff const *skb)
{
  struct ipv6hdr *tmp;
  
#line 76 
  tmp = (struct ipv6hdr *)skb_network_header(skb);
  
#line 76 
  return tmp;
}


#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)
{
  
#line 412 
  skb->vlan_proto = vlan_proto;
  
#line 413 
  skb->vlan_tci = (unsigned short)((unsigned int)vlan_tci | 4096U);
  
#line 414 
  return;
}


#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static __be16 __vlan_get_protocol(struct sk_buff *skb, __be16 type, int *depth)
{
  __be16 __retres;
  
#line 484 
  unsigned int vlan_depth = (unsigned int)skb->mac_len;
  
#line 490 
  if ((unsigned int)type == 129U || (unsigned int)type == 43144U) {
    
#line 491 
    if (vlan_depth != 0U) {
      int tmp;
      {
        
#line 492 
        int __ret_warn_on = vlan_depth <= 3U;
        
#line 492 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 492 
                                              warn_slowpath_null("include/linux/if_vlan.h",492); else ;
        
#line 492 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 492 
      if ((long)tmp != 0L) {
        
#line 493 
        __retres = (unsigned short)0U;
        
#line 493 
        goto return_label;
      }
      else ;
      
#line 494 
      vlan_depth += 4294967292U;
    }
    else 
#line 496 
         vlan_depth = 14U;
    ldv_52246: 
#line 497 
    ;
    {
      struct vlan_hdr *vh;
      int tmp_0;
      
#line 501 
      tmp_0 = pskb_may_pull(skb,vlan_depth + 4U);
      
#line 501 
      if ((long)(tmp_0 == 0) != 0L) {
        
#line 503 
        __retres = (unsigned short)0U;
        
#line 503 
        goto return_label;
      }
      else ;
      
#line 505 
      vh = (struct vlan_hdr *)(skb->data + vlan_depth);
      
#line 506 
      type = vh->h_vlan_encapsulated_proto;
      
#line 507 
      vlan_depth += 4U;
    }
    
#line 509 
    if ((unsigned int)type == 129U || (unsigned int)type == 43144U) 
#line 511 
                                                                    goto ldv_52246; else 
                                                                    
#line 514 
                                                                    goto ldv_52247;
    ldv_52247: 
#line 515 
    ;
  }
  else ;
  
#line 512 
  if (depth != (int *)0) 
#line 513 
                         *depth = (int)vlan_depth; else ;
  
#line 515 
  __retres = type;
  return_label: 
#line 515 
                return __retres;
}


#line 525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_vlan.h"
__inline static __be16 vlan_get_protocol(struct sk_buff *skb)
{
  __be16 tmp;
  
#line 527 
  tmp = __vlan_get_protocol(skb,(unsigned short)((int)skb->protocol),(int *)0);
  
#line 527 
  return tmp;
}


#line 292  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
s32 e1000_reset_hw(struct e1000_hw *hw);


#line 293 
s32 e1000_init_hw(struct e1000_hw *hw);


#line 294 
s32 e1000_set_mac_type(struct e1000_hw *hw);


#line 295 
void e1000_set_media_type(struct e1000_hw *hw);


#line 299 
s32 e1000_phy_setup_autoneg(struct e1000_hw *hw);


#line 300 
void e1000_config_collision_dist(struct e1000_hw *hw);


#line 301 
s32 e1000_check_for_link(struct e1000_hw *hw);


#line 302 
s32 e1000_get_speed_and_duplex(struct e1000_hw *hw, u16 *speed, u16 *duplex);


#line 306 
s32 e1000_read_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data);


#line 307 
s32 e1000_write_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 phy_data);


#line 308 
s32 e1000_phy_hw_reset(struct e1000_hw *hw);


#line 309 
s32 e1000_phy_reset(struct e1000_hw *hw);


#line 310 
s32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info);


#line 314 
s32 e1000_init_eeprom_params(struct e1000_hw *hw);


#line 317 
u32 e1000_enable_mng_pass_thru(struct e1000_hw *hw);


#line 372 
s32 e1000_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data);


#line 373 
s32 e1000_validate_eeprom_checksum(struct e1000_hw *hw);


#line 376 
s32 e1000_read_mac_addr(struct e1000_hw *hw);


#line 379 
u32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr);


#line 381 
void e1000_rar_set(struct e1000_hw *hw, u8 *addr, u32 index);


#line 382 
void e1000_write_vfta(struct e1000_hw *hw, u32 offset, u32 value);


#line 394 
void e1000_reset_adaptive(struct e1000_hw *hw);


#line 395 
void e1000_update_adaptive(struct e1000_hw *hw);


#line 396 
void e1000_get_bus_info(struct e1000_hw *hw);


#line 397 
void e1000_pci_set_mwi(struct e1000_hw *hw);


#line 398 
void e1000_pci_clear_mwi(struct e1000_hw *hw);


#line 399 
void e1000_pcix_set_mmrbc(struct e1000_hw *hw, int mmrbc);


#line 400 
int e1000_pcix_get_mmrbc(struct e1000_hw *hw);


#line 402 
void e1000_io_write(struct e1000_hw *hw, unsigned long port, u32 value);


#line 337  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000.h"
struct net_device *e1000_get_hw_dev(struct e1000_hw *hw);


#line 355 
char e1000_driver_name[6U];


#line 356 
char const e1000_driver_version[15U];


#line 358 
int e1000_up(struct e1000_adapter *adapter);


#line 359 
void e1000_down(struct e1000_adapter *adapter);


#line 360 
void e1000_reinit_locked(struct e1000_adapter *adapter);


#line 361 
void e1000_reset(struct e1000_adapter *adapter);


#line 362 
int e1000_set_spd_dplx(struct e1000_adapter *adapter, u32 spd, u8 dplx);


#line 363 
int e1000_setup_all_rx_resources(struct e1000_adapter *adapter);


#line 364 
int e1000_setup_all_tx_resources(struct e1000_adapter *adapter);


#line 365 
void e1000_free_all_rx_resources(struct e1000_adapter *adapter);


#line 366 
void e1000_free_all_tx_resources(struct e1000_adapter *adapter);


#line 367 
void e1000_update_stats(struct e1000_adapter *adapter);


#line 368 
bool e1000_has_link(struct e1000_adapter *adapter);


#line 369 
void e1000_power_up_phy(struct e1000_adapter *adapter);


#line 370 
void e1000_set_ethtool_ops(struct net_device *netdev);


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
char e1000_driver_name[6U] = {(char)'e', (char)'1', (char)'0', (char)'0', (char)'0', (char)'\000'};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static char e1000_driver_string[33U] = {(char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)'(', (char)'R', (char)')', (char)' ', (char)'P', (char)'R', (char)'O', (char)'/', (char)'1', (char)'0', (char)'0', (char)'0', (char)' ', (char)'N', (char)'e', (char)'t', (char)'w', (char)'o', (char)'r', (char)'k', (char)' ', (char)'D', (char)'r', (char)'i', (char)'v', (char)'e', (char)'r', (char)'\000'};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
char const e1000_driver_version[15U] = {(char)'7', (char)'.', (char)'3', (char)'.', (char)'2', (char)'1', (char)'-', (char)'k', (char)'8', (char)'-', (char)'N', (char)'A', (char)'P', (char)'I', (char)'\000'};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static char const e1000_copyright[43U] = {(char)'C', (char)'o', (char)'p', (char)'y', (char)'r', (char)'i', (char)'g', (char)'h', (char)'t', (char)' ', (char)'(', (char)'c', (char)')', (char)' ', (char)'1', (char)'9', (char)'9', (char)'9', (char)'-', (char)'2', (char)'0', (char)'0', (char)'6', (char)' ', (char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)' ', (char)'C', (char)'o', (char)'r', (char)'p', (char)'o', (char)'r', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'.', (char)'\000'};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static struct pci_device_id const e1000_pci_tbl[38U] = {{.vendor = 32902U, .device = 4096U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4097U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4100U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4104U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4105U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4108U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4109U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4110U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4111U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4112U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4113U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4114U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4115U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4116U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4117U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4118U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4119U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4120U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4121U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4122U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4125U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4126U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4134U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4135U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4136U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4213U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4214U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4215U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4216U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4217U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4218U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4219U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4220U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4234U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4249U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 4277U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 32902U, .device = 11886U, .subvendor = 4294967295U, .subdevice = 4294967295U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
struct pci_device_id const __mod_pci__e1000_pci_tbl_device_table[38U];

#line 101 
static int e1000_setup_tx_resources(struct e1000_adapter *adapter, struct e1000_tx_ring *txdr);


#line 103 
static int e1000_setup_rx_resources(struct e1000_adapter *adapter, struct e1000_rx_ring *rxdr);


#line 105 
static void e1000_free_tx_resources(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring);


#line 107 
static void e1000_free_rx_resources(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring);


#line 111 
static int e1000_init_module(void);


#line 112 
static void e1000_exit_module(void);


#line 113 
static int e1000_probe(struct pci_dev *pdev, struct pci_device_id const *ent);


#line 114 
static void e1000_remove(struct pci_dev *pdev);


#line 115 
static int e1000_alloc_queues(struct e1000_adapter *adapter);


#line 116 
static int e1000_sw_init(struct e1000_adapter *adapter);


#line 117 
static int e1000_open(struct net_device *netdev);


#line 118 
static int e1000_close(struct net_device *netdev);


#line 119 
static void e1000_configure_tx(struct e1000_adapter *adapter);


#line 120 
static void e1000_configure_rx(struct e1000_adapter *adapter);


#line 121 
static void e1000_setup_rctl(struct e1000_adapter *adapter);


#line 122 
static void e1000_clean_all_tx_rings(struct e1000_adapter *adapter);


#line 123 
static void e1000_clean_all_rx_rings(struct e1000_adapter *adapter);


#line 124 
static void e1000_clean_tx_ring(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring);


#line 126 
static void e1000_clean_rx_ring(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring);


#line 128 
static void e1000_set_rx_mode(struct net_device *netdev);


#line 129 
static void e1000_update_phy_info_task(struct work_struct *work);


#line 130 
static void e1000_watchdog(struct work_struct *work);


#line 131 
static void e1000_82547_tx_fifo_stall_task(struct work_struct *work);


#line 132 
static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb, struct net_device *netdev);


#line 134 
static struct net_device_stats *e1000_get_stats(struct net_device *netdev);


#line 135 
static int e1000_change_mtu(struct net_device *netdev, int new_mtu);


#line 136 
static int e1000_set_mac(struct net_device *netdev, void *p);


#line 137 
static irqreturn_t e1000_intr(int irq, void *data);


#line 138 
static bool e1000_clean_tx_irq(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring);


#line 140 
static int e1000_clean(struct napi_struct *napi, int budget);


#line 141 
static bool e1000_clean_rx_irq(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int *work_done, int work_to_do);


#line 144 
static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int *work_done, int work_to_do);


#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int cleaned_count)
{
  
#line 149 
  return;
}


#line 152 
static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int cleaned_count);


#line 155 
static void e1000_alloc_jumbo_rx_buffers(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int cleaned_count);


#line 158 
static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);


#line 159 
static int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);


#line 161 
static void e1000_enter_82542_rst(struct e1000_adapter *adapter);


#line 162 
static void e1000_leave_82542_rst(struct e1000_adapter *adapter);


#line 163 
static void e1000_tx_timeout(struct net_device *netdev);


#line 164 
static void e1000_reset_task(struct work_struct *work);


#line 165 
static void e1000_smartspeed(struct e1000_adapter *adapter);


#line 166 
static int e1000_82547_fifo_workaround(struct e1000_adapter *adapter, struct sk_buff *skb);


#line 169 
static bool e1000_vlan_used(struct e1000_adapter *adapter);


#line 170 
static void e1000_vlan_mode(struct net_device *netdev, netdev_features_t features);


#line 172 
static void e1000_vlan_filter_on_off(struct e1000_adapter *adapter, bool filter_on);


#line 174 
static int e1000_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid);


#line 176 
static int e1000_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid);


#line 178 
static void e1000_restore_vlan(struct e1000_adapter *adapter);


#line 181 
static int e1000_suspend(struct pci_dev *pdev, pm_message_t state);


#line 182 
static int e1000_resume(struct pci_dev *pdev);


#line 184 
static void e1000_shutdown(struct pci_dev *pdev);


#line 188 
static void e1000_netpoll(struct net_device *netdev);


#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static unsigned int copybreak = 256U;

#line 197 
static pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state);


#line 199 
static pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev);


#line 200 
static void e1000_io_resume(struct pci_dev *pdev);


#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static struct pci_error_handlers const e1000_err_handler = {.error_detected = (pci_ers_result_t (*)(struct pci_dev *, enum pci_channel_state ))(& e1000_io_error_detected), .mmio_enabled = (pci_ers_result_t (*)(struct pci_dev *))0, .link_reset = (pci_ers_result_t (*)(struct pci_dev *))0, .slot_reset = & e1000_io_slot_reset, .reset_notify = (void (*)(struct pci_dev *, bool ))0, .resume = & e1000_io_resume};

#line 208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static struct pci_driver e1000_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = (char const *)(& e1000_driver_name), .id_table = (struct pci_device_id const *)(& e1000_pci_tbl), .probe = & e1000_probe, .remove = & e1000_remove, .suspend = & e1000_suspend, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = & e1000_resume, .shutdown = & e1000_shutdown, .sriov_configure = (int (*)(struct pci_dev *, int ))0, .err_handler = & e1000_err_handler, .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = (struct dev_pm_ops const *)0, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int debug = -1;

#line 237  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
struct net_device *e1000_get_hw_dev(struct e1000_hw *hw)
{
  struct net_device *__retres;
  
#line 239 
  struct e1000_adapter *adapter = (struct e1000_adapter *)hw->back;
  
#line 240 
  __retres = adapter->netdev;
  
#line 240 
  return __retres;
}


#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_init_module(void)
{
  int ret;
  
#line 252 
  printk("\001",(char *)(& e1000_driver_string),(char const *)(& e1000_driver_version));
  
#line 254 
  printk("\001",(char const *)(& e1000_copyright));
  
#line 256 
  ret = ldv___pci_register_driver_77(& e1000_driver,& __this_module,"e1000");
  
#line 257 
  if (copybreak != 256U) 
    
#line 258 
    if (copybreak == 0U) 
#line 259 
                         printk("\001"); else 
#line 261 
                                              printk("\001",copybreak);
  else ;
  
#line 264 
  return ret;
}


#line 275  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_exit_module(void)
{
  
#line 277 
  ldv_pci_unregister_driver_78(& e1000_driver);
  
#line 278 
  return;
}


#line 282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_request_irq(struct e1000_adapter *adapter)
{
  int err;
  
#line 284 
  struct net_device *netdev = adapter->netdev;
  
#line 285 
  irqreturn_t (*handler)(int , void *) = & e1000_intr;
  
#line 286 
  int irq_flags = 128;
  
#line 289 
  err = ldv_request_irq_79((adapter->pdev)->irq,handler,(unsigned long)irq_flags,(char const *)(& netdev->name),(void *)netdev);
  
#line 291 
  if (err != 0) {
    
#line 292 
    if ((adapter->msg_enable & 2) != 0) 
#line 292 
                                        netdev_err((struct net_device const *)adapter->netdev,"Unable to allocate interrupt Error: %d\n",err); else ;
  }
  else ;
  
#line 295 
  return err;
}


#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_free_irq(struct e1000_adapter *adapter)
{
  
#line 300 
  struct net_device *netdev = adapter->netdev;
  
#line 302 
  ldv_free_irq_80((adapter->pdev)->irq,(void *)netdev);
  
#line 303 
  return;
}


#line 309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_irq_disable(struct e1000_adapter *adapter)
{
  
#line 311 
  struct e1000_hw *hw = & adapter->hw;
  
#line 313 
  writel(4294967295U,(void volatile *)(hw->hw_addr + 216U));
  
#line 314 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 315 
  synchronize_irq((adapter->pdev)->irq);
  
#line 316 
  return;
}


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_irq_enable(struct e1000_adapter *adapter)
{
  
#line 324 
  struct e1000_hw *hw = & adapter->hw;
  
#line 326 
  writel(157U,(void volatile *)(hw->hw_addr + 208U));
  
#line 327 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 328 
  return;
}


#line 330  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_update_mng_vlan(struct e1000_adapter *adapter)
{
  int tmp_0;
  bool tmp;
  int tmp_6;
  
#line 332 
  struct e1000_hw *hw = & adapter->hw;
  
#line 333 
  struct net_device *netdev = adapter->netdev;
  
#line 334 
  u16 vid = hw->mng_cookie.vlan_id;
  
#line 335 
  u16 old_vid = adapter->mng_vlan_id;
  
#line 337 
  tmp = e1000_vlan_used(adapter);
  
#line 337 
  if (tmp) 
#line 337 
           tmp_0 = 0; else 
#line 337 
                           tmp_0 = 1;
  
#line 337 
  if (tmp_0) 
#line 338 
             goto return_label; else ;
  
#line 340 
  if (0 != 0) {
    int tmp_4;
    
#line 340 
    tmp_4 = constant_test_bit((long)vid,(unsigned long const volatile *)(& adapter->active_vlans));
    
#line 340 
    tmp_6 = tmp_4 == 0;
  }
  else {
    int tmp_5;
    
#line 340 
    tmp_5 = variable_test_bit((long)vid,(unsigned long const volatile *)(& adapter->active_vlans));
    
#line 340 
    tmp_6 = tmp_5 == 0;
  }
  
#line 340 
  if (tmp_6) {
    
#line 341 
    if (((int)hw->mng_cookie.status & 2) != 0) {
      
#line 343 
      e1000_vlan_rx_add_vid(netdev,(unsigned short)129,(unsigned short)((int)vid));
      
#line 344 
      adapter->mng_vlan_id = vid;
    }
    else 
#line 346 
         adapter->mng_vlan_id = (unsigned short)65535U;
    
#line 348 
    if ((unsigned int)old_vid != 65535U && (int)vid != (int)old_vid) {
      int tmp_3;
      
#line 349 
      if (0 != 0) {
        int tmp_1;
        
#line 350 
        tmp_1 = constant_test_bit((long)old_vid,(unsigned long const volatile *)(& adapter->active_vlans));
        
#line 349 
        tmp_3 = tmp_1 == 0;
      }
      else {
        int tmp_2;
        
#line 349 
        tmp_2 = variable_test_bit((long)old_vid,(unsigned long const volatile *)(& adapter->active_vlans));
        
#line 349 
        tmp_3 = tmp_2 == 0;
      }
      
#line 349 
      if (tmp_3) 
#line 351 
                 e1000_vlan_rx_kill_vid(netdev,(unsigned short)129,(unsigned short)((int)old_vid)); else ;
    }
    else ;
  }
  else 
#line 354 
       adapter->mng_vlan_id = vid;
  return_label: 
#line 355 
                return;
}


#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_init_manageability(struct e1000_adapter *adapter)
{
  
#line 360 
  struct e1000_hw *hw = & adapter->hw;
  
#line 362 
  if (adapter->en_mng_pt != 0U) {
    
#line 363 
    u32 manc = readl((void const volatile *)(hw->hw_addr + 22560U));
    
#line 366 
    manc &= 4294959103U;
    
#line 368 
    writel(manc,(void volatile *)(hw->hw_addr + 22560U));
  }
  else ;
  
#line 370 
  return;
}


#line 372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_release_manageability(struct e1000_adapter *adapter)
{
  
#line 374 
  struct e1000_hw *hw = & adapter->hw;
  
#line 376 
  if (adapter->en_mng_pt != 0U) {
    
#line 377 
    u32 manc = readl((void const volatile *)(hw->hw_addr + 22560U));
    
#line 380 
    manc |= 8192U;
    
#line 382 
    writel(manc,(void volatile *)(hw->hw_addr + 22560U));
  }
  else ;
  
#line 384 
  return;
}


#line 390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_configure(struct e1000_adapter *adapter)
{
  int i;
  
#line 392 
  struct net_device *netdev = adapter->netdev;
  
#line 395 
  e1000_set_rx_mode(netdev);
  
#line 397 
  e1000_restore_vlan(adapter);
  
#line 398 
  e1000_init_manageability(adapter);
  
#line 400 
  e1000_configure_tx(adapter);
  
#line 401 
  e1000_setup_rctl(adapter);
  
#line 402 
  e1000_configure_rx(adapter);
  
#line 407 
  i = 0;
  
#line 407 
  goto ldv_56592;
  ldv_56591: 
#line 408 
  ;
  {
    unsigned int tmp;
    
#line 408 
    struct e1000_rx_ring *ring = adapter->rx_ring + i;
    
#line 410 
    if (ring->next_to_clean <= ring->next_to_use) 
#line 410 
                                                  tmp = ring->count; else 
                                                                    
#line 410 
                                                                    tmp = 0U;
    
#line 409 
    ;
    
#line 409 
    ;
    
#line 409 
    ;
    
#line 409 
    (*(adapter->alloc_rx_buf))(adapter,ring,(int)(((tmp + ring->next_to_clean) - ring->next_to_use) + 4294967295U));
  }
  
#line 407 
  i += 1;
  ldv_56592: 
#line 408 
  ;
  
#line 407 
  if (adapter->num_rx_queues > i) 
#line 409 
                                  goto ldv_56591; else 
#line 412 
                                                       goto ldv_56593;
  ldv_56593: 
#line 413 
  ;
  
#line 414 
  return;
}


#line 414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
int e1000_up(struct e1000_adapter *adapter)
{
  int __retres;
  
#line 416 
  struct e1000_hw *hw = & adapter->hw;
  
#line 419 
  e1000_configure(adapter);
  
#line 421 
  set_bit(2L,(unsigned long volatile *)(& adapter->flags));
  
#line 423 
  napi_enable(& adapter->napi);
  
#line 425 
  e1000_irq_enable(adapter);
  
#line 427 
  netif_wake_queue(adapter->netdev);
  
#line 430 
  writel(4U,(void volatile *)(hw->hw_addr + 200U));
  
#line 431 
  __retres = 0;
  
#line 431 
  return __retres;
}


#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_power_up_phy(struct e1000_adapter *adapter)
{
  
#line 444 
  struct e1000_hw *hw = & adapter->hw;
  
#line 445 
  u16 mii_reg = (unsigned short)0U;
  
#line 448 
  if (hw->media_type == (unsigned int)e1000_media_type_copper) {
    
#line 452 
    e1000_read_phy_reg(hw,0U,& mii_reg);
    
#line 453 
    mii_reg = (unsigned short)((unsigned int)mii_reg & 63487U);
    
#line 454 
    e1000_write_phy_reg(hw,0U,(unsigned short)((int)mii_reg));
  }
  else ;
  
#line 456 
  return;
}


#line 458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_power_down_phy(struct e1000_adapter *adapter)
{
  
#line 460 
  struct e1000_hw *hw = & adapter->hw;
  
#line 468 
  if ((adapter->wol == 0U && hw->mac_type > (unsigned int)e1000_82544) && hw->media_type == (unsigned int)e1000_media_type_copper) {
    
#line 470 
    u16 mii_reg = (unsigned short)0U;
    
#line 472 
    switch ((unsigned int)hw->mac_type) {
      unsigned int tmp;
      case (unsigned int)5: 
#line 473 
      ;
      case (unsigned int)6: 
#line 474 
      ;
      case (unsigned int)7: 
#line 475 
      ;
      case (unsigned int)8: 
#line 476 
      ;
      case (unsigned int)9: 
#line 477 
      ;
      case (unsigned int)10: 
#line 478 
      ;
      case (unsigned int)11: 
#line 479 
      ;
      case (unsigned int)12: 
#line 480 
      ;
      case (unsigned int)13: 
#line 481 
      ;
      case (unsigned int)14: 
#line 482 
      ;
      
#line 483 
      tmp = readl((void const volatile *)(hw->hw_addr + 22560U));
      
#line 483 
      if ((tmp & 1U) != 0U) 
#line 484 
                            goto out; else ;
      
#line 485 
      goto ldv_56619;
      default: 
#line 486 
      ;
      
#line 487 
      goto out;
    }
    ldv_56619: 
#line 489 
    ;
    
#line 489 
    e1000_read_phy_reg(hw,0U,& mii_reg);
    
#line 490 
    mii_reg = (unsigned short)((unsigned int)mii_reg | 2048U);
    
#line 491 
    e1000_write_phy_reg(hw,0U,(unsigned short)((int)mii_reg));
    
#line 492 
    msleep(1U);
  }
  else ;
  out: 
#line 494 
  ;
  
#line 495 
  return;
}


#line 498  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_down_and_stop(struct e1000_adapter *adapter)
{
  int tmp;
  
#line 500 
  set_bit(2L,(unsigned long volatile *)(& adapter->flags));
  
#line 502 
  cancel_delayed_work_sync(& adapter->watchdog_task);
  
#line 510 
  cancel_delayed_work_sync(& adapter->phy_info_task);
  
#line 511 
  cancel_delayed_work_sync(& adapter->fifo_stall_task);
  
#line 514 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& adapter->flags));
  
#line 514 
  if (tmp == 0) 
#line 515 
                cancel_work_sync(& adapter->reset_task); else ;
  
#line 516 
  return;
}


#line 518  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_down(struct e1000_adapter *adapter)
{
  u32 rctl;
  u32 tctl;
  
#line 520 
  struct e1000_hw *hw = & adapter->hw;
  
#line 521 
  struct net_device *netdev = adapter->netdev;
  
#line 524 
  netif_carrier_off(netdev);
  
#line 527 
  rctl = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 528 
  writel(rctl & 4294967293U,(void volatile *)(hw->hw_addr + 256U));
  
#line 531 
  netif_tx_disable(netdev);
  
#line 534 
  tctl = readl((void const volatile *)(hw->hw_addr + 1024U));
  
#line 535 
  tctl &= 4294967293U;
  
#line 536 
  writel(tctl,(void volatile *)(hw->hw_addr + 1024U));
  
#line 538 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 539 
  msleep(10U);
  
#line 541 
  napi_disable(& adapter->napi);
  
#line 543 
  e1000_irq_disable(adapter);
  
#line 549 
  e1000_down_and_stop(adapter);
  
#line 551 
  adapter->link_speed = (unsigned short)0U;
  
#line 552 
  adapter->link_duplex = (unsigned short)0U;
  
#line 554 
  e1000_reset(adapter);
  
#line 555 
  e1000_clean_all_tx_rings(adapter);
  
#line 556 
  e1000_clean_all_rx_rings(adapter);
  
#line 557 
  return;
}


#line 559  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_reinit_locked(struct e1000_adapter *adapter)
{
  int tmp_0;
  {
    int tmp;
    
#line 561 
    tmp = preempt_count();
    
#line 561 
    int __ret_warn_on = ((unsigned long)tmp & 2096896UL) != 0UL;
    
#line 561 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 561 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c",561); else ;
    
#line 561 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 562 
  goto ldv_56637;
  ldv_56636: 
#line 563 
  ;
  
#line 563 
  msleep(1U);
  ldv_56637: 
#line 564 
  ;
  
#line 562 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 562 
  if (tmp_0 != 0) 
#line 564 
                  goto ldv_56636; else 
#line 567 
                                       goto ldv_56638;
  ldv_56638: 
#line 568 
  ;
  
#line 564 
  e1000_down(adapter);
  
#line 565 
  e1000_up(adapter);
  
#line 566 
  set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 567 
  return;
}


#line 569  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_reset(struct e1000_adapter *adapter)
{
  u32 tx_space;
  u32 min_tx_space;
  u32 min_rx_space;
  u16 hwm;
  u32 tmp_0;
  s32 tmp_1;
  
#line 571 
  struct e1000_hw *hw = & adapter->hw;
  
#line 572 
  u32 pba = 0U;
  
#line 573 
  bool legacy_pba_adjust = (_Bool)0;
  
#line 580 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)1: 
#line 581 
    ;
    case (unsigned int)2: 
#line 582 
    ;
    case (unsigned int)3: 
#line 583 
    ;
    case (unsigned int)4: 
#line 584 
    ;
    case (unsigned int)5: 
#line 585 
    ;
    case (unsigned int)11: 
#line 586 
    ;
    case (unsigned int)12: 
#line 587 
    ;
    
#line 588 
    legacy_pba_adjust = (_Bool)1;
    
#line 589 
    pba = 48U;
    
#line 590 
    goto ldv_56656;
    case (unsigned int)6: 
#line 591 
    ;
    case (unsigned int)7: 
#line 592 
    ;
    case (unsigned int)8: 
#line 593 
    ;
    case (unsigned int)9: 
#line 594 
    ;
    case (unsigned int)10: 
#line 595 
    ;
    
#line 596 
    pba = 48U;
    
#line 597 
    goto ldv_56656;
    case (unsigned int)13: 
#line 598 
    ;
    case (unsigned int)14: 
#line 599 
    ;
    
#line 600 
    legacy_pba_adjust = (_Bool)1;
    
#line 601 
    pba = 30U;
    
#line 602 
    goto ldv_56656;
    case (unsigned int)0: 
#line 603 
    ;
    case (unsigned int)15: 
#line 604 
    ;
    
#line 605 
    goto ldv_56656;
  }
  ldv_56656: 
#line 608 
  ;
  
#line 608 
  if ((int)legacy_pba_adjust != 0) {
    
#line 609 
    if (hw->max_frame_size > 8192U) 
#line 610 
                                    pba += 4294967288U; else ;
    
#line 612 
    if (hw->mac_type == (unsigned int)e1000_82547) {
      
#line 613 
      adapter->tx_fifo_head = 0U;
      
#line 614 
      adapter->tx_head_addr = pba << 7;
      
#line 615 
      adapter->tx_fifo_size = (40U - pba) << 10;
      
#line 617 
      atomic_set(& adapter->tx_fifo_stall,0);
    }
    else ;
  }
  else 
    
#line 619 
    if (hw->max_frame_size > 1518U) {
      
#line 621 
      writel(pba,(void volatile *)(hw->hw_addr + 4096U));
      
#line 630 
      pba = readl((void const volatile *)(hw->hw_addr + 4096U));
      
#line 632 
      tx_space = pba >> 16;
      
#line 634 
      pba &= 65535U;
      
#line 638 
      min_tx_space = (hw->max_frame_size + 12U) * 2U;
      
#line 641 
      min_tx_space = (min_tx_space + 1023U) & 4294966272U;
      
#line 642 
      min_tx_space >>= 10;
      
#line 644 
      min_rx_space = hw->max_frame_size;
      
#line 645 
      min_rx_space = (min_rx_space + 1023U) & 4294966272U;
      
#line 646 
      min_rx_space >>= 10;
      
#line 652 
      if (tx_space < min_tx_space && min_tx_space - tx_space < pba) {
        
#line 654 
        pba = (tx_space - min_tx_space) + pba;
        
#line 657 
        switch ((unsigned int)hw->mac_type) {
          case 6U: case 7U: case 8U: case 9U: case 10U: 
#line 658 
          ;
          
#line 659 
          pba &= 4294967288U;
          
#line 660 
          goto ldv_56667;
          default: 
#line 661 
          ;
          
#line 662 
          goto ldv_56667;
        }
        ldv_56667: 
#line 668 
        ;
        
#line 668 
        if (pba < min_rx_space) 
#line 669 
                                pba = min_rx_space; else ;
      }
      else ;
    }
    else ;
  
#line 673 
  writel(pba,(void volatile *)(hw->hw_addr + 4096U));
  {
    u32 tmp;
    
#line 684 
    u32 _min1 = (pba * 9216U) / 10U;
    
#line 684 
    u32 _min2 = (pba << 10) - hw->max_frame_size;
    
#line 684 
    if (_min1 < _min2) 
#line 684 
                       tmp = _min1; else 
#line 684 
                                         tmp = _min2;
    
#line 684 
    tmp_0 = tmp;
  }
  
#line 684 
  hwm = (unsigned short)tmp_0;
  
#line 687 
  hw->fc_high_water = (unsigned short)((unsigned int)hwm & 65528U);
  
#line 688 
  hw->fc_low_water = (unsigned short)((unsigned int)hw->fc_high_water + 65528U);
  
#line 689 
  hw->fc_pause_time = (unsigned short)65535U;
  
#line 690 
  hw->fc_send_xon = (_Bool)1;
  
#line 691 
  hw->fc = (enum ldv_36248)hw->original_fc;
  
#line 694 
  e1000_reset_hw(hw);
  
#line 695 
  if (hw->mac_type > (unsigned int)e1000_82543) 
#line 696 
                                                writel(0U,(void volatile *)(hw->hw_addr + 22528U)); else ;
  
#line 698 
  tmp_1 = e1000_init_hw(hw);
  
#line 698 
  if (tmp_1 != 0) 
#line 699 
                  dev_err((struct device const *)(& (adapter->pdev)->dev),"Hardware Error\n"); else ;
  
#line 700 
  e1000_update_mng_vlan(adapter);
  
#line 703 
  if ((hw->mac_type > (unsigned int)e1000_82543 && (unsigned int)hw->autoneg == 1U) && (unsigned int)hw->autoneg_advertised == 32U) {
    
#line 706 
    u32 ctrl = readl((void const volatile *)hw->hw_addr);
    
#line 711 
    ctrl &= 4292870143U;
    
#line 712 
    writel(ctrl,(void volatile *)hw->hw_addr);
  }
  else ;
  
#line 716 
  writel(33024U,(void volatile *)(hw->hw_addr + 56U));
  
#line 718 
  e1000_reset_adaptive(hw);
  
#line 719 
  e1000_phy_get_info(hw,& adapter->phy_info);
  
#line 721 
  e1000_release_manageability(adapter);
  
#line 722 
  return;
}


#line 725  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_dump_eeprom(struct e1000_adapter *adapter)
{
  struct ethtool_eeprom eeprom;
  u8 *data;
  int i;
  u16 csum_old;
  int tmp;
  
#line 727 
  struct net_device *netdev = adapter->netdev;
  
#line 729 
  struct ethtool_ops const *ops = netdev->ethtool_ops;
  
#line 732 
  u16 csum_new = (unsigned short)0U;
  
#line 734 
  tmp = (*(ops->get_eeprom_len))(netdev);
  
#line 734 
  eeprom.len = (unsigned int)tmp;
  
#line 735 
  eeprom.offset = 0U;
  
#line 737 
  data = (u8 *)kmalloc((unsigned long)eeprom.len,208U);
  
#line 738 
  if (data == (u8 *)0U) 
#line 739 
                        goto return_label; else ;
  
#line 741 
  (*(ops->get_eeprom))(netdev,& eeprom,data);
  
#line 743 
  csum_old = (unsigned short)((int)((unsigned short)*(data + 126U)) + ((int)((unsigned short)*(data + 127U)) << 8U));
  
#line 745 
  i = 0;
  
#line 745 
  goto ldv_56684;
  ldv_56683: 
#line 746 
  ;
  
#line 746 
  csum_new = (unsigned short)(((int)((unsigned short)*(data + i)) + ((int)((unsigned short)*(data + ((unsigned int)i + 1U))) << 8U)) + (int)csum_new);
  
#line 745 
  i += 2;
  ldv_56684: 
#line 746 
  ;
  
#line 745 
  if (i <= 125) 
#line 747 
                goto ldv_56683; else 
#line 750 
                                     goto ldv_56685;
  ldv_56685: 
#line 751 
  ;
  
#line 747 
  csum_new = (unsigned short)(47802U - (unsigned int)csum_new);
  
#line 749 
  printk("\001");
  
#line 750 
  printk("\001",(int)csum_old);
  
#line 751 
  printk("\001",(int)csum_new);
  
#line 753 
  printk("\001");
  
#line 754 
  printk("\001");
  
#line 755 
  print_hex_dump("\001","",2,16,1,(void const *)data,128UL,(_Bool)0);
  
#line 757 
  printk("\001");
  
#line 758 
  printk("\001");
  
#line 759 
  printk("\001");
  
#line 760 
  printk("\001");
  
#line 761 
  printk("\001");
  
#line 762 
  printk("\001");
  
#line 763 
  printk("\001");
  
#line 764 
  printk("\001");
  
#line 765 
  printk("\001");
  
#line 766 
  printk("\001");
  
#line 767 
  printk("\001");
  
#line 769 
  kfree((void const *)data);
  return_label: 
#line 770 
                return;
}


#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_is_need_ioport(struct pci_dev *pdev)
{
  int __retres;
  
#line 780 
  switch ((int)pdev->device) {
    case 4110: 
#line 781 
    ;
    case 4117: 
#line 782 
    ;
    case 4119: 
#line 783 
    ;
    case 4118: 
#line 784 
    ;
    case 4126: 
#line 785 
    ;
    case 4115: 
#line 786 
    ;
    case 4120: 
#line 787 
    ;
    case 4216: 
#line 788 
    ;
    case 4116: 
#line 789 
    ;
    case 4214: 
#line 790 
    ;
    case 4220: 
#line 791 
    ;
    case 4215: 
#line 792 
    ;
    case 4104: 
#line 793 
    ;
    case 4105: 
#line 794 
    ;
    case 4108: 
#line 795 
    ;
    case 4109: 
#line 796 
    ;
    case 4111: 
#line 797 
    ;
    case 4113: 
#line 798 
    ;
    case 4112: 
#line 799 
    ;
    case 4114: 
#line 800 
    ;
    case 4125: 
#line 801 
    ;
    
#line 802 
    __retres = 1;
    
#line 802 
    goto return_label;
    default: 
#line 803 
    ;
    
#line 804 
    __retres = 0;
    
#line 804 
    goto return_label;
  }
  return_label: 
#line 780 
                return __retres;
}


#line 808  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static netdev_features_t e1000_fix_features(struct net_device *netdev, netdev_features_t features)
{
  
#line 814 
  if ((features & 256ULL) != 0ULL) 
#line 815 
                                   features |= 128ULL; else 
#line 817 
                                                            features &= 18446744073709551487ULL;
  
#line 819 
  return features;
}


#line 822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_set_features(struct net_device *netdev, netdev_features_t features)
{
  int __retres;
  bool tmp_0;
  
#line 825 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 826 
  netdev_features_t changed = netdev->features ^ features;
  
#line 828 
  if ((changed & 256ULL) != 0ULL) 
#line 829 
                                  e1000_vlan_mode(netdev,features); else ;
  
#line 831 
  if ((changed & 292057776128ULL) == 0ULL) {
    
#line 832 
    __retres = 0;
    
#line 832 
    goto return_label;
  }
  else ;
  
#line 834 
  netdev->features = features;
  
#line 835 
  adapter->rx_csum = (_Bool)((features & 17179869184ULL) != 0ULL);
  
#line 837 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 837 
  if ((int)tmp_0 != 0) 
#line 838 
                       e1000_reinit_locked(adapter); else 
#line 840 
                                                          e1000_reset(adapter);
  
#line 842 
  __retres = 0;
  return_label: 
#line 842 
                return __retres;
}


#line 845  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static struct net_device_ops const e1000_netdev_ops = {.ndo_init = (int (*)(struct net_device *))0, .ndo_uninit = (void (*)(struct net_device *))0, .ndo_open = & e1000_open, .ndo_stop = & e1000_close, .ndo_start_xmit = & e1000_xmit_frame, .ndo_select_queue = (u16 (*)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)))0, .ndo_change_rx_flags = (void (*)(struct net_device *, int ))0, .ndo_set_rx_mode = & e1000_set_rx_mode, .ndo_set_mac_address = & e1000_set_mac, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & e1000_ioctl, .ndo_set_config = (int (*)(struct net_device *, struct ifmap *))0, .ndo_change_mtu = & e1000_change_mtu, .ndo_neigh_setup = (int (*)(struct net_device *, struct neigh_parms *))0, .ndo_tx_timeout = & e1000_tx_timeout, .ndo_get_stats64 = (struct rtnl_link_stats64 *(*)(struct net_device *, struct rtnl_link_stats64 *))0, .ndo_get_stats = & e1000_get_stats, .ndo_vlan_rx_add_vid = & e1000_vlan_rx_add_vid, .ndo_vlan_rx_kill_vid = & e1000_vlan_rx_kill_vid, .ndo_poll_controller = & e1000_netpoll, .ndo_netpoll_setup = (int (*)(struct net_device *, struct netpoll_info *))0, .ndo_netpoll_cleanup = (void (*)(struct net_device *))0, .ndo_busy_poll = (int (*)(struct napi_struct *))0, .ndo_set_vf_mac = (int (*)(struct net_device *, int , u8 *))0, .ndo_set_vf_vlan = (int (*)(struct net_device *, int , u16 , u8 ))0, .ndo_set_vf_rate = (int (*)(struct net_device *, int , int , int ))0, .ndo_set_vf_spoofchk = (int (*)(struct net_device *, int , bool ))0, .ndo_get_vf_config = (int (*)(struct net_device *, int , struct ifla_vf_info *))0, .ndo_set_vf_link_state = (int (*)(struct net_device *, int , int ))0, .ndo_get_vf_stats = (int (*)(struct net_device *, int , struct ifla_vf_stats *))0, .ndo_set_vf_port = (int (*)(struct net_device *, int , struct nlattr **))0, .ndo_get_vf_port = (int (*)(struct net_device *, int , struct sk_buff *))0, .ndo_set_vf_rss_query_en = (int (*)(struct net_device *, int , bool ))0, .ndo_setup_tc = (int (*)(struct net_device *, u8 ))0, .ndo_fcoe_enable = (int (*)(struct net_device *))0, .ndo_fcoe_disable = (int (*)(struct net_device *))0, .ndo_fcoe_ddp_setup = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_ddp_done = (int (*)(struct net_device *, u16 ))0, .ndo_fcoe_ddp_target = (int (*)(struct net_device *, u16 , struct scatterlist *, unsigned int ))0, .ndo_fcoe_get_hbainfo = (int (*)(struct net_device *, struct netdev_fcoe_hbainfo *))0, .ndo_fcoe_get_wwn = (int (*)(struct net_device *, u64 *, int ))0, .ndo_rx_flow_steer = (int (*)(struct net_device *, struct sk_buff const *, u16 , u32 ))0, .ndo_add_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_del_slave = (int (*)(struct net_device *, struct net_device *))0, .ndo_fix_features = & e1000_fix_features, .ndo_set_features = & e1000_set_features, .ndo_neigh_construct = (int (*)(struct neighbour *))0, .ndo_neigh_destroy = (void (*)(struct neighbour *))0, .ndo_fdb_add = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ))0, .ndo_fdb_del = (int (*)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ))0, .ndo_fdb_dump = (int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ))0, .ndo_bridge_setlink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_bridge_getlink = (int (*)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ))0, .ndo_bridge_dellink = (int (*)(struct net_device *, struct nlmsghdr *, u16 ))0, .ndo_change_carrier = (int (*)(struct net_device *, bool ))0, .ndo_get_phys_port_id = (int (*)(struct net_device *, struct netdev_phys_item_id *))0, .ndo_get_phys_port_name = (int (*)(struct net_device *, char *, size_t ))0, .ndo_add_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_del_vxlan_port = (void (*)(struct net_device *, sa_family_t , __be16 ))0, .ndo_dfwd_add_station = (void *(*)(struct net_device *, struct net_device *))0, .ndo_dfwd_del_station = (void (*)(struct net_device *, void *))0, .ndo_dfwd_start_xmit = (netdev_tx_t (*)(struct sk_buff *, struct net_device *, void *))0, .ndo_get_lock_subclass = (int (*)(struct net_device *))0, .ndo_features_check = (netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t ))0, .ndo_set_tx_maxrate = (int (*)(struct net_device *, int , u32 ))0, .ndo_get_iflink = (int (*)(struct net_device const *))0};

#line 876  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_init_hw_struct(struct e1000_adapter *adapter, struct e1000_hw *hw)
{
  int __retres;
  s32 tmp;
  
#line 879 
  struct pci_dev *pdev = adapter->pdev;
  
#line 882 
  hw->vendor_id = pdev->vendor;
  
#line 883 
  hw->device_id = pdev->device;
  
#line 884 
  hw->subsystem_vendor_id = pdev->subsystem_vendor;
  
#line 885 
  hw->subsystem_id = pdev->subsystem_device;
  
#line 886 
  hw->revision_id = pdev->revision;
  
#line 888 
  pci_read_config_word((struct pci_dev const *)pdev,4,& hw->pci_cmd_word);
  
#line 890 
  hw->max_frame_size = (adapter->netdev)->mtu + 18U;
  
#line 892 
  hw->min_frame_size = 64U;
  
#line 895 
  tmp = e1000_set_mac_type(hw);
  
#line 895 
  if (tmp != 0) {
    
#line 896 
    if ((adapter->msg_enable & 2) != 0) 
#line 896 
                                        netdev_err((struct net_device const *)adapter->netdev,"Unknown MAC Type\n"); else ;
    
#line 897 
    __retres = -5;
    
#line 897 
    goto return_label;
  }
  else ;
  
#line 900 
  switch ((unsigned int)hw->mac_type) {
    default: 
#line 901 
    ;
    
#line 902 
    goto ldv_56728;
    case (unsigned int)11: 
#line 903 
    ;
    case (unsigned int)13: 
#line 904 
    ;
    case (unsigned int)12: 
#line 905 
    ;
    case (unsigned int)14: 
#line 906 
    ;
    
#line 907 
    hw->phy_init_script = 1U;
    
#line 908 
    goto ldv_56728;
  }
  ldv_56728: 
#line 911 
  ;
  
#line 911 
  e1000_set_media_type(hw);
  
#line 912 
  e1000_get_bus_info(hw);
  
#line 914 
  hw->wait_autoneg_complete = (unsigned char)0U;
  
#line 915 
  hw->tbi_compatibility_en = (_Bool)1;
  
#line 916 
  hw->adaptive_ifs = (_Bool)1;
  
#line 920 
  if (hw->media_type == (unsigned int)e1000_media_type_copper) {
    
#line 921 
    hw->mdix = (unsigned char)0U;
    
#line 922 
    hw->disable_polarity_correction = (_Bool)0;
    
#line 923 
    hw->master_slave = 0;
  }
  else ;
  
#line 926 
  __retres = 0;
  return_label: 
#line 926 
                return __retres;
}


#line 940  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_probe(struct pci_dev *pdev, struct pci_device_id const *ent)
{
  int __retres;
  struct net_device *netdev;
  struct e1000_adapter *adapter;
  struct e1000_hw *hw;
  int i;
  int err;
  int pci_using_dac;
  int bars;
  int need_ioport;
  u32 tmp_1;
  char const *tmp_4;
  s32 tmp_6;
  s32 tmp_8;
  int tmp_10;
  bool tmp_9;
  
#line 946 
  int cards_found = 0;
  
#line 947 
  int global_quad_port_a = 0;
  
#line 949 
  u16 eeprom_data = (unsigned short)0U;
  
#line 950 
  u16 tmp = (unsigned short)0U;
  
#line 951 
  u16 eeprom_apme_mask = (unsigned short)1024U;
  
#line 955 
  need_ioport = e1000_is_need_ioport(pdev);
  
#line 956 
  if (need_ioport != 0) {
    
#line 957 
    bars = pci_select_bars(pdev,768UL);
    
#line 958 
    err = pci_enable_device(pdev);
  }
  else {
    
#line 960 
    bars = pci_select_bars(pdev,512UL);
    
#line 961 
    err = pci_enable_device_mem(pdev);
  }
  
#line 963 
  if (err != 0) {
    
#line 964 
    __retres = err;
    
#line 964 
    goto return_label;
  }
  else ;
  
#line 966 
  err = pci_request_selected_regions(pdev,bars,(char const *)(& e1000_driver_name));
  
#line 967 
  if (err != 0) 
#line 968 
                goto err_pci_reg; else ;
  
#line 970 
  pci_set_master(pdev);
  
#line 971 
  err = pci_save_state(pdev);
  
#line 972 
  if (err != 0) 
#line 973 
                goto err_alloc_etherdev; else ;
  
#line 975 
  err = -12;
  
#line 976 
  netdev = ldv_alloc_etherdev_mqs_81(2888,1U,1U);
  
#line 977 
  if (netdev == (struct net_device *)0) 
#line 978 
                                        goto err_alloc_etherdev; else ;
  
#line 980 
  netdev->dev.parent = & pdev->dev;
  
#line 982 
  pci_set_drvdata(pdev,(void *)netdev);
  
#line 983 
  adapter = (struct e1000_adapter *)netdev_priv((struct net_device const *)netdev);
  
#line 984 
  adapter->netdev = netdev;
  
#line 985 
  adapter->pdev = pdev;
  
#line 986 
  tmp_1 = netif_msg_init(debug,7);
  
#line 986 
  adapter->msg_enable = (int)tmp_1;
  
#line 987 
  adapter->bars = bars;
  
#line 988 
  adapter->need_ioport = need_ioport;
  
#line 990 
  hw = & adapter->hw;
  
#line 991 
  hw->back = (void *)adapter;
  
#line 993 
  err = -5;
  
#line 994 
  hw->hw_addr = (u8 *)pci_ioremap_bar(pdev,0);
  
#line 995 
  if (hw->hw_addr == (u8 *)0U) 
#line 996 
                               goto err_ioremap; else ;
  
#line 998 
  if (adapter->need_ioport != 0) {
    
#line 999 
    i = 1;
    
#line 999 
    goto ldv_56756;
    ldv_56755: 
#line 1000 
    ;
    
#line 1000 
    if ((pdev->resource[i].start == 0ULL && pdev->resource[i].end == pdev->resource[i].start) || pdev->resource[i].end - pdev->resource[i].start == 18446744073709551615ULL) 
      
#line 1001 
      goto ldv_56753; else ;
    
#line 1002 
    if ((pdev->resource[i].flags & 256UL) != 0UL) {
      
#line 1003 
      hw->io_base = (unsigned long)pdev->resource[i].start;
      
#line 1004 
      goto ldv_56754;
    }
    else ;
    ldv_56753: 
#line 1006 
    ;
    
#line 999 
    i += 1;
    ldv_56756: 
#line 1000 
    ;
    
#line 999 
    if (i <= 5) 
#line 1001 
                goto ldv_56755; else 
#line 1004 
                                     goto ldv_56754;
    ldv_56754: 
#line 1005 
    ;
  }
  else ;
  
#line 1010 
  err = e1000_init_hw_struct(adapter,hw);
  
#line 1011 
  if (err != 0) 
#line 1012 
                goto err_sw_init; else ;
  
#line 1018 
  pci_using_dac = 0;
  
#line 1019 
  if (hw->bus_type == (unsigned int)2) {
    int tmp_3;
    
#line 1019 
    tmp_3 = dma_set_mask_and_coherent(& pdev->dev,18446744073709551615ULL);
    
#line 1019 
    if (tmp_3 == 0) 
#line 1021 
                    pci_using_dac = 1; else 
#line 1019 
                                            goto _LAND;
  }
  else {
    _LAND: {
             
#line 1023 
             err = dma_set_mask_and_coherent(& pdev->dev,4294967295ULL);
             
#line 1024 
             if (err != 0) {
               
#line 1025 
               printk("\001");
               
#line 1026 
               goto err_dma;
             }
             else ;
           }
  }
  
#line 1030 
  netdev->netdev_ops = & e1000_netdev_ops;
  
#line 1031 
  e1000_set_ethtool_ops(netdev);
  
#line 1032 
  netdev->watchdog_timeo = 1250;
  
#line 1033 
  netif_napi_add(netdev,& adapter->napi,& e1000_clean,64);
  
#line 1035 
  tmp_4 = pci_name((struct pci_dev const *)pdev);
  
#line 1035 
  ;
  
#line 1035 
  strncpy((char *)(& netdev->name),tmp_4,15UL);
  
#line 1037 
  adapter->bd_number = (unsigned int)cards_found;
  
#line 1041 
  err = e1000_sw_init(adapter);
  
#line 1042 
  if (err != 0) 
#line 1043 
                goto err_sw_init; else ;
  
#line 1045 
  err = -5;
  
#line 1046 
  if (hw->mac_type == (unsigned int)e1000_ce4100) {
    resource_size_t tmp_5;
    
#line 1049 
    if (pdev->resource[1].start != 0ULL || pdev->resource[1].end != pdev->resource[1].start) 
      
#line 1049 
      tmp_5 = (pdev->resource[1].end - pdev->resource[1].start) + 1ULL; else 
                                                                    
#line 1049 
                                                                    tmp_5 = 0ULL;
    
#line 1047 
    ;
    
#line 1047 
    hw->ce4100_gbe_mdio_base_virt = ioremap(pdev->resource[1].start,(unsigned long)tmp_5);
    
#line 1051 
    if (hw->ce4100_gbe_mdio_base_virt == (void *)0) 
#line 1052 
                                                    goto err_mdio_ioremap; else ;
  }
  else ;
  
#line 1055 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) {
    
#line 1056 
    netdev->hw_features = 265ULL;
    
#line 1059 
    netdev->features = 640ULL;
  }
  else ;
  
#line 1063 
  if (hw->mac_type > (unsigned int)e1000_82543 && hw->mac_type != (unsigned int)e1000_82547) 
    
#line 1065 
    netdev->hw_features |= 65536ULL; else ;
  
#line 1067 
  netdev->priv_flags |= 524288U;
  
#line 1069 
  netdev->features |= netdev->hw_features;
  
#line 1070 
  netdev->hw_features |= 429496729600ULL;
  
#line 1074 
  if (pci_using_dac != 0) {
    
#line 1075 
    netdev->features |= 32ULL;
    
#line 1076 
    netdev->vlan_features |= 32ULL;
  }
  else ;
  
#line 1079 
  netdev->vlan_features |= 65545ULL;
  
#line 1084 
  if ((unsigned int)hw->device_id != 4111U || (unsigned int)hw->subsystem_vendor_id != 5549U) 
    
#line 1086 
    netdev->priv_flags |= 131072U; else ;
  
#line 1088 
  adapter->en_mng_pt = e1000_enable_mng_pass_thru(hw);
  
#line 1091 
  tmp_6 = e1000_init_eeprom_params(hw);
  
#line 1091 
  if (tmp_6 != 0) {
    
#line 1092 
    if ((adapter->msg_enable & 2) != 0) 
#line 1092 
                                        netdev_err((struct net_device const *)adapter->netdev,"EEPROM initialization failed\n"); else ;
    
#line 1093 
    goto err_eeprom;
  }
  else ;
  
#line 1100 
  e1000_reset_hw(hw);
  
#line 1103 
  tmp_8 = e1000_validate_eeprom_checksum(hw);
  
#line 1103 
  if (tmp_8 < 0) {
    
#line 1104 
    if ((adapter->msg_enable & 2) != 0) 
#line 1104 
                                        netdev_err((struct net_device const *)adapter->netdev,"The EEPROM Checksum Is Not Valid\n"); else ;
    
#line 1105 
    e1000_dump_eeprom(adapter);
    
#line 1113 
    memset((void *)(& hw->mac_addr),0,(unsigned long)netdev->addr_len);
  }
  else {
    s32 tmp_7;
    
#line 1116 
    tmp_7 = e1000_read_mac_addr(hw);
    
#line 1116 
    if (tmp_7 != 0) {
      
#line 1117 
      if ((adapter->msg_enable & 2) != 0) 
#line 1117 
                                          netdev_err((struct net_device const *)adapter->netdev,"EEPROM Read Error\n"); else ;
    }
    else ;
  }
  
#line 1120 
  memcpy((void *)netdev->dev_addr,(void const *)(& hw->mac_addr),(unsigned long)netdev->addr_len);
  
#line 1122 
  tmp_9 = is_valid_ether_addr((u8 const *)netdev->dev_addr);
  
#line 1122 
  if (tmp_9) 
#line 1122 
             tmp_10 = 0; else 
#line 1122 
                              tmp_10 = 1;
  
#line 1122 
  if (tmp_10) {
    
#line 1123 
    if ((adapter->msg_enable & 2) != 0) 
#line 1123 
                                        netdev_err((struct net_device const *)adapter->netdev,"Invalid MAC Address\n"); else ;
  }
  else ;
  {
    struct lock_class_key __key;
    
#line 1126 
    __init_work(& adapter->watchdog_task.work,0);
    
#line 1126 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 1126 
    adapter->watchdog_task.work.data = __constr_expr_37;
    
#line 1126 
    lockdep_init_map(& adapter->watchdog_task.work.lockdep_map,"(&(&adapter->watchdog_task)->work)",& __key,0);
    
#line 1126 
    INIT_LIST_HEAD(& adapter->watchdog_task.work.entry);
    
#line 1126 
    adapter->watchdog_task.work.func = & e1000_watchdog;
  }
  {
    struct lock_class_key __key_0;
    
#line 1126 
    init_timer_key(& adapter->watchdog_task.timer,2097152U,"(&(&adapter->watchdog_task)->timer)",& __key_0);
  }
  
#line 1126 
  adapter->watchdog_task.timer.function = & delayed_work_timer_fn;
  
#line 1126 
  adapter->watchdog_task.timer.data = (unsigned long)(& adapter->watchdog_task);
  {
    struct lock_class_key __key_1;
    
#line 1127 
    __init_work(& adapter->fifo_stall_task.work,0);
    
#line 1127 
    atomic_long_t __constr_expr_38 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 1127 
    adapter->fifo_stall_task.work.data = __constr_expr_38;
    
#line 1127 
    lockdep_init_map(& adapter->fifo_stall_task.work.lockdep_map,"(&(&adapter->fifo_stall_task)->work)",& __key_1,0);
    
#line 1127 
    INIT_LIST_HEAD(& adapter->fifo_stall_task.work.entry);
    
#line 1127 
    adapter->fifo_stall_task.work.func = & e1000_82547_tx_fifo_stall_task;
  }
  {
    struct lock_class_key __key_2;
    
#line 1127 
    init_timer_key(& adapter->fifo_stall_task.timer,2097152U,"(&(&adapter->fifo_stall_task)->timer)",& __key_2);
  }
  
#line 1127 
  adapter->fifo_stall_task.timer.function = & delayed_work_timer_fn;
  
#line 1127 
  adapter->fifo_stall_task.timer.data = (unsigned long)(& adapter->fifo_stall_task);
  {
    struct lock_class_key __key_3;
    
#line 1129 
    __init_work(& adapter->phy_info_task.work,0);
    
#line 1129 
    atomic_long_t __constr_expr_39 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 1129 
    adapter->phy_info_task.work.data = __constr_expr_39;
    
#line 1129 
    lockdep_init_map(& adapter->phy_info_task.work.lockdep_map,"(&(&adapter->phy_info_task)->work)",& __key_3,0);
    
#line 1129 
    INIT_LIST_HEAD(& adapter->phy_info_task.work.entry);
    
#line 1129 
    adapter->phy_info_task.work.func = & e1000_update_phy_info_task;
  }
  {
    struct lock_class_key __key_4;
    
#line 1129 
    init_timer_key(& adapter->phy_info_task.timer,2097152U,"(&(&adapter->phy_info_task)->timer)",& __key_4);
  }
  
#line 1129 
  adapter->phy_info_task.timer.function = & delayed_work_timer_fn;
  
#line 1129 
  adapter->phy_info_task.timer.data = (unsigned long)(& adapter->phy_info_task);
  {
    struct lock_class_key __key_5;
    
#line 1130 
    __init_work(& adapter->reset_task,0);
    
#line 1130 
    atomic_long_t __constr_expr_40 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 1130 
    adapter->reset_task.data = __constr_expr_40;
    
#line 1130 
    lockdep_init_map(& adapter->reset_task.lockdep_map,"(&adapter->reset_task)",& __key_5,0);
    
#line 1130 
    INIT_LIST_HEAD(& adapter->reset_task.entry);
    
#line 1130 
    adapter->reset_task.func = & e1000_reset_task;
  }
  
#line 1132 
  e1000_check_options(adapter);
  
#line 1139 
  switch ((unsigned int)hw->mac_type) {
    unsigned int tmp_11;
    case (unsigned int)1: 
#line 1140 
    ;
    case (unsigned int)2: 
#line 1141 
    ;
    case (unsigned int)3: 
#line 1142 
    ;
    
#line 1143 
    goto ldv_56775;
    case (unsigned int)4: 
#line 1144 
    ;
    
#line 1145 
    e1000_read_eeprom(hw,(unsigned short)15,(unsigned short)1,& eeprom_data);
    
#line 1147 
    eeprom_apme_mask = (unsigned short)4U;
    
#line 1148 
    goto ldv_56775;
    case (unsigned int)8: 
#line 1149 
    ;
    case (unsigned int)10: 
#line 1150 
    ;
    
#line 1151 
    tmp_11 = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 1151 
    if ((tmp_11 & 4U) != 0U) {
      
#line 1152 
      e1000_read_eeprom(hw,(unsigned short)20,(unsigned short)1,& eeprom_data);
      
#line 1154 
      goto ldv_56775;
    }
    else ;
    default: 
#line 1157 
    ;
    
#line 1158 
    e1000_read_eeprom(hw,(unsigned short)36,(unsigned short)1,& eeprom_data);
    
#line 1160 
    goto ldv_56775;
  }
  ldv_56775: 
#line 1162 
  ;
  
#line 1162 
  if ((unsigned int)((int)eeprom_data & (int)eeprom_apme_mask) != 0U) 
    
#line 1163 
    adapter->eeprom_wol |= 2U; else ;
  
#line 1169 
  switch ((int)pdev->device) {
    unsigned int tmp_12;
    case 4234: 
#line 1170 
    ;
    
#line 1171 
    adapter->eeprom_wol = 0U;
    
#line 1172 
    goto ldv_56781;
    case 4114: 
#line 1173 
    ;
    case 4218: 
#line 1174 
    ;
    
#line 1178 
    tmp_12 = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 1178 
    if ((tmp_12 & 4U) != 0U) 
#line 1179 
                             adapter->eeprom_wol = 0U; else ;
    
#line 1180 
    goto ldv_56781;
    case 4277: 
#line 1181 
    ;
    
#line 1183 
    if (global_quad_port_a != 0) 
#line 1184 
                                 adapter->eeprom_wol = 0U; else 
#line 1186 
                                                                adapter->quad_port_a = (_Bool)1;
    
#line 1188 
    global_quad_port_a += 1;
    
#line 1188 
    if (global_quad_port_a == 4) 
#line 1189 
                                 global_quad_port_a = 0; else ;
    
#line 1190 
    goto ldv_56781;
  }
  ldv_56781: 
#line 1194 
  ;
  
#line 1194 
  adapter->wol = adapter->eeprom_wol;
  
#line 1195 
  device_set_wakeup_enable(& (adapter->pdev)->dev,(_Bool)(adapter->wol != 0U));
  
#line 1198 
  if (hw->mac_type == (unsigned int)e1000_ce4100) {
    
#line 1199 
    i = 0;
    
#line 1199 
    goto ldv_56788;
    ldv_56787: 
#line 1200 
    ;
    
#line 1200 
    hw->phy_addr = (unsigned int)i;
    
#line 1201 
    e1000_read_phy_reg(hw,3U,& tmp);
    
#line 1202 
    if ((unsigned int)tmp == 0U || (unsigned int)tmp == 255U) {
      
#line 1203 
      if (i == 31) 
#line 1204 
                   goto err_eeprom; else ;
      
#line 1205 
      goto ldv_56785;
    }
    else 
#line 1207 
         goto ldv_56786;
    ldv_56785: 
#line 1208 
    ;
    
#line 1199 
    i += 1;
    ldv_56788: 
#line 1200 
    ;
    
#line 1199 
    if (i <= 31) 
#line 1201 
                 goto ldv_56787; else 
#line 1204 
                                      goto ldv_56786;
    ldv_56786: 
#line 1205 
    ;
  }
  else ;
  
#line 1212 
  e1000_reset(adapter);
  
#line 1214 
  strcpy((char *)(& netdev->name),"eth%d");
  
#line 1215 
  err = ldv_register_netdev_82(netdev);
  
#line 1216 
  if (err != 0) 
#line 1217 
                goto err_register; else ;
  
#line 1219 
  e1000_vlan_filter_on_off(adapter,(_Bool)0);
  
#line 1222 
  if ((adapter->msg_enable & 2) != 0) {
    int tmp_13;
    int tmp_17;
    char *tmp_18;
    
#line 1222 
    ;
    
#line 1222 
    if (hw->bus_width == (unsigned int)2) 
#line 1222 
                                          tmp_13 = 64; else 
#line 1222 
                                                            tmp_13 = 32;
    
#line 1222 
    if (hw->bus_speed != (unsigned int)5) {
      int tmp_16;
      
#line 1222 
      if (hw->bus_speed != (unsigned int)4) {
        int tmp_15;
        
#line 1222 
        if (hw->bus_speed != (unsigned int)3) {
          int tmp_14;
          
#line 1222 
          if (hw->bus_speed == (unsigned int)2) 
#line 1222 
                                                tmp_14 = 66; else 
#line 1222 
                                                                  tmp_14 = 33;
          
#line 1222 
          tmp_15 = tmp_14;
        }
        else 
#line 1222 
             tmp_15 = 100;
        
#line 1222 
        tmp_16 = tmp_15;
      }
      else 
#line 1222 
           tmp_16 = 120;
      
#line 1222 
      tmp_17 = tmp_16;
    }
    else 
#line 1222 
         tmp_17 = 133;
    
#line 1222 
    if (hw->bus_type == (unsigned int)2) 
#line 1222 
                                         tmp_18 = (char *)"-X"; else 
                                                                  
#line 1222 
                                                                  tmp_18 = (char *)"";
    
#line 1222 
    ;
    
#line 1222 
    netdev_info((struct net_device const *)adapter->netdev,"(PCI%s:%dMHz:%d-bit) %pM\n",tmp_18,tmp_17,tmp_13,netdev->dev_addr);
  }
  else ;
  
#line 1232 
  netif_carrier_off(netdev);
  
#line 1234 
  if ((adapter->msg_enable & 2) != 0) 
#line 1234 
                                      netdev_info((struct net_device const *)adapter->netdev,"Intel(R) PRO/1000 Network Connection\n"); else ;
  
#line 1236 
  cards_found += 1;
  
#line 1237 
  __retres = 0;
  
#line 1237 
  goto return_label;
  err_register: 
#line 1239 
  ;
  err_eeprom: 
#line 1240 
  ;
  
#line 1241 
  e1000_phy_hw_reset(hw);
  
#line 1243 
  if (hw->flash_address != (u8 *)0U) 
#line 1244 
                                     iounmap((void volatile *)hw->flash_address); else ;
  
#line 1245 
  kfree((void const *)adapter->tx_ring);
  
#line 1246 
  kfree((void const *)adapter->rx_ring);
  err_dma: 
#line 1247 
  ;
  err_sw_init: 
#line 1248 
  ;
  err_mdio_ioremap: 
#line 1249 
  ;
  
#line 1250 
  iounmap((void volatile *)hw->ce4100_gbe_mdio_base_virt);
  
#line 1251 
  iounmap((void volatile *)hw->hw_addr);
  err_ioremap: 
#line 1252 
  ;
  
#line 1253 
  ldv_free_netdev_83(netdev);
  err_alloc_etherdev: 
#line 1254 
  ;
  
#line 1255 
  pci_release_selected_regions(pdev,bars);
  err_pci_reg: 
#line 1256 
  ;
  
#line 1257 
  pci_disable_device(pdev);
  
#line 1258 
  __retres = err;
  return_label: 
#line 1258 
                return __retres;
}


#line 1270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_remove(struct pci_dev *pdev)
{
  
#line 1272 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 1273 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1274 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1276 
  e1000_down_and_stop(adapter);
  
#line 1277 
  e1000_release_manageability(adapter);
  
#line 1279 
  ldv_unregister_netdev_84(netdev);
  
#line 1281 
  e1000_phy_hw_reset(hw);
  
#line 1283 
  kfree((void const *)adapter->tx_ring);
  
#line 1284 
  kfree((void const *)adapter->rx_ring);
  
#line 1286 
  if (hw->mac_type == (unsigned int)e1000_ce4100) 
#line 1287 
                                                  iounmap((void volatile *)hw->ce4100_gbe_mdio_base_virt); else ;
  
#line 1288 
  iounmap((void volatile *)hw->hw_addr);
  
#line 1289 
  if (hw->flash_address != (u8 *)0U) 
#line 1290 
                                     iounmap((void volatile *)hw->flash_address); else ;
  
#line 1291 
  pci_release_selected_regions(pdev,adapter->bars);
  
#line 1293 
  ldv_free_netdev_85(netdev);
  
#line 1295 
  pci_disable_device(pdev);
  
#line 1296 
  return;
}


#line 1305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_sw_init(struct e1000_adapter *adapter)
{
  int __retres;
  int tmp;
  
#line 1307 
  adapter->rx_buffer_len = 1522U;
  
#line 1309 
  adapter->num_tx_queues = 1;
  
#line 1310 
  adapter->num_rx_queues = 1;
  
#line 1312 
  tmp = e1000_alloc_queues(adapter);
  
#line 1312 
  if (tmp != 0) {
    
#line 1313 
    if ((adapter->msg_enable & 2) != 0) 
#line 1313 
                                        netdev_err((struct net_device const *)adapter->netdev,"Unable to allocate memory for queues\n"); else ;
    
#line 1314 
    __retres = -12;
    
#line 1314 
    goto return_label;
  }
  else ;
  
#line 1318 
  e1000_irq_disable(adapter);
  
#line 1320 
  spinlock_check(& adapter->stats_lock);
  {
    struct lock_class_key __key;
    
#line 1320 
    __raw_spin_lock_init(& adapter->stats_lock.__anonCompField_spinlock_18.rlock,"&(&adapter->stats_lock)->rlock",& __key);
  }
  
#line 1322 
  set_bit(2L,(unsigned long volatile *)(& adapter->flags));
  
#line 1324 
  __retres = 0;
  return_label: 
#line 1324 
                return __retres;
}


#line 1334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_alloc_queues(struct e1000_adapter *adapter)
{
  int __retres;
  
#line 1336 
  adapter->tx_ring = (struct e1000_tx_ring *)kcalloc((unsigned long)adapter->num_tx_queues,48UL,208U);
  
#line 1338 
  if (adapter->tx_ring == (struct e1000_tx_ring *)0) {
    
#line 1339 
    __retres = -12;
    
#line 1339 
    goto return_label;
  }
  else ;
  
#line 1341 
  adapter->rx_ring = (struct e1000_rx_ring *)kcalloc((unsigned long)adapter->num_rx_queues,56UL,208U);
  
#line 1343 
  if (adapter->rx_ring == (struct e1000_rx_ring *)0) {
    
#line 1344 
    kfree((void const *)adapter->tx_ring);
    
#line 1345 
    __retres = -12;
    
#line 1345 
    goto return_label;
  }
  else ;
  
#line 1348 
  __retres = 0;
  return_label: 
#line 1348 
                return __retres;
}


#line 1363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_open(struct net_device *netdev)
{
  int __retres;
  int err;
  int tmp_0;
  
#line 1365 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1366 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1370 
  tmp_0 = constant_test_bit(0L,(unsigned long const volatile *)(& adapter->flags));
  
#line 1370 
  if (tmp_0 != 0) {
    
#line 1371 
    __retres = -16;
    
#line 1371 
    goto return_label;
  }
  else ;
  
#line 1373 
  netif_carrier_off(netdev);
  
#line 1376 
  err = e1000_setup_all_tx_resources(adapter);
  
#line 1377 
  if (err != 0) 
#line 1378 
                goto err_setup_tx; else ;
  
#line 1381 
  err = e1000_setup_all_rx_resources(adapter);
  
#line 1382 
  if (err != 0) 
#line 1383 
                goto err_setup_rx; else ;
  
#line 1385 
  e1000_power_up_phy(adapter);
  
#line 1387 
  adapter->mng_vlan_id = (unsigned short)65535U;
  
#line 1388 
  if (((int)hw->mng_cookie.status & 2) != 0) 
#line 1390 
                                             e1000_update_mng_vlan(adapter); else ;
  
#line 1398 
  e1000_configure(adapter);
  
#line 1400 
  err = e1000_request_irq(adapter);
  
#line 1401 
  if (err != 0) 
#line 1402 
                goto err_req_irq; else ;
  
#line 1405 
  set_bit(2L,(unsigned long volatile *)(& adapter->flags));
  
#line 1407 
  napi_enable(& adapter->napi);
  
#line 1409 
  e1000_irq_enable(adapter);
  
#line 1411 
  netif_start_queue(netdev);
  
#line 1414 
  writel(4U,(void volatile *)(hw->hw_addr + 200U));
  
#line 1416 
  __retres = 0;
  
#line 1416 
  goto return_label;
  err_req_irq: 
#line 1418 
  ;
  
#line 1419 
  e1000_power_down_phy(adapter);
  
#line 1420 
  e1000_free_all_rx_resources(adapter);
  err_setup_rx: 
#line 1421 
  ;
  
#line 1422 
  e1000_free_all_tx_resources(adapter);
  err_setup_tx: 
#line 1423 
  ;
  
#line 1424 
  e1000_reset(adapter);
  
#line 1426 
  __retres = err;
  return_label: 
#line 1426 
                return __retres;
}


#line 1440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_close(struct net_device *netdev)
{
  int __retres;
  int tmp_0;
  
#line 1442 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1443 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1444 
  int count = 50;
  
#line 1446 
  goto ldv_56819;
  ldv_56818: 
#line 1447 
  ;
  
#line 1447 
  usleep_range(10000UL,20000UL);
  ldv_56819: 
#line 1448 
  ;
  
#line 1446 
  tmp_0 = constant_test_bit(1L,(unsigned long const volatile *)(& adapter->flags));
  
#line 1446 
  if (tmp_0 != 0) {
    int tmp_1;
    
#line 1446 
    tmp_1 = count;
    
#line 1446 
    count -= 1;
    
#line 1446 
    ;
    
#line 1446 
    if (tmp_1 != 0) 
#line 1448 
                    goto ldv_56818; else 
#line 1451 
                                         goto ldv_56820;
  }
  else 
#line 1451 
       goto ldv_56820;
  ldv_56820: 
#line 1452 
  ;
  {
    int tmp_2;
    
#line 1449 
    tmp_2 = constant_test_bit(1L,(unsigned long const volatile *)(& adapter->flags));
    
#line 1449 
    int __ret_warn_on = tmp_2 != 0;
    
#line 1449 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1449 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c",1449); else ;
    
#line 1449 
    long tmp_3 = (long)(__ret_warn_on != 0);
  }
  
#line 1450 
  e1000_down(adapter);
  
#line 1451 
  e1000_power_down_phy(adapter);
  
#line 1452 
  e1000_free_irq(adapter);
  
#line 1454 
  e1000_free_all_tx_resources(adapter);
  
#line 1455 
  e1000_free_all_rx_resources(adapter);
  
#line 1460 
  if (((int)hw->mng_cookie.status & 2) != 0) {
    int tmp_5;
    
#line 1461 
    if (0 != 0) {
      int tmp_3_0;
      
#line 1462 
      tmp_3_0 = constant_test_bit((long)adapter->mng_vlan_id,(unsigned long const volatile *)(& adapter->active_vlans));
      
#line 1461 
      tmp_5 = tmp_3_0 == 0;
    }
    else {
      int tmp_4;
      
#line 1461 
      tmp_4 = variable_test_bit((long)adapter->mng_vlan_id,(unsigned long const volatile *)(& adapter->active_vlans));
      
#line 1461 
      tmp_5 = tmp_4 == 0;
    }
    
#line 1461 
    if (tmp_5) 
#line 1463 
               e1000_vlan_rx_kill_vid(netdev,(unsigned short)129,(unsigned short)((int)adapter->mng_vlan_id)); else ;
  }
  else ;
  
#line 1467 
  __retres = 0;
  
#line 1467 
  return __retres;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static bool e1000_check_64k_bound(struct e1000_adapter *adapter, void *start, unsigned long len)
{
  bool __retres;
  
#line 1479 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1480 
  unsigned long begin = (unsigned long)start;
  
#line 1481 
  unsigned long end = begin + len;
  
#line 1486 
  if ((hw->mac_type == (unsigned int)e1000_82545 || hw->mac_type == (unsigned int)e1000_ce4100) || hw->mac_type == (unsigned int)e1000_82546) {
    
#line 1489 
    __retres = (_Bool)(((end + 18446744073709551615UL) ^ begin) >> 16 == 0UL);
    
#line 1489 
    goto return_label;
  }
  else ;
  
#line 1492 
  __retres = (_Bool)1;
  return_label: 
#line 1492 
                return __retres;
}


#line 1502  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_setup_tx_resources(struct e1000_adapter *adapter, struct e1000_tx_ring *txdr)
{
  int __retres;
  int size;
  int tmp_3;
  bool tmp_2;
  
#line 1505 
  struct pci_dev *pdev = adapter->pdev;
  
#line 1508 
  size = (int)(txdr->count * 40U);
  
#line 1509 
  txdr->buffer_info = (struct e1000_tx_buffer *)vzalloc((unsigned long)size);
  
#line 1510 
  if (txdr->buffer_info == (struct e1000_tx_buffer *)0) {
    
#line 1511 
    __retres = -12;
    
#line 1511 
    goto return_label;
  }
  else ;
  
#line 1515 
  txdr->size = txdr->count * 16U;
  
#line 1516 
  txdr->size = (txdr->size + 4095U) & 4294963200U;
  
#line 1518 
  txdr->desc = dma_alloc_attrs(& pdev->dev,(unsigned long)txdr->size,& txdr->dma,208U,(struct dma_attrs *)0);
  
#line 1520 
  if (txdr->desc == (void *)0) {
    setup_tx_desc_die: 
#line 1521 
    ;
    
#line 1522 
    vfree((void const *)txdr->buffer_info);
    
#line 1523 
    __retres = -12;
    
#line 1523 
    goto return_label;
  }
  else ;
  
#line 1527 
  tmp_2 = e1000_check_64k_bound(adapter,txdr->desc,(unsigned long)txdr->size);
  
#line 1527 
  if (tmp_2) 
#line 1527 
             tmp_3 = 0; else 
#line 1527 
                             tmp_3 = 1;
  
#line 1527 
  if (tmp_3) {
    int tmp_1;
    bool tmp_0;
    
#line 1528 
    void *olddesc = txdr->desc;
    
#line 1529 
    dma_addr_t olddma = txdr->dma;
    
#line 1530 
    if ((adapter->msg_enable & 128) != 0) 
#line 1530 
                                          netdev_err((struct net_device const *)adapter->netdev,"txdr align check failed: %u bytes at %p\n",txdr->size,txdr->desc); else ;
    
#line 1533 
    txdr->desc = dma_alloc_attrs(& pdev->dev,(unsigned long)txdr->size,& txdr->dma,208U,(struct dma_attrs *)0);
    
#line 1536 
    if (txdr->desc == (void *)0) {
      
#line 1537 
      dma_free_attrs(& pdev->dev,(unsigned long)txdr->size,olddesc,olddma,(struct dma_attrs *)0);
      
#line 1539 
      goto setup_tx_desc_die;
    }
    else ;
    
#line 1542 
    tmp_0 = e1000_check_64k_bound(adapter,txdr->desc,(unsigned long)txdr->size);
    
#line 1542 
    if (tmp_0) 
#line 1542 
               tmp_1 = 0; else 
#line 1542 
                               tmp_1 = 1;
    
#line 1542 
    if (tmp_1) {
      
#line 1544 
      dma_free_attrs(& pdev->dev,(unsigned long)txdr->size,txdr->desc,txdr->dma,(struct dma_attrs *)0);
      
#line 1546 
      dma_free_attrs(& pdev->dev,(unsigned long)txdr->size,olddesc,olddma,(struct dma_attrs *)0);
      
#line 1548 
      if ((adapter->msg_enable & 2) != 0) 
#line 1548 
                                          netdev_err((struct net_device const *)adapter->netdev,"Unable to allocate aligned memory "); else ;
      
#line 1550 
      vfree((void const *)txdr->buffer_info);
      
#line 1551 
      __retres = -12;
      
#line 1551 
      goto return_label;
    }
    else 
#line 1554 
         dma_free_attrs(& pdev->dev,(unsigned long)txdr->size,olddesc,olddma,(struct dma_attrs *)0);
  }
  else ;
  
#line 1558 
  memset(txdr->desc,0,(unsigned long)txdr->size);
  
#line 1560 
  txdr->next_to_use = 0U;
  
#line 1561 
  txdr->next_to_clean = 0U;
  
#line 1563 
  __retres = 0;
  return_label: 
#line 1563 
                return __retres;
}


#line 1573  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
int e1000_setup_all_tx_resources(struct e1000_adapter *adapter)
{
  int i;
  
#line 1575 
  int err = 0;
  
#line 1577 
  i = 0;
  
#line 1577 
  goto ldv_56850;
  ldv_56849: 
#line 1578 
  ;
  
#line 1578 
  err = e1000_setup_tx_resources(adapter,adapter->tx_ring + i);
  
#line 1579 
  if (err != 0) {
    
#line 1580 
    if ((adapter->msg_enable & 2) != 0) 
#line 1580 
                                        netdev_err((struct net_device const *)adapter->netdev,"Allocation for Tx Queue %u failed\n",i); else ;
    
#line 1581 
    i -= 1;
    
#line 1581 
    goto ldv_56846;
    ldv_56845: 
#line 1582 
    ;
    
#line 1582 
    e1000_free_tx_resources(adapter,adapter->tx_ring + i);
    
#line 1581 
    i -= 1;
    ldv_56846: 
#line 1582 
    ;
    
#line 1581 
    if (i >= 0) 
#line 1583 
                goto ldv_56845; else 
#line 1586 
                                     goto ldv_56847;
    ldv_56847: 
#line 1587 
    ;
    
#line 1584 
    goto ldv_56848;
  }
  else ;
  
#line 1577 
  i += 1;
  ldv_56850: 
#line 1578 
  ;
  
#line 1577 
  if (adapter->num_tx_queues > i) 
#line 1579 
                                  goto ldv_56849; else 
#line 1582 
                                                       goto ldv_56848;
  ldv_56848: 
#line 1583 
  ;
  
#line 1588 
  return err;
}


#line 1597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_configure_tx(struct e1000_adapter *adapter)
{
  u64 tdba;
  u32 tdlen;
  u32 tctl;
  u32 tipg;
  u32 ipgr1;
  u32 ipgr2;
  int tmp_4;
  
#line 1600 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1606 
  switch (adapter->num_tx_queues) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    case 1: 
#line 1607 
    ;
    default: 
#line 1608 
    ;
    
#line 1609 
    tdba = (adapter->tx_ring)->dma;
    
#line 1610 
    tdlen = (adapter->tx_ring)->count * 16U;
    
#line 1612 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1612 
                                                         tmp = 14344; else 
                                                                    
#line 1612 
                                                                    tmp = 1064;
    
#line 1612 
    ;
    
#line 1612 
    ;
    
#line 1612 
    writel(tdlen,(void volatile *)(hw->hw_addr + tmp));
    
#line 1613 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1613 
                                                         tmp_0 = 14340; else 
                                                                    
#line 1613 
                                                                    tmp_0 = 1060;
    
#line 1613 
    ;
    
#line 1613 
    ;
    
#line 1613 
    writel((unsigned int)(tdba >> 32),(void volatile *)(hw->hw_addr + tmp_0));
    
#line 1614 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1614 
                                                         tmp_1 = 14336; else 
                                                                    
#line 1614 
                                                                    tmp_1 = 1056;
    
#line 1614 
    ;
    
#line 1614 
    ;
    
#line 1614 
    writel((unsigned int)tdba,(void volatile *)(hw->hw_addr + tmp_1));
    
#line 1615 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1615 
                                                         tmp_2 = 14360; else 
                                                                    
#line 1615 
                                                                    tmp_2 = 1080;
    
#line 1615 
    ;
    
#line 1615 
    writel(0U,(void volatile *)(hw->hw_addr + tmp_2));
    
#line 1616 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1616 
                                                         tmp_3 = 14352; else 
                                                                    
#line 1616 
                                                                    tmp_3 = 1072;
    
#line 1616 
    ;
    
#line 1616 
    writel(0U,(void volatile *)(hw->hw_addr + tmp_3));
    
#line 1617 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1617 
                                                         (adapter->tx_ring)->tdh = (unsigned short)14352U; else 
                                                                    
#line 1617 
                                                                    (adapter->tx_ring)->tdh = (unsigned short)1072U;
    
#line 1619 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1619 
                                                         (adapter->tx_ring)->tdt = (unsigned short)14360U; else 
                                                                    
#line 1619 
                                                                    (adapter->tx_ring)->tdt = (unsigned short)1080U;
    
#line 1621 
    goto ldv_56863;
  }
  ldv_56863: 
#line 1625 
  ;
  
#line 1625 
  if ((unsigned int)hw->media_type + 4294967295U <= 1U) 
#line 1627 
                                                        tipg = 9U; else 
                                                                    
#line 1629 
                                                                    tipg = 8U;
  
#line 1631 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)1: 
#line 1632 
    ;
    case (unsigned int)2: 
#line 1633 
    ;
    
#line 1634 
    tipg = 10U;
    
#line 1635 
    ipgr1 = 2U;
    
#line 1636 
    ipgr2 = 10U;
    
#line 1637 
    goto ldv_56866;
    default: 
#line 1638 
    ;
    
#line 1639 
    ipgr1 = 8U;
    
#line 1640 
    ipgr2 = 6U;
    
#line 1641 
    goto ldv_56866;
  }
  ldv_56866: 
#line 1643 
  ;
  
#line 1643 
  tipg = (ipgr1 << 10) | tipg;
  
#line 1644 
  tipg = (ipgr2 << 20) | tipg;
  
#line 1645 
  writel(tipg,(void volatile *)(hw->hw_addr + 1040U));
  
#line 1649 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1649 
                                                       tmp_4 = 14368; else 
                                                                    
#line 1649 
                                                                    tmp_4 = 1088;
  
#line 1649 
  ;
  
#line 1649 
  ;
  
#line 1649 
  writel(adapter->tx_int_delay,(void volatile *)(hw->hw_addr + tmp_4));
  
#line 1650 
  if (hw->mac_type > (unsigned int)e1000_82544) 
#line 1651 
                                                writel(adapter->tx_abs_int_delay,(void volatile *)(hw->hw_addr + 14380U)); else ;
  
#line 1655 
  tctl = readl((void const volatile *)(hw->hw_addr + 1024U));
  
#line 1656 
  tctl &= 4294963215U;
  
#line 1657 
  tctl |= 16777464U;
  
#line 1660 
  e1000_config_collision_dist(hw);
  
#line 1663 
  adapter->txd_cmd = 50331648U;
  
#line 1666 
  if (adapter->tx_int_delay != 0U) 
#line 1667 
                                   adapter->txd_cmd |= 2147483648U; else ;
  
#line 1669 
  if (hw->mac_type <= (unsigned int)e1000_82542_rev2_1) 
#line 1670 
                                                        adapter->txd_cmd |= 268435456U; else 
                                                                    
#line 1672 
                                                                    adapter->txd_cmd |= 134217728U;
  
#line 1677 
  if (hw->mac_type == (unsigned int)e1000_82544 && hw->bus_type == (unsigned int)2) 
    
#line 1679 
    adapter->pcix_82544 = (_Bool)1; else ;
  
#line 1681 
  writel(tctl,(void volatile *)(hw->hw_addr + 1024U));
  
#line 1682 
  return;
}


#line 1692  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_setup_rx_resources(struct e1000_adapter *adapter, struct e1000_rx_ring *rxdr)
{
  int __retres;
  int size;
  int desc_len;
  int tmp_3;
  bool tmp_2;
  
#line 1695 
  struct pci_dev *pdev = adapter->pdev;
  
#line 1698 
  size = (int)(rxdr->count * 16U);
  
#line 1699 
  rxdr->buffer_info = (struct e1000_rx_buffer *)vzalloc((unsigned long)size);
  
#line 1700 
  if (rxdr->buffer_info == (struct e1000_rx_buffer *)0) {
    
#line 1701 
    __retres = -12;
    
#line 1701 
    goto return_label;
  }
  else ;
  
#line 1703 
  desc_len = 16;
  
#line 1707 
  rxdr->size = rxdr->count * (unsigned int)desc_len;
  
#line 1708 
  rxdr->size = (rxdr->size + 4095U) & 4294963200U;
  
#line 1710 
  rxdr->desc = dma_alloc_attrs(& pdev->dev,(unsigned long)rxdr->size,& rxdr->dma,208U,(struct dma_attrs *)0);
  
#line 1712 
  if (rxdr->desc == (void *)0) {
    setup_rx_desc_die: 
#line 1713 
    ;
    
#line 1714 
    vfree((void const *)rxdr->buffer_info);
    
#line 1715 
    __retres = -12;
    
#line 1715 
    goto return_label;
  }
  else ;
  
#line 1719 
  tmp_2 = e1000_check_64k_bound(adapter,rxdr->desc,(unsigned long)rxdr->size);
  
#line 1719 
  if (tmp_2) 
#line 1719 
             tmp_3 = 0; else 
#line 1719 
                             tmp_3 = 1;
  
#line 1719 
  if (tmp_3) {
    int tmp_1;
    bool tmp_0;
    
#line 1720 
    void *olddesc = rxdr->desc;
    
#line 1721 
    dma_addr_t olddma = rxdr->dma;
    
#line 1722 
    if ((adapter->msg_enable & 64) != 0) 
#line 1722 
                                         netdev_err((struct net_device const *)adapter->netdev,"rxdr align check failed: %u bytes at %p\n",rxdr->size,rxdr->desc); else ;
    
#line 1725 
    rxdr->desc = dma_alloc_attrs(& pdev->dev,(unsigned long)rxdr->size,& rxdr->dma,208U,(struct dma_attrs *)0);
    
#line 1728 
    if (rxdr->desc == (void *)0) {
      
#line 1729 
      dma_free_attrs(& pdev->dev,(unsigned long)rxdr->size,olddesc,olddma,(struct dma_attrs *)0);
      
#line 1731 
      goto setup_rx_desc_die;
    }
    else ;
    
#line 1734 
    tmp_0 = e1000_check_64k_bound(adapter,rxdr->desc,(unsigned long)rxdr->size);
    
#line 1734 
    if (tmp_0) 
#line 1734 
               tmp_1 = 0; else 
#line 1734 
                               tmp_1 = 1;
    
#line 1734 
    if (tmp_1) {
      
#line 1736 
      dma_free_attrs(& pdev->dev,(unsigned long)rxdr->size,rxdr->desc,rxdr->dma,(struct dma_attrs *)0);
      
#line 1738 
      dma_free_attrs(& pdev->dev,(unsigned long)rxdr->size,olddesc,olddma,(struct dma_attrs *)0);
      
#line 1740 
      if ((adapter->msg_enable & 2) != 0) 
#line 1740 
                                          netdev_err((struct net_device const *)adapter->netdev,"Unable to allocate aligned memory for "); else ;
      
#line 1742 
      goto setup_rx_desc_die;
    }
    else 
#line 1745 
         dma_free_attrs(& pdev->dev,(unsigned long)rxdr->size,olddesc,olddma,(struct dma_attrs *)0);
  }
  else ;
  
#line 1749 
  memset(rxdr->desc,0,(unsigned long)rxdr->size);
  
#line 1751 
  rxdr->next_to_clean = 0U;
  
#line 1752 
  rxdr->next_to_use = 0U;
  
#line 1753 
  rxdr->rx_skb_top = (struct sk_buff *)0;
  
#line 1755 
  __retres = 0;
  return_label: 
#line 1755 
                return __retres;
}


#line 1765  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
int e1000_setup_all_rx_resources(struct e1000_adapter *adapter)
{
  int i;
  
#line 1767 
  int err = 0;
  
#line 1769 
  i = 0;
  
#line 1769 
  goto ldv_56888;
  ldv_56887: 
#line 1770 
  ;
  
#line 1770 
  err = e1000_setup_rx_resources(adapter,adapter->rx_ring + i);
  
#line 1771 
  if (err != 0) {
    
#line 1772 
    if ((adapter->msg_enable & 2) != 0) 
#line 1772 
                                        netdev_err((struct net_device const *)adapter->netdev,"Allocation for Rx Queue %u failed\n",i); else ;
    
#line 1773 
    i -= 1;
    
#line 1773 
    goto ldv_56884;
    ldv_56883: 
#line 1774 
    ;
    
#line 1774 
    e1000_free_rx_resources(adapter,adapter->rx_ring + i);
    
#line 1773 
    i -= 1;
    ldv_56884: 
#line 1774 
    ;
    
#line 1773 
    if (i >= 0) 
#line 1775 
                goto ldv_56883; else 
#line 1778 
                                     goto ldv_56885;
    ldv_56885: 
#line 1779 
    ;
    
#line 1776 
    goto ldv_56886;
  }
  else ;
  
#line 1769 
  i += 1;
  ldv_56888: 
#line 1770 
  ;
  
#line 1769 
  if (adapter->num_rx_queues > i) 
#line 1771 
                                  goto ldv_56887; else 
#line 1774 
                                                       goto ldv_56886;
  ldv_56886: 
#line 1775 
  ;
  
#line 1780 
  return err;
}


#line 1787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_setup_rctl(struct e1000_adapter *adapter)
{
  u32 rctl;
  
#line 1789 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1792 
  rctl = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 1794 
  rctl &= 4294955007U;
  
#line 1796 
  rctl = ((hw->mc_filter_type << 12) | rctl) | 32768U;
  
#line 1800 
  if ((int)hw->tbi_compatibility_on == 1) 
#line 1801 
                                          rctl |= 4U; else 
#line 1803 
                                                           rctl &= 4294967291U;
  
#line 1805 
  if ((adapter->netdev)->mtu <= 1500U) 
#line 1806 
                                       rctl &= 4294967263U; else 
#line 1808 
                                                                 rctl |= 32U;
  
#line 1811 
  rctl &= 4294770687U;
  
#line 1812 
  rctl |= 33554432U;
  
#line 1813 
  switch (adapter->rx_buffer_len) {
    case (u32)2048: 
#line 1814 
    ;
    default: 
#line 1815 
    ;
    
#line 1816 
    rctl = rctl;
    
#line 1817 
    rctl &= 4261412863U;
    
#line 1818 
    goto ldv_56896;
    case (u32)4096: 
#line 1819 
    ;
    
#line 1820 
    rctl |= 196608U;
    
#line 1821 
    goto ldv_56896;
    case (u32)8192: 
#line 1822 
    ;
    
#line 1823 
    rctl |= 131072U;
    
#line 1824 
    goto ldv_56896;
    case (u32)16384: 
#line 1825 
    ;
    
#line 1826 
    rctl |= 65536U;
    
#line 1827 
    goto ldv_56896;
  }
  ldv_56896: 
#line 1831 
  ;
  
#line 1831 
  if (((adapter->netdev)->features & 274877906944ULL) != 0ULL) {
    
#line 1835 
    rctl |= 8421380U;
    
#line 1839 
    rctl &= 4289986559U;
  }
  else ;
  
#line 1847 
  writel(rctl,(void volatile *)(hw->hw_addr + 256U));
  
#line 1848 
  return;
}


#line 1856  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_configure_rx(struct e1000_adapter *adapter)
{
  u64 rdba;
  u32 rdlen;
  u32 rctl;
  u32 rxcsum;
  int tmp;
  
#line 1859 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1862 
  if ((adapter->netdev)->mtu > 1500U) {
    
#line 1863 
    rdlen = (adapter->rx_ring)->count * 16U;
    
#line 1865 
    adapter->clean_rx = & e1000_clean_jumbo_rx_irq;
    
#line 1866 
    adapter->alloc_rx_buf = & e1000_alloc_jumbo_rx_buffers;
  }
  else {
    
#line 1868 
    rdlen = (adapter->rx_ring)->count * 16U;
    
#line 1870 
    adapter->clean_rx = & e1000_clean_rx_irq;
    
#line 1871 
    adapter->alloc_rx_buf = & e1000_alloc_rx_buffers;
  }
  
#line 1875 
  rctl = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 1876 
  writel(rctl & 4294967293U,(void volatile *)(hw->hw_addr + 256U));
  
#line 1879 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1879 
                                                       tmp = 10272; else 
                                                                    
#line 1879 
                                                                    tmp = 264;
  
#line 1879 
  ;
  
#line 1879 
  ;
  
#line 1879 
  writel(adapter->rx_int_delay,(void volatile *)(hw->hw_addr + tmp));
  
#line 1881 
  if (hw->mac_type > (unsigned int)e1000_82544) {
    
#line 1882 
    writel(adapter->rx_abs_int_delay,(void volatile *)(hw->hw_addr + 10284U));
    
#line 1883 
    if (adapter->itr_setting != 0U) 
#line 1884 
                                    writel(1000000000U / (adapter->itr * 256U),(void volatile *)(hw->hw_addr + 196U)); else ;
  }
  else ;
  
#line 1890 
  switch (adapter->num_rx_queues) {
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    case 1: 
#line 1891 
    ;
    default: 
#line 1892 
    ;
    
#line 1893 
    rdba = (adapter->rx_ring)->dma;
    
#line 1894 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1894 
                                                         tmp_0 = 10248; else 
                                                                    
#line 1894 
                                                                    tmp_0 = 280;
    
#line 1894 
    ;
    
#line 1894 
    ;
    
#line 1894 
    writel(rdlen,(void volatile *)(hw->hw_addr + tmp_0));
    
#line 1895 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1895 
                                                         tmp_1 = 10244; else 
                                                                    
#line 1895 
                                                                    tmp_1 = 276;
    
#line 1895 
    ;
    
#line 1895 
    ;
    
#line 1895 
    writel((unsigned int)(rdba >> 32),(void volatile *)(hw->hw_addr + tmp_1));
    
#line 1896 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1896 
                                                         tmp_2 = 10240; else 
                                                                    
#line 1896 
                                                                    tmp_2 = 272;
    
#line 1896 
    ;
    
#line 1896 
    ;
    
#line 1896 
    writel((unsigned int)rdba,(void volatile *)(hw->hw_addr + tmp_2));
    
#line 1897 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1897 
                                                         tmp_3 = 10264; else 
                                                                    
#line 1897 
                                                                    tmp_3 = 296;
    
#line 1897 
    ;
    
#line 1897 
    writel(0U,(void volatile *)(hw->hw_addr + tmp_3));
    
#line 1898 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1898 
                                                         tmp_4 = 10256; else 
                                                                    
#line 1898 
                                                                    tmp_4 = 288;
    
#line 1898 
    ;
    
#line 1898 
    writel(0U,(void volatile *)(hw->hw_addr + tmp_4));
    
#line 1899 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1899 
                                                         (adapter->rx_ring)->rdh = (unsigned short)10256U; else 
                                                                    
#line 1899 
                                                                    (adapter->rx_ring)->rdh = (unsigned short)288U;
    
#line 1901 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1901 
                                                         (adapter->rx_ring)->rdt = (unsigned short)10264U; else 
                                                                    
#line 1901 
                                                                    (adapter->rx_ring)->rdt = (unsigned short)296U;
    
#line 1903 
    goto ldv_56910;
  }
  ldv_56910: 
#line 1907 
  ;
  
#line 1907 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) {
    
#line 1908 
    rxcsum = readl((void const volatile *)(hw->hw_addr + 20480U));
    
#line 1909 
    if ((int)adapter->rx_csum != 0) 
#line 1910 
                                    rxcsum |= 512U; else 
#line 1913 
                                                         rxcsum &= 4294966783U;
    
#line 1914 
    writel(rxcsum,(void volatile *)(hw->hw_addr + 20480U));
  }
  else ;
  
#line 1918 
  writel(rctl | 2U,(void volatile *)(hw->hw_addr + 256U));
  
#line 1919 
  return;
}


#line 1928  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_free_tx_resources(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring)
{
  
#line 1931 
  struct pci_dev *pdev = adapter->pdev;
  
#line 1933 
  e1000_clean_tx_ring(adapter,tx_ring);
  
#line 1935 
  vfree((void const *)tx_ring->buffer_info);
  
#line 1936 
  tx_ring->buffer_info = (struct e1000_tx_buffer *)0;
  
#line 1938 
  dma_free_attrs(& pdev->dev,(unsigned long)tx_ring->size,tx_ring->desc,tx_ring->dma,(struct dma_attrs *)0);
  
#line 1941 
  tx_ring->desc = (void *)0;
  
#line 1942 
  return;
}


#line 1950  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_free_all_tx_resources(struct e1000_adapter *adapter)
{
  int i;
  
#line 1954 
  i = 0;
  
#line 1954 
  goto ldv_56921;
  ldv_56920: 
#line 1955 
  ;
  
#line 1955 
  e1000_free_tx_resources(adapter,adapter->tx_ring + i);
  
#line 1954 
  i += 1;
  ldv_56921: 
#line 1955 
  ;
  
#line 1954 
  if (adapter->num_tx_queues > i) 
#line 1956 
                                  goto ldv_56920; else 
#line 1959 
                                                       goto ldv_56922;
  ldv_56922: 
#line 1960 
  ;
  
#line 1961 
  return;
}


#line 1959  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_unmap_and_free_tx_resource(struct e1000_adapter *adapter, struct e1000_tx_buffer *buffer_info)
{
  
#line 1962 
  if (buffer_info->dma != 0ULL) {
    
#line 1963 
    if ((int)buffer_info->mapped_as_page != 0) 
#line 1964 
                                               dma_unmap_page(& (adapter->pdev)->dev,buffer_info->dma,(unsigned long)buffer_info->length,(enum dma_data_direction)DMA_TO_DEVICE); else 
                                                                    
#line 1967 
                                                                    dma_unmap_single_attrs(& (adapter->pdev)->dev,buffer_info->dma,(unsigned long)buffer_info->length,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 1970 
    buffer_info->dma = 0ULL;
  }
  else ;
  
#line 1972 
  if (buffer_info->skb != (struct sk_buff *)0) {
    
#line 1973 
    dev_kfree_skb_any(buffer_info->skb);
    
#line 1974 
    buffer_info->skb = (struct sk_buff *)0;
  }
  else ;
  
#line 1976 
  buffer_info->time_stamp = 0UL;
  
#line 1977 
  return;
}


#line 1985  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_clean_tx_ring(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring)
{
  struct e1000_tx_buffer *buffer_info;
  unsigned long size;
  unsigned int i;
  
#line 1988 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1995 
  i = 0U;
  
#line 1995 
  goto ldv_56936;
  ldv_56935: 
#line 1996 
  ;
  
#line 1996 
  buffer_info = tx_ring->buffer_info + i;
  
#line 1997 
  e1000_unmap_and_free_tx_resource(adapter,buffer_info);
  
#line 1995 
  i += 1U;
  ldv_56936: 
#line 1996 
  ;
  
#line 1995 
  if (tx_ring->count > i) 
#line 1997 
                          goto ldv_56935; else 
#line 2000 
                                               goto ldv_56937;
  ldv_56937: 
#line 2001 
  ;
  
#line 2000 
  netdev_reset_queue(adapter->netdev);
  
#line 2001 
  size = (unsigned long)tx_ring->count * 40UL;
  
#line 2002 
  memset((void *)tx_ring->buffer_info,0,size);
  
#line 2006 
  memset(tx_ring->desc,0,(unsigned long)tx_ring->size);
  
#line 2008 
  tx_ring->next_to_use = 0U;
  
#line 2009 
  tx_ring->next_to_clean = 0U;
  
#line 2010 
  tx_ring->last_tx_tso = (_Bool)0;
  
#line 2012 
  writel(0U,(void volatile *)(hw->hw_addr + (int)tx_ring->tdh));
  
#line 2013 
  writel(0U,(void volatile *)(hw->hw_addr + (int)tx_ring->tdt));
  
#line 2014 
  return;
}


#line 2020  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_clean_all_tx_rings(struct e1000_adapter *adapter)
{
  int i;
  
#line 2024 
  i = 0;
  
#line 2024 
  goto ldv_56943;
  ldv_56942: 
#line 2025 
  ;
  
#line 2025 
  e1000_clean_tx_ring(adapter,adapter->tx_ring + i);
  
#line 2024 
  i += 1;
  ldv_56943: 
#line 2025 
  ;
  
#line 2024 
  if (adapter->num_tx_queues > i) 
#line 2026 
                                  goto ldv_56942; else 
#line 2029 
                                                       goto ldv_56944;
  ldv_56944: 
#line 2030 
  ;
  
#line 2031 
  return;
}


#line 2035  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_free_rx_resources(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring)
{
  
#line 2038 
  struct pci_dev *pdev = adapter->pdev;
  
#line 2040 
  e1000_clean_rx_ring(adapter,rx_ring);
  
#line 2042 
  vfree((void const *)rx_ring->buffer_info);
  
#line 2043 
  rx_ring->buffer_info = (struct e1000_rx_buffer *)0;
  
#line 2045 
  dma_free_attrs(& pdev->dev,(unsigned long)rx_ring->size,rx_ring->desc,rx_ring->dma,(struct dma_attrs *)0);
  
#line 2048 
  rx_ring->desc = (void *)0;
  
#line 2049 
  return;
}


#line 2057  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_free_all_rx_resources(struct e1000_adapter *adapter)
{
  int i;
  
#line 2061 
  i = 0;
  
#line 2061 
  goto ldv_56955;
  ldv_56954: 
#line 2062 
  ;
  
#line 2062 
  e1000_free_rx_resources(adapter,adapter->rx_ring + i);
  
#line 2061 
  i += 1;
  ldv_56955: 
#line 2062 
  ;
  
#line 2061 
  if (adapter->num_rx_queues > i) 
#line 2063 
                                  goto ldv_56954; else 
#line 2066 
                                                       goto ldv_56956;
  ldv_56956: 
#line 2067 
  ;
  
#line 2068 
  return;
}


#line 2066  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static unsigned int e1000_frag_len(struct e1000_adapter const *a)
{
  unsigned int __retres;
  int tmp_0;
  {
    int tmp;
    
#line 2068 
    int _max1 = 32;
    
#line 2068 
    int _max2 = 64;
    
#line 2068 
    if (_max1 > _max2) 
#line 2068 
                       tmp = _max1; else 
#line 2068 
                                         tmp = _max2;
    
#line 2068 
    tmp_0 = tmp;
  }
  
#line 2068 
  ;
  
#line 2068 
  __retres = (((a->rx_buffer_len + (unsigned int)tmp_0) + 63U) & 4294967232U) + 320U;
  
#line 2068 
  return __retres;
}


#line 2072  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void *e1000_alloc_frag(struct e1000_adapter const *a)
{
  void *__retres;
  
#line 2074 
  unsigned int len = e1000_frag_len(a);
  
#line 2075 
  u8 *data = netdev_alloc_frag(len);
  
#line 2077 
  if ((long)(data != (u8 *)0U) != 0L) {
    int tmp_2;
    {
      int tmp_1;
      
#line 2078 
      int _max1 = 32;
      
#line 2078 
      int _max2 = 64;
      
#line 2078 
      if (_max1 > _max2) 
#line 2078 
                         tmp_1 = _max1; else 
#line 2078 
                                             tmp_1 = _max2;
      
#line 2078 
      tmp_2 = tmp_1;
    }
    
#line 2078 
    data += tmp_2;
  }
  else ;
  
#line 2079 
  __retres = (void *)data;
  
#line 2079 
  return __retres;
}


#line 2087  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_clean_rx_ring(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring)
{
  struct e1000_rx_buffer *buffer_info;
  unsigned long size;
  unsigned int i;
  
#line 2090 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2092 
  struct pci_dev *pdev = adapter->pdev;
  
#line 2097 
  i = 0U;
  
#line 2097 
  goto ldv_56987;
  ldv_56986: 
#line 2098 
  ;
  
#line 2098 
  buffer_info = rx_ring->buffer_info + i;
  
#line 2099 
  if (adapter->clean_rx == & e1000_clean_rx_irq) {
    
#line 2100 
    if (buffer_info->dma != 0ULL) 
#line 2101 
                                  dma_unmap_single_attrs(& pdev->dev,buffer_info->dma,(unsigned long)adapter->rx_buffer_len,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0); else ;
    
#line 2104 
    if (buffer_info->rxbuf.data != (u8 *)0U) {
      
#line 2105 
      skb_free_frag((void *)buffer_info->rxbuf.data);
      
#line 2106 
      buffer_info->rxbuf.data = (u8 *)0U;
    }
    else ;
  }
  else 
    
#line 2108 
    if (adapter->clean_rx == & e1000_clean_jumbo_rx_irq) {
      
#line 2109 
      if (buffer_info->dma != 0ULL) 
#line 2110 
                                    dma_unmap_page(& pdev->dev,buffer_info->dma,(unsigned long)adapter->rx_buffer_len,(enum dma_data_direction)DMA_FROM_DEVICE); else ;
      
#line 2113 
      if (buffer_info->rxbuf.page != (struct page *)0) {
        
#line 2114 
        put_page(buffer_info->rxbuf.page);
        
#line 2115 
        buffer_info->rxbuf.page = (struct page *)0;
      }
      else ;
    }
    else ;
  
#line 2119 
  buffer_info->dma = 0ULL;
  
#line 2097 
  i += 1U;
  ldv_56987: 
#line 2098 
  ;
  
#line 2097 
  if (rx_ring->count > i) 
#line 2099 
                          goto ldv_56986; else 
#line 2102 
                                               goto ldv_56988;
  ldv_56988: 
#line 2103 
  ;
  
#line 2123 
  napi_free_frags(& adapter->napi);
  
#line 2124 
  rx_ring->rx_skb_top = (struct sk_buff *)0;
  
#line 2126 
  size = (unsigned long)rx_ring->count * 16UL;
  
#line 2127 
  memset((void *)rx_ring->buffer_info,0,size);
  
#line 2130 
  memset(rx_ring->desc,0,(unsigned long)rx_ring->size);
  
#line 2132 
  rx_ring->next_to_clean = 0U;
  
#line 2133 
  rx_ring->next_to_use = 0U;
  
#line 2135 
  writel(0U,(void volatile *)(hw->hw_addr + (int)rx_ring->rdh));
  
#line 2136 
  writel(0U,(void volatile *)(hw->hw_addr + (int)rx_ring->rdt));
  
#line 2137 
  return;
}


#line 2143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_clean_all_rx_rings(struct e1000_adapter *adapter)
{
  int i;
  
#line 2147 
  i = 0;
  
#line 2147 
  goto ldv_56994;
  ldv_56993: 
#line 2148 
  ;
  
#line 2148 
  e1000_clean_rx_ring(adapter,adapter->rx_ring + i);
  
#line 2147 
  i += 1;
  ldv_56994: 
#line 2148 
  ;
  
#line 2147 
  if (adapter->num_rx_queues > i) 
#line 2149 
                                  goto ldv_56993; else 
#line 2152 
                                                       goto ldv_56995;
  ldv_56995: 
#line 2153 
  ;
  
#line 2154 
  return;
}


#line 2154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_enter_82542_rst(struct e1000_adapter *adapter)
{
  u32 rctl;
  bool tmp_0;
  
#line 2156 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2157 
  struct net_device *netdev = adapter->netdev;
  
#line 2160 
  e1000_pci_clear_mwi(hw);
  
#line 2162 
  rctl = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 2163 
  rctl |= 1U;
  
#line 2164 
  writel(rctl,(void volatile *)(hw->hw_addr + 256U));
  
#line 2165 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2166 
  if (1) 
#line 2166 
         __const_udelay(21475000UL);
  else {
    
#line 2166 
    unsigned long __ms = 5UL;
    {
      unsigned long tmp;
      
#line 2166 
      goto ldv_57004;
      ldv_57003: 
#line 2167 
      ;
      
#line 2166 
      __const_udelay(4295000UL);
      ldv_57004: 
#line 2168 
      ;
      
#line 2166 
      tmp = __ms;
      
#line 2166 
      __ms -= 1UL;
      
#line 2166 
      ;
      
#line 2166 
      if (tmp != 0UL) 
#line 2168 
                      goto ldv_57003; else 
#line 2171 
                                           goto ldv_57005;
      ldv_57005: 
#line 2172 
      ;
    }
  }
  
#line 2168 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 2168 
  if ((int)tmp_0 != 0) 
#line 2169 
                       e1000_clean_all_rx_rings(adapter); else ;
  
#line 2170 
  return;
}


#line 2172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_leave_82542_rst(struct e1000_adapter *adapter)
{
  u32 rctl;
  bool tmp_1;
  
#line 2174 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2175 
  struct net_device *netdev = adapter->netdev;
  
#line 2178 
  rctl = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 2179 
  rctl &= 4294967294U;
  
#line 2180 
  writel(rctl,(void volatile *)(hw->hw_addr + 256U));
  
#line 2181 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2182 
  if (1) 
#line 2182 
         __const_udelay(21475000UL);
  else {
    
#line 2182 
    unsigned long __ms = 5UL;
    {
      unsigned long tmp;
      
#line 2182 
      goto ldv_57014;
      ldv_57013: 
#line 2183 
      ;
      
#line 2182 
      __const_udelay(4295000UL);
      ldv_57014: 
#line 2184 
      ;
      
#line 2182 
      tmp = __ms;
      
#line 2182 
      __ms -= 1UL;
      
#line 2182 
      ;
      
#line 2182 
      if (tmp != 0UL) 
#line 2184 
                      goto ldv_57013; else 
#line 2187 
                                           goto ldv_57015;
      ldv_57015: 
#line 2188 
      ;
    }
  }
  
#line 2184 
  if (((int)hw->pci_cmd_word & 16) != 0) 
#line 2185 
                                         e1000_pci_set_mwi(hw); else ;
  
#line 2187 
  tmp_1 = netif_running((struct net_device const *)netdev);
  
#line 2187 
  if ((int)tmp_1 != 0) {
    unsigned int tmp_0;
    
#line 2189 
    struct e1000_rx_ring *ring = adapter->rx_ring;
    
#line 2190 
    e1000_configure_rx(adapter);
    
#line 2191 
    if (ring->next_to_clean <= ring->next_to_use) 
#line 2191 
                                                  tmp_0 = ring->count; else 
                                                                    
#line 2191 
                                                                    tmp_0 = 0U;
    
#line 2191 
    ;
    
#line 2191 
    ;
    
#line 2191 
    ;
    
#line 2191 
    (*(adapter->alloc_rx_buf))(adapter,ring,(int)(((tmp_0 + ring->next_to_clean) - ring->next_to_use) + 4294967295U));
  }
  else ;
  
#line 2193 
  return;
}


#line 2202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_set_mac(struct net_device *netdev, void *p)
{
  int __retres;
  int tmp_1;
  bool tmp_0;
  
#line 2204 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 2205 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2206 
  struct sockaddr *addr = (struct sockaddr *)p;
  
#line 2208 
  tmp_0 = is_valid_ether_addr((u8 const *)(& addr->sa_data));
  
#line 2208 
  if (tmp_0) 
#line 2208 
             tmp_1 = 0; else 
#line 2208 
                             tmp_1 = 1;
  
#line 2208 
  if (tmp_1) {
    
#line 2209 
    __retres = -99;
    
#line 2209 
    goto return_label;
  }
  else ;
  
#line 2213 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) 
#line 2214 
                                                        e1000_enter_82542_rst(adapter); else ;
  
#line 2216 
  memcpy((void *)netdev->dev_addr,(void const *)(& addr->sa_data),(unsigned long)netdev->addr_len);
  
#line 2217 
  memcpy((void *)(& hw->mac_addr),(void const *)(& addr->sa_data),(unsigned long)netdev->addr_len);
  
#line 2219 
  e1000_rar_set(hw,(u8 *)(& hw->mac_addr),0U);
  
#line 2221 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) 
#line 2222 
                                                        e1000_leave_82542_rst(adapter); else ;
  
#line 2224 
  __retres = 0;
  return_label: 
#line 2224 
                return __retres;
}


#line 2236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_set_rx_mode(struct net_device *netdev)
{
  struct netdev_hw_addr *ha;
  u32 rctl;
  u32 hash_value;
  int i;
  struct netdev_hw_addr *tmp_5;
  struct netdev_hw_addr *tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  
#line 2238 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 2239 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2241 
  bool use_uc = (_Bool)0;
  
#line 2244 
  int rar_entries = 15;
  
#line 2245 
  int mta_reg_count = 128;
  
#line 2246 
  u32 *mcarray = kcalloc((unsigned long)mta_reg_count,4UL,32U);
  
#line 2248 
  if (mcarray == (u32 *)0U) 
#line 2249 
                            goto return_label; else ;
  
#line 2253 
  rctl = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 2255 
  if ((netdev->flags & 256U) != 0U) {
    
#line 2256 
    rctl |= 24U;
    
#line 2257 
    rctl &= 4294705151U;
  }
  else {
    bool tmp_1;
    
#line 2259 
    if ((netdev->flags & 512U) != 0U) 
#line 2260 
                                      rctl |= 16U; else 
#line 2262 
                                                        rctl &= 4294967279U;
    
#line 2264 
    tmp_1 = e1000_vlan_used(adapter);
    
#line 2264 
    if ((int)tmp_1 != 0) 
#line 2265 
                         rctl |= 262144U; else ;
  }
  
#line 2268 
  if (netdev->uc.count > rar_entries + -1) 
#line 2269 
                                           rctl |= 8U;
  else 
    
#line 2270 
    if ((netdev->flags & 256U) == 0U) {
      
#line 2271 
      rctl &= 4294967287U;
      
#line 2272 
      use_uc = (_Bool)1;
    }
    else ;
  
#line 2275 
  writel(rctl,(void volatile *)(hw->hw_addr + 256U));
  
#line 2279 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) 
#line 2280 
                                                        e1000_enter_82542_rst(adapter); else ;
  
#line 2289 
  i = 1;
  
#line 2290 
  if ((int)use_uc != 0) {
    struct netdev_hw_addr *tmp_2;
    int tmp_3;
    struct netdev_hw_addr *tmp_4;
    {
      
#line 2291 
      struct list_head const *__mptr = (struct list_head const *)netdev->uc.list.next;
      
#line 2291 
      tmp_2 = (struct netdev_hw_addr *)__mptr;
    }
    
#line 2291 
    ha = tmp_2;
    
#line 2291 
    goto ldv_57043;
    ldv_57042: 
#line 2292 
    ;
    
#line 2292 
    if (i == rar_entries) 
#line 2293 
                          goto ldv_57041; else ;
    
#line 2294 
    tmp_3 = i;
    
#line 2294 
    i += 1;
    
#line 2294 
    ;
    
#line 2294 
    ;
    
#line 2294 
    ;
    
#line 2294 
    e1000_rar_set(hw,(u8 *)(& ha->addr),(unsigned int)tmp_3);
    {
      
#line 2291 
      struct list_head const *__mptr_0 = (struct list_head const *)ha->list.next;
      
#line 2291 
      tmp_4 = (struct netdev_hw_addr *)__mptr_0;
    }
    
#line 2291 
    ha = tmp_4;
    ldv_57043: 
#line 2293 
    ;
    
#line 2291 
    if (& ha->list != & netdev->uc.list) 
#line 2293 
                                         goto ldv_57042; else 
#line 2296 
                                                              goto ldv_57041;
    ldv_57041: 
#line 2297 
    ;
  }
  else ;
  {
    
#line 2297 
    struct list_head const *__mptr_1 = (struct list_head const *)netdev->mc.list.next;
    
#line 2297 
    tmp_5 = (struct netdev_hw_addr *)__mptr_1;
  }
  
#line 2297 
  ha = tmp_5;
  
#line 2297 
  goto ldv_57052;
  ldv_57051: 
#line 2298 
  ;
  
#line 2298 
  if (i == rar_entries) {
    u32 hash_reg;
    u32 hash_bit;
    u32 mta;
    
#line 2301 
    hash_value = e1000_hash_mc_addr(hw,(u8 *)(& ha->addr));
    
#line 2302 
    hash_reg = (hash_value >> 5) & 127U;
    
#line 2303 
    hash_bit = hash_value & 31U;
    
#line 2304 
    mta = (unsigned int)(1 << hash_bit);
    
#line 2305 
    *(mcarray + hash_reg) |= mta;
  }
  else {
    int tmp_6;
    
#line 2307 
    tmp_6 = i;
    
#line 2307 
    i += 1;
    
#line 2307 
    ;
    
#line 2307 
    ;
    
#line 2307 
    ;
    
#line 2307 
    e1000_rar_set(hw,(u8 *)(& ha->addr),(unsigned int)tmp_6);
  }
  {
    
#line 2297 
    struct list_head const *__mptr_2 = (struct list_head const *)ha->list.next;
    
#line 2297 
    tmp_7 = (struct netdev_hw_addr *)__mptr_2;
  }
  
#line 2297 
  ha = tmp_7;
  ldv_57052: 
#line 2299 
  ;
  
#line 2297 
  if (& ha->list != & netdev->mc.list) 
#line 2299 
                                       goto ldv_57051; else 
#line 2302 
                                                            goto ldv_57053;
  ldv_57053: 
#line 2303 
  ;
  
#line 2311 
  goto ldv_57055;
  ldv_57054: 
#line 2312 
  ;
  
#line 2312 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2312 
                                                       tmp_8 = 21504; else 
                                                                    
#line 2312 
                                                                    tmp_8 = 64;
  
#line 2312 
  ;
  
#line 2312 
  writel(0U,(void volatile *)(hw->hw_addr + (tmp_8 + (i << 3))));
  
#line 2313 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2314 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2314 
                                                       tmp_9 = 21504; else 
                                                                    
#line 2314 
                                                                    tmp_9 = 64;
  
#line 2314 
  ;
  
#line 2314 
  writel(0U,(void volatile *)(hw->hw_addr + (tmp_9 + (((i << 1) + 1) << 2))));
  
#line 2315 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2311 
  i += 1;
  ldv_57055: 
#line 2312 
  ;
  
#line 2311 
  if (i < rar_entries) 
#line 2313 
                       goto ldv_57054; else 
#line 2316 
                                            goto ldv_57056;
  ldv_57056: 
#line 2317 
  ;
  
#line 2321 
  i = mta_reg_count + -1;
  
#line 2321 
  goto ldv_57058;
  ldv_57057: 
#line 2322 
  ;
  
#line 2327 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2327 
                                                       tmp_10 = 20992; else 
                                                                    
#line 2327 
                                                                    tmp_10 = 512;
  
#line 2327 
  ;
  
#line 2327 
  ;
  
#line 2327 
  writel(*(mcarray + i),(void volatile *)(hw->hw_addr + (tmp_10 + (i << 2))));
  
#line 2321 
  i -= 1;
  ldv_57058: 
#line 2322 
  ;
  
#line 2321 
  if (i >= 0) 
#line 2323 
              goto ldv_57057; else 
#line 2326 
                                   goto ldv_57059;
  ldv_57059: 
#line 2327 
  ;
  
#line 2329 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2331 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) 
#line 2332 
                                                        e1000_leave_82542_rst(adapter); else ;
  
#line 2334 
  kfree((void const *)mcarray);
  return_label: 
#line 2335 
                return;
}


#line 2344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_update_phy_info_task(struct work_struct *work)
{
  struct e1000_adapter *tmp;
  {
    
#line 2346 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 2346 
    tmp = (struct e1000_adapter *)__mptr + 18446744073709548952U;
  }
  
#line 2346 
  struct e1000_adapter *adapter = tmp;
  
#line 2350 
  e1000_phy_get_info(& adapter->hw,& adapter->phy_info);
  
#line 2351 
  return;
}


#line 2357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_82547_tx_fifo_stall_task(struct work_struct *work)
{
  struct e1000_adapter *tmp;
  u32 tctl;
  int tmp_13;
  {
    
#line 2359 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 2359 
    tmp = (struct e1000_adapter *)__mptr + 18446744073709549176U;
  }
  
#line 2359 
  struct e1000_adapter *adapter = tmp;
  
#line 2362 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2363 
  struct net_device *netdev = adapter->netdev;
  
#line 2366 
  tmp_13 = atomic_read((atomic_t const *)(& adapter->tx_fifo_stall));
  
#line 2366 
  if (tmp_13 != 0) {
    unsigned int tmp_4;
    int tmp_3;
    unsigned int tmp_6;
    int tmp_5;
    
#line 2367 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2367 
                                                         tmp_3 = 14360; else 
                                                                    
#line 2367 
                                                                    tmp_3 = 1080;
    
#line 2367 
    ;
    
#line 2367 
    tmp_4 = readl((void const volatile *)(hw->hw_addr + tmp_3));
    
#line 2367 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2367 
                                                         tmp_5 = 14352; else 
                                                                    
#line 2367 
                                                                    tmp_5 = 1072;
    
#line 2367 
    ;
    
#line 2367 
    tmp_6 = readl((void const volatile *)(hw->hw_addr + tmp_5));
    
#line 2367 
    if (tmp_4 == tmp_6) {
      unsigned int tmp_8;
      int tmp_7;
      unsigned int tmp_10;
      int tmp_9;
      
#line 2368 
      if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2368 
                                                           tmp_7 = 13336; else 
                                                                    
#line 2368 
                                                                    tmp_7 = 32792;
      
#line 2367 
      ;
      
#line 2367 
      tmp_8 = readl((void const volatile *)(hw->hw_addr + tmp_7));
      
#line 2368 
      if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2368 
                                                           tmp_9 = 13328; else 
                                                                    
#line 2368 
                                                                    tmp_9 = 32784;
      
#line 2368 
      ;
      
#line 2368 
      tmp_10 = readl((void const volatile *)(hw->hw_addr + tmp_9));
      
#line 2367 
      if (tmp_8 == tmp_10) {
        unsigned int tmp_11;
        unsigned int tmp_12;
        
#line 2368 
        tmp_11 = readl((void const volatile *)(hw->hw_addr + 13352U));
        
#line 2369 
        tmp_12 = readl((void const volatile *)(hw->hw_addr + 13344U));
        
#line 2368 
        if (tmp_11 == tmp_12) {
          int tmp_0;
          int tmp_1;
          
#line 2370 
          tctl = readl((void const volatile *)(hw->hw_addr + 1024U));
          
#line 2371 
          writel(tctl & 4294967293U,(void volatile *)(hw->hw_addr + 1024U));
          
#line 2372 
          if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2372 
                                                               tmp_0 = 13336; else 
                                                                    
#line 2372 
                                                                    tmp_0 = 32792;
          
#line 2372 
          ;
          
#line 2372 
          ;
          
#line 2372 
          writel(adapter->tx_head_addr,(void volatile *)(hw->hw_addr + tmp_0));
          
#line 2373 
          if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 2373 
                                                               tmp_1 = 13328; else 
                                                                    
#line 2373 
                                                                    tmp_1 = 32784;
          
#line 2373 
          ;
          
#line 2373 
          ;
          
#line 2373 
          writel(adapter->tx_head_addr,(void volatile *)(hw->hw_addr + tmp_1));
          
#line 2374 
          writel(adapter->tx_head_addr,(void volatile *)(hw->hw_addr + 13352U));
          
#line 2375 
          writel(adapter->tx_head_addr,(void volatile *)(hw->hw_addr + 13344U));
          
#line 2376 
          writel(tctl,(void volatile *)(hw->hw_addr + 1024U));
          
#line 2377 
          readl((void const volatile *)(hw->hw_addr + 8U));
          
#line 2379 
          adapter->tx_fifo_head = 0U;
          
#line 2380 
          atomic_set(& adapter->tx_fifo_stall,0);
          
#line 2381 
          netif_wake_queue(netdev);
        }
        else 
#line 2367 
             goto _LAND_0;
      }
      else 
#line 2367 
           goto _LAND_0;
    }
    else {
      int tmp_2;
      _LAND_0: 
#line 2382 
      tmp_2 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
      
#line 2382 
      if (tmp_2 == 0) 
#line 2383 
                      ldv_schedule_delayed_work_86(& adapter->fifo_stall_task,1UL); else ;
    }
  }
  else ;
  
#line 2384 
  return;
}


#line 2388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
bool e1000_has_link(struct e1000_adapter *adapter)
{
  
#line 2390 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2391 
  bool link_active = (_Bool)0;
  
#line 2399 
  switch ((unsigned int)hw->media_type) {
    unsigned int tmp;
    case (unsigned int)0: 
#line 2400 
    ;
    
#line 2401 
    if (hw->mac_type == (unsigned int)e1000_ce4100) 
#line 2402 
                                                    hw->get_link_status = (_Bool)1; else ;
    
#line 2403 
    if ((int)hw->get_link_status != 0) {
      
#line 2404 
      e1000_check_for_link(hw);
      
#line 2405 
      link_active = (_Bool)(! ((int)hw->get_link_status != 0));
    }
    else 
#line 2407 
         link_active = (_Bool)1;
    
#line 2409 
    goto ldv_57081;
    case (unsigned int)1: 
#line 2410 
    ;
    
#line 2411 
    e1000_check_for_link(hw);
    
#line 2412 
    tmp = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 2412 
    link_active = (_Bool)((tmp & 2U) != 0U);
    
#line 2413 
    goto ldv_57081;
    case (unsigned int)2: 
#line 2414 
    ;
    
#line 2415 
    e1000_check_for_link(hw);
    
#line 2416 
    link_active = hw->serdes_has_link;
    
#line 2417 
    goto ldv_57081;
    default: 
#line 2418 
    ;
    
#line 2419 
    goto ldv_57081;
  }
  ldv_57081: 
#line 2422 
  ;
  
#line 2422 
  return link_active;
}


#line 2429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_watchdog(struct work_struct *work)
{
  struct e1000_adapter *tmp;
  u32 link;
  u32 tctl;
  bool tmp_0;
  bool tmp_1;
  int tmp_13;
  bool tmp_12;
  int tmp_16;
  {
    
#line 2431 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 2431 
    tmp = (struct e1000_adapter *)__mptr + 18446744073709549400U;
  }
  
#line 2431 
  struct e1000_adapter *adapter = tmp;
  
#line 2434 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2435 
  struct net_device *netdev = adapter->netdev;
  
#line 2436 
  struct e1000_tx_ring *txdr = adapter->tx_ring;
  
#line 2439 
  tmp_0 = e1000_has_link(adapter);
  
#line 2439 
  link = (unsigned int)tmp_0;
  
#line 2440 
  tmp_1 = netif_carrier_ok((struct net_device const *)netdev);
  
#line 2440 
  if ((int)tmp_1 != 0) {
    
#line 2440 
    if (link != 0U) 
#line 2441 
                    goto link_up; else ;
  }
  else ;
  
#line 2443 
  if (link != 0U) {
    int tmp_8;
    bool tmp_7;
    
#line 2444 
    tmp_7 = netif_carrier_ok((struct net_device const *)netdev);
    
#line 2444 
    if (tmp_7) 
#line 2444 
               tmp_8 = 0; else 
#line 2444 
                               tmp_8 = 1;
    
#line 2444 
    if (tmp_8) {
      u32 ctrl;
      char *tmp_4;
      char *tmp_5;
      int tmp_6;
      
#line 2446 
      bool txb2b = (_Bool)1;
      
#line 2448 
      e1000_get_speed_and_duplex(hw,& adapter->link_speed,& adapter->link_duplex);
      
#line 2452 
      ctrl = readl((void const volatile *)hw->hw_addr);
      
#line 2453 
      if ((ctrl & 268435456U) == 0U || (ctrl & 134217728U) == 0U) {
        char *tmp_3;
        
#line 2453 
        if ((ctrl & 134217728U) == 0U) {
          char *tmp_2;
          
#line 2453 
          if ((ctrl & 268435456U) != 0U) 
#line 2453 
                                         tmp_2 = (char *)"TX"; else 
#line 2453 
                                                                    tmp_2 = (char *)"None";
          
#line 2453 
          tmp_3 = tmp_2;
        }
        else 
#line 2453 
             tmp_3 = (char *)"RX";
        
#line 2453 
        tmp_4 = tmp_3;
      }
      else 
#line 2453 
           tmp_4 = (char *)"RX/TX";
      
#line 2453 
      if ((unsigned int)adapter->link_duplex == 2U) 
#line 2453 
                                                    tmp_5 = (char *)"Full Duplex"; else 
                                                                    
#line 2453 
                                                                    tmp_5 = (char *)"Half Duplex";
      
#line 2453 
      ;
      
#line 2453 
      ;
      
#line 2453 
      printk("\001",(char *)(& netdev->name),(int)adapter->link_speed,tmp_5,tmp_4);
      
#line 2465 
      adapter->tx_timeout_factor = (unsigned char)1U;
      
#line 2466 
      switch ((int)adapter->link_speed) {
        case 10: 
#line 2467 
        ;
        
#line 2468 
        txb2b = (_Bool)0;
        
#line 2469 
        adapter->tx_timeout_factor = (unsigned char)16U;
        
#line 2470 
        goto ldv_57100;
        case 100: 
#line 2471 
        ;
        
#line 2472 
        txb2b = (_Bool)0;
        
#line 2474 
        goto ldv_57100;
      }
      ldv_57100: 
#line 2478 
      ;
      
#line 2478 
      tctl = readl((void const volatile *)(hw->hw_addr + 1024U));
      
#line 2479 
      tctl |= 2U;
      
#line 2480 
      writel(tctl,(void volatile *)(hw->hw_addr + 1024U));
      
#line 2482 
      netif_carrier_on(netdev);
      
#line 2483 
      tmp_6 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
      
#line 2483 
      if (tmp_6 == 0) 
#line 2484 
                      ldv_schedule_delayed_work_87(& adapter->phy_info_task,500UL); else ;
      
#line 2486 
      adapter->smartspeed = 0U;
    }
    else ;
  }
  else {
    bool tmp_10;
    
#line 2489 
    tmp_10 = netif_carrier_ok((struct net_device const *)netdev);
    
#line 2489 
    if ((int)tmp_10 != 0) {
      int tmp_9;
      
#line 2490 
      adapter->link_speed = (unsigned short)0U;
      
#line 2491 
      adapter->link_duplex = (unsigned short)0U;
      
#line 2492 
      printk("\001",(char *)(& netdev->name));
      
#line 2494 
      netif_carrier_off(netdev);
      
#line 2496 
      tmp_9 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
      
#line 2496 
      if (tmp_9 == 0) 
#line 2497 
                      ldv_schedule_delayed_work_88(& adapter->phy_info_task,500UL); else ;
    }
    else ;
    
#line 2501 
    e1000_smartspeed(adapter);
  }
  link_up: 
#line 2504 
  ;
  
#line 2505 
  e1000_update_stats(adapter);
  
#line 2507 
  hw->tx_packet_delta = (unsigned int)adapter->stats.tpt - (unsigned int)adapter->tpt_old;
  
#line 2508 
  adapter->tpt_old = adapter->stats.tpt;
  
#line 2509 
  hw->collision_delta = (unsigned int)adapter->stats.colc - (unsigned int)adapter->colc_old;
  
#line 2510 
  adapter->colc_old = adapter->stats.colc;
  
#line 2512 
  adapter->gorcl = (unsigned int)adapter->stats.gorcl - (unsigned int)adapter->gorcl_old;
  
#line 2513 
  adapter->gorcl_old = adapter->stats.gorcl;
  
#line 2514 
  adapter->gotcl = (unsigned int)adapter->stats.gotcl - (unsigned int)adapter->gotcl_old;
  
#line 2515 
  adapter->gotcl_old = adapter->stats.gotcl;
  
#line 2517 
  e1000_update_adaptive(hw);
  
#line 2519 
  tmp_12 = netif_carrier_ok((struct net_device const *)netdev);
  
#line 2519 
  if (tmp_12) 
#line 2519 
              tmp_13 = 0; else 
#line 2519 
                               tmp_13 = 1;
  
#line 2519 
  if (tmp_13) {
    unsigned int tmp_11;
    
#line 2520 
    if (txdr->next_to_clean <= txdr->next_to_use) 
#line 2520 
                                                  tmp_11 = txdr->count; else 
                                                                    
#line 2520 
                                                                    tmp_11 = 0U;
    
#line 2520 
    ;
    
#line 2520 
    if ((tmp_11 + txdr->next_to_clean) - txdr->next_to_use < txdr->count) {
      
#line 2526 
      adapter->tx_timeout_count += 1U;
      
#line 2527 
      ldv_schedule_work_89(& adapter->reset_task);
      
#line 2529 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2534 
  if (hw->mac_type > (unsigned int)e1000_82544 && adapter->itr_setting == 4U) {
    u32 tmp_14;
    u32 tmp_15;
    
#line 2539 
    u32 goc = (adapter->gotcl + adapter->gorcl) / 10000U;
    
#line 2540 
    if (adapter->gotcl > adapter->gorcl) 
#line 2540 
                                         tmp_14 = (adapter->gotcl - adapter->gorcl) / 10000U; else 
                                                                    
#line 2540 
                                                                    tmp_14 = (adapter->gorcl - adapter->gotcl) / 10000U;
    
#line 2540 
    u32 dif = tmp_14;
    
#line 2543 
    if (goc != 0U) 
#line 2543 
                   tmp_15 = (dif * 6000U) / goc + 2000U; else 
#line 2543 
                                                              tmp_15 = 8000U;
    
#line 2543 
    u32 itr = tmp_15;
    
#line 2545 
    writel(1000000000U / (itr * 256U),(void volatile *)(hw->hw_addr + 196U));
  }
  else ;
  
#line 2549 
  writel(16U,(void volatile *)(hw->hw_addr + 200U));
  
#line 2552 
  adapter->detect_tx_hung = (_Bool)1;
  
#line 2555 
  tmp_16 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
  
#line 2555 
  if (tmp_16 == 0) 
#line 2556 
                   ldv_schedule_delayed_work_90(& adapter->watchdog_task,500UL); else ;
  return_label: 
#line 2557 
                return;
}


#line 2583  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static unsigned int e1000_update_itr(struct e1000_adapter *adapter, u16 itr_setting, int packets, int bytes)
{
  
#line 2586 
  unsigned int retval = (unsigned int)itr_setting;
  
#line 2587 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2589 
  if ((long)(hw->mac_type <= (unsigned int)e1000_82544) != 0L) 
#line 2590 
                                                               goto update_itr_done; else ;
  
#line 2592 
  if (packets == 0) 
#line 2593 
                    goto update_itr_done; else ;
  
#line 2595 
  switch ((int)itr_setting) {
    case 0: 
#line 2596 
    ;
    
#line 2598 
    if (bytes / packets > 8000) 
#line 2599 
                                retval = 2U;
    else 
      
#line 2600 
      if (packets <= 4 && bytes > 512) 
#line 2601 
                                       retval = 1U; else ;
    
#line 2602 
    goto ldv_57120;
    case 1: 
#line 2603 
    ;
    
#line 2604 
    if (bytes > 10000) {
      
#line 2606 
      if (bytes / packets > 8000) 
#line 2607 
                                  retval = 2U;
      else 
        
#line 2608 
        if (packets <= 9 || bytes / packets > 1200) 
#line 2609 
                                                    retval = 2U;
        else 
          
#line 2610 
          if (packets > 35) 
#line 2611 
                            retval = 0U; else ;
    }
    else 
      
#line 2612 
      if (bytes / packets > 2000) 
#line 2613 
                                  retval = 2U;
      else 
        
#line 2614 
        if (packets <= 2 && bytes <= 511) 
#line 2615 
                                          retval = 0U; else ;
    
#line 2616 
    goto ldv_57120;
    case 2: 
#line 2617 
    ;
    
#line 2618 
    if (bytes > 25000) {
      
#line 2619 
      if (packets > 35) 
#line 2620 
                        retval = 1U; else ;
    }
    else 
      
#line 2621 
      if (bytes <= 5999) 
#line 2622 
                         retval = 1U; else ;
    
#line 2624 
    goto ldv_57120;
  }
  ldv_57120: 
#line 2627 
  ;
  update_itr_done: 
#line 2627 
  ;
  
#line 2628 
  return retval;
}


#line 2631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_set_itr(struct e1000_adapter *adapter)
{
  u16 current_itr;
  unsigned int tmp;
  unsigned int tmp_0;
  int tmp_2;
  
#line 2633 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2635 
  u32 new_itr = adapter->itr;
  
#line 2637 
  if ((long)(hw->mac_type <= (unsigned int)e1000_82544) != 0L) 
#line 2638 
                                                               goto return_label; else ;
  
#line 2641 
  if ((long)((unsigned int)adapter->link_speed != 1000U) != 0L) {
    
#line 2642 
    current_itr = (unsigned short)0U;
    
#line 2643 
    new_itr = 4000U;
    
#line 2644 
    goto set_itr_now;
  }
  else ;
  
#line 2647 
  tmp = e1000_update_itr(adapter,(unsigned short)((int)adapter->tx_itr),(int)adapter->total_tx_packets,(int)adapter->total_tx_bytes);
  
#line 2647 
  adapter->tx_itr = (unsigned short)tmp;
  
#line 2651 
  if (adapter->itr_setting == 3U && (unsigned int)adapter->tx_itr == 0U) 
    
#line 2652 
    adapter->tx_itr = (unsigned short)1U; else ;
  
#line 2654 
  tmp_0 = e1000_update_itr(adapter,(unsigned short)((int)adapter->rx_itr),(int)adapter->total_rx_packets,(int)adapter->total_rx_bytes);
  
#line 2654 
  adapter->rx_itr = (unsigned short)tmp_0;
  
#line 2658 
  if (adapter->itr_setting == 3U && (unsigned int)adapter->rx_itr == 0U) 
    
#line 2659 
    adapter->rx_itr = (unsigned short)1U; else ;
  {
    int tmp_1;
    
#line 2661 
    u16 _max1 = adapter->rx_itr;
    
#line 2661 
    u16 _max2 = adapter->tx_itr;
    
#line 2661 
    if ((int)_max1 > (int)_max2) 
#line 2661 
                                 tmp_1 = (int)_max1; else 
#line 2661 
                                                          tmp_1 = (int)_max2;
    
#line 2661 
    tmp_2 = tmp_1;
  }
  
#line 2661 
  current_itr = (unsigned short)tmp_2;
  
#line 2663 
  switch ((int)current_itr) {
    case 0: 
#line 2665 
    ;
    
#line 2666 
    new_itr = 70000U;
    
#line 2667 
    goto ldv_57134;
    case 1: 
#line 2668 
    ;
    
#line 2669 
    new_itr = 20000U;
    
#line 2670 
    goto ldv_57134;
    case 2: 
#line 2671 
    ;
    
#line 2672 
    new_itr = 4000U;
    
#line 2673 
    goto ldv_57134;
    default: 
#line 2674 
    ;
    
#line 2675 
    goto ldv_57134;
  }
  ldv_57134: 
#line 2678 
  ;
  set_itr_now: 
#line 2678 
  ;
  
#line 2679 
  if (adapter->itr != new_itr) {
    
#line 2684 
    if (adapter->itr < new_itr) {
      u32 tmp_4;
      {
        u32 tmp_3;
        
#line 2685 
        u32 _min1 = adapter->itr + (new_itr >> 2);
        
#line 2685 
        u32 _min2 = new_itr;
        
#line 2685 
        if (_min1 < _min2) 
#line 2685 
                           tmp_3 = _min1; else 
#line 2685 
                                               tmp_3 = _min2;
        
#line 2685 
        tmp_4 = tmp_3;
      }
      
#line 2684 
      new_itr = tmp_4;
    }
    else 
#line 2684 
         new_itr = new_itr;
    
#line 2687 
    adapter->itr = new_itr;
    
#line 2688 
    writel(1000000000U / (new_itr * 256U),(void volatile *)(hw->hw_addr + 196U));
  }
  else ;
  return_label: 
#line 2690 
                return;
}


#line 2700  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_tso(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring, struct sk_buff *skb, __be16 protocol)
{
  int __retres;
  struct e1000_context_desc *context_desc;
  struct e1000_tx_buffer *buffer_info;
  unsigned int i;
  u16 tucse;
  u16 mss;
  u8 ipcss;
  u8 ipcso;
  u8 tucss;
  u8 tucso;
  u8 hdr_len;
  bool tmp_16;
  
#line 2707 
  u32 cmd_length = 0U;
  
#line 2708 
  u16 ipcse = (unsigned short)0U;
  
#line 2711 
  tmp_16 = skb_is_gso((struct sk_buff const *)skb);
  
#line 2711 
  if ((int)tmp_16 != 0) {
    int err;
    int tmp;
    unsigned int tmp_0;
    unsigned char *tmp_1;
    int tmp_12;
    struct iphdr *tmp_13;
    int tmp_14;
    struct tcphdr *tmp_15;
    
#line 2714 
    err = skb_cow_head(skb,0U);
    
#line 2715 
    if (err < 0) {
      
#line 2716 
      __retres = err;
      
#line 2716 
      goto return_label;
    }
    else ;
    
#line 2718 
    tmp = skb_transport_offset((struct sk_buff const *)skb);
    
#line 2718 
    tmp_0 = tcp_hdrlen((struct sk_buff const *)skb);
    
#line 2718 
    hdr_len = (unsigned char)((int)((unsigned char)tmp) + (int)((unsigned char)tmp_0));
    
#line 2719 
    tmp_1 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2719 
    mss = ((struct skb_shared_info *)tmp_1)->gso_size;
    
#line 2720 
    if ((unsigned int)protocol == 8U) {
      struct tcphdr *tmp_3;
      __sum16 tmp_4;
      int tmp_5;
      
#line 2721 
      struct iphdr *iph = ip_hdr((struct sk_buff const *)skb);
      
#line 2722 
      iph->tot_len = (unsigned short)0U;
      
#line 2723 
      iph->check = (unsigned short)0U;
      
#line 2724 
      tmp_3 = tcp_hdr((struct sk_buff const *)skb);
      
#line 2724 
      tmp_4 = csum_tcpudp_magic(iph->saddr,iph->daddr,(unsigned short)0,(unsigned short)6,0U);
      
#line 2724 
      tmp_3->check = (unsigned short)(~ ((int)tmp_4));
      
#line 2728 
      cmd_length = 33554432U;
      
#line 2729 
      tmp_5 = skb_transport_offset((struct sk_buff const *)skb);
      
#line 2729 
      ipcse = (unsigned short)((unsigned int)((unsigned short)tmp_5) + 65535U);
    }
    else {
      bool tmp_11;
      
#line 2730 
      tmp_11 = skb_is_gso_v6((struct sk_buff const *)skb);
      
#line 2730 
      if ((int)tmp_11 != 0) {
        struct ipv6hdr *tmp_6;
        struct tcphdr *tmp_7;
        __sum16 tmp_10;
        struct ipv6hdr *tmp_8;
        struct ipv6hdr *tmp_9;
        
#line 2731 
        tmp_6 = ipv6_hdr((struct sk_buff const *)skb);
        
#line 2731 
        tmp_6->payload_len = (unsigned short)0U;
        
#line 2732 
        tmp_7 = tcp_hdr((struct sk_buff const *)skb);
        
#line 2734 
        tmp_8 = ipv6_hdr((struct sk_buff const *)skb);
        
#line 2733 
        tmp_9 = ipv6_hdr((struct sk_buff const *)skb);
        
#line 2732 
        tmp_10 = csum_ipv6_magic((struct in6_addr const *)(& tmp_9->saddr),(struct in6_addr const *)(& tmp_8->daddr),0U,(unsigned short)6,0U);
        
#line 2732 
        tmp_7->check = (unsigned short)(~ ((int)tmp_10));
        
#line 2736 
        ipcse = (unsigned short)0U;
      }
      else ;
    }
    
#line 2738 
    tmp_12 = skb_network_offset((struct sk_buff const *)skb);
    
#line 2738 
    ipcss = (unsigned char)tmp_12;
    
#line 2739 
    tmp_13 = ip_hdr((struct sk_buff const *)skb);
    
#line 2739 
    ipcso = (unsigned char)((long)(& tmp_13->check) - (long)skb->data);
    
#line 2740 
    tmp_14 = skb_transport_offset((struct sk_buff const *)skb);
    
#line 2740 
    tucss = (unsigned char)tmp_14;
    
#line 2741 
    tmp_15 = tcp_hdr((struct sk_buff const *)skb);
    
#line 2741 
    tucso = (unsigned char)((long)(& tmp_15->check) - (long)skb->data);
    
#line 2742 
    tucse = (unsigned short)0U;
    
#line 2744 
    cmd_length = ((skb->len - (unsigned int)hdr_len) | cmd_length) | 620756992U;
    
#line 2747 
    i = tx_ring->next_to_use;
    
#line 2748 
    context_desc = (struct e1000_context_desc *)tx_ring->desc + i;
    
#line 2749 
    buffer_info = tx_ring->buffer_info + i;
    
#line 2751 
    context_desc->lower_setup.ip_fields.ipcss = ipcss;
    
#line 2752 
    context_desc->lower_setup.ip_fields.ipcso = ipcso;
    
#line 2753 
    context_desc->lower_setup.ip_fields.ipcse = ipcse;
    
#line 2754 
    context_desc->upper_setup.tcp_fields.tucss = tucss;
    
#line 2755 
    context_desc->upper_setup.tcp_fields.tucso = tucso;
    
#line 2756 
    context_desc->upper_setup.tcp_fields.tucse = tucse;
    
#line 2757 
    context_desc->tcp_seg_setup.fields.mss = mss;
    
#line 2758 
    context_desc->tcp_seg_setup.fields.hdr_len = hdr_len;
    
#line 2759 
    context_desc->cmd_and_length = cmd_length;
    
#line 2761 
    buffer_info->time_stamp = jiffies;
    
#line 2762 
    buffer_info->next_to_watch = (unsigned short)i;
    
#line 2764 
    i += 1U;
    
#line 2764 
    ;
    
#line 2764 
    if (i == tx_ring->count) 
#line 2764 
                             i = 0U; else ;
    
#line 2765 
    tx_ring->next_to_use = i;
    
#line 2767 
    __retres = 1;
    
#line 2767 
    goto return_label;
  }
  else ;
  
#line 2769 
  __retres = 0;
  return_label: 
#line 2769 
                return __retres;
}


#line 2772  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static bool e1000_tx_csum(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring, struct sk_buff *skb, __be16 protocol)
{
  bool __retres;
  struct e1000_context_desc *context_desc;
  struct e1000_tx_buffer *buffer_info;
  unsigned int i;
  u8 css;
  int tmp_2;
  
#line 2780 
  u32 cmd_len = 536870912U;
  
#line 2782 
  if ((unsigned int)*((unsigned char *)skb + 145UL) != 6U) {
    
#line 2783 
    __retres = (_Bool)0;
    
#line 2783 
    goto return_label;
  }
  else ;
  
#line 2785 
  switch ((int)protocol) {
    struct iphdr *tmp;
    struct ipv6hdr *tmp_0;
    int tmp_1;
    case 8: 
#line 2786 
    ;
    
#line 2787 
    tmp = ip_hdr((struct sk_buff const *)skb);
    
#line 2787 
    ;
    
#line 2787 
    if ((unsigned int)tmp->protocol == 6U) 
#line 2788 
                                           cmd_len |= 16777216U; else ;
    
#line 2789 
    goto ldv_57173;
    case 56710: 
#line 2790 
    ;
    
#line 2792 
    tmp_0 = ipv6_hdr((struct sk_buff const *)skb);
    
#line 2792 
    ;
    
#line 2792 
    if ((unsigned int)tmp_0->nexthdr == 6U) 
#line 2793 
                                            cmd_len |= 16777216U; else ;
    
#line 2794 
    goto ldv_57173;
    default: 
#line 2795 
    ;
    
#line 2796 
    tmp_1 = net_ratelimit();
    
#line 2796 
    if ((long)(tmp_1 != 0) != 0L) {
      
#line 2797 
      if ((adapter->msg_enable & 1) != 0) 
#line 2797 
                                          netdev_warn((struct net_device const *)adapter->netdev,"checksum_partial proto=%x!\n",(int)skb->protocol); else ;
    }
    else ;
    
#line 2799 
    goto ldv_57173;
  }
  ldv_57173: 
#line 2802 
  ;
  
#line 2802 
  tmp_2 = skb_checksum_start_offset((struct sk_buff const *)skb);
  
#line 2802 
  css = (unsigned char)tmp_2;
  
#line 2804 
  i = tx_ring->next_to_use;
  
#line 2805 
  buffer_info = tx_ring->buffer_info + i;
  
#line 2806 
  context_desc = (struct e1000_context_desc *)tx_ring->desc + i;
  
#line 2808 
  context_desc->lower_setup.ip_config = 0U;
  
#line 2809 
  context_desc->upper_setup.tcp_fields.tucss = css;
  
#line 2810 
  context_desc->upper_setup.tcp_fields.tucso = (unsigned char)((int)((unsigned char)skb->__anonCompField_sk_buff_82.__anonCompField___anonunion_285_81.csum_offset) + (int)css);
  
#line 2812 
  context_desc->upper_setup.tcp_fields.tucse = (unsigned short)0U;
  
#line 2813 
  context_desc->tcp_seg_setup.data = 0U;
  
#line 2814 
  context_desc->cmd_and_length = cmd_len;
  
#line 2816 
  buffer_info->time_stamp = jiffies;
  
#line 2817 
  buffer_info->next_to_watch = (unsigned short)i;
  
#line 2819 
  i += 1U;
  
#line 2819 
  ;
  
#line 2819 
  if ((long)(i == tx_ring->count) != 0L) 
#line 2819 
                                         i = 0U; else ;
  
#line 2820 
  tx_ring->next_to_use = i;
  
#line 2822 
  __retres = (_Bool)1;
  return_label: 
#line 2822 
                return __retres;
}


#line 2828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_tx_map(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring, struct sk_buff *skb, unsigned int first, unsigned int max_per_txd, unsigned int nr_frags, unsigned int mss)
{
  int __retres;
  struct e1000_tx_buffer *buffer_info;
  unsigned int size;
  unsigned int i;
  unsigned int f;
  unsigned int bytecount;
  unsigned int segs;
  unsigned int tmp_1;
  int tmp_4;
  int tmp_11;
  unsigned char *tmp_12;
  unsigned int tmp_13;
  unsigned int tmp_14;
  
#line 2834 
  struct e1000_hw *hw = & adapter->hw;
  
#line 2835 
  struct pci_dev *pdev = adapter->pdev;
  
#line 2837 
  unsigned int len = skb_headlen((struct sk_buff const *)skb);
  
#line 2838 
  unsigned int offset = 0U;
  
#line 2838 
  unsigned int count = 0U;
  
#line 2841 
  i = tx_ring->next_to_use;
  
#line 2843 
  goto ldv_57201;
  ldv_57200: 
#line 2844 
  ;
  
#line 2844 
  buffer_info = tx_ring->buffer_info + i;
  {
    unsigned int tmp_0;
    
#line 2845 
    unsigned int _min1 = len;
    
#line 2845 
    unsigned int _min2 = max_per_txd;
    
#line 2845 
    if (_min1 < _min2) 
#line 2845 
                       tmp_0 = _min1; else 
#line 2845 
                                           tmp_0 = _min2;
    
#line 2845 
    tmp_1 = tmp_0;
  }
  
#line 2845 
  size = tmp_1;
  
#line 2851 
  if (skb->data_len == 0U && (int)tx_ring->last_tx_tso != 0) {
    int tmp_3;
    bool tmp_2;
    
#line 2852 
    tmp_2 = skb_is_gso((struct sk_buff const *)skb);
    
#line 2852 
    if (tmp_2) 
#line 2852 
               tmp_3 = 0; else 
#line 2852 
                               tmp_3 = 1;
    
#line 2852 
    if (tmp_3) {
      
#line 2853 
      tx_ring->last_tx_tso = (_Bool)0;
      
#line 2854 
      size += 4294967292U;
    }
    else ;
  }
  else ;
  
#line 2860 
  if ((long)((mss != 0U && nr_frags == 0U) != 0) != 0L && (long)((size == len && size > 8U) != 0) != 0L) 
    
#line 2861 
    size += 4294967292U; else ;
  
#line 2867 
  if ((long)(hw->bus_type == (unsigned int)2) != 0L && (long)((size > 2015U && count == 0U) != 0) != 0L) 
    
#line 2869 
    size = 2015U; else ;
  
#line 2874 
  if ((((long)((int)adapter->pcix_82544 != 0) != 0L && (long)(((unsigned long)(skb->data + ((unsigned long)(offset + size) + 18446744073709551615U)) & 4UL) == 0UL) != 0L) != 0) != 0 && (long)(size > 4U) != 0L) 
    
#line 2877 
    size += 4294967292U; else ;
  
#line 2879 
  buffer_info->length = (unsigned short)size;
  
#line 2881 
  buffer_info->time_stamp = jiffies;
  
#line 2882 
  buffer_info->mapped_as_page = (_Bool)0;
  
#line 2883 
  buffer_info->dma = dma_map_single_attrs(& pdev->dev,(void *)(skb->data + offset),(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 2886 
  tmp_4 = dma_mapping_error(& pdev->dev,buffer_info->dma);
  
#line 2886 
  if (tmp_4 != 0) 
#line 2887 
                  goto dma_error; else ;
  
#line 2888 
  buffer_info->next_to_watch = (unsigned short)i;
  
#line 2890 
  len -= size;
  
#line 2891 
  offset += size;
  
#line 2892 
  count += 1U;
  
#line 2893 
  if (len != 0U) {
    
#line 2894 
    i += 1U;
    
#line 2895 
    if ((long)(tx_ring->count == i) != 0L) 
#line 2896 
                                           i = 0U; else ;
  }
  else ;
  ldv_57201: 
#line 2898 
  ;
  
#line 2843 
  if (len != 0U) 
#line 2845 
                 goto ldv_57200; else 
#line 2848 
                                      goto ldv_57202;
  ldv_57202: 
#line 2849 
  ;
  
#line 2900 
  f = 0U;
  
#line 2900 
  goto ldv_57212;
  ldv_57211: 
#line 2901 
  ;
  {
    struct skb_frag_struct const *frag;
    unsigned char *tmp_5;
    
#line 2903 
    tmp_5 = skb_end_pointer((struct sk_buff const *)skb);
    
#line 2903 
    frag = (struct skb_frag_struct const *)(& ((struct skb_shared_info *)tmp_5)->frags[f]);
    
#line 2904 
    len = skb_frag_size(frag);
    
#line 2905 
    offset = 0U;
    
#line 2907 
    goto ldv_57209;
    ldv_57208: 
#line 2908 
    ;
    {
      unsigned long bufend;
      unsigned int tmp_7;
      struct page *tmp_8;
      int tmp_9;
      
#line 2909 
      i += 1U;
      
#line 2910 
      if ((long)(tx_ring->count == i) != 0L) 
#line 2911 
                                             i = 0U; else ;
      
#line 2913 
      buffer_info = tx_ring->buffer_info + i;
      {
        unsigned int tmp_6;
        
#line 2914 
        unsigned int _min1_0 = len;
        
#line 2914 
        unsigned int _min2_0 = max_per_txd;
        
#line 2914 
        if (_min1_0 < _min2_0) 
#line 2914 
                               tmp_6 = _min1_0; else 
#line 2914 
                                                     tmp_6 = _min2_0;
        
#line 2914 
        tmp_7 = tmp_6;
      }
      
#line 2914 
      size = tmp_7;
      
#line 2918 
      if ((((long)(mss != 0U) != 0L && (long)(nr_frags + 4294967295U == f) != 0L) != 0) != 0 && (long)((size == len && size > 8U) != 0) != 0L) 
        
#line 2920 
        size += 4294967292U; else ;
      
#line 2926 
      tmp_8 = skb_frag_page(frag);
      
#line 2925 
      bufend = (unsigned long)((unsigned long long)(((long)tmp_8 + 24189255811072L) / 64L) << 12);
      
#line 2927 
      bufend = (unsigned long)((offset + size) + 4294967295U) + bufend;
      
#line 2928 
      if ((((long)((int)adapter->pcix_82544 != 0) != 0L && (long)((bufend & 4UL) == 0UL) != 0L) != 0) != 0 && (long)(size > 4U) != 0L) 
        
#line 2931 
        size += 4294967292U; else ;
      
#line 2933 
      buffer_info->length = (unsigned short)size;
      
#line 2934 
      buffer_info->time_stamp = jiffies;
      
#line 2935 
      buffer_info->mapped_as_page = (_Bool)1;
      
#line 2936 
      buffer_info->dma = skb_frag_dma_map(& pdev->dev,frag,(unsigned long)offset,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE);
      
#line 2938 
      tmp_9 = dma_mapping_error(& pdev->dev,buffer_info->dma);
      
#line 2938 
      if (tmp_9 != 0) 
#line 2939 
                      goto dma_error; else ;
      
#line 2940 
      buffer_info->next_to_watch = (unsigned short)i;
      
#line 2942 
      len -= size;
      
#line 2943 
      offset += size;
      
#line 2944 
      count += 1U;
    }
    ldv_57209: 
#line 2946 
    ;
    
#line 2907 
    if (len != 0U) 
#line 2909 
                   goto ldv_57208; else 
#line 2912 
                                        goto ldv_57210;
    ldv_57210: 
#line 2913 
    ;
  }
  
#line 2900 
  f += 1U;
  ldv_57212: 
#line 2901 
  ;
  
#line 2900 
  if (f < nr_frags) 
#line 2902 
                    goto ldv_57211; else 
#line 2905 
                                         goto ldv_57213;
  ldv_57213: 
#line 2906 
  ;
  
#line 2948 
  tmp_12 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 2948 
  tmp_11 = (int)((struct skb_shared_info *)tmp_12)->gso_segs != 0;
  
#line 2948 
  if (tmp_11) ; else 
#line 2948 
                     tmp_11 = 1;
  
#line 2948 
  segs = (unsigned int)tmp_11;
  
#line 2950 
  tmp_13 = skb_headlen((struct sk_buff const *)skb);
  
#line 2950 
  bytecount = (segs + 4294967295U) * tmp_13 + skb->len;
  
#line 2952 
  (tx_ring->buffer_info + i)->skb = skb;
  
#line 2953 
  (tx_ring->buffer_info + i)->segs = (unsigned short)segs;
  
#line 2954 
  (tx_ring->buffer_info + i)->bytecount = bytecount;
  
#line 2955 
  (tx_ring->buffer_info + first)->next_to_watch = (unsigned short)i;
  
#line 2957 
  __retres = (int)count;
  
#line 2957 
  goto return_label;
  dma_error: 
#line 2959 
  ;
  
#line 2960 
  dev_err((struct device const *)(& pdev->dev),"TX DMA map failed\n");
  
#line 2961 
  buffer_info->dma = 0ULL;
  
#line 2962 
  if (count != 0U) 
#line 2963 
                   count -= 1U; else ;
  
#line 2965 
  goto ldv_57215;
  ldv_57214: 
#line 2966 
  ;
  
#line 2966 
  if (i == 0U) 
#line 2967 
               i = tx_ring->count + i; else ;
  
#line 2968 
  i -= 1U;
  
#line 2969 
  buffer_info = tx_ring->buffer_info + i;
  
#line 2970 
  e1000_unmap_and_free_tx_resource(adapter,buffer_info);
  ldv_57215: 
#line 2971 
  ;
  
#line 2965 
  tmp_14 = count;
  
#line 2965 
  count -= 1U;
  
#line 2965 
  ;
  
#line 2965 
  if (tmp_14 != 0U) 
#line 2967 
                    goto ldv_57214; else 
#line 2970 
                                         goto ldv_57216;
  ldv_57216: 
#line 2971 
  ;
  
#line 2973 
  __retres = 0;
  return_label: 
#line 2973 
                return __retres;
}


#line 2976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_tx_queue(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring, int tx_flags, int count)
{
  struct e1000_tx_buffer *buffer_info;
  unsigned int i;
  int tmp;
  
#line 2980 
  struct e1000_tx_desc *tx_desc = (struct e1000_tx_desc *)0;
  
#line 2982 
  u32 txd_upper = 0U;
  
#line 2982 
  u32 txd_lower = 33554432U;
  
#line 2985 
  if ((long)((tx_flags & 4) != 0) != 0L) {
    
#line 2986 
    txd_lower |= 605028352U;
    
#line 2988 
    txd_upper |= 512U;
    
#line 2990 
    if ((long)((tx_flags & 8) != 0) != 0L) 
#line 2991 
                                           txd_upper |= 256U; else ;
  }
  else ;
  
#line 2994 
  if ((long)((tx_flags & 1) != 0) != 0L) {
    
#line 2995 
    txd_lower |= 537919488U;
    
#line 2996 
    txd_upper |= 512U;
  }
  else ;
  
#line 2999 
  if ((long)((tx_flags & 2) != 0) != 0L) {
    
#line 3000 
    txd_lower |= 1073741824U;
    
#line 3001 
    txd_upper = ((unsigned int)tx_flags & 4294901760U) | txd_upper;
  }
  else ;
  
#line 3004 
  if ((long)((tx_flags & 16) != 0) != 0L) 
#line 3005 
                                          txd_lower &= 4261412863U; else ;
  
#line 3007 
  i = tx_ring->next_to_use;
  
#line 3009 
  goto ldv_57229;
  ldv_57228: 
#line 3010 
  ;
  
#line 3010 
  buffer_info = tx_ring->buffer_info + i;
  
#line 3011 
  tx_desc = (struct e1000_tx_desc *)tx_ring->desc + i;
  
#line 3012 
  tx_desc->buffer_addr = buffer_info->dma;
  
#line 3013 
  tx_desc->lower.data = (unsigned int)buffer_info->length | txd_lower;
  
#line 3015 
  tx_desc->upper.data = txd_upper;
  
#line 3016 
  i += 1U;
  
#line 3016 
  ;
  
#line 3016 
  if ((long)(i == tx_ring->count) != 0L) 
#line 3016 
                                         i = 0U; else ;
  ldv_57229: 
#line 3017 
  ;
  
#line 3009 
  tmp = count;
  
#line 3009 
  count -= 1;
  
#line 3009 
  ;
  
#line 3009 
  if (tmp != 0) 
#line 3011 
                goto ldv_57228; else 
#line 3014 
                                     goto ldv_57230;
  ldv_57230: 
#line 3015 
  ;
  
#line 3019 
  tx_desc->lower.data |= adapter->txd_cmd;
  
#line 3022 
  if ((long)((tx_flags & 16) != 0) != 0L) 
#line 3023 
                                          tx_desc->lower.data &= 4261412863U; else ;
  
#line 3024 
  ldv_inline_asm();
  
#line 3032 
  tx_ring->next_to_use = i;
  
#line 3033 
  return;
}


#line 3046  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_82547_fifo_workaround(struct e1000_adapter *adapter, struct sk_buff *skb)
{
  int __retres;
  int tmp;
  
#line 3049 
  u32 fifo_space = adapter->tx_fifo_size - adapter->tx_fifo_head;
  
#line 3050 
  u32 skb_fifo_len = skb->len + 16U;
  
#line 3052 
  skb_fifo_len = (skb_fifo_len + 15U) & 4294967280U;
  
#line 3054 
  if ((unsigned int)adapter->link_duplex != 1U) 
#line 3055 
                                                goto no_fifo_stall_required; else ;
  
#line 3057 
  tmp = atomic_read((atomic_t const *)(& adapter->tx_fifo_stall));
  
#line 3057 
  if (tmp != 0) {
    
#line 3058 
    __retres = 1;
    
#line 3058 
    goto return_label;
  }
  else ;
  
#line 3060 
  if (fifo_space + 992U <= skb_fifo_len) {
    
#line 3061 
    atomic_set(& adapter->tx_fifo_stall,1);
    
#line 3062 
    __retres = 1;
    
#line 3062 
    goto return_label;
  }
  else ;
  no_fifo_stall_required: 
#line 3065 
  ;
  
#line 3066 
  adapter->tx_fifo_head += skb_fifo_len;
  
#line 3067 
  if (adapter->tx_fifo_head >= adapter->tx_fifo_size) 
#line 3068 
                                                      adapter->tx_fifo_head -= adapter->tx_fifo_size; else ;
  
#line 3069 
  __retres = 0;
  return_label: 
#line 3069 
                return __retres;
}


#line 3072  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int __e1000_maybe_stop_tx(struct net_device *netdev, int size)
{
  int __retres;
  unsigned int tmp_0;
  
#line 3074 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 3075 
  struct e1000_tx_ring *tx_ring = adapter->tx_ring;
  
#line 3077 
  netif_start_queue(netdev);
  
#line 3078 
  ldv_inline_asm();
  
#line 3087 
  if (tx_ring->next_to_clean <= tx_ring->next_to_use) 
#line 3087 
                                                      tmp_0 = tx_ring->count; else 
                                                                    
#line 3087 
                                                                    tmp_0 = 0U;
  
#line 3087 
  ;
  
#line 3087 
  if ((long)(((tmp_0 + tx_ring->next_to_clean) - tx_ring->next_to_use) + 4294967295U < (unsigned int)size) != 0L) {
    
#line 3088 
    __retres = -16;
    
#line 3088 
    goto return_label;
  }
  else ;
  
#line 3091 
  netif_start_queue(netdev);
  
#line 3092 
  adapter->restart_queue += 1U;
  
#line 3093 
  __retres = 0;
  return_label: 
#line 3093 
                return __retres;
}


#line 3096  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_maybe_stop_tx(struct net_device *netdev, struct e1000_tx_ring *tx_ring, int size)
{
  int __retres;
  unsigned int tmp;
  int tmp_0;
  
#line 3099 
  if (tx_ring->next_to_clean <= tx_ring->next_to_use) 
#line 3099 
                                                      tmp = tx_ring->count; else 
                                                                    
#line 3099 
                                                                    tmp = 0U;
  
#line 3099 
  ;
  
#line 3099 
  if ((long)(((tmp + tx_ring->next_to_clean) - tx_ring->next_to_use) + 4294967295U >= (unsigned int)size) != 0L) {
    
#line 3100 
    __retres = 0;
    
#line 3100 
    goto return_label;
  }
  else ;
  
#line 3101 
  tmp_0 = __e1000_maybe_stop_tx(netdev,size);
  
#line 3101 
  __retres = tmp_0;
  return_label: 
#line 3101 
                return __retres;
}


#line 3105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
{
  netdev_tx_t __retres;
  struct e1000_tx_ring *tx_ring;
  unsigned int first;
  unsigned int nr_frags;
  unsigned int mss;
  int tso;
  unsigned int f;
  int tmp_2;
  unsigned char *tmp_3;
  unsigned char *tmp_15;
  unsigned int tmp_17;
  unsigned char *tmp_16;
  int tmp_18;
  
#line 3108 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 3109 
  struct e1000_hw *hw = & adapter->hw;
  
#line 3111 
  unsigned int max_per_txd = 4096U;
  
#line 3112 
  unsigned int max_txd_pwr = 12U;
  
#line 3113 
  unsigned int tx_flags = 0U;
  
#line 3114 
  unsigned int len = skb_headlen((struct sk_buff const *)skb);
  
#line 3117 
  int count = 0;
  
#line 3120 
  __be16 protocol = vlan_get_protocol(skb);
  
#line 3127 
  tx_ring = adapter->tx_ring;
  
#line 3133 
  tmp_2 = eth_skb_pad(skb);
  
#line 3133 
  if (tmp_2 != 0) {
    
#line 3134 
    __retres = NETDEV_TX_OK;
    
#line 3134 
    goto return_label;
  }
  else ;
  
#line 3136 
  tmp_3 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 3136 
  mss = (unsigned int)((struct skb_shared_info *)tmp_3)->gso_size;
  
#line 3144 
  if (mss != 0U) {
    u8 hdr_len;
    unsigned int tmp_5;
    int tmp_6;
    int tmp_7;
    unsigned int tmp_8;
    {
      unsigned int tmp_4;
      
#line 3146 
      unsigned int _min1 = mss << 2;
      
#line 3146 
      unsigned int _min2 = max_per_txd;
      
#line 3146 
      if (_min1 < _min2) 
#line 3146 
                         tmp_4 = _min1; else 
#line 3146 
                                             tmp_4 = _min2;
      
#line 3146 
      tmp_5 = tmp_4;
    }
    
#line 3146 
    max_per_txd = tmp_5;
    
#line 3147 
    tmp_6 = fls((int)max_per_txd);
    
#line 3147 
    max_txd_pwr = (unsigned int)(tmp_6 + -1);
    
#line 3149 
    tmp_7 = skb_transport_offset((struct sk_buff const *)skb);
    
#line 3149 
    tmp_8 = tcp_hdrlen((struct sk_buff const *)skb);
    
#line 3149 
    hdr_len = (unsigned char)((int)((unsigned char)tmp_7) + (int)((unsigned char)tmp_8));
    
#line 3150 
    if (skb->data_len != 0U && (unsigned int)hdr_len == len) {
      
#line 3151 
      switch ((unsigned int)hw->mac_type) {
        unsigned int pull_size;
        unsigned char *tmp_9;
        unsigned int tmp_11;
        unsigned char *tmp_12;
        case (unsigned int)4: 
#line 3153 
        ;
        
#line 3161 
        tmp_9 = skb_tail_pointer((struct sk_buff const *)skb);
        
#line 3161 
        if (((unsigned long)(tmp_9 + 18446744073709551615U) & 4UL) != 0UL) 
          
#line 3163 
          goto ldv_57273; else ;
        {
          unsigned int tmp_10;
          
#line 3165 
          unsigned int _min1_0 = 4U;
          
#line 3165 
          unsigned int _min2_0 = skb->data_len;
          
#line 3165 
          if (_min1_0 < _min2_0) 
#line 3165 
                                 tmp_10 = _min1_0; else 
#line 3165 
                                                        tmp_10 = _min2_0;
          
#line 3165 
          tmp_11 = tmp_10;
        }
        
#line 3165 
        pull_size = tmp_11;
        
#line 3166 
        tmp_12 = __pskb_pull_tail(skb,(int)pull_size);
        
#line 3166 
        if (tmp_12 == (unsigned char *)0U) {
          
#line 3167 
          if ((adapter->msg_enable & 1) != 0) 
#line 3167 
                                              netdev_err((struct net_device const *)adapter->netdev,"__pskb_pull_tail "); else ;
          
#line 3169 
          dev_kfree_skb_any(skb);
          
#line 3170 
          __retres = NETDEV_TX_OK;
          
#line 3170 
          goto return_label;
        }
        else ;
        
#line 3172 
        len = skb_headlen((struct sk_buff const *)skb);
        
#line 3173 
        goto ldv_57273;
        default: 
#line 3174 
        ;
        
#line 3176 
        goto ldv_57273;
      }
      ldv_57273: 
#line 3178 
      ;
    }
    else ;
  }
  else ;
  
#line 3182 
  if (mss != 0U || (unsigned int)*((unsigned char *)skb + 145UL) == 6U) 
    
#line 3183 
    count += 1; else ;
  
#line 3184 
  count += 1;
  
#line 3187 
  if (skb->data_len == 0U && (int)tx_ring->last_tx_tso != 0) {
    int tmp_14;
    bool tmp_13;
    
#line 3187 
    tmp_13 = skb_is_gso((struct sk_buff const *)skb);
    
#line 3187 
    if (tmp_13) 
#line 3187 
                tmp_14 = 0; else 
#line 3187 
                                 tmp_14 = 1;
    
#line 3187 
    if (tmp_14) 
#line 3188 
                count += 1; else ;
  }
  else ;
  
#line 3190 
  count = (int)(((len >> max_txd_pwr) + (unsigned int)count) + 1U);
  
#line 3192 
  if ((int)adapter->pcix_82544 != 0) 
#line 3193 
                                     count += 1; else ;
  
#line 3198 
  if ((long)(hw->bus_type == (unsigned int)2) != 0L && (long)(len > 2015U) != 0L) 
    
#line 3200 
    count += 1; else ;
  
#line 3202 
  tmp_15 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 3202 
  nr_frags = (unsigned int)((struct skb_shared_info *)tmp_15)->nr_frags;
  
#line 3203 
  f = 0U;
  
#line 3203 
  goto ldv_57279;
  ldv_57278: 
#line 3204 
  ;
  
#line 3204 
  tmp_16 = skb_end_pointer((struct sk_buff const *)skb);
  
#line 3204 
  tmp_17 = skb_frag_size((skb_frag_t const *)(& ((struct skb_shared_info *)tmp_16)->frags[f]));
  
#line 3205 
  count = (int)(((tmp_17 >> max_txd_pwr) + 1U) + (unsigned int)count);
  
#line 3203 
  f += 1U;
  ldv_57279: 
#line 3204 
  ;
  
#line 3203 
  if (f < nr_frags) 
#line 3205 
                    goto ldv_57278; else 
#line 3208 
                                         goto ldv_57280;
  ldv_57280: 
#line 3209 
  ;
  
#line 3206 
  if ((int)adapter->pcix_82544 != 0) 
#line 3207 
                                     count = (int)((unsigned int)count + nr_frags); else ;
  
#line 3212 
  tmp_18 = e1000_maybe_stop_tx(netdev,tx_ring,count + 2);
  
#line 3212 
  if ((long)(tmp_18 != 0) != 0L) {
    
#line 3213 
    __retres = NETDEV_TX_BUSY;
    
#line 3213 
    goto return_label;
  }
  else ;
  
#line 3215 
  if ((long)(hw->mac_type == (unsigned int)e1000_82547) != 0L) {
    int tmp_20;
    
#line 3215 
    tmp_20 = e1000_82547_fifo_workaround(adapter,skb);
    
#line 3215 
    if ((long)(tmp_20 != 0) != 0L) {
      int tmp_19;
      
#line 3217 
      netif_start_queue(netdev);
      
#line 3218 
      tmp_19 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
      
#line 3218 
      if (tmp_19 == 0) 
#line 3219 
                       ldv_schedule_delayed_work_91(& adapter->fifo_stall_task,1UL); else ;
      
#line 3220 
      __retres = NETDEV_TX_BUSY;
      
#line 3220 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 3223 
  if (((int)skb->vlan_tci & 4096) != 0) {
    
#line 3224 
    tx_flags |= 2U;
    
#line 3225 
    tx_flags = ((unsigned int)((int)skb->vlan_tci << 16) & 4026466304U) | tx_flags;
  }
  else ;
  
#line 3229 
  first = tx_ring->next_to_use;
  
#line 3231 
  tso = e1000_tso(adapter,tx_ring,skb,(unsigned short)((int)protocol));
  
#line 3232 
  if (tso < 0) {
    
#line 3233 
    dev_kfree_skb_any(skb);
    
#line 3234 
    __retres = NETDEV_TX_OK;
    
#line 3234 
    goto return_label;
  }
  else ;
  
#line 3237 
  if ((long)(tso != 0) != 0L) {
    
#line 3238 
    if ((long)(hw->mac_type != (unsigned int)e1000_82544) != 0L) 
#line 3239 
                                                                 tx_ring->last_tx_tso = (_Bool)1; else ;
    
#line 3240 
    tx_flags |= 4U;
  }
  else {
    bool tmp_21;
    
#line 3241 
    tmp_21 = e1000_tx_csum(adapter,tx_ring,skb,(unsigned short)((int)protocol));
    
#line 3241 
    if ((long)((int)tmp_21 != 0) != 0L) 
#line 3242 
                                        tx_flags |= 1U; else ;
  }
  
#line 3244 
  if ((unsigned int)protocol == 8U) 
#line 3245 
                                    tx_flags |= 8U; else ;
  
#line 3247 
  if ((long)((unsigned int)*((unsigned char *)skb + 146UL) != 0U) != 0L) 
    
#line 3248 
    tx_flags |= 16U; else ;
  
#line 3250 
  count = e1000_tx_map(adapter,tx_ring,skb,first,max_per_txd,nr_frags,mss);
  
#line 3253 
  if (count != 0) {
    
#line 3254 
    netdev_sent_queue(netdev,skb->len);
    
#line 3255 
    skb_tx_timestamp(skb);
    
#line 3257 
    e1000_tx_queue(adapter,tx_ring,(int)tx_flags,count);
    
#line 3259 
    e1000_maybe_stop_tx(netdev,tx_ring,19);
    
#line 3261 
    if ((unsigned int)*((unsigned char *)skb + 142UL) == 0U) 
#line 3261 
                                                             goto _LOR;
    else {
      bool tmp_23;
      struct netdev_queue *tmp_22;
      
#line 3262 
      tmp_22 = netdev_get_tx_queue((struct net_device const *)netdev,0U);
      
#line 3261 
      tmp_23 = netif_xmit_stopped((struct netdev_queue const *)tmp_22);
      
#line 3261 
      if ((int)tmp_23 != 0) {
        _LOR: {
                
#line 3263 
                writel(tx_ring->next_to_use,(void volatile *)(hw->hw_addr + (int)tx_ring->tdt));
                
#line 3264 
                ldv_inline_asm();
              }
      }
      else ;
    }
  }
  else {
    
#line 3271 
    dev_kfree_skb_any(skb);
    
#line 3272 
    (tx_ring->buffer_info + first)->time_stamp = 0UL;
    
#line 3273 
    tx_ring->next_to_use = first;
  }
  
#line 3276 
  __retres = NETDEV_TX_OK;
  return_label: 
#line 3276 
                return __retres;
}


#line 3280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_regdump(struct e1000_adapter *adapter)
{
  u32 regs[38U];
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  
#line 3282 
  struct e1000_hw *hw = & adapter->hw;
  
#line 3284 
  u32 *regs_buff = (u32 *)(& regs);
  
#line 3285 
  int i = 0;
  
#line 3287 
  char const * const reg_name[38U] = {"CTRL", "STATUS", "RCTL", "RDLEN", "RDH", "RDT", "RDTR", "TCTL", "TDBAL", "TDBAH", "TDLEN", "TDH", "TDT", "TIDV", "TXDCTL", "TADV", "TARC0", "TDBAL1", "TDBAH1", "TDLEN1", "TDH1", "TDT1", "TXDCTL1", "TARC1", "CTRL_EXT", "ERT", "RDBAL", "RDBAH", "TDFH", "TDFT", "TDFHS", "TDFTS", "TDFPC", "RDFH", "RDFT", "RDFHS", "RDFTS", "RDFPC"};
  
#line 3299 
  *regs_buff = readl((void const volatile *)hw->hw_addr);
  
#line 3300 
  *(regs_buff + 1U) = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 3302 
  *(regs_buff + 2U) = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 3303 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3303 
                                                       tmp = 10248; else 
                                                                    
#line 3303 
                                                                    tmp = 280;
  
#line 3303 
  ;
  
#line 3303 
  *(regs_buff + 3U) = readl((void const volatile *)(hw->hw_addr + tmp));
  
#line 3304 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3304 
                                                       tmp_0 = 10256; else 
                                                                    
#line 3304 
                                                                    tmp_0 = 288;
  
#line 3304 
  ;
  
#line 3304 
  *(regs_buff + 4U) = readl((void const volatile *)(hw->hw_addr + tmp_0));
  
#line 3305 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3305 
                                                       tmp_1 = 10264; else 
                                                                    
#line 3305 
                                                                    tmp_1 = 296;
  
#line 3305 
  ;
  
#line 3305 
  *(regs_buff + 5U) = readl((void const volatile *)(hw->hw_addr + tmp_1));
  
#line 3306 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3306 
                                                       tmp_2 = 10272; else 
                                                                    
#line 3306 
                                                                    tmp_2 = 264;
  
#line 3306 
  ;
  
#line 3306 
  *(regs_buff + 6U) = readl((void const volatile *)(hw->hw_addr + tmp_2));
  
#line 3308 
  *(regs_buff + 7U) = readl((void const volatile *)(hw->hw_addr + 1024U));
  
#line 3309 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3309 
                                                       tmp_3 = 14336; else 
                                                                    
#line 3309 
                                                                    tmp_3 = 1056;
  
#line 3309 
  ;
  
#line 3309 
  *(regs_buff + 8U) = readl((void const volatile *)(hw->hw_addr + tmp_3));
  
#line 3310 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3310 
                                                       tmp_4 = 14340; else 
                                                                    
#line 3310 
                                                                    tmp_4 = 1060;
  
#line 3310 
  ;
  
#line 3310 
  *(regs_buff + 9U) = readl((void const volatile *)(hw->hw_addr + tmp_4));
  
#line 3311 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3311 
                                                       tmp_5 = 14344; else 
                                                                    
#line 3311 
                                                                    tmp_5 = 1064;
  
#line 3311 
  ;
  
#line 3311 
  *(regs_buff + 10U) = readl((void const volatile *)(hw->hw_addr + tmp_5));
  
#line 3312 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3312 
                                                       tmp_6 = 14352; else 
                                                                    
#line 3312 
                                                                    tmp_6 = 1072;
  
#line 3312 
  ;
  
#line 3312 
  *(regs_buff + 11U) = readl((void const volatile *)(hw->hw_addr + tmp_6));
  
#line 3313 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3313 
                                                       tmp_7 = 14360; else 
                                                                    
#line 3313 
                                                                    tmp_7 = 1080;
  
#line 3313 
  ;
  
#line 3313 
  *(regs_buff + 12U) = readl((void const volatile *)(hw->hw_addr + tmp_7));
  
#line 3314 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3314 
                                                       tmp_8 = 14368; else 
                                                                    
#line 3314 
                                                                    tmp_8 = 1088;
  
#line 3314 
  ;
  
#line 3314 
  *(regs_buff + 13U) = readl((void const volatile *)(hw->hw_addr + tmp_8));
  
#line 3315 
  *(regs_buff + 14U) = readl((void const volatile *)(hw->hw_addr + 14376U));
  
#line 3316 
  *(regs_buff + 15U) = readl((void const volatile *)(hw->hw_addr + 14380U));
  
#line 3317 
  *(regs_buff + 16U) = readl((void const volatile *)(hw->hw_addr + 14400U));
  
#line 3319 
  *(regs_buff + 17U) = readl((void const volatile *)(hw->hw_addr + 14592U));
  
#line 3320 
  *(regs_buff + 18U) = readl((void const volatile *)(hw->hw_addr + 14596U));
  
#line 3321 
  *(regs_buff + 19U) = readl((void const volatile *)(hw->hw_addr + 14600U));
  
#line 3322 
  *(regs_buff + 20U) = readl((void const volatile *)(hw->hw_addr + 14608U));
  
#line 3323 
  *(regs_buff + 21U) = readl((void const volatile *)(hw->hw_addr + 14616U));
  
#line 3324 
  *(regs_buff + 22U) = readl((void const volatile *)(hw->hw_addr + 14632U));
  
#line 3325 
  *(regs_buff + 23U) = readl((void const volatile *)(hw->hw_addr + 14656U));
  
#line 3326 
  *(regs_buff + 24U) = readl((void const volatile *)(hw->hw_addr + 24U));
  
#line 3327 
  *(regs_buff + 25U) = readl((void const volatile *)(hw->hw_addr + 8200U));
  
#line 3328 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3328 
                                                       tmp_9 = 10240; else 
                                                                    
#line 3328 
                                                                    tmp_9 = 272;
  
#line 3328 
  ;
  
#line 3328 
  *(regs_buff + 26U) = readl((void const volatile *)(hw->hw_addr + tmp_9));
  
#line 3329 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3329 
                                                       tmp_10 = 10244; else 
                                                                    
#line 3329 
                                                                    tmp_10 = 276;
  
#line 3329 
  ;
  
#line 3329 
  *(regs_buff + 27U) = readl((void const volatile *)(hw->hw_addr + tmp_10));
  
#line 3330 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3330 
                                                       tmp_11 = 13328; else 
                                                                    
#line 3330 
                                                                    tmp_11 = 32784;
  
#line 3330 
  ;
  
#line 3330 
  *(regs_buff + 28U) = readl((void const volatile *)(hw->hw_addr + tmp_11));
  
#line 3331 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 3331 
                                                       tmp_12 = 13336; else 
                                                                    
#line 3331 
                                                                    tmp_12 = 32792;
  
#line 3331 
  ;
  
#line 3331 
  *(regs_buff + 29U) = readl((void const volatile *)(hw->hw_addr + tmp_12));
  
#line 3332 
  *(regs_buff + 30U) = readl((void const volatile *)(hw->hw_addr + 13344U));
  
#line 3333 
  *(regs_buff + 31U) = readl((void const volatile *)(hw->hw_addr + 13352U));
  
#line 3334 
  *(regs_buff + 32U) = readl((void const volatile *)(hw->hw_addr + 13360U));
  
#line 3335 
  *(regs_buff + 33U) = readl((void const volatile *)(hw->hw_addr + 9232U));
  
#line 3336 
  *(regs_buff + 34U) = readl((void const volatile *)(hw->hw_addr + 9240U));
  
#line 3337 
  *(regs_buff + 35U) = readl((void const volatile *)(hw->hw_addr + 9248U));
  
#line 3338 
  *(regs_buff + 36U) = readl((void const volatile *)(hw->hw_addr + 9256U));
  
#line 3339 
  *(regs_buff + 37U) = readl((void const volatile *)(hw->hw_addr + 9264U));
  
#line 3341 
  printk("\001");
  
#line 3342 
  i = 0;
  
#line 3342 
  goto ldv_57290;
  ldv_57289: 
#line 3343 
  ;
  
#line 3343 
  printk("\001",reg_name[i],*(regs_buff + i));
  
#line 3342 
  i += 1;
  ldv_57290: 
#line 3343 
  ;
  
#line 3342 
  if (i <= 37) 
#line 3344 
               goto ldv_57289; else 
#line 3347 
                                    goto ldv_57291;
  ldv_57291: 
#line 3348 
  ;
  
#line 3349 
  return;
}


#line 3349  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_dump(struct e1000_adapter *adapter)
{
  int i;
  unsigned int tmp_0;
  unsigned int tmp_1;
  unsigned int tmp_2;
  unsigned int tmp_3;
  unsigned int tmp_4;
  unsigned int tmp_5;
  unsigned int tmp_6;
  unsigned int tmp_7;
  
#line 3352 
  struct e1000_tx_ring *tx_ring = adapter->tx_ring;
  
#line 3353 
  struct e1000_rx_ring *rx_ring = adapter->rx_ring;
  
#line 3356 
  if ((adapter->msg_enable & 8192) == 0) 
#line 3357 
                                         goto return_label; else ;
  
#line 3360 
  e1000_regdump(adapter);
  
#line 3363 
  printk("\001");
  
#line 3392 
  printk("\001");
  
#line 3393 
  printk("\001");
  
#line 3395 
  if ((adapter->msg_enable & 1024) == 0) 
#line 3396 
                                         goto rx_ring_summary; else ;
  
#line 3398 
  i = 0;
  
#line 3398 
  goto ldv_57307;
  ldv_57306: 
#line 3399 
  ;
  {
    char const *type;
    int tmp;
    
#line 3399 
    struct e1000_tx_desc *tx_desc = (struct e1000_tx_desc *)tx_ring->desc + i;
    
#line 3400 
    struct e1000_tx_buffer *buffer_info = tx_ring->buffer_info + i;
    
#line 3402 
    struct my_u *u = (struct my_u *)tx_desc;
    
#line 3405 
    if (tx_ring->next_to_use == (unsigned int)i && tx_ring->next_to_clean == (unsigned int)i) 
      
#line 3406 
      type = "NTC/U";
    else 
      
#line 3407 
      if (tx_ring->next_to_use == (unsigned int)i) 
#line 3408 
                                                   type = "NTU";
      else 
        
#line 3409 
        if (tx_ring->next_to_clean == (unsigned int)i) 
#line 3410 
                                                       type = "NTC"; else 
                                                                    
#line 3412 
                                                                    type = "";
    
#line 3414 
    ;
    
#line 3414 
    ;
    
#line 3414 
    ;
    
#line 3414 
    ;
    
#line 3414 
    ;
    
#line 3414 
    ;
    
#line 3414 
    ;
    
#line 3414 
    ;
    
#line 3414 
    ;
    
#line 3414 
    if ((u->b & 1048576ULL) != 0ULL) 
#line 3414 
                                     tmp = 100; else 
#line 3414 
                                                     tmp = 99;
    
#line 3414 
    printk("\001",tmp,i,u->a,u->b,buffer_info->dma,(int)buffer_info->length,(int)buffer_info->next_to_watch,(unsigned long long)buffer_info->time_stamp,buffer_info->skb,type);
  }
  
#line 3398 
  i += 1;
  ldv_57307: 
#line 3399 
  ;
  
#line 3398 
  if (tx_ring->desc != (void *)0 && tx_ring->count > (unsigned int)i) 
    
#line 3400 
    goto ldv_57306; else 
#line 3403 
                         goto ldv_57308;
  ldv_57308: 
#line 3404 
  ;
  rx_ring_summary: 
#line 3422 
  ;
  
#line 3424 
  printk("\001");
  
#line 3435 
  printk("\001");
  
#line 3437 
  if ((adapter->msg_enable & 2048) == 0) 
#line 3438 
                                         goto exit; else ;
  
#line 3440 
  i = 0;
  
#line 3440 
  goto ldv_57318;
  ldv_57317: 
#line 3441 
  ;
  {
    char const *type_0;
    
#line 3441 
    struct e1000_rx_desc *rx_desc = (struct e1000_rx_desc *)rx_ring->desc + i;
    
#line 3442 
    struct e1000_rx_buffer *buffer_info_0 = rx_ring->buffer_info + i;
    
#line 3444 
    struct my_u_0 *u_0 = (struct my_u_0 *)rx_desc;
    
#line 3447 
    if (rx_ring->next_to_use == (unsigned int)i) 
#line 3448 
                                                 type_0 = "NTU";
    else 
      
#line 3449 
      if (rx_ring->next_to_clean == (unsigned int)i) 
#line 3450 
                                                     type_0 = "NTC"; else 
                                                                    
#line 3452 
                                                                    type_0 = "";
    
#line 3454 
    printk("\001",i,u_0->a,u_0->b,buffer_info_0->dma,buffer_info_0->rxbuf.data,type_0);
  }
  
#line 3440 
  i += 1;
  ldv_57318: 
#line 3441 
  ;
  
#line 3440 
  if (rx_ring->desc != (void *)0 && rx_ring->count > (unsigned int)i) 
    
#line 3442 
    goto ldv_57317; else 
#line 3445 
                         goto ldv_57319;
  ldv_57319: 
#line 3446 
  ;
  
#line 3461 
  printk("\001");
  
#line 3462 
  i = 24576;
  
#line 3462 
  goto ldv_57321;
  ldv_57320: 
#line 3463 
  ;
  
#line 3463 
  tmp_0 = readl((void const volatile *)(adapter->hw.hw_addr + ((unsigned int)i + 8U)));
  
#line 3463 
  tmp_1 = readl((void const volatile *)(adapter->hw.hw_addr + ((unsigned int)i + 12U)));
  
#line 3463 
  tmp_2 = readl((void const volatile *)(adapter->hw.hw_addr + i));
  
#line 3463 
  tmp_3 = readl((void const volatile *)(adapter->hw.hw_addr + ((unsigned int)i + 4U)));
  
#line 3463 
  ;
  
#line 3463 
  printk("\001",i,tmp_3,tmp_2,tmp_1,tmp_0);
  
#line 3462 
  i += 16;
  ldv_57321: 
#line 3463 
  ;
  
#line 3462 
  if (i <= 25599) 
#line 3464 
                  goto ldv_57320; else 
#line 3467 
                                       goto ldv_57322;
  ldv_57322: 
#line 3468 
  ;
  
#line 3471 
  printk("\001");
  
#line 3472 
  i = 28672;
  
#line 3472 
  goto ldv_57324;
  ldv_57323: 
#line 3473 
  ;
  
#line 3473 
  tmp_4 = readl((void const volatile *)(adapter->hw.hw_addr + ((unsigned int)i + 8U)));
  
#line 3473 
  tmp_5 = readl((void const volatile *)(adapter->hw.hw_addr + ((unsigned int)i + 12U)));
  
#line 3473 
  tmp_6 = readl((void const volatile *)(adapter->hw.hw_addr + i));
  
#line 3473 
  tmp_7 = readl((void const volatile *)(adapter->hw.hw_addr + ((unsigned int)i + 4U)));
  
#line 3473 
  ;
  
#line 3473 
  printk("\001",i,tmp_7,tmp_6,tmp_5,tmp_4);
  
#line 3472 
  i += 16;
  ldv_57324: 
#line 3473 
  ;
  
#line 3472 
  if (i <= 29695) 
#line 3474 
                  goto ldv_57323; else 
#line 3477 
                                       goto ldv_57325;
  ldv_57325: 
#line 3478 
  ;
  exit: 
#line 3480 
  ;
  return_label: 
#line 3481 
                return;
}


#line 3488  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_tx_timeout(struct net_device *netdev)
{
  
#line 3490 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 3493 
  adapter->tx_timeout_count += 1U;
  
#line 3494 
  ldv_schedule_work_92(& adapter->reset_task);
  
#line 3495 
  return;
}


#line 3497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_reset_task(struct work_struct *work)
{
  struct e1000_adapter *tmp;
  {
    
#line 3500 
    struct work_struct const *__mptr = (struct work_struct const *)work;
    
#line 3500 
    tmp = (struct e1000_adapter *)__mptr + 18446744073709549480U;
  }
  
#line 3499 
  struct e1000_adapter *adapter = tmp;
  
#line 3502 
  if ((adapter->msg_enable & 1) != 0) 
#line 3502 
                                      netdev_err((struct net_device const *)adapter->netdev,"Reset adapter\n"); else ;
  
#line 3503 
  e1000_reinit_locked(adapter);
  
#line 3504 
  return;
}


#line 3513  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static struct net_device_stats *e1000_get_stats(struct net_device *netdev)
{
  struct net_device_stats *__retres;
  
#line 3516 
  __retres = & netdev->stats;
  
#line 3516 
  return __retres;
}


#line 3526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
{
  int __retres;
  int tmp_0;
  bool tmp_1;
  bool tmp_2;
  
#line 3528 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 3529 
  struct e1000_hw *hw = & adapter->hw;
  
#line 3530 
  int max_frame = new_mtu + 18;
  
#line 3532 
  if ((unsigned int)max_frame + 4294967232U > 16064U) {
    
#line 3534 
    if ((adapter->msg_enable & 2) != 0) 
#line 3534 
                                        netdev_err((struct net_device const *)adapter->netdev,"Invalid MTU setting\n"); else ;
    
#line 3535 
    __retres = -22;
    
#line 3535 
    goto return_label;
  }
  else ;
  
#line 3539 
  switch ((unsigned int)hw->mac_type) {
    case 0U: case 1U: case 2U: 
#line 3540 
    ;
    
#line 3541 
    if (max_frame > 1518) {
      
#line 3542 
      if ((adapter->msg_enable & 2) != 0) 
#line 3542 
                                          netdev_err((struct net_device const *)adapter->netdev,"Jumbo Frames not supported.\n"); else ;
      
#line 3543 
      __retres = -22;
      
#line 3543 
      goto return_label;
    }
    else ;
    
#line 3545 
    goto ldv_57347;
    default: 
#line 3546 
    ;
    
#line 3548 
    goto ldv_57347;
  }
  ldv_57347: 
#line 3551 
  ;
  
#line 3551 
  goto ldv_57350;
  ldv_57349: 
#line 3552 
  ;
  
#line 3552 
  msleep(1U);
  ldv_57350: 
#line 3553 
  ;
  
#line 3551 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 3551 
  if (tmp_0 != 0) 
#line 3553 
                  goto ldv_57349; else 
#line 3556 
                                       goto ldv_57351;
  ldv_57351: 
#line 3557 
  ;
  
#line 3554 
  hw->max_frame_size = (unsigned int)max_frame;
  
#line 3555 
  tmp_1 = netif_running((struct net_device const *)netdev);
  
#line 3555 
  if ((int)tmp_1 != 0) {
    
#line 3557 
    adapter->alloc_rx_buf = & e1000_alloc_dummy_rx_buffers;
    
#line 3558 
    e1000_down(adapter);
  }
  else ;
  
#line 3569 
  if (max_frame <= 2048) 
#line 3570 
                         adapter->rx_buffer_len = 2048U; else 
#line 3575 
                                                              adapter->rx_buffer_len = 4096U;
  
#line 3579 
  if (! hw->tbi_compatibility_on && (max_frame == 1518 || max_frame == 1522)) 
    
#line 3582 
    adapter->rx_buffer_len = 1522U; else ;
  
#line 3584 
  printk("\001",(char *)(& netdev->name),netdev->mtu,new_mtu);
  
#line 3586 
  netdev->mtu = (unsigned int)new_mtu;
  
#line 3588 
  tmp_2 = netif_running((struct net_device const *)netdev);
  
#line 3588 
  if ((int)tmp_2 != 0) 
#line 3589 
                       e1000_up(adapter); else 
#line 3591 
                                               e1000_reset(adapter);
  
#line 3593 
  set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 3595 
  __retres = 0;
  return_label: 
#line 3595 
                return __retres;
}


#line 3602  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_update_stats(struct e1000_adapter *adapter)
{
  unsigned long flags;
  u16 phy_tmp;
  int tmp;
  unsigned int tmp_0;
  unsigned int tmp_1;
  unsigned int tmp_2;
  unsigned int tmp_3;
  unsigned int tmp_4;
  unsigned int tmp_5;
  unsigned int tmp_6;
  unsigned int tmp_7;
  unsigned int tmp_8;
  unsigned int tmp_9;
  unsigned int tmp_10;
  unsigned int tmp_11;
  unsigned int tmp_12;
  unsigned int tmp_13;
  unsigned int tmp_14;
  unsigned int tmp_15;
  unsigned int tmp_16;
  unsigned int tmp_17;
  unsigned int tmp_18;
  unsigned int tmp_19;
  unsigned int tmp_20;
  unsigned int tmp_21;
  unsigned int tmp_22;
  unsigned int tmp_23;
  unsigned int tmp_24;
  unsigned int tmp_25;
  unsigned int tmp_26;
  unsigned int tmp_27;
  unsigned int tmp_28;
  unsigned int tmp_29;
  unsigned int tmp_30;
  unsigned int tmp_31;
  unsigned int tmp_32;
  unsigned int tmp_33;
  unsigned int tmp_34;
  unsigned int tmp_35;
  unsigned int tmp_36;
  unsigned int tmp_37;
  unsigned int tmp_38;
  unsigned int tmp_39;
  unsigned int tmp_40;
  unsigned int tmp_41;
  unsigned int tmp_42;
  unsigned int tmp_43;
  unsigned int tmp_44;
  unsigned int tmp_45;
  unsigned int tmp_46;
  
#line 3604 
  struct net_device *netdev = adapter->netdev;
  
#line 3605 
  struct e1000_hw *hw = & adapter->hw;
  
#line 3606 
  struct pci_dev *pdev = adapter->pdev;
  
#line 3615 
  if ((unsigned int)adapter->link_speed == 0U) 
#line 3616 
                                               goto return_label; else ;
  
#line 3617 
  tmp = pci_channel_offline(pdev);
  
#line 3617 
  if (tmp != 0) 
#line 3618 
                goto return_label; else ;
  
#line 3620 
  ldv___ldv_spin_lock_93(& adapter->stats_lock);
  
#line 3627 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + 16384U));
  
#line 3627 
  adapter->stats.crcerrs += (unsigned long long)tmp_0;
  
#line 3628 
  tmp_1 = readl((void const volatile *)(hw->hw_addr + 16500U));
  
#line 3628 
  adapter->stats.gprc += (unsigned long long)tmp_1;
  
#line 3629 
  tmp_2 = readl((void const volatile *)(hw->hw_addr + 16520U));
  
#line 3629 
  adapter->stats.gorcl += (unsigned long long)tmp_2;
  
#line 3630 
  tmp_3 = readl((void const volatile *)(hw->hw_addr + 16524U));
  
#line 3630 
  adapter->stats.gorch += (unsigned long long)tmp_3;
  
#line 3631 
  tmp_4 = readl((void const volatile *)(hw->hw_addr + 16504U));
  
#line 3631 
  adapter->stats.bprc += (unsigned long long)tmp_4;
  
#line 3632 
  tmp_5 = readl((void const volatile *)(hw->hw_addr + 16508U));
  
#line 3632 
  adapter->stats.mprc += (unsigned long long)tmp_5;
  
#line 3633 
  tmp_6 = readl((void const volatile *)(hw->hw_addr + 16556U));
  
#line 3633 
  adapter->stats.roc += (unsigned long long)tmp_6;
  
#line 3635 
  tmp_7 = readl((void const volatile *)(hw->hw_addr + 16476U));
  
#line 3635 
  adapter->stats.prc64 += (unsigned long long)tmp_7;
  
#line 3636 
  tmp_8 = readl((void const volatile *)(hw->hw_addr + 16480U));
  
#line 3636 
  adapter->stats.prc127 += (unsigned long long)tmp_8;
  
#line 3637 
  tmp_9 = readl((void const volatile *)(hw->hw_addr + 16484U));
  
#line 3637 
  adapter->stats.prc255 += (unsigned long long)tmp_9;
  
#line 3638 
  tmp_10 = readl((void const volatile *)(hw->hw_addr + 16488U));
  
#line 3638 
  adapter->stats.prc511 += (unsigned long long)tmp_10;
  
#line 3639 
  tmp_11 = readl((void const volatile *)(hw->hw_addr + 16492U));
  
#line 3639 
  adapter->stats.prc1023 += (unsigned long long)tmp_11;
  
#line 3640 
  tmp_12 = readl((void const volatile *)(hw->hw_addr + 16496U));
  
#line 3640 
  adapter->stats.prc1522 += (unsigned long long)tmp_12;
  
#line 3642 
  tmp_13 = readl((void const volatile *)(hw->hw_addr + 16392U));
  
#line 3642 
  adapter->stats.symerrs += (unsigned long long)tmp_13;
  
#line 3643 
  tmp_14 = readl((void const volatile *)(hw->hw_addr + 16400U));
  
#line 3643 
  adapter->stats.mpc += (unsigned long long)tmp_14;
  
#line 3644 
  tmp_15 = readl((void const volatile *)(hw->hw_addr + 16404U));
  
#line 3644 
  adapter->stats.scc += (unsigned long long)tmp_15;
  
#line 3645 
  tmp_16 = readl((void const volatile *)(hw->hw_addr + 16408U));
  
#line 3645 
  adapter->stats.ecol += (unsigned long long)tmp_16;
  
#line 3646 
  tmp_17 = readl((void const volatile *)(hw->hw_addr + 16412U));
  
#line 3646 
  adapter->stats.mcc += (unsigned long long)tmp_17;
  
#line 3647 
  tmp_18 = readl((void const volatile *)(hw->hw_addr + 16416U));
  
#line 3647 
  adapter->stats.latecol += (unsigned long long)tmp_18;
  
#line 3648 
  tmp_19 = readl((void const volatile *)(hw->hw_addr + 16432U));
  
#line 3648 
  adapter->stats.dc += (unsigned long long)tmp_19;
  
#line 3649 
  tmp_20 = readl((void const volatile *)(hw->hw_addr + 16440U));
  
#line 3649 
  adapter->stats.sec += (unsigned long long)tmp_20;
  
#line 3650 
  tmp_21 = readl((void const volatile *)(hw->hw_addr + 16448U));
  
#line 3650 
  adapter->stats.rlec += (unsigned long long)tmp_21;
  
#line 3651 
  tmp_22 = readl((void const volatile *)(hw->hw_addr + 16456U));
  
#line 3651 
  adapter->stats.xonrxc += (unsigned long long)tmp_22;
  
#line 3652 
  tmp_23 = readl((void const volatile *)(hw->hw_addr + 16460U));
  
#line 3652 
  adapter->stats.xontxc += (unsigned long long)tmp_23;
  
#line 3653 
  tmp_24 = readl((void const volatile *)(hw->hw_addr + 16464U));
  
#line 3653 
  adapter->stats.xoffrxc += (unsigned long long)tmp_24;
  
#line 3654 
  tmp_25 = readl((void const volatile *)(hw->hw_addr + 16468U));
  
#line 3654 
  adapter->stats.xofftxc += (unsigned long long)tmp_25;
  
#line 3655 
  tmp_26 = readl((void const volatile *)(hw->hw_addr + 16472U));
  
#line 3655 
  adapter->stats.fcruc += (unsigned long long)tmp_26;
  
#line 3656 
  tmp_27 = readl((void const volatile *)(hw->hw_addr + 16512U));
  
#line 3656 
  adapter->stats.gptc += (unsigned long long)tmp_27;
  
#line 3657 
  tmp_28 = readl((void const volatile *)(hw->hw_addr + 16528U));
  
#line 3657 
  adapter->stats.gotcl += (unsigned long long)tmp_28;
  
#line 3658 
  tmp_29 = readl((void const volatile *)(hw->hw_addr + 16532U));
  
#line 3658 
  adapter->stats.gotch += (unsigned long long)tmp_29;
  
#line 3659 
  tmp_30 = readl((void const volatile *)(hw->hw_addr + 16544U));
  
#line 3659 
  adapter->stats.rnbc += (unsigned long long)tmp_30;
  
#line 3660 
  tmp_31 = readl((void const volatile *)(hw->hw_addr + 16548U));
  
#line 3660 
  adapter->stats.ruc += (unsigned long long)tmp_31;
  
#line 3661 
  tmp_32 = readl((void const volatile *)(hw->hw_addr + 16552U));
  
#line 3661 
  adapter->stats.rfc += (unsigned long long)tmp_32;
  
#line 3662 
  tmp_33 = readl((void const volatile *)(hw->hw_addr + 16560U));
  
#line 3662 
  adapter->stats.rjc += (unsigned long long)tmp_33;
  
#line 3663 
  tmp_34 = readl((void const volatile *)(hw->hw_addr + 16576U));
  
#line 3663 
  adapter->stats.torl += (unsigned long long)tmp_34;
  
#line 3664 
  tmp_35 = readl((void const volatile *)(hw->hw_addr + 16580U));
  
#line 3664 
  adapter->stats.torh += (unsigned long long)tmp_35;
  
#line 3665 
  tmp_36 = readl((void const volatile *)(hw->hw_addr + 16584U));
  
#line 3665 
  adapter->stats.totl += (unsigned long long)tmp_36;
  
#line 3666 
  tmp_37 = readl((void const volatile *)(hw->hw_addr + 16588U));
  
#line 3666 
  adapter->stats.toth += (unsigned long long)tmp_37;
  
#line 3667 
  tmp_38 = readl((void const volatile *)(hw->hw_addr + 16592U));
  
#line 3667 
  adapter->stats.tpr += (unsigned long long)tmp_38;
  
#line 3669 
  tmp_39 = readl((void const volatile *)(hw->hw_addr + 16600U));
  
#line 3669 
  adapter->stats.ptc64 += (unsigned long long)tmp_39;
  
#line 3670 
  tmp_40 = readl((void const volatile *)(hw->hw_addr + 16604U));
  
#line 3670 
  adapter->stats.ptc127 += (unsigned long long)tmp_40;
  
#line 3671 
  tmp_41 = readl((void const volatile *)(hw->hw_addr + 16608U));
  
#line 3671 
  adapter->stats.ptc255 += (unsigned long long)tmp_41;
  
#line 3672 
  tmp_42 = readl((void const volatile *)(hw->hw_addr + 16612U));
  
#line 3672 
  adapter->stats.ptc511 += (unsigned long long)tmp_42;
  
#line 3673 
  tmp_43 = readl((void const volatile *)(hw->hw_addr + 16616U));
  
#line 3673 
  adapter->stats.ptc1023 += (unsigned long long)tmp_43;
  
#line 3674 
  tmp_44 = readl((void const volatile *)(hw->hw_addr + 16620U));
  
#line 3674 
  adapter->stats.ptc1522 += (unsigned long long)tmp_44;
  
#line 3676 
  tmp_45 = readl((void const volatile *)(hw->hw_addr + 16624U));
  
#line 3676 
  adapter->stats.mptc += (unsigned long long)tmp_45;
  
#line 3677 
  tmp_46 = readl((void const volatile *)(hw->hw_addr + 16628U));
  
#line 3677 
  adapter->stats.bptc += (unsigned long long)tmp_46;
  
#line 3681 
  hw->tx_packet_delta = readl((void const volatile *)(hw->hw_addr + 16596U));
  
#line 3682 
  adapter->stats.tpt += (unsigned long long)hw->tx_packet_delta;
  
#line 3683 
  hw->collision_delta = readl((void const volatile *)(hw->hw_addr + 16424U));
  
#line 3684 
  adapter->stats.colc += (unsigned long long)hw->collision_delta;
  
#line 3686 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) {
    unsigned int tmp_47;
    unsigned int tmp_48;
    unsigned int tmp_49;
    unsigned int tmp_50;
    unsigned int tmp_51;
    unsigned int tmp_52;
    
#line 3687 
    tmp_47 = readl((void const volatile *)(hw->hw_addr + 16388U));
    
#line 3687 
    adapter->stats.algnerrc += (unsigned long long)tmp_47;
    
#line 3688 
    tmp_48 = readl((void const volatile *)(hw->hw_addr + 16396U));
    
#line 3688 
    adapter->stats.rxerrc += (unsigned long long)tmp_48;
    
#line 3689 
    tmp_49 = readl((void const volatile *)(hw->hw_addr + 16436U));
    
#line 3689 
    adapter->stats.tncrs += (unsigned long long)tmp_49;
    
#line 3690 
    tmp_50 = readl((void const volatile *)(hw->hw_addr + 16444U));
    
#line 3690 
    adapter->stats.cexterr += (unsigned long long)tmp_50;
    
#line 3691 
    tmp_51 = readl((void const volatile *)(hw->hw_addr + 16632U));
    
#line 3691 
    adapter->stats.tsctc += (unsigned long long)tmp_51;
    
#line 3692 
    tmp_52 = readl((void const volatile *)(hw->hw_addr + 16636U));
    
#line 3692 
    adapter->stats.tsctfc += (unsigned long long)tmp_52;
  }
  else ;
  
#line 3696 
  netdev->stats.multicast = (unsigned long)adapter->stats.mprc;
  
#line 3697 
  netdev->stats.collisions = (unsigned long)adapter->stats.colc;
  
#line 3704 
  netdev->stats.rx_errors = (unsigned long)(((((adapter->stats.rxerrc + adapter->stats.crcerrs) + adapter->stats.algnerrc) + adapter->stats.ruc) + adapter->stats.roc) + adapter->stats.cexterr);
  
#line 3708 
  adapter->stats.rlerrc = adapter->stats.ruc + adapter->stats.roc;
  
#line 3709 
  netdev->stats.rx_length_errors = (unsigned long)adapter->stats.rlerrc;
  
#line 3710 
  netdev->stats.rx_crc_errors = (unsigned long)adapter->stats.crcerrs;
  
#line 3711 
  netdev->stats.rx_frame_errors = (unsigned long)adapter->stats.algnerrc;
  
#line 3712 
  netdev->stats.rx_missed_errors = (unsigned long)adapter->stats.mpc;
  
#line 3715 
  adapter->stats.txerrc = adapter->stats.ecol + adapter->stats.latecol;
  
#line 3716 
  netdev->stats.tx_errors = (unsigned long)adapter->stats.txerrc;
  
#line 3717 
  netdev->stats.tx_aborted_errors = (unsigned long)adapter->stats.ecol;
  
#line 3718 
  netdev->stats.tx_window_errors = (unsigned long)adapter->stats.latecol;
  
#line 3719 
  netdev->stats.tx_carrier_errors = (unsigned long)adapter->stats.tncrs;
  
#line 3720 
  if ((int)hw->bad_tx_carr_stats_fd != 0 && (unsigned int)adapter->link_duplex == 2U) {
    
#line 3722 
    netdev->stats.tx_carrier_errors = 0UL;
    
#line 3723 
    adapter->stats.tncrs = 0ULL;
  }
  else ;
  
#line 3729 
  if (hw->media_type == (unsigned int)e1000_media_type_copper) {
    
#line 3730 
    if ((unsigned int)adapter->link_speed == 1000U) {
      s32 tmp_53;
      
#line 3730 
      tmp_53 = e1000_read_phy_reg(hw,10U,& phy_tmp);
      
#line 3730 
      if (tmp_53 == 0) {
        
#line 3732 
        phy_tmp = (unsigned short)((unsigned int)phy_tmp & 255U);
        
#line 3733 
        adapter->phy_stats.idle_errors += (unsigned int)phy_tmp;
      }
      else ;
    }
    else ;
    
#line 3736 
    if (hw->mac_type <= (unsigned int)e1000_82546 && hw->phy_type == (unsigned int)0) {
      s32 tmp_54;
      
#line 3737 
      tmp_54 = e1000_read_phy_reg(hw,21U,& phy_tmp);
      
#line 3737 
      if (tmp_54 == 0) 
#line 3739 
                       adapter->phy_stats.receive_errors += (unsigned int)phy_tmp; else ;
    }
    else ;
  }
  else ;
  
#line 3743 
  if ((int)hw->has_smbus != 0) {
    unsigned int tmp_55;
    unsigned int tmp_56;
    unsigned int tmp_57;
    
#line 3744 
    tmp_55 = readl((void const volatile *)(hw->hw_addr + 16572U));
    
#line 3744 
    adapter->stats.mgptc += (unsigned long long)tmp_55;
    
#line 3745 
    tmp_56 = readl((void const volatile *)(hw->hw_addr + 16564U));
    
#line 3745 
    adapter->stats.mgprc += (unsigned long long)tmp_56;
    
#line 3746 
    tmp_57 = readl((void const volatile *)(hw->hw_addr + 16568U));
    
#line 3746 
    adapter->stats.mgpdc += (unsigned long long)tmp_57;
  }
  else ;
  
#line 3749 
  ldv_spin_unlock_irqrestore_94(& adapter->stats_lock,flags);
  return_label: 
#line 3750 
                return;
}


#line 3757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static irqreturn_t e1000_intr(int irq, void *data)
{
  irqreturn_t __retres;
  int tmp_1;
  bool tmp_4;
  
#line 3759 
  struct net_device *netdev = (struct net_device *)data;
  
#line 3760 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 3761 
  struct e1000_hw *hw = & adapter->hw;
  
#line 3762 
  u32 icr = readl((void const volatile *)(hw->hw_addr + 192U));
  
#line 3764 
  if ((long)(icr == 0U) != 0L) {
    
#line 3765 
    __retres = IRQ_NONE;
    
#line 3765 
    goto return_label;
  }
  else ;
  
#line 3771 
  tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
  
#line 3771 
  if ((long)(tmp_1 != 0) != 0L) {
    
#line 3772 
    __retres = IRQ_HANDLED;
    
#line 3772 
    goto return_label;
  }
  else ;
  
#line 3774 
  if ((long)((icr & 12U) != 0U) != 0L) {
    int tmp_2;
    
#line 3775 
    hw->get_link_status = (_Bool)1;
    
#line 3777 
    tmp_2 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
    
#line 3777 
    if (tmp_2 == 0) 
#line 3778 
                    ldv_schedule_delayed_work_95(& adapter->watchdog_task,1UL); else ;
  }
  else ;
  
#line 3782 
  writel(4294967295U,(void volatile *)(hw->hw_addr + 216U));
  
#line 3783 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 3785 
  tmp_4 = napi_schedule_prep(& adapter->napi);
  
#line 3785 
  if ((long)((int)tmp_4 != 0) != 0L) {
    
#line 3786 
    adapter->total_tx_bytes = 0U;
    
#line 3787 
    adapter->total_tx_packets = 0U;
    
#line 3788 
    adapter->total_rx_bytes = 0U;
    
#line 3789 
    adapter->total_rx_packets = 0U;
    
#line 3790 
    __napi_schedule(& adapter->napi);
  }
  else {
    int tmp_3;
    
#line 3795 
    tmp_3 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
    
#line 3795 
    if (tmp_3 == 0) 
#line 3796 
                    e1000_irq_enable(adapter); else ;
  }
  
#line 3799 
  __retres = IRQ_HANDLED;
  return_label: 
#line 3799 
                return __retres;
}


#line 3806  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_clean(struct napi_struct *napi, int budget)
{
  struct e1000_adapter *tmp;
  bool tmp_0;
  {
    
#line 3808 
    struct napi_struct const *__mptr = (struct napi_struct const *)napi;
    
#line 3808 
    tmp = (struct e1000_adapter *)__mptr + 18446744073709550856U;
  }
  
#line 3808 
  struct e1000_adapter *adapter = tmp;
  
#line 3810 
  int tx_clean_complete = 0;
  
#line 3810 
  int work_done = 0;
  
#line 3812 
  tmp_0 = e1000_clean_tx_irq(adapter,adapter->tx_ring);
  
#line 3812 
  tx_clean_complete = (int)tmp_0;
  
#line 3814 
  (*(adapter->clean_rx))(adapter,adapter->rx_ring,& work_done,budget);
  
#line 3816 
  if (tx_clean_complete == 0) 
#line 3817 
                              work_done = budget; else ;
  
#line 3820 
  if (work_done < budget) {
    int tmp_1;
    
#line 3821 
    if ((long)((adapter->itr_setting & 3U) != 0U) != 0L) 
#line 3822 
                                                         e1000_set_itr(adapter); else ;
    
#line 3823 
    napi_complete(napi);
    
#line 3824 
    tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
    
#line 3824 
    if (tmp_1 == 0) 
#line 3825 
                    e1000_irq_enable(adapter); else ;
  }
  else ;
  
#line 3828 
  return work_done;
}


#line 3835  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static bool e1000_clean_tx_irq(struct e1000_adapter *adapter, struct e1000_tx_ring *tx_ring)
{
  bool __retres;
  struct e1000_tx_desc *tx_desc;
  struct e1000_tx_desc *eop_desc;
  struct e1000_tx_buffer *buffer_info;
  unsigned int i;
  unsigned int eop;
  int tmp_2;
  
#line 3838 
  struct e1000_hw *hw = & adapter->hw;
  
#line 3839 
  struct net_device *netdev = adapter->netdev;
  
#line 3843 
  unsigned int count = 0U;
  
#line 3844 
  unsigned int total_tx_bytes = 0U;
  
#line 3844 
  unsigned int total_tx_packets = 0U;
  
#line 3845 
  unsigned int bytes_compl = 0U;
  
#line 3845 
  unsigned int pkts_compl = 0U;
  
#line 3847 
  i = tx_ring->next_to_clean;
  
#line 3848 
  eop = (unsigned int)(tx_ring->buffer_info + i)->next_to_watch;
  
#line 3849 
  eop_desc = (struct e1000_tx_desc *)tx_ring->desc + eop;
  
#line 3851 
  goto ldv_57398;
  ldv_57397: 
#line 3852 
  ;
  {
    
#line 3853 
    bool cleaned = (_Bool)0;
    
#line 3854 
    ldv_inline_asm();
    
#line 3855 
    goto ldv_57395;
    ldv_57394: 
#line 3856 
    ;
    
#line 3856 
    tx_desc = (struct e1000_tx_desc *)tx_ring->desc + i;
    
#line 3857 
    buffer_info = tx_ring->buffer_info + i;
    
#line 3858 
    cleaned = (_Bool)(i == eop);
    
#line 3860 
    if ((int)cleaned != 0) {
      
#line 3861 
      total_tx_packets = (unsigned int)buffer_info->segs + total_tx_packets;
      
#line 3862 
      total_tx_bytes = buffer_info->bytecount + total_tx_bytes;
      
#line 3863 
      if (buffer_info->skb != (struct sk_buff *)0) {
        
#line 3864 
        bytes_compl = (buffer_info->skb)->len + bytes_compl;
        
#line 3865 
        pkts_compl += 1U;
      }
      else ;
    }
    else ;
    
#line 3869 
    e1000_unmap_and_free_tx_resource(adapter,buffer_info);
    
#line 3870 
    tx_desc->upper.data = 0U;
    
#line 3872 
    i += 1U;
    
#line 3872 
    ;
    
#line 3872 
    if ((long)(i == tx_ring->count) != 0L) 
#line 3872 
                                           i = 0U; else ;
    
#line 3855 
    count += 1U;
    ldv_57395: 
#line 3856 
    ;
    
#line 3855 
    if (! cleaned) 
#line 3857 
                   goto ldv_57394; else 
#line 3860 
                                        goto ldv_57396;
    ldv_57396: 
#line 3861 
    ;
    
#line 3875 
    eop = (unsigned int)(tx_ring->buffer_info + i)->next_to_watch;
    
#line 3876 
    eop_desc = (struct e1000_tx_desc *)tx_ring->desc + eop;
  }
  ldv_57398: 
#line 3878 
  ;
  
#line 3851 
  if ((eop_desc->upper.data & 1U) != 0U && tx_ring->count > count) 
#line 3854 
                                                                   goto ldv_57397; else 
                                                                    
#line 3857 
                                                                    goto ldv_57399;
  ldv_57399: 
#line 3858 
  ;
  
#line 3879 
  tx_ring->next_to_clean = i;
  
#line 3881 
  netdev_completed_queue(netdev,pkts_compl,bytes_compl);
  
#line 3884 
  if ((long)(count != 0U) != 0L) {
    bool tmp_1;
    
#line 3884 
    tmp_1 = netif_carrier_ok((struct net_device const *)netdev);
    
#line 3884 
    if ((long)((int)tmp_1 != 0) != 0L) 
#line 3884 
                                       tmp_2 = 1; else 
#line 3884 
                                                       tmp_2 = 0;
  }
  else 
#line 3884 
       tmp_2 = 0;
  
#line 3884 
  if (tmp_2 != 0) {
    unsigned int tmp_3;
    
#line 3884 
    if (tx_ring->next_to_clean <= tx_ring->next_to_use) 
#line 3884 
                                                        tmp_3 = tx_ring->count; else 
                                                                    
#line 3884 
                                                                    tmp_3 = 0U;
    
#line 3884 
    ;
    
#line 3884 
    if ((long)(((tmp_3 + tx_ring->next_to_clean) - tx_ring->next_to_use) + 4294967295U > 31U) != 0L) {
      bool tmp;
      
#line 3886 
      ldv_inline_asm();
      
#line 3891 
      tmp = netif_queue_stopped((struct net_device const *)netdev);
      
#line 3891 
      if ((int)tmp != 0) {
        int tmp_0;
        
#line 3891 
        tmp_0 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
        
#line 3891 
        if (tmp_0 == 0) {
          
#line 3893 
          netif_wake_queue(netdev);
          
#line 3894 
          adapter->restart_queue += 1U;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 3898 
  if ((int)adapter->detect_tx_hung != 0) {
    
#line 3902 
    adapter->detect_tx_hung = (_Bool)0;
    
#line 3903 
    if ((tx_ring->buffer_info + eop)->time_stamp != 0UL) {
      int tmp_6;
      {
        unsigned long __dummy;
        unsigned long volatile __dummy2;
        
#line 3904 
        tmp_6 = 1;
      }
      
#line 3903 
      if (tmp_6 != 0) {
        int tmp_7;
        {
          unsigned long __dummy_0;
          unsigned long __dummy2_0;
          
#line 3904 
          tmp_7 = 1;
        }
        
#line 3904 
        if (tmp_7 != 0) {
          
#line 3904 
          if ((long)(((tx_ring->buffer_info + eop)->time_stamp + (unsigned long)((int)adapter->tx_timeout_factor * 250)) - jiffies) < 0L) {
            unsigned int tmp_8;
            
#line 3905 
            tmp_8 = readl((void const volatile *)(hw->hw_addr + 8U));
            
#line 3905 
            if ((tmp_8 & 16U) == 0U) {
              
#line 3909 
              if ((adapter->msg_enable & 1) != 0) {
                unsigned int tmp_4;
                unsigned int tmp_5;
                
#line 3909 
                ;
                
#line 3909 
                ;
                
#line 3909 
                ;
                
#line 3909 
                ;
                
#line 3909 
                ;
                
#line 3909 
                ;
                
#line 3909 
                tmp_4 = readl((void const volatile *)(hw->hw_addr + (int)tx_ring->tdt));
                
#line 3909 
                tmp_5 = readl((void const volatile *)(hw->hw_addr + (int)tx_ring->tdh));
                
#line 3909 
                ;
                
#line 3909 
                ;
                
#line 3909 
                netdev_err((struct net_device const *)adapter->netdev,"Detected Tx Unit Hang\n",(unsigned long)(((long)tx_ring - (long)adapter->tx_ring) / 48L),tmp_5,tmp_4,tx_ring->next_to_use,tx_ring->next_to_clean,(tx_ring->buffer_info + eop)->time_stamp,eop,jiffies,(int)eop_desc->upper.fields.status);
              }
              else ;
              
#line 3929 
              e1000_dump(adapter);
              
#line 3930 
              netif_start_queue(netdev);
            }
            else ;
          }
          else ;
        }
        else ;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 3933 
  adapter->total_tx_bytes += total_tx_bytes;
  
#line 3934 
  adapter->total_tx_packets += total_tx_packets;
  
#line 3935 
  netdev->stats.tx_bytes += (unsigned long)total_tx_bytes;
  
#line 3936 
  netdev->stats.tx_packets += (unsigned long)total_tx_packets;
  
#line 3937 
  __retres = (_Bool)(tx_ring->count > count);
  
#line 3937 
  return __retres;
}


#line 3947  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_rx_checksum(struct e1000_adapter *adapter, u32 status_err, u32 csum, struct sk_buff *skb)
{
  
#line 3950 
  struct e1000_hw *hw = & adapter->hw;
  
#line 3951 
  u16 status = (unsigned short)status_err;
  
#line 3952 
  u8 errors = (unsigned char)(status_err >> 24);
  
#line 3954 
  skb_checksum_none_assert((struct sk_buff const *)skb);
  
#line 3957 
  if ((long)(hw->mac_type <= (unsigned int)e1000_82542_rev2_1) != 0L) 
    
#line 3957 
    goto return_label; else ;
  
#line 3959 
  if ((long)(((int)status & 4) != 0) != 0L) 
#line 3959 
                                            goto return_label; else ;
  
#line 3961 
  if ((long)(((int)errors & 32) != 0) != 0L) {
    
#line 3963 
    adapter->hw_csum_err += 1ULL;
    
#line 3964 
    goto return_label;
  }
  else ;
  
#line 3967 
  if (((int)status & 32) == 0) 
#line 3968 
                               goto return_label; else ;
  
#line 3971 
  if ((long)(((int)status & 32) != 0) != 0L) 
#line 3973 
                                             skb->ip_summed = (unsigned char __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))))1U; else ;
  
#line 3975 
  adapter->hw_csum_good += 1ULL;
  return_label: 
#line 3976 
                return;
}


#line 3981  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb, u16 length)
{
  
#line 3984 
  bi->rxbuf.page = (struct page *)0;
  
#line 3985 
  skb->len += (unsigned int)length;
  
#line 3986 
  skb->data_len += (unsigned int)length;
  
#line 3987 
  skb->truesize += 4096U;
  
#line 3988 
  return;
}


#line 3997  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status, __le16 vlan, struct sk_buff *skb)
{
  
#line 4000 
  skb->protocol = eth_type_trans(skb,adapter->netdev);
  
#line 4002 
  if (((int)status & 8) != 0) {
    
#line 4003 
    u16 vid = (unsigned short)((unsigned int)vlan & 4095U);
    
#line 4005 
    __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)((int)vid));
  }
  else ;
  
#line 4007 
  napi_gro_receive(& adapter->napi,skb);
  
#line 4008 
  return;
}


#line 4018  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_tbi_adjust_stats(struct e1000_hw *hw, struct e1000_hw_stats *stats, u32 frame_len, u8 const *mac_addr)
{
  u64 carry_bit;
  bool tmp_0;
  
#line 4025 
  frame_len -= 1U;
  
#line 4031 
  stats->crcerrs -= 1ULL;
  
#line 4033 
  stats->gprc += 1ULL;
  
#line 4036 
  carry_bit = stats->gorcl & 2147483648ULL;
  
#line 4037 
  stats->gorcl += (unsigned long long)frame_len;
  
#line 4045 
  if (carry_bit != 0ULL && (stats->gorcl & 2147483648ULL) == 0ULL) 
#line 4046 
                                                                   stats->gorch += 1ULL; else ;
  
#line 4051 
  tmp_0 = is_broadcast_ether_addr(mac_addr);
  
#line 4051 
  if ((int)tmp_0 != 0) 
#line 4052 
                       stats->bprc += 1ULL;
  else {
    bool tmp;
    
#line 4053 
    tmp = is_multicast_ether_addr(mac_addr);
    
#line 4053 
    if ((int)tmp != 0) 
#line 4054 
                       stats->mprc += 1ULL; else ;
  }
  
#line 4056 
  if (hw->max_frame_size == frame_len) {
    
#line 4060 
    if (stats->roc != 0ULL) 
#line 4061 
                            stats->roc -= 1ULL; else ;
  }
  else ;
  
#line 4067 
  if (frame_len == 64U) {
    
#line 4068 
    stats->prc64 += 1ULL;
    
#line 4069 
    stats->prc127 -= 1ULL;
  }
  else 
    
#line 4070 
    if (frame_len == 127U) {
      
#line 4071 
      stats->prc127 += 1ULL;
      
#line 4072 
      stats->prc255 -= 1ULL;
    }
    else 
      
#line 4073 
      if (frame_len == 255U) {
        
#line 4074 
        stats->prc255 += 1ULL;
        
#line 4075 
        stats->prc511 -= 1ULL;
      }
      else 
        
#line 4076 
        if (frame_len == 511U) {
          
#line 4077 
          stats->prc511 += 1ULL;
          
#line 4078 
          stats->prc1023 -= 1ULL;
        }
        else 
          
#line 4079 
          if (frame_len == 1023U) {
            
#line 4080 
            stats->prc1023 += 1ULL;
            
#line 4081 
            stats->prc1522 -= 1ULL;
          }
          else 
            
#line 4082 
            if (frame_len == 1522U) 
#line 4083 
                                    stats->prc1522 += 1ULL; else ;
  
#line 4084 
  return;
}


#line 4087  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static bool e1000_tbi_should_accept(struct e1000_adapter *adapter, u8 status, u8 errors, u32 length, u8 const *data)
{
  bool __retres;
  
#line 4091 
  struct e1000_hw *hw = & adapter->hw;
  
#line 4092 
  u8 last_byte = *(data + ((unsigned long)length + 18446744073709551615U));
  
#line 4094 
  if (((int)hw->tbi_compatibility_on != 0 && ((int)errors & 151) == 1) && (unsigned int)last_byte == 15U) {
    int tmp;
    
#line 4094 
    if (((int)status & 8) != 0) 
#line 4094 
                                tmp = (hw->min_frame_size + 4294967292U < length && hw->max_frame_size + 1U >= length) != 0; else 
                                                                    
#line 4094 
                                                                    tmp = (hw->min_frame_size < length && hw->max_frame_size + 5U >= length) != 0;
    
#line 4094 
    if (tmp) {
      unsigned long irq_flags;
      
#line 4097 
      ldv___ldv_spin_lock_96(& adapter->stats_lock);
      
#line 4098 
      e1000_tbi_adjust_stats(hw,& adapter->stats,length,data);
      
#line 4099 
      ldv_spin_unlock_irqrestore_97(& adapter->stats_lock,irq_flags);
      
#line 4101 
      __retres = (_Bool)1;
      
#line 4101 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 4104 
  __retres = (_Bool)0;
  return_label: 
#line 4104 
                return __retres;
}


#line 4107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static struct sk_buff *e1000_alloc_rx_skb(struct e1000_adapter *adapter, unsigned int bufsz)
{
  
#line 4110 
  struct sk_buff *skb = napi_alloc_skb(& adapter->napi,bufsz);
  
#line 4112 
  if ((long)(skb == (struct sk_buff *)0) != 0L) 
#line 4113 
                                                adapter->alloc_rx_buff_failed += 1U; else ;
  
#line 4114 
  return skb;
}


#line 4241 
void __compiletime_assert_4241(void);


#line 4127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int *work_done, int work_to_do)
{
  struct e1000_rx_desc *rx_desc;
  struct e1000_rx_desc *next_rxd;
  struct e1000_rx_buffer *buffer_info;
  struct e1000_rx_buffer *next_buffer;
  u32 length;
  unsigned int i;
  unsigned int tmp_5;
  
#line 4131 
  struct net_device *netdev = adapter->netdev;
  
#line 4132 
  struct pci_dev *pdev = adapter->pdev;
  
#line 4137 
  int cleaned_count = 0;
  
#line 4138 
  bool cleaned = (_Bool)0;
  
#line 4139 
  unsigned int total_rx_bytes = 0U;
  
#line 4139 
  unsigned int total_rx_packets = 0U;
  
#line 4141 
  i = rx_ring->next_to_clean;
  
#line 4142 
  rx_desc = (struct e1000_rx_desc *)rx_ring->desc + i;
  
#line 4143 
  buffer_info = rx_ring->buffer_info + i;
  
#line 4145 
  goto ldv_57482;
  ldv_57481: 
#line 4146 
  ;
  {
    struct sk_buff *skb;
    u8 status;
    
#line 4149 
    if (*work_done >= work_to_do) 
#line 4150 
                                  goto ldv_57469; else ;
    
#line 4151 
    *work_done += 1;
    
#line 4152 
    ldv_inline_asm();
    
#line 4154 
    status = rx_desc->status;
    
#line 4156 
    i += 1U;
    
#line 4156 
    ;
    
#line 4156 
    if (i == rx_ring->count) 
#line 4156 
                             i = 0U; else ;
    
#line 4157 
    next_rxd = (struct e1000_rx_desc *)rx_ring->desc + i;
    
#line 4158 
    __builtin_prefetch((void const *)next_rxd);
    
#line 4160 
    next_buffer = rx_ring->buffer_info + i;
    
#line 4162 
    cleaned = (_Bool)1;
    
#line 4163 
    cleaned_count += 1;
    
#line 4164 
    dma_unmap_page(& pdev->dev,buffer_info->dma,(unsigned long)adapter->rx_buffer_len,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 4166 
    buffer_info->dma = 0ULL;
    
#line 4168 
    length = (unsigned int)rx_desc->length;
    
#line 4171 
    if ((long)(((int)status & 2) != 0) != 0L && (long)(((int)rx_desc->errors & 151) != 0) != 0L) {
      bool tmp_0;
      
#line 4173 
      u8 *mapped = lowmem_page_address((struct page const *)buffer_info->rxbuf.page);
      
#line 4175 
      tmp_0 = e1000_tbi_should_accept(adapter,(unsigned char)((int)status),(unsigned char)((int)rx_desc->errors),length,(u8 const *)mapped);
      
#line 4175 
      if ((int)tmp_0 != 0) 
#line 4178 
                           length -= 1U;
      else 
        
#line 4179 
        if ((netdev->features & 274877906944ULL) != 0ULL) 
#line 4180 
                                                          goto process_skb;
        else {
          
#line 4185 
          if (rx_ring->rx_skb_top != (struct sk_buff *)0) 
#line 4186 
                                                          consume_skb(rx_ring->rx_skb_top); else ;
          
#line 4187 
          rx_ring->rx_skb_top = (struct sk_buff *)0;
          
#line 4188 
          goto next_desc;
        }
    }
    else ;
    process_skb: 
#line 4193 
    ;
    
#line 4194 
    if (((int)status & 2) == 0) {
      
#line 4196 
      if (rx_ring->rx_skb_top == (struct sk_buff *)0) {
        
#line 4198 
        rx_ring->rx_skb_top = napi_get_frags(& adapter->napi);
        
#line 4199 
        if (rx_ring->rx_skb_top == (struct sk_buff *)0) 
#line 4200 
                                                        goto ldv_57469; else ;
        
#line 4202 
        skb_fill_page_desc(rx_ring->rx_skb_top,0,buffer_info->rxbuf.page,0,(int)length);
      }
      else {
        unsigned char *tmp_1;
        
#line 4207 
        ;
        
#line 4207 
        ;
        
#line 4208 
        tmp_1 = skb_end_pointer((struct sk_buff const *)rx_ring->rx_skb_top);
        
#line 4207 
        ;
        
#line 4207 
        skb_fill_page_desc(rx_ring->rx_skb_top,(int)((struct skb_shared_info *)tmp_1)->nr_frags,buffer_info->rxbuf.page,0,(int)length);
      }
      
#line 4211 
      e1000_consume_page(buffer_info,rx_ring->rx_skb_top,(unsigned short)((int)((unsigned short)length)));
      
#line 4212 
      goto next_desc;
    }
    else 
      
#line 4214 
      if (rx_ring->rx_skb_top != (struct sk_buff *)0) {
        unsigned char *tmp_2;
        
#line 4216 
        ;
        
#line 4216 
        ;
        
#line 4217 
        tmp_2 = skb_end_pointer((struct sk_buff const *)rx_ring->rx_skb_top);
        
#line 4216 
        ;
        
#line 4216 
        skb_fill_page_desc(rx_ring->rx_skb_top,(int)((struct skb_shared_info *)tmp_2)->nr_frags,buffer_info->rxbuf.page,0,(int)length);
        
#line 4219 
        skb = rx_ring->rx_skb_top;
        
#line 4220 
        rx_ring->rx_skb_top = (struct sk_buff *)0;
        
#line 4221 
        e1000_consume_page(buffer_info,skb,(unsigned short)((int)((unsigned short)length)));
      }
      else {
        struct page *p;
        
#line 4227 
        p = buffer_info->rxbuf.page;
        
#line 4228 
        if (length <= copybreak) {
          u8 *vaddr;
          unsigned char *tmp_4;
          
#line 4231 
          if ((long)((netdev->features & 137438953472ULL) == 0ULL) != 0L) 
            
#line 4232 
            length += 4294967292U; else ;
          
#line 4233 
          skb = e1000_alloc_rx_skb(adapter,length);
          
#line 4235 
          if (skb == (struct sk_buff *)0) 
#line 4236 
                                          goto ldv_57469; else ;
          
#line 4238 
          vaddr = (u8 *)kmap_atomic(p);
          
#line 4239 
          ;
          
#line 4239 
          ;
          
#line 4239 
          tmp_4 = skb_tail_pointer((struct sk_buff const *)skb);
          
#line 4239 
          memcpy((void *)tmp_4,(void const *)vaddr,(unsigned long)length);
          {
            
#line 4241 
            bool __cond = (_Bool)0;
            
#line 4241 
            if ((int)__cond != 0) 
#line 4241 
                                  __compiletime_assert_4241(); else ;
          }
          
#line 4241 
          __kunmap_atomic((void *)vaddr);
          
#line 4245 
          skb_put(skb,length);
          
#line 4246 
          e1000_rx_checksum(adapter,(unsigned int)((int)status | ((int)rx_desc->errors << 24)),(unsigned int)rx_desc->csum,skb);
          
#line 4250 
          total_rx_bytes = skb->len + total_rx_bytes;
          
#line 4251 
          total_rx_packets += 1U;
          
#line 4253 
          e1000_receive_skb(adapter,(unsigned char)((int)status),(unsigned short)((int)rx_desc->special),skb);
          
#line 4255 
          goto next_desc;
        }
        else {
          
#line 4257 
          skb = napi_get_frags(& adapter->napi);
          
#line 4258 
          if (skb == (struct sk_buff *)0) {
            
#line 4259 
            adapter->alloc_rx_buff_failed += 1U;
            
#line 4260 
            goto ldv_57469;
          }
          else ;
          
#line 4262 
          skb_fill_page_desc(skb,0,p,0,(int)length);
          
#line 4264 
          e1000_consume_page(buffer_info,skb,(unsigned short)((int)((unsigned short)length)));
        }
      }
    
#line 4271 
    e1000_rx_checksum(adapter,(unsigned int)status | ((unsigned int)rx_desc->errors << 24),(unsigned int)rx_desc->csum,skb);
    
#line 4276 
    total_rx_bytes = (skb->len + total_rx_bytes) + 4294967292U;
    
#line 4277 
    if ((long)((netdev->features & 137438953472ULL) == 0ULL) != 0L) 
#line 4278 
                                                                    pskb_trim(skb,skb->len + 4294967292U); else ;
    
#line 4279 
    total_rx_packets += 1U;
    
#line 4281 
    if (((int)status & 8) != 0) {
      
#line 4282 
      __le16 vlan = rx_desc->special;
      
#line 4283 
      u16 vid = (unsigned short)((unsigned int)vlan & 4095U);
      
#line 4285 
      __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)((int)vid));
    }
    else ;
    
#line 4288 
    napi_gro_frags(& adapter->napi);
    next_desc: 
#line 4290 
    ;
    
#line 4291 
    rx_desc->status = (unsigned char)0U;
    
#line 4294 
    if ((long)(cleaned_count > 15) != 0L) {
      
#line 4295 
      (*(adapter->alloc_rx_buf))(adapter,rx_ring,cleaned_count);
      
#line 4296 
      cleaned_count = 0;
    }
    else ;
    
#line 4300 
    rx_desc = next_rxd;
    
#line 4301 
    buffer_info = next_buffer;
  }
  ldv_57482: 
#line 4303 
  ;
  
#line 4145 
  if (((int)rx_desc->status & 1) != 0) 
#line 4147 
                                       goto ldv_57481; else 
#line 4150 
                                                            goto ldv_57469;
  ldv_57469: 
#line 4151 
  ;
  
#line 4303 
  rx_ring->next_to_clean = i;
  
#line 4305 
  if (rx_ring->next_to_clean <= rx_ring->next_to_use) 
#line 4305 
                                                      tmp_5 = rx_ring->count; else 
                                                                    
#line 4305 
                                                                    tmp_5 = 0U;
  
#line 4305 
  cleaned_count = (int)(((tmp_5 + rx_ring->next_to_clean) - rx_ring->next_to_use) + 4294967295U);
  
#line 4306 
  if (cleaned_count != 0) 
#line 4307 
                          (*(adapter->alloc_rx_buf))(adapter,rx_ring,cleaned_count); else ;
  
#line 4309 
  adapter->total_rx_packets += total_rx_packets;
  
#line 4310 
  adapter->total_rx_bytes += total_rx_bytes;
  
#line 4311 
  netdev->stats.rx_bytes += (unsigned long)total_rx_bytes;
  
#line 4312 
  netdev->stats.rx_packets += (unsigned long)total_rx_packets;
  
#line 4313 
  return cleaned;
}


#line 4319  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static struct sk_buff *e1000_copybreak(struct e1000_adapter *adapter, struct e1000_rx_buffer *buffer_info, u32 length, void const *data)
{
  struct sk_buff *__retres;
  struct sk_buff *skb;
  unsigned char *tmp;
  
#line 4325 
  if (length > copybreak) {
    
#line 4326 
    __retres = (struct sk_buff *)0;
    
#line 4326 
    goto return_label;
  }
  else ;
  
#line 4328 
  skb = e1000_alloc_rx_skb(adapter,length);
  
#line 4329 
  if (skb == (struct sk_buff *)0) {
    
#line 4330 
    __retres = (struct sk_buff *)0;
    
#line 4330 
    goto return_label;
  }
  else ;
  
#line 4332 
  dma_sync_single_for_cpu(& (adapter->pdev)->dev,buffer_info->dma,(unsigned long)length,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 4335 
  ;
  
#line 4335 
  ;
  
#line 4335 
  tmp = skb_put(skb,length);
  
#line 4335 
  memcpy((void *)tmp,data,(unsigned long)length);
  
#line 4337 
  __retres = skb;
  return_label: 
#line 4337 
                return __retres;
}


#line 4347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static bool e1000_clean_rx_irq(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int *work_done, int work_to_do)
{
  struct e1000_rx_desc *rx_desc;
  struct e1000_rx_desc *next_rxd;
  struct e1000_rx_buffer *buffer_info;
  struct e1000_rx_buffer *next_buffer;
  u32 length;
  unsigned int i;
  unsigned int tmp_5;
  
#line 4351 
  struct net_device *netdev = adapter->netdev;
  
#line 4352 
  struct pci_dev *pdev = adapter->pdev;
  
#line 4357 
  int cleaned_count = 0;
  
#line 4358 
  bool cleaned = (_Bool)0;
  
#line 4359 
  unsigned int total_rx_bytes = 0U;
  
#line 4359 
  unsigned int total_rx_packets = 0U;
  
#line 4361 
  i = rx_ring->next_to_clean;
  
#line 4362 
  rx_desc = (struct e1000_rx_desc *)rx_ring->desc + i;
  
#line 4363 
  buffer_info = rx_ring->buffer_info + i;
  
#line 4365 
  goto ldv_57524;
  ldv_57523: 
#line 4366 
  ;
  {
    struct sk_buff *skb;
    u8 *data;
    u8 status;
    
#line 4370 
    if (*work_done >= work_to_do) 
#line 4371 
                                  goto ldv_57511; else ;
    
#line 4372 
    *work_done += 1;
    
#line 4373 
    ldv_inline_asm();
    
#line 4375 
    status = rx_desc->status;
    
#line 4376 
    length = (unsigned int)rx_desc->length;
    
#line 4378 
    data = buffer_info->rxbuf.data;
    
#line 4379 
    __builtin_prefetch((void const *)data);
    
#line 4380 
    skb = e1000_copybreak(adapter,buffer_info,length,(void const *)data);
    
#line 4381 
    if (skb == (struct sk_buff *)0) {
      int tmp_1;
      int tmp_3;
      
#line 4382 
      unsigned int frag_len = e1000_frag_len((struct e1000_adapter const *)adapter);
      
#line 4384 
      ;
      {
        int tmp_0;
        
#line 4384 
        int _max1 = 32;
        
#line 4384 
        int _max2 = 64;
        
#line 4384 
        if (_max1 > _max2) 
#line 4384 
                           tmp_0 = _max1; else 
#line 4384 
                                               tmp_0 = _max2;
        
#line 4384 
        tmp_1 = tmp_0;
      }
      
#line 4384 
      ;
      
#line 4384 
      skb = build_skb((void *)(data + - tmp_1),frag_len);
      
#line 4385 
      if (skb == (struct sk_buff *)0) {
        
#line 4386 
        adapter->alloc_rx_buff_failed += 1U;
        
#line 4387 
        goto ldv_57511;
      }
      else ;
      {
        int tmp_2;
        
#line 4390 
        int _max1_0 = 32;
        
#line 4390 
        int _max2_0 = 64;
        
#line 4390 
        if (_max1_0 > _max2_0) 
#line 4390 
                               tmp_2 = _max1_0; else 
#line 4390 
                                                     tmp_2 = _max2_0;
        
#line 4390 
        tmp_3 = tmp_2;
      }
      
#line 4390 
      ;
      
#line 4390 
      skb_reserve(skb,tmp_3);
      
#line 4391 
      dma_unmap_single_attrs(& pdev->dev,buffer_info->dma,(unsigned long)adapter->rx_buffer_len,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
      
#line 4394 
      buffer_info->dma = 0ULL;
      
#line 4395 
      buffer_info->rxbuf.data = (u8 *)0U;
    }
    else ;
    
#line 4398 
    i += 1U;
    
#line 4398 
    ;
    
#line 4398 
    if (i == rx_ring->count) 
#line 4398 
                             i = 0U; else ;
    
#line 4399 
    next_rxd = (struct e1000_rx_desc *)rx_ring->desc + i;
    
#line 4400 
    __builtin_prefetch((void const *)next_rxd);
    
#line 4402 
    next_buffer = rx_ring->buffer_info + i;
    
#line 4404 
    cleaned = (_Bool)1;
    
#line 4405 
    cleaned_count += 1;
    
#line 4413 
    if ((long)(((int)status & 2) == 0) != 0L) 
#line 4414 
                                              adapter->discarding = (_Bool)1; else ;
    
#line 4416 
    if ((int)adapter->discarding != 0) {
      {
        
#line 4418 
        struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_clean_rx_irq", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c", .format = "Receive packet consumed multiple buffers\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4418U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 4418 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) 
#line 4418 
                                                            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)netdev,"Receive packet consumed multiple buffers\n"); else ;
      }
      
#line 4419 
      consume_skb(skb);
      
#line 4420 
      if (((int)status & 2) != 0) 
#line 4421 
                                  adapter->discarding = (_Bool)0; else ;
      
#line 4422 
      goto next_desc;
    }
    else ;
    
#line 4425 
    if ((long)(((int)rx_desc->errors & 151) != 0) != 0L) {
      bool tmp_4;
      
#line 4426 
      tmp_4 = e1000_tbi_should_accept(adapter,(unsigned char)((int)status),(unsigned char)((int)rx_desc->errors),length,(u8 const *)data);
      
#line 4426 
      if ((int)tmp_4 != 0) 
#line 4429 
                           length -= 1U;
      else 
        
#line 4430 
        if ((netdev->features & 274877906944ULL) != 0ULL) 
#line 4431 
                                                          goto process_skb;
        else {
          
#line 4433 
          consume_skb(skb);
          
#line 4434 
          goto next_desc;
        }
    }
    else ;
    process_skb: 
#line 4438 
    ;
    
#line 4439 
    total_rx_bytes = (length + total_rx_bytes) + 4294967292U;
    
#line 4440 
    total_rx_packets += 1U;
    
#line 4442 
    if ((long)((netdev->features & 137438953472ULL) == 0ULL) != 0L) 
#line 4446 
                                                                    length += 4294967292U; else ;
    
#line 4448 
    if (buffer_info->rxbuf.data == (u8 *)0U) 
#line 4449 
                                             skb_put(skb,length); else 
                                                                    
#line 4451 
                                                                    skb_trim(skb,length);
    
#line 4454 
    e1000_rx_checksum(adapter,(unsigned int)status | ((unsigned int)rx_desc->errors << 24),(unsigned int)rx_desc->csum,skb);
    
#line 4459 
    e1000_receive_skb(adapter,(unsigned char)((int)status),(unsigned short)((int)rx_desc->special),skb);
    next_desc: 
#line 4461 
    ;
    
#line 4462 
    rx_desc->status = (unsigned char)0U;
    
#line 4465 
    if ((long)(cleaned_count > 15) != 0L) {
      
#line 4466 
      (*(adapter->alloc_rx_buf))(adapter,rx_ring,cleaned_count);
      
#line 4467 
      cleaned_count = 0;
    }
    else ;
    
#line 4471 
    rx_desc = next_rxd;
    
#line 4472 
    buffer_info = next_buffer;
  }
  ldv_57524: 
#line 4474 
  ;
  
#line 4365 
  if (((int)rx_desc->status & 1) != 0) 
#line 4367 
                                       goto ldv_57523; else 
#line 4370 
                                                            goto ldv_57511;
  ldv_57511: 
#line 4371 
  ;
  
#line 4474 
  rx_ring->next_to_clean = i;
  
#line 4476 
  if (rx_ring->next_to_clean <= rx_ring->next_to_use) 
#line 4476 
                                                      tmp_5 = rx_ring->count; else 
                                                                    
#line 4476 
                                                                    tmp_5 = 0U;
  
#line 4476 
  cleaned_count = (int)(((tmp_5 + rx_ring->next_to_clean) - rx_ring->next_to_use) + 4294967295U);
  
#line 4477 
  if (cleaned_count != 0) 
#line 4478 
                          (*(adapter->alloc_rx_buf))(adapter,rx_ring,cleaned_count); else ;
  
#line 4480 
  adapter->total_rx_packets += total_rx_packets;
  
#line 4481 
  adapter->total_rx_bytes += total_rx_bytes;
  
#line 4482 
  netdev->stats.rx_bytes += (unsigned long)total_rx_bytes;
  
#line 4483 
  netdev->stats.rx_packets += (unsigned long)total_rx_packets;
  
#line 4484 
  return cleaned;
}


#line 4494  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_alloc_jumbo_rx_buffers(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int cleaned_count)
{
  struct e1000_rx_desc *rx_desc;
  struct e1000_rx_buffer *buffer_info;
  unsigned int i;
  int tmp_0;
  
#line 4497 
  struct pci_dev *pdev = adapter->pdev;
  
#line 4502 
  i = rx_ring->next_to_use;
  
#line 4503 
  buffer_info = rx_ring->buffer_info + i;
  
#line 4505 
  goto ldv_57536;
  ldv_57535: 
#line 4506 
  ;
  
#line 4507 
  if (buffer_info->rxbuf.page == (struct page *)0) {
    
#line 4508 
    buffer_info->rxbuf.page = alloc_pages(32U,0U);
    
#line 4509 
    if ((long)(buffer_info->rxbuf.page == (struct page *)0) != 0L) {
      
#line 4510 
      adapter->alloc_rx_buff_failed += 1U;
      
#line 4511 
      goto ldv_57534;
    }
    else ;
  }
  else ;
  
#line 4515 
  if (buffer_info->dma == 0ULL) {
    int tmp;
    
#line 4516 
    buffer_info->dma = dma_map_page(& pdev->dev,buffer_info->rxbuf.page,0UL,(unsigned long)adapter->rx_buffer_len,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 4520 
    tmp = dma_mapping_error(& pdev->dev,buffer_info->dma);
    
#line 4520 
    if (tmp != 0) {
      
#line 4521 
      put_page(buffer_info->rxbuf.page);
      
#line 4522 
      buffer_info->rxbuf.page = (struct page *)0;
      
#line 4523 
      buffer_info->dma = 0ULL;
      
#line 4524 
      adapter->alloc_rx_buff_failed += 1U;
      
#line 4525 
      goto ldv_57534;
    }
    else ;
  }
  else ;
  
#line 4529 
  rx_desc = (struct e1000_rx_desc *)rx_ring->desc + i;
  
#line 4530 
  rx_desc->buffer_addr = buffer_info->dma;
  
#line 4532 
  i += 1U;
  
#line 4532 
  ;
  
#line 4532 
  if ((long)(i == rx_ring->count) != 0L) 
#line 4533 
                                         i = 0U; else ;
  
#line 4534 
  buffer_info = rx_ring->buffer_info + i;
  ldv_57536: 
#line 4535 
  ;
  
#line 4505 
  tmp_0 = cleaned_count;
  
#line 4505 
  cleaned_count -= 1;
  
#line 4505 
  ;
  
#line 4505 
  if (tmp_0 != 0) 
#line 4507 
                  goto ldv_57535; else 
#line 4510 
                                       goto ldv_57534;
  ldv_57534: 
#line 4511 
  ;
  
#line 4537 
  if ((long)(rx_ring->next_to_use != i) != 0L) {
    unsigned int tmp_1;
    
#line 4538 
    rx_ring->next_to_use = i;
    
#line 4539 
    tmp_1 = i;
    
#line 4539 
    i -= 1U;
    
#line 4539 
    ;
    
#line 4539 
    if ((long)(tmp_1 == 0U) != 0L) 
#line 4540 
                                   i = rx_ring->count + 4294967295U; else ;
    
#line 4541 
    ldv_inline_asm();
    
#line 4548 
    writel(i,(void volatile *)(adapter->hw.hw_addr + (int)rx_ring->rdt));
  }
  else ;
  
#line 4550 
  return;
}


#line 4556  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int cleaned_count)
{
  struct e1000_rx_desc *rx_desc;
  struct e1000_rx_buffer *buffer_info;
  unsigned int i;
  int tmp_6;
  
#line 4560 
  struct e1000_hw *hw = & adapter->hw;
  
#line 4561 
  struct pci_dev *pdev = adapter->pdev;
  
#line 4565 
  unsigned int bufsz = adapter->rx_buffer_len;
  
#line 4567 
  i = rx_ring->next_to_use;
  
#line 4568 
  buffer_info = rx_ring->buffer_info + i;
  
#line 4570 
  goto ldv_57553;
  ldv_57552: 
#line 4571 
  ;
  {
    void *data;
    int tmp_2;
    bool tmp_1;
    int tmp_3;
    int tmp_5;
    bool tmp_4;
    
#line 4573 
    if (buffer_info->rxbuf.data != (u8 *)0U) 
#line 4574 
                                             goto skip; else ;
    
#line 4576 
    data = e1000_alloc_frag((struct e1000_adapter const *)adapter);
    
#line 4577 
    if (data == (void *)0) {
      
#line 4579 
      adapter->alloc_rx_buff_failed += 1U;
      
#line 4580 
      goto ldv_57550;
    }
    else ;
    
#line 4584 
    tmp_1 = e1000_check_64k_bound(adapter,data,(unsigned long)bufsz);
    
#line 4584 
    if (tmp_1) 
#line 4584 
               tmp_2 = 0; else 
#line 4584 
                               tmp_2 = 1;
    
#line 4584 
    if (tmp_2) {
      int tmp_0;
      bool tmp;
      
#line 4585 
      void *olddata = data;
      
#line 4586 
      if ((adapter->msg_enable & 64) != 0) 
#line 4586 
                                           netdev_err((struct net_device const *)adapter->netdev,"skb align check failed: %u bytes at ",bufsz,data); else ;
      
#line 4589 
      data = e1000_alloc_frag((struct e1000_adapter const *)adapter);
      
#line 4591 
      if (data == (void *)0) {
        
#line 4592 
        skb_free_frag(olddata);
        
#line 4593 
        adapter->alloc_rx_buff_failed += 1U;
        
#line 4594 
        goto ldv_57550;
      }
      else ;
      
#line 4597 
      tmp = e1000_check_64k_bound(adapter,data,(unsigned long)bufsz);
      
#line 4597 
      if (tmp) 
#line 4597 
               tmp_0 = 0; else 
#line 4597 
                               tmp_0 = 1;
      
#line 4597 
      if (tmp_0) {
        
#line 4599 
        skb_free_frag(data);
        
#line 4600 
        skb_free_frag(olddata);
        
#line 4601 
        adapter->alloc_rx_buff_failed += 1U;
        
#line 4602 
        goto ldv_57550;
      }
      else ;
      
#line 4606 
      skb_free_frag(olddata);
    }
    else ;
    
#line 4608 
    buffer_info->dma = dma_map_single_attrs(& pdev->dev,data,(unsigned long)adapter->rx_buffer_len,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
    
#line 4612 
    tmp_3 = dma_mapping_error(& pdev->dev,buffer_info->dma);
    
#line 4612 
    if (tmp_3 != 0) {
      
#line 4613 
      skb_free_frag(data);
      
#line 4614 
      buffer_info->dma = 0ULL;
      
#line 4615 
      adapter->alloc_rx_buff_failed += 1U;
      
#line 4616 
      goto ldv_57550;
    }
    else ;
    
#line 4624 
    tmp_4 = e1000_check_64k_bound(adapter,(void *)buffer_info->dma,(unsigned long)adapter->rx_buffer_len);
    
#line 4624 
    if (tmp_4) 
#line 4624 
               tmp_5 = 0; else 
#line 4624 
                               tmp_5 = 1;
    
#line 4624 
    if (tmp_5) {
      
#line 4627 
      if ((adapter->msg_enable & 64) != 0) 
#line 4627 
                                           netdev_err((struct net_device const *)adapter->netdev,"dma align check failed: %u bytes at ",adapter->rx_buffer_len,(void *)buffer_info->dma); else ;
      
#line 4631 
      dma_unmap_single_attrs(& pdev->dev,buffer_info->dma,(unsigned long)adapter->rx_buffer_len,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
      
#line 4635 
      skb_free_frag(data);
      
#line 4636 
      buffer_info->rxbuf.data = (u8 *)0U;
      
#line 4637 
      buffer_info->dma = 0ULL;
      
#line 4639 
      adapter->alloc_rx_buff_failed += 1U;
      
#line 4640 
      goto ldv_57550;
    }
    else ;
    
#line 4642 
    buffer_info->rxbuf.data = (u8 *)data;
    skip: 
#line 4643 
    ;
    
#line 4644 
    rx_desc = (struct e1000_rx_desc *)rx_ring->desc + i;
    
#line 4645 
    rx_desc->buffer_addr = buffer_info->dma;
    
#line 4647 
    i += 1U;
    
#line 4647 
    ;
    
#line 4647 
    if ((long)(i == rx_ring->count) != 0L) 
#line 4648 
                                           i = 0U; else ;
    
#line 4649 
    buffer_info = rx_ring->buffer_info + i;
  }
  ldv_57553: 
#line 4651 
  ;
  
#line 4570 
  tmp_6 = cleaned_count;
  
#line 4570 
  cleaned_count -= 1;
  
#line 4570 
  ;
  
#line 4570 
  if (tmp_6 != 0) 
#line 4572 
                  goto ldv_57552; else 
#line 4575 
                                       goto ldv_57550;
  ldv_57550: 
#line 4576 
  ;
  
#line 4652 
  if ((long)(rx_ring->next_to_use != i) != 0L) {
    unsigned int tmp_7;
    
#line 4653 
    rx_ring->next_to_use = i;
    
#line 4654 
    tmp_7 = i;
    
#line 4654 
    i -= 1U;
    
#line 4654 
    ;
    
#line 4654 
    if ((long)(tmp_7 == 0U) != 0L) 
#line 4655 
                                   i = rx_ring->count + 4294967295U; else ;
    
#line 4656 
    ldv_inline_asm();
    
#line 4663 
    writel(i,(void volatile *)(hw->hw_addr + (int)rx_ring->rdt));
  }
  else ;
  
#line 4665 
  return;
}


#line 4671  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_smartspeed(struct e1000_adapter *adapter)
{
  u16 phy_status;
  u16 phy_ctrl;
  u32 tmp_3;
  
#line 4673 
  struct e1000_hw *hw = & adapter->hw;
  
#line 4677 
  if ((hw->phy_type != (unsigned int)1 || (unsigned int)hw->autoneg == 0U) || ((int)hw->autoneg_advertised & 32) == 0) 
    
#line 4679 
    goto return_label; else ;
  
#line 4681 
  if (adapter->smartspeed == 0U) {
    
#line 4685 
    e1000_read_phy_reg(hw,10U,& phy_status);
    
#line 4686 
    if ((int)phy_status >= 0) 
#line 4686 
                              goto return_label; else ;
    
#line 4687 
    e1000_read_phy_reg(hw,10U,& phy_status);
    
#line 4688 
    if ((int)phy_status >= 0) 
#line 4688 
                              goto return_label; else ;
    
#line 4689 
    e1000_read_phy_reg(hw,9U,& phy_ctrl);
    
#line 4690 
    if (((int)phy_ctrl & 4096) != 0) {
      s32 tmp;
      
#line 4691 
      phy_ctrl = (unsigned short)((unsigned int)phy_ctrl & 61439U);
      
#line 4692 
      e1000_write_phy_reg(hw,9U,(unsigned short)((int)phy_ctrl));
      
#line 4694 
      adapter->smartspeed += 1U;
      
#line 4695 
      tmp = e1000_phy_setup_autoneg(hw);
      
#line 4695 
      if (tmp == 0) {
        s32 tmp_0;
        
#line 4695 
        tmp_0 = e1000_read_phy_reg(hw,0U,& phy_ctrl);
        
#line 4695 
        if (tmp_0 == 0) {
          
#line 4698 
          phy_ctrl = (unsigned short)((unsigned int)phy_ctrl | 4608U);
          
#line 4700 
          e1000_write_phy_reg(hw,0U,(unsigned short)((int)phy_ctrl));
        }
        else ;
      }
      else ;
    }
    else ;
    
#line 4704 
    goto return_label;
  }
  else 
    
#line 4705 
    if (adapter->smartspeed == 3U) {
      s32 tmp_1;
      
#line 4707 
      e1000_read_phy_reg(hw,9U,& phy_ctrl);
      
#line 4708 
      phy_ctrl = (unsigned short)((unsigned int)phy_ctrl | 4096U);
      
#line 4709 
      e1000_write_phy_reg(hw,9U,(unsigned short)((int)phy_ctrl));
      
#line 4710 
      tmp_1 = e1000_phy_setup_autoneg(hw);
      
#line 4710 
      if (tmp_1 == 0) {
        s32 tmp_2;
        
#line 4710 
        tmp_2 = e1000_read_phy_reg(hw,0U,& phy_ctrl);
        
#line 4710 
        if (tmp_2 == 0) {
          
#line 4712 
          phy_ctrl = (unsigned short)((unsigned int)phy_ctrl | 4608U);
          
#line 4714 
          e1000_write_phy_reg(hw,0U,(unsigned short)((int)phy_ctrl));
        }
        else ;
      }
      else ;
    }
    else ;
  
#line 4718 
  tmp_3 = adapter->smartspeed;
  
#line 4718 
  adapter->smartspeed += 1U;
  
#line 4718 
  ;
  
#line 4718 
  if (tmp_3 == 15U) 
#line 4719 
                    adapter->smartspeed = 0U; else ;
  return_label: 
#line 4720 
                return;
}


#line 4728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
  int __retres;
  
#line 4730 
  switch (cmd) {
    int tmp;
    case 35143: 
#line 4731 
    ;
    case 35144: 
#line 4732 
    ;
    case 35145: 
#line 4733 
    ;
    
#line 4734 
    tmp = e1000_mii_ioctl(netdev,ifr,cmd);
    
#line 4734 
    __retres = tmp;
    
#line 4734 
    goto return_label;
    default: 
#line 4735 
    ;
    
#line 4736 
    __retres = -95;
    
#line 4736 
    goto return_label;
  }
  return_label: 
#line 4730 
                return __retres;
}


#line 4746  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
  int __retres;
  int retval;
  u16 mii_reg;
  unsigned long flags;
  
#line 4749 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 4750 
  struct e1000_hw *hw = & adapter->hw;
  
#line 4751 
  struct mii_ioctl_data *data = if_mii(ifr);
  
#line 4756 
  if (hw->media_type != (unsigned int)e1000_media_type_copper) {
    
#line 4757 
    __retres = -95;
    
#line 4757 
    goto return_label;
  }
  else ;
  
#line 4759 
  switch (cmd) {
    s32 tmp_1;
    s32 tmp_2;
    case 35143: 
#line 4760 
    ;
    
#line 4761 
    data->phy_id = (unsigned short)hw->phy_addr;
    
#line 4762 
    goto ldv_57581;
    case 35144: 
#line 4763 
    ;
    
#line 4764 
    ldv___ldv_spin_lock_98(& adapter->stats_lock);
    
#line 4765 
    tmp_1 = e1000_read_phy_reg(hw,(unsigned int)data->reg_num & 31U,& data->val_out);
    
#line 4765 
    if (tmp_1 != 0) {
      
#line 4767 
      ldv_spin_unlock_irqrestore_99(& adapter->stats_lock,flags);
      
#line 4768 
      __retres = -5;
      
#line 4768 
      goto return_label;
    }
    else ;
    
#line 4770 
    ldv_spin_unlock_irqrestore_100(& adapter->stats_lock,flags);
    
#line 4771 
    goto ldv_57581;
    case 35145: 
#line 4772 
    ;
    
#line 4773 
    if (((int)data->reg_num & -32) != 0) {
      
#line 4774 
      __retres = -14;
      
#line 4774 
      goto return_label;
    }
    else ;
    
#line 4775 
    mii_reg = data->val_in;
    
#line 4776 
    ldv___ldv_spin_lock_101(& adapter->stats_lock);
    
#line 4777 
    tmp_2 = e1000_write_phy_reg(hw,(unsigned int)data->reg_num,(unsigned short)((int)mii_reg));
    
#line 4777 
    if (tmp_2 != 0) {
      
#line 4779 
      ldv_spin_unlock_irqrestore_102(& adapter->stats_lock,flags);
      
#line 4780 
      __retres = -5;
      
#line 4780 
      goto return_label;
    }
    else ;
    
#line 4782 
    ldv_spin_unlock_irqrestore_103(& adapter->stats_lock,flags);
    
#line 4783 
    if (hw->media_type == (unsigned int)e1000_media_type_copper) {
      
#line 4784 
      switch ((int)data->reg_num) {
        bool tmp_3;
        s32 tmp_4;
        case 0: 
#line 4785 
        ;
        
#line 4786 
        if (((int)mii_reg & 2048) != 0) 
#line 4787 
                                        goto ldv_57585; else ;
        
#line 4788 
        if (((int)mii_reg & 4096) != 0) {
          
#line 4789 
          hw->autoneg = (unsigned char)1U;
          
#line 4790 
          hw->autoneg_advertised = (unsigned short)47U;
        }
        else {
          u32 speed;
          
#line 4793 
          if (((int)mii_reg & 64) != 0) 
#line 4794 
                                        speed = 1000U;
          else 
            
#line 4795 
            if (((int)mii_reg & 8192) != 0) 
#line 4796 
                                            speed = 100U; else 
#line 4798 
                                                               speed = 10U;
          
#line 4799 
          retval = e1000_set_spd_dplx(adapter,speed,(unsigned char)((int)((unsigned char)((int)mii_reg >> 8)) & 1));
          
#line 4804 
          if (retval != 0) {
            
#line 4805 
            __retres = retval;
            
#line 4805 
            goto return_label;
          }
          else ;
        }
        
#line 4807 
        tmp_3 = netif_running((struct net_device const *)adapter->netdev);
        
#line 4807 
        if ((int)tmp_3 != 0) 
#line 4808 
                             e1000_reinit_locked(adapter); else 
#line 4810 
                                                                e1000_reset(adapter);
        
#line 4811 
        goto ldv_57585;
        case 16: 
#line 4812 
        ;
        case 20: 
#line 4813 
        ;
        
#line 4814 
        tmp_4 = e1000_phy_reset(hw);
        
#line 4814 
        if (tmp_4 != 0) {
          
#line 4815 
          __retres = -5;
          
#line 4815 
          goto return_label;
        }
        else ;
        
#line 4816 
        goto ldv_57585;
      }
      ldv_57585: 
#line 4818 
      ;
    }
    else {
      
#line 4819 
      switch ((int)data->reg_num) {
        bool tmp_5;
        case 0: 
#line 4820 
        ;
        
#line 4821 
        if (((int)mii_reg & 2048) != 0) 
#line 4822 
                                        goto ldv_57590; else ;
        
#line 4823 
        tmp_5 = netif_running((struct net_device const *)adapter->netdev);
        
#line 4823 
        if ((int)tmp_5 != 0) 
#line 4824 
                             e1000_reinit_locked(adapter); else 
#line 4826 
                                                                e1000_reset(adapter);
        
#line 4827 
        goto ldv_57590;
      }
      ldv_57590: 
#line 4829 
      ;
    }
    
#line 4830 
    goto ldv_57581;
    default: 
#line 4831 
    ;
    
#line 4832 
    __retres = -95;
    
#line 4832 
    goto return_label;
  }
  ldv_57581: 
#line 4834 
  ;
  
#line 4834 
  __retres = 0;
  return_label: 
#line 4834 
                return __retres;
}


#line 4837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_pci_set_mwi(struct e1000_hw *hw)
{
  
#line 4839 
  struct e1000_adapter *adapter = (struct e1000_adapter *)hw->back;
  
#line 4840 
  int ret_val = pci_set_mwi(adapter->pdev);
  
#line 4842 
  if (ret_val != 0) {
    
#line 4843 
    if ((adapter->msg_enable & 2) != 0) 
#line 4843 
                                        netdev_err((struct net_device const *)adapter->netdev,"Error in setting MWI\n"); else ;
  }
  else ;
  
#line 4844 
  return;
}


#line 4846  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_pci_clear_mwi(struct e1000_hw *hw)
{
  
#line 4848 
  struct e1000_adapter *adapter = (struct e1000_adapter *)hw->back;
  
#line 4850 
  pci_clear_mwi(adapter->pdev);
  
#line 4851 
  return;
}


#line 4853  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
int e1000_pcix_get_mmrbc(struct e1000_hw *hw)
{
  int tmp;
  
#line 4855 
  struct e1000_adapter *adapter = (struct e1000_adapter *)hw->back;
  
#line 4856 
  tmp = pcix_get_mmrbc(adapter->pdev);
  
#line 4856 
  return tmp;
}


#line 4859  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_pcix_set_mmrbc(struct e1000_hw *hw, int mmrbc)
{
  
#line 4861 
  struct e1000_adapter *adapter = (struct e1000_adapter *)hw->back;
  
#line 4862 
  pcix_set_mmrbc(adapter->pdev,mmrbc);
  
#line 4863 
  return;
}


#line 4865  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
void e1000_io_write(struct e1000_hw *hw, unsigned long port, u32 value)
{
  
#line 4867 
  outl(value,(int)port);
  
#line 4868 
  return;
}


#line 4870  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
  bool __retres;
  u16 vid;
  unsigned long tmp;
  unsigned long tmp_0;
  
#line 4874 
  tmp = find_first_bit((unsigned long const *)(& adapter->active_vlans),4096UL);
  
#line 4874 
  vid = (unsigned short)tmp;
  
#line 4874 
  goto ldv_57620;
  ldv_57619: 
#line 4875 
  ;
  
#line 4875 
  __retres = (_Bool)1;
  
#line 4875 
  goto return_label;
  
#line 4874 
  tmp_0 = find_next_bit((unsigned long const *)(& adapter->active_vlans),4096UL,(unsigned long)((int)vid + 1));
  
#line 4874 
  vid = (unsigned short)tmp_0;
  ldv_57620: 
#line 4875 
  ;
  
#line 4874 
  if ((unsigned int)vid <= 4095U) 
#line 4876 
                                  goto ldv_57619; else 
#line 4879 
                                                       goto ldv_57621;
  ldv_57621: 
#line 4880 
  ;
  
#line 4876 
  __retres = (_Bool)0;
  return_label: 
#line 4876 
                return __retres;
}


#line 4879  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void __e1000_vlan_mode(struct e1000_adapter *adapter, netdev_features_t features)
{
  u32 ctrl;
  
#line 4882 
  struct e1000_hw *hw = & adapter->hw;
  
#line 4885 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 4886 
  if ((features & 256ULL) != 0ULL) 
#line 4888 
                                   ctrl |= 1073741824U; else 
#line 4891 
                                                             ctrl &= 3221225471U;
  
#line 4893 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 4894 
  return;
}


#line 4895  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_vlan_filter_on_off(struct e1000_adapter *adapter, bool filter_on)
{
  u32 rctl;
  int tmp;
  int tmp_0;
  
#line 4898 
  struct e1000_hw *hw = & adapter->hw;
  
#line 4901 
  tmp = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
  
#line 4901 
  if (tmp == 0) 
#line 4902 
                e1000_irq_disable(adapter); else ;
  
#line 4904 
  __e1000_vlan_mode(adapter,(adapter->netdev)->features);
  
#line 4905 
  if ((int)filter_on != 0) {
    
#line 4907 
    rctl = readl((void const volatile *)(hw->hw_addr + 256U));
    
#line 4908 
    rctl &= 4294443007U;
    
#line 4909 
    if (((adapter->netdev)->flags & 256U) == 0U) 
#line 4910 
                                                 rctl |= 262144U; else ;
    
#line 4911 
    writel(rctl,(void volatile *)(hw->hw_addr + 256U));
    
#line 4912 
    e1000_update_mng_vlan(adapter);
  }
  else {
    
#line 4915 
    rctl = readl((void const volatile *)(hw->hw_addr + 256U));
    
#line 4916 
    rctl &= 4294705151U;
    
#line 4917 
    writel(rctl,(void volatile *)(hw->hw_addr + 256U));
  }
  
#line 4920 
  tmp_0 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
  
#line 4920 
  if (tmp_0 == 0) 
#line 4921 
                  e1000_irq_enable(adapter); else ;
  
#line 4922 
  return;
}


#line 4924  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_vlan_mode(struct net_device *netdev, netdev_features_t features)
{
  int tmp_0;
  int tmp_1;
  
#line 4927 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 4929 
  tmp_0 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
  
#line 4929 
  if (tmp_0 == 0) 
#line 4930 
                  e1000_irq_disable(adapter); else ;
  
#line 4932 
  __e1000_vlan_mode(adapter,features);
  
#line 4934 
  tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
  
#line 4934 
  if (tmp_1 == 0) 
#line 4935 
                  e1000_irq_enable(adapter); else ;
  
#line 4936 
  return;
}


#line 4938  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  int __retres;
  u32 vfta;
  u32 index;
  int tmp_1;
  bool tmp_0;
  int tmp_2;
  
#line 4941 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 4942 
  struct e1000_hw *hw = & adapter->hw;
  
#line 4945 
  if (((int)hw->mng_cookie.status & 2) != 0 && (int)adapter->mng_vlan_id == (int)vid) {
    
#line 4948 
    __retres = 0;
    
#line 4948 
    goto return_label;
  }
  else ;
  
#line 4950 
  tmp_0 = e1000_vlan_used(adapter);
  
#line 4950 
  if (tmp_0) 
#line 4950 
             tmp_1 = 0; else 
#line 4950 
                             tmp_1 = 1;
  
#line 4950 
  if (tmp_1) 
#line 4951 
             e1000_vlan_filter_on_off(adapter,(_Bool)1); else ;
  
#line 4954 
  index = (unsigned int)((int)vid >> 5) & 127U;
  
#line 4955 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4955 
                                                       tmp_2 = 22016; else 
                                                                    
#line 4955 
                                                                    tmp_2 = 1536;
  
#line 4955 
  ;
  
#line 4955 
  vfta = readl((void const volatile *)(hw->hw_addr + ((u32)tmp_2 + (index << 2))));
  
#line 4956 
  vfta = (unsigned int)(1 << ((int)vid & 31)) | vfta;
  
#line 4957 
  e1000_write_vfta(hw,index,vfta);
  
#line 4959 
  set_bit((long)vid,(unsigned long volatile *)(& adapter->active_vlans));
  
#line 4961 
  __retres = 0;
  return_label: 
#line 4961 
                return __retres;
}


#line 4964  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  int __retres;
  u32 vfta;
  u32 index;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_4;
  bool tmp_3;
  
#line 4967 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 4968 
  struct e1000_hw *hw = & adapter->hw;
  
#line 4971 
  tmp_0 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
  
#line 4971 
  if (tmp_0 == 0) 
#line 4972 
                  e1000_irq_disable(adapter); else ;
  
#line 4973 
  tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& adapter->flags));
  
#line 4973 
  if (tmp_1 == 0) 
#line 4974 
                  e1000_irq_enable(adapter); else ;
  
#line 4977 
  index = (unsigned int)((int)vid >> 5) & 127U;
  
#line 4978 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4978 
                                                       tmp_2 = 22016; else 
                                                                    
#line 4978 
                                                                    tmp_2 = 1536;
  
#line 4978 
  ;
  
#line 4978 
  vfta = readl((void const volatile *)(hw->hw_addr + ((u32)tmp_2 + (index << 2))));
  
#line 4979 
  vfta = (unsigned int)(~ (1 << ((int)vid & 31))) & vfta;
  
#line 4980 
  e1000_write_vfta(hw,index,vfta);
  
#line 4982 
  set_bit((long)vid,(unsigned long volatile *)(& adapter->active_vlans));
  
#line 4984 
  tmp_3 = e1000_vlan_used(adapter);
  
#line 4984 
  if (tmp_3) 
#line 4984 
             tmp_4 = 0; else 
#line 4984 
                             tmp_4 = 1;
  
#line 4984 
  if (tmp_4) 
#line 4985 
             e1000_vlan_filter_on_off(adapter,(_Bool)0); else ;
  
#line 4987 
  __retres = 0;
  
#line 4987 
  return __retres;
}


#line 4990  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_restore_vlan(struct e1000_adapter *adapter)
{
  u16 vid;
  int tmp_0;
  bool tmp;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 4994 
  tmp = e1000_vlan_used(adapter);
  
#line 4994 
  if (tmp) 
#line 4994 
           tmp_0 = 0; else 
#line 4994 
                           tmp_0 = 1;
  
#line 4994 
  if (tmp_0) 
#line 4995 
             goto return_label; else ;
  
#line 4997 
  e1000_vlan_filter_on_off(adapter,(_Bool)1);
  
#line 4998 
  tmp_1 = find_first_bit((unsigned long const *)(& adapter->active_vlans),4096UL);
  
#line 4998 
  vid = (unsigned short)tmp_1;
  
#line 4998 
  goto ldv_57662;
  ldv_57661: 
#line 4999 
  ;
  
#line 4999 
  e1000_vlan_rx_add_vid(adapter->netdev,(unsigned short)129,(unsigned short)((int)vid));
  
#line 4998 
  tmp_2 = find_next_bit((unsigned long const *)(& adapter->active_vlans),4096UL,(unsigned long)((int)vid + 1));
  
#line 4998 
  vid = (unsigned short)tmp_2;
  ldv_57662: 
#line 4999 
  ;
  
#line 4998 
  if ((unsigned int)vid <= 4095U) 
#line 5000 
                                  goto ldv_57661; else 
#line 5003 
                                                       goto ldv_57663;
  ldv_57663: 
#line 5004 
  ;
  return_label: 
#line 5005 
                return;
}


#line 5002  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
int e1000_set_spd_dplx(struct e1000_adapter *adapter, u32 spd, u8 dplx)
{
  int __retres;
  
#line 5004 
  struct e1000_hw *hw = & adapter->hw;
  
#line 5006 
  hw->autoneg = (unsigned char)0U;
  
#line 5011 
  if ((spd & 1U) != 0U || ((int)dplx & -2) != 0) 
#line 5012 
                                                 goto err_inval; else ;
  
#line 5015 
  if (hw->media_type == (unsigned int)e1000_media_type_fiber && (spd != 1000U && (unsigned int)dplx != 1U)) 
    
#line 5018 
    goto err_inval; else ;
  
#line 5020 
  switch ((unsigned int)dplx + spd) {
    case (unsigned int)10: 
#line 5021 
    ;
    
#line 5022 
    hw->forced_speed_duplex = (unsigned char)0U;
    
#line 5023 
    goto ldv_57672;
    case (unsigned int)11: 
#line 5024 
    ;
    
#line 5025 
    hw->forced_speed_duplex = (unsigned char)1U;
    
#line 5026 
    goto ldv_57672;
    case (unsigned int)100: 
#line 5027 
    ;
    
#line 5028 
    hw->forced_speed_duplex = (unsigned char)2U;
    
#line 5029 
    goto ldv_57672;
    case (unsigned int)101: 
#line 5030 
    ;
    
#line 5031 
    hw->forced_speed_duplex = (unsigned char)3U;
    
#line 5032 
    goto ldv_57672;
    case (unsigned int)1001: 
#line 5033 
    ;
    
#line 5034 
    hw->autoneg = (unsigned char)1U;
    
#line 5035 
    hw->autoneg_advertised = (unsigned short)32U;
    
#line 5036 
    goto ldv_57672;
    case (unsigned int)1000: 
#line 5037 
    ;
    default: 
#line 5038 
    ;
    
#line 5039 
    goto err_inval;
  }
  ldv_57672: 
#line 5043 
  ;
  
#line 5043 
  hw->mdix = (unsigned char)0U;
  
#line 5045 
  __retres = 0;
  
#line 5045 
  goto return_label;
  err_inval: 
#line 5047 
  ;
  
#line 5048 
  if ((adapter->msg_enable & 2) != 0) 
#line 5048 
                                      netdev_err((struct net_device const *)adapter->netdev,"Unsupported Speed/Duplex configuration\n"); else ;
  
#line 5049 
  __retres = -22;
  return_label: 
#line 5049 
                return __retres;
}


#line 5052  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
{
  int __retres;
  u32 ctrl;
  u32 ctrl_ext;
  u32 rctl;
  u32 status;
  bool tmp_4_0;
  bool tmp_5;
  
#line 5054 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 5055 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 5056 
  struct e1000_hw *hw = & adapter->hw;
  
#line 5058 
  u32 wufc = adapter->wol;
  
#line 5060 
  int retval = 0;
  
#line 5063 
  netif_device_detach(netdev);
  
#line 5065 
  tmp_4_0 = netif_running((struct net_device const *)netdev);
  
#line 5065 
  if ((int)tmp_4_0 != 0) {
    int tmp_1;
    
#line 5066 
    int count = 50;
    
#line 5068 
    goto ldv_57694;
    ldv_57693: 
#line 5069 
    ;
    
#line 5069 
    usleep_range(10000UL,20000UL);
    ldv_57694: 
#line 5070 
    ;
    
#line 5068 
    tmp_1 = constant_test_bit(1L,(unsigned long const volatile *)(& adapter->flags));
    
#line 5068 
    if (tmp_1 != 0) {
      int tmp_2;
      
#line 5068 
      tmp_2 = count;
      
#line 5068 
      count -= 1;
      
#line 5068 
      ;
      
#line 5068 
      if (tmp_2 != 0) 
#line 5070 
                      goto ldv_57693; else 
#line 5073 
                                           goto ldv_57695;
    }
    else 
#line 5073 
         goto ldv_57695;
    ldv_57695: 
#line 5074 
    ;
    {
      int tmp_3;
      
#line 5071 
      tmp_3 = constant_test_bit(1L,(unsigned long const volatile *)(& adapter->flags));
      
#line 5071 
      int __ret_warn_on = tmp_3 != 0;
      
#line 5071 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 5071 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c",5071); else ;
      
#line 5071 
      long tmp_4 = (long)(__ret_warn_on != 0);
    }
    
#line 5072 
    e1000_down(adapter);
  }
  else ;
  
#line 5076 
  retval = pci_save_state(pdev);
  
#line 5077 
  if (retval != 0) {
    
#line 5078 
    __retres = retval;
    
#line 5078 
    goto return_label;
  }
  else ;
  
#line 5081 
  status = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 5082 
  if ((status & 2U) != 0U) 
#line 5083 
                           wufc &= 4294967294U; else ;
  
#line 5085 
  if (wufc != 0U) {
    
#line 5086 
    e1000_setup_rctl(adapter);
    
#line 5087 
    e1000_set_rx_mode(netdev);
    
#line 5089 
    rctl = readl((void const volatile *)(hw->hw_addr + 256U));
    
#line 5092 
    if ((wufc & 8U) != 0U) 
#line 5093 
                           rctl |= 16U; else ;
    
#line 5096 
    writel(rctl | 2U,(void volatile *)(hw->hw_addr + 256U));
    
#line 5098 
    if (hw->mac_type > (unsigned int)e1000_82544) {
      
#line 5099 
      ctrl = readl((void const volatile *)hw->hw_addr);
      
#line 5104 
      ctrl |= 3145728U;
      
#line 5106 
      writel(ctrl,(void volatile *)hw->hw_addr);
    }
    else ;
    
#line 5109 
    if ((unsigned int)hw->media_type + 4294967295U <= 1U) {
      
#line 5112 
      ctrl_ext = readl((void const volatile *)(hw->hw_addr + 24U));
      
#line 5113 
      ctrl_ext |= 128U;
      
#line 5114 
      writel(ctrl_ext,(void volatile *)(hw->hw_addr + 24U));
    }
    else ;
    
#line 5117 
    writel(2U,(void volatile *)(hw->hw_addr + 22528U));
    
#line 5118 
    writel(wufc,(void volatile *)(hw->hw_addr + 22536U));
  }
  else {
    
#line 5120 
    writel(0U,(void volatile *)(hw->hw_addr + 22528U));
    
#line 5121 
    writel(0U,(void volatile *)(hw->hw_addr + 22536U));
  }
  
#line 5124 
  e1000_release_manageability(adapter);
  
#line 5126 
  *enable_wake = (_Bool)(wufc != 0U);
  
#line 5129 
  if (adapter->en_mng_pt != 0U) 
#line 5130 
                                *enable_wake = (_Bool)1; else ;
  
#line 5132 
  tmp_5 = netif_running((struct net_device const *)netdev);
  
#line 5132 
  if ((int)tmp_5 != 0) 
#line 5133 
                       e1000_free_irq(adapter); else ;
  
#line 5135 
  pci_disable_device(pdev);
  
#line 5137 
  __retres = 0;
  return_label: 
#line 5137 
                return __retres;
}


#line 5141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
{
  int __retres;
  int retval;
  bool wake;
  
#line 5146 
  retval = __e1000_shutdown(pdev,& wake);
  
#line 5147 
  if (retval != 0) {
    
#line 5148 
    __retres = retval;
    
#line 5148 
    goto return_label;
  }
  else ;
  
#line 5150 
  if ((int)wake != 0) 
#line 5151 
                      pci_prepare_to_sleep(pdev);
  else {
    
#line 5153 
    pci_wake_from_d3(pdev,(_Bool)0);
    
#line 5154 
    pci_set_power_state(pdev,3);
  }
  
#line 5157 
  __retres = 0;
  return_label: 
#line 5157 
                return __retres;
}


#line 5160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static int e1000_resume(struct pci_dev *pdev)
{
  int __retres;
  u32 err;
  bool tmp_4;
  bool tmp_5;
  
#line 5162 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 5163 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 5164 
  struct e1000_hw *hw = & adapter->hw;
  
#line 5167 
  pci_set_power_state(pdev,0);
  
#line 5168 
  pci_restore_state(pdev);
  
#line 5169 
  pci_save_state(pdev);
  
#line 5171 
  if (adapter->need_ioport != 0) {
    int tmp_1;
    
#line 5172 
    tmp_1 = pci_enable_device(pdev);
    
#line 5172 
    err = (unsigned int)tmp_1;
  }
  else {
    int tmp_2;
    
#line 5174 
    tmp_2 = pci_enable_device_mem(pdev);
    
#line 5174 
    err = (unsigned int)tmp_2;
  }
  
#line 5175 
  if (err != 0U) {
    
#line 5176 
    printk("\001");
    
#line 5177 
    __retres = (int)err;
    
#line 5177 
    goto return_label;
  }
  else ;
  
#line 5179 
  pci_set_master(pdev);
  
#line 5181 
  pci_enable_wake(pdev,3,(_Bool)0);
  
#line 5182 
  pci_enable_wake(pdev,4,(_Bool)0);
  
#line 5184 
  tmp_4 = netif_running((struct net_device const *)netdev);
  
#line 5184 
  if ((int)tmp_4 != 0) {
    int tmp_3;
    
#line 5185 
    tmp_3 = e1000_request_irq(adapter);
    
#line 5185 
    err = (unsigned int)tmp_3;
    
#line 5186 
    if (err != 0U) {
      
#line 5187 
      __retres = (int)err;
      
#line 5187 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 5190 
  e1000_power_up_phy(adapter);
  
#line 5191 
  e1000_reset(adapter);
  
#line 5192 
  writel(4294967295U,(void volatile *)(hw->hw_addr + 22544U));
  
#line 5194 
  e1000_init_manageability(adapter);
  
#line 5196 
  tmp_5 = netif_running((struct net_device const *)netdev);
  
#line 5196 
  if ((int)tmp_5 != 0) 
#line 5197 
                       e1000_up(adapter); else ;
  
#line 5199 
  netif_device_attach(netdev);
  
#line 5201 
  __retres = 0;
  return_label: 
#line 5201 
                return __retres;
}


#line 5205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_shutdown(struct pci_dev *pdev)
{
  bool wake;
  
#line 5209 
  __e1000_shutdown(pdev,& wake);
  
#line 5211 
  if (system_state == (unsigned int)SYSTEM_POWER_OFF) {
    
#line 5212 
    pci_wake_from_d3(pdev,(_Bool)((bool)((int)wake) != 0));
    
#line 5213 
    pci_set_power_state(pdev,3);
  }
  else ;
  
#line 5215 
  return;
}


#line 5222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_netpoll(struct net_device *netdev)
{
  
#line 5224 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 5226 
  disable_irq((adapter->pdev)->irq);
  
#line 5227 
  e1000_intr((int)(adapter->pdev)->irq,(void *)netdev);
  
#line 5228 
  enable_irq((adapter->pdev)->irq);
  
#line 5229 
  return;
}


#line 5240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
{
  pci_ers_result_t __retres;
  bool tmp_1;
  
#line 5243 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 5244 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 5246 
  netif_device_detach(netdev);
  
#line 5248 
  if (state == 3U) {
    
#line 5249 
    __retres = 4U;
    
#line 5249 
    goto return_label;
  }
  else ;
  
#line 5251 
  tmp_1 = netif_running((struct net_device const *)netdev);
  
#line 5251 
  if ((int)tmp_1 != 0) 
#line 5252 
                       e1000_down(adapter); else ;
  
#line 5253 
  pci_disable_device(pdev);
  
#line 5256 
  __retres = 3U;
  return_label: 
#line 5256 
                return __retres;
}


#line 5266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev)
{
  pci_ers_result_t __retres;
  int err;
  
#line 5268 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 5269 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 5270 
  struct e1000_hw *hw = & adapter->hw;
  
#line 5273 
  if (adapter->need_ioport != 0) 
#line 5274 
                                 err = pci_enable_device(pdev); else 
                                                                  
#line 5276 
                                                                  err = pci_enable_device_mem(pdev);
  
#line 5277 
  if (err != 0) {
    
#line 5278 
    printk("\001");
    
#line 5279 
    __retres = 4U;
    
#line 5279 
    goto return_label;
  }
  else ;
  
#line 5281 
  pci_set_master(pdev);
  
#line 5283 
  pci_enable_wake(pdev,3,(_Bool)0);
  
#line 5284 
  pci_enable_wake(pdev,4,(_Bool)0);
  
#line 5286 
  e1000_reset(adapter);
  
#line 5287 
  writel(4294967295U,(void volatile *)(hw->hw_addr + 22544U));
  
#line 5289 
  __retres = 5U;
  return_label: 
#line 5289 
                return __retres;
}


#line 5300  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_main.c"
static void e1000_io_resume(struct pci_dev *pdev)
{
  bool tmp_2;
  
#line 5302 
  struct net_device *netdev = pci_get_drvdata(pdev);
  
#line 5303 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 5305 
  e1000_init_manageability(adapter);
  
#line 5307 
  tmp_2 = netif_running((struct net_device const *)netdev);
  
#line 5307 
  if ((int)tmp_2 != 0) {
    int tmp_1;
    
#line 5308 
    tmp_1 = e1000_up(adapter);
    
#line 5308 
    if (tmp_1 != 0) {
      
#line 5309 
      printk("\001");
      
#line 5310 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 5314 
  netif_device_attach(netdev);
  return_label: 
#line 5315 
                return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int (*ldv_emg_alias_eth_validate_addr_8)(struct net_device *) = & eth_validate_addr;

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
struct pci_driver *ldv_emg_alias_e1000_driver_2 = & e1000_driver;

#line 60 
void ldv_emg_unregister_netdev(struct net_device *arg0);


#line 61 
_Bool ldv_emg_schedule_delayed_work(struct delayed_work *arg0, unsigned long arg1);


#line 62 
_Bool ldv_emg_schedule_work(struct work_struct *arg0);


#line 63 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 64 
int ldv_emg_register_netdev(struct net_device *arg0);


#line 65 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 66 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 67 
void ldv_emg_free_netdev(struct net_device *arg0);


#line 68 
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);


#line 69 
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);


#line 73  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_e1000_init_module(void)
{
  int tmp;
  
#line 74 
  tmp = e1000_init_module();
  
#line 74 
  return tmp;
}


#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_vlan_rx_add_vid_26(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  int tmp;
  
#line 78 
  tmp = e1000_vlan_rx_add_vid(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 78 
  return tmp;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_close_2(struct net_device *arg0)
{
  int tmp;
  
#line 83 
  tmp = e1000_close(arg0);
  
#line 83 
  return tmp;
}


#line 87  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
void ldv_emg_wrapper_e1000_remove_5(struct pci_dev *arg0)
{
  
#line 88 
  e1000_remove(arg0);
  
#line 89 
  return;
}


#line 92  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_resume_6(struct pci_dev *arg0)
{
  int tmp;
  
#line 93 
  tmp = e1000_resume(arg0);
  
#line 93 
  return tmp;
}


#line 97  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_vlan_rx_kill_vid_38(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  int tmp;
  
#line 98 
  tmp = e1000_vlan_rx_kill_vid(arg0,(unsigned short)((int)arg1),(unsigned short)((int)arg2));
  
#line 98 
  return tmp;
}


#line 102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
unsigned long long ldv_emg_wrapper_e1000_fix_features_15(struct net_device *arg0, unsigned long long arg1)
{
  unsigned long long tmp;
  
#line 103 
  tmp = e1000_fix_features(arg0,arg1);
  
#line 103 
  return tmp;
}


#line 107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
enum netdev_tx ldv_emg_wrapper_e1000_xmit_frame_19(struct sk_buff *arg0, struct net_device *arg1)
{
  enum netdev_tx tmp;
  
#line 108 
  tmp = e1000_xmit_frame(arg0,arg1);
  
#line 108 
  return tmp;
}


#line 112  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_set_features_13(struct net_device *arg0, unsigned long long arg1)
{
  int tmp;
  
#line 113 
  tmp = e1000_set_features(arg0,arg1);
  
#line 113 
  return tmp;
}


#line 117  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_probe_3(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 118 
  tmp = e1000_probe(arg0,(struct pci_device_id const *)arg1);
  
#line 118 
  return tmp;
}


#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
struct net_device_stats *ldv_emg_wrapper_e1000_get_stats_31(struct net_device *arg0)
{
  struct net_device_stats *tmp;
  
#line 123 
  tmp = e1000_get_stats(arg0);
  
#line 123 
  return tmp;
}


#line 127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
void ldv_emg_wrapper_e1000_shutdown_2(struct pci_dev *arg0)
{
  
#line 128 
  e1000_shutdown(arg0);
  
#line 129 
  return;
}


#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
void ldv_emg_wrapper_e1000_set_rx_mode_7(struct net_device *arg0)
{
  
#line 133 
  e1000_set_rx_mode(arg0);
  
#line 134 
  return;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_ioctl_27(struct net_device *arg0, struct ifreq *arg1, int arg2)
{
  int tmp;
  
#line 138 
  tmp = e1000_ioctl(arg0,arg1,arg2);
  
#line 138 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_open_2(struct net_device *arg0)
{
  int tmp;
  
#line 143 
  tmp = e1000_open(arg0);
  
#line 143 
  return tmp;
}


#line 147  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
void ldv_emg_e1000_exit_module(void)
{
  
#line 148 
  e1000_exit_module();
  
#line 149 
  return;
}


#line 151  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_suspend_4(struct pci_dev *arg0, struct pm_message arg1)
{
  int tmp;
  
#line 152 
  tmp = e1000_suspend(arg0,arg1);
  
#line 152 
  return tmp;
}


#line 156  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_change_mtu_10(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 157 
  tmp = e1000_change_mtu(arg0,arg1);
  
#line 157 
  return tmp;
}


#line 161  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
void ldv_emg_wrapper_e1000_netpoll_39(struct net_device *arg0)
{
  
#line 162 
  e1000_netpoll(arg0);
  
#line 163 
  return;
}


#line 166  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
void ldv_emg_wrapper_e1000_tx_timeout_22(struct net_device *arg0)
{
  
#line 167 
  e1000_tx_timeout(arg0);
  
#line 168 
  return;
}


#line 171  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
int ldv_emg_wrapper_e1000_set_mac_20(struct net_device *arg0, void *arg1)
{
  int tmp;
  
#line 172 
  tmp = e1000_set_mac(arg0,arg1);
  
#line 172 
  return tmp;
}


#line 590  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 593 
  tmp = ldv_kmalloc(size,flags);
  
#line 593 
  return tmp;
}


#line 604  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 607 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 607 
  return tmp;
}


#line 714  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_spin_lock_60(spinlock_t *lock)
{
  
#line 718 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  
#line 720 
  spin_lock(lock);
  
#line 721 
  return;
}


#line 757  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_spin_unlock_63(spinlock_t *lock)
{
  
#line 761 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  
#line 763 
  spin_unlock(lock);
  
#line 764 
  return;
}


#line 897  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static int ldv___pci_register_driver_77(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 901 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 901 
  return tmp;
}


#line 905  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_pci_unregister_driver_78(struct pci_driver *ldv_func_arg1)
{
  
#line 909 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 910 
  return;
}


#line 913  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static int ldv_request_irq_79(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 917 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 917 
  return tmp;
}


#line 921  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_free_irq_80(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 925 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 926 
  return;
}


#line 929  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_81(int ldv_func_arg1, unsigned int ldv_func_arg2, unsigned int ldv_func_arg3)
{
  struct net_device *tmp;
  
#line 933 
  tmp = ldv_emg_alloc_etherdev_mqs(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3);
  
#line 933 
  return tmp;
}


#line 937  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static int ldv_register_netdev_82(struct net_device *ldv_func_arg1)
{
  int tmp;
  
#line 941 
  tmp = ldv_emg_register_netdev(ldv_func_arg1);
  
#line 941 
  return tmp;
}


#line 945  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_free_netdev_83(struct net_device *ldv_func_arg1)
{
  
#line 949 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 950 
  return;
}


#line 953  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_unregister_netdev_84(struct net_device *ldv_func_arg1)
{
  
#line 957 
  ldv_emg_unregister_netdev(ldv_func_arg1);
  
#line 958 
  return;
}


#line 961  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_free_netdev_85(struct net_device *ldv_func_arg1)
{
  
#line 965 
  ldv_emg_free_netdev(ldv_func_arg1);
  
#line 966 
  return;
}


#line 969  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static bool ldv_schedule_delayed_work_86(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 973 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 973 
  __retres = tmp != 0;
  
#line 973 
  return __retres;
}


#line 977  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static bool ldv_schedule_delayed_work_87(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 981 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 981 
  __retres = tmp != 0;
  
#line 981 
  return __retres;
}


#line 985  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static bool ldv_schedule_delayed_work_88(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 989 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 989 
  __retres = tmp != 0;
  
#line 989 
  return __retres;
}


#line 993  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static bool ldv_schedule_work_89(struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 997 
  tmp = ldv_emg_schedule_work(work);
  
#line 997 
  __retres = tmp != 0;
  
#line 997 
  return __retres;
}


#line 1001  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static bool ldv_schedule_delayed_work_90(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1005 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 1005 
  __retres = tmp != 0;
  
#line 1005 
  return __retres;
}


#line 1009  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static bool ldv_schedule_delayed_work_91(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1013 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 1013 
  __retres = tmp != 0;
  
#line 1013 
  return __retres;
}


#line 1017  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static bool ldv_schedule_work_92(struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 1021 
  tmp = ldv_emg_schedule_work(work);
  
#line 1021 
  __retres = tmp != 0;
  
#line 1021 
  return __retres;
}


#line 1025  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv___ldv_spin_lock_93(spinlock_t *ldv_func_arg1)
{
  
#line 1029 
  ldv_spin_model_lock((char *)"stats_lock_of_e1000_adapter");
  
#line 1031 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1032 
  return;
}


#line 1035  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_spin_unlock_irqrestore_94(spinlock_t *lock, unsigned long flags)
{
  
#line 1039 
  ldv_spin_model_unlock((char *)"stats_lock_of_e1000_adapter");
  
#line 1041 
  spin_unlock_irqrestore(lock,flags);
  
#line 1042 
  return;
}


#line 1045  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static bool ldv_schedule_delayed_work_95(struct delayed_work *dwork, unsigned long delay)
{
  bool __retres;
  bool tmp;
  
#line 1049 
  tmp = ldv_emg_schedule_delayed_work(dwork,delay);
  
#line 1049 
  __retres = tmp != 0;
  
#line 1049 
  return __retres;
}


#line 1053  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv___ldv_spin_lock_96(spinlock_t *ldv_func_arg1)
{
  
#line 1057 
  ldv_spin_model_lock((char *)"stats_lock_of_e1000_adapter");
  
#line 1059 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1060 
  return;
}


#line 1063  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock, unsigned long flags)
{
  
#line 1067 
  ldv_spin_model_unlock((char *)"stats_lock_of_e1000_adapter");
  
#line 1069 
  spin_unlock_irqrestore(lock,flags);
  
#line 1070 
  return;
}


#line 1073  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv___ldv_spin_lock_98(spinlock_t *ldv_func_arg1)
{
  
#line 1077 
  ldv_spin_model_lock((char *)"stats_lock_of_e1000_adapter");
  
#line 1079 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1080 
  return;
}


#line 1083  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_spin_unlock_irqrestore_99(spinlock_t *lock, unsigned long flags)
{
  
#line 1087 
  ldv_spin_model_unlock((char *)"stats_lock_of_e1000_adapter");
  
#line 1089 
  spin_unlock_irqrestore(lock,flags);
  
#line 1090 
  return;
}


#line 1093  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_spin_unlock_irqrestore_100(spinlock_t *lock, unsigned long flags)
{
  
#line 1097 
  ldv_spin_model_unlock((char *)"stats_lock_of_e1000_adapter");
  
#line 1099 
  spin_unlock_irqrestore(lock,flags);
  
#line 1100 
  return;
}


#line 1103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv___ldv_spin_lock_101(spinlock_t *ldv_func_arg1)
{
  
#line 1107 
  ldv_spin_model_lock((char *)"stats_lock_of_e1000_adapter");
  
#line 1109 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1110 
  return;
}


#line 1113  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_spin_unlock_irqrestore_102(spinlock_t *lock, unsigned long flags)
{
  
#line 1117 
  ldv_spin_model_unlock((char *)"stats_lock_of_e1000_adapter");
  
#line 1119 
  spin_unlock_irqrestore(lock,flags);
  
#line 1120 
  return;
}


#line 1123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_main.c.aux"
static void ldv_spin_unlock_irqrestore_103(spinlock_t *lock, unsigned long flags)
{
  
#line 1127 
  ldv_spin_model_unlock((char *)"stats_lock_of_e1000_adapter");
  
#line 1129 
  spin_unlock_irqrestore(lock,flags);
  
#line 1130 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_fmt(char const *, int const, char const * , ...);


#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
size_t strlcpy(char *, char const *, size_t);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm_wakeup.h"
__inline static bool device_can_wakeup(struct device *dev)
{
  bool __retres;
  
#line 83 
  __retres = (_Bool)((int)dev->power.can_wakeup != 0);
  
#line 83 
  return __retres;
}


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_0(size_t size, gfp_t flags);


#line 542 
static void *kcalloc_0(size_t n, size_t size, gfp_t flags);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_sync_single_for_device(struct device *, dma_addr_t, size_t, int);


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 118 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 120 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 120 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 122 
    ldv_inline_asm();
    
#line 120 
    ;
  }
  else ;
  
#line 121 
  if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 122 
    (*(ops->sync_single_for_device))(dev,addr,size,dir); else ;
  
#line 123 
  debug_dma_sync_single_for_device(dev,addr,size,(int)dir);
  
#line 124 
  return;
}


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag)
{
  
#line 186 
  void *ret = dma_alloc_attrs(dev,size,dma_handle,flag | 32768U,(struct dma_attrs *)0);
  
#line 188 
  return ret;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
unsigned long msleep_interruptible(unsigned int);


#line 783  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff *__alloc_skb(unsigned int, gfp_t, int, int);


#line 787  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb(unsigned int size, gfp_t priority)
{
  struct sk_buff *tmp;
  
#line 790 
  tmp = __alloc_skb(size,priority,0,-1);
  
#line 790 
  return tmp;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep, __u32 speed)
{
  
#line 117 
  ep->speed = (unsigned short)speed;
  
#line 118 
  ep->speed_hi = (unsigned short)(speed >> 16);
  
#line 119 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd const *ep)
{
  __u32 __retres;
  
#line 123 
  __retres = (unsigned int)(((int)ep->speed_hi << 16) | (int)ep->speed);
  
#line 123 
  return __retres;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
int ethtool_op_get_ts_info(struct net_device *, struct ethtool_ts_info *);


#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_irq_77(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 145 
static int ldv_request_irq_78(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev);


#line 157 
static void ldv_free_irq_79(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 2182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
int dev_open(struct net_device *);


#line 2183 
int dev_close(struct net_device *);


#line 298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.h"
s32 e1000_setup_link(struct e1000_hw *hw);


#line 303 
s32 e1000_force_mac_fc(struct e1000_hw *hw);


#line 374 
s32 e1000_update_eeprom_checksum(struct e1000_hw *hw);


#line 375 
s32 e1000_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data);


#line 385 
s32 e1000_setup_led(struct e1000_hw *hw);


#line 386 
s32 e1000_cleanup_led(struct e1000_hw *hw);


#line 387 
s32 e1000_led_on(struct e1000_hw *hw);


#line 388 
s32 e1000_led_off(struct e1000_hw *hw);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static struct e1000_stats const e1000_gstrings_stats[46U] = {{.stat_string = {(char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1616}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1640}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1648}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1664}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1624}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1856}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1632}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1848}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1424}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1432}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'\000'}, .type = 0, .sizeof_stat = 8, .stat_offset = 352}, {.stat_string = {(char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1632}, {.stat_string = {(char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1480}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1712}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 0, .sizeof_stat = 8, .stat_offset = 384}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1400}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'r', (char)'a', (char)'m', (char)'e', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 0, .sizeof_stat = 8, .stat_offset = 400}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'n', (char)'o', (char)'_', (char)'b', (char)'u', (char)'f', (char)'f', (char)'e', (char)'r', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1680}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'i', (char)'s', (char)'s', (char)'e', (char)'d', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1440}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'a', (char)'b', (char)'o', (char)'r', (char)'t', (char)'e', (char)'d', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1456}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'c', (char)'a', (char)'r', (char)'r', (char)'i', (char)'e', (char)'r', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1496}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'i', (char)'f', (char)'o', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 0, .sizeof_stat = 8, .stat_offset = 440}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'h', (char)'e', (char)'a', (char)'r', (char)'t', (char)'b', (char)'e', (char)'a', (char)'t', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 0, .sizeof_stat = 8, .stat_offset = 448}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'w', (char)'i', (char)'n', (char)'d', (char)'o', (char)'w', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1472}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'a', (char)'b', (char)'o', (char)'r', (char)'t', (char)'_', (char)'l', (char)'a', (char)'t', (char)'e', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1472}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'e', (char)'f', (char)'e', (char)'r', (char)'r', (char)'e', (char)'d', (char)'_', (char)'o', (char)'k', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1488}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'n', (char)'g', (char)'l', (char)'e', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'_', (char)'o', (char)'k', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1448}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'_', (char)'c', (char)'o', (char)'l', (char)'l', (char)'_', (char)'o', (char)'k', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1464}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'o', (char)'u', (char)'t', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t', (char)'\000'}, .type = 1, .sizeof_stat = 4, .stat_offset = 704}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'r', (char)'e', (char)'s', (char)'t', (char)'a', (char)'r', (char)'t', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'\000'}, .type = 1, .sizeof_stat = 4, .stat_offset = 656}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'o', (char)'n', (char)'g', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1704}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'h', (char)'o', (char)'r', (char)'t', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1688}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'a', (char)'l', (char)'i', (char)'g', (char)'n', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1408}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'t', (char)'c', (char)'p', (char)'_', (char)'s', (char)'e', (char)'g', (char)'_', (char)'g', (char)'o', (char)'o', (char)'d', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1864}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'t', (char)'c', (char)'p', (char)'_', (char)'s', (char)'e', (char)'g', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l', (char)'e', (char)'d', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1872}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'_', (char)'x', (char)'o', (char)'n', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1528}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1544}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'_', (char)'x', (char)'o', (char)'n', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1536}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'l', (char)'o', (char)'w', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'r', (char)'o', (char)'l', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1552}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'o', (char)'n', (char)'g', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1648}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'s', (char)'u', (char)'m', (char)'_', (char)'o', (char)'f', (char)'f', (char)'l', (char)'o', (char)'a', (char)'d', (char)'_', (char)'g', (char)'o', (char)'o', (char)'d', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1056}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'s', (char)'u', (char)'m', (char)'_', (char)'o', (char)'f', (char)'f', (char)'l', (char)'o', (char)'a', (char)'d', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1048}, {.stat_string = {(char)'a', (char)'l', (char)'l', (char)'o', (char)'c', (char)'_', (char)'r', (char)'x', (char)'_', (char)'b', (char)'u', (char)'f', (char)'f', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l', (char)'e', (char)'d', (char)'\000'}, .type = 1, .sizeof_stat = 4, .stat_offset = 1064}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'s', (char)'m', (char)'b', (char)'u', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1744}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'s', (char)'m', (char)'b', (char)'u', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1728}, {.stat_string = {(char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'_', (char)'s', (char)'m', (char)'b', (char)'u', (char)'s', (char)'\000'}, .type = 1, .sizeof_stat = 8, .stat_offset = 1736}};

#line 98  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static char const e1000_gstrings_test[5U][32U] = {{(char)'R', (char)'e', (char)'g', (char)'i', (char)'s', (char)'t', (char)'e', (char)'r', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}, {(char)'E', (char)'e', (char)'p', (char)'r', (char)'o', (char)'m', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}, {(char)'I', (char)'n', (char)'t', (char)'e', (char)'r', (char)'r', (char)'u', (char)'p', (char)'t', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}, {(char)'L', (char)'o', (char)'o', (char)'p', (char)'b', (char)'a', (char)'c', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}, {(char)'L', (char)'i', (char)'n', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'n', (char)'/', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')', (char)'\000'}};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
{
  int __retres;
  unsigned int tmp_0;
  
#line 109 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 110 
  struct e1000_hw *hw = & adapter->hw;
  
#line 112 
  if (hw->media_type == (unsigned int)e1000_media_type_copper) {
    
#line 113 
    ecmd->supported = 239U;
    
#line 120 
    ecmd->advertising = 128U;
    
#line 122 
    if ((unsigned int)hw->autoneg == 1U) {
      
#line 123 
      ecmd->advertising |= 64U;
      
#line 125 
      ecmd->advertising |= (unsigned int)hw->autoneg_advertised;
    }
    else ;
    
#line 128 
    ecmd->port = (unsigned char)0U;
    
#line 129 
    ecmd->phy_address = (unsigned char)hw->phy_addr;
    
#line 131 
    if (hw->mac_type == (unsigned int)e1000_82543) 
#line 132 
                                                   ecmd->transceiver = (unsigned char)1U; else 
                                                                    
#line 134 
                                                                    ecmd->transceiver = (unsigned char)0U;
  }
  else {
    
#line 137 
    ecmd->supported = 1120U;
    
#line 141 
    ecmd->advertising = 1120U;
    
#line 145 
    ecmd->port = (unsigned char)3U;
    
#line 147 
    if (hw->mac_type > (unsigned int)e1000_82540) 
#line 148 
                                                  ecmd->transceiver = (unsigned char)0U; else 
                                                                    
#line 150 
                                                                    ecmd->transceiver = (unsigned char)1U;
  }
  
#line 153 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 153 
  if ((tmp_0 & 2U) != 0U) {
    
#line 154 
    e1000_get_speed_and_duplex(hw,& adapter->link_speed,& adapter->link_duplex);
    
#line 156 
    ethtool_cmd_speed_set(ecmd,(unsigned int)adapter->link_speed);
    
#line 161 
    if ((unsigned int)adapter->link_duplex == 2U) 
#line 162 
                                                  ecmd->duplex = (unsigned char)1U; else 
                                                                    
#line 164 
                                                                    ecmd->duplex = (unsigned char)0U;
  }
  else {
    
#line 166 
    ethtool_cmd_speed_set(ecmd,4294967295U);
    
#line 167 
    ecmd->duplex = (unsigned char)255U;
  }
  
#line 170 
  ecmd->autoneg = (unsigned char)((hw->media_type == (unsigned int)e1000_media_type_fiber || (unsigned int)hw->autoneg != 0U) != 0);
  
#line 174 
  if (hw->media_type == (unsigned int)e1000_media_type_copper) {
    bool tmp_1;
    
#line 174 
    tmp_1 = netif_carrier_ok((struct net_device const *)netdev);
    
#line 174 
    if ((int)tmp_1 != 0) 
      
#line 176 
      if (adapter->phy_info.mdix_mode != (unsigned int)0) 
#line 176 
                                                          ecmd->eth_tp_mdix = (unsigned char)2U; else 
                                                                    
#line 176 
                                                                    ecmd->eth_tp_mdix = (unsigned char)1U;
    else 
#line 179 
         ecmd->eth_tp_mdix = (unsigned char)0U;
  }
  else 
#line 179 
       ecmd->eth_tp_mdix = (unsigned char)0U;
  
#line 181 
  if ((unsigned int)hw->mdix == 0U) 
#line 182 
                                    ecmd->eth_tp_mdix_ctrl = (unsigned char)3U; else 
                                                                    
#line 184 
                                                                    ecmd->eth_tp_mdix_ctrl = hw->mdix;
  
#line 185 
  __retres = 0;
  
#line 185 
  return __retres;
}


#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_set_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
{
  int __retres;
  int tmp_0;
  bool tmp_3;
  
#line 191 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 192 
  struct e1000_hw *hw = & adapter->hw;
  
#line 198 
  if ((unsigned int)ecmd->eth_tp_mdix_ctrl != 0U) {
    
#line 199 
    if (hw->media_type != (unsigned int)e1000_media_type_copper) {
      
#line 200 
      __retres = -95;
      
#line 200 
      goto return_label;
    }
    else ;
    
#line 202 
    if ((unsigned int)ecmd->eth_tp_mdix_ctrl != 3U && (unsigned int)ecmd->autoneg != 1U) {
      
#line 204 
      if ((adapter->msg_enable & 1) != 0) 
#line 204 
                                          netdev_err((struct net_device const *)adapter->netdev,"forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n"); else ;
      
#line 205 
      __retres = -22;
      
#line 205 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 209 
  goto ldv_54479;
  ldv_54478: 
#line 210 
  ;
  
#line 210 
  msleep(1U);
  ldv_54479: 
#line 211 
  ;
  
#line 209 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 209 
  if (tmp_0 != 0) 
#line 211 
                  goto ldv_54478; else 
#line 214 
                                       goto ldv_54480;
  ldv_54480: 
#line 215 
  ;
  
#line 212 
  if ((unsigned int)ecmd->autoneg == 1U) {
    
#line 213 
    hw->autoneg = (unsigned char)1U;
    
#line 214 
    if (hw->media_type == (unsigned int)e1000_media_type_fiber) 
#line 215 
                                                                hw->autoneg_advertised = (unsigned short)1120U; else 
                                                                    
#line 219 
                                                                    hw->autoneg_advertised = (unsigned short)((unsigned int)((unsigned short)ecmd->advertising) | 192U);
    
#line 222 
    ecmd->advertising = (unsigned int)hw->autoneg_advertised;
  }
  else {
    int tmp_2;
    
#line 224 
    u32 speed = ethtool_cmd_speed((struct ethtool_cmd const *)ecmd);
    
#line 226 
    tmp_2 = e1000_set_spd_dplx(adapter,speed,(unsigned char)((int)ecmd->duplex));
    
#line 226 
    if (tmp_2 != 0) {
      
#line 227 
      set_bit(1L,(unsigned long volatile *)(& adapter->flags));
      
#line 228 
      __retres = -22;
      
#line 228 
      goto return_label;
    }
    else ;
  }
  
#line 233 
  if ((unsigned int)ecmd->eth_tp_mdix_ctrl != 0U) 
    
#line 234 
    if ((unsigned int)ecmd->eth_tp_mdix_ctrl == 3U) 
#line 235 
                                                    hw->mdix = (unsigned char)0U; else 
                                                                    
#line 237 
                                                                    hw->mdix = ecmd->eth_tp_mdix_ctrl;
  else ;
  
#line 242 
  tmp_3 = netif_running((struct net_device const *)adapter->netdev);
  
#line 242 
  if ((int)tmp_3 != 0) {
    
#line 243 
    e1000_down(adapter);
    
#line 244 
    e1000_up(adapter);
  }
  else 
#line 246 
       e1000_reset(adapter);
  
#line 248 
  set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 249 
  __retres = 0;
  return_label: 
#line 249 
                return __retres;
}


#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static u32 e1000_get_link(struct net_device *netdev)
{
  u32 __retres;
  int tmp_1;
  bool tmp_0;
  bool tmp_2;
  
#line 254 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 262 
  tmp_0 = netif_carrier_ok((struct net_device const *)netdev);
  
#line 262 
  if (tmp_0) 
#line 262 
             tmp_1 = 0; else 
#line 262 
                             tmp_1 = 1;
  
#line 262 
  if (tmp_1) 
#line 263 
             adapter->hw.get_link_status = (_Bool)1; else ;
  
#line 265 
  tmp_2 = e1000_has_link(adapter);
  
#line 265 
  __retres = (unsigned int)tmp_2;
  
#line 265 
  return __retres;
}


#line 268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  
#line 271 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 272 
  struct e1000_hw *hw = & adapter->hw;
  
#line 274 
  pause->autoneg = (unsigned int)((unsigned int)adapter->fc_autoneg != 0U);
  
#line 277 
  if (hw->fc == (unsigned int)E1000_FC_RX_PAUSE) 
#line 278 
                                                 pause->rx_pause = 1U;
  else 
    
#line 279 
    if (hw->fc == (unsigned int)E1000_FC_TX_PAUSE) 
#line 280 
                                                   pause->tx_pause = 1U;
    else 
      
#line 281 
      if (hw->fc == (unsigned int)E1000_FC_FULL) {
        
#line 282 
        pause->rx_pause = 1U;
        
#line 283 
        pause->tx_pause = 1U;
      }
      else ;
  
#line 285 
  return;
}


#line 287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  int tmp_0;
  
#line 290 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 291 
  struct e1000_hw *hw = & adapter->hw;
  
#line 292 
  int retval = 0;
  
#line 294 
  adapter->fc_autoneg = (unsigned char)pause->autoneg;
  
#line 296 
  goto ldv_54500;
  ldv_54499: 
#line 297 
  ;
  
#line 297 
  msleep(1U);
  ldv_54500: 
#line 298 
  ;
  
#line 296 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 296 
  if (tmp_0 != 0) 
#line 298 
                  goto ldv_54499; else 
#line 301 
                                       goto ldv_54501;
  ldv_54501: 
#line 302 
  ;
  
#line 299 
  if (pause->rx_pause != 0U && pause->tx_pause != 0U) 
#line 300 
                                                      hw->fc = E1000_FC_FULL;
  else 
    
#line 301 
    if (pause->rx_pause != 0U && pause->tx_pause == 0U) 
#line 302 
                                                        hw->fc = E1000_FC_RX_PAUSE;
    else 
      
#line 303 
      if (pause->rx_pause == 0U && pause->tx_pause != 0U) 
#line 304 
                                                          hw->fc = E1000_FC_TX_PAUSE;
      else 
        
#line 305 
        if (pause->rx_pause == 0U && pause->tx_pause == 0U) 
#line 306 
                                                            hw->fc = E1000_FC_NONE; else ;
  
#line 308 
  hw->original_fc = (unsigned int)hw->fc;
  
#line 310 
  if ((unsigned int)adapter->fc_autoneg == 1U) {
    bool tmp_1;
    
#line 311 
    tmp_1 = netif_running((struct net_device const *)adapter->netdev);
    
#line 311 
    if ((int)tmp_1 != 0) {
      
#line 312 
      e1000_down(adapter);
      
#line 313 
      e1000_up(adapter);
    }
    else 
#line 315 
         e1000_reset(adapter);
  }
  else 
    
#line 318 
    if (hw->media_type == (unsigned int)e1000_media_type_fiber) 
#line 318 
                                                                retval = e1000_setup_link(hw); else 
                                                                    
#line 319 
                                                                    retval = e1000_force_mac_fc(hw);
  
#line 321 
  set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 322 
  return retval;
}


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static u32 e1000_get_msglevel(struct net_device *netdev)
{
  u32 __retres;
  
#line 327 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 329 
  __retres = (unsigned int)adapter->msg_enable;
  
#line 329 
  return __retres;
}


#line 332  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_set_msglevel(struct net_device *netdev, u32 data)
{
  
#line 334 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 336 
  adapter->msg_enable = (int)data;
  
#line 337 
  return;
}


#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_get_regs_len(struct net_device *netdev)
{
  int __retres;
  
#line 342 
  __retres = 128;
  
#line 342 
  return __retres;
}


#line 345  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_get_regs(struct net_device *netdev, struct ethtool_regs *regs, void *p)
{
  u16 phy_data;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  
#line 348 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 349 
  struct e1000_hw *hw = & adapter->hw;
  
#line 350 
  u32 *regs_buff = (u32 *)p;
  
#line 353 
  memset(p,0,128UL);
  
#line 355 
  regs->version = (unsigned int)((((int)hw->revision_id << 16) | 16777216) | (int)hw->device_id);
  
#line 357 
  *regs_buff = readl((void const volatile *)hw->hw_addr);
  
#line 358 
  *(regs_buff + 1U) = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 360 
  *(regs_buff + 2U) = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 361 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 361 
                                                       tmp_0 = 10248; else 
                                                                    
#line 361 
                                                                    tmp_0 = 280;
  
#line 361 
  ;
  
#line 361 
  *(regs_buff + 3U) = readl((void const volatile *)(hw->hw_addr + tmp_0));
  
#line 362 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 362 
                                                       tmp_1 = 10256; else 
                                                                    
#line 362 
                                                                    tmp_1 = 288;
  
#line 362 
  ;
  
#line 362 
  *(regs_buff + 4U) = readl((void const volatile *)(hw->hw_addr + tmp_1));
  
#line 363 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 363 
                                                       tmp_2 = 10264; else 
                                                                    
#line 363 
                                                                    tmp_2 = 296;
  
#line 363 
  ;
  
#line 363 
  *(regs_buff + 5U) = readl((void const volatile *)(hw->hw_addr + tmp_2));
  
#line 364 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 364 
                                                       tmp_3 = 10272; else 
                                                                    
#line 364 
                                                                    tmp_3 = 264;
  
#line 364 
  ;
  
#line 364 
  *(regs_buff + 6U) = readl((void const volatile *)(hw->hw_addr + tmp_3));
  
#line 366 
  *(regs_buff + 7U) = readl((void const volatile *)(hw->hw_addr + 1024U));
  
#line 367 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 367 
                                                       tmp_4 = 14344; else 
                                                                    
#line 367 
                                                                    tmp_4 = 1064;
  
#line 367 
  ;
  
#line 367 
  *(regs_buff + 8U) = readl((void const volatile *)(hw->hw_addr + tmp_4));
  
#line 368 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 368 
                                                       tmp_5 = 14352; else 
                                                                    
#line 368 
                                                                    tmp_5 = 1072;
  
#line 368 
  ;
  
#line 368 
  *(regs_buff + 9U) = readl((void const volatile *)(hw->hw_addr + tmp_5));
  
#line 369 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 369 
                                                       tmp_6 = 14360; else 
                                                                    
#line 369 
                                                                    tmp_6 = 1080;
  
#line 369 
  ;
  
#line 369 
  *(regs_buff + 10U) = readl((void const volatile *)(hw->hw_addr + tmp_6));
  
#line 370 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 370 
                                                       tmp_7 = 14368; else 
                                                                    
#line 370 
                                                                    tmp_7 = 1088;
  
#line 370 
  ;
  
#line 370 
  *(regs_buff + 11U) = readl((void const volatile *)(hw->hw_addr + tmp_7));
  
#line 372 
  *(regs_buff + 12U) = (unsigned int)hw->phy_type;
  
#line 373 
  if (hw->phy_type == (unsigned int)1) {
    
#line 374 
    e1000_write_phy_reg(hw,31U,(unsigned short)4466);
    
#line 376 
    e1000_read_phy_reg(hw,18U,& phy_data);
    
#line 378 
    *(regs_buff + 13U) = (unsigned int)phy_data;
    
#line 379 
    e1000_write_phy_reg(hw,31U,(unsigned short)4722);
    
#line 381 
    e1000_read_phy_reg(hw,18U,& phy_data);
    
#line 383 
    *(regs_buff + 14U) = (unsigned int)phy_data;
    
#line 384 
    e1000_write_phy_reg(hw,31U,(unsigned short)5234);
    
#line 386 
    e1000_read_phy_reg(hw,18U,& phy_data);
    
#line 388 
    *(regs_buff + 15U) = (unsigned int)phy_data;
    
#line 389 
    e1000_write_phy_reg(hw,31U,(unsigned short)6258);
    
#line 391 
    e1000_read_phy_reg(hw,18U,& phy_data);
    
#line 393 
    *(regs_buff + 16U) = (unsigned int)phy_data;
    
#line 394 
    *(regs_buff + 17U) = 0U;
    
#line 395 
    e1000_write_phy_reg(hw,31U,(unsigned short)0);
    
#line 396 
    e1000_read_phy_reg(hw,17U,& phy_data);
    
#line 398 
    *(regs_buff + 18U) = (unsigned int)phy_data;
    
#line 399 
    e1000_write_phy_reg(hw,31U,(unsigned short)180);
    
#line 401 
    e1000_read_phy_reg(hw,20U,& phy_data);
    
#line 403 
    *(regs_buff + 19U) = (unsigned int)phy_data;
    
#line 404 
    *(regs_buff + 20U) = 0U;
    
#line 405 
    *(regs_buff + 22U) = 0U;
    
#line 406 
    *(regs_buff + 23U) = *(regs_buff + 18U);
    
#line 407 
    e1000_write_phy_reg(hw,31U,(unsigned short)0);
  }
  else {
    
#line 409 
    e1000_read_phy_reg(hw,17U,& phy_data);
    
#line 410 
    *(regs_buff + 13U) = (unsigned int)phy_data;
    
#line 411 
    *(regs_buff + 14U) = 0U;
    
#line 412 
    *(regs_buff + 15U) = 0U;
    
#line 413 
    *(regs_buff + 16U) = 0U;
    
#line 414 
    e1000_read_phy_reg(hw,16U,& phy_data);
    
#line 415 
    *(regs_buff + 17U) = (unsigned int)phy_data;
    
#line 416 
    *(regs_buff + 18U) = *(regs_buff + 13U);
    
#line 417 
    *(regs_buff + 19U) = 0U;
    
#line 418 
    *(regs_buff + 20U) = *(regs_buff + 17U);
    
#line 420 
    *(regs_buff + 22U) = adapter->phy_stats.receive_errors;
    
#line 421 
    *(regs_buff + 23U) = *(regs_buff + 13U);
  }
  
#line 423 
  *(regs_buff + 21U) = adapter->phy_stats.idle_errors;
  
#line 424 
  e1000_read_phy_reg(hw,10U,& phy_data);
  
#line 425 
  *(regs_buff + 24U) = (unsigned int)phy_data;
  
#line 426 
  *(regs_buff + 25U) = *(regs_buff + 24U);
  
#line 427 
  if (hw->mac_type > (unsigned int)e1000_82544 && hw->media_type == (unsigned int)e1000_media_type_copper) 
    
#line 429 
    *(regs_buff + 26U) = readl((void const volatile *)(hw->hw_addr + 22560U)); else ;
  
#line 430 
  return;
}


#line 433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_get_eeprom_len(struct net_device *netdev)
{
  int __retres;
  
#line 435 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 436 
  struct e1000_hw *hw = & adapter->hw;
  
#line 438 
  __retres = (int)hw->eeprom.word_size * 2;
  
#line 438 
  return __retres;
}


#line 441  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  int __retres;
  u16 *eeprom_buff;
  int first_word;
  int last_word;
  u16 i;
  
#line 444 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 445 
  struct e1000_hw *hw = & adapter->hw;
  
#line 448 
  int ret_val = 0;
  
#line 451 
  if (eeprom->len == 0U) {
    
#line 452 
    __retres = -22;
    
#line 452 
    goto return_label;
  }
  else ;
  
#line 454 
  eeprom->magic = (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16));
  
#line 456 
  first_word = (int)(eeprom->offset >> 1);
  
#line 457 
  last_word = (int)(((eeprom->offset + eeprom->len) + 4294967295U) >> 1);
  
#line 459 
  eeprom_buff = (u16 *)kmalloc_0((unsigned long)((last_word - first_word) + 1) * 2UL,208U);
  
#line 461 
  if (eeprom_buff == (u16 *)0U) {
    
#line 462 
    __retres = -12;
    
#line 462 
    goto return_label;
  }
  else ;
  
#line 464 
  if (hw->eeprom.type == (unsigned int)e1000_eeprom_spi) 
#line 465 
                                                         ret_val = e1000_read_eeprom(hw,(unsigned short)((int)((unsigned short)first_word)),(unsigned short)((int)((unsigned int)((int)((unsigned short)last_word) - (int)((unsigned short)first_word)) + 1U)),eeprom_buff);
  else {
    
#line 469 
    i = (unsigned short)0U;
    
#line 469 
    goto ldv_54542;
    ldv_54541: 
#line 470 
    ;
    
#line 470 
    ret_val = e1000_read_eeprom(hw,(unsigned short)((int)((unsigned short)first_word) + (int)i),(unsigned short)1,eeprom_buff + (int)i);
    
#line 472 
    if (ret_val != 0) 
#line 473 
                      goto ldv_54540; else ;
    
#line 469 
    i = (u16)((int)i + 1);
    ldv_54542: 
#line 470 
    ;
    
#line 469 
    if ((int)i < (last_word - first_word) + 1) 
#line 471 
                                               goto ldv_54541; else 
#line 474 
                                                                    goto ldv_54540;
    ldv_54540: 
#line 475 
    ;
  }
  
#line 478 
  i = (unsigned short)0U;
  
#line 478 
  goto ldv_54544;
  ldv_54543: 
#line 479 
  ;
  
#line 479 
  u16 *tmp_2 = eeprom_buff + (int)i;
  
#line 478 
  i = (u16)((int)i + 1);
  ldv_54544: 
#line 479 
  ;
  
#line 478 
  if ((int)i < (last_word - first_word) + 1) 
#line 480 
                                             goto ldv_54543; else 
#line 483 
                                                                  goto ldv_54545;
  ldv_54545: 
#line 484 
  ;
  
#line 481 
  memcpy((void *)bytes,(void const *)eeprom_buff + (eeprom->offset & 1U),(unsigned long)eeprom->len);
  
#line 483 
  kfree((void const *)eeprom_buff);
  
#line 485 
  __retres = ret_val;
  return_label: 
#line 485 
                return __retres;
}


#line 488  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_set_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  int __retres;
  u16 *eeprom_buff;
  void *ptr;
  int max_len;
  int first_word;
  int last_word;
  u16 i;
  
#line 491 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 492 
  struct e1000_hw *hw = & adapter->hw;
  
#line 495 
  int ret_val = 0;
  
#line 498 
  if (eeprom->len == 0U) {
    
#line 499 
    __retres = -95;
    
#line 499 
    goto return_label;
  }
  else ;
  
#line 501 
  if (eeprom->magic != (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16))) {
    
#line 502 
    __retres = -14;
    
#line 502 
    goto return_label;
  }
  else ;
  
#line 504 
  max_len = (int)hw->eeprom.word_size * 2;
  
#line 506 
  first_word = (int)(eeprom->offset >> 1);
  
#line 507 
  last_word = (int)(((eeprom->offset + eeprom->len) + 4294967295U) >> 1);
  
#line 508 
  eeprom_buff = (u16 *)kmalloc_0((unsigned long)max_len,208U);
  
#line 509 
  if (eeprom_buff == (u16 *)0U) {
    
#line 510 
    __retres = -12;
    
#line 510 
    goto return_label;
  }
  else ;
  
#line 512 
  ptr = (void *)eeprom_buff;
  
#line 514 
  if ((eeprom->offset & 1U) != 0U) {
    
#line 518 
    ret_val = e1000_read_eeprom(hw,(unsigned short)((int)((unsigned short)first_word)),(unsigned short)1,eeprom_buff);
    
#line 520 
    ptr += 1;
  }
  else ;
  
#line 522 
  if (((eeprom->offset + eeprom->len) & 1U) != 0U && ret_val == 0) 
#line 526 
                                                                   ret_val = e1000_read_eeprom(hw,(unsigned short)((int)((unsigned short)last_word)),(unsigned short)1,eeprom_buff + (last_word - first_word)); else ;
  
#line 531 
  i = (unsigned short)0U;
  
#line 531 
  goto ldv_54561;
  ldv_54560: 
#line 532 
  ;
  
#line 532 
  u16 *tmp_2 = eeprom_buff + (int)i;
  
#line 531 
  i = (u16)((int)i + 1);
  ldv_54561: 
#line 532 
  ;
  
#line 531 
  if ((int)i < (last_word - first_word) + 1) 
#line 533 
                                             goto ldv_54560; else 
#line 536 
                                                                  goto ldv_54562;
  ldv_54562: 
#line 537 
  ;
  
#line 534 
  memcpy(ptr,(void const *)bytes,(unsigned long)eeprom->len);
  
#line 536 
  i = (unsigned short)0U;
  
#line 536 
  goto ldv_54564;
  ldv_54563: 
#line 537 
  ;
  
#line 537 
  *(eeprom_buff + (int)i) = *(eeprom_buff + (int)i);
  
#line 536 
  i = (u16)((int)i + 1);
  ldv_54564: 
#line 537 
  ;
  
#line 536 
  if ((int)i < (last_word - first_word) + 1) 
#line 538 
                                             goto ldv_54563; else 
#line 541 
                                                                  goto ldv_54565;
  ldv_54565: 
#line 542 
  ;
  
#line 539 
  ret_val = e1000_write_eeprom(hw,(unsigned short)((int)((unsigned short)first_word)),(unsigned short)((int)((unsigned int)((int)((unsigned short)last_word) - (int)((unsigned short)first_word)) + 1U)),eeprom_buff);
  
#line 543 
  if (ret_val == 0 && first_word <= 63) 
#line 544 
                                        e1000_update_eeprom_checksum(hw); else ;
  
#line 546 
  kfree((void const *)eeprom_buff);
  
#line 547 
  __retres = ret_val;
  return_label: 
#line 547 
                return __retres;
}


#line 550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
{
  char const *tmp_0;
  int tmp_1;
  int tmp_2;
  
#line 553 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 555 
  strlcpy((char *)(& drvinfo->driver),(char const *)(& e1000_driver_name),32UL);
  
#line 557 
  strlcpy((char *)(& drvinfo->version),(char const *)(& e1000_driver_version),32UL);
  
#line 560 
  tmp_0 = pci_name((struct pci_dev const *)adapter->pdev);
  
#line 560 
  ;
  
#line 560 
  strlcpy((char *)(& drvinfo->bus_info),tmp_0,32UL);
  
#line 562 
  tmp_1 = e1000_get_regs_len(netdev);
  
#line 562 
  drvinfo->regdump_len = (unsigned int)tmp_1;
  
#line 563 
  tmp_2 = e1000_get_eeprom_len(netdev);
  
#line 563 
  drvinfo->eedump_len = (unsigned int)tmp_2;
  
#line 564 
  return;
}


#line 566  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_get_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  int tmp_0;
  int tmp_1;
  
#line 569 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 570 
  struct e1000_hw *hw = & adapter->hw;
  
#line 571 
  e1000_mac_type mac_type = hw->mac_type;
  
#line 572 
  struct e1000_tx_ring *txdr = adapter->tx_ring;
  
#line 573 
  struct e1000_rx_ring *rxdr = adapter->rx_ring;
  
#line 575 
  if (mac_type <= (unsigned int)e1000_82543) 
#line 575 
                                             tmp_0 = 256; else 
#line 575 
                                                               tmp_0 = 4096;
  
#line 575 
  ring->rx_max_pending = (unsigned int)tmp_0;
  
#line 577 
  if (mac_type <= (unsigned int)e1000_82543) 
#line 577 
                                             tmp_1 = 256; else 
#line 577 
                                                               tmp_1 = 4096;
  
#line 577 
  ring->tx_max_pending = (unsigned int)tmp_1;
  
#line 579 
  ring->rx_pending = rxdr->count;
  
#line 580 
  ring->tx_pending = txdr->count;
  
#line 581 
  return;
}


#line 583  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_set_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  int __retres;
  struct e1000_tx_ring *txdr;
  struct e1000_tx_ring *tx_old;
  struct e1000_rx_ring *rxdr;
  struct e1000_rx_ring *rx_old;
  int i;
  int err;
  int tmp_0;
  bool tmp_1;
  unsigned int tmp_5;
  unsigned int tmp_8;
  unsigned int tmp_10;
  unsigned int tmp_13;
  bool tmp_14;
  
#line 586 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 587 
  struct e1000_hw *hw = & adapter->hw;
  
#line 588 
  e1000_mac_type mac_type = hw->mac_type;
  
#line 593 
  if (ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) {
    
#line 594 
    __retres = -22;
    
#line 594 
    goto return_label;
  }
  else ;
  
#line 596 
  goto ldv_54594;
  ldv_54593: 
#line 597 
  ;
  
#line 597 
  msleep(1U);
  ldv_54594: 
#line 598 
  ;
  
#line 596 
  tmp_0 = test_and_set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 596 
  if (tmp_0 != 0) 
#line 598 
                  goto ldv_54593; else 
#line 601 
                                       goto ldv_54595;
  ldv_54595: 
#line 602 
  ;
  
#line 599 
  tmp_1 = netif_running((struct net_device const *)adapter->netdev);
  
#line 599 
  if ((int)tmp_1 != 0) 
#line 600 
                       e1000_down(adapter); else ;
  
#line 602 
  tx_old = adapter->tx_ring;
  
#line 603 
  rx_old = adapter->rx_ring;
  
#line 605 
  err = -12;
  
#line 606 
  txdr = (struct e1000_tx_ring *)kcalloc_0((unsigned long)adapter->num_tx_queues,48UL,208U);
  
#line 608 
  if (txdr == (struct e1000_tx_ring *)0) 
#line 609 
                                         goto err_alloc_tx; else ;
  
#line 611 
  rxdr = (struct e1000_rx_ring *)kcalloc_0((unsigned long)adapter->num_rx_queues,56UL,208U);
  
#line 613 
  if (rxdr == (struct e1000_rx_ring *)0) 
#line 614 
                                         goto err_alloc_rx; else ;
  
#line 616 
  adapter->tx_ring = txdr;
  
#line 617 
  adapter->rx_ring = rxdr;
  {
    __u32 tmp_4;
    
#line 619 
    __u32 _max1 = ring->rx_pending;
    
#line 619 
    unsigned int _max2 = 48U;
    
#line 619 
    if (_max1 > _max2) 
#line 619 
                       tmp_4 = _max1; else 
#line 619 
                                           tmp_4 = _max2;
    
#line 619 
    tmp_5 = tmp_4;
  }
  
#line 619 
  rxdr->count = tmp_5;
  {
    int tmp_6;
    unsigned int tmp_7;
    
#line 620 
    unsigned int _min1 = rxdr->count;
    
#line 620 
    if (mac_type <= (unsigned int)e1000_82543) 
#line 620 
                                               tmp_6 = 256; else 
#line 620 
                                                                 tmp_6 = 4096;
    
#line 620 
    unsigned int _min2 = (unsigned int)tmp_6;
    
#line 620 
    if (_min1 < _min2) 
#line 620 
                       tmp_7 = _min1; else 
#line 620 
                                           tmp_7 = _min2;
    
#line 620 
    tmp_8 = tmp_7;
  }
  
#line 620 
  rxdr->count = tmp_8;
  
#line 622 
  rxdr->count = (rxdr->count + 7U) & 4294967288U;
  {
    __u32 tmp_9;
    
#line 623 
    __u32 _max1_0 = ring->tx_pending;
    
#line 623 
    unsigned int _max2_0 = 48U;
    
#line 623 
    if (_max1_0 > _max2_0) 
#line 623 
                           tmp_9 = _max1_0; else 
#line 623 
                                                 tmp_9 = _max2_0;
    
#line 623 
    tmp_10 = tmp_9;
  }
  
#line 623 
  txdr->count = tmp_10;
  {
    int tmp_11;
    unsigned int tmp_12;
    
#line 624 
    unsigned int _min1_0 = txdr->count;
    
#line 624 
    if (mac_type <= (unsigned int)e1000_82543) 
#line 624 
                                               tmp_11 = 256; else 
#line 624 
                                                                  tmp_11 = 4096;
    
#line 624 
    unsigned int _min2_0 = (unsigned int)tmp_11;
    
#line 624 
    if (_min1_0 < _min2_0) 
#line 624 
                           tmp_12 = _min1_0; else 
#line 624 
                                                  tmp_12 = _min2_0;
    
#line 624 
    tmp_13 = tmp_12;
  }
  
#line 624 
  txdr->count = tmp_13;
  
#line 626 
  txdr->count = (txdr->count + 7U) & 4294967288U;
  
#line 628 
  i = 0;
  
#line 628 
  goto ldv_54611;
  ldv_54610: 
#line 629 
  ;
  
#line 629 
  (txdr + i)->count = txdr->count;
  
#line 628 
  i += 1;
  ldv_54611: 
#line 629 
  ;
  
#line 628 
  if (adapter->num_tx_queues > i) 
#line 630 
                                  goto ldv_54610; else 
#line 633 
                                                       goto ldv_54612;
  ldv_54612: 
#line 634 
  ;
  
#line 630 
  i = 0;
  
#line 630 
  goto ldv_54614;
  ldv_54613: 
#line 631 
  ;
  
#line 631 
  (rxdr + i)->count = rxdr->count;
  
#line 630 
  i += 1;
  ldv_54614: 
#line 631 
  ;
  
#line 630 
  if (adapter->num_rx_queues > i) 
#line 632 
                                  goto ldv_54613; else 
#line 635 
                                                       goto ldv_54615;
  ldv_54615: 
#line 636 
  ;
  
#line 633 
  tmp_14 = netif_running((struct net_device const *)adapter->netdev);
  
#line 633 
  if ((int)tmp_14 != 0) {
    
#line 635 
    err = e1000_setup_all_rx_resources(adapter);
    
#line 636 
    if (err != 0) 
#line 637 
                  goto err_setup_rx; else ;
    
#line 638 
    err = e1000_setup_all_tx_resources(adapter);
    
#line 639 
    if (err != 0) 
#line 640 
                  goto err_setup_tx; else ;
    
#line 646 
    adapter->rx_ring = rx_old;
    
#line 647 
    adapter->tx_ring = tx_old;
    
#line 648 
    e1000_free_all_rx_resources(adapter);
    
#line 649 
    e1000_free_all_tx_resources(adapter);
    
#line 650 
    kfree((void const *)tx_old);
    
#line 651 
    kfree((void const *)rx_old);
    
#line 652 
    adapter->rx_ring = rxdr;
    
#line 653 
    adapter->tx_ring = txdr;
    
#line 654 
    err = e1000_up(adapter);
    
#line 655 
    if (err != 0) 
#line 656 
                  goto err_setup; else ;
  }
  else ;
  
#line 659 
  set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 660 
  __retres = 0;
  
#line 660 
  goto return_label;
  err_setup_tx: 
#line 661 
  ;
  
#line 662 
  e1000_free_all_rx_resources(adapter);
  err_setup_rx: 
#line 663 
  ;
  
#line 664 
  adapter->rx_ring = rx_old;
  
#line 665 
  adapter->tx_ring = tx_old;
  
#line 666 
  kfree((void const *)rxdr);
  err_alloc_rx: 
#line 667 
  ;
  
#line 668 
  kfree((void const *)txdr);
  err_alloc_tx: 
#line 669 
  ;
  
#line 670 
  e1000_up(adapter);
  err_setup: 
#line 671 
  ;
  
#line 672 
  set_bit(1L,(unsigned long volatile *)(& adapter->flags));
  
#line 673 
  __retres = err;
  return_label: 
#line 673 
                return __retres;
}


#line 676  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static bool reg_pattern_test(struct e1000_adapter *adapter, u64 *data, int reg, u32 mask, u32 write)
{
  bool __retres;
  u32 read;
  int i;
  
#line 679 
  struct e1000_hw *hw = & adapter->hw;
  
#line 680 
  u32 const test[4U] = {1515870810U, 2779096485U, 0U, 4294967295U};
  
#line 683 
  u8 *address = hw->hw_addr + reg;
  
#line 687 
  i = 0;
  
#line 687 
  goto ldv_54635;
  ldv_54634: 
#line 688 
  ;
  
#line 688 
  writel(test[i] & write,(void volatile *)address);
  
#line 689 
  read = readl((void const volatile *)address);
  
#line 690 
  if (((test[i] & write) & mask) != read) {
    
#line 691 
    if ((adapter->msg_enable & 1) != 0) 
#line 691 
                                        netdev_err((struct net_device const *)adapter->netdev,"pattern test reg %04X failed: ",reg,read,(test[i] & write) & mask); else ;
    
#line 694 
    *data = (unsigned long long)reg;
    
#line 695 
    __retres = (_Bool)1;
    
#line 695 
    goto return_label;
  }
  else ;
  
#line 687 
  i += 1;
  ldv_54635: 
#line 688 
  ;
  
#line 687 
  if ((unsigned int)i <= 3U) 
#line 689 
                             goto ldv_54634; else 
#line 692 
                                                  goto ldv_54636;
  ldv_54636: 
#line 693 
  ;
  
#line 698 
  __retres = (_Bool)0;
  return_label: 
#line 698 
                return __retres;
}


#line 701  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static bool reg_set_and_check(struct e1000_adapter *adapter, u64 *data, int reg, u32 mask, u32 write)
{
  bool __retres;
  u32 read;
  
#line 704 
  struct e1000_hw *hw = & adapter->hw;
  
#line 705 
  u8 *address = hw->hw_addr + reg;
  
#line 708 
  writel(write & mask,(void volatile *)address);
  
#line 709 
  read = readl((void const volatile *)address);
  
#line 710 
  if (((read ^ write) & mask) != 0U) {
    
#line 711 
    if ((adapter->msg_enable & 1) != 0) 
#line 711 
                                        netdev_err((struct net_device const *)adapter->netdev,"set/check reg %04X test failed: ",reg,read & mask,write & mask); else ;
    
#line 714 
    *data = (unsigned long long)reg;
    
#line 715 
    __retres = (_Bool)1;
    
#line 715 
    goto return_label;
  }
  else ;
  
#line 717 
  __retres = (_Bool)0;
  return_label: 
#line 717 
                return __retres;
}


#line 738  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_reg_test(struct e1000_adapter *adapter, u64 *data)
{
  int __retres;
  u32 value;
  u32 before;
  u32 after;
  u32 i;
  u32 toggle;
  unsigned int tmp;
  unsigned int tmp_0;
  bool tmp_1;
  bool tmp_2;
  bool tmp_3;
  bool tmp_4;
  bool tmp_6;
  int tmp_5;
  bool tmp_8;
  int tmp_7;
  bool tmp_10;
  int tmp_9;
  bool tmp_12;
  int tmp_11;
  bool tmp_14;
  int tmp_13;
  bool tmp_16;
  int tmp_15;
  bool tmp_17;
  bool tmp_18;
  bool tmp_20;
  int tmp_19;
  bool tmp_22;
  int tmp_21;
  bool tmp_23;
  bool tmp_24;
  bool tmp_25;
  bool tmp_43;
  u32 tmp_42;
  
#line 742 
  struct e1000_hw *hw = & adapter->hw;
  
#line 749 
  toggle = 4294965299U;
  
#line 751 
  before = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 752 
  tmp = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 752 
  value = tmp & toggle;
  
#line 753 
  writel(toggle,(void volatile *)(hw->hw_addr + 8U));
  
#line 754 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 754 
  after = tmp_0 & toggle;
  
#line 755 
  if (value != after) {
    
#line 756 
    if ((adapter->msg_enable & 1) != 0) 
#line 756 
                                        netdev_err((struct net_device const *)adapter->netdev,"failed STATUS register test got: ",after,value); else ;
    
#line 758 
    *data = 1ULL;
    
#line 759 
    __retres = 1;
    
#line 759 
    goto return_label;
  }
  else ;
  
#line 762 
  writel(before,(void volatile *)(hw->hw_addr + 8U));
  
#line 764 
  tmp_1 = reg_pattern_test(adapter,data,40,4294967295U,4294967295U);
  
#line 764 
  if ((int)tmp_1 != 0) {
    
#line 764 
    __retres = 1;
    
#line 764 
    goto return_label;
  }
  else ;
  
#line 765 
  tmp_2 = reg_pattern_test(adapter,data,44,65535U,4294967295U);
  
#line 765 
  if ((int)tmp_2 != 0) {
    
#line 765 
    __retres = 1;
    
#line 765 
    goto return_label;
  }
  else ;
  
#line 766 
  tmp_3 = reg_pattern_test(adapter,data,48,65535U,4294967295U);
  
#line 766 
  if ((int)tmp_3 != 0) {
    
#line 766 
    __retres = 1;
    
#line 766 
    goto return_label;
  }
  else ;
  
#line 767 
  tmp_4 = reg_pattern_test(adapter,data,56,65535U,4294967295U);
  
#line 767 
  if ((int)tmp_4 != 0) {
    
#line 767 
    __retres = 1;
    
#line 767 
    goto return_label;
  }
  else ;
  
#line 769 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 769 
                                                       tmp_5 = 10272; else 
                                                                    
#line 769 
                                                                    tmp_5 = 264;
  
#line 769 
  ;
  
#line 769 
  ;
  
#line 769 
  tmp_6 = reg_pattern_test(adapter,data,tmp_5,65535U,4294967295U);
  
#line 769 
  if ((int)tmp_6 != 0) {
    
#line 769 
    __retres = 1;
    
#line 769 
    goto return_label;
  }
  else ;
  
#line 770 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 770 
                                                       tmp_7 = 10244; else 
                                                                    
#line 770 
                                                                    tmp_7 = 276;
  
#line 770 
  ;
  
#line 770 
  ;
  
#line 770 
  tmp_8 = reg_pattern_test(adapter,data,tmp_7,4294967295U,4294967295U);
  
#line 770 
  if ((int)tmp_8 != 0) {
    
#line 770 
    __retres = 1;
    
#line 770 
    goto return_label;
  }
  else ;
  
#line 771 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 771 
                                                       tmp_9 = 10248; else 
                                                                    
#line 771 
                                                                    tmp_9 = 280;
  
#line 771 
  ;
  
#line 771 
  ;
  
#line 771 
  tmp_10 = reg_pattern_test(adapter,data,tmp_9,1048448U,1048575U);
  
#line 771 
  if ((int)tmp_10 != 0) {
    
#line 771 
    __retres = 1;
    
#line 771 
    goto return_label;
  }
  else ;
  
#line 772 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 772 
                                                       tmp_11 = 10256; else 
                                                                    
#line 772 
                                                                    tmp_11 = 288;
  
#line 772 
  ;
  
#line 772 
  ;
  
#line 772 
  tmp_12 = reg_pattern_test(adapter,data,tmp_11,65535U,65535U);
  
#line 772 
  if ((int)tmp_12 != 0) {
    
#line 772 
    __retres = 1;
    
#line 772 
    goto return_label;
  }
  else ;
  
#line 773 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 773 
                                                       tmp_13 = 10264; else 
                                                                    
#line 773 
                                                                    tmp_13 = 296;
  
#line 773 
  ;
  
#line 773 
  ;
  
#line 773 
  tmp_14 = reg_pattern_test(adapter,data,tmp_13,65535U,65535U);
  
#line 773 
  if ((int)tmp_14 != 0) {
    
#line 773 
    __retres = 1;
    
#line 773 
    goto return_label;
  }
  else ;
  
#line 774 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 774 
                                                       tmp_15 = 8552; else 
                                                                    
#line 774 
                                                                    tmp_15 = 352;
  
#line 774 
  ;
  
#line 774 
  ;
  
#line 774 
  tmp_16 = reg_pattern_test(adapter,data,tmp_15,65528U,65528U);
  
#line 774 
  if ((int)tmp_16 != 0) {
    
#line 774 
    __retres = 1;
    
#line 774 
    goto return_label;
  }
  else ;
  
#line 775 
  tmp_17 = reg_pattern_test(adapter,data,368,65535U,65535U);
  
#line 775 
  if ((int)tmp_17 != 0) {
    
#line 775 
    __retres = 1;
    
#line 775 
    goto return_label;
  }
  else ;
  
#line 776 
  tmp_18 = reg_pattern_test(adapter,data,1040,1073741823U,1073741823U);
  
#line 776 
  if ((int)tmp_18 != 0) {
    
#line 776 
    __retres = 1;
    
#line 776 
    goto return_label;
  }
  else ;
  
#line 777 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 777 
                                                       tmp_19 = 14340; else 
                                                                    
#line 777 
                                                                    tmp_19 = 1060;
  
#line 777 
  ;
  
#line 777 
  ;
  
#line 777 
  tmp_20 = reg_pattern_test(adapter,data,tmp_19,4294967295U,4294967295U);
  
#line 777 
  if ((int)tmp_20 != 0) {
    
#line 777 
    __retres = 1;
    
#line 777 
    goto return_label;
  }
  else ;
  
#line 778 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 778 
                                                       tmp_21 = 14344; else 
                                                                    
#line 778 
                                                                    tmp_21 = 1064;
  
#line 778 
  ;
  
#line 778 
  ;
  
#line 778 
  tmp_22 = reg_pattern_test(adapter,data,tmp_21,1048448U,1048575U);
  
#line 778 
  if ((int)tmp_22 != 0) {
    
#line 778 
    __retres = 1;
    
#line 778 
    goto return_label;
  }
  else ;
  
#line 780 
  tmp_23 = reg_set_and_check(adapter,data,256,4294967295U,0U);
  
#line 780 
  if ((int)tmp_23 != 0) {
    
#line 780 
    __retres = 1;
    
#line 780 
    goto return_label;
  }
  else ;
  
#line 782 
  before = 115323902U;
  
#line 783 
  tmp_24 = reg_set_and_check(adapter,data,256,before,4194299U);
  
#line 783 
  if ((int)tmp_24 != 0) {
    
#line 783 
    __retres = 1;
    
#line 783 
    goto return_label;
  }
  else ;
  
#line 784 
  tmp_25 = reg_set_and_check(adapter,data,1024,4294967295U,0U);
  
#line 784 
  if ((int)tmp_25 != 0) {
    
#line 784 
    __retres = 1;
    
#line 784 
    goto return_label;
  }
  else ;
  
#line 786 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) {
    bool tmp_26;
    bool tmp_28;
    int tmp_27;
    bool tmp_29;
    bool tmp_31;
    int tmp_30;
    bool tmp_33;
    int tmp_32;
    bool tmp_35;
    u32 tmp_34;
    
#line 787 
    tmp_26 = reg_set_and_check(adapter,data,256,before,4294967295U);
    
#line 787 
    if ((int)tmp_26 != 0) {
      
#line 787 
      __retres = 1;
      
#line 787 
      goto return_label;
    }
    else ;
    
#line 788 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 788 
                                                         tmp_27 = 10240; else 
                                                                    
#line 788 
                                                                    tmp_27 = 272;
    
#line 788 
    ;
    
#line 788 
    ;
    
#line 788 
    tmp_28 = reg_pattern_test(adapter,data,tmp_27,4294967280U,4294967295U);
    
#line 788 
    if ((int)tmp_28 != 0) {
      
#line 788 
      __retres = 1;
      
#line 788 
      goto return_label;
    }
    else ;
    
#line 789 
    tmp_29 = reg_pattern_test(adapter,data,376,3221291007U,65535U);
    
#line 789 
    if ((int)tmp_29 != 0) {
      
#line 789 
      __retres = 1;
      
#line 789 
      goto return_label;
    }
    else ;
    
#line 790 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 790 
                                                         tmp_30 = 14336; else 
                                                                    
#line 790 
                                                                    tmp_30 = 1056;
    
#line 790 
    ;
    
#line 790 
    ;
    
#line 790 
    tmp_31 = reg_pattern_test(adapter,data,tmp_30,4294967280U,4294967295U);
    
#line 790 
    if ((int)tmp_31 != 0) {
      
#line 790 
      __retres = 1;
      
#line 790 
      goto return_label;
    }
    else ;
    
#line 791 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 791 
                                                         tmp_32 = 14368; else 
                                                                    
#line 791 
                                                                    tmp_32 = 1088;
    
#line 791 
    ;
    
#line 791 
    ;
    
#line 791 
    tmp_33 = reg_pattern_test(adapter,data,tmp_32,65535U,65535U);
    
#line 791 
    if ((int)tmp_33 != 0) {
      
#line 791 
      __retres = 1;
      
#line 791 
      goto return_label;
    }
    else ;
    
#line 792 
    value = 15U;
    
#line 793 
    i = 0U;
    
#line 793 
    goto ldv_54658;
    ldv_54657: 
#line 794 
    ;
    
#line 794 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 794 
                                                         tmp_34 = (((i << 1) + 1U) << 2) + 21504U; else 
                                                                    
#line 794 
                                                                    tmp_34 = (((i << 1) + 1U) << 2) + 64U;
    
#line 794 
    ;
    
#line 794 
    ;
    
#line 794 
    tmp_35 = reg_pattern_test(adapter,data,(int)tmp_34,2147745791U,4294967295U);
    
#line 794 
    if ((int)tmp_35 != 0) {
      
#line 794 
      __retres = 1;
      
#line 794 
      goto return_label;
    }
    else ;
    
#line 793 
    i += 1U;
    ldv_54658: 
#line 794 
    ;
    
#line 793 
    if (i < value) 
#line 795 
                   goto ldv_54657; else 
#line 798 
                                        goto ldv_54659;
    ldv_54659: 
#line 799 
    ;
  }
  else {
    bool tmp_36;
    bool tmp_38;
    int tmp_37;
    bool tmp_39;
    bool tmp_41;
    int tmp_40;
    
#line 798 
    tmp_36 = reg_set_and_check(adapter,data,256,4294967295U,33554431U);
    
#line 798 
    if ((int)tmp_36 != 0) {
      
#line 798 
      __retres = 1;
      
#line 798 
      goto return_label;
    }
    else ;
    
#line 799 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 799 
                                                         tmp_37 = 10240; else 
                                                                    
#line 799 
                                                                    tmp_37 = 272;
    
#line 799 
    ;
    
#line 799 
    ;
    
#line 799 
    tmp_38 = reg_pattern_test(adapter,data,tmp_37,4294963200U,4294967295U);
    
#line 799 
    if ((int)tmp_38 != 0) {
      
#line 799 
      __retres = 1;
      
#line 799 
      goto return_label;
    }
    else ;
    
#line 800 
    tmp_39 = reg_pattern_test(adapter,data,376,65535U,65535U);
    
#line 800 
    if ((int)tmp_39 != 0) {
      
#line 800 
      __retres = 1;
      
#line 800 
      goto return_label;
    }
    else ;
    
#line 801 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 801 
                                                         tmp_40 = 14336; else 
                                                                    
#line 801 
                                                                    tmp_40 = 1056;
    
#line 801 
    ;
    
#line 801 
    ;
    
#line 801 
    tmp_41 = reg_pattern_test(adapter,data,tmp_40,4294963200U,4294967295U);
    
#line 801 
    if ((int)tmp_41 != 0) {
      
#line 801 
      __retres = 1;
      
#line 801 
      goto return_label;
    }
    else ;
  }
  
#line 804 
  value = 128U;
  
#line 805 
  i = 0U;
  
#line 805 
  goto ldv_54661;
  ldv_54660: 
#line 806 
  ;
  
#line 806 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 806 
                                                       tmp_42 = (i << 2) + 20992U; else 
                                                                    
#line 806 
                                                                    tmp_42 = (i << 2) + 512U;
  
#line 806 
  ;
  
#line 806 
  ;
  
#line 806 
  tmp_43 = reg_pattern_test(adapter,data,(int)tmp_42,4294967295U,4294967295U);
  
#line 806 
  if ((int)tmp_43 != 0) {
    
#line 806 
    __retres = 1;
    
#line 806 
    goto return_label;
  }
  else ;
  
#line 805 
  i += 1U;
  ldv_54661: 
#line 806 
  ;
  
#line 805 
  if (i < value) 
#line 807 
                 goto ldv_54660; else 
#line 810 
                                      goto ldv_54662;
  ldv_54662: 
#line 811 
  ;
  
#line 808 
  *data = 0ULL;
  
#line 809 
  __retres = 0;
  return_label: 
#line 809 
                return __retres;
}


#line 812  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_eeprom_test(struct e1000_adapter *adapter, u64 *data)
{
  int __retres;
  u16 temp;
  u16 i;
  s32 tmp;
  
#line 814 
  struct e1000_hw *hw = & adapter->hw;
  
#line 816 
  u16 checksum = (unsigned short)0U;
  
#line 819 
  *data = 0ULL;
  
#line 821 
  i = (unsigned short)0U;
  
#line 821 
  goto ldv_54673;
  ldv_54672: 
#line 822 
  ;
  
#line 822 
  tmp = e1000_read_eeprom(hw,(unsigned short)((int)i),(unsigned short)1,& temp);
  
#line 822 
  if (tmp < 0) {
    
#line 823 
    *data = 1ULL;
    
#line 824 
    goto ldv_54671;
  }
  else ;
  
#line 826 
  checksum = (unsigned short)((int)checksum + (int)temp);
  
#line 821 
  i = (u16)((int)i + 1);
  ldv_54673: 
#line 822 
  ;
  
#line 821 
  if ((unsigned int)i <= 63U) 
#line 823 
                              goto ldv_54672; else 
#line 826 
                                                   goto ldv_54671;
  ldv_54671: 
#line 827 
  ;
  
#line 830 
  if ((unsigned int)checksum != 47802U && *data == 0ULL) 
#line 831 
                                                         *data = 2ULL; else ;
  
#line 833 
  __retres = (int)*data;
  
#line 833 
  return __retres;
}


#line 836  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static irqreturn_t e1000_test_intr(int irq, void *data)
{
  irqreturn_t __retres;
  unsigned int tmp_0;
  
#line 838 
  struct net_device *netdev = (struct net_device *)data;
  
#line 839 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 840 
  struct e1000_hw *hw = & adapter->hw;
  
#line 842 
  tmp_0 = readl((void const volatile *)(hw->hw_addr + 192U));
  
#line 842 
  adapter->test_icr |= tmp_0;
  
#line 844 
  __retres = IRQ_HANDLED;
  
#line 844 
  return __retres;
}


#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)
{
  int __retres;
  u32 mask;
  int tmp_0;
  
#line 849 
  struct net_device *netdev = adapter->netdev;
  
#line 850 
  u32 i = 0U;
  
#line 851 
  bool shared_int = (_Bool)1;
  
#line 852 
  u32 irq = (adapter->pdev)->irq;
  
#line 853 
  struct e1000_hw *hw = & adapter->hw;
  
#line 855 
  *data = 0ULL;
  
#line 860 
  tmp_0 = ldv_request_irq_77(irq,& e1000_test_intr,256UL,(char const *)(& netdev->name),(void *)netdev);
  
#line 860 
  if (tmp_0 == 0) 
#line 862 
                  shared_int = (_Bool)0;
  else {
    int tmp;
    
#line 863 
    tmp = ldv_request_irq_78(irq,& e1000_test_intr,128UL,(char const *)(& netdev->name),(void *)netdev);
    
#line 863 
    if (tmp != 0) {
      
#line 865 
      *data = 1ULL;
      
#line 866 
      __retres = -1;
      
#line 866 
      goto return_label;
    }
    else ;
  }
  
#line 868 
  if ((adapter->msg_enable & 8192) != 0) {
    char *tmp_1;
    
#line 868 
    if ((int)shared_int != 0) 
#line 868 
                              tmp_1 = (char *)"shared"; else 
#line 868 
                                                             tmp_1 = (char *)"unshared";
    
#line 868 
    ;
    
#line 868 
    netdev_info((struct net_device const *)adapter->netdev,"testing %s interrupt\n",tmp_1);
  }
  else ;
  
#line 872 
  writel(4294967295U,(void volatile *)(hw->hw_addr + 216U));
  
#line 873 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 874 
  msleep(10U);
  
#line 877 
  goto ldv_54693;
  ldv_54692: 
#line 878 
  ;
  
#line 879 
  mask = (unsigned int)(1 << i);
  
#line 881 
  if (! shared_int) {
    
#line 888 
    adapter->test_icr = 0U;
    
#line 889 
    writel(mask,(void volatile *)(hw->hw_addr + 216U));
    
#line 890 
    writel(mask,(void volatile *)(hw->hw_addr + 200U));
    
#line 891 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 892 
    msleep(10U);
    
#line 894 
    if ((adapter->test_icr & mask) != 0U) {
      
#line 895 
      *data = 3ULL;
      
#line 896 
      goto ldv_54691;
    }
    else ;
  }
  else ;
  
#line 906 
  adapter->test_icr = 0U;
  
#line 907 
  writel(mask,(void volatile *)(hw->hw_addr + 208U));
  
#line 908 
  writel(mask,(void volatile *)(hw->hw_addr + 200U));
  
#line 909 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 910 
  msleep(10U);
  
#line 912 
  if ((adapter->test_icr & mask) == 0U) {
    
#line 913 
    *data = 4ULL;
    
#line 914 
    goto ldv_54691;
  }
  else ;
  
#line 917 
  if (! shared_int) {
    
#line 924 
    adapter->test_icr = 0U;
    
#line 925 
    writel(~ mask & 32767U,(void volatile *)(hw->hw_addr + 216U));
    
#line 926 
    writel(~ mask & 32767U,(void volatile *)(hw->hw_addr + 200U));
    
#line 927 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 928 
    msleep(10U);
    
#line 930 
    if (adapter->test_icr != 0U) {
      
#line 931 
      *data = 5ULL;
      
#line 932 
      goto ldv_54691;
    }
    else ;
  }
  else ;
  
#line 877 
  i += 1U;
  ldv_54693: 
#line 878 
  ;
  
#line 877 
  if (i <= 9U) 
#line 879 
               goto ldv_54692; else 
#line 882 
                                    goto ldv_54691;
  ldv_54691: 
#line 883 
  ;
  
#line 938 
  writel(4294967295U,(void volatile *)(hw->hw_addr + 216U));
  
#line 939 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 940 
  msleep(10U);
  
#line 943 
  ldv_free_irq_79(irq,(void *)netdev);
  
#line 945 
  __retres = (int)*data;
  return_label: 
#line 945 
                return __retres;
}


#line 948  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_free_desc_rings(struct e1000_adapter *adapter)
{
  int i;
  
#line 950 
  struct e1000_tx_ring *txdr = & adapter->test_tx_ring;
  
#line 951 
  struct e1000_rx_ring *rxdr = & adapter->test_rx_ring;
  
#line 952 
  struct pci_dev *pdev = adapter->pdev;
  
#line 955 
  if (txdr->desc != (void *)0 && txdr->buffer_info != (struct e1000_tx_buffer *)0) {
    
#line 956 
    i = 0;
    
#line 956 
    goto ldv_54702;
    ldv_54701: 
#line 957 
    ;
    
#line 957 
    if ((txdr->buffer_info + i)->dma != 0ULL) 
#line 958 
                                              dma_unmap_single_attrs(& pdev->dev,(txdr->buffer_info + i)->dma,(unsigned long)(txdr->buffer_info + i)->length,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0); else ;
    
#line 962 
    if ((txdr->buffer_info + i)->skb != (struct sk_buff *)0) 
#line 963 
                                                             consume_skb((txdr->buffer_info + i)->skb); else ;
    
#line 956 
    i += 1;
    ldv_54702: 
#line 957 
    ;
    
#line 956 
    if (txdr->count > (unsigned int)i) 
#line 958 
                                       goto ldv_54701; else 
#line 961 
                                                            goto ldv_54703;
    ldv_54703: 
#line 962 
    ;
  }
  else ;
  
#line 967 
  if (rxdr->desc != (void *)0 && rxdr->buffer_info != (struct e1000_rx_buffer *)0) {
    
#line 968 
    i = 0;
    
#line 968 
    goto ldv_54705;
    ldv_54704: 
#line 969 
    ;
    
#line 969 
    if ((rxdr->buffer_info + i)->dma != 0ULL) 
#line 970 
                                              dma_unmap_single_attrs(& pdev->dev,(rxdr->buffer_info + i)->dma,2048UL,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0); else ;
    
#line 974 
    kfree((void const *)(rxdr->buffer_info + i)->rxbuf.data);
    
#line 968 
    i += 1;
    ldv_54705: 
#line 969 
    ;
    
#line 968 
    if (rxdr->count > (unsigned int)i) 
#line 970 
                                       goto ldv_54704; else 
#line 973 
                                                            goto ldv_54706;
    ldv_54706: 
#line 974 
    ;
  }
  else ;
  
#line 978 
  if (txdr->desc != (void *)0) {
    
#line 979 
    dma_free_attrs(& pdev->dev,(unsigned long)txdr->size,txdr->desc,txdr->dma,(struct dma_attrs *)0);
    
#line 981 
    txdr->desc = (void *)0;
  }
  else ;
  
#line 983 
  if (rxdr->desc != (void *)0) {
    
#line 984 
    dma_free_attrs(& pdev->dev,(unsigned long)rxdr->size,rxdr->desc,rxdr->dma,(struct dma_attrs *)0);
    
#line 986 
    rxdr->desc = (void *)0;
  }
  else ;
  
#line 989 
  kfree((void const *)txdr->buffer_info);
  
#line 990 
  txdr->buffer_info = (struct e1000_tx_buffer *)0;
  
#line 991 
  kfree((void const *)rxdr->buffer_info);
  
#line 992 
  rxdr->buffer_info = (struct e1000_rx_buffer *)0;
  
#line 993 
  return;
}


#line 995  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_setup_desc_rings(struct e1000_adapter *adapter)
{
  int __retres;
  u32 rctl;
  int i;
  int ret_val;
  unsigned int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  unsigned int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  
#line 997 
  struct e1000_hw *hw = & adapter->hw;
  
#line 998 
  struct e1000_tx_ring *txdr = & adapter->test_tx_ring;
  
#line 999 
  struct e1000_rx_ring *rxdr = & adapter->test_rx_ring;
  
#line 1000 
  struct pci_dev *pdev = adapter->pdev;
  
#line 1006 
  if (txdr->count == 0U) 
#line 1007 
                         txdr->count = 256U; else ;
  
#line 1009 
  txdr->buffer_info = (struct e1000_tx_buffer *)kcalloc_0((unsigned long)txdr->count,40UL,208U);
  
#line 1011 
  if (txdr->buffer_info == (struct e1000_tx_buffer *)0) {
    
#line 1012 
    ret_val = 1;
    
#line 1013 
    goto err_nomem;
  }
  else ;
  
#line 1016 
  txdr->size = txdr->count * 16U;
  
#line 1017 
  txdr->size = (txdr->size + 4095U) & 4294963200U;
  
#line 1018 
  txdr->desc = dma_zalloc_coherent(& pdev->dev,(unsigned long)txdr->size,& txdr->dma,208U);
  
#line 1020 
  if (txdr->desc == (void *)0) {
    
#line 1021 
    ret_val = 2;
    
#line 1022 
    goto err_nomem;
  }
  else ;
  
#line 1024 
  tmp_0 = 0U;
  
#line 1024 
  txdr->next_to_clean = tmp_0;
  
#line 1024 
  txdr->next_to_use = tmp_0;
  
#line 1026 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1026 
                                                       tmp_1 = 14336; else 
                                                                    
#line 1026 
                                                                    tmp_1 = 1056;
  
#line 1026 
  ;
  
#line 1026 
  ;
  
#line 1026 
  writel((unsigned int)txdr->dma,(void volatile *)(hw->hw_addr + tmp_1));
  
#line 1027 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1027 
                                                       tmp_2 = 14340; else 
                                                                    
#line 1027 
                                                                    tmp_2 = 1060;
  
#line 1027 
  ;
  
#line 1027 
  ;
  
#line 1027 
  writel((unsigned int)(txdr->dma >> 32),(void volatile *)(hw->hw_addr + tmp_2));
  
#line 1028 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1028 
                                                       tmp_3 = 14344; else 
                                                                    
#line 1028 
                                                                    tmp_3 = 1064;
  
#line 1028 
  ;
  
#line 1028 
  ;
  
#line 1028 
  writel(txdr->count * 16U,(void volatile *)(hw->hw_addr + tmp_3));
  
#line 1029 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1029 
                                                       tmp_4 = 14352; else 
                                                                    
#line 1029 
                                                                    tmp_4 = 1072;
  
#line 1029 
  ;
  
#line 1029 
  writel(0U,(void volatile *)(hw->hw_addr + tmp_4));
  
#line 1030 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1030 
                                                       tmp_5 = 14360; else 
                                                                    
#line 1030 
                                                                    tmp_5 = 1080;
  
#line 1030 
  ;
  
#line 1030 
  writel(0U,(void volatile *)(hw->hw_addr + tmp_5));
  
#line 1031 
  writel(258298U,(void volatile *)(hw->hw_addr + 1024U));
  
#line 1035 
  i = 0;
  
#line 1035 
  goto ldv_54722;
  ldv_54721: 
#line 1036 
  ;
  {
    struct sk_buff *skb;
    int tmp_6;
    
#line 1036 
    struct e1000_tx_desc *tx_desc = (struct e1000_tx_desc *)txdr->desc + i;
    
#line 1038 
    unsigned int size = 1024U;
    
#line 1040 
    skb = alloc_skb(size,208U);
    
#line 1041 
    if (skb == (struct sk_buff *)0) {
      
#line 1042 
      ret_val = 3;
      
#line 1043 
      goto err_nomem;
    }
    else ;
    
#line 1045 
    skb_put(skb,size);
    
#line 1046 
    (txdr->buffer_info + i)->skb = skb;
    
#line 1047 
    (txdr->buffer_info + i)->length = (unsigned short)skb->len;
    
#line 1048 
    (txdr->buffer_info + i)->dma = dma_map_single_attrs(& pdev->dev,(void *)skb->data,(unsigned long)skb->len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 1051 
    tmp_6 = dma_mapping_error(& pdev->dev,(txdr->buffer_info + i)->dma);
    
#line 1051 
    if (tmp_6 != 0) {
      
#line 1052 
      ret_val = 4;
      
#line 1053 
      goto err_nomem;
    }
    else ;
    
#line 1055 
    tx_desc->buffer_addr = (txdr->buffer_info + i)->dma;
    
#line 1056 
    tx_desc->lower.data = skb->len;
    
#line 1057 
    tx_desc->lower.data |= 318767104U;
    
#line 1060 
    tx_desc->upper.data = 0U;
  }
  
#line 1035 
  i += 1;
  ldv_54722: 
#line 1036 
  ;
  
#line 1035 
  if (txdr->count > (unsigned int)i) 
#line 1037 
                                     goto ldv_54721; else 
#line 1040 
                                                          goto ldv_54723;
  ldv_54723: 
#line 1041 
  ;
  
#line 1065 
  if (rxdr->count == 0U) 
#line 1066 
                         rxdr->count = 256U; else ;
  
#line 1068 
  rxdr->buffer_info = (struct e1000_rx_buffer *)kcalloc_0((unsigned long)rxdr->count,16UL,208U);
  
#line 1070 
  if (rxdr->buffer_info == (struct e1000_rx_buffer *)0) {
    
#line 1071 
    ret_val = 5;
    
#line 1072 
    goto err_nomem;
  }
  else ;
  
#line 1075 
  rxdr->size = rxdr->count * 16U;
  
#line 1076 
  rxdr->desc = dma_zalloc_coherent(& pdev->dev,(unsigned long)rxdr->size,& rxdr->dma,208U);
  
#line 1078 
  if (rxdr->desc == (void *)0) {
    
#line 1079 
    ret_val = 6;
    
#line 1080 
    goto err_nomem;
  }
  else ;
  
#line 1082 
  tmp_8 = 0U;
  
#line 1082 
  rxdr->next_to_clean = tmp_8;
  
#line 1082 
  rxdr->next_to_use = tmp_8;
  
#line 1084 
  rctl = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 1085 
  writel(rctl & 4294967293U,(void volatile *)(hw->hw_addr + 256U));
  
#line 1086 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1086 
                                                       tmp_9 = 10240; else 
                                                                    
#line 1086 
                                                                    tmp_9 = 272;
  
#line 1086 
  ;
  
#line 1086 
  ;
  
#line 1086 
  writel((unsigned int)rxdr->dma,(void volatile *)(hw->hw_addr + tmp_9));
  
#line 1087 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1087 
                                                       tmp_10 = 10244; else 
                                                                    
#line 1087 
                                                                    tmp_10 = 276;
  
#line 1087 
  ;
  
#line 1087 
  ;
  
#line 1087 
  writel((unsigned int)(rxdr->dma >> 32),(void volatile *)(hw->hw_addr + tmp_10));
  
#line 1088 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1088 
                                                       tmp_11 = 10248; else 
                                                                    
#line 1088 
                                                                    tmp_11 = 280;
  
#line 1088 
  ;
  
#line 1088 
  ;
  
#line 1088 
  writel(rxdr->size,(void volatile *)(hw->hw_addr + tmp_11));
  
#line 1089 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1089 
                                                       tmp_12 = 10256; else 
                                                                    
#line 1089 
                                                                    tmp_12 = 288;
  
#line 1089 
  ;
  
#line 1089 
  writel(0U,(void volatile *)(hw->hw_addr + tmp_12));
  
#line 1090 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1090 
                                                       tmp_13 = 10264; else 
                                                                    
#line 1090 
                                                                    tmp_13 = 296;
  
#line 1090 
  ;
  
#line 1090 
  writel(0U,(void volatile *)(hw->hw_addr + tmp_13));
  
#line 1091 
  rctl = (hw->mc_filter_type << 12) | 32770U;
  
#line 1094 
  writel(rctl,(void volatile *)(hw->hw_addr + 256U));
  
#line 1096 
  i = 0;
  
#line 1096 
  goto ldv_54733;
  ldv_54732: 
#line 1097 
  ;
  {
    u8 *buf;
    void *tmp_16;
    int tmp_15;
    int tmp_18;
    int tmp_19;
    
#line 1097 
    struct e1000_rx_desc *rx_desc = (struct e1000_rx_desc *)rxdr->desc + i;
    {
      int tmp_14;
      
#line 1100 
      int _max1 = 32;
      
#line 1100 
      int _max2 = 64;
      
#line 1100 
      if (_max1 > _max2) 
#line 1100 
                         tmp_14 = _max1; else 
#line 1100 
                                              tmp_14 = _max2;
      
#line 1100 
      tmp_15 = tmp_14;
    }
    
#line 1100 
    tmp_16 = kzalloc((unsigned long)(tmp_15 + 2048),208U);
    
#line 1100 
    buf = (u8 *)tmp_16;
    
#line 1102 
    if (buf == (u8 *)0U) {
      
#line 1103 
      ret_val = 7;
      
#line 1104 
      goto err_nomem;
    }
    else ;
    
#line 1106 
    (rxdr->buffer_info + i)->rxbuf.data = buf;
    {
      int tmp_17;
      
#line 1109 
      int _max1_0 = 32;
      
#line 1109 
      int _max2_0 = 64;
      
#line 1109 
      if (_max1_0 > _max2_0) 
#line 1109 
                             tmp_17 = _max1_0; else 
#line 1109 
                                                    tmp_17 = _max2_0;
      
#line 1109 
      tmp_18 = tmp_17;
    }
    
#line 1108 
    ;
    
#line 1108 
    ;
    
#line 1108 
    (rxdr->buffer_info + i)->dma = dma_map_single_attrs(& pdev->dev,(void *)(buf + tmp_18),2048UL,(enum dma_data_direction)DMA_FROM_DEVICE,(struct dma_attrs *)0);
    
#line 1112 
    tmp_19 = dma_mapping_error(& pdev->dev,(rxdr->buffer_info + i)->dma);
    
#line 1112 
    if (tmp_19 != 0) {
      
#line 1113 
      ret_val = 8;
      
#line 1114 
      goto err_nomem;
    }
    else ;
    
#line 1116 
    rx_desc->buffer_addr = (rxdr->buffer_info + i)->dma;
  }
  
#line 1096 
  i += 1;
  ldv_54733: 
#line 1097 
  ;
  
#line 1096 
  if (rxdr->count > (unsigned int)i) 
#line 1098 
                                     goto ldv_54732; else 
#line 1101 
                                                          goto ldv_54734;
  ldv_54734: 
#line 1102 
  ;
  
#line 1119 
  __retres = 0;
  
#line 1119 
  goto return_label;
  err_nomem: 
#line 1121 
  ;
  
#line 1122 
  e1000_free_desc_rings(adapter);
  
#line 1123 
  __retres = ret_val;
  return_label: 
#line 1123 
                return __retres;
}


#line 1126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_phy_disable_receiver(struct e1000_adapter *adapter)
{
  
#line 1128 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1131 
  e1000_write_phy_reg(hw,29U,(unsigned short)31);
  
#line 1132 
  e1000_write_phy_reg(hw,30U,(unsigned short)36860);
  
#line 1133 
  e1000_write_phy_reg(hw,29U,(unsigned short)26);
  
#line 1134 
  e1000_write_phy_reg(hw,30U,(unsigned short)36848);
  
#line 1135 
  return;
}


#line 1137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_phy_reset_clk_and_crs(struct e1000_adapter *adapter)
{
  u16 phy_reg;
  
#line 1139 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1146 
  e1000_read_phy_reg(hw,20U,& phy_reg);
  
#line 1147 
  phy_reg = (unsigned short)((unsigned int)phy_reg | 112U);
  
#line 1148 
  e1000_write_phy_reg(hw,20U,(unsigned short)((int)phy_reg));
  
#line 1154 
  e1000_read_phy_reg(hw,16U,& phy_reg);
  
#line 1155 
  phy_reg = (unsigned short)((unsigned int)phy_reg | 2048U);
  
#line 1156 
  e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_reg));
  
#line 1157 
  return;
}


#line 1159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_nonintegrated_phy_loopback(struct e1000_adapter *adapter)
{
  int __retres;
  u32 ctrl_reg;
  u16 phy_reg;
  
#line 1161 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1167 
  ctrl_reg = readl((void const volatile *)hw->hw_addr);
  
#line 1168 
  ctrl_reg |= 6785U;
  
#line 1174 
  writel(ctrl_reg,(void volatile *)hw->hw_addr);
  
#line 1177 
  e1000_read_phy_reg(hw,16U,& phy_reg);
  
#line 1182 
  phy_reg = (unsigned short)((unsigned int)phy_reg & 65439U);
  
#line 1183 
  e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_reg));
  
#line 1186 
  e1000_phy_reset(hw);
  
#line 1189 
  e1000_phy_reset_clk_and_crs(adapter);
  
#line 1191 
  e1000_write_phy_reg(hw,0U,(unsigned short)33024);
  
#line 1194 
  __const_udelay(2147500UL);
  
#line 1197 
  e1000_phy_reset_clk_and_crs(adapter);
  
#line 1200 
  e1000_phy_disable_receiver(adapter);
  
#line 1203 
  e1000_read_phy_reg(hw,0U,& phy_reg);
  
#line 1204 
  phy_reg = (unsigned short)((unsigned int)phy_reg | 16384U);
  
#line 1205 
  e1000_write_phy_reg(hw,0U,(unsigned short)((int)phy_reg));
  
#line 1208 
  e1000_phy_reset_clk_and_crs(adapter);
  
#line 1211 
  e1000_read_phy_reg(hw,0U,& phy_reg);
  
#line 1212 
  if ((unsigned int)phy_reg != 16640U) {
    
#line 1213 
    __retres = 9;
    
#line 1213 
    goto return_label;
  }
  else ;
  
#line 1215 
  e1000_read_phy_reg(hw,20U,& phy_reg);
  
#line 1216 
  if ((unsigned int)phy_reg != 112U) {
    
#line 1217 
    __retres = 10;
    
#line 1217 
    goto return_label;
  }
  else ;
  
#line 1219 
  e1000_read_phy_reg(hw,29U,& phy_reg);
  
#line 1220 
  if ((unsigned int)phy_reg != 26U) {
    
#line 1221 
    __retres = 11;
    
#line 1221 
    goto return_label;
  }
  else ;
  
#line 1223 
  __retres = 0;
  return_label: 
#line 1223 
                return __retres;
}


#line 1226  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_integrated_phy_loopback(struct e1000_adapter *adapter)
{
  int __retres;
  
#line 1228 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1229 
  u32 ctrl_reg = 0U;
  
#line 1230 
  u32 stat_reg = 0U;
  
#line 1232 
  hw->autoneg = (unsigned char)0U;
  
#line 1234 
  if (hw->phy_type == (unsigned int)0) {
    
#line 1236 
    e1000_write_phy_reg(hw,16U,(unsigned short)2056);
    
#line 1239 
    e1000_write_phy_reg(hw,0U,(unsigned short)37184);
    
#line 1241 
    e1000_write_phy_reg(hw,0U,(unsigned short)33088);
  }
  else ;
  
#line 1244 
  ctrl_reg = readl((void const volatile *)hw->hw_addr);
  
#line 1247 
  e1000_write_phy_reg(hw,0U,(unsigned short)16704);
  
#line 1250 
  ctrl_reg = readl((void const volatile *)hw->hw_addr);
  
#line 1251 
  ctrl_reg &= 4294966527U;
  
#line 1252 
  ctrl_reg |= 6657U;
  
#line 1257 
  if (hw->media_type == (unsigned int)e1000_media_type_copper && hw->phy_type == (unsigned int)0) 
    
#line 1259 
    ctrl_reg |= 128U;
  else {
    
#line 1264 
    stat_reg = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 1265 
    if ((stat_reg & 1U) == 0U) 
#line 1266 
                               ctrl_reg |= 192U; else ;
  }
  
#line 1269 
  writel(ctrl_reg,(void volatile *)hw->hw_addr);
  
#line 1274 
  if (hw->phy_type == (unsigned int)0) 
#line 1275 
                                       e1000_phy_disable_receiver(adapter); else ;
  
#line 1277 
  __const_udelay(2147500UL);
  
#line 1279 
  __retres = 0;
  
#line 1279 
  return __retres;
}


#line 1282  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_set_phy_loopback(struct e1000_adapter *adapter)
{
  int __retres;
  
#line 1284 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1285 
  u16 phy_reg = (unsigned short)0U;
  
#line 1286 
  u16 count = (unsigned short)0U;
  
#line 1288 
  switch ((unsigned int)hw->mac_type) {
    int tmp_1;
    case (unsigned int)3: 
#line 1289 
    ;
    
#line 1290 
    if (hw->media_type == (unsigned int)e1000_media_type_copper) {
      int tmp;
      
#line 1295 
      goto ldv_54764;
      ldv_54763: 
#line 1296 
      ;
      ldv_54764: 
#line 1297 
      ;
      
#line 1295 
      tmp = e1000_nonintegrated_phy_loopback(adapter);
      
#line 1295 
      if (tmp != 0) {
        u16 tmp_0;
        
#line 1295 
        tmp_0 = count;
        
#line 1295 
        count = (u16)((int)count + 1);
        
#line 1295 
        ;
        
#line 1295 
        if ((unsigned int)tmp_0 <= 9U) 
#line 1298 
                                       goto ldv_54763; else 
#line 1301 
                                                            goto ldv_54765;
      }
      else 
#line 1301 
           goto ldv_54765;
      ldv_54765: 
#line 1302 
      ;
      
#line 1297 
      if ((unsigned int)count <= 10U) {
        
#line 1298 
        __retres = 0;
        
#line 1298 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 1300 
    goto ldv_54766;
    case (unsigned int)4: 
#line 1302 
    ;
    case (unsigned int)5: 
#line 1303 
    ;
    case (unsigned int)6: 
#line 1304 
    ;
    case (unsigned int)7: 
#line 1305 
    ;
    case (unsigned int)8: 
#line 1306 
    ;
    case (unsigned int)10: 
#line 1307 
    ;
    case (unsigned int)11: 
#line 1308 
    ;
    case (unsigned int)12: 
#line 1309 
    ;
    case (unsigned int)13: 
#line 1310 
    ;
    case (unsigned int)14: 
#line 1311 
    ;
    
#line 1312 
    tmp_1 = e1000_integrated_phy_loopback(adapter);
    
#line 1312 
    __retres = tmp_1;
    
#line 1312 
    goto return_label;
    default: 
#line 1313 
    ;
    
#line 1317 
    e1000_read_phy_reg(hw,0U,& phy_reg);
    
#line 1318 
    phy_reg = (unsigned short)((unsigned int)phy_reg | 16384U);
    
#line 1319 
    e1000_write_phy_reg(hw,0U,(unsigned short)((int)phy_reg));
    
#line 1320 
    __retres = 0;
    
#line 1320 
    goto return_label;
  }
  ldv_54766: 
#line 1323 
  ;
  
#line 1323 
  __retres = 8;
  return_label: 
#line 1323 
                return __retres;
}


#line 1326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_setup_loopback_test(struct e1000_adapter *adapter)
{
  int __retres;
  u32 rctl;
  
#line 1328 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1331 
  if ((unsigned int)hw->media_type + 4294967295U <= 1U) 
    
#line 1333 
    switch ((unsigned int)hw->mac_type) {
      int tmp;
      case (unsigned int)6: 
#line 1334 
      ;
      case (unsigned int)8: 
#line 1335 
      ;
      case (unsigned int)7: 
#line 1336 
      ;
      case (unsigned int)10: 
#line 1337 
      ;
      
#line 1338 
      tmp = e1000_set_phy_loopback(adapter);
      
#line 1338 
      __retres = tmp;
      
#line 1338 
      goto return_label;
      default: 
#line 1339 
      ;
      
#line 1340 
      rctl = readl((void const volatile *)(hw->hw_addr + 256U));
      
#line 1341 
      rctl |= 192U;
      
#line 1342 
      writel(rctl,(void volatile *)(hw->hw_addr + 256U));
      
#line 1343 
      __retres = 0;
      
#line 1343 
      goto return_label;
    }
  else 
    
#line 1345 
    if (hw->media_type == (unsigned int)e1000_media_type_copper) {
      int tmp_0;
      
#line 1346 
      tmp_0 = e1000_set_phy_loopback(adapter);
      
#line 1346 
      __retres = tmp_0;
      
#line 1346 
      goto return_label;
    }
    else ;
  
#line 1349 
  __retres = 7;
  return_label: 
#line 1349 
                return __retres;
}


#line 1352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_loopback_cleanup(struct e1000_adapter *adapter)
{
  u32 rctl;
  u16 phy_reg;
  
#line 1354 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1358 
  rctl = readl((void const volatile *)(hw->hw_addr + 256U));
  
#line 1359 
  rctl &= 4294967103U;
  
#line 1360 
  writel(rctl,(void volatile *)(hw->hw_addr + 256U));
  
#line 1362 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)6: 
#line 1363 
    ;
    case (unsigned int)8: 
#line 1364 
    ;
    case (unsigned int)7: 
#line 1365 
    ;
    case (unsigned int)10: 
#line 1366 
    ;
    default: 
#line 1367 
    ;
    
#line 1368 
    hw->autoneg = (unsigned char)1U;
    
#line 1369 
    e1000_read_phy_reg(hw,0U,& phy_reg);
    
#line 1370 
    if (((int)phy_reg & 16384) != 0) {
      
#line 1371 
      phy_reg = (unsigned short)((unsigned int)phy_reg & 49151U);
      
#line 1372 
      e1000_write_phy_reg(hw,0U,(unsigned short)((int)phy_reg));
      
#line 1373 
      e1000_phy_reset(hw);
    }
    else ;
    
#line 1375 
    goto ldv_54799;
  }
  ldv_54799: 
#line 1377 
  ;
  
#line 1378 
  return;
}


#line 1379  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_create_lbtest_frame(struct sk_buff *skb, unsigned int frame_size)
{
  
#line 1382 
  memset((void *)skb->data,255,(unsigned long)frame_size);
  
#line 1383 
  frame_size &= 4294967294U;
  
#line 1384 
  memset((void *)(skb->data + frame_size / 2U),170,(unsigned long)(frame_size / 2U + 4294967295U));
  
#line 1385 
  memset((void *)(skb->data + (frame_size / 2U + 10U)),190,1UL);
  
#line 1386 
  memset((void *)(skb->data + (frame_size / 2U + 12U)),175,1UL);
  
#line 1387 
  return;
}


#line 1389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_check_lbtest_frame(unsigned char const *data, unsigned int frame_size)
{
  int __retres;
  
#line 1392 
  frame_size &= 4294967294U;
  
#line 1393 
  if ((unsigned int)*(data + 3U) == 255U) {
    
#line 1394 
    if ((unsigned int)*(data + (frame_size / 2U + 10U)) == 190U && (unsigned int)*(data + (frame_size / 2U + 12U)) == 175U) {
      
#line 1396 
      __retres = 0;
      
#line 1396 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1399 
  __retres = 13;
  return_label: 
#line 1399 
                return __retres;
}


#line 1402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_run_loopback_test(struct e1000_adapter *adapter)
{
  int i;
  int j;
  int k;
  int l;
  int lc;
  int good_cnt;
  unsigned long time;
  int tmp;
  int tmp_0;
  int tmp_2;
  int tmp_5;
  
#line 1404 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1405 
  struct e1000_tx_ring *txdr = & adapter->test_tx_ring;
  
#line 1406 
  struct e1000_rx_ring *rxdr = & adapter->test_rx_ring;
  
#line 1407 
  struct pci_dev *pdev = adapter->pdev;
  
#line 1408 
  int ret_val = 0;
  
#line 1411 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1411 
                                                       tmp = 10264; else 
                                                                    
#line 1411 
                                                                    tmp = 296;
  
#line 1411 
  ;
  
#line 1411 
  ;
  
#line 1411 
  writel(rxdr->count + 4294967295U,(void volatile *)(hw->hw_addr + tmp));
  
#line 1418 
  if (rxdr->count <= txdr->count) 
#line 1419 
                                  lc = (int)((txdr->count / 64U) * 2U + 1U); else 
                                                                    
#line 1421 
                                                                    lc = (int)((rxdr->count / 64U) * 2U + 1U);
  
#line 1423 
  l = 0;
  
#line 1423 
  k = l;
  
#line 1424 
  j = 0;
  
#line 1424 
  goto ldv_54845;
  ldv_54844: 
#line 1425 
  ;
  
#line 1425 
  i = 0;
  
#line 1425 
  goto ldv_54824;
  ldv_54823: 
#line 1426 
  ;
  
#line 1426 
  e1000_create_lbtest_frame((txdr->buffer_info + i)->skb,1024U);
  
#line 1428 
  dma_sync_single_for_device(& pdev->dev,(txdr->buffer_info + k)->dma,(unsigned long)(txdr->buffer_info + k)->length,(enum dma_data_direction)DMA_TO_DEVICE);
  
#line 1432 
  k += 1;
  
#line 1432 
  ;
  
#line 1432 
  if ((long)((unsigned int)k == txdr->count) != 0L) 
#line 1433 
                                                    k = 0; else ;
  
#line 1425 
  i += 1;
  ldv_54824: 
#line 1426 
  ;
  
#line 1425 
  if (i <= 63) 
#line 1427 
               goto ldv_54823; else 
#line 1430 
                                    goto ldv_54825;
  ldv_54825: 
#line 1431 
  ;
  
#line 1435 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 1435 
                                                       tmp_0 = 14360; else 
                                                                    
#line 1435 
                                                                    tmp_0 = 1080;
  
#line 1435 
  ;
  
#line 1435 
  ;
  
#line 1435 
  writel((unsigned int)k,(void volatile *)(hw->hw_addr + tmp_0));
  
#line 1436 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 1437 
  msleep(200U);
  
#line 1438 
  time = jiffies;
  
#line 1439 
  good_cnt = 0;
  ldv_54835: 
#line 1440 
  ;
  
#line 1441 
  dma_sync_single_for_cpu(& pdev->dev,(rxdr->buffer_info + l)->dma,2048UL,(enum dma_data_direction)DMA_FROM_DEVICE);
  {
    int tmp_1;
    
#line 1448 
    int _max1 = 32;
    
#line 1448 
    int _max2 = 64;
    
#line 1448 
    if (_max1 > _max2) 
#line 1448 
                       tmp_1 = _max1; else 
#line 1448 
                                           tmp_1 = _max2;
    
#line 1448 
    tmp_2 = tmp_1;
  }
  
#line 1446 
  ;
  
#line 1446 
  ret_val = e1000_check_lbtest_frame((unsigned char const *)((rxdr->buffer_info + l)->rxbuf.data + tmp_2),1024U);
  
#line 1450 
  if (ret_val == 0) 
#line 1451 
                    good_cnt += 1; else ;
  
#line 1452 
  l += 1;
  
#line 1452 
  ;
  
#line 1452 
  if ((long)((unsigned int)l == rxdr->count) != 0L) 
#line 1453 
                                                    l = 0; else ;
  
#line 1458 
  if (good_cnt <= 63) {
    int tmp_3;
    {
      unsigned long __dummy;
      unsigned long __dummy2;
      
#line 1458 
      tmp_3 = 1;
    }
    
#line 1458 
    if (tmp_3 != 0) {
      int tmp_4;
      {
        unsigned long __dummy_0;
        unsigned long volatile __dummy2_0;
        
#line 1458 
        tmp_4 = 1;
      }
      
#line 1458 
      if (tmp_4 != 0) {
        
#line 1458 
        if ((long)((jiffies - time) + 18446744073709551596UL) < 0L) 
#line 1460 
                                                                    goto ldv_54835; else 
                                                                    
#line 1463 
                                                                    goto ldv_54836;
      }
      else 
#line 1463 
           goto ldv_54836;
    }
    else 
#line 1463 
         goto ldv_54836;
  }
  else 
#line 1463 
       goto ldv_54836;
  ldv_54836: 
#line 1464 
  ;
  
#line 1460 
  if (good_cnt != 64) {
    
#line 1461 
    ret_val = 13;
    
#line 1462 
    goto ldv_54837;
  }
  else ;
  {
    unsigned long __dummy_1;
    unsigned long volatile __dummy2_1;
    
#line 1464 
    tmp_5 = 1;
  }
  
#line 1464 
  if (tmp_5 != 0) {
    int tmp_6;
    {
      unsigned long __dummy_2;
      unsigned long __dummy2_2;
      
#line 1464 
      tmp_6 = 1;
    }
    
#line 1464 
    if (tmp_6 != 0) {
      
#line 1464 
      if ((long)((jiffies - time) + 18446744073709551614UL) >= 0L) {
        
#line 1465 
        ret_val = 14;
        
#line 1466 
        goto ldv_54837;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1424 
  j += 1;
  ldv_54845: 
#line 1425 
  ;
  
#line 1424 
  if (j <= lc) 
#line 1426 
               goto ldv_54844; else 
#line 1429 
                                    goto ldv_54837;
  ldv_54837: 
#line 1430 
  ;
  
#line 1469 
  return ret_val;
}


#line 1472  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  
#line 1474 
  tmp = e1000_setup_desc_rings(adapter);
  
#line 1474 
  *data = (unsigned long long)tmp;
  
#line 1475 
  if (*data != 0ULL) 
#line 1476 
                     goto out; else ;
  
#line 1477 
  tmp_0 = e1000_setup_loopback_test(adapter);
  
#line 1477 
  *data = (unsigned long long)tmp_0;
  
#line 1478 
  if (*data != 0ULL) 
#line 1479 
                     goto err_loopback; else ;
  
#line 1480 
  tmp_1 = e1000_run_loopback_test(adapter);
  
#line 1480 
  *data = (unsigned long long)tmp_1;
  
#line 1481 
  e1000_loopback_cleanup(adapter);
  err_loopback: 
#line 1483 
  ;
  
#line 1484 
  e1000_free_desc_rings(adapter);
  out: 
#line 1485 
  ;
  
#line 1486 
  __retres = (int)*data;
  
#line 1486 
  return __retres;
}


#line 1489  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_link_test(struct e1000_adapter *adapter, u64 *data)
{
  int __retres;
  
#line 1491 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1492 
  *data = 0ULL;
  
#line 1493 
  if (hw->media_type == (unsigned int)e1000_media_type_internal_serdes) {
    int tmp;
    
#line 1494 
    int i = 0;
    
#line 1496 
    hw->serdes_has_link = (_Bool)0;
    ldv_54858: 
#line 1497 
    ;
    
#line 1502 
    e1000_check_for_link(hw);
    
#line 1503 
    if ((int)hw->serdes_has_link != 0) {
      
#line 1504 
      __retres = (int)*data;
      
#line 1504 
      goto return_label;
    }
    else ;
    
#line 1505 
    msleep(20U);
    
#line 1506 
    tmp = i;
    
#line 1506 
    i += 1;
    
#line 1506 
    ;
    
#line 1506 
    if (tmp <= 3749) 
#line 1508 
                     goto ldv_54858; else 
#line 1511 
                                          goto ldv_54859;
    ldv_54859: 
#line 1512 
    ;
    
#line 1508 
    *data = 1ULL;
  }
  else {
    unsigned int tmp_0;
    
#line 1510 
    e1000_check_for_link(hw);
    
#line 1511 
    if ((unsigned int)hw->autoneg != 0U) 
#line 1512 
                                         msleep(4000U); else ;
    
#line 1514 
    tmp_0 = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 1514 
    if ((tmp_0 & 2U) == 0U) 
#line 1515 
                            *data = 1ULL; else ;
  }
  
#line 1517 
  __retres = (int)*data;
  return_label: 
#line 1517 
                return __retres;
}


#line 1520  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_get_sset_count(struct net_device *netdev, int sset)
{
  int __retres;
  
#line 1522 
  switch (sset) {
    case 0: 
#line 1523 
    ;
    
#line 1524 
    __retres = 5;
    
#line 1524 
    goto return_label;
    case 1: 
#line 1525 
    ;
    
#line 1526 
    __retres = 46;
    
#line 1526 
    goto return_label;
    default: 
#line 1527 
    ;
    
#line 1528 
    __retres = -95;
    
#line 1528 
    goto return_label;
  }
  return_label: 
#line 1522 
                return __retres;
}


#line 1532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_diag_test(struct net_device *netdev, struct ethtool_test *eth_test, u64 *data)
{
  
#line 1535 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1536 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1537 
  bool if_running = netif_running((struct net_device const *)netdev);
  
#line 1539 
  set_bit(0L,(unsigned long volatile *)(& adapter->flags));
  
#line 1540 
  if (eth_test->flags == 1U) {
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_5;
    
#line 1544 
    u16 autoneg_advertised = hw->autoneg_advertised;
    
#line 1545 
    u8 forced_speed_duplex = hw->forced_speed_duplex;
    
#line 1546 
    u8 autoneg = hw->autoneg;
    
#line 1548 
    if ((adapter->msg_enable & 8192) != 0) 
#line 1548 
                                           netdev_info((struct net_device const *)adapter->netdev,"offline testing starting\n"); else ;
    
#line 1553 
    tmp_1 = e1000_link_test(adapter,data + 4U);
    
#line 1553 
    if (tmp_1 != 0) 
#line 1554 
                    eth_test->flags |= 2U; else ;
    
#line 1556 
    if ((int)if_running != 0) 
#line 1558 
                              dev_close(netdev); else 
#line 1560 
                                                      e1000_reset(adapter);
    
#line 1562 
    tmp_2 = e1000_reg_test(adapter,data);
    
#line 1562 
    if (tmp_2 != 0) 
#line 1563 
                    eth_test->flags |= 2U; else ;
    
#line 1565 
    e1000_reset(adapter);
    
#line 1566 
    tmp_3 = e1000_eeprom_test(adapter,data + 1U);
    
#line 1566 
    if (tmp_3 != 0) 
#line 1567 
                    eth_test->flags |= 2U; else ;
    
#line 1569 
    e1000_reset(adapter);
    
#line 1570 
    tmp_4 = e1000_intr_test(adapter,data + 2U);
    
#line 1570 
    if (tmp_4 != 0) 
#line 1571 
                    eth_test->flags |= 2U; else ;
    
#line 1573 
    e1000_reset(adapter);
    
#line 1575 
    e1000_power_up_phy(adapter);
    
#line 1576 
    tmp_5 = e1000_loopback_test(adapter,data + 3U);
    
#line 1576 
    if (tmp_5 != 0) 
#line 1577 
                    eth_test->flags |= 2U; else ;
    
#line 1580 
    hw->autoneg_advertised = autoneg_advertised;
    
#line 1581 
    hw->forced_speed_duplex = forced_speed_duplex;
    
#line 1582 
    hw->autoneg = autoneg;
    
#line 1584 
    e1000_reset(adapter);
    
#line 1585 
    set_bit(0L,(unsigned long volatile *)(& adapter->flags));
    
#line 1586 
    if ((int)if_running != 0) 
#line 1587 
                              dev_open(netdev); else ;
  }
  else {
    int tmp_6;
    
#line 1589 
    if ((adapter->msg_enable & 8192) != 0) 
#line 1589 
                                           netdev_info((struct net_device const *)adapter->netdev,"online testing starting\n"); else ;
    
#line 1591 
    tmp_6 = e1000_link_test(adapter,data + 4U);
    
#line 1591 
    if (tmp_6 != 0) 
#line 1592 
                    eth_test->flags |= 2U; else ;
    
#line 1595 
    *data = 0ULL;
    
#line 1596 
    *(data + 1U) = 0ULL;
    
#line 1597 
    *(data + 2U) = 0ULL;
    
#line 1598 
    *(data + 3U) = 0ULL;
    
#line 1600 
    set_bit(0L,(unsigned long volatile *)(& adapter->flags));
  }
  
#line 1602 
  msleep_interruptible(4000U);
  
#line 1603 
  return;
}


#line 1605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_wol_exclusion(struct e1000_adapter *adapter, struct ethtool_wolinfo *wol)
{
  
#line 1608 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1609 
  int retval = 1;
  
#line 1611 
  switch ((int)hw->device_id) {
    unsigned int tmp;
    unsigned int tmp_0;
    case 4096: 
#line 1612 
    ;
    case 4097: 
#line 1613 
    ;
    case 4100: 
#line 1614 
    ;
    case 4105: 
#line 1615 
    ;
    case 4125: 
#line 1616 
    ;
    case 4113: 
#line 1617 
    ;
    case 4111: 
#line 1618 
    ;
    case 4249: 
#line 1619 
    ;
    case 4234: 
#line 1620 
    ;
    
#line 1622 
    wol->supported = 0U;
    
#line 1623 
    goto ldv_54899;
    case 4114: 
#line 1624 
    ;
    case 4218: 
#line 1625 
    ;
    
#line 1627 
    tmp = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 1627 
    if ((tmp & 4U) != 0U) {
      
#line 1628 
      wol->supported = 0U;
      
#line 1629 
      goto ldv_54899;
    }
    else ;
    
#line 1632 
    retval = 0;
    
#line 1633 
    goto ldv_54899;
    case 4277: 
#line 1634 
    ;
    
#line 1636 
    if (! adapter->quad_port_a) {
      
#line 1637 
      wol->supported = 0U;
      
#line 1638 
      goto ldv_54899;
    }
    else ;
    
#line 1641 
    retval = 0;
    
#line 1642 
    goto ldv_54899;
    default: 
#line 1643 
    ;
    
#line 1648 
    tmp_0 = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 1648 
    if ((tmp_0 & 4U) != 0U) {
      
#line 1648 
      if (adapter->eeprom_wol == 0U) {
        
#line 1650 
        wol->supported = 0U;
        
#line 1651 
        goto ldv_54899;
      }
      else ;
    }
    else ;
    
#line 1654 
    retval = 0;
  }
  ldv_54899: 
#line 1657 
  ;
  
#line 1657 
  return retval;
}


#line 1660  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
  int tmp_0;
  
#line 1663 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1664 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1666 
  wol->supported = 46U;
  
#line 1667 
  wol->wolopts = 0U;
  
#line 1672 
  tmp_0 = e1000_wol_exclusion(adapter,wol);
  
#line 1672 
  if (tmp_0 != 0) 
#line 1674 
                  goto return_label;
  else {
    int tmp_2;
    bool tmp_1;
    
#line 1673 
    tmp_1 = device_can_wakeup(& (adapter->pdev)->dev);
    
#line 1673 
    if (tmp_1) 
#line 1673 
               tmp_2 = 0; else 
#line 1673 
                               tmp_2 = 1;
    
#line 1673 
    if (tmp_2) 
#line 1674 
               goto return_label; else ;
  }
  
#line 1677 
  switch ((int)hw->device_id) {
    case 4277: 
#line 1678 
    ;
    
#line 1680 
    wol->supported &= 4294967293U;
    
#line 1682 
    if ((adapter->wol & 4U) != 0U) {
      
#line 1683 
      if ((adapter->msg_enable & 1) != 0) 
#line 1683 
                                          netdev_err((struct net_device const *)adapter->netdev,"Interface does not support directed "); else ;
    }
    else ;
    
#line 1685 
    goto ldv_54911;
    default: 
#line 1686 
    ;
    
#line 1687 
    goto ldv_54911;
  }
  ldv_54911: 
#line 1690 
  ;
  
#line 1690 
  if ((adapter->wol & 4U) != 0U) 
#line 1691 
                                 wol->wolopts |= 2U; else ;
  
#line 1692 
  if ((adapter->wol & 8U) != 0U) 
#line 1693 
                                 wol->wolopts |= 4U; else ;
  
#line 1694 
  if ((adapter->wol & 16U) != 0U) 
#line 1695 
                                  wol->wolopts |= 8U; else ;
  
#line 1696 
  if ((adapter->wol & 2U) != 0U) 
#line 1697 
                                 wol->wolopts |= 32U; else ;
  return_label: 
#line 1698 
                return;
}


#line 1700  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
  int __retres;
  int tmp_1;
  
#line 1702 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1703 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1705 
  if ((wol->wolopts & 81U) != 0U) {
    
#line 1706 
    __retres = -95;
    
#line 1706 
    goto return_label;
  }
  else ;
  
#line 1708 
  tmp_1 = e1000_wol_exclusion(adapter,wol);
  
#line 1708 
  if (tmp_1 != 0) 
#line 1708 
                  goto _LOR;
  else {
    int tmp_3;
    bool tmp_2;
    
#line 1709 
    tmp_2 = device_can_wakeup(& (adapter->pdev)->dev);
    
#line 1709 
    if (tmp_2) 
#line 1709 
               tmp_3 = 0; else 
#line 1709 
                               tmp_3 = 1;
    
#line 1709 
    if (tmp_3) {
      int tmp_0;
      _LOR: 
#line 1710 
      ;
      
#line 1710 
      if (wol->wolopts != 0U) 
#line 1710 
                              tmp_0 = -95; else 
#line 1710 
                                                tmp_0 = 0;
      
#line 1710 
      __retres = tmp_0;
      
#line 1710 
      goto return_label;
    }
    else ;
  }
  
#line 1712 
  switch ((int)hw->device_id) {
    case 4277: 
#line 1713 
    ;
    
#line 1714 
    if ((wol->wolopts & 2U) != 0U) {
      
#line 1715 
      if ((adapter->msg_enable & 1) != 0) 
#line 1715 
                                          netdev_err((struct net_device const *)adapter->netdev,"Interface does not support directed "); else ;
      
#line 1717 
      __retres = -95;
      
#line 1717 
      goto return_label;
    }
    else ;
    
#line 1719 
    goto ldv_54920;
    default: 
#line 1720 
    ;
    
#line 1721 
    goto ldv_54920;
  }
  ldv_54920: 
#line 1725 
  ;
  
#line 1725 
  adapter->wol = 0U;
  
#line 1727 
  if ((wol->wolopts & 2U) != 0U) 
#line 1728 
                                 adapter->wol |= 4U; else ;
  
#line 1729 
  if ((wol->wolopts & 4U) != 0U) 
#line 1730 
                                 adapter->wol |= 8U; else ;
  
#line 1731 
  if ((wol->wolopts & 8U) != 0U) 
#line 1732 
                                 adapter->wol |= 16U; else ;
  
#line 1733 
  if ((wol->wolopts & 32U) != 0U) 
#line 1734 
                                  adapter->wol |= 2U; else ;
  
#line 1736 
  device_set_wakeup_enable(& (adapter->pdev)->dev,(_Bool)(adapter->wol != 0U));
  
#line 1738 
  __retres = 0;
  return_label: 
#line 1738 
                return __retres;
}


#line 1741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_set_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)
{
  int __retres;
  
#line 1744 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1745 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1747 
  switch ((unsigned int)state) {
    case (unsigned int)1: 
#line 1748 
    ;
    
#line 1749 
    e1000_setup_led(hw);
    
#line 1750 
    __retres = 2;
    
#line 1750 
    goto return_label;
    case (unsigned int)2: 
#line 1752 
    ;
    
#line 1753 
    e1000_led_on(hw);
    
#line 1754 
    goto ldv_54930;
    case (unsigned int)3: 
#line 1756 
    ;
    
#line 1757 
    e1000_led_off(hw);
    
#line 1758 
    goto ldv_54930;
    case (unsigned int)0: 
#line 1760 
    ;
    
#line 1761 
    e1000_cleanup_led(hw);
  }
  ldv_54930: 
#line 1764 
  ;
  
#line 1764 
  __retres = 0;
  return_label: 
#line 1764 
                return __retres;
}


#line 1767  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
{
  int __retres;
  
#line 1770 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1772 
  if (adapter->hw.mac_type <= (unsigned int)e1000_82540) {
    
#line 1773 
    __retres = -95;
    
#line 1773 
    goto return_label;
  }
  else ;
  
#line 1775 
  if (adapter->itr_setting <= 4U) 
#line 1776 
                                  ec->rx_coalesce_usecs = adapter->itr_setting; else 
                                                                    
#line 1778 
                                                                    ec->rx_coalesce_usecs = 1000000U / adapter->itr_setting;
  
#line 1780 
  __retres = 0;
  return_label: 
#line 1780 
                return __retres;
}


#line 1783  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
{
  int __retres;
  
#line 1786 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1787 
  struct e1000_hw *hw = & adapter->hw;
  
#line 1789 
  if (hw->mac_type <= (unsigned int)e1000_82540) {
    
#line 1790 
    __retres = -95;
    
#line 1790 
    goto return_label;
  }
  else ;
  
#line 1792 
  if ((ec->rx_coalesce_usecs > 10000U || ec->rx_coalesce_usecs + 4294967291U <= 4U) || ec->rx_coalesce_usecs == 2U) {
    
#line 1796 
    __retres = -22;
    
#line 1796 
    goto return_label;
  }
  else ;
  
#line 1798 
  if (ec->rx_coalesce_usecs == 4U) {
    u32 tmp_0;
    
#line 1799 
    tmp_0 = 4U;
    
#line 1799 
    adapter->itr_setting = tmp_0;
    
#line 1799 
    adapter->itr = tmp_0;
  }
  else 
    
#line 1800 
    if (ec->rx_coalesce_usecs <= 3U) {
      
#line 1801 
      adapter->itr = 20000U;
      
#line 1802 
      adapter->itr_setting = ec->rx_coalesce_usecs;
    }
    else {
      
#line 1804 
      adapter->itr = 1000000U / ec->rx_coalesce_usecs;
      
#line 1805 
      adapter->itr_setting = adapter->itr & 4294967292U;
    }
  
#line 1808 
  if (adapter->itr_setting != 0U) 
#line 1809 
                                  writel(1000000000U / (adapter->itr * 256U),(void volatile *)(hw->hw_addr + 196U)); else 
                                                                    
#line 1811 
                                                                    writel(0U,(void volatile *)(hw->hw_addr + 196U));
  
#line 1813 
  __retres = 0;
  return_label: 
#line 1813 
                return __retres;
}


#line 1816  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static int e1000_nway_reset(struct net_device *netdev)
{
  int __retres;
  bool tmp_0;
  
#line 1818 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1820 
  tmp_0 = netif_running((struct net_device const *)netdev);
  
#line 1820 
  if ((int)tmp_0 != 0) 
#line 1821 
                       e1000_reinit_locked(adapter); else ;
  
#line 1822 
  __retres = 0;
  
#line 1822 
  return __retres;
}


#line 1825  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_get_ethtool_stats(struct net_device *netdev, struct ethtool_stats *stats, u64 *data)
{
  int i;
  
#line 1828 
  struct e1000_adapter *adapter = netdev_priv((struct net_device const *)netdev);
  
#line 1830 
  char *p = (char *)0;
  
#line 1831 
  struct e1000_stats const *stat = (struct e1000_stats const *)(& e1000_gstrings_stats);
  
#line 1833 
  e1000_update_stats(adapter);
  
#line 1834 
  i = 0;
  
#line 1834 
  goto ldv_54970;
  ldv_54969: 
#line 1835 
  ;
  
#line 1835 
  switch (stat->type) {
    case 0: 
#line 1836 
    ;
    
#line 1837 
    p = (char *)netdev + stat->stat_offset;
    
#line 1838 
    goto ldv_54961;
    case 1: 
#line 1839 
    ;
    
#line 1840 
    p = (char *)adapter + stat->stat_offset;
    
#line 1841 
    goto ldv_54961;
    default: 
#line 1842 
    ;
    {
      bool __warned;
      
#line 1843 
      int __ret_warn_once = 1;
      
#line 1843 
      if ((long)(__ret_warn_once != 0) != 0L) {
        int tmp_0;
        {
          
#line 1843 
          int __ret_warn_on = ! __warned;
          
#line 1843 
          if ((long)(__ret_warn_on != 0) != 0L) 
#line 1843 
                                                warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c",1844,"Invalid E1000 stat type: %u index %d\n",stat->type,i); else ;
          
#line 1843 
          tmp_0 = (long)(__ret_warn_on != 0);
        }
        
#line 1843 
        if ((long)tmp_0 != 0L) 
#line 1843 
                               __warned = (_Bool)1; else ;
      }
      else ;
      
#line 1843 
      long tmp_2 = (long)(__ret_warn_once != 0);
    }
    
#line 1845 
    goto ldv_54961;
  }
  ldv_54961: 
#line 1848 
  ;
  
#line 1848 
  if (stat->sizeof_stat == 8) 
#line 1849 
                              *(data + i) = *((u64 *)p); else 
#line 1851 
                                                              *(data + i) = (unsigned long long)*((u32 *)p);
  
#line 1853 
  stat += 1;
  
#line 1834 
  i += 1;
  ldv_54970: 
#line 1835 
  ;
  
#line 1834 
  if ((unsigned int)i <= 45U) 
#line 1836 
                              goto ldv_54969; else 
#line 1839 
                                                   goto ldv_54971;
  ldv_54971: 
#line 1840 
  ;
  
#line 1841 
  return;
}


#line 1858  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static void e1000_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
{
  int i;
  
#line 1861 
  u8 *p = data;
  
#line 1864 
  switch (stringset) {
    case (u32)0: 
#line 1865 
    ;
    
#line 1866 
    memcpy((void *)data,(void const *)(& e1000_gstrings_test),160UL);
    
#line 1867 
    goto ldv_54980;
    case (u32)1: 
#line 1868 
    ;
    
#line 1869 
    i = 0;
    
#line 1869 
    goto ldv_54986;
    ldv_54985: 
#line 1870 
    ;
    
#line 1870 
    memcpy((void *)p,(void const *)(& e1000_gstrings_stats[i].stat_string),32UL);
    
#line 1872 
    p += 32U;
    
#line 1869 
    i += 1;
    ldv_54986: 
#line 1870 
    ;
    
#line 1869 
    if ((unsigned int)i <= 45U) 
#line 1871 
                                goto ldv_54985; else 
#line 1874 
                                                     goto ldv_54987;
    ldv_54987: 
#line 1875 
    ;
    
#line 1875 
    goto ldv_54980;
  }
  ldv_54980: 
#line 1877 
  ;
  
#line 1878 
  return;
}


#line 1879  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
static struct ethtool_ops const e1000_ethtool_ops = {.get_settings = & e1000_get_settings, .set_settings = & e1000_set_settings, .get_drvinfo = & e1000_get_drvinfo, .get_regs_len = & e1000_get_regs_len, .get_regs = & e1000_get_regs, .get_wol = & e1000_get_wol, .set_wol = & e1000_set_wol, .get_msglevel = & e1000_get_msglevel, .set_msglevel = & e1000_set_msglevel, .nway_reset = & e1000_nway_reset, .get_link = & e1000_get_link, .get_eeprom_len = & e1000_get_eeprom_len, .get_eeprom = & e1000_get_eeprom, .set_eeprom = & e1000_set_eeprom, .get_coalesce = & e1000_get_coalesce, .set_coalesce = & e1000_set_coalesce, .get_ringparam = & e1000_get_ringparam, .set_ringparam = & e1000_set_ringparam, .get_pauseparam = & e1000_get_pauseparam, .set_pauseparam = & e1000_set_pauseparam, .self_test = & e1000_diag_test, .get_strings = & e1000_get_strings, .set_phys_id = & e1000_set_phys_id, .get_ethtool_stats = & e1000_get_ethtool_stats, .begin = (int (*)(struct net_device *))0, .complete = (void (*)(struct net_device *))0, .get_priv_flags = (u32 (*)(struct net_device *))0, .set_priv_flags = (int (*)(struct net_device *, u32 ))0, .get_sset_count = & e1000_get_sset_count, .get_rxnfc = (int (*)(struct net_device *, struct ethtool_rxnfc *, u32 *))0, .set_rxnfc = (int (*)(struct net_device *, struct ethtool_rxnfc *))0, .flash_device = (int (*)(struct net_device *, struct ethtool_flash *))0, .reset = (int (*)(struct net_device *, u32 *))0, .get_rxfh_key_size = (u32 (*)(struct net_device *))0, .get_rxfh_indir_size = (u32 (*)(struct net_device *))0, .get_rxfh = (int (*)(struct net_device *, u32 *, u8 *, u8 *))0, .set_rxfh = (int (*)(struct net_device *, u32 const *, u8 const *, u8 const ))0, .get_channels = (void (*)(struct net_device *, struct ethtool_channels *))0, .set_channels = (int (*)(struct net_device *, struct ethtool_channels *))0, .get_dump_flag = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_dump_data = (int (*)(struct net_device *, struct ethtool_dump *, void *))0, .set_dump = (int (*)(struct net_device *, struct ethtool_dump *))0, .get_ts_info = & ethtool_op_get_ts_info, .get_module_info = (int (*)(struct net_device *, struct ethtool_modinfo *))0, .get_module_eeprom = (int (*)(struct net_device *, struct ethtool_eeprom *, u8 *))0, .get_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .set_eee = (int (*)(struct net_device *, struct ethtool_eee *))0, .get_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void *))0, .set_tunable = (int (*)(struct net_device *, struct ethtool_tunable const *, void const *))0};

#line 1908  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_ethtool.c"
void e1000_set_ethtool_ops(struct net_device *netdev)
{
  
#line 1910 
  netdev->ethtool_ops = & e1000_ethtool_ops;
  
#line 1911 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int (*ldv_emg_alias_ethtool_op_get_ts_info_33)(struct net_device *, struct ethtool_ts_info *) = & ethtool_op_get_ts_info;

#line 72  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_set_pauseparam_37(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  int tmp;
  
#line 73 
  tmp = e1000_set_pauseparam(arg0,arg1);
  
#line 73 
  return tmp;
}


#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_get_eeprom_len_40(struct net_device *arg0)
{
  int tmp;
  
#line 78 
  tmp = e1000_get_eeprom_len(arg0);
  
#line 78 
  return tmp;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_get_strings_24(struct net_device *arg0, unsigned int arg1, unsigned char *arg2)
{
  
#line 83 
  e1000_get_strings(arg0,arg1,arg2);
  
#line 84 
  return;
}


#line 87  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_get_coalesce_34(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 88 
  tmp = e1000_get_coalesce(arg0,arg1);
  
#line 88 
  return tmp;
}


#line 92  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_get_eeprom_3(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  int tmp;
  
#line 93 
  tmp = e1000_get_eeprom(arg0,arg1,arg2);
  
#line 93 
  return tmp;
}


#line 97  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_get_wol_25(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  
#line 98 
  e1000_get_wol(arg0,arg1);
  
#line 99 
  return;
}


#line 102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_get_sset_count_30(struct net_device *arg0, int arg1)
{
  int tmp;
  
#line 103 
  tmp = e1000_get_sset_count(arg0,arg1);
  
#line 103 
  return tmp;
}


#line 107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_set_msglevel_6(struct net_device *arg0, unsigned int arg1)
{
  
#line 108 
  e1000_set_msglevel(arg0,arg1);
  
#line 109 
  return;
}


#line 112  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_set_ringparam_17(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  int tmp;
  
#line 113 
  tmp = e1000_set_ringparam(arg0,arg1);
  
#line 113 
  return tmp;
}


#line 117  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_get_settings_21(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 118 
  tmp = e1000_get_settings(arg0,arg1);
  
#line 118 
  return tmp;
}


#line 122  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
unsigned int ldv_emg_wrapper_e1000_get_msglevel_18(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 123 
  tmp = e1000_get_msglevel(arg0);
  
#line 123 
  return tmp;
}


#line 127  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_get_ringparam_12(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  
#line 128 
  e1000_get_ringparam(arg0,arg1);
  
#line 129 
  return;
}


#line 132  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_set_phys_id_5(struct net_device *arg0, enum ethtool_phys_id_state arg1)
{
  int tmp;
  
#line 133 
  tmp = e1000_set_phys_id(arg0,arg1);
  
#line 133 
  return tmp;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
unsigned int ldv_emg_wrapper_e1000_get_link_11(struct net_device *arg0)
{
  unsigned int tmp;
  
#line 138 
  tmp = e1000_get_link(arg0);
  
#line 138 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_set_eeprom_16(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  int tmp;
  
#line 143 
  tmp = e1000_set_eeprom(arg0,arg1,arg2);
  
#line 143 
  return tmp;
}


#line 147  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_nway_reset_32(struct net_device *arg0)
{
  int tmp;
  
#line 148 
  tmp = e1000_nway_reset(arg0);
  
#line 148 
  return tmp;
}


#line 152  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_set_settings_4(struct net_device *arg0, struct ethtool_cmd *arg1)
{
  int tmp;
  
#line 153 
  tmp = e1000_set_settings(arg0,arg1);
  
#line 153 
  return tmp;
}


#line 157  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_get_regs_29(struct net_device *arg0, struct ethtool_regs *arg1, void *arg2)
{
  
#line 158 
  e1000_get_regs(arg0,arg1,arg2);
  
#line 159 
  return;
}


#line 162  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
enum irqreturn ldv_emg_wrapper_e1000_test_intr_2(int arg0, void *arg1)
{
  enum irqreturn tmp;
  
#line 163 
  tmp = e1000_test_intr(arg0,arg1);
  
#line 163 
  return tmp;
}


#line 167  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_get_pauseparam_2(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  
#line 168 
  e1000_get_pauseparam(arg0,arg1);
  
#line 169 
  return;
}


#line 172  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_set_coalesce_36(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  int tmp;
  
#line 173 
  tmp = e1000_set_coalesce(arg0,arg1);
  
#line 173 
  return tmp;
}


#line 177  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_get_ethtool_stats_9(struct net_device *arg0, struct ethtool_stats *arg1, unsigned long long *arg2)
{
  
#line 178 
  e1000_get_ethtool_stats(arg0,arg1,arg2);
  
#line 179 
  return;
}


#line 182  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_diag_test_23(struct net_device *arg0, struct ethtool_test *arg1, unsigned long long *arg2)
{
  
#line 183 
  e1000_diag_test(arg0,arg1,arg2);
  
#line 184 
  return;
}


#line 187  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_set_wol_28(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  int tmp;
  
#line 188 
  tmp = e1000_set_wol(arg0,arg1);
  
#line 188 
  return tmp;
}


#line 192  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
int ldv_emg_wrapper_e1000_get_regs_len_35(struct net_device *arg0)
{
  int tmp;
  
#line 193 
  tmp = e1000_get_regs_len(arg0);
  
#line 193 
  return tmp;
}


#line 197  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
void ldv_emg_wrapper_e1000_get_drvinfo_14(struct net_device *arg0, struct ethtool_drvinfo *arg1)
{
  
#line 198 
  e1000_get_drvinfo(arg0,arg1);
  
#line 199 
  return;
}


#line 616  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
static void *kmalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 619 
  tmp = ldv_kmalloc(size,flags);
  
#line 619 
  return tmp;
}


#line 630  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 633 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 633 
  return tmp;
}


#line 637  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 640 
  tmp = ldv_kzalloc(size,flags);
  
#line 640 
  return tmp;
}


#line 923  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
static int ldv_request_irq_77(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 927 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 927 
  return tmp;
}


#line 931  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
static int ldv_request_irq_78(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char const *name, void *dev)
{
  int tmp;
  
#line 935 
  tmp = ldv_emg_request_irq(irq,handler,flags,(char *)name,dev);
  
#line 935 
  return tmp;
}


#line 939  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_ethtool.c.aux"
static void ldv_free_irq_79(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 943 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 944 
  return;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_0(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_83(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_85(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_0(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_84(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_86(spinlock_t *lock);


#line 462  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_0(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 464 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 465 
  return;
}


#line 494 
static void ldv_spin_unlock_irqrestore_78(spinlock_t *lock, unsigned long flags);


#line 498 
static void ldv_spin_unlock_irqrestore_79(spinlock_t *lock, unsigned long flags);


#line 502 
static void ldv_spin_unlock_irqrestore_81(spinlock_t *lock, unsigned long flags);


#line 506 
static void ldv_spin_unlock_irqrestore_82(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv___ldv_spin_lock_77(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_80(spinlock_t *ldv_func_arg1);


#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void *phys_to_virt(phys_addr_t address)
{
  void *__retres;
  
#line 138 
  __retres = (void *)((unsigned long)address + 18446612132314218496UL);
  
#line 138 
  return __retres;
}


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/iomap.h"
void ioread16_rep(void *, void *, unsigned long);


#line 56 
void iowrite16_rep(void *, void const *, unsigned long);


#line 5  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __bad_udelay(void);


#line 8 
void __udelay(unsigned long);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_check_downshift(struct e1000_hw *hw);


#line 36 
static s32 e1000_check_polarity(struct e1000_hw *hw, e1000_rev_polarity *polarity);


#line 38 
static void e1000_clear_hw_cntrs(struct e1000_hw *hw);


#line 39 
static void e1000_clear_vfta(struct e1000_hw *hw);


#line 40 
static s32 e1000_config_dsp_after_link_change(struct e1000_hw *hw, bool link_up);


#line 42 
static s32 e1000_config_fc_after_link_up(struct e1000_hw *hw);


#line 43 
static s32 e1000_detect_gig_phy(struct e1000_hw *hw);


#line 44 
static s32 e1000_get_auto_rd_done(struct e1000_hw *hw);


#line 45 
static s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length, u16 *max_length);


#line 47 
static s32 e1000_get_phy_cfg_done(struct e1000_hw *hw);


#line 48 
static s32 e1000_id_led_init(struct e1000_hw *hw);


#line 49 
static void e1000_init_rx_addrs(struct e1000_hw *hw);


#line 50 
static s32 e1000_phy_igp_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info);


#line 52 
static s32 e1000_phy_m88_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info);


#line 54 
static s32 e1000_set_d3_lplu_state(struct e1000_hw *hw, bool active);


#line 55 
static s32 e1000_wait_autoneg(struct e1000_hw *hw);


#line 56 
static void e1000_write_reg_io(struct e1000_hw *hw, u32 offset, u32 value);


#line 57 
static s32 e1000_set_phy_type(struct e1000_hw *hw);


#line 58 
static void e1000_phy_init_script(struct e1000_hw *hw);


#line 59 
static s32 e1000_setup_copper_link(struct e1000_hw *hw);


#line 60 
static s32 e1000_setup_fiber_serdes_link(struct e1000_hw *hw);


#line 61 
static s32 e1000_adjust_serdes_amplitude(struct e1000_hw *hw);


#line 62 
static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw);


#line 63 
static s32 e1000_config_mac_to_phy(struct e1000_hw *hw);


#line 64 
static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl);


#line 65 
static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl);


#line 66 
static void e1000_shift_out_mdi_bits(struct e1000_hw *hw, u32 data, u16 count);


#line 67 
static u16 e1000_shift_in_mdi_bits(struct e1000_hw *hw);


#line 68 
static s32 e1000_phy_reset_dsp(struct e1000_hw *hw);


#line 69 
static s32 e1000_write_eeprom_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data);


#line 71 
static s32 e1000_write_eeprom_microwire(struct e1000_hw *hw, u16 offset, u16 words, u16 *data);


#line 73 
static s32 e1000_spi_eeprom_ready(struct e1000_hw *hw);


#line 74 
static void e1000_raise_ee_clk(struct e1000_hw *hw, u32 *eecd);


#line 75 
static void e1000_lower_ee_clk(struct e1000_hw *hw, u32 *eecd);


#line 76 
static void e1000_shift_out_ee_bits(struct e1000_hw *hw, u16 data, u16 count);


#line 77 
static s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr, u16 phy_data);


#line 79 
static s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data);


#line 81 
static u16 e1000_shift_in_ee_bits(struct e1000_hw *hw, u16 count);


#line 82 
static s32 e1000_acquire_eeprom(struct e1000_hw *hw);


#line 83 
static void e1000_release_eeprom(struct e1000_hw *hw);


#line 84 
static void e1000_standby_eeprom(struct e1000_hw *hw);


#line 85 
static s32 e1000_set_vco_speed(struct e1000_hw *hw);


#line 86 
static s32 e1000_polarity_reversal_workaround(struct e1000_hw *hw);


#line 87 
static s32 e1000_set_phy_mode(struct e1000_hw *hw);


#line 88 
static s32 e1000_do_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data);


#line 90 
static s32 e1000_do_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data);


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static u16 const e1000_igp_cable_length_table[128U] = {(unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)5U, (unsigned short)10U, (unsigned short)10U, (unsigned short)10U, (unsigned short)10U, (unsigned short)10U, (unsigned short)10U, (unsigned short)10U, (unsigned short)20U, (unsigned short)20U, (unsigned short)20U, (unsigned short)20U, (unsigned short)20U, (unsigned short)25U, (unsigned short)25U, (unsigned short)25U, (unsigned short)25U, (unsigned short)25U, (unsigned short)25U, (unsigned short)25U, (unsigned short)30U, (unsigned short)30U, (unsigned short)30U, (unsigned short)30U, (unsigned short)40U, (unsigned short)40U, (unsigned short)40U, (unsigned short)40U, (unsigned short)40U, (unsigned short)40U, (unsigned short)40U, (unsigned short)40U, (unsigned short)40U, (unsigned short)50U, (unsigned short)50U, (unsigned short)50U, (unsigned short)50U, (unsigned short)50U, (unsigned short)50U, (unsigned short)50U, (unsigned short)60U, (unsigned short)60U, (unsigned short)60U, (unsigned short)60U, (unsigned short)60U, (unsigned short)60U, (unsigned short)60U, (unsigned short)60U, (unsigned short)60U, (unsigned short)70U, (unsigned short)70U, (unsigned short)70U, (unsigned short)70U, (unsigned short)70U, (unsigned short)70U, (unsigned short)80U, (unsigned short)80U, (unsigned short)80U, (unsigned short)80U, (unsigned short)80U, (unsigned short)80U, (unsigned short)90U, (unsigned short)90U, (unsigned short)90U, (unsigned short)90U, (unsigned short)90U, (unsigned short)90U, (unsigned short)90U, (unsigned short)90U, (unsigned short)90U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)100U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)110U, (unsigned short)120U, (unsigned short)120U, (unsigned short)120U, (unsigned short)120U, (unsigned short)120U, (unsigned short)120U, (unsigned short)120U, (unsigned short)120U, (unsigned short)120U, (unsigned short)120U};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static spinlock_t e1000_eeprom_lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 3735899821U, .owner_cpu = 4294967295U, .owner = (void *)(-1), .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = "e1000_eeprom_lock", .cpu = 0, .ip = 0UL}}}};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static spinlock_t e1000_phy_lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 3735899821U, .owner_cpu = 4294967295U, .owner = (void *)(-1), .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = "e1000_phy_lock", .cpu = 0, .ip = 0UL}}}};

#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_set_phy_type(struct e1000_hw *hw)
{
  s32 __retres;
  
#line 118 
  if (hw->mac_type == (unsigned int)e1000_undefined) {
    
#line 119 
    __retres = -6;
    
#line 119 
    goto return_label;
  }
  else ;
  
#line 121 
  switch (hw->phy_id) {
    case (u32)21040208: 
#line 122 
    ;
    case (u32)21040176: 
#line 123 
    ;
    case (u32)21040160: 
#line 124 
    ;
    case (u32)21040320: 
#line 125 
    ;
    case (u32)21040704: 
#line 126 
    ;
    
#line 127 
    hw->phy_type = 0;
    
#line 128 
    goto ldv_54607;
    case (u32)44565376: 
#line 129 
    ;
    
#line 132 
    if ((unsigned int)hw->mac_type + 4294967285U <= 3U) 
#line 134 
                                                        hw->phy_type = 1; else ;
    
#line 135 
    goto ldv_54607;
    case (u32)1886480: 
#line 136 
    ;
    
#line 137 
    hw->phy_type = 2;
    
#line 138 
    goto ldv_54607;
    case (u32)33280: 
#line 139 
    ;
    
#line 140 
    hw->phy_type = 3;
    
#line 141 
    goto ldv_54607;
    default: 
#line 142 
    ;
    
#line 144 
    hw->phy_type = 255;
    
#line 145 
    __retres = -6;
    
#line 145 
    goto return_label;
  }
  ldv_54607: 
#line 148 
  ;
  
#line 148 
  __retres = 0;
  return_label: 
#line 148 
                return __retres;
}


#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_phy_init_script(struct e1000_hw *hw)
{
  u32 ret_val;
  u16 phy_saved_data;
  
#line 160 
  if (hw->phy_init_script != 0U) {
    s32 tmp;
    
#line 161 
    msleep(20U);
    
#line 166 
    tmp = e1000_read_phy_reg(hw,12123U,& phy_saved_data);
    
#line 166 
    ret_val = (unsigned int)tmp;
    
#line 169 
    e1000_write_phy_reg(hw,12123U,(unsigned short)3);
    
#line 170 
    msleep(20U);
    
#line 172 
    e1000_write_phy_reg(hw,0U,(unsigned short)320);
    
#line 173 
    msleep(5U);
    
#line 175 
    switch ((unsigned int)hw->mac_type) {
      case (unsigned int)11: 
#line 176 
      ;
      case (unsigned int)13: 
#line 177 
      ;
      
#line 178 
      e1000_write_phy_reg(hw,8085U,(unsigned short)1);
      
#line 179 
      e1000_write_phy_reg(hw,8049U,(unsigned short)48417);
      
#line 180 
      e1000_write_phy_reg(hw,8057U,(unsigned short)24);
      
#line 181 
      e1000_write_phy_reg(hw,7984U,(unsigned short)5632);
      
#line 182 
      e1000_write_phy_reg(hw,7985U,(unsigned short)20);
      
#line 183 
      e1000_write_phy_reg(hw,7986U,(unsigned short)5660);
      
#line 184 
      e1000_write_phy_reg(hw,8084U,(unsigned short)3);
      
#line 185 
      e1000_write_phy_reg(hw,8086U,(unsigned short)63);
      
#line 186 
      e1000_write_phy_reg(hw,8208U,(unsigned short)8);
      
#line 187 
      goto ldv_54619;
      case (unsigned int)12: 
#line 189 
      ;
      case (unsigned int)14: 
#line 190 
      ;
      
#line 191 
      e1000_write_phy_reg(hw,8051U,(unsigned short)153);
      
#line 192 
      goto ldv_54619;
      default: 
#line 193 
      ;
      
#line 194 
      goto ldv_54619;
    }
    ldv_54619: 
#line 197 
    ;
    
#line 197 
    e1000_write_phy_reg(hw,0U,(unsigned short)13056);
    
#line 198 
    msleep(20U);
    
#line 201 
    e1000_write_phy_reg(hw,12123U,(unsigned short)((int)phy_saved_data));
    
#line 203 
    if (hw->mac_type == (unsigned int)e1000_82547) {
      u16 fused;
      u16 fine;
      u16 coarse;
      
#line 207 
      e1000_read_phy_reg(hw,8401U,& fused);
      
#line 211 
      if (((int)fused & 256) == 0) {
        
#line 212 
        e1000_read_phy_reg(hw,8400U,& fused);
        
#line 216 
        fine = (unsigned short)((unsigned int)fused & 3968U);
        
#line 217 
        coarse = (unsigned short)((unsigned int)fused & 112U);
        
#line 220 
        if ((unsigned int)coarse > 64U) {
          
#line 222 
          coarse = (unsigned short)((unsigned int)coarse + 65520U);
          
#line 224 
          fine = (unsigned short)((unsigned int)fine + 65408U);
        }
        else 
          
#line 225 
          if ((unsigned int)coarse == 64U) 
#line 227 
                                           fine = (unsigned short)((unsigned int)fine + 64256U); else ;
        
#line 229 
        fused = (unsigned short)((((int)fused & -4096) | ((int)fine & 3968)) | ((int)coarse & 112));
        
#line 235 
        e1000_write_phy_reg(hw,8412U,(unsigned short)((int)fused));
        
#line 238 
        e1000_write_phy_reg(hw,8414U,(unsigned short)2);
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 242 
  return;
}


#line 250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
  s32 __retres;
  
#line 252 
  switch ((int)hw->device_id) {
    case 4096: 
#line 253 
    ;
    
#line 254 
    switch ((int)hw->revision_id) {
      case 2: 
#line 255 
      ;
      
#line 256 
      hw->mac_type = e1000_82542_rev2_0;
      
#line 257 
      goto ldv_54631;
      case 3: 
#line 258 
      ;
      
#line 259 
      hw->mac_type = e1000_82542_rev2_1;
      
#line 260 
      goto ldv_54631;
      default: 
#line 261 
      ;
      
#line 263 
      __retres = -5;
      
#line 263 
      goto return_label;
    }
    ldv_54631: 
#line 265 
    ;
    
#line 265 
    goto ldv_54634;
    case 4097: 
#line 266 
    ;
    case 4100: 
#line 267 
    ;
    
#line 268 
    hw->mac_type = e1000_82543;
    
#line 269 
    goto ldv_54634;
    case 4104: 
#line 270 
    ;
    case 4105: 
#line 271 
    ;
    case 4108: 
#line 272 
    ;
    case 4109: 
#line 273 
    ;
    
#line 274 
    hw->mac_type = e1000_82544;
    
#line 275 
    goto ldv_54634;
    case 4110: 
#line 276 
    ;
    case 4117: 
#line 277 
    ;
    case 4119: 
#line 278 
    ;
    case 4118: 
#line 279 
    ;
    case 4126: 
#line 280 
    ;
    
#line 281 
    hw->mac_type = e1000_82540;
    
#line 282 
    goto ldv_54634;
    case 4111: 
#line 283 
    ;
    case 4113: 
#line 284 
    ;
    
#line 285 
    hw->mac_type = e1000_82545;
    
#line 286 
    goto ldv_54634;
    case 4134: 
#line 287 
    ;
    case 4135: 
#line 288 
    ;
    case 4136: 
#line 289 
    ;
    
#line 290 
    hw->mac_type = e1000_82545_rev_3;
    
#line 291 
    goto ldv_54634;
    case 4112: 
#line 292 
    ;
    case 4114: 
#line 293 
    ;
    case 4125: 
#line 294 
    ;
    
#line 295 
    hw->mac_type = e1000_82546;
    
#line 296 
    goto ldv_54634;
    case 4217: 
#line 297 
    ;
    case 4218: 
#line 298 
    ;
    case 4219: 
#line 299 
    ;
    case 4234: 
#line 300 
    ;
    case 4249: 
#line 301 
    ;
    case 4277: 
#line 302 
    ;
    
#line 303 
    hw->mac_type = e1000_82546_rev_3;
    
#line 304 
    goto ldv_54634;
    case 4115: 
#line 305 
    ;
    case 4120: 
#line 306 
    ;
    case 4116: 
#line 307 
    ;
    
#line 308 
    hw->mac_type = e1000_82541;
    
#line 309 
    goto ldv_54634;
    case 4216: 
#line 310 
    ;
    case 4214: 
#line 311 
    ;
    case 4220: 
#line 312 
    ;
    case 4215: 
#line 313 
    ;
    
#line 314 
    hw->mac_type = e1000_82541_rev_2;
    
#line 315 
    goto ldv_54634;
    case 4121: 
#line 316 
    ;
    case 4122: 
#line 317 
    ;
    
#line 318 
    hw->mac_type = e1000_82547;
    
#line 319 
    goto ldv_54634;
    case 4213: 
#line 320 
    ;
    
#line 321 
    hw->mac_type = e1000_82547_rev_2;
    
#line 322 
    goto ldv_54634;
    case 11886: 
#line 323 
    ;
    
#line 324 
    hw->mac_type = e1000_ce4100;
    
#line 325 
    goto ldv_54634;
    default: 
#line 326 
    ;
    
#line 328 
    __retres = -5;
    
#line 328 
    goto return_label;
  }
  ldv_54634: 
#line 331 
  ;
  
#line 331 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)11: 
#line 332 
    ;
    case (unsigned int)13: 
#line 333 
    ;
    case (unsigned int)12: 
#line 334 
    ;
    case (unsigned int)14: 
#line 335 
    ;
    
#line 336 
    hw->asf_firmware_present = 1U;
    
#line 337 
    goto ldv_54676;
    default: 
#line 338 
    ;
    
#line 339 
    goto ldv_54676;
  }
  ldv_54676: 
#line 345 
  ;
  
#line 345 
  if (hw->mac_type == (unsigned int)e1000_82543) 
#line 346 
                                                 hw->bad_tx_carr_stats_fd = (_Bool)1; else ;
  
#line 348 
  if (hw->mac_type > (unsigned int)e1000_82544) 
#line 349 
                                                hw->has_smbus = (_Bool)1; else ;
  
#line 351 
  __retres = 0;
  return_label: 
#line 351 
                return __retres;
}


#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
void e1000_set_media_type(struct e1000_hw *hw)
{
  u32 status;
  
#line 362 
  if (hw->mac_type != (unsigned int)e1000_82543) 
#line 364 
                                                 hw->tbi_compatibility_en = (_Bool)0; else ;
  
#line 367 
  switch ((int)hw->device_id) {
    case 4136: 
#line 368 
    ;
    case 4219: 
#line 369 
    ;
    
#line 370 
    hw->media_type = e1000_media_type_internal_serdes;
    
#line 371 
    goto ldv_54684;
    default: 
#line 372 
    ;
    
#line 373 
    switch ((unsigned int)hw->mac_type) {
      case (unsigned int)1: 
#line 374 
      ;
      case (unsigned int)2: 
#line 375 
      ;
      
#line 376 
      hw->media_type = e1000_media_type_fiber;
      
#line 377 
      goto ldv_54688;
      case (unsigned int)9: 
#line 378 
      ;
      
#line 379 
      hw->media_type = e1000_media_type_copper;
      
#line 380 
      goto ldv_54688;
      default: 
#line 381 
      ;
      
#line 382 
      status = readl((void const volatile *)(hw->hw_addr + 8U));
      
#line 383 
      if ((status & 32U) != 0U) {
        
#line 384 
        hw->media_type = e1000_media_type_fiber;
        
#line 386 
        hw->tbi_compatibility_en = (_Bool)0;
      }
      else 
#line 388 
           hw->media_type = e1000_media_type_copper;
      
#line 390 
      goto ldv_54688;
    }
    ldv_54688: 
#line 392 
    ;
  }
  ldv_54684: 
#line 393 
  ;
  
#line 394 
  return;
}


#line 401  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_reset_hw(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl;
  u32 ctrl_ext;
  u32 icr;
  u32 manc;
  u32 led_ctrl;
  s32 ret_val;
  
#line 411 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) {
    {
      
#line 412 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_reset_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Disabling MWI on 82542 rev 2.0\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))412U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 412 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 412 
        tmp = e1000_get_hw_dev(hw);
        
#line 412 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Disabling MWI on 82542 rev 2.0\n");
      }
      else ;
    }
    
#line 413 
    e1000_pci_clear_mwi(hw);
  }
  else ;
  {
    
#line 417 
    struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_reset_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Masking off all interrupts\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))417U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 417 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      struct net_device *tmp_0;
      
#line 417 
      tmp_0 = e1000_get_hw_dev(hw);
      
#line 417 
      __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Masking off all interrupts\n");
    }
    else ;
  }
  
#line 418 
  writel(4294967295U,(void volatile *)(hw->hw_addr + 216U));
  
#line 424 
  writel(0U,(void volatile *)(hw->hw_addr + 256U));
  
#line 425 
  writel(8U,(void volatile *)(hw->hw_addr + 1024U));
  
#line 426 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 429 
  hw->tbi_compatibility_on = (_Bool)0;
  
#line 434 
  msleep(10U);
  
#line 436 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 439 
  if (hw->mac_type == (unsigned int)e1000_82541 || hw->mac_type == (unsigned int)e1000_82547) {
    
#line 440 
    writel(ctrl | 2147483648U,(void volatile *)hw->hw_addr);
    
#line 441 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 442 
    msleep(5U);
  }
  else ;
  {
    
#line 450 
    struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_reset_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Issuing a global reset to MAC\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))450U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 450 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
      struct net_device *tmp_1;
      
#line 450 
      tmp_1 = e1000_get_hw_dev(hw);
      
#line 450 
      __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Issuing a global reset to MAC\n");
    }
    else ;
  }
  
#line 452 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)4: 
#line 453 
    ;
    case (unsigned int)5: 
#line 454 
    ;
    case (unsigned int)6: 
#line 455 
    ;
    case (unsigned int)8: 
#line 456 
    ;
    case (unsigned int)11: 
#line 457 
    ;
    case (unsigned int)12: 
#line 458 
    ;
    
#line 462 
    e1000_write_reg_io(hw,0U,ctrl | 67108864U);
    
#line 463 
    goto ldv_54710;
    case (unsigned int)7: 
#line 464 
    ;
    case (unsigned int)10: 
#line 465 
    ;
    
#line 467 
    writel(ctrl | 67108864U,(void volatile *)(hw->hw_addr + 4U));
    
#line 468 
    goto ldv_54710;
    case (unsigned int)9: 
#line 469 
    ;
    default: 
#line 470 
    ;
    
#line 471 
    writel(ctrl | 67108864U,(void volatile *)hw->hw_addr);
    
#line 472 
    goto ldv_54710;
  }
  ldv_54710: 
#line 479 
  ;
  
#line 479 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)1: 
#line 480 
    ;
    case (unsigned int)2: 
#line 481 
    ;
    case (unsigned int)3: 
#line 482 
    ;
    case (unsigned int)4: 
#line 483 
    ;
    
#line 485 
    __const_udelay(42950UL);
    
#line 486 
    ctrl_ext = readl((void const volatile *)(hw->hw_addr + 24U));
    
#line 487 
    ctrl_ext |= 8192U;
    
#line 488 
    writel(ctrl_ext,(void volatile *)(hw->hw_addr + 24U));
    
#line 489 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 491 
    msleep(2U);
    
#line 492 
    goto ldv_54719;
    case (unsigned int)11: 
#line 493 
    ;
    case (unsigned int)12: 
#line 494 
    ;
    case (unsigned int)13: 
#line 495 
    ;
    case (unsigned int)14: 
#line 496 
    ;
    
#line 498 
    msleep(20U);
    
#line 499 
    goto ldv_54719;
    default: 
#line 500 
    ;
    
#line 502 
    ret_val = e1000_get_auto_rd_done(hw);
    
#line 503 
    if (ret_val != 0) {
      
#line 504 
      __retres = ret_val;
      
#line 504 
      goto return_label;
    }
    else ;
    
#line 505 
    goto ldv_54719;
  }
  ldv_54719: 
#line 509 
  ;
  
#line 509 
  if (hw->mac_type > (unsigned int)e1000_82544) {
    
#line 510 
    manc = readl((void const volatile *)(hw->hw_addr + 22560U));
    
#line 511 
    manc &= 4294959103U;
    
#line 512 
    writel(manc,(void volatile *)(hw->hw_addr + 22560U));
  }
  else ;
  
#line 515 
  if (hw->mac_type == (unsigned int)e1000_82541 || hw->mac_type == (unsigned int)e1000_82547) {
    
#line 516 
    e1000_phy_init_script(hw);
    
#line 519 
    led_ctrl = readl((void const volatile *)(hw->hw_addr + 3584U));
    
#line 520 
    led_ctrl &= 4294963455U;
    
#line 521 
    led_ctrl |= 117441280U;
    
#line 522 
    writel(led_ctrl,(void volatile *)(hw->hw_addr + 3584U));
  }
  else ;
  {
    
#line 526 
    struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_reset_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Masking off all interrupts\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))526U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 526 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
      struct net_device *tmp_2;
      
#line 526 
      tmp_2 = e1000_get_hw_dev(hw);
      
#line 526 
      __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"Masking off all interrupts\n");
    }
    else ;
  }
  
#line 527 
  writel(4294967295U,(void volatile *)(hw->hw_addr + 216U));
  
#line 530 
  icr = readl((void const volatile *)(hw->hw_addr + 192U));
  
#line 533 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) {
    
#line 534 
    if (((int)hw->pci_cmd_word & 16) != 0) 
#line 535 
                                           e1000_pci_set_mwi(hw); else ;
  }
  else ;
  
#line 538 
  __retres = 0;
  return_label: 
#line 538 
                return __retres;
}


#line 551  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_init_hw(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl;
  u32 i;
  s32 ret_val;
  u32 mta_size;
  u32 ctrl_ext;
  int tmp_3;
  
#line 560 
  ret_val = e1000_id_led_init(hw);
  
#line 561 
  if (ret_val != 0) {
    {
      
#line 562 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_init_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Initializing Identification LED\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))562U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 562 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 562 
        tmp = e1000_get_hw_dev(hw);
        
#line 562 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Error Initializing Identification LED\n");
      }
      else ;
    }
    
#line 563 
    __retres = ret_val;
    
#line 563 
    goto return_label;
  }
  else ;
  
#line 567 
  e1000_set_media_type(hw);
  {
    
#line 570 
    struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_init_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Initializing the IEEE VLAN\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))570U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 570 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      struct net_device *tmp_0;
      
#line 570 
      tmp_0 = e1000_get_hw_dev(hw);
      
#line 570 
      __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Initializing the IEEE VLAN\n");
    }
    else ;
  }
  
#line 571 
  if (hw->mac_type <= (unsigned int)e1000_82545) 
#line 572 
                                                 writel(0U,(void volatile *)(hw->hw_addr + 56U)); else ;
  
#line 573 
  e1000_clear_vfta(hw);
  
#line 576 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) {
    {
      
#line 577 
      struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_init_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Disabling MWI on 82542 rev 2.0\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))577U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 577 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
        struct net_device *tmp_1;
        
#line 577 
        tmp_1 = e1000_get_hw_dev(hw);
        
#line 577 
        __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Disabling MWI on 82542 rev 2.0\n");
      }
      else ;
    }
    
#line 578 
    e1000_pci_clear_mwi(hw);
    
#line 579 
    writel(1U,(void volatile *)(hw->hw_addr + 256U));
    
#line 580 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 581 
    msleep(5U);
  }
  else ;
  
#line 587 
  e1000_init_rx_addrs(hw);
  
#line 590 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) {
    
#line 591 
    writel(0U,(void volatile *)(hw->hw_addr + 256U));
    
#line 592 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 593 
    msleep(1U);
    
#line 594 
    if (((int)hw->pci_cmd_word & 16) != 0) 
#line 595 
                                           e1000_pci_set_mwi(hw); else ;
  }
  else ;
  {
    
#line 599 
    struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_init_hw", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Zeroing the MTA\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))599U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 599 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
      struct net_device *tmp_2;
      
#line 599 
      tmp_2 = e1000_get_hw_dev(hw);
      
#line 599 
      __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"Zeroing the MTA\n");
    }
    else ;
  }
  
#line 600 
  mta_size = 128U;
  
#line 601 
  i = 0U;
  
#line 601 
  goto ldv_54740;
  ldv_54739: 
#line 602 
  ;
  
#line 602 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 602 
                                                       tmp_3 = 20992; else 
                                                                    
#line 602 
                                                                    tmp_3 = 512;
  
#line 602 
  ;
  
#line 602 
  writel(0U,(void volatile *)(hw->hw_addr + ((u32)tmp_3 + (i << 2))));
  
#line 606 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 601 
  i += 1U;
  ldv_54740: 
#line 602 
  ;
  
#line 601 
  if (i < mta_size) 
#line 603 
                    goto ldv_54739; else 
#line 606 
                                         goto ldv_54741;
  ldv_54741: 
#line 607 
  ;
  
#line 614 
  if ((unsigned int)hw->dma_fairness != 0U && hw->mac_type <= (unsigned int)e1000_82543) {
    
#line 615 
    ctrl = readl((void const volatile *)hw->hw_addr);
    
#line 616 
    writel(ctrl | 4U,(void volatile *)hw->hw_addr);
  }
  else ;
  
#line 619 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)7: 
#line 620 
    ;
    case (unsigned int)10: 
#line 621 
    ;
    
#line 622 
    goto ldv_54744;
    default: 
#line 623 
    ;
    
#line 627 
    if (hw->bus_type == (unsigned int)2) {
      int tmp_4;
      
#line 628 
      tmp_4 = e1000_pcix_get_mmrbc(hw);
      
#line 628 
      if (tmp_4 > 2048) 
#line 629 
                        e1000_pcix_set_mmrbc(hw,2048); else ;
    }
    else ;
    
#line 630 
    goto ldv_54744;
  }
  ldv_54744: 
#line 634 
  ;
  
#line 634 
  ret_val = e1000_setup_link(hw);
  
#line 637 
  if (hw->mac_type > (unsigned int)e1000_82544) {
    
#line 638 
    ctrl = readl((void const volatile *)(hw->hw_addr + 14376U));
    
#line 639 
    ctrl = (ctrl & 4274061311U) | 16842752U;
    
#line 642 
    writel(ctrl,(void volatile *)(hw->hw_addr + 14376U));
  }
  else ;
  
#line 650 
  e1000_clear_hw_cntrs(hw);
  
#line 652 
  if ((unsigned int)hw->device_id == 4249U || (unsigned int)hw->device_id == 4277U) {
    
#line 654 
    ctrl_ext = readl((void const volatile *)(hw->hw_addr + 24U));
    
#line 658 
    ctrl_ext |= 131072U;
    
#line 659 
    writel(ctrl_ext,(void volatile *)(hw->hw_addr + 24U));
  }
  else ;
  
#line 662 
  __retres = ret_val;
  return_label: 
#line 662 
                return __retres;
}


#line 669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_adjust_serdes_amplitude(struct e1000_hw *hw)
{
  s32 __retres;
  u16 eeprom_data;
  s32 ret_val;
  
#line 674 
  if (hw->media_type != (unsigned int)e1000_media_type_internal_serdes) {
    
#line 675 
    __retres = 0;
    
#line 675 
    goto return_label;
  }
  else ;
  
#line 677 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)7: 
#line 678 
    ;
    case (unsigned int)10: 
#line 679 
    ;
    
#line 680 
    goto ldv_54753;
    default: 
#line 681 
    ;
    
#line 682 
    __retres = 0;
    
#line 682 
    goto return_label;
  }
  ldv_54753: 
#line 685 
  ;
  
#line 685 
  ret_val = e1000_read_eeprom(hw,(unsigned short)6,(unsigned short)1,& eeprom_data);
  
#line 687 
  if (ret_val != 0) {
    
#line 688 
    __retres = ret_val;
    
#line 688 
    goto return_label;
  }
  else ;
  
#line 691 
  if ((unsigned int)eeprom_data != 65535U) {
    
#line 693 
    eeprom_data = (unsigned short)((unsigned int)eeprom_data & 15U);
    
#line 694 
    ret_val = e1000_write_phy_reg(hw,26U,(unsigned short)((int)eeprom_data));
    
#line 696 
    if (ret_val != 0) {
      
#line 697 
      __retres = ret_val;
      
#line 697 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 700 
  __retres = 0;
  return_label: 
#line 700 
                return __retres;
}


#line 713  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_setup_link(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl_ext;
  s32 ret_val;
  u16 eeprom_data;
  
#line 727 
  if (hw->fc == (unsigned int)E1000_FC_DEFAULT) {
    
#line 728 
    ret_val = e1000_read_eeprom(hw,(unsigned short)15,(unsigned short)1,& eeprom_data);
    
#line 730 
    if (ret_val != 0) {
      {
        
#line 731 
        struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_setup_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Read Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))731U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 731 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
          struct net_device *tmp;
          
#line 731 
          tmp = e1000_get_hw_dev(hw);
          
#line 731 
          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"EEPROM Read Error\n");
        }
        else ;
      }
      
#line 732 
      __retres = -1;
      
#line 732 
      goto return_label;
    }
    else ;
    
#line 734 
    if (((int)eeprom_data & 12288) == 0) 
#line 735 
                                         hw->fc = E1000_FC_NONE;
    else 
      
#line 736 
      if (((int)eeprom_data & 12288) == 8192) 
#line 738 
                                              hw->fc = E1000_FC_TX_PAUSE; else 
                                                                    
#line 740 
                                                                    hw->fc = E1000_FC_FULL;
  }
  else ;
  
#line 747 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) 
#line 748 
                                                        hw->fc = (enum ldv_36248)((unsigned int)hw->fc & 4294967293U); else ;
  
#line 750 
  if (hw->mac_type <= (unsigned int)e1000_82542_rev2_1 && (int)hw->report_tx_early == 1) 
    
#line 751 
    hw->fc = (enum ldv_36248)((unsigned int)hw->fc & 4294967294U); else ;
  
#line 753 
  hw->original_fc = (unsigned int)hw->fc;
  {
    
#line 755 
    struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_setup_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "After fix-ups FlowControl is now = %x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))755U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 755 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      struct net_device *tmp_0;
      
#line 755 
      ;
      
#line 755 
      tmp_0 = e1000_get_hw_dev(hw);
      
#line 755 
      __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"After fix-ups FlowControl is now = %x\n",(unsigned int)hw->fc);
    }
    else ;
  }
  
#line 764 
  if (hw->mac_type == (unsigned int)e1000_82543) {
    
#line 765 
    ret_val = e1000_read_eeprom(hw,(unsigned short)15,(unsigned short)1,& eeprom_data);
    
#line 767 
    if (ret_val != 0) {
      {
        
#line 768 
        struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_setup_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Read Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))768U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 768 
        if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
          struct net_device *tmp_1;
          
#line 768 
          tmp_1 = e1000_get_hw_dev(hw);
          
#line 768 
          __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"EEPROM Read Error\n");
        }
        else ;
      }
      
#line 769 
      __retres = -1;
      
#line 769 
      goto return_label;
    }
    else ;
    
#line 771 
    ctrl_ext = (unsigned int)((int)eeprom_data << 4) & 3840U;
    
#line 773 
    writel(ctrl_ext,(void volatile *)(hw->hw_addr + 24U));
  }
  else ;
  
#line 777 
  if (hw->media_type == (unsigned int)e1000_media_type_copper) 
#line 777 
                                                               ret_val = e1000_setup_copper_link(hw); else 
                                                                    
#line 778 
                                                                    ret_val = e1000_setup_fiber_serdes_link(hw);
  {
    
#line 785 
    struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_setup_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Initializing the Flow Control address, type and timer regs\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))785U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 785 
    if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
      struct net_device *tmp_4;
      
#line 785 
      tmp_4 = e1000_get_hw_dev(hw);
      
#line 785 
      __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_4,"Initializing the Flow Control address, type and timer regs\n");
    }
    else ;
  }
  
#line 787 
  writel(34824U,(void volatile *)(hw->hw_addr + 48U));
  
#line 788 
  writel(256U,(void volatile *)(hw->hw_addr + 44U));
  
#line 789 
  writel(12746753U,(void volatile *)(hw->hw_addr + 40U));
  
#line 791 
  writel((unsigned int)hw->fc_pause_time,(void volatile *)(hw->hw_addr + 368U));
  
#line 799 
  if (((unsigned int)hw->fc & 2U) == 0U) {
    int tmp_5;
    int tmp_6;
    
#line 800 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 800 
                                                         tmp_5 = 8544; else 
                                                                    
#line 800 
                                                                    tmp_5 = 360;
    
#line 800 
    ;
    
#line 800 
    writel(0U,(void volatile *)(hw->hw_addr + tmp_5));
    
#line 801 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 801 
                                                         tmp_6 = 8552; else 
                                                                    
#line 801 
                                                                    tmp_6 = 352;
    
#line 801 
    ;
    
#line 801 
    writel(0U,(void volatile *)(hw->hw_addr + tmp_6));
  }
  else 
    
#line 807 
    if ((int)hw->fc_send_xon != 0) {
      int tmp_7;
      int tmp_8;
      
#line 808 
      if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 808 
                                                           tmp_7 = 8544; else 
                                                                    
#line 808 
                                                                    tmp_7 = 360;
      
#line 808 
      ;
      
#line 808 
      ;
      
#line 808 
      writel((unsigned int)hw->fc_low_water | 2147483648U,(void volatile *)(hw->hw_addr + tmp_7));
      
#line 809 
      if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 809 
                                                           tmp_8 = 8552; else 
                                                                    
#line 809 
                                                                    tmp_8 = 352;
      
#line 809 
      ;
      
#line 809 
      ;
      
#line 809 
      writel((unsigned int)hw->fc_high_water,(void volatile *)(hw->hw_addr + tmp_8));
    }
    else {
      int tmp_9;
      int tmp_10;
      
#line 811 
      if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 811 
                                                           tmp_9 = 8544; else 
                                                                    
#line 811 
                                                                    tmp_9 = 360;
      
#line 811 
      ;
      
#line 811 
      ;
      
#line 811 
      writel((unsigned int)hw->fc_low_water,(void volatile *)(hw->hw_addr + tmp_9));
      
#line 812 
      if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 812 
                                                           tmp_10 = 8552; else 
                                                                    
#line 812 
                                                                    tmp_10 = 352;
      
#line 812 
      ;
      
#line 812 
      ;
      
#line 812 
      writel((unsigned int)hw->fc_high_water,(void volatile *)(hw->hw_addr + tmp_10));
    }
  
#line 815 
  __retres = ret_val;
  return_label: 
#line 815 
                return __retres;
}


#line 826  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_setup_fiber_serdes_link(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl;
  u32 status;
  u32 i;
  s32 ret_val;
  
#line 830 
  u32 txcw = 0U;
  
#line 832 
  u32 signal = 0U;
  
#line 841 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 842 
  if (hw->media_type == (unsigned int)e1000_media_type_fiber) {
    int tmp;
    
#line 843 
    if (hw->mac_type > (unsigned int)e1000_82544) 
#line 843 
                                                  tmp = 524288; else 
                                                                  
#line 843 
                                                                  tmp = 0;
    
#line 843 
    signal = (unsigned int)tmp;
  }
  else ;
  
#line 845 
  ret_val = e1000_adjust_serdes_amplitude(hw);
  
#line 846 
  if (ret_val != 0) {
    
#line 847 
    __retres = ret_val;
    
#line 847 
    goto return_label;
  }
  else ;
  
#line 850 
  ctrl &= 4294967287U;
  
#line 853 
  ret_val = e1000_set_vco_speed(hw);
  
#line 854 
  if (ret_val != 0) {
    
#line 855 
    __retres = ret_val;
    
#line 855 
    goto return_label;
  }
  else ;
  
#line 857 
  e1000_config_collision_dist(hw);
  
#line 875 
  switch ((unsigned int)hw->fc) {
    case (unsigned int)0: 
#line 876 
    ;
    
#line 878 
    txcw = 2147483680U;
    
#line 879 
    goto ldv_54776;
    case (unsigned int)1: 
#line 880 
    ;
    
#line 888 
    txcw = 2147484064U;
    
#line 889 
    goto ldv_54776;
    case (unsigned int)2: 
#line 890 
    ;
    
#line 894 
    txcw = 2147483936U;
    
#line 895 
    goto ldv_54776;
    case (unsigned int)3: 
#line 896 
    ;
    
#line 900 
    txcw = 2147484064U;
    
#line 901 
    goto ldv_54776;
    default: 
#line 902 
    ;
    {
      
#line 903 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_setup_fiber_serdes_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow control param set incorrectly\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))903U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 903 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 903 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 903 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp_0,"Flow control param set incorrectly\n");
      }
      else ;
    }
    
#line 904 
    __retres = -3;
    
#line 904 
    goto return_label;
  }
  ldv_54776: 
#line 913 
  ;
  {
    
#line 913 
    struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_setup_fiber_serdes_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Auto-negotiation enabled\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))913U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 913 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      struct net_device *tmp_1;
      
#line 913 
      tmp_1 = e1000_get_hw_dev(hw);
      
#line 913 
      __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_1,"Auto-negotiation enabled\n");
    }
    else ;
  }
  
#line 915 
  writel(txcw,(void volatile *)(hw->hw_addr + 376U));
  
#line 916 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 917 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 919 
  hw->txcw = txcw;
  
#line 920 
  msleep(1U);
  
#line 929 
  if (hw->media_type == (unsigned int)e1000_media_type_internal_serdes) 
    
#line 929 
    goto _LOR;
  else {
    unsigned int tmp_7;
    
#line 929 
    tmp_7 = readl((void const volatile *)hw->hw_addr);
    
#line 929 
    ;
    
#line 929 
    if ((tmp_7 & 524288U) == signal) {
      _LOR: {
              {
                
#line 931 
                struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_setup_fiber_serdes_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Looking for Link\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))931U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
                
#line 931 
                if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
                  struct net_device *tmp_2;
                  
#line 931 
                  tmp_2 = e1000_get_hw_dev(hw);
                  
#line 931 
                  __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_2,"Looking for Link\n");
                }
                else ;
              }
              
#line 932 
              i = 0U;
              
#line 932 
              goto ldv_54787;
              ldv_54786: 
#line 933 
              ;
              
#line 933 
              msleep(10U);
              
#line 934 
              status = readl((void const volatile *)(hw->hw_addr + 8U));
              
#line 935 
              if ((status & 2U) != 0U) 
#line 936 
                                       goto ldv_54785; else ;
              
#line 932 
              i += 1U;
              ldv_54787: 
#line 933 
              ;
              
#line 932 
              if (i <= 49U) 
#line 934 
                            goto ldv_54786; else 
#line 937 
                                                 goto ldv_54785;
              ldv_54785: 
#line 938 
              ;
              
#line 938 
              if (i == 50U) {
                {
                  
#line 939 
                  struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_setup_fiber_serdes_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Never got a valid link from auto-neg!!!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))939U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
                  
#line 939 
                  if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
                    struct net_device *tmp_3;
                    
#line 939 
                    tmp_3 = e1000_get_hw_dev(hw);
                    
#line 939 
                    __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_3,"Never got a valid link from auto-neg!!!\n");
                  }
                  else ;
                }
                
#line 940 
                hw->autoneg_failed = 1U;
                
#line 946 
                ret_val = e1000_check_for_link(hw);
                
#line 947 
                if (ret_val != 0) {
                  {
                    
#line 948 
                    struct _ddebug descriptor_3 = {.modname = "e1000", .function = "e1000_setup_fiber_serdes_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error while checking for link\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))948U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
                    
#line 948 
                    if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) {
                      struct net_device *tmp_4;
                      
#line 948 
                      tmp_4 = e1000_get_hw_dev(hw);
                      
#line 948 
                      __dynamic_netdev_dbg(& descriptor_3,(struct net_device const *)tmp_4,"Error while checking for link\n");
                    }
                    else ;
                  }
                  
#line 949 
                  __retres = ret_val;
                  
#line 949 
                  goto return_label;
                }
                else ;
                
#line 951 
                hw->autoneg_failed = 0U;
              }
              else {
                
#line 953 
                hw->autoneg_failed = 0U;
                {
                  
#line 954 
                  struct _ddebug descriptor_4 = {.modname = "e1000", .function = "e1000_setup_fiber_serdes_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Valid Link Found\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))954U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
                  
#line 954 
                  if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) {
                    struct net_device *tmp_5;
                    
#line 954 
                    tmp_5 = e1000_get_hw_dev(hw);
                    
#line 954 
                    __dynamic_netdev_dbg(& descriptor_4,(struct net_device const *)tmp_5,"Valid Link Found\n");
                  }
                  else ;
                }
              }
            }
    }
    else {
      
#line 957 
      struct _ddebug descriptor_5 = {.modname = "e1000", .function = "e1000_setup_fiber_serdes_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "No Signal Detected\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))957U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 957 
      if ((long)(((int)descriptor_5.flags & 1) != 0) != 0L) {
        struct net_device *tmp_6;
        
#line 957 
        tmp_6 = e1000_get_hw_dev(hw);
        
#line 957 
        __dynamic_netdev_dbg(& descriptor_5,(struct net_device const *)tmp_6,"No Signal Detected\n");
      }
      else ;
    }
  }
  
#line 959 
  __retres = 0;
  return_label: 
#line 959 
                return __retres;
}


#line 968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_copper_link_rtl_setup(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  
#line 973 
  ret_val = e1000_phy_reset(hw);
  
#line 974 
  if (ret_val != 0) {
    {
      
#line 975 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_copper_link_rtl_setup", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Resetting the PHY\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))975U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 975 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 975 
        tmp = e1000_get_hw_dev(hw);
        
#line 975 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Error Resetting the PHY\n");
      }
      else ;
    }
    
#line 976 
    __retres = ret_val;
    
#line 976 
    goto return_label;
  }
  else ;
  
#line 979 
  __retres = 0;
  return_label: 
#line 979 
                return __retres;
}


#line 982  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 gbe_dhg_phy_setup(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u32 ctrl_aux;
  
#line 987 
  switch ((unsigned int)hw->phy_type) {
    case (unsigned int)2: 
#line 988 
    ;
    
#line 989 
    ret_val = e1000_copper_link_rtl_setup(hw);
    
#line 990 
    if (ret_val != 0) {
      {
        
#line 991 
        struct _ddebug descriptor = {.modname = "e1000", .function = "gbe_dhg_phy_setup", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "e1000_copper_link_rtl_setup failed!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))991U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 991 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
          struct net_device *tmp;
          
#line 991 
          tmp = e1000_get_hw_dev(hw);
          
#line 991 
          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"e1000_copper_link_rtl_setup failed!\n");
        }
        else ;
      }
      
#line 992 
      __retres = ret_val;
      
#line 992 
      goto return_label;
    }
    else ;
    
#line 994 
    goto ldv_54806;
    case (unsigned int)3: 
#line 995 
    ;
    
#line 997 
    ctrl_aux = readl((void const volatile *)(hw->hw_addr + 224U));
    
#line 998 
    ctrl_aux |= 1U;
    
#line 999 
    writel(ctrl_aux,(void volatile *)(hw->hw_addr + 224U));
    
#line 1000 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 1003 
    ctrl_aux = readl((void const volatile *)(hw->hw_addr + 224U));
    
#line 1004 
    ctrl_aux |= 4U;
    
#line 1005 
    ctrl_aux &= 4294967293U;
    
#line 1006 
    writel(ctrl_aux,(void volatile *)(hw->hw_addr + 224U));
    
#line 1007 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 1008 
    ret_val = e1000_copper_link_rtl_setup(hw);
    
#line 1010 
    if (ret_val != 0) {
      {
        
#line 1011 
        struct _ddebug descriptor_0 = {.modname = "e1000", .function = "gbe_dhg_phy_setup", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "e1000_copper_link_rtl_setup failed!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1011U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1011 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
          struct net_device *tmp_0;
          
#line 1011 
          tmp_0 = e1000_get_hw_dev(hw);
          
#line 1011 
          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"e1000_copper_link_rtl_setup failed!\n");
        }
        else ;
      }
      
#line 1012 
      __retres = ret_val;
      
#line 1012 
      goto return_label;
    }
    else ;
    
#line 1014 
    goto ldv_54806;
    default: 
#line 1015 
    ;
    {
      
#line 1016 
      struct _ddebug descriptor_1 = {.modname = "e1000", .function = "gbe_dhg_phy_setup", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Resetting the PHY\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1016U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1016 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
        struct net_device *tmp_1;
        
#line 1016 
        tmp_1 = e1000_get_hw_dev(hw);
        
#line 1016 
        __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Error Resetting the PHY\n");
      }
      else ;
    }
    
#line 1017 
    __retres = 6;
    
#line 1017 
    goto return_label;
  }
  ldv_54806: 
#line 1020 
  ;
  
#line 1020 
  __retres = 0;
  return_label: 
#line 1020 
                return __retres;
}


#line 1029  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_copper_link_preconfig(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl;
  s32 ret_val;
  u16 phy_data;
  
#line 1035 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 1040 
  if (hw->mac_type > (unsigned int)e1000_82543) {
    
#line 1041 
    ctrl |= 64U;
    
#line 1042 
    ctrl &= 4294961151U;
    
#line 1043 
    writel(ctrl,(void volatile *)hw->hw_addr);
  }
  else {
    
#line 1045 
    ctrl |= 6208U;
    
#line 1047 
    writel(ctrl,(void volatile *)hw->hw_addr);
    
#line 1048 
    ret_val = e1000_phy_hw_reset(hw);
    
#line 1049 
    if (ret_val != 0) {
      
#line 1050 
      __retres = ret_val;
      
#line 1050 
      goto return_label;
    }
    else ;
  }
  
#line 1054 
  ret_val = e1000_detect_gig_phy(hw);
  
#line 1055 
  if (ret_val != 0) {
    {
      
#line 1056 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_copper_link_preconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error, did not detect valid phy.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1056U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1056 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 1056 
        tmp = e1000_get_hw_dev(hw);
        
#line 1056 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Error, did not detect valid phy.\n");
      }
      else ;
    }
    
#line 1057 
    __retres = ret_val;
    
#line 1057 
    goto return_label;
  }
  else ;
  {
    
#line 1059 
    struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_copper_link_preconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Phy ID = %x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1059U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1059 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      struct net_device *tmp_0;
      
#line 1059 
      ;
      
#line 1059 
      tmp_0 = e1000_get_hw_dev(hw);
      
#line 1059 
      __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Phy ID = %x\n",hw->phy_id);
    }
    else ;
  }
  
#line 1062 
  ret_val = e1000_set_phy_mode(hw);
  
#line 1063 
  if (ret_val != 0) {
    
#line 1064 
    __retres = ret_val;
    
#line 1064 
    goto return_label;
  }
  else ;
  
#line 1066 
  if (hw->mac_type == (unsigned int)e1000_82545_rev_3 || hw->mac_type == (unsigned int)e1000_82546_rev_3) {
    
#line 1068 
    ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
    
#line 1070 
    phy_data = (unsigned short)((unsigned int)phy_data | 8U);
    
#line 1071 
    ret_val = e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_data));
  }
  else ;
  
#line 1075 
  if ((((hw->mac_type <= (unsigned int)e1000_82543 || hw->mac_type == (unsigned int)e1000_82541) || hw->mac_type == (unsigned int)e1000_82547) || hw->mac_type == (unsigned int)e1000_82541_rev_2) || hw->mac_type == (unsigned int)e1000_82547_rev_2) 
    
#line 1079 
    hw->phy_reset_disable = (_Bool)0; else ;
  
#line 1081 
  __retres = 0;
  return_label: 
#line 1081 
                return __retres;
}


#line 1088  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_copper_link_igp_setup(struct e1000_hw *hw)
{
  s32 __retres;
  u32 led_ctrl;
  s32 ret_val;
  u16 phy_data;
  
#line 1094 
  if ((int)hw->phy_reset_disable != 0) {
    
#line 1095 
    __retres = 0;
    
#line 1095 
    goto return_label;
  }
  else ;
  
#line 1097 
  ret_val = e1000_phy_reset(hw);
  
#line 1098 
  if (ret_val != 0) {
    {
      
#line 1099 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_copper_link_igp_setup", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Resetting the PHY\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1099U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1099 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 1099 
        tmp = e1000_get_hw_dev(hw);
        
#line 1099 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Error Resetting the PHY\n");
      }
      else ;
    }
    
#line 1100 
    __retres = ret_val;
    
#line 1100 
    goto return_label;
  }
  else ;
  
#line 1104 
  msleep(15U);
  
#line 1106 
  led_ctrl = readl((void const volatile *)(hw->hw_addr + 3584U));
  
#line 1107 
  led_ctrl &= 4294963455U;
  
#line 1108 
  led_ctrl |= 117441280U;
  
#line 1109 
  writel(led_ctrl,(void volatile *)(hw->hw_addr + 3584U));
  
#line 1112 
  if (hw->phy_type == (unsigned int)1) {
    
#line 1114 
    ret_val = e1000_set_d3_lplu_state(hw,(_Bool)0);
    
#line 1115 
    if (ret_val != 0) {
      {
        
#line 1116 
        struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_copper_link_igp_setup", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Disabling LPLU D3\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1116U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1116 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
          struct net_device *tmp_0;
          
#line 1116 
          tmp_0 = e1000_get_hw_dev(hw);
          
#line 1116 
          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Error Disabling LPLU D3\n");
        }
        else ;
      }
      
#line 1117 
      __retres = ret_val;
      
#line 1117 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1122 
  ret_val = e1000_read_phy_reg(hw,18U,& phy_data);
  
#line 1123 
  if (ret_val != 0) {
    
#line 1124 
    __retres = ret_val;
    
#line 1124 
    goto return_label;
  }
  else ;
  
#line 1126 
  if (hw->mac_type == (unsigned int)e1000_82541 || hw->mac_type == (unsigned int)e1000_82547) {
    
#line 1127 
    hw->dsp_config_state = 0;
    
#line 1129 
    phy_data = (unsigned short)((unsigned int)phy_data & 53247U);
    
#line 1132 
    hw->mdix = (unsigned char)1U;
  }
  else {
    
#line 1135 
    hw->dsp_config_state = 1;
    
#line 1136 
    phy_data = (unsigned short)((unsigned int)phy_data & 61439U);
    
#line 1138 
    switch ((int)hw->mdix) {
      case 1: 
#line 1139 
      ;
      
#line 1140 
      phy_data = (unsigned short)((unsigned int)phy_data & 57343U);
      
#line 1141 
      goto ldv_54830;
      case 2: 
#line 1142 
      ;
      
#line 1143 
      phy_data = (unsigned short)((unsigned int)phy_data | 8192U);
      
#line 1144 
      goto ldv_54830;
      case 0: 
#line 1145 
      ;
      default: 
#line 1146 
      ;
      
#line 1147 
      phy_data = (unsigned short)((unsigned int)phy_data | 4096U);
      
#line 1148 
      goto ldv_54830;
    }
    ldv_54830: 
#line 1150 
    ;
  }
  
#line 1151 
  ret_val = e1000_write_phy_reg(hw,18U,(unsigned short)((int)phy_data));
  
#line 1152 
  if (ret_val != 0) {
    
#line 1153 
    __retres = ret_val;
    
#line 1153 
    goto return_label;
  }
  else ;
  
#line 1156 
  if ((unsigned int)hw->autoneg != 0U) {
    int tmp_2;
    
#line 1157 
    e1000_ms_type phy_ms_setting = hw->master_slave;
    
#line 1159 
    if (hw->ffe_config_state == (unsigned int)1) 
#line 1160 
                                                 hw->ffe_config_state = 0; else ;
    
#line 1162 
    if (hw->dsp_config_state == (unsigned int)2) 
#line 1163 
                                                 hw->dsp_config_state = 1; else ;
    
#line 1169 
    if ((unsigned int)hw->autoneg_advertised == 32U) {
      
#line 1171 
      ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
      
#line 1174 
      if (ret_val != 0) {
        
#line 1175 
        __retres = ret_val;
        
#line 1175 
        goto return_label;
      }
      else ;
      
#line 1176 
      phy_data = (unsigned short)((unsigned int)phy_data & 65407U);
      
#line 1177 
      ret_val = e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_data));
      
#line 1180 
      if (ret_val != 0) {
        
#line 1181 
        __retres = ret_val;
        
#line 1181 
        goto return_label;
      }
      else ;
      
#line 1183 
      ret_val = e1000_read_phy_reg(hw,9U,& phy_data);
      
#line 1185 
      if (ret_val != 0) {
        
#line 1186 
        __retres = ret_val;
        
#line 1186 
        goto return_label;
      }
      else ;
      
#line 1187 
      phy_data = (unsigned short)((unsigned int)phy_data & 61439U);
      
#line 1188 
      ret_val = e1000_write_phy_reg(hw,9U,(unsigned short)((int)phy_data));
      
#line 1190 
      if (ret_val != 0) {
        
#line 1191 
        __retres = ret_val;
        
#line 1191 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 1194 
    ret_val = e1000_read_phy_reg(hw,9U,& phy_data);
    
#line 1195 
    if (ret_val != 0) {
      
#line 1196 
      __retres = ret_val;
      
#line 1196 
      goto return_label;
    }
    else ;
    
#line 1202 
    if (((int)phy_data & 4096) != 0) {
      int tmp_1;
      
#line 1199 
      if (((int)phy_data & 2048) != 0) 
#line 1199 
                                       tmp_1 = 1; else 
#line 1199 
                                                       tmp_1 = 2;
      
#line 1202 
      tmp_2 = tmp_1;
    }
    else 
#line 1202 
         tmp_2 = 3;
    
#line 1199 
    hw->original_master_slave = tmp_2;
    
#line 1204 
    switch ((unsigned int)phy_ms_setting) {
      case (unsigned int)1: 
#line 1205 
      ;
      
#line 1206 
      phy_data = (unsigned short)((unsigned int)phy_data | 6144U);
      
#line 1207 
      goto ldv_54836;
      case (unsigned int)2: 
#line 1208 
      ;
      
#line 1209 
      phy_data = (unsigned short)((unsigned int)phy_data | 4096U);
      
#line 1210 
      phy_data = (unsigned short)((unsigned int)phy_data & 63487U);
      
#line 1211 
      goto ldv_54836;
      case (unsigned int)3: 
#line 1212 
      ;
      
#line 1213 
      phy_data = (unsigned short)((unsigned int)phy_data & 61439U);
      default: 
#line 1214 
      ;
      
#line 1215 
      goto ldv_54836;
    }
    ldv_54836: 
#line 1217 
    ;
    
#line 1217 
    ret_val = e1000_write_phy_reg(hw,9U,(unsigned short)((int)phy_data));
    
#line 1218 
    if (ret_val != 0) {
      
#line 1219 
      __retres = ret_val;
      
#line 1219 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1222 
  __retres = 0;
  return_label: 
#line 1222 
                return __retres;
}


#line 1229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_copper_link_mgp_setup(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  
#line 1234 
  if ((int)hw->phy_reset_disable != 0) {
    
#line 1235 
    __retres = 0;
    
#line 1235 
    goto return_label;
  }
  else ;
  
#line 1238 
  ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
  
#line 1239 
  if (ret_val != 0) {
    
#line 1240 
    __retres = ret_val;
    
#line 1240 
    goto return_label;
  }
  else ;
  
#line 1242 
  phy_data = (unsigned short)((unsigned int)phy_data | 2048U);
  
#line 1251 
  phy_data = (unsigned short)((unsigned int)phy_data & 65439U);
  
#line 1253 
  switch ((int)hw->mdix) {
    case 1: 
#line 1254 
    ;
    
#line 1255 
    phy_data = phy_data;
    
#line 1256 
    goto ldv_54846;
    case 2: 
#line 1257 
    ;
    
#line 1258 
    phy_data = (unsigned short)((unsigned int)phy_data | 32U);
    
#line 1259 
    goto ldv_54846;
    case 3: 
#line 1260 
    ;
    
#line 1261 
    phy_data = (unsigned short)((unsigned int)phy_data | 64U);
    
#line 1262 
    goto ldv_54846;
    case 0: 
#line 1263 
    ;
    default: 
#line 1264 
    ;
    
#line 1265 
    phy_data = (unsigned short)((unsigned int)phy_data | 96U);
    
#line 1266 
    goto ldv_54846;
  }
  ldv_54846: 
#line 1275 
  ;
  
#line 1275 
  phy_data = (unsigned short)((unsigned int)phy_data & 65533U);
  
#line 1276 
  if ((int)hw->disable_polarity_correction == 1) 
#line 1277 
                                                 phy_data = (unsigned short)((unsigned int)phy_data | 2U); else ;
  
#line 1278 
  ret_val = e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_data));
  
#line 1279 
  if (ret_val != 0) {
    
#line 1280 
    __retres = ret_val;
    
#line 1280 
    goto return_label;
  }
  else ;
  
#line 1282 
  if (hw->phy_revision <= 3U) {
    
#line 1286 
    ret_val = e1000_read_phy_reg(hw,20U,& phy_data);
    
#line 1289 
    if (ret_val != 0) {
      
#line 1290 
      __retres = ret_val;
      
#line 1290 
      goto return_label;
    }
    else ;
    
#line 1292 
    phy_data = (unsigned short)((unsigned int)phy_data | 112U);
    
#line 1294 
    if (hw->phy_revision == 2U && hw->phy_id == 21040320U) {
      
#line 1297 
      phy_data = (unsigned short)((unsigned int)phy_data & 61951U);
      
#line 1298 
      phy_data = (unsigned short)((unsigned int)phy_data | 2048U);
      
#line 1299 
      ret_val = e1000_write_phy_reg(hw,20U,(unsigned short)((int)phy_data));
      
#line 1302 
      if (ret_val != 0) {
        
#line 1303 
        __retres = ret_val;
        
#line 1303 
        goto return_label;
      }
      else ;
    }
    else {
      
#line 1306 
      phy_data = (unsigned short)((unsigned int)phy_data & 61695U);
      
#line 1308 
      phy_data = (unsigned short)((unsigned int)phy_data | 256U);
      
#line 1310 
      ret_val = e1000_write_phy_reg(hw,20U,(unsigned short)((int)phy_data));
      
#line 1313 
      if (ret_val != 0) {
        
#line 1314 
        __retres = ret_val;
        
#line 1314 
        goto return_label;
      }
      else ;
    }
  }
  else ;
  
#line 1319 
  ret_val = e1000_phy_reset(hw);
  
#line 1320 
  if (ret_val != 0) {
    {
      
#line 1321 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_copper_link_mgp_setup", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Resetting the PHY\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1321U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1321 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 1321 
        tmp = e1000_get_hw_dev(hw);
        
#line 1321 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Error Resetting the PHY\n");
      }
      else ;
    }
    
#line 1322 
    __retres = ret_val;
    
#line 1322 
    goto return_label;
  }
  else ;
  
#line 1325 
  __retres = 0;
  return_label: 
#line 1325 
                return __retres;
}


#line 1335  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_copper_link_autoneg(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  
#line 1343 
  hw->autoneg_advertised = (unsigned short)((unsigned int)hw->autoneg_advertised & 47U);
  
#line 1348 
  if ((unsigned int)hw->autoneg_advertised == 0U) 
#line 1349 
                                                  hw->autoneg_advertised = (unsigned short)47U; else ;
  
#line 1352 
  if (hw->phy_type == (unsigned int)3) 
#line 1353 
                                       hw->autoneg_advertised = (unsigned short)((unsigned int)hw->autoneg_advertised & 15U); else ;
  {
    
#line 1355 
    struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_copper_link_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Reconfiguring auto-neg advertisement params\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1355U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1355 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      struct net_device *tmp;
      
#line 1355 
      tmp = e1000_get_hw_dev(hw);
      
#line 1355 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Reconfiguring auto-neg advertisement params\n");
    }
    else ;
  }
  
#line 1356 
  ret_val = e1000_phy_setup_autoneg(hw);
  
#line 1357 
  if (ret_val != 0) {
    {
      
#line 1358 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_copper_link_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Setting up Auto-Negotiation\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1358U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1358 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 1358 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 1358 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Error Setting up Auto-Negotiation\n");
      }
      else ;
    }
    
#line 1359 
    __retres = ret_val;
    
#line 1359 
    goto return_label;
  }
  else ;
  {
    
#line 1361 
    struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_copper_link_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Restarting Auto-Neg\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1361U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1361 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
      struct net_device *tmp_1;
      
#line 1361 
      tmp_1 = e1000_get_hw_dev(hw);
      
#line 1361 
      __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Restarting Auto-Neg\n");
    }
    else ;
  }
  
#line 1366 
  ret_val = e1000_read_phy_reg(hw,0U,& phy_data);
  
#line 1367 
  if (ret_val != 0) {
    
#line 1368 
    __retres = ret_val;
    
#line 1368 
    goto return_label;
  }
  else ;
  
#line 1370 
  phy_data = (unsigned short)((unsigned int)phy_data | 4608U);
  
#line 1371 
  ret_val = e1000_write_phy_reg(hw,0U,(unsigned short)((int)phy_data));
  
#line 1372 
  if (ret_val != 0) {
    
#line 1373 
    __retres = ret_val;
    
#line 1373 
    goto return_label;
  }
  else ;
  
#line 1378 
  if ((unsigned int)hw->wait_autoneg_complete != 0U) {
    
#line 1379 
    ret_val = e1000_wait_autoneg(hw);
    
#line 1380 
    if (ret_val != 0) {
      {
        
#line 1381 
        struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_copper_link_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error while waiting for autoneg to complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1382U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1381 
        if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
          struct net_device *tmp_2;
          
#line 1381 
          tmp_2 = e1000_get_hw_dev(hw);
          
#line 1381 
          __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"Error while waiting for autoneg to complete\n");
        }
        else ;
      }
      
#line 1383 
      __retres = ret_val;
      
#line 1383 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1387 
  hw->get_link_status = (_Bool)1;
  
#line 1389 
  __retres = 0;
  return_label: 
#line 1389 
                return __retres;
}


#line 1405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_copper_link_postconfig(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  
#line 1409 
  if (hw->mac_type > (unsigned int)e1000_82543 && hw->mac_type != (unsigned int)e1000_ce4100) 
    
#line 1410 
    e1000_config_collision_dist(hw);
  else {
    
#line 1412 
    ret_val = e1000_config_mac_to_phy(hw);
    
#line 1413 
    if (ret_val != 0) {
      {
        
#line 1414 
        struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_copper_link_postconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error configuring MAC to PHY settings\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1414U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1414 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
          struct net_device *tmp;
          
#line 1414 
          tmp = e1000_get_hw_dev(hw);
          
#line 1414 
          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Error configuring MAC to PHY settings\n");
        }
        else ;
      }
      
#line 1415 
      __retres = ret_val;
      
#line 1415 
      goto return_label;
    }
    else ;
  }
  
#line 1418 
  ret_val = e1000_config_fc_after_link_up(hw);
  
#line 1419 
  if (ret_val != 0) {
    {
      
#line 1420 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_copper_link_postconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Configuring Flow Control\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1420U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1420 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 1420 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 1420 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Error Configuring Flow Control\n");
      }
      else ;
    }
    
#line 1421 
    __retres = ret_val;
    
#line 1421 
    goto return_label;
  }
  else ;
  
#line 1425 
  if (hw->phy_type == (unsigned int)1) {
    
#line 1426 
    ret_val = e1000_config_dsp_after_link_change(hw,(_Bool)1);
    
#line 1427 
    if (ret_val != 0) {
      {
        
#line 1428 
        struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_copper_link_postconfig", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Configuring DSP after link up\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1428U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1428 
        if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
          struct net_device *tmp_1;
          
#line 1428 
          tmp_1 = e1000_get_hw_dev(hw);
          
#line 1428 
          __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Error Configuring DSP after link up\n");
        }
        else ;
      }
      
#line 1429 
      __retres = ret_val;
      
#line 1429 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1433 
  __retres = 0;
  return_label: 
#line 1433 
                return __retres;
}


#line 1442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_setup_copper_link(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 i;
  u16 phy_data;
  
#line 1449 
  ret_val = e1000_copper_link_preconfig(hw);
  
#line 1450 
  if (ret_val != 0) {
    
#line 1451 
    __retres = ret_val;
    
#line 1451 
    goto return_label;
  }
  else ;
  
#line 1453 
  if (hw->phy_type == (unsigned int)1) {
    
#line 1454 
    ret_val = e1000_copper_link_igp_setup(hw);
    
#line 1455 
    if (ret_val != 0) {
      
#line 1456 
      __retres = ret_val;
      
#line 1456 
      goto return_label;
    }
    else ;
  }
  else 
    
#line 1457 
    if (hw->phy_type == (unsigned int)0) {
      
#line 1458 
      ret_val = e1000_copper_link_mgp_setup(hw);
      
#line 1459 
      if (ret_val != 0) {
        
#line 1460 
        __retres = ret_val;
        
#line 1460 
        goto return_label;
      }
      else ;
    }
    else {
      
#line 1462 
      ret_val = gbe_dhg_phy_setup(hw);
      
#line 1463 
      if (ret_val != 0) {
        {
          
#line 1464 
          struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_setup_copper_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "gbe_dhg_phy_setup failed!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1464U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 1464 
          if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
            struct net_device *tmp;
            
#line 1464 
            tmp = e1000_get_hw_dev(hw);
            
#line 1464 
            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"gbe_dhg_phy_setup failed!\n");
          }
          else ;
        }
        
#line 1465 
        __retres = ret_val;
        
#line 1465 
        goto return_label;
      }
      else ;
    }
  
#line 1469 
  if ((unsigned int)hw->autoneg != 0U) {
    
#line 1473 
    ret_val = e1000_copper_link_autoneg(hw);
    
#line 1474 
    if (ret_val != 0) {
      
#line 1475 
      __retres = ret_val;
      
#line 1475 
      goto return_label;
    }
    else ;
  }
  else {
    {
      
#line 1480 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_setup_copper_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Forcing speed and duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1480U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1480 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 1480 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 1480 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Forcing speed and duplex\n");
      }
      else ;
    }
    
#line 1481 
    ret_val = e1000_phy_force_speed_duplex(hw);
    
#line 1482 
    if (ret_val != 0) {
      {
        
#line 1483 
        struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_setup_copper_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Forcing Speed and Duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1483U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 1483 
        if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
          struct net_device *tmp_1;
          
#line 1483 
          tmp_1 = e1000_get_hw_dev(hw);
          
#line 1483 
          __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Error Forcing Speed and Duplex\n");
        }
        else ;
      }
      
#line 1484 
      __retres = ret_val;
      
#line 1484 
      goto return_label;
    }
    else ;
  }
  
#line 1491 
  i = (unsigned short)0U;
  
#line 1491 
  goto ldv_54883;
  ldv_54882: 
#line 1492 
  ;
  
#line 1492 
  ret_val = e1000_read_phy_reg(hw,1U,& phy_data);
  
#line 1493 
  if (ret_val != 0) {
    
#line 1494 
    __retres = ret_val;
    
#line 1494 
    goto return_label;
  }
  else ;
  
#line 1495 
  ret_val = e1000_read_phy_reg(hw,1U,& phy_data);
  
#line 1496 
  if (ret_val != 0) {
    
#line 1497 
    __retres = ret_val;
    
#line 1497 
    goto return_label;
  }
  else ;
  
#line 1499 
  if (((int)phy_data & 4) != 0) {
    
#line 1501 
    ret_val = e1000_copper_link_postconfig(hw);
    
#line 1502 
    if (ret_val != 0) {
      
#line 1503 
      __retres = ret_val;
      
#line 1503 
      goto return_label;
    }
    else ;
    {
      
#line 1505 
      struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_setup_copper_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Valid link established!!!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1505U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1505 
      if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
        struct net_device *tmp_2;
        
#line 1505 
        tmp_2 = e1000_get_hw_dev(hw);
        
#line 1505 
        __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"Valid link established!!!\n");
      }
      else ;
    }
    
#line 1506 
    __retres = 0;
    
#line 1506 
    goto return_label;
  }
  else ;
  
#line 1508 
  __const_udelay(42950UL);
  
#line 1491 
  i = (u16)((int)i + 1);
  ldv_54883: 
#line 1492 
  ;
  
#line 1491 
  if ((unsigned int)i <= 9U) 
#line 1493 
                             goto ldv_54882; else 
#line 1496 
                                                  goto ldv_54884;
  ldv_54884: 
#line 1497 
  ;
  {
    
#line 1511 
    struct _ddebug descriptor_3 = {.modname = "e1000", .function = "e1000_setup_copper_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Unable to establish link!!!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1511U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1511 
    if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) {
      struct net_device *tmp_3;
      
#line 1511 
      tmp_3 = e1000_get_hw_dev(hw);
      
#line 1511 
      __dynamic_netdev_dbg(& descriptor_3,(struct net_device const *)tmp_3,"Unable to establish link!!!\n");
    }
    else ;
  }
  
#line 1512 
  __retres = 0;
  return_label: 
#line 1512 
                return __retres;
}


#line 1521  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_phy_setup_autoneg(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 mii_autoneg_adv_reg;
  u16 mii_1000t_ctrl_reg;
  
#line 1528 
  ret_val = e1000_read_phy_reg(hw,4U,& mii_autoneg_adv_reg);
  
#line 1529 
  if (ret_val != 0) {
    
#line 1530 
    __retres = ret_val;
    
#line 1530 
    goto return_label;
  }
  else ;
  
#line 1533 
  ret_val = e1000_read_phy_reg(hw,9U,& mii_1000t_ctrl_reg);
  
#line 1534 
  if (ret_val != 0) {
    
#line 1535 
    __retres = ret_val;
    
#line 1535 
    goto return_label;
  }
  else 
    
#line 1536 
    if (hw->phy_type == (unsigned int)3) 
#line 1537 
                                         mii_1000t_ctrl_reg = (unsigned short)((unsigned int)mii_1000t_ctrl_reg & 64767U); else ;
  
#line 1550 
  mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg & 65055U);
  
#line 1551 
  mii_1000t_ctrl_reg = (unsigned short)((unsigned int)mii_1000t_ctrl_reg & 64767U);
  {
    
#line 1553 
    struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "autoneg_advertised %x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1553U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1553 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      struct net_device *tmp;
      
#line 1553 
      ;
      
#line 1553 
      tmp = e1000_get_hw_dev(hw);
      
#line 1553 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"autoneg_advertised %x\n",(int)hw->autoneg_advertised);
    }
    else ;
  }
  
#line 1556 
  if (((int)hw->autoneg_advertised & 1) != 0) {
    {
      
#line 1557 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Advertise 10mb Half duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1557U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1557 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 1557 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 1557 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Advertise 10mb Half duplex\n");
      }
      else ;
    }
    
#line 1558 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg | 32U);
  }
  else ;
  
#line 1562 
  if (((int)hw->autoneg_advertised & 2) != 0) {
    {
      
#line 1563 
      struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Advertise 10mb Full duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1563U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1563 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
        struct net_device *tmp_1;
        
#line 1563 
        tmp_1 = e1000_get_hw_dev(hw);
        
#line 1563 
        __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Advertise 10mb Full duplex\n");
      }
      else ;
    }
    
#line 1564 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg | 64U);
  }
  else ;
  
#line 1568 
  if (((int)hw->autoneg_advertised & 4) != 0) {
    {
      
#line 1569 
      struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Advertise 100mb Half duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1569U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1569 
      if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
        struct net_device *tmp_2;
        
#line 1569 
        tmp_2 = e1000_get_hw_dev(hw);
        
#line 1569 
        __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"Advertise 100mb Half duplex\n");
      }
      else ;
    }
    
#line 1570 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg | 128U);
  }
  else ;
  
#line 1574 
  if (((int)hw->autoneg_advertised & 8) != 0) {
    {
      
#line 1575 
      struct _ddebug descriptor_3 = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Advertise 100mb Full duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1575U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1575 
      if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) {
        struct net_device *tmp_3;
        
#line 1575 
        tmp_3 = e1000_get_hw_dev(hw);
        
#line 1575 
        __dynamic_netdev_dbg(& descriptor_3,(struct net_device const *)tmp_3,"Advertise 100mb Full duplex\n");
      }
      else ;
    }
    
#line 1576 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg | 256U);
  }
  else ;
  
#line 1580 
  if (((int)hw->autoneg_advertised & 16) != 0) {
    
#line 1581 
    struct _ddebug descriptor_4 = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Advertise 1000mb Half duplex requested, request denied!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1582U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1581 
    if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) {
      struct net_device *tmp_4;
      
#line 1581 
      tmp_4 = e1000_get_hw_dev(hw);
      
#line 1581 
      __dynamic_netdev_dbg(& descriptor_4,(struct net_device const *)tmp_4,"Advertise 1000mb Half duplex requested, request denied!\n");
    }
    else ;
  }
  else ;
  
#line 1586 
  if (((int)hw->autoneg_advertised & 32) != 0) {
    {
      
#line 1587 
      struct _ddebug descriptor_5 = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Advertise 1000mb Full duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1587U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1587 
      if ((long)(((int)descriptor_5.flags & 1) != 0) != 0L) {
        struct net_device *tmp_5;
        
#line 1587 
        tmp_5 = e1000_get_hw_dev(hw);
        
#line 1587 
        __dynamic_netdev_dbg(& descriptor_5,(struct net_device const *)tmp_5,"Advertise 1000mb Full duplex\n");
      }
      else ;
    }
    
#line 1588 
    mii_1000t_ctrl_reg = (unsigned short)((unsigned int)mii_1000t_ctrl_reg | 512U);
  }
  else ;
  
#line 1608 
  switch ((unsigned int)hw->fc) {
    case (unsigned int)0: 
#line 1609 
    ;
    
#line 1613 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg & 62463U);
    
#line 1614 
    goto ldv_54901;
    case (unsigned int)1: 
#line 1615 
    ;
    
#line 1625 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg | 3072U);
    
#line 1626 
    goto ldv_54901;
    case (unsigned int)2: 
#line 1627 
    ;
    
#line 1631 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg | 2048U);
    
#line 1632 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg & 64511U);
    
#line 1633 
    goto ldv_54901;
    case (unsigned int)3: 
#line 1634 
    ;
    
#line 1638 
    mii_autoneg_adv_reg = (unsigned short)((unsigned int)mii_autoneg_adv_reg | 3072U);
    
#line 1639 
    goto ldv_54901;
    default: 
#line 1640 
    ;
    {
      
#line 1641 
      struct _ddebug descriptor_6 = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow control param set incorrectly\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1641U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1641 
      if ((long)(((int)descriptor_6.flags & 1) != 0) != 0L) {
        struct net_device *tmp_6;
        
#line 1641 
        tmp_6 = e1000_get_hw_dev(hw);
        
#line 1641 
        __dynamic_netdev_dbg(& descriptor_6,(struct net_device const *)tmp_6,"Flow control param set incorrectly\n");
      }
      else ;
    }
    
#line 1642 
    __retres = -3;
    
#line 1642 
    goto return_label;
  }
  ldv_54901: 
#line 1645 
  ;
  
#line 1645 
  ret_val = e1000_write_phy_reg(hw,4U,(unsigned short)((int)mii_autoneg_adv_reg));
  
#line 1646 
  if (ret_val != 0) {
    
#line 1647 
    __retres = ret_val;
    
#line 1647 
    goto return_label;
  }
  else ;
  {
    
#line 1649 
    struct _ddebug descriptor_7 = {.modname = "e1000", .function = "e1000_phy_setup_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Auto-Neg Advertising %x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1649U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1649 
    if ((long)(((int)descriptor_7.flags & 1) != 0) != 0L) {
      struct net_device *tmp_7;
      
#line 1649 
      ;
      
#line 1649 
      tmp_7 = e1000_get_hw_dev(hw);
      
#line 1649 
      __dynamic_netdev_dbg(& descriptor_7,(struct net_device const *)tmp_7,"Auto-Neg Advertising %x\n",(int)mii_autoneg_adv_reg);
    }
    else ;
  }
  
#line 1651 
  if (hw->phy_type == (unsigned int)3) 
#line 1652 
                                       mii_1000t_ctrl_reg = (unsigned short)0U;
  else {
    
#line 1654 
    ret_val = e1000_write_phy_reg(hw,9U,(unsigned short)((int)mii_1000t_ctrl_reg));
    
#line 1656 
    if (ret_val != 0) {
      
#line 1657 
      __retres = ret_val;
      
#line 1657 
      goto return_label;
    }
    else ;
  }
  
#line 1660 
  __retres = 0;
  return_label: 
#line 1660 
                return __retres;
}


#line 1669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_phy_force_speed_duplex(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl;
  s32 ret_val;
  u16 mii_ctrl_reg;
  u16 mii_status_reg;
  u16 phy_data;
  u16 i;
  
#line 1679 
  hw->fc = E1000_FC_NONE;
  {
    
#line 1681 
    struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_phy_force_speed_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "hw->fc = %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1681U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 1681 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      struct net_device *tmp;
      
#line 1681 
      ;
      
#line 1681 
      tmp = e1000_get_hw_dev(hw);
      
#line 1681 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"hw->fc = %d\n",(unsigned int)hw->fc);
    }
    else ;
  }
  
#line 1684 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 1687 
  ctrl |= 6144U;
  
#line 1688 
  ctrl &= 4294966527U;
  
#line 1691 
  ctrl &= 4294967263U;
  
#line 1694 
  ret_val = e1000_read_phy_reg(hw,0U,& mii_ctrl_reg);
  
#line 1695 
  if (ret_val != 0) {
    
#line 1696 
    __retres = ret_val;
    
#line 1696 
    goto return_label;
  }
  else ;
  
#line 1700 
  mii_ctrl_reg = (unsigned short)((unsigned int)mii_ctrl_reg & 61439U);
  
#line 1703 
  if ((unsigned int)hw->forced_speed_duplex == 3U || (unsigned int)hw->forced_speed_duplex == 1U) {
    
#line 1708 
    ctrl |= 1U;
    
#line 1709 
    mii_ctrl_reg = (unsigned short)((unsigned int)mii_ctrl_reg | 256U);
    {
      
#line 1710 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_phy_force_speed_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Full Duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1710U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1710 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 1710 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 1710 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Full Duplex\n");
      }
      else ;
    }
  }
  else {
    
#line 1715 
    ctrl &= 4294967294U;
    
#line 1716 
    mii_ctrl_reg = (unsigned short)((unsigned int)mii_ctrl_reg & 65279U);
    {
      
#line 1717 
      struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_phy_force_speed_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Half Duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1717U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1717 
      if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
        struct net_device *tmp_1;
        
#line 1717 
        tmp_1 = e1000_get_hw_dev(hw);
        
#line 1717 
        __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Half Duplex\n");
      }
      else ;
    }
  }
  
#line 1721 
  if ((unsigned int)hw->forced_speed_duplex + 254U <= 1U) {
    
#line 1724 
    ctrl |= 256U;
    
#line 1725 
    mii_ctrl_reg = (unsigned short)((unsigned int)mii_ctrl_reg | 8192U);
    
#line 1726 
    mii_ctrl_reg = (unsigned short)((unsigned int)mii_ctrl_reg & 65471U);
    {
      
#line 1727 
      struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_phy_force_speed_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Forcing 100mb ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1727U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1727 
      if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
        struct net_device *tmp_2;
        
#line 1727 
        tmp_2 = e1000_get_hw_dev(hw);
        
#line 1727 
        __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"Forcing 100mb ");
      }
      else ;
    }
  }
  else {
    
#line 1730 
    ctrl &= 4294966527U;
    
#line 1731 
    mii_ctrl_reg = mii_ctrl_reg;
    
#line 1732 
    mii_ctrl_reg = (unsigned short)((unsigned int)mii_ctrl_reg & 57279U);
    {
      
#line 1733 
      struct _ddebug descriptor_3 = {.modname = "e1000", .function = "e1000_phy_force_speed_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Forcing 10mb ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1733U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1733 
      if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) {
        struct net_device *tmp_3;
        
#line 1733 
        tmp_3 = e1000_get_hw_dev(hw);
        
#line 1733 
        __dynamic_netdev_dbg(& descriptor_3,(struct net_device const *)tmp_3,"Forcing 10mb ");
      }
      else ;
    }
  }
  
#line 1736 
  e1000_config_collision_dist(hw);
  
#line 1739 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 1741 
  if (hw->phy_type == (unsigned int)0) {
    
#line 1742 
    ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
    
#line 1744 
    if (ret_val != 0) {
      
#line 1745 
      __retres = ret_val;
      
#line 1745 
      goto return_label;
    }
    else ;
    
#line 1750 
    phy_data = (unsigned short)((unsigned int)phy_data & 65439U);
    
#line 1751 
    ret_val = e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_data));
    
#line 1753 
    if (ret_val != 0) {
      
#line 1754 
      __retres = ret_val;
      
#line 1754 
      goto return_label;
    }
    else ;
    {
      
#line 1756 
      struct _ddebug descriptor_4 = {.modname = "e1000", .function = "e1000_phy_force_speed_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "M88E1000 PSCR: %x\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1756U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1756 
      if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) {
        struct net_device *tmp_4;
        
#line 1756 
        ;
        
#line 1756 
        tmp_4 = e1000_get_hw_dev(hw);
        
#line 1756 
        __dynamic_netdev_dbg(& descriptor_4,(struct net_device const *)tmp_4,"M88E1000 PSCR: %x\n",(int)phy_data);
      }
      else ;
    }
    
#line 1759 
    mii_ctrl_reg = (unsigned short)((unsigned int)mii_ctrl_reg | 32768U);
  }
  else {
    
#line 1766 
    ret_val = e1000_read_phy_reg(hw,18U,& phy_data);
    
#line 1768 
    if (ret_val != 0) {
      
#line 1769 
      __retres = ret_val;
      
#line 1769 
      goto return_label;
    }
    else ;
    
#line 1771 
    phy_data = (unsigned short)((unsigned int)phy_data & 61439U);
    
#line 1772 
    phy_data = (unsigned short)((unsigned int)phy_data & 57343U);
    
#line 1774 
    ret_val = e1000_write_phy_reg(hw,18U,(unsigned short)((int)phy_data));
    
#line 1776 
    if (ret_val != 0) {
      
#line 1777 
      __retres = ret_val;
      
#line 1777 
      goto return_label;
    }
    else ;
  }
  
#line 1781 
  ret_val = e1000_write_phy_reg(hw,0U,(unsigned short)((int)mii_ctrl_reg));
  
#line 1782 
  if (ret_val != 0) {
    
#line 1783 
    __retres = ret_val;
    
#line 1783 
    goto return_label;
  }
  else ;
  
#line 1785 
  __const_udelay(4295UL);
  
#line 1794 
  if ((unsigned int)hw->wait_autoneg_complete != 0U) {
    {
      
#line 1796 
      struct _ddebug descriptor_5 = {.modname = "e1000", .function = "e1000_phy_force_speed_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Waiting for forced speed/duplex link.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1796U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 1796 
      if ((long)(((int)descriptor_5.flags & 1) != 0) != 0L) {
        struct net_device *tmp_5;
        
#line 1796 
        tmp_5 = e1000_get_hw_dev(hw);
        
#line 1796 
        __dynamic_netdev_dbg(& descriptor_5,(struct net_device const *)tmp_5,"Waiting for forced speed/duplex link.\n");
      }
      else ;
    }
    
#line 1797 
    mii_status_reg = (unsigned short)0U;
    
#line 1800 
    i = (unsigned short)20U;
    
#line 1800 
    goto ldv_54927;
    ldv_54926: 
#line 1801 
    ;
    
#line 1804 
    ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
    
#line 1806 
    if (ret_val != 0) {
      
#line 1807 
      __retres = ret_val;
      
#line 1807 
      goto return_label;
    }
    else ;
    
#line 1809 
    ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
    
#line 1811 
    if (ret_val != 0) {
      
#line 1812 
      __retres = ret_val;
      
#line 1812 
      goto return_label;
    }
    else ;
    
#line 1814 
    if (((int)mii_status_reg & 4) != 0) 
#line 1815 
                                        goto ldv_54925; else ;
    
#line 1816 
    msleep(100U);
    
#line 1800 
    i = (u16)((int)i - 1);
    ldv_54927: 
#line 1801 
    ;
    
#line 1800 
    if ((unsigned int)i != 0U) 
#line 1802 
                               goto ldv_54926; else 
#line 1805 
                                                    goto ldv_54925;
    ldv_54925: 
#line 1806 
    ;
    
#line 1818 
    if ((unsigned int)i == 0U && hw->phy_type == (unsigned int)0) {
      
#line 1822 
      ret_val = e1000_phy_reset_dsp(hw);
      
#line 1823 
      if (ret_val != 0) {
        {
          
#line 1824 
          struct _ddebug descriptor_6 = {.modname = "e1000", .function = "e1000_phy_force_speed_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error Resetting PHY DSP\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))1824U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 1824 
          if ((long)(((int)descriptor_6.flags & 1) != 0) != 0L) {
            struct net_device *tmp_6;
            
#line 1824 
            tmp_6 = e1000_get_hw_dev(hw);
            
#line 1824 
            __dynamic_netdev_dbg(& descriptor_6,(struct net_device const *)tmp_6,"Error Resetting PHY DSP\n");
          }
          else ;
        }
        
#line 1825 
        __retres = ret_val;
        
#line 1825 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 1831 
    i = (unsigned short)20U;
    
#line 1831 
    goto ldv_54931;
    ldv_54930: 
#line 1832 
    ;
    
#line 1832 
    if (((int)mii_status_reg & 4) != 0) 
#line 1833 
                                        goto ldv_54929; else ;
    
#line 1834 
    msleep(100U);
    
#line 1838 
    ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
    
#line 1840 
    if (ret_val != 0) {
      
#line 1841 
      __retres = ret_val;
      
#line 1841 
      goto return_label;
    }
    else ;
    
#line 1843 
    ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
    
#line 1845 
    if (ret_val != 0) {
      
#line 1846 
      __retres = ret_val;
      
#line 1846 
      goto return_label;
    }
    else ;
    
#line 1831 
    i = (u16)((int)i - 1);
    ldv_54931: 
#line 1832 
    ;
    
#line 1831 
    if ((unsigned int)i != 0U) 
#line 1833 
                               goto ldv_54930; else 
#line 1836 
                                                    goto ldv_54929;
    ldv_54929: 
#line 1837 
    ;
  }
  else ;
  
#line 1850 
  if (hw->phy_type == (unsigned int)0) {
    
#line 1856 
    ret_val = e1000_read_phy_reg(hw,20U,& phy_data);
    
#line 1859 
    if (ret_val != 0) {
      
#line 1860 
      __retres = ret_val;
      
#line 1860 
      goto return_label;
    }
    else ;
    
#line 1862 
    phy_data = (unsigned short)((unsigned int)phy_data | 112U);
    
#line 1863 
    ret_val = e1000_write_phy_reg(hw,20U,(unsigned short)((int)phy_data));
    
#line 1866 
    if (ret_val != 0) {
      
#line 1867 
      __retres = ret_val;
      
#line 1867 
      goto return_label;
    }
    else ;
    
#line 1873 
    ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
    
#line 1875 
    if (ret_val != 0) {
      
#line 1876 
      __retres = ret_val;
      
#line 1876 
      goto return_label;
    }
    else ;
    
#line 1878 
    phy_data = (unsigned short)((unsigned int)phy_data | 2048U);
    
#line 1879 
    ret_val = e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_data));
    
#line 1881 
    if (ret_val != 0) {
      
#line 1882 
      __retres = ret_val;
      
#line 1882 
      goto return_label;
    }
    else ;
    
#line 1884 
    if (((unsigned int)hw->mac_type + 4294967293U <= 1U && (unsigned int)hw->autoneg == 0U) && (unsigned int)hw->forced_speed_duplex <= 1U) {
      
#line 1888 
      ret_val = e1000_polarity_reversal_workaround(hw);
      
#line 1889 
      if (ret_val != 0) {
        
#line 1890 
        __retres = ret_val;
        
#line 1890 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 1893 
  __retres = 0;
  return_label: 
#line 1893 
                return __retres;
}


#line 1904  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
void e1000_config_collision_dist(struct e1000_hw *hw)
{
  u32 tctl;
  u32 coll_dist;
  
#line 1908 
  if (hw->mac_type <= (unsigned int)e1000_82542_rev2_1) 
#line 1909 
                                                        coll_dist = 64U; else 
                                                                    
#line 1911 
                                                                    coll_dist = 63U;
  
#line 1913 
  tctl = readl((void const volatile *)(hw->hw_addr + 1024U));
  
#line 1915 
  tctl &= 4290777087U;
  
#line 1916 
  tctl = (coll_dist << 12) | tctl;
  
#line 1918 
  writel(tctl,(void volatile *)(hw->hw_addr + 1024U));
  
#line 1919 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 1920 
  return;
}


#line 1931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_config_mac_to_phy(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl;
  s32 ret_val;
  u16 phy_data;
  
#line 1940 
  if (hw->mac_type > (unsigned int)e1000_82543 && hw->mac_type != (unsigned int)e1000_ce4100) {
    
#line 1941 
    __retres = 0;
    
#line 1941 
    goto return_label;
  }
  else ;
  
#line 1946 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 1947 
  ctrl |= 6144U;
  
#line 1948 
  ctrl &= 4294966399U;
  
#line 1950 
  switch ((unsigned int)hw->phy_type) {
    case (unsigned int)3: 
#line 1951 
    ;
    
#line 1952 
    ret_val = e1000_read_phy_reg(hw,0U,& phy_data);
    
#line 1953 
    if (ret_val != 0) {
      
#line 1954 
      __retres = ret_val;
      
#line 1954 
      goto return_label;
    }
    else ;
    
#line 1956 
    if (((int)phy_data & 256) != 0) 
#line 1957 
                                    ctrl |= 1U; else 
#line 1959 
                                                     ctrl &= 4294967294U;
    
#line 1961 
    if (((int)phy_data & 2097152) != 0) 
#line 1962 
                                        ctrl |= 256U; else 
#line 1964 
                                                           ctrl = ctrl;
    
#line 1966 
    e1000_config_collision_dist(hw);
    
#line 1967 
    goto ldv_54944;
    default: 
#line 1968 
    ;
    
#line 1972 
    ret_val = e1000_read_phy_reg(hw,17U,& phy_data);
    
#line 1974 
    if (ret_val != 0) {
      
#line 1975 
      __retres = ret_val;
      
#line 1975 
      goto return_label;
    }
    else ;
    
#line 1977 
    if (((int)phy_data & 8192) != 0) 
#line 1978 
                                     ctrl |= 1U; else 
#line 1980 
                                                      ctrl &= 4294967294U;
    
#line 1982 
    e1000_config_collision_dist(hw);
    
#line 1987 
    if (((int)phy_data & 49152) == 32768) 
#line 1988 
                                          ctrl |= 512U;
    else 
      
#line 1989 
      if (((int)phy_data & 49152) == 16384) 
#line 1991 
                                            ctrl |= 256U; else ;
  }
  ldv_54944: 
#line 1995 
  ;
  
#line 1995 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 1996 
  __retres = 0;
  return_label: 
#line 1996 
                return __retres;
}


#line 2010  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_force_mac_fc(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl;
  
#line 2015 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 2035 
  switch ((unsigned int)hw->fc) {
    case (unsigned int)0: 
#line 2036 
    ;
    
#line 2037 
    ctrl &= 3892314111U;
    
#line 2038 
    goto ldv_54951;
    case (unsigned int)1: 
#line 2039 
    ;
    
#line 2040 
    ctrl &= 4026531839U;
    
#line 2041 
    ctrl |= 134217728U;
    
#line 2042 
    goto ldv_54951;
    case (unsigned int)2: 
#line 2043 
    ;
    
#line 2044 
    ctrl &= 4160749567U;
    
#line 2045 
    ctrl |= 268435456U;
    
#line 2046 
    goto ldv_54951;
    case (unsigned int)3: 
#line 2047 
    ;
    
#line 2048 
    ctrl |= 402653184U;
    
#line 2049 
    goto ldv_54951;
    default: 
#line 2050 
    ;
    {
      
#line 2051 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_force_mac_fc", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow control param set incorrectly\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2051U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2051 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 2051 
        tmp = e1000_get_hw_dev(hw);
        
#line 2051 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Flow control param set incorrectly\n");
      }
      else ;
    }
    
#line 2052 
    __retres = -3;
    
#line 2052 
    goto return_label;
  }
  ldv_54951: 
#line 2056 
  ;
  
#line 2056 
  if (hw->mac_type == (unsigned int)e1000_82542_rev2_0) 
#line 2057 
                                                        ctrl &= 4026531839U; else ;
  
#line 2059 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 2060 
  __retres = 0;
  return_label: 
#line 2060 
                return __retres;
}


#line 2074  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_config_fc_after_link_up(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 mii_status_reg;
  u16 mii_nway_adv_reg;
  u16 mii_nway_lp_ability_reg;
  u16 speed;
  u16 duplex;
  
#line 2088 
  if (((unsigned int)hw->media_type + 4294967295U <= 1U && hw->autoneg_failed != 0U) || (hw->media_type == (unsigned int)e1000_media_type_copper && (unsigned int)hw->autoneg == 0U)) {
    
#line 2092 
    ret_val = e1000_force_mac_fc(hw);
    
#line 2093 
    if (ret_val != 0) {
      {
        
#line 2094 
        struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error forcing flow control settings\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2094U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 2094 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
          struct net_device *tmp;
          
#line 2094 
          tmp = e1000_get_hw_dev(hw);
          
#line 2094 
          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Error forcing flow control settings\n");
        }
        else ;
      }
      
#line 2095 
      __retres = ret_val;
      
#line 2095 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2104 
  if (hw->media_type == (unsigned int)e1000_media_type_copper && (unsigned int)hw->autoneg != 0U) {
    
#line 2109 
    ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
    
#line 2110 
    if (ret_val != 0) {
      
#line 2111 
      __retres = ret_val;
      
#line 2111 
      goto return_label;
    }
    else ;
    
#line 2112 
    ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
    
#line 2113 
    if (ret_val != 0) {
      
#line 2114 
      __retres = ret_val;
      
#line 2114 
      goto return_label;
    }
    else ;
    
#line 2116 
    if (((int)mii_status_reg & 32) != 0) {
      
#line 2123 
      ret_val = e1000_read_phy_reg(hw,4U,& mii_nway_adv_reg);
      
#line 2125 
      if (ret_val != 0) {
        
#line 2126 
        __retres = ret_val;
        
#line 2126 
        goto return_label;
      }
      else ;
      
#line 2127 
      ret_val = e1000_read_phy_reg(hw,5U,& mii_nway_lp_ability_reg);
      
#line 2129 
      if (ret_val != 0) {
        
#line 2130 
        __retres = ret_val;
        
#line 2130 
        goto return_label;
      }
      else ;
      
#line 2167 
      if (((int)mii_nway_adv_reg & 1024) != 0 && ((int)mii_nway_lp_ability_reg & 1024) != 0) 
        
#line 2176 
        if (hw->original_fc == 3U) {
          
#line 2177 
          hw->fc = E1000_FC_FULL;
          {
            
#line 2178 
            struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow Control = FULL.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2178U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 2178 
            if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
              struct net_device *tmp_0;
              
#line 2178 
              tmp_0 = e1000_get_hw_dev(hw);
              
#line 2178 
              __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Flow Control = FULL.\n");
            }
            else ;
          }
        }
        else {
          
#line 2180 
          hw->fc = E1000_FC_RX_PAUSE;
          {
            
#line 2181 
            struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow Control = RX PAUSE frames only.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2182U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 2181 
            if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
              struct net_device *tmp_1;
              
#line 2181 
              tmp_1 = e1000_get_hw_dev(hw);
              
#line 2181 
              __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Flow Control = RX PAUSE frames only.\n");
            }
            else ;
          }
        }
      else 
        
#line 2193 
        if (((((int)mii_nway_adv_reg & 1024) == 0 && ((int)mii_nway_adv_reg & 2048) != 0) && ((int)mii_nway_lp_ability_reg & 1024) != 0) && ((int)mii_nway_lp_ability_reg & 2048) != 0) {
          
#line 2198 
          hw->fc = E1000_FC_TX_PAUSE;
          {
            
#line 2199 
            struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow Control = TX PAUSE frames only.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2200U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 2199 
            if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
              struct net_device *tmp_2;
              
#line 2199 
              tmp_2 = e1000_get_hw_dev(hw);
              
#line 2199 
              __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"Flow Control = TX PAUSE frames only.\n");
            }
            else ;
          }
        }
        else 
          
#line 2210 
          if (((((int)mii_nway_adv_reg & 1024) != 0 && ((int)mii_nway_adv_reg & 2048) != 0) && ((int)mii_nway_lp_ability_reg & 1024) == 0) && ((int)mii_nway_lp_ability_reg & 2048) != 0) {
            
#line 2215 
            hw->fc = E1000_FC_RX_PAUSE;
            {
              
#line 2216 
              struct _ddebug descriptor_3 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow Control = RX PAUSE frames only.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2217U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
              
#line 2216 
              if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) {
                struct net_device *tmp_3;
                
#line 2216 
                tmp_3 = e1000_get_hw_dev(hw);
                
#line 2216 
                __dynamic_netdev_dbg(& descriptor_3,(struct net_device const *)tmp_3,"Flow Control = RX PAUSE frames only.\n");
              }
              else ;
            }
          }
          else 
            
#line 2241 
            if ((hw->original_fc == 0U || hw->original_fc == 2U) || (int)hw->fc_strict_ieee != 0) {
              
#line 2244 
              hw->fc = E1000_FC_NONE;
              {
                
#line 2245 
                struct _ddebug descriptor_4 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow Control = NONE.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2245U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
                
#line 2245 
                if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) {
                  struct net_device *tmp_4;
                  
#line 2245 
                  tmp_4 = e1000_get_hw_dev(hw);
                  
#line 2245 
                  __dynamic_netdev_dbg(& descriptor_4,(struct net_device const *)tmp_4,"Flow Control = NONE.\n");
                }
                else ;
              }
            }
            else {
              
#line 2247 
              hw->fc = E1000_FC_RX_PAUSE;
              {
                
#line 2248 
                struct _ddebug descriptor_5 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Flow Control = RX PAUSE frames only.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2249U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
                
#line 2248 
                if ((long)(((int)descriptor_5.flags & 1) != 0) != 0L) {
                  struct net_device *tmp_5;
                  
#line 2248 
                  tmp_5 = e1000_get_hw_dev(hw);
                  
#line 2248 
                  __dynamic_netdev_dbg(& descriptor_5,(struct net_device const *)tmp_5,"Flow Control = RX PAUSE frames only.\n");
                }
                else ;
              }
            }
      
#line 2256 
      ret_val = e1000_get_speed_and_duplex(hw,& speed,& duplex);
      
#line 2258 
      if (ret_val != 0) {
        {
          
#line 2259 
          struct _ddebug descriptor_6 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error getting link speed and duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2260U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2259 
          if ((long)(((int)descriptor_6.flags & 1) != 0) != 0L) {
            struct net_device *tmp_6;
            
#line 2259 
            tmp_6 = e1000_get_hw_dev(hw);
            
#line 2259 
            __dynamic_netdev_dbg(& descriptor_6,(struct net_device const *)tmp_6,"Error getting link speed and duplex\n");
          }
          else ;
        }
        
#line 2261 
        __retres = ret_val;
        
#line 2261 
        goto return_label;
      }
      else ;
      
#line 2264 
      if ((unsigned int)duplex == 1U) 
#line 2265 
                                      hw->fc = E1000_FC_NONE; else ;
      
#line 2270 
      ret_val = e1000_force_mac_fc(hw);
      
#line 2271 
      if (ret_val != 0) {
        {
          
#line 2272 
          struct _ddebug descriptor_7 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error forcing flow control settings\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2273U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2272 
          if ((long)(((int)descriptor_7.flags & 1) != 0) != 0L) {
            struct net_device *tmp_7;
            
#line 2272 
            tmp_7 = e1000_get_hw_dev(hw);
            
#line 2272 
            __dynamic_netdev_dbg(& descriptor_7,(struct net_device const *)tmp_7,"Error forcing flow control settings\n");
          }
          else ;
        }
        
#line 2274 
        __retres = ret_val;
        
#line 2274 
        goto return_label;
      }
      else ;
    }
    else {
      
#line 2277 
      struct _ddebug descriptor_8 = {.modname = "e1000", .function = "e1000_config_fc_after_link_up", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Copper PHY and Auto Neg has not completed.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2278U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2277 
      if ((long)(((int)descriptor_8.flags & 1) != 0) != 0L) {
        struct net_device *tmp_8;
        
#line 2277 
        tmp_8 = e1000_get_hw_dev(hw);
        
#line 2277 
        __dynamic_netdev_dbg(& descriptor_8,(struct net_device const *)tmp_8,"Copper PHY and Auto Neg has not completed.\n");
      }
      else ;
    }
  }
  else ;
  
#line 2281 
  __retres = 0;
  return_label: 
#line 2281 
                return __retres;
}


#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_check_for_serdes_link_generic(struct e1000_hw *hw)
{
  u32 rxcw;
  u32 ctrl;
  u32 status;
  unsigned int tmp_9;
  
#line 2296 
  s32 ret_val = 0;
  
#line 2298 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 2299 
  status = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2300 
  rxcw = readl((void const volatile *)(hw->hw_addr + 384U));
  
#line 2309 
  if ((status & 2U) == 0U && (rxcw & 536870912U) == 0U) {
    
#line 2310 
    if (hw->autoneg_failed == 0U) {
      
#line 2311 
      hw->autoneg_failed = 1U;
      
#line 2312 
      goto out;
    }
    else ;
    {
      
#line 2314 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "NOT RXing /C/, disable AutoNeg and force link.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2314U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2314 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 2314 
        tmp = e1000_get_hw_dev(hw);
        
#line 2314 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"NOT RXing /C/, disable AutoNeg and force link.\n");
      }
      else ;
    }
    
#line 2317 
    writel(hw->txcw & 2147483647U,(void volatile *)(hw->hw_addr + 376U));
    
#line 2320 
    ctrl = readl((void const volatile *)hw->hw_addr);
    
#line 2321 
    ctrl |= 65U;
    
#line 2322 
    writel(ctrl,(void volatile *)hw->hw_addr);
    
#line 2325 
    ret_val = e1000_config_fc_after_link_up(hw);
    
#line 2326 
    if (ret_val != 0) {
      {
        
#line 2327 
        struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error configuring flow control\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2327U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 2327 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
          struct net_device *tmp_0;
          
#line 2327 
          tmp_0 = e1000_get_hw_dev(hw);
          
#line 2327 
          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Error configuring flow control\n");
        }
        else ;
      }
      
#line 2328 
      goto out;
    }
    else ;
  }
  else 
    
#line 2330 
    if ((ctrl & 64U) != 0U && (rxcw & 536870912U) != 0U) {
      {
        
#line 2336 
        struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "RXing /C/, enable AutoNeg and stop forcing link.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2336U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 2336 
        if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
          struct net_device *tmp_1;
          
#line 2336 
          tmp_1 = e1000_get_hw_dev(hw);
          
#line 2336 
          __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"RXing /C/, enable AutoNeg and stop forcing link.\n");
        }
        else ;
      }
      
#line 2337 
      writel(hw->txcw,(void volatile *)(hw->hw_addr + 376U));
      
#line 2338 
      writel(ctrl & 4294967231U,(void volatile *)hw->hw_addr);
      
#line 2340 
      hw->serdes_has_link = (_Bool)1;
    }
    else {
      unsigned int tmp_4;
      
#line 2341 
      tmp_4 = readl((void const volatile *)(hw->hw_addr + 376U));
      
#line 2341 
      if (tmp_4 >= (unsigned int)0) {
        
#line 2347 
        __const_udelay(42950UL);
        
#line 2348 
        rxcw = readl((void const volatile *)(hw->hw_addr + 384U));
        
#line 2349 
        if ((rxcw & 1073741824U) != 0U) {
          
#line 2350 
          if ((rxcw & 134217728U) == 0U) {
            
#line 2351 
            hw->serdes_has_link = (_Bool)1;
            {
              
#line 2352 
              struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "SERDES: Link up - forced.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2352U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
              
#line 2352 
              if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
                struct net_device *tmp_2;
                
#line 2352 
                tmp_2 = e1000_get_hw_dev(hw);
                
#line 2352 
                __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"SERDES: Link up - forced.\n");
              }
              else ;
            }
          }
          else ;
        }
        else {
          
#line 2355 
          hw->serdes_has_link = (_Bool)0;
          {
            
#line 2356 
            struct _ddebug descriptor_3 = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "SERDES: Link down - force failed.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2356U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 2356 
            if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) {
              struct net_device *tmp_3;
              
#line 2356 
              tmp_3 = e1000_get_hw_dev(hw);
              
#line 2356 
              __dynamic_netdev_dbg(& descriptor_3,(struct net_device const *)tmp_3,"SERDES: Link down - force failed.\n");
            }
            else ;
          }
        }
      }
      else ;
    }
  
#line 2360 
  tmp_9 = readl((void const volatile *)(hw->hw_addr + 376U));
  
#line 2360 
  if (tmp_9 < (unsigned int)0) {
    
#line 2361 
    status = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 2362 
    if ((status & 2U) != 0U) {
      
#line 2364 
      __const_udelay(42950UL);
      
#line 2365 
      rxcw = readl((void const volatile *)(hw->hw_addr + 384U));
      
#line 2366 
      if ((rxcw & 1073741824U) != 0U) 
        
#line 2367 
        if ((rxcw & 134217728U) == 0U) {
          
#line 2368 
          hw->serdes_has_link = (_Bool)1;
          {
            
#line 2369 
            struct _ddebug descriptor_4 = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "SERDES: Link up - autoneg ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2370U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 2369 
            if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) {
              struct net_device *tmp_5;
              
#line 2369 
              tmp_5 = e1000_get_hw_dev(hw);
              
#line 2369 
              __dynamic_netdev_dbg(& descriptor_4,(struct net_device const *)tmp_5,"SERDES: Link up - autoneg ");
            }
            else ;
          }
        }
        else {
          
#line 2372 
          hw->serdes_has_link = (_Bool)0;
          {
            
#line 2373 
            struct _ddebug descriptor_5 = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "SERDES: Link down - invalid", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2374U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
            
#line 2373 
            if ((long)(((int)descriptor_5.flags & 1) != 0) != 0L) {
              struct net_device *tmp_6;
              
#line 2373 
              tmp_6 = e1000_get_hw_dev(hw);
              
#line 2373 
              __dynamic_netdev_dbg(& descriptor_5,(struct net_device const *)tmp_6,"SERDES: Link down - invalid");
            }
            else ;
          }
        }
      else {
        
#line 2377 
        hw->serdes_has_link = (_Bool)0;
        {
          
#line 2378 
          struct _ddebug descriptor_6 = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "SERDES: Link down - no sync.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2378U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2378 
          if ((long)(((int)descriptor_6.flags & 1) != 0) != 0L) {
            struct net_device *tmp_7;
            
#line 2378 
            tmp_7 = e1000_get_hw_dev(hw);
            
#line 2378 
            __dynamic_netdev_dbg(& descriptor_6,(struct net_device const *)tmp_7,"SERDES: Link down - no sync.\n");
          }
          else ;
        }
      }
    }
    else {
      
#line 2381 
      hw->serdes_has_link = (_Bool)0;
      {
        
#line 2382 
        struct _ddebug descriptor_7 = {.modname = "e1000", .function = "e1000_check_for_serdes_link_generic", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "SERDES: Link down - autoneg failed\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2382U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 2382 
        if ((long)(((int)descriptor_7.flags & 1) != 0) != 0L) {
          struct net_device *tmp_8;
          
#line 2382 
          tmp_8 = e1000_get_hw_dev(hw);
          
#line 2382 
          __dynamic_netdev_dbg(& descriptor_7,(struct net_device const *)tmp_8,"SERDES: Link down - autoneg failed\n");
        }
        else ;
      }
    }
  }
  else ;
  out: 
#line 2386 
  ;
  
#line 2387 
  return ret_val;
}


#line 2397  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_check_for_link(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ctrl;
  u32 status;
  u32 rctl;
  u32 icr;
  s32 ret_val;
  u16 phy_data;
  
#line 2399 
  u32 rxcw = 0U;
  
#line 2404 
  u32 signal = 0U;
  
#line 2408 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 2409 
  status = readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2415 
  if ((unsigned int)hw->media_type + 4294967295U <= 1U) {
    
#line 2417 
    rxcw = readl((void const volatile *)(hw->hw_addr + 384U));
    
#line 2419 
    if (hw->media_type == (unsigned int)e1000_media_type_fiber) {
      int tmp;
      
#line 2422 
      if (hw->mac_type > (unsigned int)e1000_82544) 
#line 2422 
                                                    tmp = 524288; else 
                                                                    
#line 2422 
                                                                    tmp = 0;
      
#line 2420 
      signal = (unsigned int)tmp;
      
#line 2423 
      if ((status & 2U) != 0U) 
#line 2424 
                               hw->get_link_status = (_Bool)0; else ;
    }
    else ;
  }
  else ;
  
#line 2434 
  if (hw->media_type == (unsigned int)e1000_media_type_copper && (int)hw->get_link_status != 0) {
    
#line 2440 
    ret_val = e1000_read_phy_reg(hw,1U,& phy_data);
    
#line 2441 
    if (ret_val != 0) {
      
#line 2442 
      __retres = ret_val;
      
#line 2442 
      goto return_label;
    }
    else ;
    
#line 2443 
    ret_val = e1000_read_phy_reg(hw,1U,& phy_data);
    
#line 2444 
    if (ret_val != 0) {
      
#line 2445 
      __retres = ret_val;
      
#line 2445 
      goto return_label;
    }
    else ;
    
#line 2447 
    if (((int)phy_data & 4) != 0) {
      
#line 2448 
      hw->get_link_status = (_Bool)0;
      
#line 2452 
      e1000_check_downshift(hw);
      
#line 2464 
      if (((unsigned int)hw->mac_type + 4294967293U <= 1U && (unsigned int)hw->autoneg == 0U) && (unsigned int)hw->forced_speed_duplex <= 1U) {
        
#line 2467 
        writel(4294967295U,(void volatile *)(hw->hw_addr + 216U));
        
#line 2468 
        ret_val = e1000_polarity_reversal_workaround(hw);
        
#line 2470 
        icr = readl((void const volatile *)(hw->hw_addr + 192U));
        
#line 2471 
        writel(icr & 4294967291U,(void volatile *)(hw->hw_addr + 200U));
        
#line 2472 
        writel(157U,(void volatile *)(hw->hw_addr + 208U));
      }
      else ;
    }
    else {
      
#line 2477 
      e1000_config_dsp_after_link_change(hw,(_Bool)0);
      
#line 2478 
      __retres = 0;
      
#line 2478 
      goto return_label;
    }
    
#line 2484 
    if ((unsigned int)hw->autoneg == 0U) {
      
#line 2485 
      __retres = -3;
      
#line 2485 
      goto return_label;
    }
    else ;
    
#line 2488 
    e1000_config_dsp_after_link_change(hw,(_Bool)1);
    
#line 2498 
    if (hw->mac_type > (unsigned int)e1000_82543 && hw->mac_type != (unsigned int)e1000_ce4100) 
      
#line 2500 
      e1000_config_collision_dist(hw);
    else {
      
#line 2502 
      ret_val = e1000_config_mac_to_phy(hw);
      
#line 2503 
      if (ret_val != 0) {
        {
          
#line 2504 
          struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_check_for_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error configuring MAC to PHY settings\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2505U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2504 
          if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
            struct net_device *tmp_0;
            
#line 2504 
            tmp_0 = e1000_get_hw_dev(hw);
            
#line 2504 
            __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp_0,"Error configuring MAC to PHY settings\n");
          }
          else ;
        }
        
#line 2506 
        __retres = ret_val;
        
#line 2506 
        goto return_label;
      }
      else ;
    }
    
#line 2515 
    ret_val = e1000_config_fc_after_link_up(hw);
    
#line 2516 
    if (ret_val != 0) {
      {
        
#line 2517 
        struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_check_for_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error configuring flow control\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2517U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 2517 
        if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
          struct net_device *tmp_1;
          
#line 2517 
          tmp_1 = e1000_get_hw_dev(hw);
          
#line 2517 
          __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_1,"Error configuring flow control\n");
        }
        else ;
      }
      
#line 2518 
      __retres = ret_val;
      
#line 2518 
      goto return_label;
    }
    else ;
    
#line 2529 
    if ((int)hw->tbi_compatibility_en != 0) {
      u16 speed;
      u16 duplex;
      
#line 2531 
      ret_val = e1000_get_speed_and_duplex(hw,& speed,& duplex);
      
#line 2533 
      if (ret_val != 0) {
        {
          
#line 2534 
          struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_check_for_link", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error getting link speed and duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2535U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2534 
          if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
            struct net_device *tmp_2;
            
#line 2534 
            tmp_2 = e1000_get_hw_dev(hw);
            
#line 2534 
            __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_2,"Error getting link speed and duplex\n");
          }
          else ;
        }
        
#line 2536 
        __retres = ret_val;
        
#line 2536 
        goto return_label;
      }
      else ;
      
#line 2538 
      if ((unsigned int)speed != 1000U) {
        
#line 2542 
        if ((int)hw->tbi_compatibility_on != 0) {
          
#line 2546 
          rctl = readl((void const volatile *)(hw->hw_addr + 256U));
          
#line 2547 
          rctl &= 4294967291U;
          
#line 2548 
          writel(rctl,(void volatile *)(hw->hw_addr + 256U));
          
#line 2549 
          hw->tbi_compatibility_on = (_Bool)0;
        }
        else ;
      }
      else 
        
#line 2558 
        if (! hw->tbi_compatibility_on) {
          
#line 2559 
          hw->tbi_compatibility_on = (_Bool)1;
          
#line 2560 
          rctl = readl((void const volatile *)(hw->hw_addr + 256U));
          
#line 2561 
          rctl |= 4U;
          
#line 2562 
          writel(rctl,(void volatile *)(hw->hw_addr + 256U));
        }
        else ;
    }
    else ;
  }
  else ;
  
#line 2568 
  if ((unsigned int)hw->media_type + 4294967295U <= 1U) 
#line 2570 
                                                        e1000_check_for_serdes_link_generic(hw); else ;
  
#line 2572 
  __retres = 0;
  return_label: 
#line 2572 
                return __retres;
}


#line 2583  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_get_speed_and_duplex(struct e1000_hw *hw, u16 *speed, u16 *duplex)
{
  s32 __retres;
  u32 status;
  s32 ret_val;
  u16 phy_data;
  
#line 2589 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) {
    
#line 2590 
    status = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 2591 
    if ((status & 128U) != 0U) {
      
#line 2592 
      *speed = (unsigned short)1000U;
      {
        
#line 2593 
        struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_get_speed_and_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "1000 Mbs, ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2593U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 2593 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
          struct net_device *tmp;
          
#line 2593 
          tmp = e1000_get_hw_dev(hw);
          
#line 2593 
          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"1000 Mbs, ");
        }
        else ;
      }
    }
    else 
      
#line 2594 
      if ((status & 64U) != 0U) {
        
#line 2595 
        *speed = (unsigned short)100U;
        {
          
#line 2596 
          struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_get_speed_and_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "100 Mbs, ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2596U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2596 
          if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
            struct net_device *tmp_0;
            
#line 2596 
            tmp_0 = e1000_get_hw_dev(hw);
            
#line 2596 
            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"100 Mbs, ");
          }
          else ;
        }
      }
      else {
        
#line 2598 
        *speed = (unsigned short)10U;
        {
          
#line 2599 
          struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_get_speed_and_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "10 Mbs, ", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2599U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2599 
          if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
            struct net_device *tmp_1;
            
#line 2599 
            tmp_1 = e1000_get_hw_dev(hw);
            
#line 2599 
            __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"10 Mbs, ");
          }
          else ;
        }
      }
    
#line 2602 
    if ((status & 1U) != 0U) {
      
#line 2603 
      *duplex = (unsigned short)2U;
      {
        
#line 2604 
        struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_get_speed_and_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Full Duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2604U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 2604 
        if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
          struct net_device *tmp_2;
          
#line 2604 
          tmp_2 = e1000_get_hw_dev(hw);
          
#line 2604 
          __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_2,"Full Duplex\n");
        }
        else ;
      }
    }
    else {
      
#line 2606 
      *duplex = (unsigned short)1U;
      {
        
#line 2607 
        struct _ddebug descriptor_3 = {.modname = "e1000", .function = "e1000_get_speed_and_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = " Half Duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2607U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 2607 
        if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) {
          struct net_device *tmp_3;
          
#line 2607 
          tmp_3 = e1000_get_hw_dev(hw);
          
#line 2607 
          __dynamic_netdev_dbg(& descriptor_3,(struct net_device const *)tmp_3," Half Duplex\n");
        }
        else ;
      }
    }
  }
  else {
    {
      
#line 2610 
      struct _ddebug descriptor_4 = {.modname = "e1000", .function = "e1000_get_speed_and_duplex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "1000 Mbs, Full Duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2610U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2610 
      if ((long)(((int)descriptor_4.flags & 1) != 0) != 0L) {
        struct net_device *tmp_4;
        
#line 2610 
        tmp_4 = e1000_get_hw_dev(hw);
        
#line 2610 
        __dynamic_netdev_dbg(& descriptor_4,(struct net_device const *)tmp_4,"1000 Mbs, Full Duplex\n");
      }
      else ;
    }
    
#line 2611 
    *speed = (unsigned short)1000U;
    
#line 2612 
    *duplex = (unsigned short)2U;
  }
  
#line 2619 
  if (hw->phy_type == (unsigned int)1 && (int)hw->speed_downgraded != 0) {
    
#line 2620 
    ret_val = e1000_read_phy_reg(hw,6U,& phy_data);
    
#line 2621 
    if (ret_val != 0) {
      
#line 2622 
      __retres = ret_val;
      
#line 2622 
      goto return_label;
    }
    else ;
    
#line 2624 
    if (((int)phy_data & 1) == 0) 
#line 2625 
                                  *duplex = (unsigned short)1U;
    else {
      
#line 2627 
      ret_val = e1000_read_phy_reg(hw,5U,& phy_data);
      
#line 2629 
      if (ret_val != 0) {
        
#line 2630 
        __retres = ret_val;
        
#line 2630 
        goto return_label;
      }
      else ;
      
#line 2631 
      if (((unsigned int)*speed == 100U && ((int)phy_data & 256) == 0) || ((unsigned int)*speed == 10U && ((int)phy_data & 64) == 0)) 
        
#line 2635 
        *duplex = (unsigned short)1U; else ;
    }
  }
  else ;
  
#line 2639 
  __retres = 0;
  return_label: 
#line 2639 
                return __retres;
}


#line 2648  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_wait_autoneg(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 i;
  u16 phy_data;
  {
    
#line 2654 
    struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_wait_autoneg", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Waiting for Auto-Neg to complete.\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2654U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 2654 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      struct net_device *tmp;
      
#line 2654 
      tmp = e1000_get_hw_dev(hw);
      
#line 2654 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Waiting for Auto-Neg to complete.\n");
    }
    else ;
  }
  
#line 2657 
  i = (unsigned short)45U;
  
#line 2657 
  goto ldv_55037;
  ldv_55036: 
#line 2658 
  ;
  
#line 2661 
  ret_val = e1000_read_phy_reg(hw,1U,& phy_data);
  
#line 2662 
  if (ret_val != 0) {
    
#line 2663 
    __retres = ret_val;
    
#line 2663 
    goto return_label;
  }
  else ;
  
#line 2664 
  ret_val = e1000_read_phy_reg(hw,1U,& phy_data);
  
#line 2665 
  if (ret_val != 0) {
    
#line 2666 
    __retres = ret_val;
    
#line 2666 
    goto return_label;
  }
  else ;
  
#line 2667 
  if (((int)phy_data & 32) != 0) {
    
#line 2668 
    __retres = 0;
    
#line 2668 
    goto return_label;
  }
  else ;
  
#line 2670 
  msleep(100U);
  
#line 2657 
  i = (u16)((int)i - 1);
  ldv_55037: 
#line 2658 
  ;
  
#line 2657 
  if ((unsigned int)i != 0U) 
#line 2659 
                             goto ldv_55036; else 
#line 2662 
                                                  goto ldv_55038;
  ldv_55038: 
#line 2663 
  ;
  
#line 2672 
  __retres = 0;
  return_label: 
#line 2672 
                return __retres;
}


#line 2680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
  
#line 2685 
  writel(*ctrl | 2097152U,(void volatile *)hw->hw_addr);
  
#line 2686 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2687 
  __const_udelay(42950UL);
  
#line 2689 
  return;
}


#line 2695  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
  
#line 2700 
  writel(*ctrl & 4292870143U,(void volatile *)hw->hw_addr);
  
#line 2701 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2702 
  __const_udelay(42950UL);
  
#line 2704 
  return;
}


#line 2713  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_shift_out_mdi_bits(struct e1000_hw *hw, u32 data, u16 count)
{
  u32 ctrl;
  u32 mask;
  
#line 2722 
  mask = 1U;
  
#line 2723 
  mask <<= (int)count + -1;
  
#line 2725 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 2728 
  ctrl |= 50331648U;
  
#line 2730 
  goto ldv_55055;
  ldv_55054: 
#line 2731 
  ;
  
#line 2736 
  if ((data & mask) != 0U) 
#line 2737 
                           ctrl |= 1048576U; else 
#line 2739 
                                                  ctrl &= 4293918719U;
  
#line 2741 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 2742 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2744 
  __const_udelay(42950UL);
  
#line 2746 
  e1000_raise_mdi_clk(hw,& ctrl);
  
#line 2747 
  e1000_lower_mdi_clk(hw,& ctrl);
  
#line 2749 
  mask >>= 1;
  ldv_55055: 
#line 2750 
  ;
  
#line 2730 
  if (mask != 0U) 
#line 2732 
                  goto ldv_55054; else 
#line 2735 
                                       goto ldv_55056;
  ldv_55056: 
#line 2736 
  ;
  
#line 2737 
  return;
}


#line 2759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static u16 e1000_shift_in_mdi_bits(struct e1000_hw *hw)
{
  u32 ctrl;
  u8 i;
  
#line 2762 
  u16 data = (unsigned short)0U;
  
#line 2772 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 2777 
  ctrl &= 4278190079U;
  
#line 2778 
  ctrl &= 4293918719U;
  
#line 2780 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 2781 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 2787 
  e1000_raise_mdi_clk(hw,& ctrl);
  
#line 2788 
  e1000_lower_mdi_clk(hw,& ctrl);
  
#line 2790 
  data = (unsigned short)0U;
  
#line 2790 
  i = (unsigned char)0U;
  
#line 2790 
  goto ldv_55064;
  ldv_55063: 
#line 2791 
  ;
  
#line 2791 
  data = (unsigned short)((int)data << 1U);
  
#line 2792 
  e1000_raise_mdi_clk(hw,& ctrl);
  
#line 2793 
  ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 2795 
  if ((ctrl & 1048576U) != 0U) 
#line 2796 
                               data = (unsigned short)((unsigned int)data | 1U); else ;
  
#line 2797 
  e1000_lower_mdi_clk(hw,& ctrl);
  
#line 2790 
  i = (u8)((int)i + 1);
  ldv_55064: 
#line 2791 
  ;
  
#line 2790 
  if ((unsigned int)i <= 15U) 
#line 2792 
                              goto ldv_55063; else 
#line 2795 
                                                   goto ldv_55065;
  ldv_55065: 
#line 2796 
  ;
  
#line 2800 
  e1000_raise_mdi_clk(hw,& ctrl);
  
#line 2801 
  e1000_lower_mdi_clk(hw,& ctrl);
  
#line 2803 
  return data;
}


#line 2815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_read_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)
{
  s32 __retres;
  u32 ret_val;
  unsigned long flags;
  s32 tmp_0;
  
#line 2820 
  ldv___ldv_spin_lock_77(& e1000_phy_lock);
  
#line 2822 
  if (hw->phy_type == (unsigned int)1 && reg_addr > 15U) {
    s32 tmp;
    
#line 2824 
    tmp = e1000_write_phy_reg_ex(hw,31U,(unsigned short)((int)((unsigned short)reg_addr)));
    
#line 2824 
    ret_val = (unsigned int)tmp;
    
#line 2826 
    if (ret_val != 0U) {
      
#line 2827 
      ldv_spin_unlock_irqrestore_78(& e1000_phy_lock,flags);
      
#line 2828 
      __retres = (int)ret_val;
      
#line 2828 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2832 
  tmp_0 = e1000_read_phy_reg_ex(hw,reg_addr & 31U,phy_data);
  
#line 2832 
  ret_val = (unsigned int)tmp_0;
  
#line 2834 
  ldv_spin_unlock_irqrestore_79(& e1000_phy_lock,flags);
  
#line 2836 
  __retres = (int)ret_val;
  return_label: 
#line 2836 
                return __retres;
}


#line 2839  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)
{
  s32 __retres;
  u32 i;
  u32 tmp;
  
#line 2843 
  u32 mdic = 0U;
  
#line 2844 
  if (hw->mac_type == (unsigned int)e1000_ce4100) 
#line 2844 
                                                  tmp = hw->phy_addr; else 
                                                                    
#line 2844 
                                                                    tmp = 1U;
  
#line 2844 
  u32 const phy_addr = tmp;
  
#line 2846 
  if (reg_addr > 31U) {
    {
      
#line 2847 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_read_phy_reg_ex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "PHY Address %d is out of range\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2847U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2847 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 2847 
        ;
        
#line 2847 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 2847 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp_0,"PHY Address %d is out of range\n",reg_addr);
      }
      else ;
    }
    
#line 2848 
    __retres = -4;
    
#line 2848 
    goto return_label;
  }
  else ;
  
#line 2851 
  if (hw->mac_type > (unsigned int)e1000_82543) 
    
#line 2856 
    if (hw->mac_type == (unsigned int)e1000_ce4100) {
      
#line 2857 
      mdic = ((reg_addr << 16) | (phy_addr << 21)) | 2147483648U;
      
#line 2862 
      writel(mdic,(void volatile *)(hw->ce4100_gbe_mdio_base_virt + 4U));
      
#line 2867 
      i = 0U;
      
#line 2867 
      goto ldv_55085;
      ldv_55084: 
#line 2868 
      ;
      
#line 2868 
      __const_udelay(214750UL);
      
#line 2869 
      mdic = readl((void const volatile *)(hw->ce4100_gbe_mdio_base_virt + 4U));
      
#line 2870 
      if (mdic >= (u32)0) 
#line 2871 
                          goto ldv_55083; else ;
      
#line 2867 
      i += 1U;
      ldv_55085: 
#line 2868 
      ;
      
#line 2867 
      if (i <= 63U) 
#line 2869 
                    goto ldv_55084; else 
#line 2872 
                                         goto ldv_55083;
      ldv_55083: 
#line 2873 
      ;
      
#line 2874 
      if (mdic < (u32)0) {
        {
          
#line 2875 
          struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_read_phy_reg_ex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "MDI Read did not complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2875U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2875 
          if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
            struct net_device *tmp_1;
            
#line 2875 
            tmp_1 = e1000_get_hw_dev(hw);
            
#line 2875 
            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_1,"MDI Read did not complete\n");
          }
          else ;
        }
        
#line 2876 
        __retres = -2;
        
#line 2876 
        goto return_label;
      }
      else ;
      
#line 2879 
      mdic = readl((void const volatile *)hw->ce4100_gbe_mdio_base_virt);
      
#line 2880 
      if (mdic < (u32)0) {
        {
          
#line 2881 
          struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_read_phy_reg_ex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "MDI Read Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2881U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2881 
          if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
            struct net_device *tmp_2;
            
#line 2881 
            tmp_2 = e1000_get_hw_dev(hw);
            
#line 2881 
            __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_2,"MDI Read Error\n");
          }
          else ;
        }
        
#line 2882 
        __retres = -2;
        
#line 2882 
        goto return_label;
      }
      else ;
      
#line 2884 
      *phy_data = (unsigned short)mdic;
    }
    else {
      
#line 2886 
      mdic = ((reg_addr << 16) | (phy_addr << 21)) | 134217728U;
      
#line 2890 
      writel(mdic,(void volatile *)(hw->hw_addr + 32U));
      
#line 2895 
      i = 0U;
      
#line 2895 
      goto ldv_55090;
      ldv_55089: 
#line 2896 
      ;
      
#line 2896 
      __const_udelay(214750UL);
      
#line 2897 
      mdic = readl((void const volatile *)(hw->hw_addr + 32U));
      
#line 2898 
      if ((mdic & 268435456U) != 0U) 
#line 2899 
                                     goto ldv_55088; else ;
      
#line 2895 
      i += 1U;
      ldv_55090: 
#line 2896 
      ;
      
#line 2895 
      if (i <= 63U) 
#line 2897 
                    goto ldv_55089; else 
#line 2900 
                                         goto ldv_55088;
      ldv_55088: 
#line 2901 
      ;
      
#line 2901 
      if ((mdic & 268435456U) == 0U) {
        {
          
#line 2902 
          struct _ddebug descriptor_2 = {.modname = "e1000", .function = "e1000_read_phy_reg_ex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "MDI Read did not complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2902U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2902 
          if ((long)(((int)descriptor_2.flags & 1) != 0) != 0L) {
            struct net_device *tmp_3;
            
#line 2902 
            tmp_3 = e1000_get_hw_dev(hw);
            
#line 2902 
            __dynamic_netdev_dbg(& descriptor_2,(struct net_device const *)tmp_3,"MDI Read did not complete\n");
          }
          else ;
        }
        
#line 2903 
        __retres = -2;
        
#line 2903 
        goto return_label;
      }
      else ;
      
#line 2905 
      if ((mdic & 1073741824U) != 0U) {
        {
          
#line 2906 
          struct _ddebug descriptor_3 = {.modname = "e1000", .function = "e1000_read_phy_reg_ex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "MDI Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2906U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 2906 
          if ((long)(((int)descriptor_3.flags & 1) != 0) != 0L) {
            struct net_device *tmp_4;
            
#line 2906 
            tmp_4 = e1000_get_hw_dev(hw);
            
#line 2906 
            __dynamic_netdev_dbg(& descriptor_3,(struct net_device const *)tmp_4,"MDI Error\n");
          }
          else ;
        }
        
#line 2907 
        __retres = -2;
        
#line 2907 
        goto return_label;
      }
      else ;
      
#line 2909 
      *phy_data = (unsigned short)mdic;
    }
  else {
    
#line 2916 
    e1000_shift_out_mdi_bits(hw,4294967295U,(unsigned short)32);
    
#line 2930 
    mdic = ((phy_addr << 5) | reg_addr) | 6144U;
    
#line 2933 
    e1000_shift_out_mdi_bits(hw,mdic,(unsigned short)14);
    
#line 2939 
    *phy_data = e1000_shift_in_mdi_bits(hw);
  }
  
#line 2941 
  __retres = 0;
  return_label: 
#line 2941 
                return __retres;
}


#line 2953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_write_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)
{
  s32 __retres;
  u32 ret_val;
  unsigned long flags;
  s32 tmp_0;
  
#line 2958 
  ldv___ldv_spin_lock_80(& e1000_phy_lock);
  
#line 2960 
  if (hw->phy_type == (unsigned int)1 && reg_addr > 15U) {
    s32 tmp;
    
#line 2962 
    tmp = e1000_write_phy_reg_ex(hw,31U,(unsigned short)((int)((unsigned short)reg_addr)));
    
#line 2962 
    ret_val = (unsigned int)tmp;
    
#line 2964 
    if (ret_val != 0U) {
      
#line 2965 
      ldv_spin_unlock_irqrestore_81(& e1000_phy_lock,flags);
      
#line 2966 
      __retres = (int)ret_val;
      
#line 2966 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 2970 
  tmp_0 = e1000_write_phy_reg_ex(hw,reg_addr & 31U,(unsigned short)((int)phy_data));
  
#line 2970 
  ret_val = (unsigned int)tmp_0;
  
#line 2972 
  ldv_spin_unlock_irqrestore_82(& e1000_phy_lock,flags);
  
#line 2974 
  __retres = (int)ret_val;
  return_label: 
#line 2974 
                return __retres;
}


#line 2977  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)
{
  s32 __retres;
  u32 i;
  u32 tmp;
  
#line 2981 
  u32 mdic = 0U;
  
#line 2982 
  if (hw->mac_type == (unsigned int)e1000_ce4100) 
#line 2982 
                                                  tmp = hw->phy_addr; else 
                                                                    
#line 2982 
                                                                    tmp = 1U;
  
#line 2982 
  u32 const phy_addr = tmp;
  
#line 2984 
  if (reg_addr > 31U) {
    {
      
#line 2985 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_write_phy_reg_ex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "PHY Address %d is out of range\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))2985U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 2985 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 2985 
        ;
        
#line 2985 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 2985 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp_0,"PHY Address %d is out of range\n",reg_addr);
      }
      else ;
    }
    
#line 2986 
    __retres = -4;
    
#line 2986 
    goto return_label;
  }
  else ;
  
#line 2989 
  if (hw->mac_type > (unsigned int)e1000_82543) 
    
#line 2995 
    if (hw->mac_type == (unsigned int)e1000_ce4100) {
      
#line 2996 
      mdic = (((unsigned int)phy_data | (reg_addr << 16)) | (phy_addr << 21)) | 2214592512U;
      
#line 3002 
      writel(mdic,(void volatile *)(hw->ce4100_gbe_mdio_base_virt + 4U));
      
#line 3007 
      i = 0U;
      
#line 3007 
      goto ldv_55112;
      ldv_55111: 
#line 3008 
      ;
      
#line 3008 
      __const_udelay(21475UL);
      
#line 3009 
      mdic = readl((void const volatile *)(hw->ce4100_gbe_mdio_base_virt + 4U));
      
#line 3010 
      if (mdic >= (u32)0) 
#line 3011 
                          goto ldv_55110; else ;
      
#line 3007 
      i += 1U;
      ldv_55112: 
#line 3008 
      ;
      
#line 3007 
      if (i <= 639U) 
#line 3009 
                     goto ldv_55111; else 
#line 3012 
                                          goto ldv_55110;
      ldv_55110: 
#line 3013 
      ;
      
#line 3013 
      if (mdic < (u32)0) {
        {
          
#line 3014 
          struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_write_phy_reg_ex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "MDI Write did not complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3014U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 3014 
          if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
            struct net_device *tmp_1;
            
#line 3014 
            tmp_1 = e1000_get_hw_dev(hw);
            
#line 3014 
            __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_1,"MDI Write did not complete\n");
          }
          else ;
        }
        
#line 3015 
        __retres = -2;
        
#line 3015 
        goto return_label;
      }
      else ;
    }
    else {
      
#line 3018 
      mdic = (((unsigned int)phy_data | (reg_addr << 16)) | (phy_addr << 21)) | 67108864U;
      
#line 3023 
      writel(mdic,(void volatile *)(hw->hw_addr + 32U));
      
#line 3028 
      i = 0U;
      
#line 3028 
      goto ldv_55116;
      ldv_55115: 
#line 3029 
      ;
      
#line 3029 
      __const_udelay(21475UL);
      
#line 3030 
      mdic = readl((void const volatile *)(hw->hw_addr + 32U));
      
#line 3031 
      if ((mdic & 268435456U) != 0U) 
#line 3032 
                                     goto ldv_55114; else ;
      
#line 3028 
      i += 1U;
      ldv_55116: 
#line 3029 
      ;
      
#line 3028 
      if (i <= 640U) 
#line 3030 
                     goto ldv_55115; else 
#line 3033 
                                          goto ldv_55114;
      ldv_55114: 
#line 3034 
      ;
      
#line 3034 
      if ((mdic & 268435456U) == 0U) {
        {
          
#line 3035 
          struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_write_phy_reg_ex", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "MDI Write did not complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3035U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
          
#line 3035 
          if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
            struct net_device *tmp_2;
            
#line 3035 
            tmp_2 = e1000_get_hw_dev(hw);
            
#line 3035 
            __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_2,"MDI Write did not complete\n");
          }
          else ;
        }
        
#line 3036 
        __retres = -2;
        
#line 3036 
        goto return_label;
      }
      else ;
    }
  else {
    
#line 3045 
    e1000_shift_out_mdi_bits(hw,4294967295U,(unsigned short)32);
    
#line 3053 
    mdic = ((reg_addr << 2) | (phy_addr << 7)) | 20482U;
    
#line 3055 
    mdic <<= 16;
    
#line 3056 
    mdic = (unsigned int)phy_data | mdic;
    
#line 3058 
    e1000_shift_out_mdi_bits(hw,mdic,(unsigned short)32);
  }
  
#line 3061 
  __retres = 0;
  return_label: 
#line 3061 
                return __retres;
}


#line 3070  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_phy_hw_reset(struct e1000_hw *hw)
{
  u32 ctrl;
  u32 ctrl_ext;
  u32 led_ctrl;
  s32 tmp_0;
  {
    
#line 3075 
    struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_phy_hw_reset", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Resetting Phy...\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3075U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3075 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      struct net_device *tmp;
      
#line 3075 
      tmp = e1000_get_hw_dev(hw);
      
#line 3075 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Resetting Phy...\n");
    }
    else ;
  }
  
#line 3077 
  if (hw->mac_type > (unsigned int)e1000_82543) {
    
#line 3083 
    ctrl = readl((void const volatile *)hw->hw_addr);
    
#line 3084 
    writel(ctrl | 2147483648U,(void volatile *)hw->hw_addr);
    
#line 3085 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 3087 
    msleep(10U);
    
#line 3089 
    writel(ctrl,(void volatile *)hw->hw_addr);
    
#line 3090 
    readl((void const volatile *)(hw->hw_addr + 8U));
  }
  else {
    
#line 3097 
    ctrl_ext = readl((void const volatile *)(hw->hw_addr + 24U));
    
#line 3098 
    ctrl_ext |= 256U;
    
#line 3099 
    ctrl_ext &= 4294967279U;
    
#line 3100 
    writel(ctrl_ext,(void volatile *)(hw->hw_addr + 24U));
    
#line 3101 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 3102 
    msleep(10U);
    
#line 3103 
    ctrl_ext |= 16U;
    
#line 3104 
    writel(ctrl_ext,(void volatile *)(hw->hw_addr + 24U));
    
#line 3105 
    readl((void const volatile *)(hw->hw_addr + 8U));
  }
  
#line 3107 
  __const_udelay(644250UL);
  
#line 3109 
  if (hw->mac_type == (unsigned int)e1000_82541 || hw->mac_type == (unsigned int)e1000_82547) {
    
#line 3111 
    led_ctrl = readl((void const volatile *)(hw->hw_addr + 3584U));
    
#line 3112 
    led_ctrl &= 4294963455U;
    
#line 3113 
    led_ctrl |= 117441280U;
    
#line 3114 
    writel(led_ctrl,(void volatile *)(hw->hw_addr + 3584U));
  }
  else ;
  
#line 3118 
  tmp_0 = e1000_get_phy_cfg_done(hw);
  
#line 3118 
  return tmp_0;
}


#line 3128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_phy_reset(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  
#line 3133 
  switch ((unsigned int)hw->phy_type) {
    case (unsigned int)1: 
#line 3134 
    ;
    
#line 3135 
    ret_val = e1000_phy_hw_reset(hw);
    
#line 3136 
    if (ret_val != 0) {
      
#line 3137 
      __retres = ret_val;
      
#line 3137 
      goto return_label;
    }
    else ;
    
#line 3138 
    goto ldv_55132;
    default: 
#line 3139 
    ;
    
#line 3140 
    ret_val = e1000_read_phy_reg(hw,0U,& phy_data);
    
#line 3141 
    if (ret_val != 0) {
      
#line 3142 
      __retres = ret_val;
      
#line 3142 
      goto return_label;
    }
    else ;
    
#line 3144 
    phy_data = (unsigned short)((unsigned int)phy_data | 32768U);
    
#line 3145 
    ret_val = e1000_write_phy_reg(hw,0U,(unsigned short)((int)phy_data));
    
#line 3146 
    if (ret_val != 0) {
      
#line 3147 
      __retres = ret_val;
      
#line 3147 
      goto return_label;
    }
    else ;
    
#line 3149 
    __const_udelay(4295UL);
    
#line 3150 
    goto ldv_55132;
  }
  ldv_55132: 
#line 3153 
  ;
  
#line 3153 
  if (hw->phy_type == (unsigned int)1) 
#line 3154 
                                       e1000_phy_init_script(hw); else ;
  
#line 3156 
  __retres = 0;
  return_label: 
#line 3156 
                return __retres;
}


#line 3165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_detect_gig_phy(struct e1000_hw *hw)
{
  s32 __retres;
  s32 phy_init_status;
  s32 ret_val;
  u16 phy_id_high;
  u16 phy_id_low;
  
#line 3169 
  bool match = (_Bool)0;
  
#line 3171 
  if (hw->phy_id != 0U) {
    
#line 3172 
    __retres = 0;
    
#line 3172 
    goto return_label;
  }
  else ;
  
#line 3175 
  ret_val = e1000_read_phy_reg(hw,2U,& phy_id_high);
  
#line 3176 
  if (ret_val != 0) {
    
#line 3177 
    __retres = ret_val;
    
#line 3177 
    goto return_label;
  }
  else ;
  
#line 3179 
  hw->phy_id = (unsigned int)((int)phy_id_high << 16);
  
#line 3180 
  __const_udelay(85900UL);
  
#line 3181 
  ret_val = e1000_read_phy_reg(hw,3U,& phy_id_low);
  
#line 3182 
  if (ret_val != 0) {
    
#line 3183 
    __retres = ret_val;
    
#line 3183 
    goto return_label;
  }
  else ;
  
#line 3185 
  hw->phy_id |= (unsigned int)phy_id_low & 4294967280U;
  
#line 3186 
  hw->phy_revision = (unsigned int)phy_id_low & 15U;
  
#line 3188 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)3: 
#line 3189 
    ;
    
#line 3190 
    if (hw->phy_id == 21040208U) 
#line 3191 
                                 match = (_Bool)1; else ;
    
#line 3192 
    goto ldv_55143;
    case (unsigned int)4: 
#line 3193 
    ;
    
#line 3194 
    if (hw->phy_id == 21040176U) 
#line 3195 
                                 match = (_Bool)1; else ;
    
#line 3196 
    goto ldv_55143;
    case (unsigned int)5: 
#line 3197 
    ;
    case (unsigned int)6: 
#line 3198 
    ;
    case (unsigned int)7: 
#line 3199 
    ;
    case (unsigned int)8: 
#line 3200 
    ;
    case (unsigned int)10: 
#line 3201 
    ;
    
#line 3202 
    if (hw->phy_id == 21040160U) 
#line 3203 
                                 match = (_Bool)1; else ;
    
#line 3204 
    goto ldv_55143;
    case (unsigned int)9: 
#line 3205 
    ;
    
#line 3206 
    if ((hw->phy_id == 1886480U || hw->phy_id == 33280U) || hw->phy_id == 21040704U) 
      
#line 3209 
      match = (_Bool)1; else ;
    
#line 3210 
    goto ldv_55143;
    case (unsigned int)11: 
#line 3211 
    ;
    case (unsigned int)12: 
#line 3212 
    ;
    case (unsigned int)13: 
#line 3213 
    ;
    case (unsigned int)14: 
#line 3214 
    ;
    
#line 3215 
    if (hw->phy_id == 44565376U) 
#line 3216 
                                 match = (_Bool)1; else ;
    
#line 3217 
    goto ldv_55143;
    default: 
#line 3218 
    ;
    {
      
#line 3219 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_detect_gig_phy", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Invalid MAC type %d\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3219U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3219 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 3219 
        ;
        
#line 3219 
        tmp = e1000_get_hw_dev(hw);
        
#line 3219 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Invalid MAC type %d\n",(unsigned int)hw->mac_type);
      }
      else ;
    }
    
#line 3220 
    __retres = -3;
    
#line 3220 
    goto return_label;
  }
  ldv_55143: 
#line 3222 
  ;
  
#line 3222 
  phy_init_status = e1000_set_phy_type(hw);
  
#line 3224 
  if ((int)match != 0 && phy_init_status == 0) {
    {
      
#line 3225 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_detect_gig_phy", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "PHY ID 0x%X detected\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3225U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3225 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 3225 
        ;
        
#line 3225 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 3225 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"PHY ID 0x%X detected\n",hw->phy_id);
      }
      else ;
    }
    
#line 3226 
    __retres = 0;
    
#line 3226 
    goto return_label;
  }
  else ;
  {
    
#line 3228 
    struct _ddebug descriptor_1 = {.modname = "e1000", .function = "e1000_detect_gig_phy", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Invalid PHY ID 0x%X\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3228U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 3228 
    if ((long)(((int)descriptor_1.flags & 1) != 0) != 0L) {
      struct net_device *tmp_1;
      
#line 3228 
      ;
      
#line 3228 
      tmp_1 = e1000_get_hw_dev(hw);
      
#line 3228 
      __dynamic_netdev_dbg(& descriptor_1,(struct net_device const *)tmp_1,"Invalid PHY ID 0x%X\n",hw->phy_id);
    }
    else ;
  }
  
#line 3229 
  __retres = -2;
  return_label: 
#line 3229 
                return __retres;
}


#line 3238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_phy_reset_dsp(struct e1000_hw *hw)
{
  s32 ret_val;
  
#line 3243 
  ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)29);
  
#line 3244 
  if (ret_val != 0) 
#line 3245 
                    goto ldv_55164; else ;
  
#line 3246 
  ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)193);
  
#line 3247 
  if (ret_val != 0) 
#line 3248 
                    goto ldv_55164; else ;
  
#line 3249 
  ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)0);
  
#line 3250 
  if (ret_val != 0) 
#line 3251 
                    goto ldv_55164; else ;
  
#line 3252 
  ret_val = 0;
  ldv_55164: 
#line 3253 
  ;
  
#line 3255 
  return ret_val;
}


#line 3265  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_phy_igp_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  u16 min_length;
  u16 max_length;
  u16 average;
  e1000_rev_polarity polarity;
  
#line 3275 
  phy_info->downshift = (int)hw->speed_downgraded;
  
#line 3278 
  phy_info->extended_10bt_distance = 0;
  
#line 3281 
  phy_info->polarity_correction = 0;
  
#line 3284 
  ret_val = e1000_check_polarity(hw,& polarity);
  
#line 3285 
  if (ret_val != 0) {
    
#line 3286 
    __retres = ret_val;
    
#line 3286 
    goto return_label;
  }
  else ;
  
#line 3288 
  phy_info->cable_polarity = polarity;
  
#line 3290 
  ret_val = e1000_read_phy_reg(hw,17U,& phy_data);
  
#line 3291 
  if (ret_val != 0) {
    
#line 3292 
    __retres = ret_val;
    
#line 3292 
    goto return_label;
  }
  else ;
  
#line 3294 
  phy_info->mdix_mode = ((int)phy_data >> 11) & 1;
  
#line 3298 
  if (((int)phy_data & 49152) == 49152) {
    
#line 3303 
    ret_val = e1000_read_phy_reg(hw,10U,& phy_data);
    
#line 3304 
    if (ret_val != 0) {
      
#line 3305 
      __retres = ret_val;
      
#line 3305 
      goto return_label;
    }
    else ;
    
#line 3307 
    phy_info->local_rx = ((int)phy_data >> 13) & 1;
    
#line 3310 
    phy_info->remote_rx = ((int)phy_data >> 12) & 1;
    
#line 3315 
    ret_val = e1000_get_cable_length(hw,& min_length,& max_length);
    
#line 3316 
    if (ret_val != 0) {
      
#line 3317 
      __retres = ret_val;
      
#line 3317 
      goto return_label;
    }
    else ;
    
#line 3320 
    average = (unsigned short)(((int)max_length + (int)min_length) / 2);
    
#line 3322 
    if ((unsigned int)average <= 50U) 
#line 3323 
                                      phy_info->cable_length = 0;
    else 
      
#line 3324 
      if ((unsigned int)average <= 80U) 
#line 3325 
                                        phy_info->cable_length = 1;
      else 
        
#line 3326 
        if ((unsigned int)average <= 110U) 
#line 3327 
                                           phy_info->cable_length = 2;
        else 
          
#line 3328 
          if ((unsigned int)average <= 140U) 
#line 3329 
                                             phy_info->cable_length = 3; else 
                                                                    
#line 3331 
                                                                    phy_info->cable_length = 4;
  }
  else ;
  
#line 3334 
  __retres = 0;
  return_label: 
#line 3334 
                return __retres;
}


#line 3344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_phy_m88_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  e1000_rev_polarity polarity;
  
#line 3354 
  phy_info->downshift = (int)hw->speed_downgraded;
  
#line 3356 
  ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
  
#line 3357 
  if (ret_val != 0) {
    
#line 3358 
    __retres = ret_val;
    
#line 3358 
    goto return_label;
  }
  else ;
  
#line 3360 
  phy_info->extended_10bt_distance = ((int)phy_data >> 7) & 1;
  
#line 3366 
  phy_info->polarity_correction = ((int)phy_data >> 1) & 1;
  
#line 3372 
  ret_val = e1000_check_polarity(hw,& polarity);
  
#line 3373 
  if (ret_val != 0) {
    
#line 3374 
    __retres = ret_val;
    
#line 3374 
    goto return_label;
  }
  else ;
  
#line 3375 
  phy_info->cable_polarity = polarity;
  
#line 3377 
  ret_val = e1000_read_phy_reg(hw,17U,& phy_data);
  
#line 3378 
  if (ret_val != 0) {
    
#line 3379 
    __retres = ret_val;
    
#line 3379 
    goto return_label;
  }
  else ;
  
#line 3381 
  phy_info->mdix_mode = ((int)phy_data >> 6) & 1;
  
#line 3385 
  if (((int)phy_data & 49152) == 32768) {
    
#line 3389 
    phy_info->cable_length = ((int)phy_data >> 7) & 7;
    
#line 3394 
    ret_val = e1000_read_phy_reg(hw,10U,& phy_data);
    
#line 3395 
    if (ret_val != 0) {
      
#line 3396 
      __retres = ret_val;
      
#line 3396 
      goto return_label;
    }
    else ;
    
#line 3398 
    phy_info->local_rx = ((int)phy_data >> 13) & 1;
    
#line 3401 
    phy_info->remote_rx = ((int)phy_data >> 12) & 1;
  }
  else ;
  
#line 3407 
  __retres = 0;
  return_label: 
#line 3407 
                return __retres;
}


#line 3417  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  
#line 3422 
  phy_info->cable_length = 255;
  
#line 3423 
  phy_info->extended_10bt_distance = 255;
  
#line 3424 
  phy_info->cable_polarity = 255;
  
#line 3425 
  phy_info->downshift = 255;
  
#line 3426 
  phy_info->polarity_correction = 255;
  
#line 3427 
  phy_info->mdix_mode = 255;
  
#line 3428 
  phy_info->local_rx = 255;
  
#line 3429 
  phy_info->remote_rx = 255;
  
#line 3431 
  if (hw->media_type != (unsigned int)e1000_media_type_copper) {
    {
      
#line 3432 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_phy_get_info", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "PHY info is only valid for copper media\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3432U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3432 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 3432 
        tmp = e1000_get_hw_dev(hw);
        
#line 3432 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"PHY info is only valid for copper media\n");
      }
      else ;
    }
    
#line 3433 
    __retres = -3;
    
#line 3433 
    goto return_label;
  }
  else ;
  
#line 3436 
  ret_val = e1000_read_phy_reg(hw,1U,& phy_data);
  
#line 3437 
  if (ret_val != 0) {
    
#line 3438 
    __retres = ret_val;
    
#line 3438 
    goto return_label;
  }
  else ;
  
#line 3440 
  ret_val = e1000_read_phy_reg(hw,1U,& phy_data);
  
#line 3441 
  if (ret_val != 0) {
    
#line 3442 
    __retres = ret_val;
    
#line 3442 
    goto return_label;
  }
  else ;
  
#line 3444 
  if (((int)phy_data & 4) == 0) {
    {
      
#line 3445 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_phy_get_info", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "PHY info is only valid if link is up\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3445U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3445 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 3445 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 3445 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"PHY info is only valid if link is up\n");
      }
      else ;
    }
    
#line 3446 
    __retres = -3;
    
#line 3446 
    goto return_label;
  }
  else ;
  
#line 3449 
  if (hw->phy_type == (unsigned int)1) {
    s32 tmp_1;
    
#line 3450 
    tmp_1 = e1000_phy_igp_get_info(hw,phy_info);
    
#line 3450 
    __retres = tmp_1;
    
#line 3450 
    goto return_label;
  }
  else 
    
#line 3451 
    if ((unsigned int)hw->phy_type + 4294967294U <= 1U) {
      
#line 3453 
      __retres = 0;
      
#line 3453 
      goto return_label;
    }
    else {
      s32 tmp_2;
      
#line 3455 
      tmp_2 = e1000_phy_m88_get_info(hw,phy_info);
      
#line 3455 
      __retres = tmp_2;
      
#line 3455 
      goto return_label;
    }
  return_label: 
#line 3449 
                return __retres;
}


#line 3458  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_validate_mdi_setting(struct e1000_hw *hw)
{
  s32 __retres;
  
#line 3460 
  if ((unsigned int)hw->autoneg == 0U && ((unsigned int)hw->mdix == 0U || (unsigned int)hw->mdix == 3U)) {
    {
      
#line 3461 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_validate_mdi_setting", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Invalid MDI setting detected\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3461U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3461 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 3461 
        tmp = e1000_get_hw_dev(hw);
        
#line 3461 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Invalid MDI setting detected\n");
      }
      else ;
    }
    
#line 3462 
    hw->mdix = (unsigned char)1U;
    
#line 3463 
    __retres = -3;
    
#line 3463 
    goto return_label;
  }
  else ;
  
#line 3465 
  __retres = 0;
  return_label: 
#line 3465 
                return __retres;
}


#line 3475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_init_eeprom_params(struct e1000_hw *hw)
{
  s32 __retres;
  u16 eeprom_size;
  
#line 3477 
  struct e1000_eeprom_info *eeprom = & hw->eeprom;
  
#line 3478 
  u32 eecd = readl((void const volatile *)(hw->hw_addr + 16U));
  
#line 3479 
  s32 ret_val = 0;
  
#line 3482 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)1: 
#line 3483 
    ;
    case (unsigned int)2: 
#line 3484 
    ;
    case (unsigned int)3: 
#line 3485 
    ;
    case (unsigned int)4: 
#line 3486 
    ;
    
#line 3487 
    eeprom->type = e1000_eeprom_microwire;
    
#line 3488 
    eeprom->word_size = (unsigned short)64U;
    
#line 3489 
    eeprom->opcode_bits = (unsigned short)3U;
    
#line 3490 
    eeprom->address_bits = (unsigned short)6U;
    
#line 3491 
    eeprom->delay_usec = (unsigned short)50U;
    
#line 3492 
    goto ldv_55207;
    case (unsigned int)5: 
#line 3493 
    ;
    case (unsigned int)6: 
#line 3494 
    ;
    case (unsigned int)7: 
#line 3495 
    ;
    case (unsigned int)8: 
#line 3496 
    ;
    case (unsigned int)10: 
#line 3497 
    ;
    
#line 3498 
    eeprom->type = e1000_eeprom_microwire;
    
#line 3499 
    eeprom->opcode_bits = (unsigned short)3U;
    
#line 3500 
    eeprom->delay_usec = (unsigned short)50U;
    
#line 3501 
    if ((eecd & 512U) != 0U) {
      
#line 3502 
      eeprom->word_size = (unsigned short)256U;
      
#line 3503 
      eeprom->address_bits = (unsigned short)8U;
    }
    else {
      
#line 3505 
      eeprom->word_size = (unsigned short)64U;
      
#line 3506 
      eeprom->address_bits = (unsigned short)6U;
    }
    
#line 3508 
    goto ldv_55207;
    case (unsigned int)11: 
#line 3509 
    ;
    case (unsigned int)12: 
#line 3510 
    ;
    case (unsigned int)13: 
#line 3511 
    ;
    case (unsigned int)14: 
#line 3512 
    ;
    
#line 3513 
    if ((eecd & 8192U) != 0U) {
      
#line 3514 
      eeprom->type = e1000_eeprom_spi;
      
#line 3515 
      eeprom->opcode_bits = (unsigned short)8U;
      
#line 3516 
      eeprom->delay_usec = (unsigned short)1U;
      
#line 3517 
      if ((eecd & 1024U) != 0U) {
        
#line 3518 
        eeprom->page_size = (unsigned short)32U;
        
#line 3519 
        eeprom->address_bits = (unsigned short)16U;
      }
      else {
        
#line 3521 
        eeprom->page_size = (unsigned short)8U;
        
#line 3522 
        eeprom->address_bits = (unsigned short)8U;
      }
    }
    else {
      
#line 3525 
      eeprom->type = e1000_eeprom_microwire;
      
#line 3526 
      eeprom->opcode_bits = (unsigned short)3U;
      
#line 3527 
      eeprom->delay_usec = (unsigned short)50U;
      
#line 3528 
      if ((eecd & 1024U) != 0U) {
        
#line 3529 
        eeprom->word_size = (unsigned short)256U;
        
#line 3530 
        eeprom->address_bits = (unsigned short)8U;
      }
      else {
        
#line 3532 
        eeprom->word_size = (unsigned short)64U;
        
#line 3533 
        eeprom->address_bits = (unsigned short)6U;
      }
    }
    
#line 3536 
    goto ldv_55207;
    default: 
#line 3537 
    ;
    
#line 3538 
    goto ldv_55207;
  }
  ldv_55207: 
#line 3541 
  ;
  
#line 3541 
  if (eeprom->type == (unsigned int)e1000_eeprom_spi) {
    
#line 3546 
    eeprom->word_size = (unsigned short)64U;
    
#line 3547 
    ret_val = e1000_read_eeprom(hw,(unsigned short)18,(unsigned short)1,& eeprom_size);
    
#line 3548 
    if (ret_val != 0) {
      
#line 3549 
      __retres = ret_val;
      
#line 3549 
      goto return_label;
    }
    else ;
    
#line 3550 
    eeprom_size = (unsigned short)((unsigned int)((unsigned short)((int)eeprom_size >> 10)) & 7U);
    
#line 3556 
    if ((unsigned int)eeprom_size != 0U) 
#line 3557 
                                         eeprom_size = (u16)((int)eeprom_size + 1); else ;
    
#line 3559 
    eeprom->word_size = (unsigned short)(1 << ((int)eeprom_size + 6));
  }
  else ;
  
#line 3561 
  __retres = ret_val;
  return_label: 
#line 3561 
                return __retres;
}


#line 3569  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_raise_ee_clk(struct e1000_hw *hw, u32 *eecd)
{
  
#line 3574 
  *eecd |= 1U;
  
#line 3575 
  writel(*eecd,(void volatile *)(hw->hw_addr + 16U));
  
#line 3576 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 3577 
  if (0 != 0) 
    
#line 3577 
    if ((unsigned int)hw->eeprom.delay_usec > 19999U) 
#line 3577 
                                                      __bad_udelay(); else 
                                                                    
#line 3577 
                                                                    __const_udelay((unsigned long)hw->eeprom.delay_usec * 4295UL);
  else 
#line 3577 
       __udelay((unsigned long)hw->eeprom.delay_usec);
  
#line 3579 
  return;
}


#line 3585  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_lower_ee_clk(struct e1000_hw *hw, u32 *eecd)
{
  
#line 3590 
  *eecd &= 4294967294U;
  
#line 3591 
  writel(*eecd,(void volatile *)(hw->hw_addr + 16U));
  
#line 3592 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 3593 
  if (0 != 0) 
    
#line 3593 
    if ((unsigned int)hw->eeprom.delay_usec > 19999U) 
#line 3593 
                                                      __bad_udelay(); else 
                                                                    
#line 3593 
                                                                    __const_udelay((unsigned long)hw->eeprom.delay_usec * 4295UL);
  else 
#line 3593 
       __udelay((unsigned long)hw->eeprom.delay_usec);
  
#line 3595 
  return;
}


#line 3602  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_shift_out_ee_bits(struct e1000_hw *hw, u16 data, u16 count)
{
  u32 eecd;
  u32 mask;
  
#line 3604 
  struct e1000_eeprom_info *eeprom = & hw->eeprom;
  
#line 3612 
  mask = (unsigned int)(1 << ((int)count + -1));
  
#line 3613 
  eecd = readl((void const volatile *)(hw->hw_addr + 16U));
  
#line 3614 
  if (eeprom->type == (unsigned int)e1000_eeprom_microwire) 
#line 3615 
                                                            eecd &= 4294967287U;
  else 
    
#line 3616 
    if (eeprom->type == (unsigned int)e1000_eeprom_spi) 
#line 3617 
                                                        eecd |= 8U; else ;
  ldv_55234: 
#line 3618 
  ;
  
#line 3626 
  eecd &= 4294967291U;
  
#line 3628 
  if (((unsigned int)data & mask) != 0U) 
#line 3629 
                                         eecd |= 4U; else ;
  
#line 3631 
  writel(eecd,(void volatile *)(hw->hw_addr + 16U));
  
#line 3632 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 3634 
  if (0 != 0) 
    
#line 3634 
    if ((unsigned int)eeprom->delay_usec > 19999U) 
#line 3634 
                                                   __bad_udelay(); else 
                                                                    
#line 3634 
                                                                    __const_udelay((unsigned long)eeprom->delay_usec * 4295UL);
  else 
#line 3634 
       __udelay((unsigned long)eeprom->delay_usec);
  
#line 3636 
  e1000_raise_ee_clk(hw,& eecd);
  
#line 3637 
  e1000_lower_ee_clk(hw,& eecd);
  
#line 3639 
  mask >>= 1;
  
#line 3641 
  if (mask != 0U) 
#line 3643 
                  goto ldv_55234; else 
#line 3646 
                                       goto ldv_55235;
  ldv_55235: 
#line 3647 
  ;
  
#line 3644 
  eecd &= 4294967291U;
  
#line 3645 
  writel(eecd,(void volatile *)(hw->hw_addr + 16U));
  
#line 3646 
  return;
}


#line 3653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static u16 e1000_shift_in_ee_bits(struct e1000_hw *hw, u16 count)
{
  u32 eecd;
  u32 i;
  u16 data;
  
#line 3666 
  eecd = readl((void const volatile *)(hw->hw_addr + 16U));
  
#line 3668 
  eecd &= 4294967283U;
  
#line 3669 
  data = (unsigned short)0U;
  
#line 3671 
  i = 0U;
  
#line 3671 
  goto ldv_55244;
  ldv_55243: 
#line 3672 
  ;
  
#line 3672 
  data = (unsigned short)((int)data << 1U);
  
#line 3673 
  e1000_raise_ee_clk(hw,& eecd);
  
#line 3675 
  eecd = readl((void const volatile *)(hw->hw_addr + 16U));
  
#line 3677 
  eecd &= 4294967291U;
  
#line 3678 
  if ((eecd & 8U) != 0U) 
#line 3679 
                         data = (unsigned short)((unsigned int)data | 1U); else ;
  
#line 3681 
  e1000_lower_ee_clk(hw,& eecd);
  
#line 3671 
  i += 1U;
  ldv_55244: 
#line 3672 
  ;
  
#line 3671 
  if ((unsigned int)count > i) 
#line 3673 
                               goto ldv_55243; else 
#line 3676 
                                                    goto ldv_55245;
  ldv_55245: 
#line 3677 
  ;
  
#line 3684 
  return data;
}


#line 3694  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_acquire_eeprom(struct e1000_hw *hw)
{
  s32 __retres;
  u32 eecd;
  
#line 3696 
  struct e1000_eeprom_info *eeprom = & hw->eeprom;
  
#line 3697 
  u32 i = 0U;
  
#line 3699 
  eecd = readl((void const volatile *)(hw->hw_addr + 16U));
  
#line 3702 
  if (hw->mac_type > (unsigned int)e1000_82544) {
    
#line 3703 
    eecd |= 64U;
    
#line 3704 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
    
#line 3705 
    eecd = readl((void const volatile *)(hw->hw_addr + 16U));
    
#line 3706 
    goto ldv_55253;
    ldv_55252: 
#line 3707 
    ;
    
#line 3708 
    i += 1U;
    
#line 3709 
    __const_udelay(21475UL);
    
#line 3710 
    eecd = readl((void const volatile *)(hw->hw_addr + 16U));
    ldv_55253: 
#line 3711 
    ;
    
#line 3706 
    if ((eecd & 128U) == 0U && i <= 999U) 
#line 3709 
                                          goto ldv_55252; else 
#line 3712 
                                                               goto ldv_55254;
    ldv_55254: 
#line 3713 
    ;
    
#line 3712 
    if ((eecd & 128U) == 0U) {
      
#line 3713 
      eecd &= 4294967231U;
      
#line 3714 
      writel(eecd,(void volatile *)(hw->hw_addr + 16U));
      {
        
#line 3715 
        struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_acquire_eeprom", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Could not acquire EEPROM grant\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3715U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 3715 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
          struct net_device *tmp;
          
#line 3715 
          tmp = e1000_get_hw_dev(hw);
          
#line 3715 
          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Could not acquire EEPROM grant\n");
        }
        else ;
      }
      
#line 3716 
      __retres = -1;
      
#line 3716 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 3722 
  if (eeprom->type == (unsigned int)e1000_eeprom_microwire) {
    
#line 3724 
    eecd &= 4294967290U;
    
#line 3725 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
    
#line 3728 
    eecd |= 2U;
    
#line 3729 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
  }
  else 
    
#line 3730 
    if (eeprom->type == (unsigned int)e1000_eeprom_spi) {
      
#line 3732 
      eecd &= 4294967292U;
      
#line 3733 
      writel(eecd,(void volatile *)(hw->hw_addr + 16U));
      
#line 3734 
      readl((void const volatile *)(hw->hw_addr + 8U));
      
#line 3735 
      __const_udelay(4295UL);
    }
    else ;
  
#line 3738 
  __retres = 0;
  return_label: 
#line 3738 
                return __retres;
}


#line 3745  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_standby_eeprom(struct e1000_hw *hw)
{
  u32 eecd;
  
#line 3747 
  struct e1000_eeprom_info *eeprom = & hw->eeprom;
  
#line 3750 
  eecd = readl((void const volatile *)(hw->hw_addr + 16U));
  
#line 3752 
  if (eeprom->type == (unsigned int)e1000_eeprom_microwire) {
    
#line 3753 
    eecd &= 4294967292U;
    
#line 3754 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
    
#line 3755 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 3756 
    if (0 != 0) 
      
#line 3756 
      if ((unsigned int)eeprom->delay_usec > 19999U) 
#line 3756 
                                                     __bad_udelay(); else 
                                                                    
#line 3756 
                                                                    __const_udelay((unsigned long)eeprom->delay_usec * 4295UL);
    else 
#line 3756 
         __udelay((unsigned long)eeprom->delay_usec);
    
#line 3759 
    eecd |= 1U;
    
#line 3760 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
    
#line 3761 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 3762 
    if (0 != 0) 
      
#line 3762 
      if ((unsigned int)eeprom->delay_usec > 19999U) 
#line 3762 
                                                     __bad_udelay(); else 
                                                                    
#line 3762 
                                                                    __const_udelay((unsigned long)eeprom->delay_usec * 4295UL);
    else 
#line 3762 
         __udelay((unsigned long)eeprom->delay_usec);
    
#line 3765 
    eecd |= 2U;
    
#line 3766 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
    
#line 3767 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 3768 
    if (0 != 0) 
      
#line 3768 
      if ((unsigned int)eeprom->delay_usec > 19999U) 
#line 3768 
                                                     __bad_udelay(); else 
                                                                    
#line 3768 
                                                                    __const_udelay((unsigned long)eeprom->delay_usec * 4295UL);
    else 
#line 3768 
         __udelay((unsigned long)eeprom->delay_usec);
    
#line 3771 
    eecd &= 4294967294U;
    
#line 3772 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
    
#line 3773 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 3774 
    if (0 != 0) 
      
#line 3774 
      if ((unsigned int)eeprom->delay_usec > 19999U) 
#line 3774 
                                                     __bad_udelay(); else 
                                                                    
#line 3774 
                                                                    __const_udelay((unsigned long)eeprom->delay_usec * 4295UL);
    else 
#line 3774 
         __udelay((unsigned long)eeprom->delay_usec);
  }
  else 
    
#line 3775 
    if (eeprom->type == (unsigned int)e1000_eeprom_spi) {
      
#line 3777 
      eecd |= 2U;
      
#line 3778 
      writel(eecd,(void volatile *)(hw->hw_addr + 16U));
      
#line 3779 
      readl((void const volatile *)(hw->hw_addr + 8U));
      
#line 3780 
      if (0 != 0) 
        
#line 3780 
        if ((unsigned int)eeprom->delay_usec > 19999U) 
#line 3780 
                                                       __bad_udelay(); else 
                                                                    
#line 3780 
                                                                    __const_udelay((unsigned long)eeprom->delay_usec * 4295UL);
      else 
#line 3780 
           __udelay((unsigned long)eeprom->delay_usec);
      
#line 3781 
      eecd &= 4294967293U;
      
#line 3782 
      writel(eecd,(void volatile *)(hw->hw_addr + 16U));
      
#line 3783 
      readl((void const volatile *)(hw->hw_addr + 8U));
      
#line 3784 
      if (0 != 0) 
        
#line 3784 
        if ((unsigned int)eeprom->delay_usec > 19999U) 
#line 3784 
                                                       __bad_udelay(); else 
                                                                    
#line 3784 
                                                                    __const_udelay((unsigned long)eeprom->delay_usec * 4295UL);
      else 
#line 3784 
           __udelay((unsigned long)eeprom->delay_usec);
    }
    else ;
  
#line 3787 
  return;
}


#line 3794  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_release_eeprom(struct e1000_hw *hw)
{
  u32 eecd;
  
#line 3798 
  eecd = readl((void const volatile *)(hw->hw_addr + 16U));
  
#line 3800 
  if (hw->eeprom.type == (unsigned int)e1000_eeprom_spi) {
    
#line 3801 
    eecd |= 2U;
    
#line 3802 
    eecd &= 4294967294U;
    
#line 3804 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
    
#line 3805 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 3807 
    if (0 != 0) 
      
#line 3807 
      if ((unsigned int)hw->eeprom.delay_usec > 19999U) 
#line 3807 
                                                        __bad_udelay(); else 
                                                                    
#line 3807 
                                                                    __const_udelay((unsigned long)hw->eeprom.delay_usec * 4295UL);
    else 
#line 3807 
         __udelay((unsigned long)hw->eeprom.delay_usec);
  }
  else 
    
#line 3808 
    if (hw->eeprom.type == (unsigned int)e1000_eeprom_microwire) {
      
#line 3812 
      eecd &= 4294967289U;
      
#line 3814 
      writel(eecd,(void volatile *)(hw->hw_addr + 16U));
      
#line 3817 
      eecd |= 1U;
      
#line 3818 
      writel(eecd,(void volatile *)(hw->hw_addr + 16U));
      
#line 3819 
      readl((void const volatile *)(hw->hw_addr + 8U));
      
#line 3820 
      if (0 != 0) 
        
#line 3820 
        if ((unsigned int)hw->eeprom.delay_usec > 19999U) 
#line 3820 
                                                          __bad_udelay(); else 
                                                                    
#line 3820 
                                                                    __const_udelay((unsigned long)hw->eeprom.delay_usec * 4295UL);
      else 
#line 3820 
           __udelay((unsigned long)hw->eeprom.delay_usec);
      
#line 3823 
      eecd &= 4294967294U;
      
#line 3824 
      writel(eecd,(void volatile *)(hw->hw_addr + 16U));
      
#line 3825 
      readl((void const volatile *)(hw->hw_addr + 8U));
      
#line 3826 
      if (0 != 0) 
        
#line 3826 
        if ((unsigned int)hw->eeprom.delay_usec > 19999U) 
#line 3826 
                                                          __bad_udelay(); else 
                                                                    
#line 3826 
                                                                    __const_udelay((unsigned long)hw->eeprom.delay_usec * 4295UL);
      else 
#line 3826 
           __udelay((unsigned long)hw->eeprom.delay_usec);
    }
    else ;
  
#line 3830 
  if (hw->mac_type > (unsigned int)e1000_82544) {
    
#line 3831 
    eecd &= 4294967231U;
    
#line 3832 
    writel(eecd,(void volatile *)(hw->hw_addr + 16U));
  }
  else ;
  
#line 3834 
  return;
}


#line 3840  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_spi_eeprom_ready(struct e1000_hw *hw)
{
  s32 __retres;
  u8 spi_stat_reg;
  u16 tmp;
  
#line 3842 
  u16 retry_count = (unsigned short)0U;
  
#line 3850 
  retry_count = (unsigned short)0U;
  ldv_55272: 
#line 3851 
  ;
  
#line 3852 
  e1000_shift_out_ee_bits(hw,(unsigned short)5,(unsigned short)((int)hw->eeprom.opcode_bits));
  
#line 3854 
  tmp = e1000_shift_in_ee_bits(hw,(unsigned short)8);
  
#line 3854 
  spi_stat_reg = (unsigned char)tmp;
  
#line 3855 
  if (((int)spi_stat_reg & 1) == 0) 
#line 3856 
                                    goto ldv_55271; else ;
  
#line 3858 
  __const_udelay(21475UL);
  
#line 3859 
  retry_count = (unsigned short)((unsigned int)retry_count + 5U);
  
#line 3861 
  e1000_standby_eeprom(hw);
  
#line 3862 
  if ((unsigned int)retry_count <= 4999U) 
#line 3864 
                                          goto ldv_55272; else 
#line 3867 
                                                               goto ldv_55271;
  ldv_55271: 
#line 3868 
  ;
  
#line 3867 
  if ((unsigned int)retry_count > 4999U) {
    {
      
#line 3868 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_spi_eeprom_ready", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "SPI EEPROM Status error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3868U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3868 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 3868 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 3868 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp_0,"SPI EEPROM Status error\n");
      }
      else ;
    }
    
#line 3869 
    __retres = -1;
    
#line 3869 
    goto return_label;
  }
  else ;
  
#line 3872 
  __retres = 0;
  return_label: 
#line 3872 
                return __retres;
}


#line 3882  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
{
  s32 ret;
  
#line 3885 
  ldv_spin_lock_83(& e1000_eeprom_lock);
  
#line 3886 
  ret = e1000_do_read_eeprom(hw,(unsigned short)((int)offset),(unsigned short)((int)words),data);
  
#line 3887 
  ldv_spin_unlock_84(& e1000_eeprom_lock);
  
#line 3888 
  return ret;
}


#line 3891  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_do_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
{
  s32 __retres;
  s32 tmp_1;
  
#line 3894 
  struct e1000_eeprom_info *eeprom = & hw->eeprom;
  
#line 3895 
  u32 i = 0U;
  
#line 3897 
  if (hw->mac_type == (unsigned int)e1000_ce4100) {
    void *tmp;
    
#line 3898 
    ;
    
#line 3898 
    ;
    
#line 3898 
    tmp = phys_to_virt(393216ULL);
    
#line 3898 
    ;
    
#line 3898 
    ioread16_rep(tmp + ((int)offset << 1),(void *)data,(unsigned long)words);
    
#line 3900 
    __retres = 0;
    
#line 3900 
    goto return_label;
  }
  else ;
  
#line 3904 
  if ((unsigned int)eeprom->word_size == 0U) 
#line 3905 
                                             e1000_init_eeprom_params(hw); else ;
  
#line 3910 
  if (((int)eeprom->word_size <= (int)offset || (int)words > (int)eeprom->word_size - (int)offset) || (unsigned int)words == 0U) {
    {
      
#line 3912 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_do_read_eeprom", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "\"words\" parameter out of bounds. Words = %d,", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3913U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3912 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 3912 
        ;
        
#line 3912 
        ;
        
#line 3912 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 3912 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp_0,"\"words\" parameter out of bounds. Words = %d,",(int)offset,(int)eeprom->word_size);
      }
      else ;
    }
    
#line 3914 
    __retres = -1;
    
#line 3914 
    goto return_label;
  }
  else ;
  
#line 3922 
  tmp_1 = e1000_acquire_eeprom(hw);
  
#line 3922 
  if (tmp_1 != 0) {
    
#line 3923 
    __retres = -1;
    
#line 3923 
    goto return_label;
  }
  else ;
  
#line 3928 
  if (eeprom->type == (unsigned int)e1000_eeprom_spi) {
    u16 word_in;
    s32 tmp_2;
    
#line 3930 
    u8 read_opcode = (unsigned char)3U;
    
#line 3932 
    tmp_2 = e1000_spi_eeprom_ready(hw);
    
#line 3932 
    if (tmp_2 != 0) {
      
#line 3933 
      e1000_release_eeprom(hw);
      
#line 3934 
      __retres = -1;
      
#line 3934 
      goto return_label;
    }
    else ;
    
#line 3937 
    e1000_standby_eeprom(hw);
    
#line 3942 
    if ((unsigned int)eeprom->address_bits == 8U && (unsigned int)offset > 127U) 
      
#line 3943 
      read_opcode = (unsigned char)((unsigned int)read_opcode | 8U); else ;
    
#line 3946 
    e1000_shift_out_ee_bits(hw,(unsigned short)((int)read_opcode),(unsigned short)((int)eeprom->opcode_bits));
    
#line 3947 
    e1000_shift_out_ee_bits(hw,(unsigned short)((int)((unsigned int)offset * 2U)),(unsigned short)((int)eeprom->address_bits));
    
#line 3957 
    i = 0U;
    
#line 3957 
    goto ldv_55295;
    ldv_55294: 
#line 3958 
    ;
    
#line 3958 
    word_in = e1000_shift_in_ee_bits(hw,(unsigned short)16);
    
#line 3959 
    *(data + i) = (unsigned short)(((int)word_in >> 8) | ((int)word_in << 8));
    
#line 3957 
    i += 1U;
    ldv_55295: 
#line 3958 
    ;
    
#line 3957 
    if ((unsigned int)words > i) 
#line 3959 
                                 goto ldv_55294; else 
#line 3962 
                                                      goto ldv_55296;
    ldv_55296: 
#line 3963 
    ;
  }
  else 
    
#line 3961 
    if (eeprom->type == (unsigned int)e1000_eeprom_microwire) {
      
#line 3962 
      i = 0U;
      
#line 3962 
      goto ldv_55298;
      ldv_55297: 
#line 3963 
      ;
      
#line 3964 
      e1000_shift_out_ee_bits(hw,(unsigned short)6,(unsigned short)((int)eeprom->opcode_bits));
      
#line 3967 
      e1000_shift_out_ee_bits(hw,(unsigned short)((int)((unsigned short)i) + (int)offset),(unsigned short)((int)eeprom->address_bits));
      
#line 3973 
      *(data + i) = e1000_shift_in_ee_bits(hw,(unsigned short)16);
      
#line 3974 
      e1000_standby_eeprom(hw);
      
#line 3962 
      i += 1U;
      ldv_55298: 
#line 3963 
      ;
      
#line 3962 
      if ((unsigned int)words > i) 
#line 3964 
                                   goto ldv_55297; else 
#line 3967 
                                                        goto ldv_55299;
      ldv_55299: 
#line 3968 
      ;
    }
    else ;
  
#line 3979 
  e1000_release_eeprom(hw);
  
#line 3981 
  __retres = 0;
  return_label: 
#line 3981 
                return __retres;
}


#line 3992  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_validate_eeprom_checksum(struct e1000_hw *hw)
{
  s32 __retres;
  u16 i;
  u16 eeprom_data;
  s32 tmp_0;
  
#line 3994 
  u16 checksum = (unsigned short)0U;
  
#line 3997 
  i = (unsigned short)0U;
  
#line 3997 
  goto ldv_55309;
  ldv_55308: 
#line 3998 
  ;
  
#line 3998 
  tmp_0 = e1000_read_eeprom(hw,(unsigned short)((int)i),(unsigned short)1,& eeprom_data);
  
#line 3998 
  if (tmp_0 < 0) {
    {
      
#line 3999 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_validate_eeprom_checksum", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Read Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))3999U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 3999 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 3999 
        tmp = e1000_get_hw_dev(hw);
        
#line 3999 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"EEPROM Read Error\n");
      }
      else ;
    }
    
#line 4000 
    __retres = -1;
    
#line 4000 
    goto return_label;
  }
  else ;
  
#line 4002 
  checksum = (unsigned short)((int)checksum + (int)eeprom_data);
  
#line 3997 
  i = (u16)((int)i + 1);
  ldv_55309: 
#line 3998 
  ;
  
#line 3997 
  if ((unsigned int)i <= 63U) 
#line 3999 
                              goto ldv_55308; else 
#line 4002 
                                                   goto ldv_55310;
  ldv_55310: 
#line 4003 
  ;
  
#line 4011 
  if ((unsigned int)checksum == 47802U) {
    
#line 4012 
    __retres = 0;
    
#line 4012 
    goto return_label;
  }
  else {
    {
      
#line 4014 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_validate_eeprom_checksum", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Checksum Invalid\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4014U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 4014 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_1;
        
#line 4014 
        tmp_1 = e1000_get_hw_dev(hw);
        
#line 4014 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_1,"EEPROM Checksum Invalid\n");
      }
      else ;
    }
    
#line 4015 
    __retres = -1;
    
#line 4015 
    goto return_label;
  }
  return_label: 
#line 4011 
                return __retres;
}


#line 4026  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_update_eeprom_checksum(struct e1000_hw *hw)
{
  s32 __retres;
  u16 i;
  u16 eeprom_data;
  s32 tmp_0;
  s32 tmp_2;
  
#line 4028 
  u16 checksum = (unsigned short)0U;
  
#line 4031 
  i = (unsigned short)0U;
  
#line 4031 
  goto ldv_55321;
  ldv_55320: 
#line 4032 
  ;
  
#line 4032 
  tmp_0 = e1000_read_eeprom(hw,(unsigned short)((int)i),(unsigned short)1,& eeprom_data);
  
#line 4032 
  if (tmp_0 < 0) {
    {
      
#line 4033 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_update_eeprom_checksum", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Read Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4033U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 4033 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 4033 
        tmp = e1000_get_hw_dev(hw);
        
#line 4033 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"EEPROM Read Error\n");
      }
      else ;
    }
    
#line 4034 
    __retres = -1;
    
#line 4034 
    goto return_label;
  }
  else ;
  
#line 4036 
  checksum = (unsigned short)((int)checksum + (int)eeprom_data);
  
#line 4031 
  i = (u16)((int)i + 1);
  ldv_55321: 
#line 4032 
  ;
  
#line 4031 
  if ((unsigned int)i <= 62U) 
#line 4033 
                              goto ldv_55320; else 
#line 4036 
                                                   goto ldv_55322;
  ldv_55322: 
#line 4037 
  ;
  
#line 4038 
  checksum = (unsigned short)(47802U - (unsigned int)checksum);
  
#line 4039 
  tmp_2 = e1000_write_eeprom(hw,(unsigned short)63,(unsigned short)1,& checksum);
  
#line 4039 
  if (tmp_2 < 0) {
    {
      
#line 4040 
      struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_update_eeprom_checksum", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Write Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4040U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 4040 
      if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
        struct net_device *tmp_1;
        
#line 4040 
        tmp_1 = e1000_get_hw_dev(hw);
        
#line 4040 
        __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_1,"EEPROM Write Error\n");
      }
      else ;
    }
    
#line 4041 
    __retres = -1;
    
#line 4041 
    goto return_label;
  }
  else ;
  
#line 4043 
  __retres = 0;
  return_label: 
#line 4043 
                return __retres;
}


#line 4056  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
{
  s32 ret;
  
#line 4059 
  ldv_spin_lock_85(& e1000_eeprom_lock);
  
#line 4060 
  ret = e1000_do_write_eeprom(hw,(unsigned short)((int)offset),(unsigned short)((int)words),data);
  
#line 4061 
  ldv_spin_unlock_86(& e1000_eeprom_lock);
  
#line 4062 
  return ret;
}


#line 4065  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_do_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
{
  s32 __retres;
  s32 tmp_1;
  
#line 4068 
  struct e1000_eeprom_info *eeprom = & hw->eeprom;
  
#line 4069 
  s32 status = 0;
  
#line 4071 
  if (hw->mac_type == (unsigned int)e1000_ce4100) {
    void *tmp;
    
#line 4072 
    ;
    
#line 4072 
    ;
    
#line 4072 
    tmp = phys_to_virt(393216ULL);
    
#line 4072 
    ;
    
#line 4072 
    iowrite16_rep(tmp + (int)offset,(void const *)data,(unsigned long)words);
    
#line 4074 
    __retres = 0;
    
#line 4074 
    goto return_label;
  }
  else ;
  
#line 4078 
  if ((unsigned int)eeprom->word_size == 0U) 
#line 4079 
                                             e1000_init_eeprom_params(hw); else ;
  
#line 4084 
  if (((int)eeprom->word_size <= (int)offset || (int)words > (int)eeprom->word_size - (int)offset) || (unsigned int)words == 0U) {
    {
      
#line 4086 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_do_write_eeprom", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "\"words\" parameter out of bounds\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4086U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 4086 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp_0;
        
#line 4086 
        tmp_0 = e1000_get_hw_dev(hw);
        
#line 4086 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp_0,"\"words\" parameter out of bounds\n");
      }
      else ;
    }
    
#line 4087 
    __retres = -1;
    
#line 4087 
    goto return_label;
  }
  else ;
  
#line 4091 
  tmp_1 = e1000_acquire_eeprom(hw);
  
#line 4091 
  if (tmp_1 != 0) {
    
#line 4092 
    __retres = -1;
    
#line 4092 
    goto return_label;
  }
  else ;
  
#line 4094 
  if (eeprom->type == (unsigned int)e1000_eeprom_microwire) 
#line 4095 
                                                            status = e1000_write_eeprom_microwire(hw,(unsigned short)((int)offset),(unsigned short)((int)words),data);
  else {
    
#line 4097 
    status = e1000_write_eeprom_spi(hw,(unsigned short)((int)offset),(unsigned short)((int)words),data);
    
#line 4098 
    msleep(10U);
  }
  
#line 4102 
  e1000_release_eeprom(hw);
  
#line 4104 
  __retres = status;
  return_label: 
#line 4104 
                return __retres;
}


#line 4114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_write_eeprom_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
{
  s32 __retres;
  
#line 4117 
  struct e1000_eeprom_info *eeprom = & hw->eeprom;
  
#line 4118 
  u16 widx = (unsigned short)0U;
  
#line 4120 
  goto ldv_55355;
  ldv_55354: 
#line 4121 
  ;
  {
    s32 tmp;
    
#line 4121 
    u8 write_opcode = (unsigned char)2U;
    
#line 4123 
    tmp = e1000_spi_eeprom_ready(hw);
    
#line 4123 
    if (tmp != 0) {
      
#line 4124 
      __retres = -1;
      
#line 4124 
      goto return_label;
    }
    else ;
    
#line 4126 
    e1000_standby_eeprom(hw);
    
#line 4129 
    e1000_shift_out_ee_bits(hw,(unsigned short)6,(unsigned short)((int)eeprom->opcode_bits));
    
#line 4132 
    e1000_standby_eeprom(hw);
    
#line 4137 
    if ((unsigned int)eeprom->address_bits == 8U && (unsigned int)offset > 127U) 
      
#line 4138 
      write_opcode = (unsigned char)((unsigned int)write_opcode | 8U); else ;
    
#line 4141 
    e1000_shift_out_ee_bits(hw,(unsigned short)((int)write_opcode),(unsigned short)((int)eeprom->opcode_bits));
    
#line 4143 
    e1000_shift_out_ee_bits(hw,(unsigned short)((int)((unsigned int)((int)offset + (int)widx) * 2U)),(unsigned short)((int)eeprom->address_bits));
    
#line 4151 
    goto ldv_55353;
    ldv_55352: 
#line 4152 
    ;
    {
      
#line 4152 
      u16 word_out = *(data + (int)widx);
      
#line 4153 
      word_out = (unsigned short)(((int)word_out >> 8) | ((int)word_out << 8));
      
#line 4154 
      e1000_shift_out_ee_bits(hw,(unsigned short)((int)word_out),(unsigned short)16);
      
#line 4155 
      widx = (u16)((int)widx + 1);
      
#line 4162 
      if ((((int)offset + (int)widx) * 2) % (int)eeprom->page_size == 0) {
        
#line 4163 
        e1000_standby_eeprom(hw);
        
#line 4164 
        goto ldv_55351;
      }
      else ;
    }
    ldv_55353: 
#line 4167 
    ;
    
#line 4151 
    if ((int)widx < (int)words) 
#line 4153 
                                goto ldv_55352; else 
#line 4156 
                                                     goto ldv_55351;
    ldv_55351: 
#line 4157 
    ;
  }
  ldv_55355: 
#line 4159 
  ;
  
#line 4120 
  if ((int)widx < (int)words) 
#line 4122 
                              goto ldv_55354; else 
#line 4125 
                                                   goto ldv_55356;
  ldv_55356: 
#line 4126 
  ;
  
#line 4169 
  __retres = 0;
  return_label: 
#line 4169 
                return __retres;
}


#line 4179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_write_eeprom_microwire(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
{
  s32 __retres;
  u32 eecd;
  
#line 4182 
  struct e1000_eeprom_info *eeprom = & hw->eeprom;
  
#line 4184 
  u16 words_written = (unsigned short)0U;
  
#line 4185 
  u16 i = (unsigned short)0U;
  
#line 4193 
  e1000_shift_out_ee_bits(hw,(unsigned short)19,(unsigned short)((int)((unsigned int)eeprom->opcode_bits + 2U)));
  
#line 4196 
  e1000_shift_out_ee_bits(hw,(unsigned short)0,(unsigned short)((int)((unsigned int)eeprom->address_bits + 65534U)));
  
#line 4199 
  e1000_standby_eeprom(hw);
  
#line 4201 
  goto ldv_55373;
  ldv_55372: 
#line 4202 
  ;
  
#line 4203 
  e1000_shift_out_ee_bits(hw,(unsigned short)5,(unsigned short)((int)eeprom->opcode_bits));
  
#line 4206 
  e1000_shift_out_ee_bits(hw,(unsigned short)((int)offset + (int)words_written),(unsigned short)((int)eeprom->address_bits));
  
#line 4210 
  e1000_shift_out_ee_bits(hw,(unsigned short)((int)*(data + (int)words_written)),(unsigned short)16);
  
#line 4215 
  e1000_standby_eeprom(hw);
  
#line 4222 
  i = (unsigned short)0U;
  
#line 4222 
  goto ldv_55369;
  ldv_55368: 
#line 4223 
  ;
  
#line 4223 
  eecd = readl((void const volatile *)(hw->hw_addr + 16U));
  
#line 4224 
  if ((eecd & 8U) != 0U) 
#line 4225 
                         goto ldv_55367; else ;
  
#line 4226 
  __const_udelay(214750UL);
  
#line 4222 
  i = (u16)((int)i + 1);
  ldv_55369: 
#line 4223 
  ;
  
#line 4222 
  if ((unsigned int)i <= 199U) 
#line 4224 
                               goto ldv_55368; else 
#line 4227 
                                                    goto ldv_55367;
  ldv_55367: 
#line 4228 
  ;
  
#line 4228 
  if ((unsigned int)i == 200U) {
    {
      
#line 4229 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_write_eeprom_microwire", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Write did not complete\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4229U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 4229 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 4229 
        tmp = e1000_get_hw_dev(hw);
        
#line 4229 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"EEPROM Write did not complete\n");
      }
      else ;
    }
    
#line 4230 
    __retres = -1;
    
#line 4230 
    goto return_label;
  }
  else ;
  
#line 4234 
  e1000_standby_eeprom(hw);
  
#line 4236 
  words_written = (u16)((int)words_written + 1);
  ldv_55373: 
#line 4237 
  ;
  
#line 4201 
  if ((int)words_written < (int)words) 
#line 4203 
                                       goto ldv_55372; else 
#line 4206 
                                                            goto ldv_55374;
  ldv_55374: 
#line 4207 
  ;
  
#line 4245 
  e1000_shift_out_ee_bits(hw,(unsigned short)16,(unsigned short)((int)((unsigned int)eeprom->opcode_bits + 2U)));
  
#line 4248 
  e1000_shift_out_ee_bits(hw,(unsigned short)0,(unsigned short)((int)((unsigned int)eeprom->address_bits + 65534U)));
  
#line 4250 
  __retres = 0;
  return_label: 
#line 4250 
                return __retres;
}


#line 4260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_read_mac_addr(struct e1000_hw *hw)
{
  s32 __retres;
  u16 offset;
  u16 eeprom_data;
  u16 i;
  s32 tmp_0;
  
#line 4265 
  i = (unsigned short)0U;
  
#line 4265 
  goto ldv_55384;
  ldv_55383: 
#line 4266 
  ;
  
#line 4266 
  offset = (unsigned short)((int)i >> 1);
  
#line 4267 
  tmp_0 = e1000_read_eeprom(hw,(unsigned short)((int)offset),(unsigned short)1,& eeprom_data);
  
#line 4267 
  if (tmp_0 < 0) {
    {
      
#line 4268 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_read_mac_addr", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Read Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4268U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 4268 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 4268 
        tmp = e1000_get_hw_dev(hw);
        
#line 4268 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"EEPROM Read Error\n");
      }
      else ;
    }
    
#line 4269 
    __retres = -1;
    
#line 4269 
    goto return_label;
  }
  else ;
  
#line 4271 
  hw->perm_mac_addr[(int)i] = (unsigned char)eeprom_data;
  
#line 4272 
  hw->perm_mac_addr[(int)i + 1] = (unsigned char)((int)eeprom_data >> 8);
  
#line 4265 
  i = (unsigned short)((unsigned int)i + 2U);
  ldv_55384: 
#line 4266 
  ;
  
#line 4265 
  if ((unsigned int)i <= 5U) 
#line 4267 
                             goto ldv_55383; else 
#line 4270 
                                                  goto ldv_55385;
  ldv_55385: 
#line 4271 
  ;
  
#line 4275 
  switch ((unsigned int)hw->mac_type) {
    unsigned int tmp_1;
    default: 
#line 4276 
    ;
    
#line 4277 
    goto ldv_55387;
    case (unsigned int)8: 
#line 4278 
    ;
    case (unsigned int)10: 
#line 4279 
    ;
    
#line 4280 
    tmp_1 = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 4280 
    if ((tmp_1 & 4U) != 0U) 
#line 4281 
                            hw->perm_mac_addr[5] = (unsigned char)((unsigned int)hw->perm_mac_addr[5] ^ 1U); else ;
    
#line 4282 
    goto ldv_55387;
  }
  ldv_55387: 
#line 4285 
  ;
  
#line 4285 
  i = (unsigned short)0U;
  
#line 4285 
  goto ldv_55391;
  ldv_55390: 
#line 4286 
  ;
  
#line 4286 
  hw->mac_addr[(int)i] = hw->perm_mac_addr[(int)i];
  
#line 4285 
  i = (u16)((int)i + 1);
  ldv_55391: 
#line 4286 
  ;
  
#line 4285 
  if ((unsigned int)i <= 5U) 
#line 4287 
                             goto ldv_55390; else 
#line 4290 
                                                  goto ldv_55392;
  ldv_55392: 
#line 4291 
  ;
  
#line 4287 
  __retres = 0;
  return_label: 
#line 4287 
                return __retres;
}


#line 4298  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_init_rx_addrs(struct e1000_hw *hw)
{
  u32 i;
  u32 rar_num;
  int tmp_1;
  int tmp_2;
  {
    
#line 4304 
    struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_init_rx_addrs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Programming MAC Address into RAR[0]\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4304U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 4304 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      struct net_device *tmp;
      
#line 4304 
      tmp = e1000_get_hw_dev(hw);
      
#line 4304 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Programming MAC Address into RAR[0]\n");
    }
    else ;
  }
  
#line 4306 
  e1000_rar_set(hw,(u8 *)(& hw->mac_addr),0U);
  
#line 4308 
  rar_num = 15U;
  {
    
#line 4311 
    struct _ddebug descriptor_0 = {.modname = "e1000", .function = "e1000_init_rx_addrs", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Clearing RAR[1-15]\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4311U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 4311 
    if ((long)(((int)descriptor_0.flags & 1) != 0) != 0L) {
      struct net_device *tmp_0;
      
#line 4311 
      tmp_0 = e1000_get_hw_dev(hw);
      
#line 4311 
      __dynamic_netdev_dbg(& descriptor_0,(struct net_device const *)tmp_0,"Clearing RAR[1-15]\n");
    }
    else ;
  }
  
#line 4312 
  i = 1U;
  
#line 4312 
  goto ldv_55402;
  ldv_55401: 
#line 4313 
  ;
  
#line 4313 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4313 
                                                       tmp_1 = 21504; else 
                                                                    
#line 4313 
                                                                    tmp_1 = 64;
  
#line 4313 
  ;
  
#line 4313 
  writel(0U,(void volatile *)(hw->hw_addr + ((u32)tmp_1 + (i << 3))));
  
#line 4314 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 4315 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4315 
                                                       tmp_2 = 21504; else 
                                                                    
#line 4315 
                                                                    tmp_2 = 64;
  
#line 4315 
  ;
  
#line 4315 
  writel(0U,(void volatile *)(hw->hw_addr + ((u32)tmp_2 + (((i << 1) + 1U) << 2))));
  
#line 4316 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 4312 
  i += 1U;
  ldv_55402: 
#line 4313 
  ;
  
#line 4312 
  if (i < rar_num) 
#line 4314 
                   goto ldv_55401; else 
#line 4317 
                                        goto ldv_55403;
  ldv_55403: 
#line 4318 
  ;
  
#line 4319 
  return;
}


#line 4325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
u32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)
{
  
#line 4327 
  u32 hash_value = 0U;
  
#line 4332 
  switch (hw->mc_filter_type) {
    case (u32)0: 
#line 4337 
    ;
    
#line 4339 
    hash_value = (unsigned int)(((int)*(mc_addr + 4U) >> 4) | ((int)*(mc_addr + 5U) << 4));
    
#line 4340 
    goto ldv_55410;
    case (u32)1: 
#line 4341 
    ;
    
#line 4343 
    hash_value = (unsigned int)(((int)*(mc_addr + 4U) >> 3) | ((int)*(mc_addr + 5U) << 5));
    
#line 4344 
    goto ldv_55410;
    case (u32)2: 
#line 4345 
    ;
    
#line 4347 
    hash_value = (unsigned int)(((int)*(mc_addr + 4U) >> 2) | ((int)*(mc_addr + 5U) << 6));
    
#line 4348 
    goto ldv_55410;
    case (u32)3: 
#line 4349 
    ;
    
#line 4351 
    hash_value = (unsigned int)((int)*(mc_addr + 4U) | ((int)*(mc_addr + 5U) << 8));
    
#line 4352 
    goto ldv_55410;
  }
  ldv_55410: 
#line 4355 
  ;
  
#line 4355 
  hash_value &= 4095U;
  
#line 4356 
  return hash_value;
}


#line 4365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
void e1000_rar_set(struct e1000_hw *hw, u8 *addr, u32 index)
{
  u32 rar_low;
  u32 rar_high;
  int tmp;
  int tmp_0;
  
#line 4372 
  rar_low = (((unsigned int)*addr | ((unsigned int)*(addr + 1U) << 8)) | ((unsigned int)*(addr + 2U) << 16)) | ((unsigned int)*(addr + 3U) << 24);
  
#line 4374 
  rar_high = (unsigned int)*(addr + 4U) | ((unsigned int)*(addr + 5U) << 8);
  
#line 4394 
  switch ((unsigned int)hw->mac_type) {
    default: 
#line 4395 
    ;
    
#line 4397 
    rar_high |= 2147483648U;
    
#line 4398 
    goto ldv_55422;
  }
  ldv_55422: 
#line 4401 
  ;
  
#line 4401 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4401 
                                                       tmp = 21504; else 
                                                                    
#line 4401 
                                                                    tmp = 64;
  
#line 4401 
  ;
  
#line 4401 
  ;
  
#line 4401 
  writel(rar_low,(void volatile *)(hw->hw_addr + ((u32)tmp + (index << 3))));
  
#line 4402 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 4403 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4403 
                                                       tmp_0 = 21504; else 
                                                                    
#line 4403 
                                                                    tmp_0 = 64;
  
#line 4403 
  ;
  
#line 4403 
  ;
  
#line 4403 
  writel(rar_high,(void volatile *)(hw->hw_addr + ((u32)tmp_0 + (((index << 1) + 1U) << 2))));
  
#line 4404 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 4405 
  return;
}


#line 4413  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
void e1000_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)
{
  u32 temp;
  
#line 4417 
  if (hw->mac_type == (unsigned int)e1000_82544 && (offset & 1U) != 0U) {
    int tmp;
    int tmp_0;
    int tmp_1;
    
#line 4418 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4418 
                                                         tmp = 22016; else 
                                                                    
#line 4418 
                                                                    tmp = 1536;
    
#line 4418 
    ;
    
#line 4418 
    temp = readl((void const volatile *)(hw->hw_addr + ((u32)tmp + ((offset + 4294967295U) << 2))));
    
#line 4419 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4419 
                                                         tmp_0 = 22016; else 
                                                                    
#line 4419 
                                                                    tmp_0 = 1536;
    
#line 4419 
    ;
    
#line 4419 
    ;
    
#line 4419 
    writel(value,(void volatile *)(hw->hw_addr + ((u32)tmp_0 + (offset << 2))));
    
#line 4420 
    readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 4421 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4421 
                                                         tmp_1 = 22016; else 
                                                                    
#line 4421 
                                                                    tmp_1 = 1536;
    
#line 4421 
    ;
    
#line 4421 
    ;
    
#line 4421 
    writel(temp,(void volatile *)(hw->hw_addr + ((u32)tmp_1 + ((offset + 4294967295U) << 2))));
    
#line 4422 
    readl((void const volatile *)(hw->hw_addr + 8U));
  }
  else {
    int tmp_2;
    
#line 4424 
    if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4424 
                                                         tmp_2 = 22016; else 
                                                                    
#line 4424 
                                                                    tmp_2 = 1536;
    
#line 4424 
    ;
    
#line 4424 
    ;
    
#line 4424 
    writel(value,(void volatile *)(hw->hw_addr + ((u32)tmp_2 + (offset << 2))));
    
#line 4425 
    readl((void const volatile *)(hw->hw_addr + 8U));
  }
  
#line 4427 
  return;
}


#line 4433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_clear_vfta(struct e1000_hw *hw)
{
  u32 offset;
  int tmp;
  
#line 4436 
  u32 vfta_value = 0U;
  
#line 4437 
  u32 vfta_offset = 0U;
  
#line 4438 
  u32 vfta_bit_in_reg = 0U;
  
#line 4440 
  offset = 0U;
  
#line 4440 
  goto ldv_55437;
  ldv_55436: 
#line 4441 
  ;
  
#line 4445 
  if (offset == vfta_offset) 
#line 4445 
                             vfta_value = vfta_bit_in_reg; else 
#line 4445 
                                                                vfta_value = 0U;
  
#line 4446 
  if (hw->mac_type > (unsigned int)e1000_82542_rev2_1) 
#line 4446 
                                                       tmp = 22016; else 
                                                                    
#line 4446 
                                                                    tmp = 1536;
  
#line 4446 
  ;
  
#line 4446 
  ;
  
#line 4446 
  writel(vfta_value,(void volatile *)(hw->hw_addr + ((u32)tmp + (offset << 2))));
  
#line 4447 
  readl((void const volatile *)(hw->hw_addr + 8U));
  
#line 4440 
  offset += 1U;
  ldv_55437: 
#line 4441 
  ;
  
#line 4440 
  if (offset <= 127U) 
#line 4442 
                      goto ldv_55436; else 
#line 4445 
                                           goto ldv_55438;
  ldv_55438: 
#line 4446 
  ;
  
#line 4447 
  return;
}


#line 4451  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_id_led_init(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ledctl;
  u16 eeprom_data;
  u16 i;
  u16 temp;
  s32 tmp_0;
  
#line 4454 
  u32 const ledctl_mask = 255U;
  
#line 4455 
  u32 const ledctl_on = 14U;
  
#line 4456 
  u32 const ledctl_off = 15U;
  
#line 4458 
  u16 const led_mask = (unsigned short)15U;
  
#line 4460 
  if (hw->mac_type <= (unsigned int)e1000_82544) {
    
#line 4462 
    __retres = 0;
    
#line 4462 
    goto return_label;
  }
  else ;
  
#line 4465 
  ledctl = readl((void const volatile *)(hw->hw_addr + 3584U));
  
#line 4466 
  hw->ledctl_default = ledctl;
  
#line 4467 
  hw->ledctl_mode1 = hw->ledctl_default;
  
#line 4468 
  hw->ledctl_mode2 = hw->ledctl_default;
  
#line 4470 
  tmp_0 = e1000_read_eeprom(hw,(unsigned short)4,(unsigned short)1,& eeprom_data);
  
#line 4470 
  if (tmp_0 < 0) {
    {
      
#line 4471 
      struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_id_led_init", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "EEPROM Read Error\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4471U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
      
#line 4471 
      if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
        struct net_device *tmp;
        
#line 4471 
        tmp = e1000_get_hw_dev(hw);
        
#line 4471 
        __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"EEPROM Read Error\n");
      }
      else ;
    }
    
#line 4472 
    __retres = -1;
    
#line 4472 
    goto return_label;
  }
  else ;
  
#line 4475 
  if ((unsigned int)eeprom_data + 65535U > 65533U) 
#line 4477 
                                                   eeprom_data = (unsigned short)35089U; else ;
  
#line 4480 
  i = (unsigned short)0U;
  
#line 4480 
  goto ldv_55469;
  ldv_55468: 
#line 4481 
  ;
  
#line 4481 
  temp = (unsigned short)((unsigned int)((unsigned short)((int)eeprom_data >> ((int)i << 2))) & 15U);
  
#line 4482 
  switch ((int)temp) {
    case 4: 
#line 4483 
    ;
    case 5: 
#line 4484 
    ;
    case 6: 
#line 4485 
    ;
    
#line 4486 
    hw->ledctl_mode1 &= ~ (255U << ((int)i << 3));
    
#line 4487 
    hw->ledctl_mode1 |= 14U << ((int)i << 3);
    
#line 4488 
    goto ldv_55455;
    case 7: 
#line 4489 
    ;
    case 8: 
#line 4490 
    ;
    case 9: 
#line 4491 
    ;
    
#line 4492 
    hw->ledctl_mode1 &= ~ (255U << ((int)i << 3));
    
#line 4493 
    hw->ledctl_mode1 |= 15U << ((int)i << 3);
    
#line 4494 
    goto ldv_55455;
    default: 
#line 4495 
    ;
    
#line 4497 
    goto ldv_55455;
  }
  ldv_55455: 
#line 4499 
  ;
  
#line 4499 
  switch ((int)temp) {
    case 2: 
#line 4500 
    ;
    case 5: 
#line 4501 
    ;
    case 8: 
#line 4502 
    ;
    
#line 4503 
    hw->ledctl_mode2 &= ~ (255U << ((int)i << 3));
    
#line 4504 
    hw->ledctl_mode2 |= 14U << ((int)i << 3);
    
#line 4505 
    goto ldv_55463;
    case 3: 
#line 4506 
    ;
    case 6: 
#line 4507 
    ;
    case 9: 
#line 4508 
    ;
    
#line 4509 
    hw->ledctl_mode2 &= ~ (255U << ((int)i << 3));
    
#line 4510 
    hw->ledctl_mode2 |= 15U << ((int)i << 3);
    
#line 4511 
    goto ldv_55463;
    default: 
#line 4512 
    ;
    
#line 4514 
    goto ldv_55463;
  }
  ldv_55463: 
#line 4516 
  ;
  
#line 4480 
  i = (u16)((int)i + 1);
  ldv_55469: 
#line 4481 
  ;
  
#line 4480 
  if ((unsigned int)i <= 3U) 
#line 4482 
                             goto ldv_55468; else 
#line 4485 
                                                  goto ldv_55470;
  ldv_55470: 
#line 4486 
  ;
  
#line 4517 
  __retres = 0;
  return_label: 
#line 4517 
                return __retres;
}


#line 4526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_setup_led(struct e1000_hw *hw)
{
  s32 __retres;
  u32 ledctl;
  
#line 4529 
  s32 ret_val = 0;
  
#line 4531 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)1: 
#line 4532 
    ;
    case (unsigned int)2: 
#line 4533 
    ;
    case (unsigned int)3: 
#line 4534 
    ;
    case (unsigned int)4: 
#line 4535 
    ;
    
#line 4537 
    goto ldv_55480;
    case (unsigned int)11: 
#line 4538 
    ;
    case (unsigned int)13: 
#line 4539 
    ;
    case (unsigned int)12: 
#line 4540 
    ;
    case (unsigned int)14: 
#line 4541 
    ;
    
#line 4543 
    ret_val = e1000_read_phy_reg(hw,20U,& hw->phy_spd_default);
    
#line 4545 
    if (ret_val != 0) {
      
#line 4546 
      __retres = ret_val;
      
#line 4546 
      goto return_label;
    }
    else ;
    
#line 4547 
    ret_val = e1000_write_phy_reg(hw,20U,(unsigned short)((int)hw->phy_spd_default & 65503));
    
#line 4550 
    if (ret_val != 0) {
      
#line 4551 
      __retres = ret_val;
      
#line 4551 
      goto return_label;
    }
    else ;
    default: 
#line 4553 
    ;
    
#line 4554 
    if (hw->media_type == (unsigned int)e1000_media_type_fiber) {
      
#line 4555 
      ledctl = readl((void const volatile *)(hw->hw_addr + 3584U));
      
#line 4557 
      hw->ledctl_default = ledctl;
      
#line 4559 
      ledctl &= 4294967088U;
      
#line 4562 
      ledctl |= 15U;
      
#line 4564 
      writel(ledctl,(void volatile *)(hw->hw_addr + 3584U));
    }
    else 
      
#line 4565 
      if (hw->media_type == (unsigned int)e1000_media_type_copper) 
#line 4566 
                                                                   writel(hw->ledctl_mode1,(void volatile *)(hw->hw_addr + 3584U)); else ;
    
#line 4567 
    goto ldv_55480;
  }
  ldv_55480: 
#line 4570 
  ;
  
#line 4570 
  __retres = 0;
  return_label: 
#line 4570 
                return __retres;
}


#line 4577  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_cleanup_led(struct e1000_hw *hw)
{
  s32 __retres;
  
#line 4579 
  s32 ret_val = 0;
  
#line 4581 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)1: 
#line 4582 
    ;
    case (unsigned int)2: 
#line 4583 
    ;
    case (unsigned int)3: 
#line 4584 
    ;
    case (unsigned int)4: 
#line 4585 
    ;
    
#line 4587 
    goto ldv_55494;
    case (unsigned int)11: 
#line 4588 
    ;
    case (unsigned int)13: 
#line 4589 
    ;
    case (unsigned int)12: 
#line 4590 
    ;
    case (unsigned int)14: 
#line 4591 
    ;
    
#line 4593 
    ret_val = e1000_write_phy_reg(hw,20U,(unsigned short)((int)hw->phy_spd_default));
    
#line 4595 
    if (ret_val != 0) {
      
#line 4596 
      __retres = ret_val;
      
#line 4596 
      goto return_label;
    }
    else ;
    default: 
#line 4598 
    ;
    
#line 4600 
    writel(hw->ledctl_default,(void volatile *)(hw->hw_addr + 3584U));
    
#line 4601 
    goto ldv_55494;
  }
  ldv_55494: 
#line 4604 
  ;
  
#line 4604 
  __retres = 0;
  return_label: 
#line 4604 
                return __retres;
}


#line 4611  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_led_on(struct e1000_hw *hw)
{
  s32 __retres;
  
#line 4613 
  u32 ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 4615 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)1: 
#line 4616 
    ;
    case (unsigned int)2: 
#line 4617 
    ;
    case (unsigned int)3: 
#line 4618 
    ;
    
#line 4620 
    ctrl |= 262144U;
    
#line 4621 
    ctrl |= 4194304U;
    
#line 4622 
    goto ldv_55507;
    case (unsigned int)4: 
#line 4623 
    ;
    
#line 4624 
    if (hw->media_type == (unsigned int)e1000_media_type_fiber) {
      
#line 4626 
      ctrl |= 262144U;
      
#line 4627 
      ctrl |= 4194304U;
    }
    else {
      
#line 4630 
      ctrl &= 4294705151U;
      
#line 4631 
      ctrl |= 4194304U;
    }
    
#line 4633 
    goto ldv_55507;
    default: 
#line 4634 
    ;
    
#line 4635 
    if (hw->media_type == (unsigned int)e1000_media_type_fiber) {
      
#line 4637 
      ctrl &= 4294705151U;
      
#line 4638 
      ctrl |= 4194304U;
    }
    else 
      
#line 4639 
      if (hw->media_type == (unsigned int)e1000_media_type_copper) {
        
#line 4640 
        writel(hw->ledctl_mode2,(void volatile *)(hw->hw_addr + 3584U));
        
#line 4641 
        __retres = 0;
        
#line 4641 
        goto return_label;
      }
      else ;
    
#line 4643 
    goto ldv_55507;
  }
  ldv_55507: 
#line 4646 
  ;
  
#line 4646 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 4648 
  __retres = 0;
  return_label: 
#line 4648 
                return __retres;
}


#line 4655  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
s32 e1000_led_off(struct e1000_hw *hw)
{
  s32 __retres;
  
#line 4657 
  u32 ctrl = readl((void const volatile *)hw->hw_addr);
  
#line 4659 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)1: 
#line 4660 
    ;
    case (unsigned int)2: 
#line 4661 
    ;
    case (unsigned int)3: 
#line 4662 
    ;
    
#line 4664 
    ctrl &= 4294705151U;
    
#line 4665 
    ctrl |= 4194304U;
    
#line 4666 
    goto ldv_55517;
    case (unsigned int)4: 
#line 4667 
    ;
    
#line 4668 
    if (hw->media_type == (unsigned int)e1000_media_type_fiber) {
      
#line 4670 
      ctrl &= 4294705151U;
      
#line 4671 
      ctrl |= 4194304U;
    }
    else {
      
#line 4674 
      ctrl |= 262144U;
      
#line 4675 
      ctrl |= 4194304U;
    }
    
#line 4677 
    goto ldv_55517;
    default: 
#line 4678 
    ;
    
#line 4679 
    if (hw->media_type == (unsigned int)e1000_media_type_fiber) {
      
#line 4681 
      ctrl |= 262144U;
      
#line 4682 
      ctrl |= 4194304U;
    }
    else 
      
#line 4683 
      if (hw->media_type == (unsigned int)e1000_media_type_copper) {
        
#line 4684 
        writel(hw->ledctl_mode1,(void volatile *)(hw->hw_addr + 3584U));
        
#line 4685 
        __retres = 0;
        
#line 4685 
        goto return_label;
      }
      else ;
    
#line 4687 
    goto ldv_55517;
  }
  ldv_55517: 
#line 4690 
  ;
  
#line 4690 
  writel(ctrl,(void volatile *)hw->hw_addr);
  
#line 4692 
  __retres = 0;
  return_label: 
#line 4692 
                return __retres;
}


#line 4699  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_clear_hw_cntrs(struct e1000_hw *hw)
{
  u32 volatile temp;
  
#line 4703 
  temp = readl((void const volatile *)(hw->hw_addr + 16384U));
  
#line 4704 
  temp = readl((void const volatile *)(hw->hw_addr + 16392U));
  
#line 4705 
  temp = readl((void const volatile *)(hw->hw_addr + 16400U));
  
#line 4706 
  temp = readl((void const volatile *)(hw->hw_addr + 16404U));
  
#line 4707 
  temp = readl((void const volatile *)(hw->hw_addr + 16408U));
  
#line 4708 
  temp = readl((void const volatile *)(hw->hw_addr + 16412U));
  
#line 4709 
  temp = readl((void const volatile *)(hw->hw_addr + 16416U));
  
#line 4710 
  temp = readl((void const volatile *)(hw->hw_addr + 16424U));
  
#line 4711 
  temp = readl((void const volatile *)(hw->hw_addr + 16432U));
  
#line 4712 
  temp = readl((void const volatile *)(hw->hw_addr + 16440U));
  
#line 4713 
  temp = readl((void const volatile *)(hw->hw_addr + 16448U));
  
#line 4714 
  temp = readl((void const volatile *)(hw->hw_addr + 16456U));
  
#line 4715 
  temp = readl((void const volatile *)(hw->hw_addr + 16460U));
  
#line 4716 
  temp = readl((void const volatile *)(hw->hw_addr + 16464U));
  
#line 4717 
  temp = readl((void const volatile *)(hw->hw_addr + 16468U));
  
#line 4718 
  temp = readl((void const volatile *)(hw->hw_addr + 16472U));
  
#line 4720 
  temp = readl((void const volatile *)(hw->hw_addr + 16476U));
  
#line 4721 
  temp = readl((void const volatile *)(hw->hw_addr + 16480U));
  
#line 4722 
  temp = readl((void const volatile *)(hw->hw_addr + 16484U));
  
#line 4723 
  temp = readl((void const volatile *)(hw->hw_addr + 16488U));
  
#line 4724 
  temp = readl((void const volatile *)(hw->hw_addr + 16492U));
  
#line 4725 
  temp = readl((void const volatile *)(hw->hw_addr + 16496U));
  
#line 4727 
  temp = readl((void const volatile *)(hw->hw_addr + 16500U));
  
#line 4728 
  temp = readl((void const volatile *)(hw->hw_addr + 16504U));
  
#line 4729 
  temp = readl((void const volatile *)(hw->hw_addr + 16508U));
  
#line 4730 
  temp = readl((void const volatile *)(hw->hw_addr + 16512U));
  
#line 4731 
  temp = readl((void const volatile *)(hw->hw_addr + 16520U));
  
#line 4732 
  temp = readl((void const volatile *)(hw->hw_addr + 16524U));
  
#line 4733 
  temp = readl((void const volatile *)(hw->hw_addr + 16528U));
  
#line 4734 
  temp = readl((void const volatile *)(hw->hw_addr + 16532U));
  
#line 4735 
  temp = readl((void const volatile *)(hw->hw_addr + 16544U));
  
#line 4736 
  temp = readl((void const volatile *)(hw->hw_addr + 16548U));
  
#line 4737 
  temp = readl((void const volatile *)(hw->hw_addr + 16552U));
  
#line 4738 
  temp = readl((void const volatile *)(hw->hw_addr + 16556U));
  
#line 4739 
  temp = readl((void const volatile *)(hw->hw_addr + 16560U));
  
#line 4740 
  temp = readl((void const volatile *)(hw->hw_addr + 16576U));
  
#line 4741 
  temp = readl((void const volatile *)(hw->hw_addr + 16580U));
  
#line 4742 
  temp = readl((void const volatile *)(hw->hw_addr + 16584U));
  
#line 4743 
  temp = readl((void const volatile *)(hw->hw_addr + 16588U));
  
#line 4744 
  temp = readl((void const volatile *)(hw->hw_addr + 16592U));
  
#line 4745 
  temp = readl((void const volatile *)(hw->hw_addr + 16596U));
  
#line 4747 
  temp = readl((void const volatile *)(hw->hw_addr + 16600U));
  
#line 4748 
  temp = readl((void const volatile *)(hw->hw_addr + 16604U));
  
#line 4749 
  temp = readl((void const volatile *)(hw->hw_addr + 16608U));
  
#line 4750 
  temp = readl((void const volatile *)(hw->hw_addr + 16612U));
  
#line 4751 
  temp = readl((void const volatile *)(hw->hw_addr + 16616U));
  
#line 4752 
  temp = readl((void const volatile *)(hw->hw_addr + 16620U));
  
#line 4754 
  temp = readl((void const volatile *)(hw->hw_addr + 16624U));
  
#line 4755 
  temp = readl((void const volatile *)(hw->hw_addr + 16628U));
  
#line 4757 
  if (hw->mac_type <= (unsigned int)e1000_82542_rev2_1) 
#line 4758 
                                                        goto return_label; else ;
  
#line 4760 
  temp = readl((void const volatile *)(hw->hw_addr + 16388U));
  
#line 4761 
  temp = readl((void const volatile *)(hw->hw_addr + 16396U));
  
#line 4762 
  temp = readl((void const volatile *)(hw->hw_addr + 16436U));
  
#line 4763 
  temp = readl((void const volatile *)(hw->hw_addr + 16444U));
  
#line 4764 
  temp = readl((void const volatile *)(hw->hw_addr + 16632U));
  
#line 4765 
  temp = readl((void const volatile *)(hw->hw_addr + 16636U));
  
#line 4767 
  if (hw->mac_type <= (unsigned int)e1000_82544) 
#line 4768 
                                                 goto return_label; else ;
  
#line 4770 
  temp = readl((void const volatile *)(hw->hw_addr + 16564U));
  
#line 4771 
  temp = readl((void const volatile *)(hw->hw_addr + 16568U));
  
#line 4772 
  temp = readl((void const volatile *)(hw->hw_addr + 16572U));
  return_label: 
#line 4773 
                return;
}


#line 4784  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
void e1000_reset_adaptive(struct e1000_hw *hw)
{
  
#line 4786 
  if ((int)hw->adaptive_ifs != 0) {
    
#line 4787 
    if (! hw->ifs_params_forced) {
      
#line 4788 
      hw->current_ifs_val = (unsigned short)0U;
      
#line 4789 
      hw->ifs_min_val = (unsigned short)40U;
      
#line 4790 
      hw->ifs_max_val = (unsigned short)80U;
      
#line 4791 
      hw->ifs_step_size = (unsigned short)10U;
      
#line 4792 
      hw->ifs_ratio = (unsigned short)4U;
    }
    else ;
    
#line 4794 
    hw->in_ifs_mode = (_Bool)0;
    
#line 4795 
    writel(0U,(void volatile *)(hw->hw_addr + 1112U));
  }
  else {
    
#line 4797 
    struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_reset_adaptive", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Not in Adaptive IFS mode!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4797U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 4797 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      struct net_device *tmp;
      
#line 4797 
      tmp = e1000_get_hw_dev(hw);
      
#line 4797 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Not in Adaptive IFS mode!\n");
    }
    else ;
  }
  
#line 4799 
  return;
}


#line 4810  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
void e1000_update_adaptive(struct e1000_hw *hw)
{
  
#line 4812 
  if ((int)hw->adaptive_ifs != 0) {
    
#line 4813 
    if (hw->collision_delta * (unsigned int)hw->ifs_ratio > hw->tx_packet_delta) {
      
#line 4814 
      if (hw->tx_packet_delta > 1000U) {
        
#line 4815 
        hw->in_ifs_mode = (_Bool)1;
        
#line 4816 
        if ((int)hw->current_ifs_val < (int)hw->ifs_max_val) {
          
#line 4817 
          if ((unsigned int)hw->current_ifs_val == 0U) 
#line 4818 
                                                       hw->current_ifs_val = hw->ifs_min_val; else 
                                                                    
#line 4821 
                                                                    hw->current_ifs_val = (unsigned short)((int)hw->current_ifs_val + (int)hw->ifs_step_size);
          
#line 4823 
          writel((unsigned int)hw->current_ifs_val,(void volatile *)(hw->hw_addr + 1112U));
        }
        else ;
      }
      else ;
    }
    else 
      
#line 4827 
      if ((int)hw->in_ifs_mode != 0 && hw->tx_packet_delta <= 1000U) {
        
#line 4829 
        hw->current_ifs_val = (unsigned short)0U;
        
#line 4830 
        hw->in_ifs_mode = (_Bool)0;
        
#line 4831 
        writel(0U,(void volatile *)(hw->hw_addr + 1112U));
      }
      else ;
  }
  else {
    
#line 4835 
    struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_update_adaptive", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Not in Adaptive IFS mode!\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))4835U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
    
#line 4835 
    if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
      struct net_device *tmp;
      
#line 4835 
      tmp = e1000_get_hw_dev(hw);
      
#line 4835 
      __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Not in Adaptive IFS mode!\n");
    }
    else ;
  }
  
#line 4837 
  return;
}


#line 4845  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
void e1000_get_bus_info(struct e1000_hw *hw)
{
  u32 status;
  
#line 4849 
  switch ((unsigned int)hw->mac_type) {
    int tmp;
    int tmp_2;
    case (unsigned int)1: 
#line 4850 
    ;
    case (unsigned int)2: 
#line 4851 
    ;
    
#line 4852 
    hw->bus_type = 1;
    
#line 4853 
    hw->bus_speed = 0;
    
#line 4854 
    hw->bus_width = 0;
    
#line 4855 
    goto ldv_55540;
    default: 
#line 4856 
    ;
    
#line 4857 
    status = readl((void const volatile *)(hw->hw_addr + 8U));
    
#line 4859 
    if ((status & 8192U) != 0U) 
#line 4859 
                                tmp = 2; else 
#line 4859 
                                              tmp = 1;
    
#line 4858 
    hw->bus_type = tmp;
    
#line 4861 
    if ((unsigned int)hw->device_id == 4125U) {
      int tmp_0;
      
#line 4863 
      if (hw->bus_type == (unsigned int)1) 
#line 4863 
                                           tmp_0 = 2; else 
#line 4863 
                                                           tmp_0 = 4;
      
#line 4862 
      hw->bus_speed = tmp_0;
    }
    else 
      
#line 4864 
      if (hw->bus_type == (unsigned int)1) {
        int tmp_1;
        
#line 4866 
        if ((status & 2048U) != 0U) 
#line 4866 
                                    tmp_1 = 2; else 
#line 4866 
                                                    tmp_1 = 1;
        
#line 4865 
        hw->bus_speed = tmp_1;
      }
      else {
        
#line 4868 
        switch (status & 49152U) {
          case (unsigned int)0: 
#line 4869 
          ;
          
#line 4870 
          hw->bus_speed = 2;
          
#line 4871 
          goto ldv_55543;
          case (unsigned int)16384: 
#line 4872 
          ;
          
#line 4873 
          hw->bus_speed = 3;
          
#line 4874 
          goto ldv_55543;
          case (unsigned int)32768: 
#line 4875 
          ;
          
#line 4876 
          hw->bus_speed = 5;
          
#line 4877 
          goto ldv_55543;
          default: 
#line 4878 
          ;
          
#line 4879 
          hw->bus_speed = 6;
          
#line 4880 
          goto ldv_55543;
        }
        ldv_55543: 
#line 4882 
        ;
      }
    
#line 4884 
    if ((status & 4096U) != 0U) 
#line 4884 
                                tmp_2 = 2; else 
#line 4884 
                                                tmp_2 = 1;
    
#line 4883 
    hw->bus_width = tmp_2;
    
#line 4885 
    goto ldv_55540;
  }
  ldv_55540: 
#line 4887 
  ;
  
#line 4888 
  return;
}


#line 4898  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static void e1000_write_reg_io(struct e1000_hw *hw, u32 offset, u32 value)
{
  
#line 4900 
  unsigned long io_addr = hw->io_base;
  
#line 4901 
  unsigned long io_data = hw->io_base + 4UL;
  
#line 4903 
  e1000_io_write(hw,io_addr,offset);
  
#line 4904 
  e1000_io_write(hw,io_data,value);
  
#line 4905 
  return;
}


#line 4921  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length, u16 *max_length)
{
  s32 __retres;
  s32 ret_val;
  u16 i;
  u16 phy_data;
  u16 cable_length;
  u16 tmp;
  
#line 4925 
  u16 agc_value = (unsigned short)0U;
  
#line 4929 
  tmp = (unsigned short)0U;
  
#line 4929 
  *max_length = tmp;
  
#line 4929 
  *min_length = tmp;
  
#line 4932 
  if (hw->phy_type == (unsigned int)0) {
    
#line 4934 
    ret_val = e1000_read_phy_reg(hw,17U,& phy_data);
    
#line 4936 
    if (ret_val != 0) {
      
#line 4937 
      __retres = ret_val;
      
#line 4937 
      goto return_label;
    }
    else ;
    
#line 4938 
    cable_length = (unsigned short)((unsigned int)((unsigned short)((int)phy_data >> 7)) & 7U);
    
#line 4942 
    switch ((int)cable_length) {
      case 0: 
#line 4943 
      ;
      
#line 4944 
      *min_length = (unsigned short)0U;
      
#line 4945 
      *max_length = (unsigned short)50U;
      
#line 4946 
      goto ldv_55565;
      case 1: 
#line 4947 
      ;
      
#line 4948 
      *min_length = (unsigned short)50U;
      
#line 4949 
      *max_length = (unsigned short)80U;
      
#line 4950 
      goto ldv_55565;
      case 2: 
#line 4951 
      ;
      
#line 4952 
      *min_length = (unsigned short)80U;
      
#line 4953 
      *max_length = (unsigned short)110U;
      
#line 4954 
      goto ldv_55565;
      case 3: 
#line 4955 
      ;
      
#line 4956 
      *min_length = (unsigned short)110U;
      
#line 4957 
      *max_length = (unsigned short)140U;
      
#line 4958 
      goto ldv_55565;
      case 4: 
#line 4959 
      ;
      
#line 4960 
      *min_length = (unsigned short)140U;
      
#line 4961 
      *max_length = (unsigned short)170U;
      
#line 4962 
      goto ldv_55565;
      default: 
#line 4963 
      ;
      
#line 4964 
      __retres = -2;
      
#line 4964 
      goto return_label;
    }
    ldv_55565: 
#line 4966 
    ;
  }
  else 
    
#line 4966 
    if (hw->phy_type == (unsigned int)1) {
      u16 cur_agc_value;
      int tmp_0;
      
#line 4968 
      u16 min_agc_value = (unsigned short)128U;
      
#line 4969 
      u16 const agc_reg_array[4U] = {(unsigned short)4466U, (unsigned short)4722U, (unsigned short)5234U, (unsigned short)6258U};
      
#line 4976 
      i = (unsigned short)0U;
      
#line 4976 
      goto ldv_55575;
      ldv_55574: 
#line 4977 
      ;
      
#line 4978 
      ret_val = e1000_read_phy_reg(hw,(unsigned int)agc_reg_array[(int)i],& phy_data);
      
#line 4980 
      if (ret_val != 0) {
        
#line 4981 
        __retres = ret_val;
        
#line 4981 
        goto return_label;
      }
      else ;
      
#line 4983 
      cur_agc_value = (unsigned short)((int)phy_data >> 7);
      
#line 4986 
      if ((unsigned int)cur_agc_value + 65535U > 125U) {
        
#line 4989 
        __retres = -2;
        
#line 4989 
        goto return_label;
      }
      else ;
      
#line 4991 
      agc_value = (unsigned short)((int)agc_value + (int)cur_agc_value);
      
#line 4994 
      if ((int)min_agc_value > (int)cur_agc_value) 
#line 4995 
                                                   min_agc_value = cur_agc_value; else ;
      
#line 4976 
      i = (u16)((int)i + 1);
      ldv_55575: 
#line 4977 
      ;
      
#line 4976 
      if ((unsigned int)i <= 3U) 
#line 4978 
                                 goto ldv_55574; else 
#line 4981 
                                                      goto ldv_55576;
      ldv_55576: 
#line 4982 
      ;
      
#line 4999 
      if ((unsigned int)agc_value <= 199U) {
        
#line 5001 
        agc_value = (unsigned short)((int)agc_value - (int)min_agc_value);
        
#line 5004 
        agc_value = (unsigned short)((unsigned int)agc_value / 3U);
      }
      else 
#line 5007 
           agc_value = (unsigned short)((unsigned int)agc_value / 4U);
      
#line 5011 
      if (0 > (int)e1000_igp_cable_length_table[(int)agc_value] + -10) 
        
#line 5011 
        tmp_0 = 0; else 
#line 5011 
                        tmp_0 = (int)e1000_igp_cable_length_table[(int)agc_value] + -10;
      
#line 5011 
      *min_length = (unsigned short)tmp_0;
      
#line 5015 
      *max_length = (unsigned short)((unsigned int)e1000_igp_cable_length_table[(int)agc_value] + 10U);
    }
    else ;
  
#line 5019 
  __retres = 0;
  return_label: 
#line 5019 
                return __retres;
}


#line 5037  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_check_polarity(struct e1000_hw *hw, e1000_rev_polarity *polarity)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  
#line 5043 
  if (hw->phy_type == (unsigned int)0) {
    
#line 5045 
    ret_val = e1000_read_phy_reg(hw,17U,& phy_data);
    
#line 5047 
    if (ret_val != 0) {
      
#line 5048 
      __retres = ret_val;
      
#line 5048 
      goto return_label;
    }
    else ;
    
#line 5049 
    *polarity = ((int)phy_data >> 1) & 1;
  }
  else 
    
#line 5053 
    if (hw->phy_type == (unsigned int)1) {
      
#line 5055 
      ret_val = e1000_read_phy_reg(hw,17U,& phy_data);
      
#line 5057 
      if (ret_val != 0) {
        
#line 5058 
        __retres = ret_val;
        
#line 5058 
        goto return_label;
      }
      else ;
      
#line 5063 
      if (((int)phy_data & 49152) == 49152) {
        
#line 5067 
        ret_val = e1000_read_phy_reg(hw,180U,& phy_data);
        
#line 5070 
        if (ret_val != 0) {
          
#line 5071 
          __retres = ret_val;
          
#line 5071 
          goto return_label;
        }
        else ;
        
#line 5074 
        *polarity = ((int)phy_data & 120) != 0;
      }
      else 
#line 5081 
           *polarity = ((int)phy_data >> 1) & 1;
    }
    else ;
  
#line 5087 
  __retres = 0;
  return_label: 
#line 5087 
                return __retres;
}


#line 5104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_check_downshift(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  
#line 5109 
  if (hw->phy_type == (unsigned int)1) {
    
#line 5110 
    ret_val = e1000_read_phy_reg(hw,19U,& phy_data);
    
#line 5112 
    if (ret_val != 0) {
      
#line 5113 
      __retres = ret_val;
      
#line 5113 
      goto return_label;
    }
    else ;
    
#line 5115 
    hw->speed_downgraded = (_Bool)((((int)phy_data >> 15) & 1) != 0);
  }
  else 
    
#line 5117 
    if (hw->phy_type == (unsigned int)0) {
      
#line 5118 
      ret_val = e1000_read_phy_reg(hw,17U,& phy_data);
      
#line 5120 
      if (ret_val != 0) {
        
#line 5121 
        __retres = ret_val;
        
#line 5121 
        goto return_label;
      }
      else ;
      
#line 5123 
      hw->speed_downgraded = (_Bool)((((int)phy_data >> 5) & 1) != 0);
    }
    else ;
  
#line 5127 
  __retres = 0;
  return_label: 
#line 5127 
                return __retres;
}


#line 5130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static u16 const dsp_reg_array[4U] = {(unsigned short)4465U, (unsigned short)4721U, (unsigned short)5233U, (unsigned short)6257U};

#line 5137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_1000Mb_check_cable_length(struct e1000_hw *hw)
{
  s32 __retres;
  u16 min_length;
  u16 max_length;
  u16 phy_data;
  u16 i;
  s32 ret_val;
  
#line 5143 
  ret_val = e1000_get_cable_length(hw,& min_length,& max_length);
  
#line 5144 
  if (ret_val != 0) {
    
#line 5145 
    __retres = ret_val;
    
#line 5145 
    goto return_label;
  }
  else ;
  
#line 5147 
  if (hw->dsp_config_state != (unsigned int)1) {
    
#line 5148 
    __retres = 0;
    
#line 5148 
    goto return_label;
  }
  else ;
  
#line 5150 
  if ((unsigned int)min_length > 49U) {
    
#line 5151 
    i = (unsigned short)0U;
    
#line 5151 
    goto ldv_55598;
    ldv_55597: 
#line 5152 
    ;
    
#line 5152 
    ret_val = e1000_read_phy_reg(hw,(unsigned int)dsp_reg_array[(int)i],& phy_data);
    
#line 5154 
    if (ret_val != 0) {
      
#line 5155 
      __retres = ret_val;
      
#line 5155 
      goto return_label;
    }
    else ;
    
#line 5157 
    phy_data = (unsigned short)((unsigned int)phy_data & 16383U);
    
#line 5159 
    ret_val = e1000_write_phy_reg(hw,(unsigned int)dsp_reg_array[(int)i],(unsigned short)((int)phy_data));
    
#line 5161 
    if (ret_val != 0) {
      
#line 5162 
      __retres = ret_val;
      
#line 5162 
      goto return_label;
    }
    else ;
    
#line 5151 
    i = (u16)((int)i + 1);
    ldv_55598: 
#line 5152 
    ;
    
#line 5151 
    if ((unsigned int)i <= 3U) 
#line 5153 
                               goto ldv_55597; else 
#line 5156 
                                                    goto ldv_55599;
    ldv_55599: 
#line 5157 
    ;
    
#line 5164 
    hw->dsp_config_state = 2;
  }
  else {
    
#line 5166 
    u16 ffe_idle_err_timeout = (unsigned short)20U;
    
#line 5167 
    u32 idle_errs = 0U;
    
#line 5170 
    ret_val = e1000_read_phy_reg(hw,10U,& phy_data);
    
#line 5171 
    if (ret_val != 0) {
      
#line 5172 
      __retres = ret_val;
      
#line 5172 
      goto return_label;
    }
    else ;
    
#line 5174 
    i = (unsigned short)0U;
    
#line 5174 
    goto ldv_55604;
    ldv_55603: 
#line 5175 
    ;
    
#line 5175 
    __const_udelay(4295000UL);
    
#line 5176 
    ret_val = e1000_read_phy_reg(hw,10U,& phy_data);
    
#line 5178 
    if (ret_val != 0) {
      
#line 5179 
      __retres = ret_val;
      
#line 5179 
      goto return_label;
    }
    else ;
    
#line 5181 
    idle_errs = ((unsigned int)phy_data & 255U) + idle_errs;
    
#line 5182 
    if (idle_errs > 5U) {
      
#line 5183 
      hw->ffe_config_state = 1;
      
#line 5185 
      ret_val = e1000_write_phy_reg(hw,7989U,(unsigned short)105);
      
#line 5188 
      if (ret_val != 0) {
        
#line 5189 
        __retres = ret_val;
        
#line 5189 
        goto return_label;
      }
      else ;
      
#line 5190 
      goto ldv_55602;
    }
    else ;
    
#line 5193 
    if (idle_errs != 0U) 
#line 5194 
                         ffe_idle_err_timeout = (unsigned short)100U; else ;
    
#line 5174 
    i = (u16)((int)i + 1);
    ldv_55604: 
#line 5175 
    ;
    
#line 5174 
    if ((int)i < (int)ffe_idle_err_timeout) 
#line 5176 
                                            goto ldv_55603; else 
#line 5179 
                                                                 goto ldv_55602;
    ldv_55602: 
#line 5180 
    ;
  }
  
#line 5199 
  __retres = 0;
  return_label: 
#line 5199 
                return __retres;
}


#line 5214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_config_dsp_after_link_change(struct e1000_hw *hw, bool link_up)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  u16 phy_saved_data;
  u16 speed;
  u16 duplex;
  u16 i;
  
#line 5219 
  if (hw->phy_type != (unsigned int)1) {
    
#line 5220 
    __retres = 0;
    
#line 5220 
    goto return_label;
  }
  else ;
  
#line 5222 
  if ((int)link_up != 0) {
    
#line 5223 
    ret_val = e1000_get_speed_and_duplex(hw,& speed,& duplex);
    
#line 5224 
    if (ret_val != 0) {
      {
        
#line 5225 
        struct _ddebug descriptor = {.modname = "e1000", .function = "e1000_config_dsp_after_link_change", .filename = "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c", .format = "Error getting link speed and duplex\n", .lineno = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(18))))5225U, .flags = (unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))))0U};
        
#line 5225 
        if ((long)(((int)descriptor.flags & 1) != 0) != 0L) {
          struct net_device *tmp;
          
#line 5225 
          tmp = e1000_get_hw_dev(hw);
          
#line 5225 
          __dynamic_netdev_dbg(& descriptor,(struct net_device const *)tmp,"Error getting link speed and duplex\n");
        }
        else ;
      }
      
#line 5226 
      __retres = ret_val;
      
#line 5226 
      goto return_label;
    }
    else ;
    
#line 5229 
    if ((unsigned int)speed == 1000U) {
      
#line 5230 
      ret_val = e1000_1000Mb_check_cable_length(hw);
      
#line 5231 
      if (ret_val != 0) {
        
#line 5232 
        __retres = ret_val;
        
#line 5232 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else {
    
#line 5235 
    if (hw->dsp_config_state == (unsigned int)2) {
      
#line 5239 
      ret_val = e1000_read_phy_reg(hw,12123U,& phy_saved_data);
      
#line 5242 
      if (ret_val != 0) {
        
#line 5243 
        __retres = ret_val;
        
#line 5243 
        goto return_label;
      }
      else ;
      
#line 5246 
      ret_val = e1000_write_phy_reg(hw,12123U,(unsigned short)3);
      
#line 5248 
      if (ret_val != 0) {
        
#line 5249 
        __retres = ret_val;
        
#line 5249 
        goto return_label;
      }
      else ;
      
#line 5251 
      msleep(20U);
      
#line 5253 
      ret_val = e1000_write_phy_reg(hw,0U,(unsigned short)320);
      
#line 5255 
      if (ret_val != 0) {
        
#line 5256 
        __retres = ret_val;
        
#line 5256 
        goto return_label;
      }
      else ;
      
#line 5257 
      i = (unsigned short)0U;
      
#line 5257 
      goto ldv_55618;
      ldv_55617: 
#line 5258 
      ;
      
#line 5258 
      ret_val = e1000_read_phy_reg(hw,(unsigned int)dsp_reg_array[(int)i],& phy_data);
      
#line 5261 
      if (ret_val != 0) {
        
#line 5262 
        __retres = ret_val;
        
#line 5262 
        goto return_label;
      }
      else ;
      
#line 5264 
      phy_data = (unsigned short)((unsigned int)phy_data & 16383U);
      
#line 5265 
      phy_data = (unsigned short)((unsigned int)phy_data | 32768U);
      
#line 5267 
      ret_val = e1000_write_phy_reg(hw,(unsigned int)dsp_reg_array[(int)i],(unsigned short)((int)phy_data));
      
#line 5270 
      if (ret_val != 0) {
        
#line 5271 
        __retres = ret_val;
        
#line 5271 
        goto return_label;
      }
      else ;
      
#line 5257 
      i = (u16)((int)i + 1);
      ldv_55618: 
#line 5258 
      ;
      
#line 5257 
      if ((unsigned int)i <= 3U) 
#line 5259 
                                 goto ldv_55617; else 
#line 5262 
                                                      goto ldv_55619;
      ldv_55619: 
#line 5263 
      ;
      
#line 5274 
      ret_val = e1000_write_phy_reg(hw,0U,(unsigned short)13056);
      
#line 5276 
      if (ret_val != 0) {
        
#line 5277 
        __retres = ret_val;
        
#line 5277 
        goto return_label;
      }
      else ;
      
#line 5279 
      msleep(20U);
      
#line 5282 
      ret_val = e1000_write_phy_reg(hw,12123U,(unsigned short)((int)phy_saved_data));
      
#line 5285 
      if (ret_val != 0) {
        
#line 5286 
        __retres = ret_val;
        
#line 5286 
        goto return_label;
      }
      else ;
      
#line 5288 
      hw->dsp_config_state = 1;
    }
    else ;
    
#line 5291 
    if (hw->ffe_config_state == (unsigned int)1) {
      
#line 5295 
      ret_val = e1000_read_phy_reg(hw,12123U,& phy_saved_data);
      
#line 5298 
      if (ret_val != 0) {
        
#line 5299 
        __retres = ret_val;
        
#line 5299 
        goto return_label;
      }
      else ;
      
#line 5302 
      ret_val = e1000_write_phy_reg(hw,12123U,(unsigned short)3);
      
#line 5304 
      if (ret_val != 0) {
        
#line 5305 
        __retres = ret_val;
        
#line 5305 
        goto return_label;
      }
      else ;
      
#line 5307 
      msleep(20U);
      
#line 5309 
      ret_val = e1000_write_phy_reg(hw,0U,(unsigned short)320);
      
#line 5311 
      if (ret_val != 0) {
        
#line 5312 
        __retres = ret_val;
        
#line 5312 
        goto return_label;
      }
      else ;
      
#line 5313 
      ret_val = e1000_write_phy_reg(hw,7989U,(unsigned short)42);
      
#line 5316 
      if (ret_val != 0) {
        
#line 5317 
        __retres = ret_val;
        
#line 5317 
        goto return_label;
      }
      else ;
      
#line 5319 
      ret_val = e1000_write_phy_reg(hw,0U,(unsigned short)13056);
      
#line 5321 
      if (ret_val != 0) {
        
#line 5322 
        __retres = ret_val;
        
#line 5322 
        goto return_label;
      }
      else ;
      
#line 5324 
      msleep(20U);
      
#line 5327 
      ret_val = e1000_write_phy_reg(hw,12123U,(unsigned short)((int)phy_saved_data));
      
#line 5330 
      if (ret_val != 0) {
        
#line 5331 
        __retres = ret_val;
        
#line 5331 
        goto return_label;
      }
      else ;
      
#line 5333 
      hw->ffe_config_state = 0;
    }
    else ;
  }
  
#line 5336 
  __retres = 0;
  return_label: 
#line 5336 
                return __retres;
}


#line 5347  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_set_phy_mode(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 eeprom_data;
  
#line 5352 
  if (hw->mac_type == (unsigned int)e1000_82545_rev_3 && hw->media_type == (unsigned int)e1000_media_type_copper) {
    
#line 5354 
    ret_val = e1000_read_eeprom(hw,(unsigned short)7,(unsigned short)1,& eeprom_data);
    
#line 5357 
    if (ret_val != 0) {
      
#line 5358 
      __retres = ret_val;
      
#line 5358 
      goto return_label;
    }
    else ;
    
#line 5361 
    if ((unsigned int)eeprom_data + 32768U <= 32766U) {
      
#line 5363 
      ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)11);
      
#line 5366 
      if (ret_val != 0) {
        
#line 5367 
        __retres = ret_val;
        
#line 5367 
        goto return_label;
      }
      else ;
      
#line 5368 
      ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)33028);
      
#line 5371 
      if (ret_val != 0) {
        
#line 5372 
        __retres = ret_val;
        
#line 5372 
        goto return_label;
      }
      else ;
      
#line 5374 
      hw->phy_reset_disable = (_Bool)0;
    }
    else ;
  }
  else ;
  
#line 5378 
  __retres = 0;
  return_label: 
#line 5378 
                return __retres;
}


#line 5394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_set_d3_lplu_state(struct e1000_hw *hw, bool active)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  
#line 5399 
  if (hw->phy_type != (unsigned int)1) {
    
#line 5400 
    __retres = 0;
    
#line 5400 
    goto return_label;
  }
  else ;
  
#line 5406 
  if (hw->mac_type == (unsigned int)e1000_82541_rev_2 || hw->mac_type == (unsigned int)e1000_82547_rev_2) {
    
#line 5408 
    ret_val = e1000_read_phy_reg(hw,20U,& phy_data);
    
#line 5410 
    if (ret_val != 0) {
      
#line 5411 
      __retres = ret_val;
      
#line 5411 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 5414 
  if (! active) {
    
#line 5415 
    if (hw->mac_type == (unsigned int)e1000_82541_rev_2 || hw->mac_type == (unsigned int)e1000_82547_rev_2) {
      
#line 5417 
      phy_data = (unsigned short)((unsigned int)phy_data & 65519U);
      
#line 5418 
      ret_val = e1000_write_phy_reg(hw,20U,(unsigned short)((int)phy_data));
      
#line 5421 
      if (ret_val != 0) {
        
#line 5422 
        __retres = ret_val;
        
#line 5422 
        goto return_label;
      }
      else ;
    }
    else ;
    
#line 5430 
    if (hw->smart_speed == (unsigned int)1) {
      
#line 5431 
      ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
      
#line 5434 
      if (ret_val != 0) {
        
#line 5435 
        __retres = ret_val;
        
#line 5435 
        goto return_label;
      }
      else ;
      
#line 5437 
      phy_data = (unsigned short)((unsigned int)phy_data | 128U);
      
#line 5438 
      ret_val = e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_data));
      
#line 5441 
      if (ret_val != 0) {
        
#line 5442 
        __retres = ret_val;
        
#line 5442 
        goto return_label;
      }
      else ;
    }
    else 
      
#line 5443 
      if (hw->smart_speed == (unsigned int)2) {
        
#line 5444 
        ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
        
#line 5447 
        if (ret_val != 0) {
          
#line 5448 
          __retres = ret_val;
          
#line 5448 
          goto return_label;
        }
        else ;
        
#line 5450 
        phy_data = (unsigned short)((unsigned int)phy_data & 65407U);
        
#line 5451 
        ret_val = e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_data));
        
#line 5454 
        if (ret_val != 0) {
          
#line 5455 
          __retres = ret_val;
          
#line 5455 
          goto return_label;
        }
        else ;
      }
      else ;
  }
  else 
    
#line 5457 
    if (((unsigned int)hw->autoneg_advertised == 47U || (unsigned int)hw->autoneg_advertised == 3U) || (unsigned int)hw->autoneg_advertised == 15U) {
      
#line 5462 
      if (hw->mac_type == (unsigned int)e1000_82541_rev_2 || hw->mac_type == (unsigned int)e1000_82547_rev_2) {
        
#line 5464 
        phy_data = (unsigned short)((unsigned int)phy_data | 16U);
        
#line 5465 
        ret_val = e1000_write_phy_reg(hw,20U,(unsigned short)((int)phy_data));
        
#line 5468 
        if (ret_val != 0) {
          
#line 5469 
          __retres = ret_val;
          
#line 5469 
          goto return_label;
        }
        else ;
      }
      else ;
      
#line 5473 
      ret_val = e1000_read_phy_reg(hw,16U,& phy_data);
      
#line 5476 
      if (ret_val != 0) {
        
#line 5477 
        __retres = ret_val;
        
#line 5477 
        goto return_label;
      }
      else ;
      
#line 5479 
      phy_data = (unsigned short)((unsigned int)phy_data & 65407U);
      
#line 5480 
      ret_val = e1000_write_phy_reg(hw,16U,(unsigned short)((int)phy_data));
      
#line 5483 
      if (ret_val != 0) {
        
#line 5484 
        __retres = ret_val;
        
#line 5484 
        goto return_label;
      }
      else ;
    }
    else ;
  
#line 5487 
  __retres = 0;
  return_label: 
#line 5487 
                return __retres;
}


#line 5496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_set_vco_speed(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 phy_data;
  
#line 5499 
  u16 default_page = (unsigned short)0U;
  
#line 5502 
  switch ((unsigned int)hw->mac_type) {
    case (unsigned int)7: 
#line 5503 
    ;
    case (unsigned int)10: 
#line 5504 
    ;
    
#line 5505 
    goto ldv_55639;
    default: 
#line 5506 
    ;
    
#line 5507 
    __retres = 0;
    
#line 5507 
    goto return_label;
  }
  ldv_55639: 
#line 5512 
  ;
  
#line 5512 
  ret_val = e1000_read_phy_reg(hw,29U,& default_page);
  
#line 5514 
  if (ret_val != 0) {
    
#line 5515 
    __retres = ret_val;
    
#line 5515 
    goto return_label;
  }
  else ;
  
#line 5517 
  ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)5);
  
#line 5518 
  if (ret_val != 0) {
    
#line 5519 
    __retres = ret_val;
    
#line 5519 
    goto return_label;
  }
  else ;
  
#line 5521 
  ret_val = e1000_read_phy_reg(hw,30U,& phy_data);
  
#line 5522 
  if (ret_val != 0) {
    
#line 5523 
    __retres = ret_val;
    
#line 5523 
    goto return_label;
  }
  else ;
  
#line 5525 
  phy_data = (unsigned short)((unsigned int)phy_data & 65279U);
  
#line 5526 
  ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)((int)phy_data));
  
#line 5527 
  if (ret_val != 0) {
    
#line 5528 
    __retres = ret_val;
    
#line 5528 
    goto return_label;
  }
  else ;
  
#line 5532 
  ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)4);
  
#line 5533 
  if (ret_val != 0) {
    
#line 5534 
    __retres = ret_val;
    
#line 5534 
    goto return_label;
  }
  else ;
  
#line 5536 
  ret_val = e1000_read_phy_reg(hw,30U,& phy_data);
  
#line 5537 
  if (ret_val != 0) {
    
#line 5538 
    __retres = ret_val;
    
#line 5538 
    goto return_label;
  }
  else ;
  
#line 5540 
  phy_data = (unsigned short)((unsigned int)phy_data | 2048U);
  
#line 5541 
  ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)((int)phy_data));
  
#line 5542 
  if (ret_val != 0) {
    
#line 5543 
    __retres = ret_val;
    
#line 5543 
    goto return_label;
  }
  else ;
  
#line 5545 
  ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)((int)default_page));
  
#line 5547 
  if (ret_val != 0) {
    
#line 5548 
    __retres = ret_val;
    
#line 5548 
    goto return_label;
  }
  else ;
  
#line 5550 
  __retres = 0;
  return_label: 
#line 5550 
                return __retres;
}


#line 5561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
u32 e1000_enable_mng_pass_thru(struct e1000_hw *hw)
{
  u32 __retres;
  u32 manc;
  
#line 5565 
  if (hw->asf_firmware_present != 0U) {
    
#line 5566 
    manc = readl((void const volatile *)(hw->hw_addr + 22560U));
    
#line 5568 
    if ((manc & 131072U) == 0U || (manc & 1048576U) == 0U) {
      
#line 5570 
      __retres = 0U;
      
#line 5570 
      goto return_label;
    }
    else ;
    
#line 5571 
    if ((manc & 1U) != 0U && (manc & 2U) == 0U) {
      
#line 5572 
      __retres = 1U;
      
#line 5572 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 5574 
  __retres = 0U;
  return_label: 
#line 5574 
                return __retres;
}


#line 5577  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_polarity_reversal_workaround(struct e1000_hw *hw)
{
  s32 __retres;
  s32 ret_val;
  u16 mii_status_reg;
  u16 i;
  
#line 5587 
  ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)25);
  
#line 5588 
  if (ret_val != 0) {
    
#line 5589 
    __retres = ret_val;
    
#line 5589 
    goto return_label;
  }
  else ;
  
#line 5590 
  ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)65535);
  
#line 5591 
  if (ret_val != 0) {
    
#line 5592 
    __retres = ret_val;
    
#line 5592 
    goto return_label;
  }
  else ;
  
#line 5594 
  ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)0);
  
#line 5595 
  if (ret_val != 0) {
    
#line 5596 
    __retres = ret_val;
    
#line 5596 
    goto return_label;
  }
  else ;
  
#line 5599 
  i = (unsigned short)20U;
  
#line 5599 
  goto ldv_55653;
  ldv_55652: 
#line 5600 
  ;
  
#line 5604 
  ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
  
#line 5605 
  if (ret_val != 0) {
    
#line 5606 
    __retres = ret_val;
    
#line 5606 
    goto return_label;
  }
  else ;
  
#line 5608 
  ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
  
#line 5609 
  if (ret_val != 0) {
    
#line 5610 
    __retres = ret_val;
    
#line 5610 
    goto return_label;
  }
  else ;
  
#line 5612 
  if (((int)mii_status_reg & -5) == 0) 
#line 5613 
                                       goto ldv_55651; else ;
  
#line 5614 
  msleep(100U);
  
#line 5599 
  i = (u16)((int)i - 1);
  ldv_55653: 
#line 5600 
  ;
  
#line 5599 
  if ((unsigned int)i != 0U) 
#line 5601 
                             goto ldv_55652; else 
#line 5604 
                                                  goto ldv_55651;
  ldv_55651: 
#line 5605 
  ;
  
#line 5618 
  msleep(1000U);
  
#line 5622 
  ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)25);
  
#line 5623 
  if (ret_val != 0) {
    
#line 5624 
    __retres = ret_val;
    
#line 5624 
    goto return_label;
  }
  else ;
  
#line 5625 
  msleep(50U);
  
#line 5626 
  ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)65520);
  
#line 5627 
  if (ret_val != 0) {
    
#line 5628 
    __retres = ret_val;
    
#line 5628 
    goto return_label;
  }
  else ;
  
#line 5629 
  msleep(50U);
  
#line 5630 
  ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)65280);
  
#line 5631 
  if (ret_val != 0) {
    
#line 5632 
    __retres = ret_val;
    
#line 5632 
    goto return_label;
  }
  else ;
  
#line 5633 
  msleep(50U);
  
#line 5634 
  ret_val = e1000_write_phy_reg(hw,30U,(unsigned short)0);
  
#line 5635 
  if (ret_val != 0) {
    
#line 5636 
    __retres = ret_val;
    
#line 5636 
    goto return_label;
  }
  else ;
  
#line 5638 
  ret_val = e1000_write_phy_reg(hw,29U,(unsigned short)0);
  
#line 5639 
  if (ret_val != 0) {
    
#line 5640 
    __retres = ret_val;
    
#line 5640 
    goto return_label;
  }
  else ;
  
#line 5643 
  i = (unsigned short)20U;
  
#line 5643 
  goto ldv_55656;
  ldv_55655: 
#line 5644 
  ;
  
#line 5648 
  ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
  
#line 5649 
  if (ret_val != 0) {
    
#line 5650 
    __retres = ret_val;
    
#line 5650 
    goto return_label;
  }
  else ;
  
#line 5652 
  ret_val = e1000_read_phy_reg(hw,1U,& mii_status_reg);
  
#line 5653 
  if (ret_val != 0) {
    
#line 5654 
    __retres = ret_val;
    
#line 5654 
    goto return_label;
  }
  else ;
  
#line 5656 
  if (((int)mii_status_reg & 4) != 0) 
#line 5657 
                                      goto ldv_55654; else ;
  
#line 5658 
  msleep(100U);
  
#line 5643 
  i = (u16)((int)i - 1);
  ldv_55656: 
#line 5644 
  ;
  
#line 5643 
  if ((unsigned int)i != 0U) 
#line 5645 
                             goto ldv_55655; else 
#line 5648 
                                                  goto ldv_55654;
  ldv_55654: 
#line 5649 
  ;
  
#line 5660 
  __retres = 0;
  return_label: 
#line 5660 
                return __retres;
}


#line 5671  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_get_auto_rd_done(struct e1000_hw *hw)
{
  s32 __retres;
  
#line 5673 
  msleep(5U);
  
#line 5674 
  __retres = 0;
  
#line 5674 
  return __retres;
}


#line 5685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/ethernet/intel/e1000/e1000_hw.c"
static s32 e1000_get_phy_cfg_done(struct e1000_hw *hw)
{
  s32 __retres;
  
#line 5687 
  msleep(10U);
  
#line 5688 
  __retres = 0;
  
#line 5688 
  return __retres;
}


#line 788  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv___ldv_spin_lock_77(spinlock_t *ldv_func_arg1)
{
  
#line 792 
  ldv_spin_model_lock((char *)"e1000_phy_lock");
  
#line 794 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 795 
  return;
}


#line 798  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv_spin_unlock_irqrestore_78(spinlock_t *lock, unsigned long flags)
{
  
#line 802 
  ldv_spin_model_unlock((char *)"e1000_phy_lock");
  
#line 804 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 805 
  return;
}


#line 808  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv_spin_unlock_irqrestore_79(spinlock_t *lock, unsigned long flags)
{
  
#line 812 
  ldv_spin_model_unlock((char *)"e1000_phy_lock");
  
#line 814 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 815 
  return;
}


#line 818  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv___ldv_spin_lock_80(spinlock_t *ldv_func_arg1)
{
  
#line 822 
  ldv_spin_model_lock((char *)"e1000_phy_lock");
  
#line 824 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 825 
  return;
}


#line 828  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv_spin_unlock_irqrestore_81(spinlock_t *lock, unsigned long flags)
{
  
#line 832 
  ldv_spin_model_unlock((char *)"e1000_phy_lock");
  
#line 834 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 835 
  return;
}


#line 838  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv_spin_unlock_irqrestore_82(spinlock_t *lock, unsigned long flags)
{
  
#line 842 
  ldv_spin_model_unlock((char *)"e1000_phy_lock");
  
#line 844 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 845 
  return;
}


#line 848  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv_spin_lock_83(spinlock_t *lock)
{
  
#line 852 
  ldv_spin_model_lock((char *)"e1000_eeprom_lock");
  
#line 854 
  spin_lock_0(lock);
  
#line 855 
  return;
}


#line 858  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv_spin_unlock_84(spinlock_t *lock)
{
  
#line 862 
  ldv_spin_model_unlock((char *)"e1000_eeprom_lock");
  
#line 864 
  spin_unlock_0(lock);
  
#line 865 
  return;
}


#line 868  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv_spin_lock_85(spinlock_t *lock)
{
  
#line 872 
  ldv_spin_model_lock((char *)"e1000_eeprom_lock");
  
#line 874 
  spin_lock_0(lock);
  
#line 875 
  return;
}


#line 878  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/weaver/.tmp_e1000_hw.c.aux"
static void ldv_spin_unlock_86(spinlock_t *lock)
{
  
#line 882 
  ldv_spin_model_unlock((char *)"e1000_eeprom_lock");
  
#line 884 
  spin_unlock_0(lock);
  
#line 885 
  return;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 28 
long ldv_is_err_or_null(void const *ptr);


#line 29 
void *ldv_err_ptr(long error);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 97 
void ldv_failed_register_netdev(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
int main(void);


#line 95 
void *ldv_initialization_1(void *arg0);


#line 97 
void ldv_dispatch_register_10_4(struct net_device *arg0);


#line 99 
void ldv_dispatch_irq_deregister_4_1(int arg0);


#line 102 
void ldv_dispatch_register_7_3(struct pci_driver *arg0);


#line 103 
void ldv_dispatch_irq_register_11_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 104 
void *ldv_pci_scenario_12(void *arg0);


#line 105 
void *ldv_random_allocationless_scenario_13(void *arg0);


#line 106 
void ldv_dispatch_deregister_6_1(struct net_device *arg0);


#line 108 
void ldv_dispatch_deregister_9_1(struct pci_driver *arg0);


#line 109 
void *ldv_interrupt_scenario_14(void *arg0);


#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_14;

#line 115  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_12;

#line 116  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_13;

#line 120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_schedule_delayed_work(struct delayed_work *arg0, unsigned long arg1)
{
  _Bool __retres;
  struct work_struct *ldv_3_ldv_param_0_2;
  struct delayed_work *ldv_3_delayed_work;
  int tmp_0;
  
#line 128 
  tmp_0 = ldv_undef_int();
  
#line 128 
  if (tmp_0 != 0) {
    
#line 130 
    ldv_3_delayed_work = arg0;
    
#line 134 
    ldv_3_ldv_param_0_2 = (struct work_struct *)ldv_xmalloc_unknown_size(0UL);
    
#line 138 
    if (ldv_3_delayed_work->work.func != (void (*)(struct work_struct *))0) 
      
#line 140 
      (*(ldv_3_delayed_work->work.func))(ldv_3_ldv_param_0_2); else ;
    
#line 145 
    ldv_free((void *)ldv_3_ldv_param_0_2);
    
#line 149 
    __retres = (_Bool)1;
    
#line 149 
    goto return_label;
  }
  else {
    
#line 156 
    __retres = (_Bool)0;
    
#line 156 
    goto return_label;
  }
  return_label: 
#line 128 
                return __retres;
}


#line 166  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_schedule_work(struct work_struct *arg0)
{
  _Bool __retres;
  struct work_struct *ldv_8_work_struct;
  int tmp;
  
#line 173 
  tmp = ldv_undef_int();
  
#line 173 
  if (tmp != 0) {
    
#line 175 
    ldv_8_work_struct = arg0;
    
#line 179 
    if (ldv_8_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 181 
      (*(ldv_8_work_struct->func))(ldv_8_work_struct); else ;
    
#line 186 
    __retres = (_Bool)1;
    
#line 186 
    goto return_label;
  }
  else {
    
#line 193 
    __retres = (_Bool)0;
    
#line 193 
    goto return_label;
  }
  return_label: 
#line 173 
                return __retres;
}


#line 203  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 206 
  struct pci_driver *ldv_7_pci_driver = ldv_emg_alias_e1000_driver_2;
  
#line 210 
  tmp_0 = ldv_undef_int();
  
#line 210 
  if (tmp_0 != 0) {
    
#line 212 
    ldv_7_pci_driver = arg0;
    
#line 216 
    ldv_dispatch_register_7_3(ldv_7_pci_driver);
    
#line 220 
    __retres = 0;
    
#line 220 
    goto return_label;
  }
  else {
    int tmp;
    
#line 227 
    tmp = ldv_undef_int_negative();
    
#line 227 
    __retres = tmp;
    
#line 227 
    goto return_label;
  }
  return_label: 
#line 210 
                return __retres;
}


#line 237  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 240 
  ldv_initialize();
  
#line 243 
  ldv_initialization_1((void *)0);
  
#line 245 
  __retres = 0;
  
#line 245 
  return __retres;
}


#line 250  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 257 
  ldv_1_ret = ldv_emg_e1000_init_module();
  
#line 258 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 261 
  tmp = ldv_undef_int();
  
#line 261 
  if (tmp != 0) {
    
#line 263 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 267 
    __retres = (void *)0;
    
#line 267 
    goto return_label;
  }
  else {
    
#line 271 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 276 
    ldv_emg_e1000_exit_module();
    
#line 280 
    __retres = (void *)0;
    
#line 280 
    goto return_label;
  }
  
#line 283 
  __retres = (void *)0;
  return_label: 
#line 283 
                return __retres;
}


#line 288  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 291 
  struct pci_driver *ldv_9_pci_driver = ldv_emg_alias_e1000_driver_2;
  
#line 294 
  ldv_9_pci_driver = arg0;
  
#line 298 
  ldv_dispatch_deregister_9_1(ldv_9_pci_driver);
  
#line 302 
  goto return_label;
  return_label: 
#line 304 
                return;
}


#line 309  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_10_4(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_13 *cf_arg_13;
  int tmp;
  
#line 312 
  tmp = ldv_undef_int();
  
#line 312 
  switch (tmp) {
    case 0: 
#line 313 
    ;
    
#line 314 
    cf_arg_13 = (struct ldv_struct_random_allocationless_scenario_13 *)ldv_xmalloc(16UL);
    
#line 315 
    cf_arg_13->arg0 = arg0;
    
#line 316 
    ret = pthread_create(& ldv_thread_13,(pthread_attr_t const *)0,& ldv_random_allocationless_scenario_13,(void *)cf_arg_13);
    
#line 317 
    __VERIFIER_assume(ret == 0);
    
#line 318 
    goto ldv_44788;
    default: 
#line 320 
    ;
    
#line 320 
    __VERIFIER_assume(0);
  }
  ldv_44788: 
#line 321 
  ;
  
#line 322 
  return;
}


#line 326  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
struct net_device *ldv_emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  struct net_device *__retres;
  struct net_device *ldv_5_netdev;
  int tmp_0;
  
#line 333 
  tmp_0 = ldv_undef_int();
  
#line 333 
  if (tmp_0 != 0) {
    
#line 335 
    ldv_5_netdev = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    
#line 339 
    __retres = ldv_5_netdev;
    
#line 339 
    goto return_label;
  }
  else {
    
#line 346 
    __retres = (struct net_device *)0;
    
#line 346 
    goto return_label;
  }
  return_label: 
#line 333 
                return __retres;
}


#line 356  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_14(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_14_ret_val;
  int ldv_14_line;
  void *ldv_14_data;
  enum irqreturn (*ldv_14_thread)(int , void *);
  int tmp;
  
#line 362 
  enum irqreturn (*ldv_14_callback)(int , void *) = & ldv_emg_wrapper_e1000_test_intr_2;
  
#line 365 
  struct ldv_struct_interrupt_scenario_14 *data = (struct ldv_struct_interrupt_scenario_14 *)arg0;
  
#line 370 
  if (data != (struct ldv_struct_interrupt_scenario_14 *)0) {
    
#line 371 
    ldv_14_line = data->arg0;
    
#line 372 
    ldv_14_callback = data->arg1;
    
#line 373 
    ldv_14_thread = data->arg2;
    
#line 374 
    ldv_14_data = data->arg3;
    
#line 375 
    ldv_free((void *)data);
  }
  else ;
  
#line 381 
  ldv_switch_to_interrupt_context();
  
#line 383 
  ldv_14_ret_val = ldv_emg_wrapper_e1000_test_intr_2(ldv_14_line,ldv_14_data);
  
#line 385 
  ldv_switch_to_process_context();
  
#line 388 
  tmp = ldv_undef_int();
  
#line 388 
  if (tmp != 0) {
    
#line 390 
    __VERIFIER_assume(ldv_14_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 394 
    if (ldv_14_thread != (enum irqreturn (*)(int , void *))0) 
#line 396 
                                                              (*ldv_14_thread)(ldv_14_line,ldv_14_data); else ;
  }
  else 
#line 403 
       __VERIFIER_assume(ldv_14_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 412 
  __retres = (void *)0;
  
#line 412 
  goto return_label;
  
#line 414 
  __retres = (void *)0;
  return_label: 
#line 414 
                return __retres;
}


#line 419  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_unregister_netdev(struct net_device *arg0)
{
  struct net_device *ldv_6_netdev;
  
#line 425 
  ldv_6_netdev = arg0;
  
#line 430 
  ldv_emg_wrapper_e1000_close_2(ldv_6_netdev);
  
#line 434 
  ldv_dispatch_deregister_6_1(ldv_6_netdev);
  
#line 438 
  goto return_label;
  return_label: 
#line 440 
                return;
}


#line 445  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_4_line;
  
#line 451 
  ldv_4_line = (int)arg0;
  
#line 455 
  ldv_dispatch_irq_deregister_4_1(ldv_4_line);
  
#line 459 
  goto return_label;
  return_label: 
#line 461 
                return;
}


#line 466  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_7_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_12 *cf_arg_12;
  int tmp;
  
#line 469 
  tmp = ldv_undef_int();
  
#line 469 
  switch (tmp) {
    case 0: 
#line 470 
    ;
    
#line 471 
    cf_arg_12 = (struct ldv_struct_pci_scenario_12 *)ldv_xmalloc(16UL);
    
#line 472 
    cf_arg_12->arg0 = arg0;
    
#line 473 
    ret = pthread_create(& ldv_thread_12,(pthread_attr_t const *)0,& ldv_pci_scenario_12,(void *)cf_arg_12);
    
#line 474 
    __VERIFIER_assume(ret == 0);
    
#line 475 
    goto ldv_44824;
    default: 
#line 477 
    ;
    
#line 477 
    __VERIFIER_assume(0);
  }
  ldv_44824: 
#line 478 
  ;
  
#line 479 
  return;
}


#line 483  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_11_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_14 *cf_arg_14;
  int tmp;
  
#line 486 
  tmp = ldv_undef_int();
  
#line 486 
  switch (tmp) {
    case 0: 
#line 487 
    ;
    
#line 488 
    cf_arg_14 = (struct ldv_struct_interrupt_scenario_14 *)ldv_xmalloc(32UL);
    
#line 489 
    cf_arg_14->arg0 = arg0;
    
#line 490 
    cf_arg_14->arg1 = arg1;
    
#line 491 
    cf_arg_14->arg2 = arg2;
    
#line 492 
    cf_arg_14->arg3 = arg3;
    
#line 493 
    ret = pthread_create(& ldv_thread_14,(pthread_attr_t const *)0,& ldv_interrupt_scenario_14,(void *)cf_arg_14);
    
#line 494 
    __VERIFIER_assume(ret == 0);
    
#line 495 
    goto ldv_44839;
    default: 
#line 497 
    ;
    
#line 497 
    __VERIFIER_assume(0);
  }
  ldv_44839: 
#line 498 
  ;
  
#line 499 
  return;
}


#line 503  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_12(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_12_resource_1;
  struct pci_device_id *ldv_12_ldv_param_1_2;
  struct pm_message ldv_12_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 508 
  struct pci_driver *ldv_12_container = ldv_emg_alias_e1000_driver_2;
  
#line 509 
  int ldv_12_ret = ldv_undef_int();
  
#line 512 
  struct ldv_struct_pci_scenario_12 *data = (struct ldv_struct_pci_scenario_12 *)arg0;
  
#line 516 
  ldv_12_ret = ldv_undef_int();
  
#line 519 
  if (data != (struct ldv_struct_pci_scenario_12 *)0) {
    
#line 520 
    ldv_12_container = data->arg0;
    
#line 521 
    ldv_free((void *)data);
  }
  else ;
  
#line 532 
  goto ldv_main_12;
  
#line 534 
  __retres = (void *)0;
  
#line 534 
  goto return_label;
  ldv_main_12: 
#line 537 
  ;
  
#line 540 
  tmp_2 = ldv_undef_int();
  
#line 540 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 542 
    ldv_12_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 547 
    ldv_pre_probe();
    
#line 549 
    ldv_12_ret = ldv_emg_wrapper_e1000_probe_3(ldv_12_resource_1,ldv_12_ldv_param_1_2);
    
#line 551 
    ldv_12_ret = ldv_post_probe(ldv_12_ret);
    
#line 555 
    ldv_free((void *)ldv_12_ldv_param_1_2);
    
#line 558 
    tmp_1 = ldv_undef_int();
    
#line 558 
    if (tmp_1 != 0) {
      
#line 560 
      __VERIFIER_assume(ldv_12_ret == 0);
      
#line 567 
      goto ldv_call_12;
    }
    else {
      
#line 571 
      __VERIFIER_assume(ldv_12_ret != 0);
      
#line 578 
      goto ldv_main_12;
    }
  }
  else {
    
#line 590 
    __retres = (void *)0;
    
#line 590 
    goto return_label;
  }
  
#line 593 
  __retres = (void *)0;
  
#line 593 
  goto return_label;
  ldv_call_12: 
#line 596 
  ;
  
#line 599 
  tmp_3 = ldv_undef_int();
  
#line 599 
  switch (tmp_3) {
    case 1: 
#line 600 
    ;
    
#line 609 
    goto ldv_call_12;
    case 2: 
#line 612 
    ;
    
#line 615 
    ldv_12_ret = ldv_emg_wrapper_e1000_suspend_4(ldv_12_resource_1,ldv_12_resource_0);
    
#line 617 
    ldv_12_ret = ldv_filter_err_code(ldv_12_ret);
    
#line 621 
    if (ldv_12_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 623 
      ldv_12_ret = (*(ldv_12_container->suspend_late))(ldv_12_resource_1,ldv_12_resource_0);
      
#line 625 
      ldv_12_ret = ldv_filter_err_code(ldv_12_ret);
    }
    else 
#line 627 
         ldv_12_ret = ldv_undef_int();
    
#line 632 
    if (ldv_12_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 634 
      (*(ldv_12_container->resume_early))(ldv_12_resource_1); else ;
    
#line 640 
    ldv_emg_wrapper_e1000_resume_6(ldv_12_resource_1);
    
#line 647 
    goto ldv_call_12;
    case 3: 
#line 650 
    ;
    
#line 653 
    ldv_emg_wrapper_e1000_shutdown_2(ldv_12_resource_1);
    
#line 658 
    ldv_emg_wrapper_e1000_remove_5(ldv_12_resource_1);
    
#line 665 
    goto ldv_main_12;
    default: 
#line 668 
    ;
    
#line 668 
    __VERIFIER_assume(0);
  }
  
#line 671 
  __retres = (void *)0;
  return_label: 
#line 671 
                return __retres;
}


#line 676  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_random_allocationless_scenario_13(void *arg0)
{
  void *__retres;
  struct ethtool_cmd *ldv_13_ldv_param_1_3;
  unsigned long long ldv_13_ldv_param_1_10;
  struct ethtool_eeprom *ldv_13_ldv_param_1_13;
  struct ethtool_ringparam *ldv_13_ldv_param_1_15;
  int ldv_13_ldv_param_2_28;
  struct ethtool_ts_info *ldv_13_ldv_param_1_6;
  unsigned short ldv_13_ldv_param_1_25;
  struct ethtool_stats *ldv_13_ldv_param_1_8;
  struct ethtool_coalesce *ldv_13_ldv_param_1_29;
  struct ethtool_pauseparam *ldv_13_ldv_param_1_2;
  struct ethtool_cmd *ldv_13_ldv_param_1_4;
  enum ethtool_phys_id_state *ldv_13_ldv_param_1_5;
  struct ethtool_drvinfo *ldv_13_ldv_param_1_11;
  struct sk_buff *ldv_13_ldv_param_0_16;
  unsigned short ldv_13_ldv_param_1_38;
  unsigned long long *ldv_13_ldv_param_2_22;
  struct ifreq *ldv_13_ldv_param_1_27;
  unsigned long long ldv_13_ldv_param_1_12;
  unsigned int ldv_13_ldv_param_1_23;
  struct ethtool_eeprom *ldv_13_ldv_param_1_18;
  int ldv_13_ldv_param_1_20;
  struct ethtool_wolinfo *ldv_13_ldv_param_1_30;
  unsigned char *ldv_13_ldv_param_2_19;
  unsigned int ldv_13_ldv_param_1_33;
  struct ethtool_test *ldv_13_ldv_param_1_21;
  struct ethtool_ringparam *ldv_13_ldv_param_1_35;
  struct ethtool_regs *ldv_13_ldv_param_1_31;
  unsigned char *ldv_13_ldv_param_2_34;
  void *ldv_13_ldv_param_1_17;
  unsigned long long *ldv_13_ldv_param_2_9;
  struct ethtool_pauseparam *ldv_13_ldv_param_1_37;
  struct ethtool_coalesce *ldv_13_ldv_param_1_36;
  void *ldv_13_ldv_param_2_32;
  unsigned char *ldv_13_ldv_param_2_14;
  struct net_device *ldv_13_container;
  unsigned short ldv_13_ldv_param_2_39;
  unsigned short ldv_13_ldv_param_2_26;
  int ldv_13_ldv_param_1_7;
  struct ethtool_wolinfo *ldv_13_ldv_param_1_24;
  int tmp_25;
  
#line 719 
  struct ldv_struct_random_allocationless_scenario_13 *data = (struct ldv_struct_random_allocationless_scenario_13 *)arg0;
  
#line 724 
  if (data != (struct ldv_struct_random_allocationless_scenario_13 *)0) {
    
#line 725 
    ldv_13_container = data->arg0;
    
#line 726 
    ldv_free((void *)data);
  }
  else ;
  
#line 734 
  goto ldv_call_13;
  
#line 736 
  __retres = (void *)0;
  
#line 736 
  goto return_label;
  ldv_call_13: 
#line 739 
  ;
  
#line 742 
  tmp_25 = ldv_undef_int();
  
#line 742 
  if (tmp_25 != 0) {
    int tmp_0;
    
#line 744 
    ldv_13_ldv_param_1_2 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
    
#line 747 
    tmp_0 = ldv_undef_int();
    
#line 747 
    switch (tmp_0) {
      case 1: 
#line 748 
      ;
      
#line 751 
      ldv_emg_wrapper_e1000_get_pauseparam_2(ldv_13_container,ldv_13_ldv_param_1_2);
      
#line 754 
      goto ldv_44901;
      case 2: 
#line 756 
      ;
      
#line 759 
      ldv_emg_wrapper_e1000_set_rx_mode_7(ldv_13_container);
      
#line 762 
      goto ldv_44901;
      case 3: 
#line 764 
      ;
      
#line 767 
      ldv_emg_wrapper_e1000_nway_reset_32(ldv_13_container);
      
#line 770 
      goto ldv_44901;
      case 4: 
#line 772 
      ;
      
#line 778 
      ldv_emg_wrapper_e1000_vlan_rx_kill_vid_38(ldv_13_container,(unsigned short)((int)ldv_13_ldv_param_1_38),(unsigned short)((int)ldv_13_ldv_param_2_39));
      
#line 784 
      goto ldv_44901;
      case 5: 
#line 786 
      ;
      
#line 788 
      ldv_13_ldv_param_1_37 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 793 
      ldv_emg_wrapper_e1000_set_pauseparam_37(ldv_13_container,ldv_13_ldv_param_1_37);
      
#line 797 
      ldv_free((void *)ldv_13_ldv_param_1_37);
      
#line 800 
      goto ldv_44901;
      case 6: 
#line 802 
      ;
      
#line 804 
      ldv_13_ldv_param_1_36 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 809 
      ldv_emg_wrapper_e1000_set_coalesce_36(ldv_13_container,ldv_13_ldv_param_1_36);
      
#line 813 
      ldv_free((void *)ldv_13_ldv_param_1_36);
      
#line 816 
      goto ldv_44901;
      case 7: 
#line 818 
      ;
      
#line 821 
      ldv_emg_wrapper_e1000_get_regs_len_35(ldv_13_container);
      
#line 824 
      goto ldv_44901;
      case 8: 
#line 826 
      ;
      
#line 828 
      ldv_13_ldv_param_1_35 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 833 
      ldv_emg_wrapper_e1000_get_ringparam_12(ldv_13_container,ldv_13_ldv_param_1_35);
      
#line 837 
      ldv_free((void *)ldv_13_ldv_param_1_35);
      
#line 840 
      goto ldv_44901;
      case 9: 
#line 842 
      ;
      
#line 844 
      ldv_13_ldv_param_2_34 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 849 
      ldv_emg_wrapper_e1000_get_strings_24(ldv_13_container,ldv_13_ldv_param_1_33,ldv_13_ldv_param_2_34);
      
#line 853 
      ldv_free((void *)ldv_13_ldv_param_2_34);
      
#line 856 
      goto ldv_44901;
      case 10: 
#line 858 
      ;
      
#line 861 
      ldv_emg_wrapper_e1000_netpoll_39(ldv_13_container);
      
#line 864 
      goto ldv_44901;
      case 11: 
#line 866 
      ;
      
#line 869 
      ldv_emg_wrapper_e1000_get_stats_31(ldv_13_container);
      
#line 872 
      goto ldv_44901;
      case 12: 
#line 874 
      ;
      
#line 877 
      ldv_emg_wrapper_e1000_tx_timeout_22(ldv_13_container);
      
#line 880 
      goto ldv_44901;
      case 13: 
#line 882 
      ;
      
#line 884 
      ldv_13_ldv_param_2_32 = ldv_xmalloc_unknown_size(0UL);
      
#line 885 
      ldv_13_ldv_param_1_31 = (struct ethtool_regs *)ldv_xmalloc_unknown_size(0UL);
      
#line 890 
      ldv_emg_wrapper_e1000_get_regs_29(ldv_13_container,ldv_13_ldv_param_1_31,ldv_13_ldv_param_2_32);
      
#line 894 
      ldv_free(ldv_13_ldv_param_2_32);
      
#line 895 
      ldv_free((void *)ldv_13_ldv_param_1_31);
      
#line 898 
      goto ldv_44901;
      case 14: 
#line 900 
      ;
      
#line 902 
      ldv_13_ldv_param_1_30 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 907 
      ldv_emg_wrapper_e1000_set_wol_28(ldv_13_container,ldv_13_ldv_param_1_30);
      
#line 911 
      ldv_free((void *)ldv_13_ldv_param_1_30);
      
#line 914 
      goto ldv_44901;
      case 15: 
#line 916 
      ;
      
#line 918 
      ldv_13_ldv_param_1_29 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
      
#line 923 
      ldv_emg_wrapper_e1000_get_coalesce_34(ldv_13_container,ldv_13_ldv_param_1_29);
      
#line 927 
      ldv_free((void *)ldv_13_ldv_param_1_29);
      
#line 930 
      goto ldv_44901;
      case 16: 
#line 932 
      ;
      
#line 934 
      ldv_13_ldv_param_1_27 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
      
#line 939 
      ldv_emg_wrapper_e1000_ioctl_27(ldv_13_container,ldv_13_ldv_param_1_27,ldv_13_ldv_param_2_28);
      
#line 943 
      ldv_free((void *)ldv_13_ldv_param_1_27);
      
#line 946 
      goto ldv_44901;
      case 17: 
#line 948 
      ;
      
#line 954 
      ldv_emg_wrapper_e1000_vlan_rx_add_vid_26(ldv_13_container,(unsigned short)((int)ldv_13_ldv_param_1_25),(unsigned short)((int)ldv_13_ldv_param_2_26));
      
#line 960 
      goto ldv_44901;
      case 18: 
#line 962 
      ;
      
#line 964 
      ldv_13_ldv_param_1_24 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 969 
      ldv_emg_wrapper_e1000_get_wol_25(ldv_13_container,ldv_13_ldv_param_1_24);
      
#line 973 
      ldv_free((void *)ldv_13_ldv_param_1_24);
      
#line 976 
      goto ldv_44901;
      case 19: 
#line 978 
      ;
      
#line 984 
      ldv_emg_wrapper_e1000_set_msglevel_6(ldv_13_container,ldv_13_ldv_param_1_23);
      
#line 990 
      goto ldv_44901;
      case 20: 
#line 992 
      ;
      
#line 994 
      ldv_13_ldv_param_2_22 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 995 
      ldv_13_ldv_param_1_21 = (struct ethtool_test *)ldv_xmalloc_unknown_size(0UL);
      
#line 1000 
      ldv_emg_wrapper_e1000_diag_test_23(ldv_13_container,ldv_13_ldv_param_1_21,ldv_13_ldv_param_2_22);
      
#line 1004 
      ldv_free((void *)ldv_13_ldv_param_2_22);
      
#line 1005 
      ldv_free((void *)ldv_13_ldv_param_1_21);
      
#line 1008 
      goto ldv_44901;
      case 21: 
#line 1010 
      ;
      
#line 1016 
      ldv_emg_wrapper_e1000_get_sset_count_30(ldv_13_container,ldv_13_ldv_param_1_20);
      
#line 1022 
      goto ldv_44901;
      case 22: 
#line 1024 
      ;
      
#line 1026 
      ldv_13_ldv_param_1_18 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
      
#line 1027 
      ldv_13_ldv_param_2_19 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1032 
      ldv_emg_wrapper_e1000_get_eeprom_3(ldv_13_container,ldv_13_ldv_param_1_18,ldv_13_ldv_param_2_19);
      
#line 1036 
      ldv_free((void *)ldv_13_ldv_param_1_18);
      
#line 1037 
      ldv_free((void *)ldv_13_ldv_param_2_19);
      
#line 1040 
      goto ldv_44901;
      case 23: 
#line 1042 
      ;
      
#line 1044 
      ldv_13_ldv_param_1_17 = ldv_xmalloc_unknown_size(0UL);
      
#line 1049 
      ldv_emg_wrapper_e1000_set_mac_20(ldv_13_container,ldv_13_ldv_param_1_17);
      
#line 1053 
      ldv_free(ldv_13_ldv_param_1_17);
      
#line 1056 
      goto ldv_44901;
      case 24: 
#line 1058 
      ;
      
#line 1060 
      ldv_13_ldv_param_0_16 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
      
#line 1065 
      ldv_emg_wrapper_e1000_xmit_frame_19(ldv_13_ldv_param_0_16,ldv_13_container);
      
#line 1069 
      ldv_free((void *)ldv_13_ldv_param_0_16);
      
#line 1072 
      goto ldv_44901;
      case 25: 
#line 1074 
      ;
      
#line 1077 
      ldv_emg_wrapper_e1000_get_msglevel_18(ldv_13_container);
      
#line 1080 
      goto ldv_44901;
      case 26: 
#line 1082 
      ;
      
#line 1084 
      ldv_13_ldv_param_1_15 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
      
#line 1089 
      ldv_emg_wrapper_e1000_set_ringparam_17(ldv_13_container,ldv_13_ldv_param_1_15);
      
#line 1093 
      ldv_free((void *)ldv_13_ldv_param_1_15);
      
#line 1096 
      goto ldv_44901;
      case 27: 
#line 1098 
      ;
      
#line 1100 
      ldv_13_ldv_param_2_14 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1101 
      ldv_13_ldv_param_1_13 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
      
#line 1106 
      ldv_emg_wrapper_e1000_set_eeprom_16(ldv_13_container,ldv_13_ldv_param_1_13,ldv_13_ldv_param_2_14);
      
#line 1110 
      ldv_free((void *)ldv_13_ldv_param_2_14);
      
#line 1111 
      ldv_free((void *)ldv_13_ldv_param_1_13);
      
#line 1114 
      goto ldv_44901;
      case 28: 
#line 1116 
      ;
      
#line 1119 
      ldv_emg_wrapper_e1000_get_eeprom_len_40(ldv_13_container);
      
#line 1122 
      goto ldv_44901;
      case 29: 
#line 1124 
      ;
      
#line 1130 
      ldv_emg_wrapper_e1000_fix_features_15(ldv_13_container,ldv_13_ldv_param_1_12);
      
#line 1136 
      goto ldv_44901;
      case 30: 
#line 1138 
      ;
      
#line 1140 
      ldv_13_ldv_param_1_11 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
      
#line 1145 
      ldv_emg_wrapper_e1000_get_drvinfo_14(ldv_13_container,ldv_13_ldv_param_1_11);
      
#line 1149 
      ldv_free((void *)ldv_13_ldv_param_1_11);
      
#line 1152 
      goto ldv_44901;
      case 31: 
#line 1154 
      ;
      
#line 1160 
      ldv_emg_wrapper_e1000_set_features_13(ldv_13_container,ldv_13_ldv_param_1_10);
      
#line 1166 
      goto ldv_44901;
      case 32: 
#line 1168 
      ;
      
#line 1171 
      ldv_emg_wrapper_e1000_get_link_11(ldv_13_container);
      
#line 1174 
      goto ldv_44901;
      case 33: 
#line 1176 
      ;
      
#line 1179 
      (*ldv_emg_alias_eth_validate_addr_8)(ldv_13_container);
      
#line 1182 
      goto ldv_44901;
      case 34: 
#line 1184 
      ;
      
#line 1186 
      ldv_13_ldv_param_1_8 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
      
#line 1187 
      ldv_13_ldv_param_2_9 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1192 
      ldv_emg_wrapper_e1000_get_ethtool_stats_9(ldv_13_container,ldv_13_ldv_param_1_8,ldv_13_ldv_param_2_9);
      
#line 1196 
      ldv_free((void *)ldv_13_ldv_param_1_8);
      
#line 1197 
      ldv_free((void *)ldv_13_ldv_param_2_9);
      
#line 1200 
      goto ldv_44901;
      case 35: 
#line 1202 
      ;
      
#line 1208 
      ldv_emg_wrapper_e1000_change_mtu_10(ldv_13_container,ldv_13_ldv_param_1_7);
      
#line 1214 
      goto ldv_44901;
      case 36: 
#line 1216 
      ;
      
#line 1218 
      ldv_13_ldv_param_1_6 = (struct ethtool_ts_info *)ldv_xmalloc_unknown_size(0UL);
      
#line 1223 
      (*ldv_emg_alias_ethtool_op_get_ts_info_33)(ldv_13_container,ldv_13_ldv_param_1_6);
      
#line 1227 
      ldv_free((void *)ldv_13_ldv_param_1_6);
      
#line 1230 
      goto ldv_44901;
      case 37: 
#line 1232 
      ;
      
#line 1234 
      ldv_13_ldv_param_1_5 = (enum ethtool_phys_id_state *)ldv_xmalloc_unknown_size(0UL);
      
#line 1239 
      ldv_emg_wrapper_e1000_set_phys_id_5(ldv_13_container,*ldv_13_ldv_param_1_5);
      
#line 1243 
      ldv_free((void *)ldv_13_ldv_param_1_5);
      
#line 1246 
      goto ldv_44901;
      case 38: 
#line 1248 
      ;
      
#line 1250 
      ldv_13_ldv_param_1_4 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 1255 
      ldv_emg_wrapper_e1000_set_settings_4(ldv_13_container,ldv_13_ldv_param_1_4);
      
#line 1259 
      ldv_free((void *)ldv_13_ldv_param_1_4);
      
#line 1262 
      goto ldv_44901;
      case 39: 
#line 1264 
      ;
      
#line 1266 
      ldv_13_ldv_param_1_3 = (struct ethtool_cmd *)ldv_xmalloc_unknown_size(0UL);
      
#line 1271 
      ldv_emg_wrapper_e1000_get_settings_21(ldv_13_container,ldv_13_ldv_param_1_3);
      
#line 1275 
      ldv_free((void *)ldv_13_ldv_param_1_3);
      
#line 1278 
      goto ldv_44901;
      default: 
#line 1280 
      ;
      
#line 1280 
      __VERIFIER_assume(0);
    }
    ldv_44901: 
#line 1283 
    ;
    
#line 1283 
    ldv_free((void *)ldv_13_ldv_param_1_2);
    
#line 1290 
    goto ldv_call_13;
  }
  else {
    
#line 1298 
    __retres = (void *)0;
    
#line 1298 
    goto return_label;
  }
  
#line 1301 
  __retres = (void *)0;
  return_label: 
#line 1301 
                return __retres;
}


#line 1306  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_6_1(struct net_device *arg0)
{
  int ret;
  struct ldv_struct_random_allocationless_scenario_13 *cf_arg_13;
  int tmp;
  
#line 1309 
  tmp = ldv_undef_int();
  
#line 1309 
  switch (tmp) {
    case 0: 
#line 1310 
    ;
    
#line 1311 
    ret = pthread_join(ldv_thread_13,(void **)0);
    
#line 1312 
    __VERIFIER_assume(ret == 0);
    
#line 1313 
    goto ldv_44947;
    default: 
#line 1315 
    ;
    
#line 1315 
    __VERIFIER_assume(0);
  }
  ldv_44947: 
#line 1316 
  ;
  
#line 1317 
  return;
}


#line 1321  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_netdev(struct net_device *arg0)
{
  struct net_device *ldv_2_netdev;
  
#line 1327 
  ldv_2_netdev = arg0;
  
#line 1328 
  ldv_free((void *)ldv_2_netdev);
  
#line 1332 
  goto return_label;
  return_label: 
#line 1334 
                return;
}


#line 1339  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_9_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_12 *cf_arg_12;
  int tmp;
  
#line 1342 
  tmp = ldv_undef_int();
  
#line 1342 
  switch (tmp) {
    case 0: 
#line 1343 
    ;
    
#line 1344 
    ret = pthread_join(ldv_thread_12,(void **)0);
    
#line 1345 
    __VERIFIER_assume(ret == 0);
    
#line 1346 
    goto ldv_44959;
    default: 
#line 1348 
    ;
    
#line 1348 
    __VERIFIER_assume(0);
  }
  ldv_44959: 
#line 1349 
  ;
  
#line 1350 
  return;
}


#line 1354  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_4_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_4 *cf_arg_14;
  int tmp;
  
#line 1357 
  tmp = ldv_undef_int();
  
#line 1357 
  switch (tmp) {
    case 0: 
#line 1358 
    ;
    
#line 1359 
    ret = pthread_join(ldv_thread_14,(void **)0);
    
#line 1360 
    __VERIFIER_assume(ret == 0);
    
#line 1361 
    goto ldv_44967;
    default: 
#line 1363 
    ;
    
#line 1363 
    __VERIFIER_assume(0);
  }
  ldv_44967: 
#line 1364 
  ;
  
#line 1365 
  return;
}


#line 1369  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_register_netdev(struct net_device *arg0)
{
  int __retres;
  struct net_device *ldv_10_netdev;
  int tmp_3;
  
#line 1373 
  int ldv_10_ret = ldv_undef_int();
  
#line 1376 
  ldv_10_ret = ldv_undef_int();
  
#line 1379 
  tmp_3 = ldv_undef_int();
  
#line 1379 
  if (tmp_3 != 0) {
    int tmp_1;
    
#line 1381 
    ldv_10_netdev = arg0;
    
#line 1386 
    ldv_10_ret = ldv_emg_wrapper_e1000_open_2(ldv_10_netdev);
    
#line 1389 
    tmp_1 = ldv_undef_int();
    
#line 1389 
    if (tmp_1 != 0) {
      
#line 1391 
      __VERIFIER_assume(ldv_10_ret == 0);
      
#line 1395 
      ldv_dispatch_register_10_4(ldv_10_netdev);
      
#line 1399 
      __retres = 0;
      
#line 1399 
      goto return_label;
    }
    else {
      int tmp_0;
      
#line 1406 
      __VERIFIER_assume(ldv_10_ret != 0);
      
#line 1407 
      ldv_failed_register_netdev();
      
#line 1408 
      tmp_0 = ldv_undef_int_negative();
      
#line 1408 
      __retres = tmp_0;
      
#line 1408 
      goto return_label;
    }
  }
  else {
    int tmp_2;
    
#line 1416 
    ldv_failed_register_netdev();
    
#line 1417 
    tmp_2 = ldv_undef_int_negative();
    
#line 1417 
    __retres = tmp_2;
    
#line 1417 
    goto return_label;
  }
  return_label: 
#line 1379 
                return __retres;
}


#line 1427  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/e1000/e1000.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  int __retres;
  int ldv_11_line;
  void *ldv_11_data;
  enum irqreturn (*ldv_11_thread)(int , void *);
  int tmp_0;
  
#line 1432 
  enum irqreturn (*ldv_11_callback)(int , void *) = & ldv_emg_wrapper_e1000_test_intr_2;
  
#line 1437 
  tmp_0 = ldv_undef_int();
  
#line 1437 
  if (tmp_0 != 0) {
    
#line 1439 
    ldv_11_line = (int)arg0;
    
#line 1440 
    ldv_11_callback = arg1;
    
#line 1441 
    ldv_11_thread = (enum irqreturn (*)(int , void *))0;
    
#line 1442 
    ldv_11_data = arg4;
    
#line 1446 
    ldv_dispatch_irq_register_11_3(ldv_11_line,ldv_11_callback,ldv_11_thread,ldv_11_data);
    
#line 1450 
    __retres = 0;
    
#line 1450 
    goto return_label;
  }
  else {
    int tmp;
    
#line 1457 
    tmp = ldv_undef_int_negative();
    
#line 1457 
    __retres = tmp;
    
#line 1457 
    goto return_label;
  }
  return_label: 
#line 1437 
                return __retres;
}


