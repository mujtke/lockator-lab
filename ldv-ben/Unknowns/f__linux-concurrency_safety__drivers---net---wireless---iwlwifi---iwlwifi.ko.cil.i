/* Generated by Frama-C */

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef signed char s8;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned char u8;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned short u16;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef int s32;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned int u32;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef long long s64;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __le16;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u16 __be16;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __le32;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __be32;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u32 __wsum;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 __kernel_dev_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_dev_t dev_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned short umode_t;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_pid_t pid_t;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef _Bool bool;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_uid32_t uid_t;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_gid32_t gid_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_loff_t loff_t;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_size_t size_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __kernel_time_t time_t;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __s32 int32_t;

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u8 uint8_t;

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u32 uint32_t;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef __u64 uint64_t;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long sector_t;

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned long blkcnt_t;

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 dma_addr_t;

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int gfp_t;

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int fmode_t;

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef unsigned int oom_flags_t;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef u64 phys_addr_t;

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef phys_addr_t resource_size_t;

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;

#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};

#line 188 
struct hlist_node;

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_9 {
   unsigned int a ;
   unsigned int b ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct __anonstruct_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base1 : 8 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) type : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) s : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) dpl : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) p : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(4))) limit : 4 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) avl : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) g : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) base2 : 8 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
union __anonunion_8 {
   struct __anonstruct_9 __anonCompField___anonunion_8_4 ;
   struct __anonstruct_10 __anonCompField___anonunion_8_5 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_8 __anonCompField_desc_struct_6 ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};

#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;

#line 361 
struct page;

#line 361  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;

#line 372 
struct file;

#line 385 
struct seq_file;

#line 423 
struct thread_struct;

#line 425 
struct mm_struct;

#line 426 
struct task_struct;

#line 427 
struct cpumask;

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dynamic_debug.h"
struct device;

#line 54 
struct net_device;

#line 420  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct file_operations;

#line 432 
struct completion;

#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct timespec;

#line 103 
struct compat_timespec;

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
union __anonunion_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_15 __anonCompField_restart_block_7 ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
union __anonunion_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_19 __anonCompField_math_emu_info_8 ;
};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;

#line 652  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/paravirt.h"
struct static_key;

#line 260  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_29 {
   u64 rip ;
   u64 rdp ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_28 {
   struct __anonstruct_29 __anonCompField___anonunion_28_12 ;
   struct __anonstruct_30 __anonCompField___anonunion_28_13 ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union __anonunion_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_28 __anonCompField_fxregs_state_14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_31 __anonCompField_fxregs_state_15 ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
   union fpregs_state state ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct seq_operations;

#line 369 
struct perf_event;

#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   struct fpu fpu ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
typedef int pao_T__;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
struct lockdep_map;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};

#line 28  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(13))) class_idx : 13 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_context : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) trylock : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) read : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) check : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardirqs_off : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(12))) references : 12 ;
   unsigned int pin_count ;
};

#line 546  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct __anonstruct_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
union __anonunion_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct_35 __anonCompField___anonunion_34_17 ;
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_34 __anonCompField_spinlock_18 ;
};

#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct jump_entry;

#line 59 
struct static_key_mod;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
   struct jump_entry *entries ;
   struct static_key_mod *next ;
};

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct mutex;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;

#line 33 
struct inode;

#line 34 
struct dentry;

#line 35 
struct user_namespace;

#line 250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/capability.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_46 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_46 seqlock_t;

#line 598  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};

#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;

#line 1170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugobjects.h"
union ktime {
   s64 tv64 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ktime.h"
typedef union ktime ktime_t;

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct notifier_block;

#line 1120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_47 {
   unsigned long bits[16U] ;
};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_47 nodemask_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};

#line 39 
struct rw_semaphore;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/osq_lock.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rwsem.h"
struct vm_area_struct;

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};

#line 238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct hrtimer;

#line 239 
enum hrtimer_restart;

#line 837  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/sysctl.h"
struct ctl_table;

#line 838 
struct nsproxy;

#line 839 
struct ctl_table_root;

#line 840 
struct ctl_table_header;

#line 841 
struct ctl_dir;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct __anonstruct_49 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
union __anonunion_48 {
   struct __anonstruct_49 __anonCompField___anonunion_48_19 ;
   struct callback_head rcu ;
};

#line 122 
struct ctl_table_set;

#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_48 __anonCompField_ctl_table_header_20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};

#line 154  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *, struct nsproxy *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
struct workqueue_struct;

#line 260 
struct work_struct;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
enum ldv_11789 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_STATIC_BIT = 4,
    WORK_STRUCT_COLOR_SHIFT = 5,
    WORK_STRUCT_COLOR_BITS = 4,
    WORK_STRUCT_PENDING = 1,
    WORK_STRUCT_DELAYED = 2,
    WORK_STRUCT_PWQ = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_STRUCT_STATIC = 16,
    WORK_NR_COLORS = 15,
    WORK_NO_COLOR = 15,
    WORK_CPU_UNBOUND = 8192,
    WORK_STRUCT_FLAG_BITS = 9,
    WORK_OFFQ_FLAG_BASE = 5,
    __WORK_OFFQ_CANCELING = 5,
    WORK_OFFQ_CANCELING = 32,
    WORK_OFFQ_FLAG_BITS = 1,
    WORK_OFFQ_POOL_SHIFT = 6,
    WORK_OFFQ_LEFT = 58,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 511,
    WORK_STRUCT_WQ_DATA_MASK = -512,
    WORK_STRUCT_NO_POOL = 137438953408,
    WORK_BUSY_PENDING = 1,
    WORK_BUSY_RUNNING = 2,
    WORKER_DESC_LEN = 24
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};

#line 66 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_55 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct __anonstruct_56 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
union __anonunion_54 {
   struct __anonstruct_55 __anonCompField___anonunion_54_23 ;
   struct __anonstruct_56 __anonCompField___anonunion_54_24 ;
};

#line 73 
struct uprobe;

#line 73 
struct return_instance;

#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_54 __anonCompField_uprobe_task_25 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct xol_area;

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct ldt_struct;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_57 {
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_57 mm_context_t;

#line 27 
struct address_space;

#line 28 
struct mem_cgroup;

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page *);

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_58 {
   struct address_space *mapping ;
   void *s_mem ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_60 {
   unsigned long index ;
   void *freelist ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_64 {
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) inuse : 16 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(15))) objects : 15 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) frozen : 1 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_63 {
   atomic_t _mapcount ;
   struct __anonstruct_64 __anonCompField___anonunion_63_28 ;
   int units ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_62 {
   union __anonunion_63 __anonCompField___anonstruct_62_29 ;
   atomic_t _count ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_61 {
   unsigned long counters ;
   struct __anonstruct_62 __anonCompField___anonunion_61_30 ;
   unsigned int active ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_59 {
   union __anonunion_60 __anonCompField___anonstruct_59_27 ;
   union __anonunion_61 __anonCompField___anonstruct_59_31 ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_66 {
   struct page *next ;
   int pages ;
   int pobjects ;
};

#line 32 
struct slab;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_67 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_65 {
   struct list_head lru ;
   struct __anonstruct_66 __anonCompField___anonunion_65_33 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct_67 __anonCompField___anonunion_65_34 ;
   pgtable_t pmd_huge_pte ;
};

#line 32 
struct kmem_cache;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
union __anonunion_68 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion_58 __anonCompField_page_26 ;
   struct __anonstruct_59 __anonCompField_page_32 ;
   union __anonunion_65 __anonCompField_page_35 ;
   union __anonunion_68 __anonCompField_page_36 ;
   struct mem_cgroup *mem_cgroup ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct __anonstruct_shared_69 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};

#line 257 
struct anon_vma;

#line 257 
struct vm_operations_struct;

#line 257 
struct mempolicy;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_69 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};

#line 331  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};

#line 357 
struct kioctx_table;

#line 358 
struct linux_binfmt;

#line 358 
struct mmu_notifier_mm;

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};

#line 4  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;

#line 14 
struct llist_node;

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/x86_init.h"
struct pci_dev;

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_message {
   int event ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
typedef struct pm_message pm_message_t;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};

#line 320 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};

#line 327 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};

#line 335 
struct wakeup_source;

#line 336 
struct wake_irq;

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};

#line 553 
struct dev_pm_qos;

#line 553  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) can_wakeup : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) async_suspend : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_prepared : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_noirq_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_late_suspended : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_children : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) early_init : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) direct_complete : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_path : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) disable_depth : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) idle_notification : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) request_pending : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) deferred_resume : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_auto : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_callbacks : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_safe : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) use_autosuspend : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) timer_autosuspends : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};

#line 615  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/topology.h"
struct pci_bus;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/xen/features.h"
struct bio_vec;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sem_undo_list;

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/shm.h"
struct user_struct;

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;

#line 25 
struct siginfo;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int );

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};

#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;

#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};

#line 443 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
};

#line 450 
struct pid_namespace;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};

#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp_filter;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rtmutex.h"
struct rt_mutex_waiter;

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};

#line 50 
struct hrtimer_clock_base;

#line 51 
struct hrtimer_cpu_base;

#line 60 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_hrtirq : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hres_active : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};

#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array_ptr;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};

#line 31  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef int32_t key_serial_t;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
typedef uint32_t key_perm_t;

#line 35 
struct key;

#line 36 
struct signal_struct;

#line 37 
struct cred;

#line 38 
struct key_type;

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};

#line 123 
struct key_user;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_180 {
   time_t expiry ;
   time_t revoked_at ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct __anonstruct_182 {
   struct key_type *type ;
   char *description ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct_182 __anonCompField___anonunion_181_49 ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
union __anonunion_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_179 __anonCompField_key_47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_180 __anonCompField_key_48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_181 __anonCompField_key_50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion_184 __anonCompField_key_51 ;
};

#line 358 
struct audit_context;

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
union __anonunion_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_186 __anonCompField_idr_layer_52 ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};

#line 153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};

#line 185 
struct percpu_ref;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref *);

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) force_atomic : 1 ;
   struct callback_head rcu ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup;

#line 28 
struct cgroup_root;

#line 29 
struct cgroup_subsys;

#line 30 
struct cgroup_taskset;

#line 31 
struct kernfs_node;

#line 32 
struct kernfs_ops;

#line 33 
struct kernfs_open_file;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};

#line 124  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};

#line 270 
struct kernfs_root;

#line 270  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_subsys_state *, struct cgroup_taskset *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct cgroup_subsys_state *, struct cgroup_subsys_state *, struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct futex_pi_state;

#line 129 
struct robust_list_head;

#line 130 
struct bio_list;

#line 131 
struct fs_struct;

#line 132 
struct perf_event_context;

#line 133 
struct blk_plug;

#line 135 
struct nameidata;

#line 188 
struct cfs_rq;

#line 189 
struct task_group;

#line 477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};

#line 516  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};

#line 524  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};

#line 531  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};

#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};

#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};

#line 620 
struct autogroup;

#line 621 
struct tty_struct;

#line 621 
struct taskstats;

#line 621 
struct tty_audit_buf;

#line 621  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_child_subreaper : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};

#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};

#line 845 
struct backing_dev_info;

#line 846 
struct reclaim_state;

#line 847  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};

#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};

#line 909  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};

#line 1138 
struct io_context;

#line 1172 
struct pipe_inode_info;

#line 1173 
struct uts_namespace;

#line 1174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};

#line 1181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};

#line 1206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};

#line 1241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};

#line 1273 
struct rt_rq;

#line 1273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};

#line 1289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};

#line 1355  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) may_oom : 1 ;
};

#line 1779 
struct sched_class;

#line 1779 
struct files_struct;

#line 1779 
struct compat_robust_list_head;

#line 1779 
struct numa_group;

#line 1779 
struct ftrace_ret_stack;

#line 1779  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_execve : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) in_iowait : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_reset_on_fork : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_contributes_to_load : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sched_migrated : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) memcg_kmem_skip_account : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct thread_struct thread ;
};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
union __anonunion_203 {
   struct iovec const *iov ;
   struct kvec const *kvec ;
   struct bio_vec const *bvec ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_203 __anonCompField_iov_iter_54 ;
   unsigned long nr_segs ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};

#line 38 
struct kiocb;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/asm-generic/fcntl.h"
enum ldv_17330 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
typedef enum ldv_17330 socket_state;

#line 55 
struct net;

#line 72 
struct fasync_struct;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct sock;

#line 93 
struct proto_ops;

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int ) ;
   int (*getname)(struct socket *, struct sockaddr *, int *, int ) ;
   unsigned int (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/checksum_64.h"
struct in6_addr;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct sk_buff;

#line 176 
struct iattr;

#line 177 
struct super_block;

#line 178 
struct file_system_type;

#line 179 
struct kernfs_open_node;

#line 180 
struct kernfs_iattrs;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/checksum.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
union __anonunion_206 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};

#line 96  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_206 __anonCompField_kernfs_node_57 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root *, int *, char *) ;
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char const *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char const *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};

#line 477 
struct kobject;

#line 478 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};

#line 484  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock *) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct bin_attribute;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/stat.h"
struct attribute {
   char const *name ;
   umode_t mode ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char const *, size_t ) ;
};

#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset;

#line 52 
struct kobj_type;

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_initialized : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_in_sysfs : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_add_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_remove_uevent_sent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) uevent_suppress : 1 ;
};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject *) ;
   void const *(*namespace)(struct kobject *) ;
};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const filter)(struct kset *, struct kobject *) ;
   char const *(* const name)(struct kset *, struct kobject *) ;
   int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};

#line 223 
struct klist_node;

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};

#line 67 
struct path;

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};

#line 222 
struct pinctrl;

#line 223 
struct pinctrl_state;

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dma_map_ops;

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/device.h"
struct device_driver;

#line 16 
struct driver_private;

#line 17 
struct class;

#line 18 
struct subsys_private;

#line 19 
struct bus_type;

#line 20 
struct device_node;

#line 21 
struct fwnode_handle;

#line 22 
struct iommu_ops;

#line 23 
struct iommu_group;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute;

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops const *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};

#line 139 
struct device_type;

#line 197 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};

#line 203 
struct of_device_id;

#line 203 
struct acpi_device_id;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};

#line 353 
struct class_attribute;

#line 353  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device *) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};

#line 446  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *, struct class_attribute *, char *) ;
   ssize_t (*store)(struct class *, struct class_attribute *, char const *, size_t ) ;
};

#line 514  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops const *pm ;
};

#line 542  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *, struct device_attribute *, char *) ;
   ssize_t (*store)(struct device *, struct device_attribute *, char const *, size_t ) ;
};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};

#line 684 
struct dma_coherent_mem;

#line 684 
struct cma;

#line 684  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline_disabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) offline : 1 ;
};

#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) active : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) autosleep_enabled : 1 ;
};

#line 1283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};

#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page_ext.h"
struct file_ra_state;

#line 65 
struct writeback_control;

#line 66 
struct bdi_writeback;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*fault)(struct vm_area_struct *, struct vm_fault *) ;
   void (*map_pages)(struct vm_area_struct *, struct vm_fault *) ;
   int (*page_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*pfn_mkwrite)(struct vm_area_struct *, struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char const *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};

#line 2291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , struct dma_attrs *) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , struct dma_attrs *) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , struct dma_attrs *) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , struct dma_attrs *) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device *, dma_addr_t ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   int (*set_dma_mask)(struct device *, u64 ) ;
   int is_phys ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
typedef u64 netdev_features_t;

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
union __anonunion_in6_u_207 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_207 in6_u ;
};

#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buf_operations;

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations const *ops ;
   unsigned int flags ;
   unsigned long private ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct napi_struct;

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
enum ldv_22503 {
    BRNF_PROTO_UNCHANGED = 0,
    BRNF_PROTO_8021Q = 1,
    BRNF_PROTO_PPPOE = 2
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_212 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_213 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   enum ldv_22503 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) orig_proto : 8 ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion_212 __anonCompField_nf_bridge_info_61 ;
   union __anonunion_213 __anonCompField_nf_bridge_info_62 ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_216 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_215 {
   u64 v64 ;
   struct __anonstruct_216 __anonCompField___anonunion_215_63 ;
};

#line 404  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_215 __anonCompField_skb_mstamp_64 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_219 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_218 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_219 __anonCompField___anonstruct_218_65 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_217 {
   struct __anonstruct_218 __anonCompField___anonunion_217_66 ;
   struct rb_node rbnode ;
};

#line 457 
struct sec_path;

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct __anonstruct_221 {
   __u16 csum_start ;
   __u16 csum_offset ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_220 {
   __wsum csum ;
   struct __anonstruct_221 __anonCompField___anonunion_220_68 ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_222 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_223 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
union __anonunion_224 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_217 __anonCompField_sk_buff_67 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cloned : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nohdr : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) fclone : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) peeked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) head_frag : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pkt_type : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pfmemalloc : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_df : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) nfctinfo : 3 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) nf_trace : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ip_summed : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ooo_okay : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) l4_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) sw_hash : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wifi_acked : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_fcs : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encapsulation : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) encap_hdr_csum : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_valid : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_complete_sw : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) csum_level : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) csum_bad : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) ndisc_nodetype : 2 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ipvs_property : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inner_protocol_type : 1 ;
   __u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion_220 __anonCompField_sk_buff_69 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_222 __anonCompField_sk_buff_70 ;
   __u32 secmark ;
   union __anonunion_223 __anonCompField_sk_buff_71 ;
   union __anonunion_224 __anonCompField_sk_buff_72 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};

#line 718 
struct dst_entry;

#line 1204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};

#line 1229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};

#line 1354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};

#line 1435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};

#line 1182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_265 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};

#line 43  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_265 sync_serial_settings;

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_266 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_266 te1_settings;

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_267 {
   unsigned short encoding ;
   unsigned short parity ;
};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_267 raw_hdlc_proto;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_268 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_268 fr_proto;

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_269 {
   unsigned int dlci ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_269 fr_proto_pvc;

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_270 {
   unsigned int dlci ;
   char master[16U] ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_270 fr_proto_pvc_info;

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_271 {
   unsigned int interval ;
   unsigned int timeout ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_271 cisco_proto;

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_272 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};

#line 177  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_272 ifs_ifsu ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_273 {
   char ifrn_name[16U] ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_274 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};

#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_273 ifr_ifrn ;
   union __anonunion_ifr_ifru_274 ifr_ifru ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_node;

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct __anonstruct_279 {
   spinlock_t lock ;
   int count ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
union __anonunion_278 {
   struct __anonstruct_279 __anonCompField___anonunion_278_74 ;
};

#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_278 __anonCompField_lockref_75 ;
};

#line 50  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct vfsmount;

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct __anonstruct_281 {
   u32 hash ;
   u32 len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
union __anonunion_280 {
   struct __anonstruct_281 __anonCompField___anonunion_280_76 ;
   u64 hash_len ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockref.h"
struct qstr {
   union __anonunion_280 __anonCompField_qstr_77 ;
   unsigned char const *name ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations;

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
union __anonunion_d_u_282 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_282 d_u ;
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry const *, struct qstr *) ;
   int (*d_compare)(struct dentry const *, struct dentry const *, unsigned int , char const *, struct qstr const *) ;
   int (*d_delete)(struct dentry const *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct dentry *, bool ) ;
   struct inode *(*d_select_inode)(struct dentry *, unsigned int ) ;
};

#line 586  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};

#line 27  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};

#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct __anonstruct_286 {
   struct radix_tree_node *parent ;
   void *private_data ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
union __anonunion_285 {
   struct __anonstruct_286 __anonCompField___anonunion_285_78 ;
   struct callback_head callback_head ;
};

#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_285 __anonCompField_radix_tree_node_79 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
};

#line 47 
struct block_device;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/fs.h"
struct export_operations;

#line 62 
struct kstatfs;

#line 63 
struct swap_info_struct;

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dqblk_xfs.h"
struct dquot;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
struct __anonstruct_kprojid_t_290 {
   projid_t val ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_290 kprojid_t;

#line 166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
typedef long long qsize_t;

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
union __anonunion_291 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kqid {
   union __anonunion_291 __anonCompField_kqid_81 ;
   enum quota_type type ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};

#line 206 
struct quota_format_type;

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
};

#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};

#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};

#line 394  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};

#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};

#line 432  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};

#line 496  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops const *ops[3U] ;
};

#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
};

#line 366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *, loff_t ) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};

#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};

#line 443 
struct request_queue;

#line 444 
struct hd_struct;

#line 444 
struct gendisk;

#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};

#line 560 
struct posix_acl;

#line 561 
struct inode_operations;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_294 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_295 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};

#line 561 
struct file_lock_context;

#line 561 
struct cdev;

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_296 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};

#line 561  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_294 __anonCompField_inode_82 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_295 __anonCompField_inode_83 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_296 __anonCompField_inode_84 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};

#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};

#line 815  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
union __anonunion_f_u_297 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};

#line 838  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file {
   union __anonunion_f_u_297 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};

#line 923  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
typedef void *fl_owner_t;

#line 924 
struct file_lock;

#line 925  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};

#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock *, struct file_lock *) ;
   unsigned long (*lm_owner_key)(struct file_lock *) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};

#line 952 
struct nlm_lockowner;

#line 953  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_299 {
   struct list_head link ;
   int state ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_298 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_299 afs ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_298 fl_u ;
};

#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};

#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};

#line 1256  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};

#line 1287 
struct super_operations;

#line 1287 
struct xattr_handler;

#line 1287 
struct mtd_info;

#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};

#line 1526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};

#line 1540 
struct dir_context;

#line 1565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char const *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};

#line 1572  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char const *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   unsigned int (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*mremap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb *, int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
};

#line 1633  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char const *(*follow_link)(struct dentry *, void **) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   void (*put_link)(struct inode *, void *) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char const *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *) ;
   int (*rename2)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct vfsmount *, struct dentry *, struct kstat *) ;
   int (*setxattr)(struct dentry *, char const *, void const *, size_t , int ) ;
   ssize_t (*getxattr)(struct dentry *, char const *, void *, size_t ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*removexattr)(struct dentry *, char const *) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t , int *) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
};

#line 1687  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char const *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};

#line 1926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type *, int , char const *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;

#line 45  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};

#line 276  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};

#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};

#line 715  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};

#line 189  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 267  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 293  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};

#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};

#line 438  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};

#line 503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};

#line 605  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};

#line 637  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};

#line 679  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};

#line 712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};

#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};

#line 748  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};

#line 759  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};

#line 778  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};

#line 828  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};

#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};

#line 1007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};

#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device *, struct ethtool_cmd *) ;
   int (*set_settings)(struct net_device *, struct ethtool_cmd *) ;
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 const *, u8 const *, u8 const ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable const *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable const *, void const *) ;
};

#line 235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct prot_inuse;

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct u64_stats_sync {
   
};

#line 146  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};

#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};

#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};

#line 118 
struct proc_dir_entry;

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};

#line 26  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct ipv4_devconf;

#line 185 
struct fib_rules_ops;

#line 186 
struct fib_table;

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};

#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};

#line 29 
struct inet_peer_base;

#line 29 
struct xt_table;

#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};

#line 113 
struct neighbour;

#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const *) ;
   unsigned int (*mtu)(struct dst_entry const *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const *, struct sk_buff *, void const *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct ipv6_devconf;

#line 39 
struct rt6_info;

#line 39 
struct rt6_statistics;

#line 39 
struct fib6_table;

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};

#line 20 
struct sctp_mib;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct nf_logger;

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct ebt_table;

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node;

#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};

#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};

#line 49  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};

#line 72 
struct ip_conntrack_stat;

#line 72 
struct nf_ct_event_notifier;

#line 72 
struct nf_exp_event_notifier;

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};

#line 114 
struct nft_af_info;

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};

#line 508  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/xfrm.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;

#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};

#line 88 
struct mpls_route;

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct proc_ns_operations;

#line 17  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations const *ops ;
   unsigned int inum ;
};

#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net_generic;

#line 12 
struct netns_ipvs;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_330 {
   struct net *net ;
};

#line 241  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_330 possible_net_t;

#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;

#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};

#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};

#line 221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};

#line 652 
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
};

#line 659  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
typedef u32 phandle;

#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};

#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/of.h"
struct device_node {
   char const *name ;
   char const *type ;
   phandle phandle ;
   char const *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mii.h"
enum ldv_28502 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
};

#line 80  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
typedef enum ldv_28502 phy_interface_t;

#line 126 
enum ldv_28555 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};

#line 133 
struct phy_device;

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct mii_bus {
   char const *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28555 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};

#line 214 
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};

#line 323 
struct phy_driver;

#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device *) ;
};

#line 429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd_indirect)(struct phy_device *, int , int , int ) ;
   void (*write_mmd_indirect)(struct phy_device *, int , int , int , u32 ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   struct device_driver driver ;
};

#line 803  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};

#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};

#line 84 
struct packet_type;

#line 85 
struct dsa_switch;

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};

#line 123 
struct dsa_switch_driver;

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device *, int ) ;
   int (*setup)(struct dsa_switch *) ;
   int (*set_addr)(struct dsa_switch *, u8 *) ;
   u32 (*get_phy_flags)(struct dsa_switch *, int ) ;
   int (*phy_read)(struct dsa_switch *, int , int ) ;
   int (*phy_write)(struct dsa_switch *, int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch *) ;
   void (*adjust_link)(struct dsa_switch *, int , struct phy_device *) ;
   void (*fixed_link_update)(struct dsa_switch *, int , struct fixed_phy_status *) ;
   void (*get_strings)(struct dsa_switch *, int , uint8_t *) ;
   void (*get_ethtool_stats)(struct dsa_switch *, int , uint64_t *) ;
   int (*get_sset_count)(struct dsa_switch *) ;
   void (*get_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*set_wol)(struct dsa_switch *, int , struct ethtool_wolinfo *) ;
   int (*suspend)(struct dsa_switch *) ;
   int (*resume)(struct dsa_switch *) ;
   int (*port_enable)(struct dsa_switch *, int , struct phy_device *) ;
   void (*port_disable)(struct dsa_switch *, int , struct phy_device *) ;
   int (*set_eee)(struct dsa_switch *, int , struct phy_device *, struct ethtool_eee *) ;
   int (*get_eee)(struct dsa_switch *, int , struct ethtool_eee *) ;
   int (*get_temp)(struct dsa_switch *, int *) ;
   int (*get_temp_limit)(struct dsa_switch *, int *) ;
   int (*set_temp_limit)(struct dsa_switch *, int ) ;
   int (*get_temp_alarm)(struct dsa_switch *, bool *) ;
   int (*get_eeprom_len)(struct dsa_switch *) ;
   int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *) ;
   int (*get_regs_len)(struct dsa_switch *, int ) ;
   void (*get_regs)(struct dsa_switch *, int , struct ethtool_regs *, void *) ;
   int (*port_join_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_leave_bridge)(struct dsa_switch *, int , u32 ) ;
   int (*port_stp_update)(struct dsa_switch *, int , u8 ) ;
   int (*fdb_add)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_del)(struct dsa_switch *, int , unsigned char const *, u16 ) ;
   int (*fdb_getnext)(struct dsa_switch *, int , unsigned char *, bool *) ;
};

#line 320  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};

#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};

#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};

#line 202  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
};

#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};

#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};

#line 1628  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct mnt_namespace;

#line 1629 
struct ipc_namespace;

#line 1630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};

#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};

#line 106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};

#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/if_bonding.h"
struct netpoll_info;

#line 119 
struct wireless_dev;

#line 120 
struct wpan_dev;

#line 121 
struct mpls_dev;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;

#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};

#line 190 
struct neigh_parms;

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};

#line 245  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void const *, void const *, unsigned int ) ;
   int (*parse)(struct sk_buff const *, unsigned char *) ;
   int (*cache)(struct neighbour const *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device const *, unsigned char const *) ;
};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct *, int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};

#line 340 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};

#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;

#line 389  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

#line 537 
struct Qdisc;

#line 537  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};

#line 619  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};

#line 631  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};

#line 683  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};

#line 719  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};

#line 730  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};

#line 741  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};

#line 757  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};

#line 770  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, void *, u16 (*)(struct net_device *, struct sk_buff *)) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_busy_poll)(struct napi_struct *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff const *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 , u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char const *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int ) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_add_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device *, sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *, struct net_device *, void *) ;
   int (*ndo_get_lock_subclass)(struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device const *) ;
};

#line 1243 
enum ldv_30267 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};

#line 1252 
enum ldv_30268 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_adj_list_343 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_344 {
   struct list_head upper ;
   struct list_head lower ;
};

#line 1257 
struct iw_handler_def;

#line 1257 
struct iw_public_data;

#line 1257 
struct switchdev_ops;

#line 1257 
struct vlan_info;

#line 1257 
struct tipc_bearer;

#line 1257 
struct in_device;

#line 1257 
struct dn_dev;

#line 1257 
struct inet6_dev;

#line 1257 
struct tcf_proto;

#line 1257 
struct cpu_rmap;

#line 1257 
struct pcpu_lstats;

#line 1257 
struct pcpu_sw_netstats;

#line 1257 
struct pcpu_dstats;

#line 1257 
struct pcpu_vstats;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
union __anonunion_345 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};

#line 1257 
struct garp_port;

#line 1257 
struct mrp_port;

#line 1257 
struct rtnl_link_ops;

#line 1257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_343 adj_list ;
   struct __anonstruct_all_adj_list_344 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct switchdev_ops const *switchdev_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_30267 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reg_state : 8 ;
   bool dismantle ;
   enum ldv_30268 __attribute__((__FRAMA_C_BITFIELD_SIZE__(16))) rtnl_link_state : 16 ;
   void (*destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_345 __anonCompField_net_device_94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};

#line 1978  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *) ;
   bool (*id_match)(struct packet_type *, struct sock *) ;
   void *af_packet_priv ;
   struct list_head list ;
};

#line 2025  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};

#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NUM_NL80211_IFTYPES = 12,
    NL80211_IFTYPE_MAX = 11
};

#line 2431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
};

#line 2484 
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
};

#line 2491 
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
};

#line 2607 
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
};

#line 2618 
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
};

#line 2650 
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
};

#line 2668 
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
};

#line 3734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};

#line 3871  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};

#line 3883  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};

#line 4131 
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
};

#line 4153  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};

#line 4581 
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
};

#line 4587  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/nl80211.h"
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};

#line 205 
struct wiphy;

#line 206 
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
};

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/regulatory.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};

#line 269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};

#line 289  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};

#line 305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};

#line 387  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};

#line 608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};

#line 671  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct mac_address {
   u8 addr[6U] ;
};

#line 1395  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};

#line 1491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};

#line 1499  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   u32 delay ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   struct ieee80211_channel *channels[0U] ;
};

#line 1561 
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
};

#line 1766  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 const *ssid ;
   u8 const *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};

#line 1814  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const *bssid ;
   u8 const *bssid_hint ;
   u8 const *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};

#line 1916  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_pkt_pattern {
   u8 const *mask ;
   u8 const *pattern ;
   int pattern_len ;
   int pkt_offset ;
};

#line 1933  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const *wake_data ;
   u8 const *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};

#line 1968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
   struct cfg80211_sched_scan_request *nd_config ;
};

#line 2736  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};

#line 2797  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit const *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};

#line 2869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};

#line 2885  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature const *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};

#line 2910  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   int max_nd_match_sets ;
   struct wiphy_wowlan_tcp_support const *tcp ;
};

#line 2935  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};

#line 2960  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy *, struct wireless_dev *, void const *, int ) ;
};

#line 2981  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes const *mgmt_stypes ;
   struct ieee80211_iface_combination const *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[1U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support const *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const *extended_capabilities ;
   u8 const *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy *, struct regulatory_request *) ;
   struct ieee80211_regdomain const *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap const *ht_capa_mod_mask ;
   struct ieee80211_vht_cap const *vht_capa_mod_mask ;
   possible_net_t _net ;
   struct iw_handler_def const *wext ;
   struct wiphy_coalesce_support const *coalesce ;
   struct wiphy_vendor_command const *vendor_commands ;
   struct nl80211_vendor_cmd_info const *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};

#line 3369 
struct cfg80211_conn;

#line 3370 
struct cfg80211_internal_bss;

#line 3371 
struct cfg80211_cached_keys;

#line 3372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct __anonstruct_wext_351 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};

#line 3372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_351 wext ;
};

#line 1174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
enum ieee80211_smps_mode {
    IEEE80211_SMPS_AUTOMATIC = 0,
    IEEE80211_SMPS_OFF = 1,
    IEEE80211_SMPS_STATIC = 2,
    IEEE80211_SMPS_DYNAMIC = 3,
    IEEE80211_SMPS_NUM_MODES = 4
};

#line 1547  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/mac80211.h"
struct ieee80211_cipher_scheme {
   u32 cipher ;
   u16 iftype ;
   u8 hdr_len ;
   u8 pn_len ;
   u8 pn_off ;
   u8 key_idx_off ;
   u8 key_idx_mask ;
   u8 key_idx_shift ;
   u8 mic_len ;
};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-modparams.h"
struct iwl_mod_params;

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-modparams.h"
struct iwl_mod_params {
   int sw_crypto ;
   unsigned int disable_11n ;
   int amsdu_size_8K ;
   bool restart_fw ;
   bool bt_coex_active ;
   int led_mode ;
   bool power_save ;
   int power_level ;
   u32 debug_level ;
   int ant_coupling ;
   char *nvm_file ;
   bool uapsd_disable ;
   bool d0i3_disable ;
   bool lar_disable ;
   bool fw_monitor ;
};

#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.h"
enum iwl_device_family {
    IWL_DEVICE_FAMILY_UNDEFINED = 0,
    IWL_DEVICE_FAMILY_1000 = 1,
    IWL_DEVICE_FAMILY_100 = 2,
    IWL_DEVICE_FAMILY_2000 = 3,
    IWL_DEVICE_FAMILY_2030 = 4,
    IWL_DEVICE_FAMILY_105 = 5,
    IWL_DEVICE_FAMILY_135 = 6,
    IWL_DEVICE_FAMILY_5000 = 7,
    IWL_DEVICE_FAMILY_5150 = 8,
    IWL_DEVICE_FAMILY_6000 = 9,
    IWL_DEVICE_FAMILY_6000i = 10,
    IWL_DEVICE_FAMILY_6005 = 11,
    IWL_DEVICE_FAMILY_6030 = 12,
    IWL_DEVICE_FAMILY_6050 = 13,
    IWL_DEVICE_FAMILY_6150 = 14,
    IWL_DEVICE_FAMILY_7000 = 15,
    IWL_DEVICE_FAMILY_8000 = 16
};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
enum iwl_led_mode {
    IWL_LED_DEFAULT = 0,
    IWL_LED_RF_STATE = 1,
    IWL_LED_BLINK = 2,
    IWL_LED_DISABLE = 3
};

#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_base_params {
   int eeprom_size ;
   int num_of_queues ;
   u32 pll_cfg_val ;
   u16 const max_ll_items ;
   bool const shadow_ram_support ;
   u16 led_compensation ;
   unsigned int wd_timeout ;
   u32 max_event_log_size ;
   bool const shadow_reg_enable ;
   bool const pcie_l1_allowed ;
   bool const apmg_wake_up_wa ;
   bool const scd_chain_ext_wa ;
};

#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_ht_params {
   enum ieee80211_smps_mode smps_mode ;
   bool const ht_greenfield_support ;
   bool const stbc ;
   bool const ldpc ;
   bool use_rts_for_aggregation ;
   u8 ht40_bands ;
};

#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_tt_tx_backoff {
   s32 temperature ;
   u32 backoff ;
};

#line 206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_tt_params {
   s32 ct_kill_entry ;
   s32 ct_kill_exit ;
   u32 ct_kill_duration ;
   s32 dynamic_smps_entry ;
   s32 dynamic_smps_exit ;
   s32 tx_protection_entry ;
   s32 tx_protection_exit ;
   struct iwl_tt_tx_backoff tx_backoff[6U] ;
   bool support_ct_kill ;
   bool support_dynamic_smps ;
   bool support_tx_protection ;
   bool support_tx_backoff ;
};

#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_eeprom_params {
   u8 const regulatory_bands[7U] ;
   bool enhanced_txpower ;
};

#line 262  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_pwr_tx_backoff {
   u32 pwr ;
   u32 backoff ;
};

#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_cfg {
   char const *name ;
   char const *fw_name_pre ;
   unsigned int const ucode_api_max ;
   unsigned int const ucode_api_ok ;
   unsigned int const ucode_api_min ;
   enum iwl_device_family const device_family ;
   u32 const max_data_size ;
   u32 const max_inst_size ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   u8 non_shared_ant ;
   bool bt_shared_single_ant ;
   u16 nvm_ver ;
   u16 nvm_calib_ver ;
   struct iwl_base_params const *base_params ;
   struct iwl_ht_params const *ht_params ;
   struct iwl_eeprom_params const *eeprom_params ;
   enum iwl_led_mode led_mode ;
   bool const rx_with_siso_diversity ;
   bool const internal_wimax_coex ;
   bool const host_interrupt_operation_mode ;
   bool high_temp ;
   bool d0i3 ;
   u8 nvm_hw_section_num ;
   bool lp_xtal_workaround ;
   struct iwl_pwr_tx_backoff const *pwr_tx_backoffs ;
   bool no_power_up_nic_in_init ;
   char const *default_nvm_file_B_step ;
   char const *default_nvm_file_C_step ;
   unsigned int max_rx_agg_size ;
   bool disable_dummy_notification ;
   unsigned int max_tx_agg_size ;
   unsigned int max_ht_ampdu_exponent ;
   unsigned int max_vht_ampdu_exponent ;
   u32 const dccm_offset ;
   u32 const dccm_len ;
   u32 const dccm2_offset ;
   u32 const dccm2_len ;
   u32 const smem_offset ;
   u32 const smem_len ;
   struct iwl_tt_params const *thermal_params ;
   bool apmg_not_supported ;
};

#line 300  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_tlv_calib_ctrl {
   __le32 flow_trigger ;
   __le32 event_trigger ;
};

#line 415  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_fw_dbg_reg_op {
   u8 op ;
   u8 reserved[3U] ;
   __le32 addr ;
   __le32 val ;
};

#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_fw_dbg_dest_tlv {
   u8 version ;
   u8 monitor_mode ;
   u8 size_power ;
   u8 reserved ;
   __le32 base_reg ;
   __le32 end_reg ;
   __le32 write_ptr_reg ;
   __le32 wrap_count ;
   u8 base_shift ;
   u8 end_shift ;
   struct iwl_fw_dbg_reg_op reg_ops[0U] ;
};

#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_fw_dbg_conf_hcmd {
   u8 id ;
   u8 reserved ;
   __le16 len ;
   u8 data[0U] ;
};

#line 497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_fw_dbg_trigger_tlv {
   __le32 id ;
   __le32 vif_type ;
   __le32 stop_conf_ids ;
   __le32 stop_delay ;
   u8 mode ;
   u8 start_conf_id ;
   __le16 occurrences ;
   __le32 reserved[2U] ;
   u8 data[0U] ;
};

#line 701  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_fw_dbg_conf_tlv {
   u8 id ;
   u8 usniffer ;
   u8 reserved ;
   u8 num_of_hcmds ;
   struct iwl_fw_dbg_conf_hcmd hcmd ;
};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h"
struct iwl_ucode_capabilities {
   u32 max_probe_length ;
   u32 n_scan_channels ;
   u32 standard_phy_calibration_size ;
   u32 flags ;
   unsigned long _api[1U] ;
   unsigned long _capa[1U] ;
};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw.h"
struct fw_desc {
   void const *data ;
   u32 len ;
   u32 offset ;
};

#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw.h"
struct fw_img {
   struct fw_desc sec[12U] ;
   bool is_dual_cpus ;
};

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw.h"
struct iwl_sf_region {
   u32 addr ;
   u32 size ;
};

#line 152  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw.h"
struct iwl_fw {
   u32 ucode_ver ;
   char fw_version[32U] ;
   struct fw_img img[4U] ;
   struct iwl_ucode_capabilities ucode_capa ;
   bool enhance_sensitivity_table ;
   u32 init_evtlog_ptr ;
   u32 init_evtlog_size ;
   u32 init_errlog_ptr ;
   u32 inst_evtlog_ptr ;
   u32 inst_evtlog_size ;
   u32 inst_errlog_ptr ;
   struct iwl_tlv_calib_ctrl default_calib[4U] ;
   u32 phy_config ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   bool mvm_fw ;
   struct ieee80211_cipher_scheme cs[1U] ;
   u8 human_readable[64U] ;
   u32 sdio_adma_addr ;
   struct iwl_fw_dbg_dest_tlv *dbg_dest_tlv ;
   struct iwl_fw_dbg_conf_tlv *dbg_conf_tlv[32U] ;
   size_t dbg_conf_tlv_len[32U] ;
   struct iwl_fw_dbg_trigger_tlv *dbg_trigger_tlv[12U] ;
   size_t dbg_trigger_tlv_len[12U] ;
   u8 dbg_dest_reg_num ;
};

#line 253 
struct iwl_op_mode;

#line 254 
struct iwl_trans;

#line 255 
struct iwl_device_cmd;

#line 256 
struct iwl_rx_cmd_buffer;

#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw.h"
struct iwl_op_mode_ops {
   struct iwl_op_mode *(*start)(struct iwl_trans *, struct iwl_cfg const *, struct iwl_fw const *, struct dentry *) ;
   void (*stop)(struct iwl_op_mode *) ;
   int (*rx)(struct iwl_op_mode *, struct iwl_rx_cmd_buffer *, struct iwl_device_cmd *) ;
   void (*napi_add)(struct iwl_op_mode *, struct napi_struct *, struct net_device *, int (*)(struct napi_struct *, int ), int ) ;
   void (*queue_full)(struct iwl_op_mode *, int ) ;
   void (*queue_not_full)(struct iwl_op_mode *, int ) ;
   bool (*hw_rf_kill)(struct iwl_op_mode *, bool ) ;
   void (*free_skb)(struct iwl_op_mode *, struct sk_buff *) ;
   void (*nic_error)(struct iwl_op_mode *) ;
   void (*cmd_queue_full)(struct iwl_op_mode *) ;
   void (*nic_config)(struct iwl_op_mode *) ;
   void (*wimax_active)(struct iwl_op_mode *) ;
   int (*enter_d0i3)(struct iwl_op_mode *) ;
   int (*exit_d0i3)(struct iwl_op_mode *) ;
};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
struct iwl_op_mode {
   struct iwl_op_mode_ops const *ops ;
   char op_mode_specific[0U] ;
};

#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
struct iwl_cmd_header {
   u8 cmd ;
   u8 flags ;
   __le16 sequence ;
};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_rx_packet {
   __le32 len_n_flags ;
   struct iwl_cmd_header hdr ;
   u8 data[] ;
};

#line 200  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_device_cmd {
   struct iwl_cmd_header hdr ;
   u8 payload[320U] ;
};

#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_host_cmd {
   void const *data[2U] ;
   struct iwl_rx_packet *resp_pkt ;
   unsigned long _rx_page_addr ;
   u32 _rx_page_order ;
   int handler_status ;
   u32 flags ;
   u16 len[2U] ;
   u8 dataflags[2U] ;
   u8 id ;
};

#line 288  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_rx_cmd_buffer {
   struct page *_page ;
   int _offset ;
   bool _page_stolen ;
   u32 _rx_page_order ;
   unsigned int truesize ;
};

#line 318 
enum iwl_d3_status {
    IWL_D3_STATUS_ALIVE = 0,
    IWL_D3_STATUS_RESET = 1
};

#line 334  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_trans_config {
   struct iwl_op_mode *op_mode ;
   u8 cmd_queue ;
   u8 cmd_fifo ;
   unsigned int cmd_q_wdg_timeout ;
   u8 const *no_reclaim_cmds ;
   unsigned int n_no_reclaim_cmds ;
   bool rx_buf_size_8k ;
   bool bc_table_dword ;
   bool scd_set_active ;
   char const * const *command_names ;
   u32 sdio_adma_addr ;
};

#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_trans_dump_data {
   u32 len ;
   u8 data[] ;
};

#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_trans_txq_scd_cfg {
   u8 fifo ;
   s8 sta_id ;
   u8 tid ;
   bool aggregate ;
   int frame_limit ;
};

#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_trans_ops {
   int (*start_hw)(struct iwl_trans *, bool ) ;
   void (*op_mode_leave)(struct iwl_trans *) ;
   int (*start_fw)(struct iwl_trans *, struct fw_img const *, bool ) ;
   int (*update_sf)(struct iwl_trans *, struct iwl_sf_region *) ;
   void (*fw_alive)(struct iwl_trans *, u32 ) ;
   void (*stop_device)(struct iwl_trans *, bool ) ;
   void (*d3_suspend)(struct iwl_trans *, bool ) ;
   int (*d3_resume)(struct iwl_trans *, enum iwl_d3_status *, bool ) ;
   int (*send_cmd)(struct iwl_trans *, struct iwl_host_cmd *) ;
   int (*tx)(struct iwl_trans *, struct sk_buff *, struct iwl_device_cmd *, int ) ;
   void (*reclaim)(struct iwl_trans *, int , int , struct sk_buff_head *) ;
   void (*txq_enable)(struct iwl_trans *, int , u16 , struct iwl_trans_txq_scd_cfg const *, unsigned int ) ;
   void (*txq_disable)(struct iwl_trans *, int , bool ) ;
   int (*dbgfs_register)(struct iwl_trans *, struct dentry *) ;
   int (*wait_tx_queue_empty)(struct iwl_trans *, u32 ) ;
   void (*freeze_txq_timer)(struct iwl_trans *, unsigned long , bool ) ;
   void (*write8)(struct iwl_trans *, u32 , u8 ) ;
   void (*write32)(struct iwl_trans *, u32 , u32 ) ;
   u32 (*read32)(struct iwl_trans *, u32 ) ;
   u32 (*read_prph)(struct iwl_trans *, u32 ) ;
   void (*write_prph)(struct iwl_trans *, u32 , u32 ) ;
   int (*read_mem)(struct iwl_trans *, u32 , void *, int ) ;
   int (*write_mem)(struct iwl_trans *, u32 , void const *, int ) ;
   void (*configure)(struct iwl_trans *, struct iwl_trans_config const *) ;
   void (*set_pmi)(struct iwl_trans *, bool ) ;
   bool (*grab_nic_access)(struct iwl_trans *, bool , unsigned long *) ;
   void (*release_nic_access)(struct iwl_trans *, unsigned long *) ;
   void (*set_bits_mask)(struct iwl_trans *, u32 , u32 , u32 ) ;
   void (*ref)(struct iwl_trans *) ;
   void (*unref)(struct iwl_trans *) ;
   void (*suspend)(struct iwl_trans *) ;
   void (*resume)(struct iwl_trans *) ;
   struct iwl_trans_dump_data *(*dump_data)(struct iwl_trans *) ;
};

#line 552 
enum iwl_trans_state {
    IWL_TRANS_NO_FW = 0,
    IWL_TRANS_FW_ALIVE = 1
};

#line 557 
enum iwl_d0i3_mode {
    IWL_D0I3_MODE_OFF = 0,
    IWL_D0I3_MODE_ON_IDLE = 1,
    IWL_D0I3_MODE_ON_SUSPEND = 2
};

#line 563  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_trans {
   struct iwl_trans_ops const *ops ;
   struct iwl_op_mode *op_mode ;
   struct iwl_cfg const *cfg ;
   enum iwl_trans_state state ;
   unsigned long status ;
   struct device *dev ;
   u32 hw_rev ;
   u32 hw_id ;
   char hw_id_str[52U] ;
   u8 rx_mpdu_cmd ;
   u8 rx_mpdu_cmd_hdr_size ;
   bool pm_support ;
   bool ltr_enabled ;
   struct kmem_cache *dev_cmd_pool ;
   size_t dev_cmd_headroom ;
   char dev_cmd_pool_name[50U] ;
   struct dentry *dbgfs_dir ;
   struct lockdep_map sync_cmd_lockdep_map ;
   u64 dflt_pwr_limit ;
   struct iwl_fw_dbg_dest_tlv const *dbg_dest_tlv ;
   struct iwl_fw_dbg_conf_tlv const *dbg_conf_tlv[32U] ;
   struct iwl_fw_dbg_trigger_tlv * const *dbg_trigger_tlv ;
   u8 dbg_dest_reg_num ;
   enum iwl_d0i3_mode d0i3_mode ;
   bool wowlan_d0i3 ;
   char trans_specific[0U] ;
};

#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.h"
struct tracepoint;

#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};

#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tracepoint.h"
struct tracepoint {
   char const *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_375 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_377 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_379 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_381 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_383 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_385 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_395 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_397 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_399 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_401 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
union __anonunion___u_435 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
union __anonunion___u_437 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
union __anonunion___u_443 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
union __anonunion___u_445 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct hotplug_slot;

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef int pci_power_t;

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;

#line 138 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;

#line 192  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;

#line 249 
struct pcie_link_state;

#line 250 
struct pci_vpd;

#line 251 
struct pci_sriov;

#line 252 
struct pci_ats;

#line 253 
struct pci_driver;

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
union __anonunion_458 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};

#line 253  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(5))) pme_support : 5 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_interrupt : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) pme_poll : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d1_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d2_support : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d1d2 : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) d3cold_allowed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) mmio_always_on : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) wakeup_prepared : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) runtime_d3cold : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) transparent : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) multifunction : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_busmaster : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) no_64bit_msi : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) block_cfg_access : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_parity_status : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(2))) irq_reroute_variant : 2 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msi_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) msix_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ari_enabled : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) needs_freset : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) state_saved : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_physfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_virtfn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) reset_fn : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_hotplug_bridge : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first_valid : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) __aer_firmware_first : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) broken_intx_masking : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) io_window_1k : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) irq_managed : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group const **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_458 __anonCompField_pci_dev_100 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};

#line 442 
struct pci_ops;

#line 442 
struct msi_controller;

#line 442  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_added : 1 ;
};

#line 565  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};

#line 593  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};

#line 607  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;

#line 617  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_notify)(struct pci_dev *, bool ) ;
   void (*resume)(struct pci_dev *) ;
};

#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const *name ;
   struct pci_device_id const *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id const *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*suspend_late)(struct pci_dev *, pm_message_t ) ;
   int (*resume_early)(struct pci_dev *) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers const *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fh.h"
struct iwl_rb_status {
   __le16 closed_rb_num ;
   __le16 closed_fr_num ;
   __le16 finished_rb_num ;
   __le16 finished_fr_nam ;
   __le32 __unused ;
};

#line 476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fh.h"
struct iwl_tfd_tb {
   __le32 lo ;
   __le16 hi_n_len ;
};

#line 490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fh.h"
struct iwl_tfd {
   u8 __reserved1[3U] ;
   u8 num_tbs ;
   struct iwl_tfd_tb tbs[20U] ;
   __le32 __pad ;
};

#line 559  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fh.h"
struct iwl_rx_mem_buffer {
   dma_addr_t page_dma ;
   struct page *page ;
   struct list_head list ;
};

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct isr_statistics {
   u32 hw ;
   u32 sw ;
   u32 err_code ;
   u32 sch ;
   u32 alive ;
   u32 rfkill ;
   u32 ctkill ;
   u32 wakeup ;
   u32 rx ;
   u32 tx ;
   u32 unhandled ;
};

#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_rxq {
   __le32 *bd ;
   dma_addr_t bd_dma ;
   struct iwl_rx_mem_buffer pool[320U] ;
   struct iwl_rx_mem_buffer *queue[256U] ;
   u32 read ;
   u32 write ;
   u32 free_count ;
   u32 write_actual ;
   struct list_head rx_free ;
   struct list_head rx_used ;
   bool need_update ;
   struct iwl_rb_status *rb_stts ;
   dma_addr_t rb_stts_dma ;
   spinlock_t lock ;
};

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_dma_ptr {
   dma_addr_t dma ;
   void *addr ;
   size_t size ;
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_cmd_meta {
   struct iwl_host_cmd *source ;
   u32 flags ;
};

#line 141  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_queue {
   int write_ptr ;
   int read_ptr ;
   dma_addr_t dma_addr ;
   int n_window ;
   u32 id ;
   int low_mark ;
   int high_mark ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_pcie_txq_entry {
   struct iwl_device_cmd *cmd ;
   struct sk_buff *skb ;
   void const *free_buf ;
   struct iwl_cmd_meta meta ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_pcie_txq_scratch_buf {
   struct iwl_cmd_header hdr ;
   u8 buf[8U] ;
   __le32 scratch ;
};

#line 203 
struct iwl_trans_pcie;

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_txq {
   struct iwl_queue q ;
   struct iwl_tfd *tfds ;
   struct iwl_pcie_txq_scratch_buf *scratchbufs ;
   dma_addr_t scratchbufs_dma ;
   struct iwl_pcie_txq_entry *entries ;
   spinlock_t lock ;
   unsigned long frozen_expiry_remainder ;
   struct timer_list stuck_timer ;
   struct iwl_trans_pcie *trans_pcie ;
   bool need_update ;
   bool frozen ;
   u8 active ;
   bool ampdu ;
   unsigned long wd_timeout ;
};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_trans_pcie {
   struct iwl_rxq rxq ;
   struct work_struct rx_replenish ;
   struct iwl_trans *trans ;
   struct iwl_drv *drv ;
   struct net_device napi_dev ;
   struct napi_struct napi ;
   __le32 *ict_tbl ;
   dma_addr_t ict_tbl_dma ;
   int ict_index ;
   bool use_ict ;
   struct isr_statistics isr_stats ;
   spinlock_t irq_lock ;
   u32 inta_mask ;
   u32 scd_base_addr ;
   struct iwl_dma_ptr scd_bc_tbls ;
   struct iwl_dma_ptr kw ;
   struct iwl_txq *txq ;
   unsigned long queue_used[1U] ;
   unsigned long queue_stopped[1U] ;
   struct pci_dev *pci_dev ;
   void *hw_base ;
   bool ucode_write_complete ;
   wait_queue_head_t ucode_write_waitq ;
   wait_queue_head_t wait_command_queue ;
   u8 cmd_queue ;
   u8 cmd_fifo ;
   unsigned int cmd_q_wdg_timeout ;
   u8 n_no_reclaim_cmds ;
   u8 no_reclaim_cmds[6U] ;
   bool rx_buf_size_8k ;
   bool bc_table_dword ;
   bool scd_set_active ;
   u32 rx_page_order ;
   char const * const *command_names ;
   spinlock_t reg_lock ;
   bool cmd_hold_nic_awake ;
   bool ref_cmd_in_flight ;
   spinlock_t ref_lock ;
   u32 ref_count ;
   dma_addr_t fw_mon_phys ;
   struct page *fw_mon_page ;
   u32 fw_mon_size ;
};

#line 14  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-phy-db.c.aux"
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.h"
struct iwl_phy_db;

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.h"
struct iwl_phy_db_entry {
   u16 size ;
   u8 *data ;
};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct iwl_phy_db {
   struct iwl_phy_db_entry cfg ;
   struct iwl_phy_db_entry calib_nch ;
   struct iwl_phy_db_entry calib_ch_group_papd[9U] ;
   struct iwl_phy_db_entry calib_ch_group_txp[9U] ;
   struct iwl_trans *trans ;
};

#line 100 
enum iwl_phy_db_section_type {
    IWL_PHY_DB_CFG = 1,
    IWL_PHY_DB_CALIB_NCH = 2,
    IWL_PHY_DB_UNUSED = 3,
    IWL_PHY_DB_CALIB_CHG_PAPD = 4,
    IWL_PHY_DB_CALIB_CHG_TXP = 5,
    IWL_PHY_DB_MAX = 6
};

#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct iwl_phy_db_cmd {
   __le16 type ;
   __le16 length ;
   u8 data[] ;
};

#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct iwl_phy_db_chg_txp {
   __le32 space ;
   __le16 max_channel_idx ;
};

#line 126  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct iwl_calib_res_notif_phy_db {
   __le16 type ;
   __le16 length ;
   u8 data[] ;
};

#line 1030  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_nvm_data {
   int n_hw_addrs ;
   u8 hw_addr[6U] ;
   u8 calib_version ;
   __le16 calib_voltage ;
   __le16 raw_temperature ;
   __le16 kelvin_temperature ;
   __le16 kelvin_voltage ;
   __le16 xtal_calib[2U] ;
   bool sku_cap_band_24GHz_enable ;
   bool sku_cap_band_52GHz_enable ;
   bool sku_cap_11n_enable ;
   bool sku_cap_11ac_enable ;
   bool sku_cap_amt_enable ;
   bool sku_cap_ipan_enable ;
   bool sku_cap_mimo_disabled ;
   u16 radio_cfg_type ;
   u8 radio_cfg_step ;
   u8 radio_cfg_dash ;
   u8 radio_cfg_pnum ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   u32 nvm_version ;
   s8 max_tx_pwr_half_dbm ;
   bool lar_enabled ;
   struct ieee80211_supported_band bands[3U] ;
   struct ieee80211_channel channels[] ;
};

#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.h"
struct iwl_eeprom_calib_hdr {
   u8 version ;
   u8 pa_type ;
   __le16 voltage ;
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
struct iwl_eeprom_channel {
   u8 flags ;
   s8 max_power_avg ;
};

#line 327  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
struct iwl_eeprom_enhanced_txpwr {
   u8 flags ;
   u8 channel ;
   s8 chain_a_max ;
   s8 chain_b_max ;
   s8 chain_c_max ;
   u8 delta_20_in_40 ;
   s8 mimo2_max ;
   s8 mimo3_max ;
};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/init.h"
typedef void (*ctor_fn_t)(void);

#line 555  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;

#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;

#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;

#line 21  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;

#line 190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param;

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const *, struct kernel_param const *) ;
   int (*get)(char *, struct kernel_param const *) ;
   void (*free)(void *) ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string;

#line 62 
struct kparam_array;

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
union __anonunion_3409 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kernel_param {
   char const *name ;
   struct module *mod ;
   struct kernel_param_ops const *ops ;
   u16 const perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_3409 __anonCompField_kernel_param_49 ;
};

#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};

#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};

#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rbtree_latch.h"
struct mod_arch_specific {
   
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_param_attrs;

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};

#line 48  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char const *, size_t ) ;
   void (*setup)(struct module *, char const *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};

#line 74 
struct exception_table_entry;

#line 290 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};

#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};

#line 304 
struct module_sect_attrs;

#line 304 
struct module_notes_attrs;

#line 304 
struct trace_event_call;

#line 304 
struct trace_enum_map;

#line 304  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};

#line 1341  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
struct acpi_device;

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
typedef u64 acpi_size;

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
typedef u64 acpi_io_address;

#line 447  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
typedef u32 acpi_status;

#line 449  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
typedef char *acpi_string;

#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
typedef void *acpi_handle;

#line 644  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
typedef u32 acpi_object_type;

#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct __anonstruct_integer_3459 {
   acpi_object_type type ;
   u64 value ;
};

#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct __anonstruct_string_3460 {
   acpi_object_type type ;
   u32 length ;
   char *pointer ;
};

#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct __anonstruct_buffer_3461 {
   acpi_object_type type ;
   u32 length ;
   u8 *pointer ;
};

#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct __anonstruct_package_3462 {
   acpi_object_type type ;
   u32 count ;
   union acpi_object *elements ;
};

#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct __anonstruct_reference_3463 {
   acpi_object_type type ;
   acpi_object_type actual_type ;
   acpi_handle handle ;
};

#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct __anonstruct_processor_3464 {
   acpi_object_type type ;
   u32 proc_id ;
   acpi_io_address pblk_address ;
   u32 pblk_length ;
};

#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct __anonstruct_power_resource_3465 {
   acpi_object_type type ;
   u32 system_level ;
   u32 resource_order ;
};

#line 899  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
union acpi_object {
   acpi_object_type type ;
   struct __anonstruct_integer_3459 integer ;
   struct __anonstruct_string_3460 string ;
   struct __anonstruct_buffer_3461 buffer ;
   struct __anonstruct_package_3462 package ;
   struct __anonstruct_reference_3463 reference ;
   struct __anonstruct_processor_3464 processor ;
   struct __anonstruct_power_resource_3465 power_resource ;
};

#line 952  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct acpi_object_list {
   u32 count ;
   union acpi_object *pointer ;
};

#line 960  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/actypes.h"
struct acpi_buffer {
   acpi_size length ;
   void *pointer ;
};

#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_driver;

#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_hotplug_profile {
   struct kobject kobj ;
   int (*scan_dependent)(struct acpi_device *) ;
   void (*notify_online)(struct acpi_device *) ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) enabled : 1 ;
   bool __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) demand_offline : 1 ;
};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_scan_handler {
   struct acpi_device_id const *ids ;
   struct list_head list_node ;
   bool (*match)(char *, struct acpi_device_id const **) ;
   int (*attach)(struct acpi_device *, struct acpi_device_id const *) ;
   void (*detach)(struct acpi_device *) ;
   void (*bind)(struct device *) ;
   void (*unbind)(struct device *) ;
   struct acpi_hotplug_profile hotplug ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_hotplug_context {
   struct acpi_device *self ;
   int (*notify)(struct acpi_device *, u32 ) ;
   void (*uevent)(struct acpi_device *, u32 ) ;
   void (*fixup)(struct acpi_device *) ;
};

#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_ops {
   int (*add)(struct acpi_device *) ;
   int (*remove)(struct acpi_device *) ;
   void (*notify)(struct acpi_device *, u32 ) ;
};

#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_driver {
   char name[80U] ;
   char class[80U] ;
   struct acpi_device_id const *ids ;
   unsigned int flags ;
   struct acpi_device_ops ops ;
   struct device_driver drv ;
   struct module *owner ;
};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_status {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) present : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) enabled : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) show_in_ui : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) functional : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) battery_present : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(27))) reserved : 27 ;
};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_flags {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) dynamic_status : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) removable : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ejectable : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) power_manageable : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) match_driver : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) initialized : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) visited : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hotplug_notify : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dock_station : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) of_compatible_ok : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) coherent_dma : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cca_seen : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(20))) reserved : 20 ;
};

#line 216  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_dir {
   struct proc_dir_entry *entry ;
};

#line 227  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
typedef char acpi_bus_id[8U];

#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
typedef unsigned long acpi_bus_address;

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
typedef char acpi_device_name[40U];

#line 230  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
typedef char acpi_device_class[20U];

#line 236  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_pnp_type {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) hardware_id : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) bus_address : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) platform_id : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(29))) reserved : 29 ;
};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_pnp {
   acpi_bus_id bus_id ;
   struct acpi_pnp_type type ;
   acpi_bus_address bus_address ;
   char *unique_id ;
   struct list_head ids ;
   acpi_device_name device_name ;
   acpi_device_class device_class ;
   union acpi_object *str_obj ;
};

#line 258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_power_flags {
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) explicit_get : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) power_resources : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) inrush_current : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) power_removed : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) ignore_parent : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) dsw_present : 1 ;
   u32 __attribute__((__FRAMA_C_BITFIELD_SIZE__(26))) reserved : 26 ;
};

#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct __anonstruct_flags_3490 {
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) valid : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) explicit_set : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(6))) reserved : 6 ;
};

#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_power_state {
   struct __anonstruct_flags_3490 flags ;
   int power ;
   int latency ;
   struct list_head resources ;
};

#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_power {
   int state ;
   struct acpi_device_power_flags flags ;
   struct acpi_device_power_state states[5U] ;
};

#line 290  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_perf_flags {
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(8))) reserved : 8 ;
};

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct __anonstruct_flags_3491 {
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) valid : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(7))) reserved : 7 ;
};

#line 296  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_perf_state {
   struct __anonstruct_flags_3491 flags ;
   u8 power ;
   u8 performance ;
   int latency ;
};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_perf {
   int state ;
   struct acpi_device_perf_flags flags ;
   int state_count ;
   struct acpi_device_perf_state *states ;
};

#line 313  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_wakeup_flags {
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) valid : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) run_wake : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) notifier_present : 1 ;
   u8 __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) enabled : 1 ;
};

#line 321  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_wakeup_context {
   struct work_struct work ;
   struct device *dev ;
};

#line 326  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_wakeup {
   acpi_handle gpe_device ;
   u64 gpe_number ;
   u64 sleep_state ;
   struct list_head resources ;
   struct acpi_device_wakeup_flags flags ;
   struct acpi_device_wakeup_context context ;
   struct wakeup_source *ws ;
   int prepare_count ;
};

#line 344  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device_data {
   union acpi_object const *pointer ;
   union acpi_object const *properties ;
   union acpi_object const *of_compatible ;
};

#line 351 
struct acpi_gpio_mapping;

#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
struct acpi_device {
   int device_type ;
   acpi_handle handle ;
   struct fwnode_handle fwnode ;
   struct acpi_device *parent ;
   struct list_head children ;
   struct list_head node ;
   struct list_head wakeup_list ;
   struct list_head del_list ;
   struct acpi_device_status status ;
   struct acpi_device_flags flags ;
   struct acpi_device_pnp pnp ;
   struct acpi_device_power power ;
   struct acpi_device_wakeup wakeup ;
   struct acpi_device_perf performance ;
   struct acpi_device_dir dir ;
   struct acpi_device_data data ;
   struct acpi_scan_handler *handler ;
   struct acpi_hotplug_context *hp ;
   struct acpi_driver *driver ;
   struct acpi_gpio_mapping const *driver_gpios ;
   void *driver_data ;
   struct device dev ;
   unsigned int physical_node_count ;
   unsigned int dep_unmet ;
   struct list_head physical_node_list ;
   struct mutex physical_node_lock ;
   void (*remove)(struct acpi_device *) ;
};

#line 653  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/acpi.h"
struct acpi_gpio_params {
   unsigned int crs_entry_index ;
   unsigned int line_index ;
   bool active_low ;
};

#line 706  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/acpi.h"
struct acpi_gpio_mapping {
   char const *name ;
   struct acpi_gpio_params const *data ;
   unsigned int size ;
};

#line 62  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/tracepoint.h"
struct trace_enum_map {
   char const *system ;
   char const *enum_string ;
   unsigned long enum_value ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_3633 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_3635 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_3641 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_3643 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4474 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4476 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4482 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4484 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4486 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4488 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4490 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4492 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue;

#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;

#line 15  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *, unsigned int , int , void *) ;
   struct list_head task_list ;
};

#line 734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_fw_error_dump_data {
   __le32 type ;
   __le32 len ;
   __u8 data[] ;
};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h"
struct iwl_fw_error_dump_txcmd {
   __le32 cmdlen ;
   __le32 caplen ;
   u8 data[] ;
};

#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h"
struct iwl_fw_error_dump_fw_mon {
   __le32 fw_mon_wr_ptr ;
   __le32 fw_mon_base_ptr ;
   __le32 fw_mon_cycle_cnt ;
   __le32 reserved[3U] ;
   u8 data[] ;
};

#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h"
struct iwl_fw_error_dump_prph {
   __le32 prph_start ;
   __le32 data[] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4935 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4937 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4943 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_4945 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 2052  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
struct __anonstruct_iwl_prph_dump_addr_5019 {
   u32 start ;
   u32 end ;
};

#line 1030  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
struct iwl_notif_wait_data {
   struct list_head notif_waits ;
   spinlock_t notif_wait_lock ;
   wait_queue_head_t notif_waitq ;
};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.h"
struct iwl_notification_wait {
   struct list_head list ;
   bool (*fn)(struct iwl_notif_wait_data *, struct iwl_rx_packet *, void *) ;
   void *fn_data ;
   u8 cmds[5U] ;
   u8 n_cmds ;
   bool triggered ;
   bool aborted ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
struct ieee80211_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   u8 addr4[6U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_6157 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_6159 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_6165 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_6167 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
union __anonunion___u_6213 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
union __anonunion___u_6215 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
union __anonunion___u_6221 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
union __anonunion___u_6223 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
union __anonunion___u_6229 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
union __anonunion___u_6231 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fh.h"
struct iwlagn_scd_bc_tbl {
   __le16 tfd_offset[320U] ;
};

#line 1128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_dram_scratch {
   u8 try_cnt ;
   u8 bt_kill_cnt ;
   __le16 reserved ;
};

#line 1242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/dvm/commands.h"
union __anonunion_stop_time_6241 {
   __le32 life_time ;
   __le32 attempt ;
};

#line 1242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/dvm/commands.h"
union __anonunion_timeout_6242 {
   __le16 pm_frame_timeout ;
   __le16 attempt_duration ;
};

#line 1242  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_tx_cmd {
   __le16 len ;
   __le16 next_frame_len ;
   __le32 tx_flags ;
   struct iwl_dram_scratch scratch ;
   __le32 rate_n_flags ;
   u8 sta_id ;
   u8 sec_ctl ;
   u8 initial_rate_index ;
   u8 reserved ;
   u8 key[16U] ;
   __le16 next_frame_flags ;
   __le16 reserved2 ;
   union __anonunion_stop_time_6241 stop_time ;
   __le32 dram_lsb_ptr ;
   u8 dram_msb_ptr ;
   u8 rts_retry_limit ;
   u8 data_retry_limit ;
   u8 tid_tspec ;
   union __anonunion_timeout_6242 timeout ;
   __le16 driver_txop ;
   u8 payload[0U] ;
   struct ieee80211_hdr hdr[0U] ;
};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/types.h"
typedef __u64 __le64;

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
struct firmware {
   size_t size ;
   u8 const *data ;
   struct page **pages ;
   void *priv ;
};

#line 433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct __anonstruct_v1_6627 {
   __le32 inst_size ;
   __le32 data_size ;
   __le32 init_size ;
   __le32 init_data_size ;
   __le32 boot_size ;
   u8 data[0U] ;
};

#line 433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct __anonstruct_v2_6628 {
   __le32 build ;
   __le32 inst_size ;
   __le32 data_size ;
   __le32 init_size ;
   __le32 init_data_size ;
   __le32 boot_size ;
   u8 data[0U] ;
};

#line 433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
union __anonunion_u_6626 {
   struct __anonstruct_v1_6627 v1 ;
   struct __anonstruct_v2_6628 v2 ;
};

#line 433  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_ucode_header {
   __le32 ver ;
   union __anonunion_u_6626 u ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
enum iwl_ucode_tlv_type {
    IWL_UCODE_TLV_INVALID = 0,
    IWL_UCODE_TLV_INST = 1,
    IWL_UCODE_TLV_DATA = 2,
    IWL_UCODE_TLV_INIT = 3,
    IWL_UCODE_TLV_INIT_DATA = 4,
    IWL_UCODE_TLV_BOOT = 5,
    IWL_UCODE_TLV_PROBE_MAX_LEN = 6,
    IWL_UCODE_TLV_PAN = 7,
    IWL_UCODE_TLV_RUNT_EVTLOG_PTR = 8,
    IWL_UCODE_TLV_RUNT_EVTLOG_SIZE = 9,
    IWL_UCODE_TLV_RUNT_ERRLOG_PTR = 10,
    IWL_UCODE_TLV_INIT_EVTLOG_PTR = 11,
    IWL_UCODE_TLV_INIT_EVTLOG_SIZE = 12,
    IWL_UCODE_TLV_INIT_ERRLOG_PTR = 13,
    IWL_UCODE_TLV_ENHANCE_SENS_TBL = 14,
    IWL_UCODE_TLV_PHY_CALIBRATION_SIZE = 15,
    IWL_UCODE_TLV_WOWLAN_INST = 16,
    IWL_UCODE_TLV_WOWLAN_DATA = 17,
    IWL_UCODE_TLV_FLAGS = 18,
    IWL_UCODE_TLV_SEC_RT = 19,
    IWL_UCODE_TLV_SEC_INIT = 20,
    IWL_UCODE_TLV_SEC_WOWLAN = 21,
    IWL_UCODE_TLV_DEF_CALIB = 22,
    IWL_UCODE_TLV_PHY_SKU = 23,
    IWL_UCODE_TLV_SECURE_SEC_RT = 24,
    IWL_UCODE_TLV_SECURE_SEC_INIT = 25,
    IWL_UCODE_TLV_SECURE_SEC_WOWLAN = 26,
    IWL_UCODE_TLV_NUM_OF_CPU = 27,
    IWL_UCODE_TLV_CSCHEME = 28,
    IWL_UCODE_TLV_API_CHANGES_SET = 29,
    IWL_UCODE_TLV_ENABLED_CAPABILITIES = 30,
    IWL_UCODE_TLV_N_SCAN_CHANNELS = 31,
    IWL_UCODE_TLV_SEC_RT_USNIFFER = 34,
    IWL_UCODE_TLV_SDIO_ADMA_ADDR = 35,
    IWL_UCODE_TLV_FW_VERSION = 36,
    IWL_UCODE_TLV_FW_DBG_DEST = 38,
    IWL_UCODE_TLV_FW_DBG_CONF = 39,
    IWL_UCODE_TLV_FW_DBG_TRIGGER = 40
};

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_ucode_tlv {
   __le32 type ;
   __le32 length ;
   u8 data[0U] ;
};

#line 148  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_tlv_ucode_header {
   __le32 zero ;
   __le32 magic ;
   u8 human_readable[64U] ;
   __le32 ver ;
   __le32 build ;
   __le64 ignore ;
   u8 data[0U] ;
};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_ucode_api {
   __le32 api_index ;
   __le32 api_flags ;
};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_ucode_capa {
   __le32 api_index ;
   __le32 api_capa ;
};

#line 240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
typedef unsigned int iwl_ucode_tlv_api_t;

#line 378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-file.h"
struct iwl_fw_cipher_scheme {
   __le32 cipher ;
   u8 flags ;
   u8 hdr_len ;
   u8 pn_len ;
   u8 pn_off ;
   u8 key_idx_off ;
   u8 key_idx_mask ;
   u8 key_idx_shift ;
   u8 mic_len ;
   u8 hw_cipher ;
};

#line 286  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h"
enum iwl_ucode_type {
    IWL_UCODE_REGULAR = 0,
    IWL_UCODE_INIT = 1,
    IWL_UCODE_WOWLAN = 2,
    IWL_UCODE_REGULAR_USNIFFER = 3,
    IWL_UCODE_TYPE_MAX = 4
};

#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw.h"
struct iwl_fw_cscheme_list {
   u8 size ;
   struct iwl_fw_cipher_scheme cs[] ;
};

#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct iwl_drv {
   struct list_head list ;
   struct iwl_fw fw ;
   struct iwl_op_mode *op_mode ;
   struct iwl_trans *trans ;
   struct device *dev ;
   struct iwl_cfg const *cfg ;
   int fw_index ;
   char firmware_name[32U] ;
   struct completion request_firmware_complete ;
   struct dentry *dbgfs_drv ;
   struct dentry *dbgfs_trans ;
   struct dentry *dbgfs_op_mode ;
};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct iwlwifi_opmode_table {
   char const *name ;
   struct iwl_op_mode_ops const *ops ;
   struct list_head drv ;
};

#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct fw_sec {
   void const *data ;
   size_t size ;
   u32 offset ;
};

#line 259  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct fw_img_parsing {
   struct fw_sec sec[12U] ;
   int sec_counter ;
};

#line 264  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct fw_sec_parsing {
   __le32 offset ;
   u8 const data[] ;
};

#line 272  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct iwl_tlv_calib_data {
   __le32 ucode_type ;
   struct iwl_tlv_calib_ctrl calib ;
};

#line 283  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct iwl_firmware_pieces {
   struct fw_img_parsing img[4U] ;
   u32 init_evtlog_ptr ;
   u32 init_evtlog_size ;
   u32 init_errlog_ptr ;
   u32 inst_evtlog_ptr ;
   u32 inst_evtlog_size ;
   u32 inst_errlog_ptr ;
   struct iwl_fw_dbg_dest_tlv *dbg_dest_tlv ;
   struct iwl_fw_dbg_conf_tlv *dbg_conf_tlv[32U] ;
   size_t dbg_conf_tlv_len[32U] ;
   struct iwl_fw_dbg_trigger_tlv *dbg_trigger_tlv[12U] ;
   size_t dbg_trigger_tlv_len[12U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_7766 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_7768 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_7774 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
union __anonunion___u_7776 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 6  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/fvtp/.tmp_iwl-debug.c"
struct __va_list_tag;

#line 6  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/fvtp/.tmp_iwl-debug.c"
typedef struct __va_list_tag __va_list_tag;

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/usr/lib/gcc/x86_64-linux-gnu/6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list[1U];

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/usr/lib/gcc/x86_64-linux-gnu/6/include/stdarg.h"
typedef __gnuc_va_list va_list[1U];

#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
struct va_format {
   char const *fmt ;
   va_list *va ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8259 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8261 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8263 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8265 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8267 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8269 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8271 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8273 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8275 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
union __anonunion___u_8277 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
struct ldv_list_element {
   void *data ;
   struct ldv_list_element *next ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
typedef struct ldv_list_element *ldv_list_ptr;

#line 41  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};

#line 18  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/int-ll64.h"
typedef short s16;

#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work;

#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
};

#line 380  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/scatterlist.h"
struct dma_chan;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master;

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};

#line 151 
struct spi_message;

#line 152 
struct spi_transfer;

#line 205  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master *) ;
   int (*transfer_one_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_master *) ;
   int (*prepare_message)(struct spi_master *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_master *, struct spi_message *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_master *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_master *, struct spi_message *) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};

#line 506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_transfer {
   void const *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) cs_change : 1 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) tx_nbits : 3 ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(3))) rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};

#line 630  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int __attribute__((__FRAMA_C_BITFIELD_SIZE__(1))) is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef unsigned long pthread_t;

#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};

#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;

#line 678  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pagemap.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};

#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   unsigned long _key ;
};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
struct ldv_struct_character_driver_scenario_11 {
   struct file_operations *arg0 ;
   int signal_pending ;
};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_free_irq_3 {
   int arg0 ;
   int signal_pending ;
};

#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_interrupt_scenario_14 {
   enum irqreturn (*arg2)(int , void *) ;
   enum irqreturn (*arg1)(int , void *) ;
   void *arg3 ;
   int arg0 ;
   int signal_pending ;
};

#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_pci_scenario_13 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};

#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
struct ldv_struct_timer_scenario_19 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
void *__builtin_memcpy(void *, void const *, unsigned long);

void __builtin_unreachable(void);


#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/fvtp/.tmp_rx.c"
void ldv_inline_asm(void);


#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/compiler.h"
__inline static void __read_once_size(void const volatile *p, void *res, int size)
{
  
#line 203 
  switch (size) {
    case 1: 
#line 204 
    ;
    
#line 204 
    *((__u8 *)res) = *((__u8 volatile *)p);
    
#line 204 
    goto ldv_1185;
    case 2: 
#line 205 
    ;
    
#line 205 
    *((__u16 *)res) = *((__u16 volatile *)p);
    
#line 205 
    goto ldv_1185;
    case 4: 
#line 206 
    ;
    
#line 206 
    *((__u32 *)res) = *((__u32 volatile *)p);
    
#line 206 
    goto ldv_1185;
    case 8: 
#line 207 
    ;
    
#line 207 
    *((__u64 *)res) = *((__u64 volatile *)p);
    
#line 207 
    goto ldv_1185;
    default: 
#line 208 
    ;
    
#line 209 
    ldv_inline_asm();
    
#line 210 
    __builtin_memcpy(res,(void const *)p,(unsigned long)size);
    
#line 211 
    ldv_inline_asm();
  }
  ldv_1185: 
#line 213 
  ;
  
#line 214 
  return;
}


#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops;


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr, unsigned long volatile *addr)
{
  
#line 74 
  if (0 != 0) 
#line 76 
              ldv_inline_asm(); else 
#line 79 
                                     ldv_inline_asm();
  
#line 80 
  return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr, unsigned long volatile *addr)
{
  int __retres;
  
#line 206 
  ldv_inline_asm();
  
#line 207 
  ldv_inline_asm();
  
#line 206 
  __retres = 0;
  
#line 206 
  goto return_label;
  cc_label: 
#line 206 
  ;
  
#line 206 
  __retres = 1;
  return_label: 
#line 206 
                return __retres;
}


#line 308  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr, unsigned long const volatile *addr)
{
  int __retres;
  
#line 311 
  __retres = ((*(addr + (nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL;
  
#line 311 
  return __retres;
}


#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_sleep(char const *, int, int);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list)
{
  
#line 27 
  list->next = list;
  
#line 28 
  list->prev = list;
  
#line 29 
  return;
}


#line 48 
void __list_add(struct list_head *, struct list_head *, struct list_head *);


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add(struct list_head *new, struct list_head *head)
{
  
#line 63 
  __list_add(new,head,head->next);
  
#line 64 
  return;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new, struct list_head *head)
{
  
#line 77 
  __list_add(new,head->prev,head);
  
#line 78 
  return;
}


#line 113 
void list_del(struct list_head *);


#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/list.h"
__inline static int list_empty(struct list_head const *head)
{
  int __retres;
  
#line 189 
  __retres = (struct list_head const *)head->next == head;
  
#line 189 
  return __retres;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/percpu.h"
void __bad_percpu_size(void);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_null(char const *, int const);


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memset(void *, int, size_t);


#line 829  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void)
{
  unsigned long tmp;
  {
    unsigned long __ret;
    
#line 831 
    unsigned long __edi = __edi;
    
#line 831 
    unsigned long __esi = __esi;
    
#line 831 
    unsigned long __edx = __edx;
    
#line 831 
    unsigned long __ecx = __ecx;
    
#line 831 
    unsigned long __eax = __eax;
    
#line 831 
    if ((long)(pv_irq_ops.save_fl.func == (void *)0) != 0L) {
      
#line 833 
      ldv_inline_asm();
      
#line 831 
      ;
    }
    else ;
    
#line 835 
    ldv_inline_asm();
    
#line 831 
    __ret = __eax;
    
#line 831 
    tmp = __ret;
  }
  
#line 831 
  return tmp;
}


#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags)
{
  int __retres;
  
#line 153 
  __retres = (flags & 512UL) == 0UL;
  
#line 153 
  return __retres;
}


#line 20  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  int __retres;
  int tmp;
  {
    int pfo_ret__;
    
#line 22 
    switch (4UL) {
      case (unsigned long)1: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)2: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)4: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      case (unsigned long)8: 
#line 22 
      ;
      
#line 23 
      ldv_inline_asm();
      
#line 22 
      goto ldv_6320;
      default: 
#line 22 
      ;
      
#line 22 
      __bad_percpu_size();
    }
    ldv_6320: 
#line 22 
    ;
    
#line 22 
    tmp = pfo_ret__;
  }
  
#line 22 
  __retres = tmp & 2147483647;
  
#line 22 
  return __retres;
}


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val)
{
  int tmp;
  
#line 72 
  if (0 != 0 && (val == 1 || val == -1)) 
#line 72 
                                         tmp = val; else 
#line 72 
                                                         tmp = 0;
  
#line 72 
  int const pao_ID__ = tmp;
  
#line 72 
  switch (4UL) {
    case (unsigned long)1: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)2: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)4: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    case (unsigned long)8: 
#line 72 
    ;
    
#line 72 
    if (pao_ID__ == 1) 
#line 74 
                       ldv_inline_asm();
    else 
      
#line 72 
      if (pao_ID__ == -1) 
#line 74 
                          ldv_inline_asm(); else 
#line 77 
                                                 ldv_inline_asm();
    
#line 72 
    goto ldv_6377;
    default: 
#line 72 
    ;
    
#line 72 
    __bad_percpu_size();
  }
  ldv_6377: 
#line 72 
  ;
  
#line 74 
  return;
}


#line 75  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val)
{
  int tmp;
  
#line 77 
  if (0 != 0 && (- val == 1 || - val == -1)) 
#line 77 
                                             tmp = - val; else 
#line 77 
                                                               tmp = 0;
  
#line 77 
  int const pao_ID__ = tmp;
  
#line 77 
  switch (4UL) {
    case (unsigned long)1: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)2: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)4: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    case (unsigned long)8: 
#line 77 
    ;
    
#line 77 
    if (pao_ID__ == 1) 
#line 79 
                       ldv_inline_asm();
    else 
      
#line 77 
      if (pao_ID__ == -1) 
#line 79 
                          ldv_inline_asm(); else 
#line 82 
                                                 ldv_inline_asm();
    
#line 77 
    goto ldv_6389;
    default: 
#line 77 
    ;
    
#line 77 
    __bad_percpu_size();
  }
  ldv_6389: 
#line 77 
  ;
  
#line 79 
  return;
}


#line 7  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
void __local_bh_disable_ip(unsigned long, unsigned int);


#line 16  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_disable(void)
{
  __here_0: 
#line 18 
  ;
  
#line 18 
  __local_bh_disable_ip((unsigned long)((void *)0),512U);
  
#line 20 
  return;
}


#line 22 
void __local_bh_enable_ip(unsigned long, unsigned int);


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/bottom_half.h"
__inline static void local_bh_enable(void)
{
  __here_0: 
#line 31 
  ;
  
#line 31 
  __local_bh_enable_ip((unsigned long)((void *)0),512U);
  
#line 33 
  return;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debug_locks.h"
extern int debug_locks;


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/lockdep.h"
void lockdep_init_map(struct lockdep_map *, char const *, struct lock_class_key *, int);


#line 333 
void lock_acquire(struct lockdep_map *, unsigned int, int, int, int, struct lockdep_map *, unsigned long);


#line 337 
void lock_release(struct lockdep_map *, int, unsigned long);


#line 342 
int lock_is_held(struct lockdep_map *);


#line 545 
void lockdep_rcu_suspicious(char const *, int const, char const *);


#line 19  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/jump_label.h"
__inline static bool arch_static_branch(struct static_key *key)
{
  bool __retres;
  
#line 21 
  ldv_inline_asm();
  
#line 22 
  ldv_inline_asm();
  
#line 28 
  __retres = (_Bool)0;
  
#line 28 
  goto return_label;
  l_yes: 
#line 29 
  ;
  
#line 30 
  __retres = (_Bool)1;
  return_label: 
#line 30 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
static bool static_key_false(struct static_key *key)
{
  bool tmp;
  
#line 125 
  tmp = arch_static_branch(key);
  
#line 125 
  return tmp;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
void __raw_spin_lock_init(raw_spinlock_t *, char const *, struct lock_class_key *);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock(raw_spinlock_t *);


#line 41 
void _raw_spin_unlock(raw_spinlock_t *);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  raw_spinlock_t *__retres;
  
#line 301 
  __retres = & lock->__anonCompField_spinlock_18.rlock;
  
#line 301 
  return __retres;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_73(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_75(spinlock_t *lock);


#line 366 
static void ldv_spin_lock_78(spinlock_t *lock);


#line 370 
static void ldv_spin_lock_80(spinlock_t *lock);


#line 374 
static void ldv_spin_lock_83(spinlock_t *lock);


#line 378 
static void ldv_spin_lock_86(spinlock_t *lock);


#line 382 
static void ldv_spin_lock_88(spinlock_t *lock);


#line 386 
static void ldv_spin_lock_90(spinlock_t *lock);


#line 390 
static void ldv_spin_lock_92(spinlock_t *lock);


#line 394 
static void ldv_spin_lock_94(spinlock_t *lock);


#line 398 
static void ldv_spin_lock_96(spinlock_t *lock);


#line 402 
static void ldv_spin_lock_99(spinlock_t *lock);


#line 406 
static void ldv_spin_lock_103(spinlock_t *lock);


#line 410 
static void ldv_spin_lock_105(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_74(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_76(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_79(spinlock_t *lock);


#line 419 
static void ldv_spin_unlock_81(spinlock_t *lock);


#line 423 
static void ldv_spin_unlock_82(spinlock_t *lock);


#line 427 
static void ldv_spin_unlock_84(spinlock_t *lock);


#line 431 
static void ldv_spin_unlock_85(spinlock_t *lock);


#line 435 
static void ldv_spin_unlock_87(spinlock_t *lock);


#line 439 
static void ldv_spin_unlock_89(spinlock_t *lock);


#line 443 
static void ldv_spin_unlock_91(spinlock_t *lock);


#line 447 
static void ldv_spin_unlock_93(spinlock_t *lock);


#line 451 
static void ldv_spin_unlock_95(spinlock_t *lock);


#line 455 
static void ldv_spin_unlock_97(spinlock_t *lock);


#line 459 
static void ldv_spin_unlock_98(spinlock_t *lock);


#line 463 
static void ldv_spin_unlock_100(spinlock_t *lock);


#line 467 
static void ldv_spin_unlock_101(spinlock_t *lock);


#line 471 
static void ldv_spin_unlock_102(spinlock_t *lock);


#line 475 
static void ldv_spin_unlock_104(spinlock_t *lock);


#line 479 
static void ldv_spin_unlock_106(spinlock_t *lock);


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
void ldv_spin_model_lock(char *);


#line 75 
void ldv_spin_model_unlock(char *);


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
void __wake_up(wait_queue_head_t *, unsigned int, int, void *);


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcutree.h"
bool rcu_is_watching(void);


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
bool rcu_lockdep_current_cpu_online(void);


#line 459 
extern struct lockdep_map rcu_sched_lock_map;


#line 461 
int debug_lockdep_rcu_enabled(void);


#line 498  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held(void)
{
  int __retres;
  int tmp;
  int tmp_1;
  bool tmp_0;
  int tmp_3;
  bool tmp_2;
  int tmp_8;
  
#line 500 
  int lockdep_opinion = 0;
  
#line 502 
  tmp = debug_lockdep_rcu_enabled();
  
#line 502 
  if (tmp == 0) {
    
#line 503 
    __retres = 1;
    
#line 503 
    goto return_label;
  }
  else ;
  
#line 504 
  tmp_0 = rcu_is_watching();
  
#line 504 
  if (tmp_0) 
#line 504 
             tmp_1 = 0; else 
#line 504 
                             tmp_1 = 1;
  
#line 504 
  if (tmp_1) {
    
#line 505 
    __retres = 0;
    
#line 505 
    goto return_label;
  }
  else ;
  
#line 506 
  tmp_2 = rcu_lockdep_current_cpu_online();
  
#line 506 
  if (tmp_2) 
#line 506 
             tmp_3 = 0; else 
#line 506 
                             tmp_3 = 1;
  
#line 506 
  if (tmp_3) {
    
#line 507 
    __retres = 0;
    
#line 507 
    goto return_label;
  }
  else ;
  
#line 508 
  if (debug_locks != 0) 
#line 509 
                        lockdep_opinion = lock_is_held(& rcu_sched_lock_map); else ;
  
#line 510 
  if (lockdep_opinion != 0) 
#line 510 
                            tmp_8 = 1;
  else {
    int tmp_4;
    
#line 510 
    tmp_4 = preempt_count();
    
#line 510 
    if (tmp_4 != 0) 
#line 510 
                    tmp_8 = 1;
    else {
      int tmp_7;
      {
        unsigned long _flags;
        int tmp_6;
        {
          unsigned long __dummy;
          unsigned long __dummy2;
          
        }
        
#line 510 
        _flags = arch_local_save_flags();
        {
          unsigned long __dummy_0;
          unsigned long __dummy2_0;
          
        }
        
#line 510 
        tmp_6 = arch_irqs_disabled_flags(_flags);
        
#line 510 
        tmp_7 = tmp_6;
      }
      
#line 510 
      if (tmp_7 != 0) 
#line 510 
                      tmp_8 = 1; else 
#line 510 
                                      tmp_8 = 0;
    }
  }
  
#line 510 
  __retres = tmp_8;
  return_label: 
#line 510 
                return __retres;
}


#line 969  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_read_lock_sched_notrace(void)
{
  
#line 971 
  __preempt_count_add(1);
  
#line 972 
  ldv_inline_asm();
  
#line 973 
  return;
}


#line 990  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rcupdate.h"
__inline static void rcu_read_unlock_sched_notrace(void)
{
  
#line 993 
  ldv_inline_asm();
  
#line 993 
  __preempt_count_sub(1);
  
#line 994 
  return;
}


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/workqueue.h"
void __init_work(struct work_struct *, int);


#line 444 
bool cancel_work_sync(struct work_struct *);


#line 560 
static bool ldv_schedule_work_77(struct work_struct *work);


#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/signal.h"
void __compiletime_assert_117(void);


#line 322  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
struct page *alloc_pages_current(gfp_t, unsigned int);


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)
{
  struct page *tmp;
  
#line 327 
  tmp = alloc_pages_current(gfp_mask,order);
  
#line 327 
  return tmp;
}


#line 366 
void __free_pages(struct page *, unsigned int);


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address, unsigned int n)
{
  
#line 133 
  return;
}


#line 220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/net.h"
int net_ratelimit(void);


#line 144  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kzfree(void const *);


#line 945  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page const *page)
{
  void *__retres;
  
#line 947 
  __retres = (void *)((unsigned long)((unsigned long long)(((long)page + 24189255811072L) / 64L) << 12) + 18446612132314218496UL);
  
#line 947 
  return __retres;
}


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  int __retres;
  
#line 76 
  __retres = (unsigned int)dma_direction <= 2U;
  
#line 76 
  return __retres;
}


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t, bool);


#line 42 
void debug_dma_mapping_error(struct device *, dma_addr_t);


#line 44 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int, bool);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops;


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  struct dma_map_ops *__retres;
  
#line 37 
  if ((long)(dev == (struct device *)0) != 0L || dev->archdata.dma_ops == (struct dma_map_ops *)0) {
    
#line 38 
    __retres = dma_ops;
    
#line 38 
    goto return_label;
  }
  else {
    
#line 40 
    __retres = dev->archdata.dma_ops;
    
#line 40 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
{
  dma_addr_t addr;
  void *tmp_0;
  int tmp_1;
  
#line 80 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 83 
  ;
  
#line 83 
  tmp_0 = lowmem_page_address((struct page const *)page);
  
#line 83 
  ;
  
#line 83 
  kmemcheck_mark_initialized(tmp_0 + offset,(unsigned int)size);
  
#line 84 
  tmp_1 = valid_dma_direction((int)dir);
  
#line 84 
  if ((long)(tmp_1 == 0) != 0L) {
    
#line 86 
    ldv_inline_asm();
    
#line 84 
    ;
  }
  else ;
  
#line 85 
  addr = (*(ops->map_page))(dev,page,offset,size,dir,(struct dma_attrs *)0);
  
#line 86 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr,(_Bool)0);
  
#line 88 
  return addr;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 94 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 96 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 96 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 98 
    ldv_inline_asm();
    
#line 96 
    ;
  }
  else ;
  
#line 97 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 98 
    (*(ops->unmap_page))(dev,addr,size,dir,(struct dma_attrs *)0); else ;
  
#line 99 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)0);
  
#line 100 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  int __retres;
  
#line 49 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 50 
  debug_dma_mapping_error(dev,dma_addr);
  
#line 51 
  if (ops->mapping_error != (int (*)(struct device *, dma_addr_t ))0) {
    int tmp_0;
    
#line 52 
    tmp_0 = (*(ops->mapping_error))(dev,dma_addr);
    
#line 52 
    __retres = tmp_0;
    
#line 52 
    goto return_label;
  }
  else ;
  
#line 54 
  __retres = dma_addr == 0ULL;
  return_label: 
#line 54 
                return __retres;
}


#line 131 
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, struct dma_attrs *);


#line 136 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, struct dma_attrs *);


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag)
{
  
#line 186 
  void *ret = dma_alloc_attrs(dev,size,dma_handle,flag | 32768U,(struct dma_attrs *)0);
  
#line 188 
  return ret;
}


#line 2949  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void napi_gro_flush(struct napi_struct *, bool);


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-modparams.h"
struct iwl_mod_params iwlwifi_mod_params;


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.h"
__inline static bool iwl_have_debug_level(u32 level)
{
  bool __retres;
  
#line 38 
  __retres = (_Bool)((iwlwifi_mod_params.debug_level & level) != 0U);
  
#line 38 
  return __retres;
}


#line 44 
void __iwl_err(struct device *dev, bool rfkill_prefix, bool trace_only, char const *fmt , ...);


#line 46 
void __iwl_warn(struct device *dev, char const *fmt , ...);


#line 48 
void __iwl_crit(struct device *dev, char const *fmt , ...);


#line 78 
void __iwl_dbg(struct device *dev, u32 level, bool limit, char const *function, char const *fmt , ...);


#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static int iwl_op_mode_rx(struct iwl_op_mode *op_mode, struct iwl_rx_cmd_buffer *rxb, struct iwl_device_cmd *cmd)
{
  int tmp;
  
#line 195 
  tmp = (*((op_mode->ops)->rx))(op_mode,rxb,cmd);
  
#line 195 
  return tmp;
}


#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_nic_error(struct iwl_op_mode *op_mode)
{
  
#line 225 
  (*((op_mode->ops)->nic_error))(op_mode);
  
#line 226 
  return;
}


#line 239  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_wimax_active(struct iwl_op_mode *op_mode)
{
  
#line 241 
  __might_sleep("drivers/net/wireless/iwlwifi/iwl-op-mode.h",241,0);
  
#line 242 
  (*((op_mode->ops)->wimax_active))(op_mode);
  
#line 243 
  return;
}


#line 181  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static u32 iwl_rx_packet_len(struct iwl_rx_packet const *pkt)
{
  u32 __retres;
  
#line 183 
  __retres = pkt->len_n_flags & 16383U;
  
#line 183 
  return __retres;
}


#line 297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void *rxb_addr(struct iwl_rx_cmd_buffer *r)
{
  void *__retres;
  void *tmp;
  
#line 299 
  tmp = lowmem_page_address((struct page const *)r->_page);
  
#line 299 
  ;
  
#line 299 
  __retres = (void *)((unsigned long)tmp + (unsigned long)r->_offset);
  
#line 299 
  return __retres;
}


#line 921  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_trans_write8(struct iwl_trans *trans, u32 ofs, u8 val)
{
  
#line 923 
  (*((trans->ops)->write8))(trans,ofs,(unsigned char)((int)val));
  
#line 924 
  return;
}


#line 926  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_trans_write32(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 928 
  (*((trans->ops)->write32))(trans,ofs,val);
  
#line 929 
  return;
}


#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static u32 iwl_trans_read32(struct iwl_trans *trans, u32 ofs)
{
  u32 tmp;
  
#line 933 
  tmp = (*((trans->ops)->read32))(trans,ofs);
  
#line 933 
  return tmp;
}


#line 989  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_trans_set_bits_mask(struct iwl_trans *trans, u32 reg, u32 mask, u32 value)
{
  
#line 991 
  (*((trans->ops)->set_bits_mask))(trans,reg,mask,value);
  
#line 992 
  return;
}


#line 1005  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_trans_fw_error(struct iwl_trans *trans)
{
  int tmp_0;
  int tmp_1;
  {
    bool __warned;
    
#line 1007 
    int __ret_warn_once = trans->op_mode == (struct iwl_op_mode *)0;
    
#line 1007 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 1007 
        int __ret_warn_on = ! __warned;
        
#line 1007 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 1007 
                                              warn_slowpath_null("drivers/net/wireless/iwlwifi/iwl-trans.h",1007); else ;
        
#line 1007 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 1007 
      if ((long)tmp != 0L) 
#line 1007 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 1007 
    tmp_0 = (long)(__ret_warn_once != 0);
  }
  
#line 1007 
  if ((long)tmp_0 != 0L) 
#line 1008 
                         goto return_label; else ;
  
#line 1011 
  tmp_1 = test_and_set_bit(5L,(unsigned long volatile *)(& trans->status));
  
#line 1011 
  if (tmp_1 == 0) 
#line 1012 
                  iwl_op_mode_nic_error(trans->op_mode); else ;
  return_label: 
#line 1013 
                return;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_ioread32;


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 35 
  tmp_4 = static_key_false(& __tracepoint_iwlwifi_dev_ioread32.key);
  
#line 35 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 35 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_375 __u;
          
#line 35 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u.__c),8);
          
#line 35 
          tmp = __u.__val;
        }
        
#line 35 
        struct tracepoint_func *_________p1 = tmp;
        
#line 35 
        tmp_0 = _________p1;
      }
      
#line 35 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 35 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 35 
        if (tmp_1 != 0) {
          
#line 35 
          if (! __warned) {
            int tmp_2;
            
#line 35 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 35 
            if (tmp_2 == 0) {
              
#line 35 
              __warned = (_Bool)1;
              
#line 35 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 35 
      tmp_3 = ________p1;
    }
    
#line 35 
    it_func_ptr = tmp_3;
    
#line 35 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50475: 
#line 37 
      ;
      
#line 35 
      it_func = it_func_ptr->func;
      
#line 35 
      __data = it_func_ptr->data;
      
#line 35 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 35 
      it_func_ptr += 1;
      
#line 35 
      ;
      
#line 35 
      if (it_func_ptr->func != (void *)0) 
#line 37 
                                          goto ldv_50475; else 
#line 40 
                                                               goto ldv_50476;
      ldv_50476: 
#line 41 
      ;
    }
    else ;
    
#line 35 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 35 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_377 __u_0;
        
#line 35 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u_0.__c),8);
        
#line 35 
        tmp_5 = __u_0.__val;
      }
      
#line 35 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 35 
      tmp_6 = _________p1_0;
    }
    
#line 35 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 35 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 35 
      if (tmp_7 != 0) {
        
#line 35 
        if (! __warned_0) {
          int tmp_8;
          
#line 35 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 35 
          if (tmp_8 == 0) {
            
#line 35 
            __warned_0 = (_Bool)1;
            
#line 35 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 35 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 35 
  rcu_read_unlock_sched_notrace();
  
#line 37 
  return;
}


#line 52 
struct tracepoint __tracepoint_iwlwifi_dev_iowrite8;


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite8(struct device const *dev, u32 offs, u8 val)
{
  bool tmp_4;
  
#line 52 
  tmp_4 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite8.key);
  
#line 52 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 52 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_379 __u;
          
#line 52 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite8.funcs),(void *)(& __u.__c),8);
          
#line 52 
          tmp = __u.__val;
        }
        
#line 52 
        struct tracepoint_func *_________p1 = tmp;
        
#line 52 
        tmp_0 = _________p1;
      }
      
#line 52 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 52 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 52 
        if (tmp_1 != 0) {
          
#line 52 
          if (! __warned) {
            int tmp_2;
            
#line 52 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 52 
            if (tmp_2 == 0) {
              
#line 52 
              __warned = (_Bool)1;
              
#line 52 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",67,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 52 
      tmp_3 = ________p1;
    }
    
#line 52 
    it_func_ptr = tmp_3;
    
#line 52 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50536: 
#line 54 
      ;
      
#line 52 
      it_func = it_func_ptr->func;
      
#line 52 
      __data = it_func_ptr->data;
      
#line 52 
      (*((void (*)(void *, struct device const *, u32 , u8 ))it_func))(__data,dev,offs,(unsigned char)((int)val));
      
#line 52 
      it_func_ptr += 1;
      
#line 52 
      ;
      
#line 52 
      if (it_func_ptr->func != (void *)0) 
#line 54 
                                          goto ldv_50536; else 
#line 57 
                                                               goto ldv_50537;
      ldv_50537: 
#line 58 
      ;
    }
    else ;
    
#line 52 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 52 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_381 __u_0;
        
#line 52 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite8.funcs),(void *)(& __u_0.__c),8);
        
#line 52 
        tmp_5 = __u_0.__val;
      }
      
#line 52 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 52 
      tmp_6 = _________p1_0;
    }
    
#line 52 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 52 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 52 
      if (tmp_7 != 0) {
        
#line 52 
        if (! __warned_0) {
          int tmp_8;
          
#line 52 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 52 
          if (tmp_8 == 0) {
            
#line 52 
            __warned_0 = (_Bool)1;
            
#line 52 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",67,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 52 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 52 
  rcu_read_unlock_sched_notrace();
  
#line 54 
  return;
}


#line 69 
struct tracepoint __tracepoint_iwlwifi_dev_iowrite32;


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 69 
  tmp_4 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite32.key);
  
#line 69 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 69 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_383 __u;
          
#line 69 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u.__c),8);
          
#line 69 
          tmp = __u.__val;
        }
        
#line 69 
        struct tracepoint_func *_________p1 = tmp;
        
#line 69 
        tmp_0 = _________p1;
      }
      
#line 69 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 69 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 69 
        if (tmp_1 != 0) {
          
#line 69 
          if (! __warned) {
            int tmp_2;
            
#line 69 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 69 
            if (tmp_2 == 0) {
              
#line 69 
              __warned = (_Bool)1;
              
#line 69 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 69 
      tmp_3 = ________p1;
    }
    
#line 69 
    it_func_ptr = tmp_3;
    
#line 69 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50597: 
#line 71 
      ;
      
#line 69 
      it_func = it_func_ptr->func;
      
#line 69 
      __data = it_func_ptr->data;
      
#line 69 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 69 
      it_func_ptr += 1;
      
#line 69 
      ;
      
#line 69 
      if (it_func_ptr->func != (void *)0) 
#line 71 
                                          goto ldv_50597; else 
#line 74 
                                                               goto ldv_50598;
      ldv_50598: 
#line 75 
      ;
    }
    else ;
    
#line 69 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 69 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_385 __u_0;
        
#line 69 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u_0.__c),8);
        
#line 69 
        tmp_5 = __u_0.__val;
      }
      
#line 69 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 69 
      tmp_6 = _________p1_0;
    }
    
#line 69 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 69 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 69 
      if (tmp_7 != 0) {
        
#line 69 
        if (! __warned_0) {
          int tmp_8;
          
#line 69 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 69 
          if (tmp_8 == 0) {
            
#line 69 
            __warned_0 = (_Bool)1;
            
#line 69 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 69 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 69 
  rcu_read_unlock_sched_notrace();
  
#line 71 
  return;
}


#line 120 
struct tracepoint __tracepoint_iwlwifi_dev_irq;


#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_irq(struct device const *dev)
{
  bool tmp_4;
  
#line 120 
  tmp_4 = static_key_false(& __tracepoint_iwlwifi_dev_irq.key);
  
#line 120 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 120 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_395 __u;
          
#line 120 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_irq.funcs),(void *)(& __u.__c),8);
          
#line 120 
          tmp = __u.__val;
        }
        
#line 120 
        struct tracepoint_func *_________p1 = tmp;
        
#line 120 
        tmp_0 = _________p1;
      }
      
#line 120 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 120 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 120 
        if (tmp_1 != 0) {
          
#line 120 
          if (! __warned) {
            int tmp_2;
            
#line 120 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 120 
            if (tmp_2 == 0) {
              
#line 120 
              __warned = (_Bool)1;
              
#line 120 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",131,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 120 
      tmp_3 = ________p1;
    }
    
#line 120 
    it_func_ptr = tmp_3;
    
#line 120 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50776: 
#line 122 
      ;
      
#line 120 
      it_func = it_func_ptr->func;
      
#line 120 
      __data = it_func_ptr->data;
      
#line 120 
      (*((void (*)(void *, struct device const *))it_func))(__data,dev);
      
#line 120 
      it_func_ptr += 1;
      
#line 120 
      ;
      
#line 120 
      if (it_func_ptr->func != (void *)0) 
#line 122 
                                          goto ldv_50776; else 
#line 125 
                                                               goto ldv_50777;
      ldv_50777: 
#line 126 
      ;
    }
    else ;
    
#line 120 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 120 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_397 __u_0;
        
#line 120 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_irq.funcs),(void *)(& __u_0.__c),8);
        
#line 120 
        tmp_5 = __u_0.__val;
      }
      
#line 120 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 120 
      tmp_6 = _________p1_0;
    }
    
#line 120 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 120 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 120 
      if (tmp_7 != 0) {
        
#line 120 
        if (! __warned_0) {
          int tmp_8;
          
#line 120 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 120 
          if (tmp_8 == 0) {
            
#line 120 
            __warned_0 = (_Bool)1;
            
#line 120 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",131,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 120 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 120 
  rcu_read_unlock_sched_notrace();
  
#line 122 
  return;
}


#line 133 
struct tracepoint __tracepoint_iwlwifi_dev_ict_read;


#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ict_read(struct device const *dev, u32 index, u32 value)
{
  bool tmp_4;
  
#line 133 
  tmp_4 = static_key_false(& __tracepoint_iwlwifi_dev_ict_read.key);
  
#line 133 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 133 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_399 __u;
          
#line 133 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ict_read.funcs),(void *)(& __u.__c),8);
          
#line 133 
          tmp = __u.__val;
        }
        
#line 133 
        struct tracepoint_func *_________p1 = tmp;
        
#line 133 
        tmp_0 = _________p1;
      }
      
#line 133 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 133 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 133 
        if (tmp_1 != 0) {
          
#line 133 
          if (! __warned) {
            int tmp_2;
            
#line 133 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 133 
            if (tmp_2 == 0) {
              
#line 133 
              __warned = (_Bool)1;
              
#line 133 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",148,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 133 
      tmp_3 = ________p1;
    }
    
#line 133 
    it_func_ptr = tmp_3;
    
#line 133 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50831: 
#line 135 
      ;
      
#line 133 
      it_func = it_func_ptr->func;
      
#line 133 
      __data = it_func_ptr->data;
      
#line 133 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,index,value);
      
#line 133 
      it_func_ptr += 1;
      
#line 133 
      ;
      
#line 133 
      if (it_func_ptr->func != (void *)0) 
#line 135 
                                          goto ldv_50831; else 
#line 138 
                                                               goto ldv_50832;
      ldv_50832: 
#line 139 
      ;
    }
    else ;
    
#line 133 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 133 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_401 __u_0;
        
#line 133 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ict_read.funcs),(void *)(& __u_0.__c),8);
        
#line 133 
        tmp_5 = __u_0.__val;
      }
      
#line 133 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 133 
      tmp_6 = _________p1_0;
    }
    
#line 133 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 133 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 133 
      if (tmp_7 != 0) {
        
#line 133 
        if (! __warned_0) {
          int tmp_8;
          
#line 133 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 133 
          if (tmp_8 == 0) {
            
#line 133 
            __warned_0 = (_Bool)1;
            
#line 133 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",148,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 133 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 133 
  rcu_read_unlock_sched_notrace();
  
#line 135 
  return;
}


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
struct tracepoint __tracepoint_iwlwifi_dev_rx_data;


#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
__inline static void trace_iwlwifi_dev_rx_data(struct device const *dev, struct iwl_trans const *trans, void *rxbuf, size_t len)
{
  bool tmp_4;
  
#line 53 
  tmp_4 = static_key_false(& __tracepoint_iwlwifi_dev_rx_data.key);
  
#line 53 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 53 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_435 __u;
          
#line 53 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_rx_data.funcs),(void *)(& __u.__c),8);
          
#line 53 
          tmp = __u.__val;
        }
        
#line 53 
        struct tracepoint_func *_________p1 = tmp;
        
#line 53 
        tmp_0 = _________p1;
      }
      
#line 53 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 53 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 53 
        if (tmp_1 != 0) {
          
#line 53 
          if (! __warned) {
            int tmp_2;
            
#line 53 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 53 
            if (tmp_2 == 0) {
              
#line 53 
              __warned = (_Bool)1;
              
#line 53 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-data.h",72,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 53 
      tmp_3 = ________p1;
    }
    
#line 53 
    it_func_ptr = tmp_3;
    
#line 53 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_51362: 
#line 55 
      ;
      
#line 53 
      it_func = it_func_ptr->func;
      
#line 53 
      __data = it_func_ptr->data;
      
#line 53 
      (*((void (*)(void *, struct device const *, struct iwl_trans const *, void *, size_t ))it_func))(__data,dev,trans,rxbuf,len);
      
#line 53 
      it_func_ptr += 1;
      
#line 53 
      ;
      
#line 53 
      if (it_func_ptr->func != (void *)0) 
#line 55 
                                          goto ldv_51362; else 
#line 58 
                                                               goto ldv_51363;
      ldv_51363: 
#line 59 
      ;
    }
    else ;
    
#line 53 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 53 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_437 __u_0;
        
#line 53 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_rx_data.funcs),(void *)(& __u_0.__c),8);
        
#line 53 
        tmp_5 = __u_0.__val;
      }
      
#line 53 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 53 
      tmp_6 = _________p1_0;
    }
    
#line 53 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 53 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 53 
      if (tmp_7 != 0) {
        
#line 53 
        if (! __warned_0) {
          int tmp_8;
          
#line 53 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 53 
          if (tmp_8 == 0) {
            
#line 53 
            __warned_0 = (_Bool)1;
            
#line 53 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-data.h",72,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 53 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 53 
  rcu_read_unlock_sched_notrace();
  
#line 55 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
struct tracepoint __tracepoint_iwlwifi_dev_rx;


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
__inline static void trace_iwlwifi_dev_rx(struct device const *dev, struct iwl_trans const *trans, struct iwl_rx_packet *pkt, size_t len)
{
  bool tmp_4;
  
#line 66 
  tmp_4 = static_key_false(& __tracepoint_iwlwifi_dev_rx.key);
  
#line 66 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 66 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_443 __u;
          
#line 66 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_rx.funcs),(void *)(& __u.__c),8);
          
#line 66 
          tmp = __u.__val;
        }
        
#line 66 
        struct tracepoint_func *_________p1 = tmp;
        
#line 66 
        tmp_0 = _________p1;
      }
      
#line 66 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 66 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 66 
        if (tmp_1 != 0) {
          
#line 66 
          if (! __warned) {
            int tmp_2;
            
#line 66 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 66 
            if (tmp_2 == 0) {
              
#line 66 
              __warned = (_Bool)1;
              
#line 66 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h",83,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 66 
      tmp_3 = ________p1;
    }
    
#line 66 
    it_func_ptr = tmp_3;
    
#line 66 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_51494: 
#line 68 
      ;
      
#line 66 
      it_func = it_func_ptr->func;
      
#line 66 
      __data = it_func_ptr->data;
      
#line 66 
      (*((void (*)(void *, struct device const *, struct iwl_trans const *, struct iwl_rx_packet *, size_t ))it_func))(__data,dev,trans,pkt,len);
      
#line 66 
      it_func_ptr += 1;
      
#line 66 
      ;
      
#line 66 
      if (it_func_ptr->func != (void *)0) 
#line 68 
                                          goto ldv_51494; else 
#line 71 
                                                               goto ldv_51495;
      ldv_51495: 
#line 72 
      ;
    }
    else ;
    
#line 66 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 66 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_445 __u_0;
        
#line 66 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_rx.funcs),(void *)(& __u_0.__c),8);
        
#line 66 
        tmp_5 = __u_0.__val;
      }
      
#line 66 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 66 
      tmp_6 = _________p1_0;
    }
    
#line 66 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 66 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 66 
      if (tmp_7 != 0) {
        
#line 66 
        if (! __warned_0) {
          int tmp_8;
          
#line 66 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 66 
          if (tmp_8 == 0) {
            
#line 66 
            __warned_0 = (_Bool)1;
            
#line 66 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h",83,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 66 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 66 
  rcu_read_unlock_sched_notrace();
  
#line 68 
  return;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_write8(struct iwl_trans *trans, u32 ofs, u8 val)
{
  
#line 37 
  trace_iwlwifi_dev_iowrite8((struct device const *)trans->dev,ofs,(unsigned char)((int)val));
  
#line 38 
  iwl_trans_write8(trans,ofs,(unsigned char)((int)val));
  
#line 39 
  return;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_write32(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 43 
  trace_iwlwifi_dev_iowrite32((struct device const *)trans->dev,ofs,val);
  
#line 44 
  iwl_trans_write32(trans,ofs,val);
  
#line 45 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static u32 iwl_read32(struct iwl_trans *trans, u32 ofs)
{
  
#line 49 
  u32 val = iwl_trans_read32(trans,ofs);
  
#line 50 
  trace_iwlwifi_dev_ioread32((struct device const *)trans->dev,ofs,val);
  
#line 51 
  return val;
}


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_set_bit(struct iwl_trans *trans, u32 reg, u32 mask)
{
  
#line 56 
  iwl_trans_set_bits_mask(trans,reg,mask,mask);
  
#line 57 
  return;
}


#line 66 
int iwl_poll_direct_bit(struct iwl_trans *trans, u32 addr, u32 mask, int timeout);


#line 70 
void iwl_write_direct32(struct iwl_trans *trans, u32 reg, u32 value);


#line 74 
u32 iwl_read_prph(struct iwl_trans *trans, u32 ofs);


#line 86 
int iwl_dump_fh(struct iwl_trans *trans, char **buf);


#line 357  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
int iwl_pcie_rx_init(struct iwl_trans *trans);


#line 358 
irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id);


#line 359 
int iwl_pcie_rx_stop(struct iwl_trans *trans);


#line 360 
void iwl_pcie_rx_free(struct iwl_trans *trans);


#line 365 
irqreturn_t iwl_pcie_isr(int irq, void *data);


#line 366 
int iwl_pcie_alloc_ict(struct iwl_trans *trans);


#line 367 
void iwl_pcie_free_ict(struct iwl_trans *trans);


#line 368 
void iwl_pcie_reset_ict(struct iwl_trans *trans);


#line 369 
void iwl_pcie_disable_ict(struct iwl_trans *trans);


#line 385 
void iwl_pcie_txq_check_wrptrs(struct iwl_trans *trans);


#line 387 
void iwl_pcie_hcmd_complete(struct iwl_trans *trans, struct iwl_rx_cmd_buffer *rxb, int handler_status);


#line 406 
void iwl_pcie_dump_csr(struct iwl_trans *trans);


#line 422 
void __compiletime_assert_422(void);


#line 411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_disable_interrupts(struct iwl_trans *trans)
{
  
#line 413 
  set_bit(3L,(unsigned long volatile *)(& trans->status));
  
#line 416 
  iwl_write32(trans,12U,0U);
  
#line 420 
  iwl_write32(trans,8U,4294967295U);
  
#line 421 
  iwl_write32(trans,16U,4294967295U);
  {
    
#line 422 
    bool __cond = (_Bool)((int)*("Disabled interrupts\n" + 19UL) != 10);
    
#line 422 
    if ((int)__cond != 0) 
#line 422 
                          __compiletime_assert_422(); else ;
  }
  
#line 422 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_disable_interrupts","Disabled interrupts\n");
  
#line 423 
  return;
}


#line 429 
void __compiletime_assert_429(void);


#line 425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_enable_interrupts(struct iwl_trans *trans)
{
  
#line 427 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    
#line 429 
    bool __cond = (_Bool)((int)*("Enabling interrupts\n" + 19UL) != 10);
    
#line 429 
    if ((int)__cond != 0) 
#line 429 
                          __compiletime_assert_429(); else ;
  }
  
#line 429 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_enable_interrupts","Enabling interrupts\n");
  
#line 430 
  set_bit(3L,(unsigned long volatile *)(& trans->status));
  
#line 431 
  trans_pcie->inta_mask = 3120562315U;
  
#line 432 
  iwl_write32(trans,12U,trans_pcie->inta_mask);
  
#line 433 
  return;
}


#line 439 
void __compiletime_assert_439(void);


#line 435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_enable_rfkill_int(struct iwl_trans *trans)
{
  
#line 437 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    
#line 439 
    bool __cond = (_Bool)((int)*("Enabling rfkill interrupt\n" + 25UL) != 10);
    
#line 439 
    if ((int)__cond != 0) 
#line 439 
                          __compiletime_assert_439(); else ;
  }
  
#line 439 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_enable_rfkill_int","Enabling rfkill interrupt\n");
  
#line 440 
  trans_pcie->inta_mask = 128U;
  
#line 441 
  iwl_write32(trans,12U,trans_pcie->inta_mask);
  
#line 442 
  return;
}


#line 475  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static u8 get_cmd_index(struct iwl_queue *q, u32 index)
{
  u8 __retres;
  
#line 477 
  __retres = (unsigned char)(((unsigned int)((unsigned char)q->n_window) + 255U) & (unsigned int)((unsigned char)index));
  
#line 477 
  return __retres;
}


#line 480  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static char const *get_cmd_string(struct iwl_trans_pcie *trans_pcie, u8 cmd)
{
  char const *__retres;
  
#line 483 
  if (trans_pcie->command_names == (char const * const *)0 || *(trans_pcie->command_names + (int)cmd) == (char const *)0) {
    
#line 484 
    __retres = "UNKNOWN";
    
#line 484 
    goto return_label;
  }
  else ;
  
#line 485 
  __retres = *(trans_pcie->command_names + (int)cmd);
  return_label: 
#line 485 
                return __retres;
}


#line 488  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static bool iwl_is_rfkill_set(struct iwl_trans *trans)
{
  bool __retres;
  u32 tmp;
  
#line 490 
  tmp = iwl_read32(trans,36U);
  
#line 490 
  __retres = (_Bool)((tmp & 134217728U) == 0U);
  
#line 490 
  return __retres;
}


#line 521 
void iwl_trans_pcie_rf_kill(struct iwl_trans *trans, bool state);


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static int iwl_rxq_space(struct iwl_rxq const *rxq)
{
  int __retres;
  {
    
#line 117 
    bool __cond = (_Bool)0;
    
#line 117 
    if ((int)__cond != 0) 
#line 117 
                          __compiletime_assert_117(); else ;
  }
  
#line 125 
  __retres = (int)((rxq->read - rxq->write) + 4294967295U) & 255;
  
#line 125 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
__inline static __le32 iwl_pcie_dma_addr2rbd_ptr(dma_addr_t dma_addr)
{
  __le32 __retres;
  
#line 133 
  __retres = (unsigned int)(dma_addr >> 8);
  
#line 133 
  return __retres;
}


#line 139  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
int iwl_pcie_rx_stop(struct iwl_trans *trans)
{
  int tmp;
  
#line 141 
  iwl_write_direct32(trans,7168U,0U);
  
#line 142 
  tmp = iwl_poll_direct_bit(trans,7236U,16777216U,1000);
  
#line 142 
  return tmp;
}


#line 167 
void __compiletime_assert_168(void);


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rxq_inc_wr_ptr(struct iwl_trans *trans)
{
  u32 reg;
  
#line 151 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 152 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  {
    int tmp_0;
    
#line 155 
    if (debug_locks != 0) {
      int tmp;
      
#line 155 
      tmp = lock_is_held(& rxq->lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 155 
      if (tmp == 0) 
#line 155 
                    tmp_0 = 1; else 
#line 155 
                                    tmp_0 = 0;
    }
    else 
#line 155 
         tmp_0 = 0;
    
#line 155 
    int __ret_warn_on = tmp_0;
    
#line 155 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 155 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c",155); else ;
    
#line 155 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 162 
  if (! ((trans->cfg)->base_params)->shadow_reg_enable) {
    int tmp_1;
    
#line 162 
    tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& trans->status));
    
#line 162 
    if (tmp_1 != 0) {
      
#line 164 
      reg = iwl_read32(trans,84U);
      
#line 166 
      if ((reg & 1U) != 0U) {
        {
          
#line 167 
          bool __cond = (_Bool)((int)*("Rx queue requesting wakeup, GP1 = 0x%x\n" + 38UL) != 10);
          
#line 167 
          if ((int)__cond != 0) 
#line 167 
                                __compiletime_assert_168(); else ;
        }
        
#line 167 
        __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_rxq_inc_wr_ptr","Rx queue requesting wakeup, GP1 = 0x%x\n",reg);
        
#line 169 
        iwl_set_bit(trans,36U,8U);
        
#line 171 
        rxq->need_update = (_Bool)1;
        
#line 172 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  
#line 176 
  rxq->write_actual = rxq->write & 4294967288U;
  
#line 177 
  iwl_write32(trans,7112U,rxq->write_actual);
  return_label: 
#line 178 
                return;
}


#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rxq_check_wrptr(struct iwl_trans *trans)
{
  
#line 182 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 183 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 185 
  ldv_spin_lock_73(& rxq->lock);
  
#line 187 
  if (! rxq->need_update) 
#line 188 
                          goto exit_unlock; else ;
  
#line 190 
  iwl_pcie_rxq_inc_wr_ptr(trans);
  
#line 191 
  rxq->need_update = (_Bool)0;
  exit_unlock: 
#line 193 
  ;
  
#line 194 
  ldv_spin_unlock_74(& rxq->lock);
  
#line 195 
  return;
}


#line 208  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rxq_restock(struct iwl_trans *trans)
{
  struct iwl_rx_mem_buffer *rxb;
  int tmp;
  struct iwl_rx_mem_buffer *tmp_0;
  int tmp_1;
  
#line 210 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 211 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 222 
  tmp = constant_test_bit(1L,(unsigned long const volatile *)(& trans->status));
  
#line 222 
  if (tmp == 0) 
#line 223 
                goto return_label; else ;
  
#line 225 
  ldv_spin_lock_75(& rxq->lock);
  
#line 226 
  goto ldv_53909;
  ldv_53908: 
#line 227 
  ;
  
#line 228 
  rxb = rxq->queue[rxq->write];
  
#line 229 
  if ((long)(rxb != (struct iwl_rx_mem_buffer *)0) != 0L && (long)(rxb->page != (struct page *)0) != 0L) {
    
#line 231 
    ldv_inline_asm();
    
#line 229 
    ;
  }
  else ;
  {
    
#line 232 
    struct list_head const *__mptr = (struct list_head const *)rxq->rx_free.next;
    
#line 232 
    tmp_0 = (struct iwl_rx_mem_buffer *)__mptr + 18446744073709551600U;
  }
  
#line 232 
  rxb = tmp_0;
  
#line 234 
  list_del(& rxb->list);
  
#line 237 
  *(rxq->bd + rxq->write) = iwl_pcie_dma_addr2rbd_ptr(rxb->page_dma);
  
#line 238 
  rxq->queue[rxq->write] = rxb;
  
#line 239 
  rxq->write = (rxq->write + 1U) & 255U;
  
#line 240 
  rxq->free_count -= 1U;
  ldv_53909: 
#line 241 
  ;
  
#line 226 
  tmp_1 = iwl_rxq_space((struct iwl_rxq const *)rxq);
  
#line 226 
  if (tmp_1 > 0) {
    
#line 226 
    if (rxq->free_count != 0U) 
#line 228 
                               goto ldv_53908; else 
#line 231 
                                                    goto ldv_53910;
  }
  else 
#line 231 
       goto ldv_53910;
  ldv_53910: 
#line 232 
  ;
  
#line 242 
  ldv_spin_unlock_76(& rxq->lock);
  
#line 245 
  if (rxq->free_count <= 8U) 
#line 246 
                             ldv_schedule_work_77(& trans_pcie->rx_replenish); else ;
  
#line 250 
  if (rxq->write_actual != (rxq->write & 4294967288U)) {
    
#line 251 
    ldv_spin_lock_78(& rxq->lock);
    
#line 252 
    iwl_pcie_rxq_inc_wr_ptr(trans);
    
#line 253 
    ldv_spin_unlock_79(& rxq->lock);
  }
  else ;
  return_label: 
#line 255 
                return;
}


#line 292 
void __compiletime_assert_294(void);


#line 298 
void __compiletime_assert_302(void);


#line 266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
{
  struct iwl_rx_mem_buffer *rxb;
  struct page *page;
  int tmp;
  int tmp_3;
  struct iwl_rx_mem_buffer *tmp_4;
  int tmp_5;
  
#line 268 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 269 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 272 
  gfp_t gfp_mask = priority;
  ldv_53931: 
#line 273 
  ;
  
#line 275 
  ldv_spin_lock_80(& rxq->lock);
  
#line 276 
  tmp = list_empty((struct list_head const *)(& rxq->rx_used));
  
#line 276 
  if (tmp != 0) {
    
#line 277 
    ldv_spin_unlock_81(& rxq->lock);
    
#line 278 
    goto return_label;
  }
  else ;
  
#line 280 
  ldv_spin_unlock_82(& rxq->lock);
  
#line 282 
  if (rxq->free_count > 8U) 
#line 283 
                            gfp_mask |= 512U; else ;
  
#line 285 
  if (trans_pcie->rx_page_order != 0U) 
#line 286 
                                       gfp_mask |= 16384U; else ;
  
#line 289 
  page = alloc_pages(gfp_mask,trans_pcie->rx_page_order);
  
#line 290 
  if (page == (struct page *)0) {
    int tmp_0;
    
#line 291 
    tmp_0 = net_ratelimit();
    
#line 291 
    if (tmp_0 != 0) {
      {
        
#line 292 
        bool __cond = (_Bool)((int)*("alloc_pages failed, " + 29UL) != 10);
        
#line 292 
        if ((int)__cond != 0) 
#line 292 
                              __compiletime_assert_294(); else ;
      }
      
#line 292 
      __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_rxq_alloc_rbs","alloc_pages failed, ",trans_pcie->rx_page_order);
    }
    else ;
    
#line 296 
    if (rxq->free_count <= 8U) {
      int tmp_2;
      
#line 296 
      tmp_2 = net_ratelimit();
      
#line 296 
      if (tmp_2 != 0) {
        char *tmp_1;
        {
          
#line 298 
          bool __cond_0 = (_Bool)((int)*("Failed to alloc_pages with %s." + 61UL) != 10);
          
#line 298 
          if ((int)__cond_0 != 0) 
#line 298 
                                  __compiletime_assert_302(); else ;
        }
        
#line 298 
        ;
        
#line 298 
        if (priority == 32U) 
#line 298 
                             tmp_1 = (char *)"GFP_ATOMIC"; else 
#line 298 
                                                                tmp_1 = (char *)"GFP_KERNEL";
        
#line 298 
        ;
        
#line 298 
        __iwl_crit(trans->dev,"Failed to alloc_pages with %s.",tmp_1,rxq->free_count);
      }
      else ;
    }
    else ;
    
#line 306 
    goto return_label;
  }
  else ;
  
#line 309 
  ldv_spin_lock_83(& rxq->lock);
  
#line 311 
  tmp_3 = list_empty((struct list_head const *)(& rxq->rx_used));
  
#line 311 
  if (tmp_3 != 0) {
    
#line 312 
    ldv_spin_unlock_84(& rxq->lock);
    
#line 313 
    __free_pages(page,trans_pcie->rx_page_order);
    
#line 314 
    goto return_label;
  }
  else ;
  {
    
#line 316 
    struct list_head const *__mptr = (struct list_head const *)rxq->rx_used.next;
    
#line 316 
    tmp_4 = (struct iwl_rx_mem_buffer *)__mptr + 18446744073709551600U;
  }
  
#line 316 
  rxb = tmp_4;
  
#line 318 
  list_del(& rxb->list);
  
#line 319 
  ldv_spin_unlock_85(& rxq->lock);
  
#line 321 
  if ((long)(rxb->page != (struct page *)0) != 0L) {
    
#line 323 
    ldv_inline_asm();
    
#line 321 
    ;
  }
  else ;
  
#line 322 
  rxb->page = page;
  
#line 324 
  rxb->page_dma = dma_map_page(trans->dev,page,0UL,4096UL << trans_pcie->rx_page_order,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 328 
  tmp_5 = dma_mapping_error(trans->dev,rxb->page_dma);
  
#line 328 
  if (tmp_5 != 0) {
    
#line 329 
    rxb->page = (struct page *)0;
    
#line 330 
    ldv_spin_lock_86(& rxq->lock);
    
#line 331 
    list_add(& rxb->list,& rxq->rx_used);
    
#line 332 
    ldv_spin_unlock_87(& rxq->lock);
    
#line 333 
    __free_pages(page,trans_pcie->rx_page_order);
    
#line 334 
    goto return_label;
  }
  else ;
  
#line 337 
  if ((long)((rxb->page_dma & 18446744004990074880ULL) != 0ULL) != 0L) {
    
#line 339 
    ldv_inline_asm();
    
#line 337 
    ;
  }
  else ;
  
#line 339 
  if ((long)((rxb->page_dma & 255ULL) != 0ULL) != 0L) {
    
#line 341 
    ldv_inline_asm();
    
#line 339 
    ;
  }
  else ;
  
#line 341 
  ldv_spin_lock_88(& rxq->lock);
  
#line 343 
  list_add_tail(& rxb->list,& rxq->rx_free);
  
#line 344 
  rxq->free_count += 1U;
  
#line 346 
  ldv_spin_unlock_89(& rxq->lock);
  
#line 275 
  goto ldv_53931;
  return_label: 
#line 275 
                return;
}


#line 350  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rxq_free_rbs(struct iwl_trans *trans)
{
  int i;
  
#line 352 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 353 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  {
    int tmp_0;
    
#line 356 
    if (debug_locks != 0) {
      int tmp;
      
#line 356 
      tmp = lock_is_held(& rxq->lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 356 
      if (tmp == 0) 
#line 356 
                    tmp_0 = 1; else 
#line 356 
                                    tmp_0 = 0;
    }
    else 
#line 356 
         tmp_0 = 0;
    
#line 356 
    int __ret_warn_on = tmp_0;
    
#line 356 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 356 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c",356); else ;
    
#line 356 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 358 
  i = 0;
  
#line 358 
  goto ldv_53942;
  ldv_53941: 
#line 359 
  ;
  
#line 359 
  if (rxq->pool[i].page == (struct page *)0) 
#line 360 
                                             goto ldv_53940; else ;
  
#line 361 
  dma_unmap_page(trans->dev,rxq->pool[i].page_dma,4096UL << trans_pcie->rx_page_order,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 364 
  __free_pages(rxq->pool[i].page,trans_pcie->rx_page_order);
  
#line 365 
  rxq->pool[i].page = (struct page *)0;
  ldv_53940: 
#line 366 
  ;
  
#line 358 
  i += 1;
  ldv_53942: 
#line 359 
  ;
  
#line 358 
  if (i <= 319) 
#line 360 
                goto ldv_53941; else 
#line 363 
                                     goto ldv_53943;
  ldv_53943: 
#line 364 
  ;
  
#line 365 
  return;
}


#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rx_replenish(struct iwl_trans *trans, gfp_t gfp)
{
  
#line 379 
  iwl_pcie_rxq_alloc_rbs(trans,gfp);
  
#line 381 
  iwl_pcie_rxq_restock(trans);
  
#line 382 
  return;
}


#line 384  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rx_replenish_work(struct work_struct *data)
{
  struct iwl_trans_pcie *tmp;
  {
    
#line 387 
    struct work_struct const *__mptr = (struct work_struct const *)data;
    
#line 387 
    tmp = (struct iwl_trans_pcie *)__mptr + 18446744073709539168U;
  }
  
#line 386 
  struct iwl_trans_pcie *trans_pcie = tmp;
  
#line 389 
  iwl_pcie_rx_replenish(trans_pcie->trans,208U);
  
#line 390 
  return;
}


#line 392  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static int iwl_pcie_rx_alloc(struct iwl_trans *trans)
{
  int __retres;
  int tmp;
  
#line 394 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 395 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 396 
  struct device *dev = trans->dev;
  
#line 398 
  memset((void *)(& trans_pcie->rxq),0,12448UL);
  
#line 400 
  spinlock_check(& rxq->lock);
  {
    struct lock_class_key __key;
    
#line 400 
    __raw_spin_lock_init(& rxq->lock.__anonCompField_spinlock_18.rlock,"&(&rxq->lock)->rlock",& __key);
  }
  {
    
#line 402 
    int __ret_warn_on = (rxq->bd != (__le32 *)0U || rxq->rb_stts != (struct iwl_rb_status *)0) != 0;
    
#line 402 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 402 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c",402); else ;
    
#line 402 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 402 
  if ((long)tmp != 0L) {
    
#line 403 
    __retres = -22;
    
#line 403 
    goto return_label;
  }
  else ;
  
#line 406 
  rxq->bd = (__le32 *)dma_zalloc_coherent(dev,1024UL,& rxq->bd_dma,208U);
  
#line 408 
  if (rxq->bd == (__le32 *)0U) 
#line 409 
                               goto err_bd; else ;
  
#line 412 
  rxq->rb_stts = (struct iwl_rb_status *)dma_zalloc_coherent(dev,12UL,& rxq->rb_stts_dma,208U);
  
#line 414 
  if (rxq->rb_stts == (struct iwl_rb_status *)0) 
#line 415 
                                                 goto err_rb_stts; else ;
  
#line 417 
  __retres = 0;
  
#line 417 
  goto return_label;
  err_rb_stts: 
#line 419 
  ;
  
#line 420 
  dma_free_attrs(dev,1024UL,(void *)rxq->bd,rxq->bd_dma,(struct dma_attrs *)0);
  
#line 422 
  rxq->bd_dma = 0ULL;
  
#line 423 
  rxq->bd = (__le32 *)0U;
  err_bd: 
#line 424 
  ;
  
#line 425 
  __retres = -12;
  return_label: 
#line 425 
                return __retres;
}


#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rx_hw_init(struct iwl_trans *trans, struct iwl_rxq *rxq)
{
  u32 rb_size;
  
#line 430 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 432 
  u32 const rfdnlog = 8U;
  
#line 434 
  if ((int)trans_pcie->rx_buf_size_8k != 0) 
#line 435 
                                            rb_size = 65536U; else 
#line 437 
                                                                   rb_size = 0U;
  
#line 440 
  iwl_write_direct32(trans,7168U,0U);
  
#line 442 
  iwl_write_direct32(trans,7176U,0U);
  
#line 443 
  iwl_write_direct32(trans,7184U,0U);
  
#line 444 
  iwl_write_direct32(trans,7116U,0U);
  
#line 447 
  iwl_write_direct32(trans,7112U,0U);
  
#line 450 
  iwl_write_direct32(trans,7108U,(unsigned int)(rxq->bd_dma >> 8));
  
#line 454 
  iwl_write_direct32(trans,7104U,(unsigned int)(rxq->rb_stts_dma >> 4));
  
#line 465 
  iwl_write_direct32(trans,7168U,rb_size | 2155876628U);
  
#line 474 
  iwl_write8(trans,4U,(unsigned char)64);
  
#line 477 
  if ((int)(trans->cfg)->host_interrupt_operation_mode != 0) 
#line 478 
                                                             iwl_set_bit(trans,4U,2147483648U); else ;
  
#line 479 
  return;
}


#line 481  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rx_init_rxb_lists(struct iwl_rxq *rxq)
{
  int i;
  {
    int tmp_0;
    
#line 485 
    if (debug_locks != 0) {
      int tmp;
      
#line 485 
      tmp = lock_is_held(& rxq->lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 485 
      if (tmp == 0) 
#line 485 
                    tmp_0 = 1; else 
#line 485 
                                    tmp_0 = 0;
    }
    else 
#line 485 
         tmp_0 = 0;
    
#line 485 
    int __ret_warn_on = tmp_0;
    
#line 485 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 485 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c",485); else ;
    
#line 485 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 487 
  INIT_LIST_HEAD(& rxq->rx_free);
  
#line 488 
  INIT_LIST_HEAD(& rxq->rx_used);
  
#line 489 
  rxq->free_count = 0U;
  
#line 491 
  i = 0;
  
#line 491 
  goto ldv_53979;
  ldv_53978: 
#line 492 
  ;
  
#line 492 
  list_add(& rxq->pool[i].list,& rxq->rx_used);
  
#line 491 
  i += 1;
  ldv_53979: 
#line 492 
  ;
  
#line 491 
  if (i <= 319) 
#line 493 
                goto ldv_53978; else 
#line 496 
                                     goto ldv_53980;
  ldv_53980: 
#line 497 
  ;
  
#line 498 
  return;
}


#line 495  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
int iwl_pcie_rx_init(struct iwl_trans *trans)
{
  int __retres;
  int i;
  int err;
  u32 tmp;
  
#line 497 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 498 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 501 
  if (rxq->bd == (__le32 *)0U) {
    
#line 502 
    err = iwl_pcie_rx_alloc(trans);
    
#line 503 
    if (err != 0) {
      
#line 504 
      __retres = err;
      
#line 504 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 507 
  ldv_spin_lock_90(& rxq->lock);
  {
    struct lock_class_key __key;
    
#line 509 
    __init_work(& trans_pcie->rx_replenish,0);
    
#line 509 
    atomic_long_t __constr_expr_37 = {.counter = WORK_STRUCT_NO_POOL};
    
#line 509 
    trans_pcie->rx_replenish.data = __constr_expr_37;
    
#line 509 
    lockdep_init_map(& trans_pcie->rx_replenish.lockdep_map,"(&trans_pcie->rx_replenish)",& __key,0);
    
#line 509 
    INIT_LIST_HEAD(& trans_pcie->rx_replenish.entry);
    
#line 509 
    trans_pcie->rx_replenish.func = & iwl_pcie_rx_replenish_work;
  }
  
#line 512 
  iwl_pcie_rxq_free_rbs(trans);
  
#line 513 
  iwl_pcie_rx_init_rxb_lists(rxq);
  
#line 515 
  i = 0;
  
#line 515 
  goto ldv_53991;
  ldv_53990: 
#line 516 
  ;
  
#line 516 
  rxq->queue[i] = (struct iwl_rx_mem_buffer *)0;
  
#line 515 
  i += 1;
  ldv_53991: 
#line 516 
  ;
  
#line 515 
  if (i <= 255) 
#line 517 
                goto ldv_53990; else 
#line 520 
                                     goto ldv_53992;
  ldv_53992: 
#line 521 
  ;
  
#line 520 
  tmp = 0U;
  
#line 520 
  rxq->write = tmp;
  
#line 520 
  rxq->read = tmp;
  
#line 521 
  rxq->write_actual = 0U;
  
#line 522 
  memset((void *)rxq->rb_stts,0,12UL);
  
#line 523 
  ldv_spin_unlock_91(& rxq->lock);
  
#line 525 
  iwl_pcie_rx_replenish(trans,208U);
  
#line 527 
  iwl_pcie_rx_hw_init(trans,rxq);
  
#line 529 
  ldv_spin_lock_92(& rxq->lock);
  
#line 530 
  iwl_pcie_rxq_inc_wr_ptr(trans);
  
#line 531 
  ldv_spin_unlock_93(& rxq->lock);
  
#line 533 
  __retres = 0;
  return_label: 
#line 533 
                return __retres;
}


#line 544 
void __compiletime_assert_544(void);


#line 564 
void __compiletime_assert_564(void);


#line 536  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
void iwl_pcie_rx_free(struct iwl_trans *trans)
{
  
#line 538 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 539 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 543 
  if (rxq->bd == (__le32 *)0U) {
    {
      
#line 544 
      bool __cond = (_Bool)((int)*("Free NULL rx context\n" + 20UL) != 10);
      
#line 544 
      if ((int)__cond != 0) 
#line 544 
                            __compiletime_assert_544(); else ;
    }
    
#line 544 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_rx_free","Free NULL rx context\n");
    
#line 545 
    goto return_label;
  }
  else ;
  
#line 548 
  cancel_work_sync(& trans_pcie->rx_replenish);
  
#line 550 
  ldv_spin_lock_94(& rxq->lock);
  
#line 551 
  iwl_pcie_rxq_free_rbs(trans);
  
#line 552 
  ldv_spin_unlock_95(& rxq->lock);
  
#line 554 
  dma_free_attrs(trans->dev,1024UL,(void *)rxq->bd,rxq->bd_dma,(struct dma_attrs *)0);
  
#line 556 
  rxq->bd_dma = 0ULL;
  
#line 557 
  rxq->bd = (__le32 *)0U;
  
#line 559 
  if (rxq->rb_stts != (struct iwl_rb_status *)0) 
#line 560 
                                                 dma_free_attrs(trans->dev,12UL,(void *)rxq->rb_stts,rxq->rb_stts_dma,(struct dma_attrs *)0);
  else {
    {
      
#line 564 
      bool __cond_0 = (_Bool)((int)*("Free rxq->rb_stts which is NULL\n" + 31UL) != 10);
      
#line 564 
      if ((int)__cond_0 != 0) 
#line 564 
                              __compiletime_assert_564(); else ;
    }
    
#line 564 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_rx_free","Free rxq->rb_stts which is NULL\n");
  }
  
#line 565 
  rxq->rb_stts_dma = 0ULL;
  
#line 566 
  rxq->rb_stts = (struct iwl_rb_status *)0;
  return_label: 
#line 567 
                return;
}


#line 603 
void __compiletime_assert_607(void);


#line 662 
void __compiletime_assert_662(void);


#line 569  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rx_handle_rb(struct iwl_trans *trans, struct iwl_rx_mem_buffer *rxb)
{
  int tmp;
  
#line 572 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 573 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 574 
  struct iwl_txq *txq = trans_pcie->txq + (int)trans_pcie->cmd_queue;
  
#line 575 
  bool page_stolen = (_Bool)0;
  
#line 576 
  int max_len = (int)(4096UL << trans_pcie->rx_page_order);
  
#line 577 
  u32 offset = 0U;
  {
    
#line 579 
    int __ret_warn_on = rxb == (struct iwl_rx_mem_buffer *)0;
    
#line 579 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 579 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c",579); else ;
    
#line 579 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 579 
  if ((long)tmp != 0L) 
#line 580 
                       goto return_label; else ;
  
#line 582 
  dma_unmap_page(trans->dev,rxb->page_dma,(unsigned long)max_len,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 584 
  goto ldv_54043;
  ldv_54042: 
#line 585 
  ;
  {
    struct iwl_rx_packet *pkt;
    struct iwl_device_cmd *cmd;
    u16 sequence;
    bool reclaim;
    int index;
    int cmd_index;
    int err;
    int len;
    char const *tmp_1;
    u32 tmp_2;
    u8 tmp_3;
    
#line 590 
    struct iwl_rx_cmd_buffer rxcb = {._page = rxb->page, ._offset = (int)offset, ._page_stolen = (_Bool)0, ._rx_page_order = trans_pcie->rx_page_order, .truesize = (unsigned int)max_len};
    
#line 598 
    pkt = (struct iwl_rx_packet *)rxb_addr(& rxcb);
    
#line 600 
    if (pkt->len_n_flags == 1431633920U) 
#line 601 
                                         goto ldv_54028; else ;
    {
      
#line 603 
      bool __cond = (_Bool)((int)*("cmd at offset %d: %s (0x%.2x, seq 0x%x)\n" + 39UL) != 10);
      
#line 603 
      if ((int)__cond != 0) 
#line 603 
                            __compiletime_assert_607(); else ;
    }
    
#line 603 
    ;
    
#line 603 
    ;
    
#line 603 
    tmp_1 = get_cmd_string(trans_pcie,(unsigned char)((int)pkt->hdr.cmd));
    
#line 603 
    ;
    
#line 603 
    ;
    
#line 603 
    __iwl_dbg(trans->dev,16777216U,(_Bool)0,"iwl_pcie_rx_handle_rb","cmd at offset %d: %s (0x%.2x, seq 0x%x)\n",rxcb._offset,tmp_1,(int)pkt->hdr.cmd,(int)pkt->hdr.sequence);
    
#line 609 
    tmp_2 = iwl_rx_packet_len((struct iwl_rx_packet const *)pkt);
    
#line 609 
    len = (int)tmp_2;
    
#line 610 
    len = (int)((unsigned int)len + 4U);
    
#line 611 
    trace_iwlwifi_dev_rx((struct device const *)trans->dev,(struct iwl_trans const *)trans,pkt,(unsigned long)len);
    
#line 612 
    trace_iwlwifi_dev_rx_data((struct device const *)trans->dev,(struct iwl_trans const *)trans,(void *)pkt,(unsigned long)len);
    
#line 620 
    reclaim = (_Bool)((int)pkt->hdr.sequence >= 0);
    
#line 621 
    if ((int)reclaim != 0) {
      int i;
      
#line 624 
      i = 0;
      
#line 624 
      goto ldv_54037;
      ldv_54036: 
#line 625 
      ;
      
#line 625 
      if ((int)trans_pcie->no_reclaim_cmds[i] == (int)pkt->hdr.cmd) {
        
#line 627 
        reclaim = (_Bool)0;
        
#line 628 
        goto ldv_54035;
      }
      else ;
      
#line 624 
      i += 1;
      ldv_54037: 
#line 625 
      ;
      
#line 624 
      if ((int)trans_pcie->n_no_reclaim_cmds > i) 
#line 626 
                                                  goto ldv_54036; else 
                                                                    
#line 629 
                                                                    goto ldv_54035;
      ldv_54035: 
#line 630 
      ;
    }
    else ;
    
#line 633 
    sequence = pkt->hdr.sequence;
    
#line 634 
    index = (int)sequence & 255;
    
#line 635 
    tmp_3 = get_cmd_index(& txq->q,(unsigned int)index);
    
#line 635 
    cmd_index = (int)tmp_3;
    
#line 637 
    if ((int)reclaim != 0) 
#line 638 
                           cmd = (txq->entries + cmd_index)->cmd; else 
                                                                    
#line 640 
                                                                    cmd = (struct iwl_device_cmd *)0;
    
#line 642 
    err = iwl_op_mode_rx(trans->op_mode,& rxcb,cmd);
    
#line 644 
    if ((int)reclaim != 0) {
      
#line 645 
      kzfree((txq->entries + cmd_index)->free_buf);
      
#line 646 
      (txq->entries + cmd_index)->free_buf = (void const *)0;
    }
    else ;
    
#line 654 
    if ((int)reclaim != 0) 
      
#line 659 
      if (! rxcb._page_stolen) 
#line 660 
                               iwl_pcie_hcmd_complete(trans,& rxcb,err);
      else {
        {
          
#line 662 
          bool __cond_0 = (_Bool)((int)*("Claim null rxb?\n" + 15UL) != 10);
          
#line 662 
          if ((int)__cond_0 != 0) 
#line 662 
                                  __compiletime_assert_662(); else ;
        }
        
#line 662 
        __iwl_warn(trans->dev,"Claim null rxb?\n");
      }
    else ;
    
#line 665 
    page_stolen = (_Bool)(((int)rxcb._page_stolen | (int)page_stolen) != 0);
    
#line 666 
    offset = ((unsigned int)(len + 63) & 4294967232U) + offset;
  }
  ldv_54043: 
#line 668 
  ;
  
#line 584 
  if ((unsigned long)offset + 8UL < (unsigned long)max_len) 
#line 586 
                                                            goto ldv_54042; else 
                                                                    
#line 589 
                                                                    goto ldv_54028;
  ldv_54028: 
#line 590 
  ;
  
#line 670 
  if ((int)page_stolen != 0) {
    
#line 671 
    __free_pages(rxb->page,trans_pcie->rx_page_order);
    
#line 672 
    rxb->page = (struct page *)0;
  }
  else ;
  
#line 678 
  if (rxb->page != (struct page *)0) {
    int tmp_4;
    
#line 679 
    rxb->page_dma = dma_map_page(trans->dev,rxb->page,0UL,4096UL << trans_pcie->rx_page_order,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 683 
    tmp_4 = dma_mapping_error(trans->dev,rxb->page_dma);
    
#line 683 
    if (tmp_4 != 0) {
      
#line 689 
      __free_pages(rxb->page,trans_pcie->rx_page_order);
      
#line 690 
      rxb->page = (struct page *)0;
      
#line 691 
      list_add_tail(& rxb->list,& rxq->rx_used);
    }
    else {
      
#line 693 
      list_add_tail(& rxb->list,& rxq->rx_free);
      
#line 694 
      rxq->free_count += 1U;
    }
  }
  else 
#line 697 
       list_add_tail(& rxb->list,& rxq->rx_used);
  return_label: 
#line 698 
                return;
}


#line 721 
void __compiletime_assert_721(void);


#line 737 
void __compiletime_assert_738(void);


#line 703  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_rx_handle(struct iwl_trans *trans)
{
  u32 r;
  u32 i;
  int total_empty;
  __le16 volatile *tmp;
  
#line 705 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 706 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 708 
  u8 fill_rx = (unsigned char)0U;
  
#line 709 
  u32 count = 8U;
  restart: 
#line 712 
  ;
  
#line 713 
  ldv_spin_lock_96(& rxq->lock);
  {
    
#line 716 
    __le16 __var = (unsigned short)0U;
    
#line 716 
    tmp = (__le16 volatile *)(& (rxq->rb_stts)->closed_rb_num);
  }
  
#line 716 
  r = (unsigned int)*tmp & 4095U;
  
#line 717 
  i = rxq->read;
  
#line 720 
  if (i == r) {
    {
      
#line 721 
      bool __cond = (_Bool)((int)*("HW = SW = %d\n" + 12UL) != 10);
      
#line 721 
      if ((int)__cond != 0) 
#line 721 
                            __compiletime_assert_721(); else ;
    }
    
#line 721 
    __iwl_dbg(trans->dev,16777216U,(_Bool)0,"iwl_pcie_rx_handle","HW = SW = %d\n",r);
  }
  else ;
  
#line 724 
  total_empty = (int)(r - rxq->write_actual);
  
#line 725 
  if (total_empty < 0) 
#line 726 
                       total_empty += 256; else ;
  
#line 728 
  if (total_empty > 128) 
#line 729 
                         fill_rx = (unsigned char)1U; else ;
  
#line 731 
  goto ldv_54068;
  ldv_54067: 
#line 732 
  ;
  {
    struct iwl_rx_mem_buffer *rxb;
    
#line 734 
    rxb = rxq->queue[i];
    
#line 735 
    rxq->queue[i] = (struct iwl_rx_mem_buffer *)0;
    {
      
#line 737 
      bool __cond_0 = (_Bool)((int)*("rxbuf: HW = %d, SW = %d (%p)\n" + 28UL) != 10);
      
#line 737 
      if ((int)__cond_0 != 0) 
#line 737 
                              __compiletime_assert_738(); else ;
    }
    
#line 737 
    __iwl_dbg(trans->dev,16777216U,(_Bool)0,"iwl_pcie_rx_handle","rxbuf: HW = %d, SW = %d (%p)\n",r,i,rxb);
    
#line 739 
    iwl_pcie_rx_handle_rb(trans,rxb);
    
#line 741 
    i = (i + 1U) & 255U;
    
#line 744 
    if ((unsigned int)fill_rx != 0U) {
      
#line 745 
      count += 1U;
      
#line 746 
      if (count > 7U) {
        
#line 747 
        rxq->read = i;
        
#line 748 
        ldv_spin_unlock_97(& rxq->lock);
        
#line 749 
        iwl_pcie_rx_replenish(trans,32U);
        
#line 750 
        count = 0U;
        
#line 751 
        goto restart;
      }
      else ;
    }
    else ;
  }
  ldv_54068: 
#line 755 
  ;
  
#line 731 
  if (i != r) 
#line 733 
              goto ldv_54067; else 
#line 736 
                                   goto ldv_54069;
  ldv_54069: 
#line 737 
  ;
  
#line 757 
  rxq->read = i;
  
#line 758 
  ldv_spin_unlock_98(& rxq->lock);
  
#line 760 
  if ((unsigned int)fill_rx != 0U) 
#line 761 
                                   iwl_pcie_rx_replenish(trans,32U); else 
                                                                    
#line 763 
                                                                    iwl_pcie_rxq_restock(trans);
  
#line 765 
  if (trans_pcie->napi.poll != (int (*)(struct napi_struct *, int ))0) 
    
#line 766 
    napi_gro_flush(& trans_pcie->napi,(_Bool)0); else ;
  
#line 767 
  return;
}


#line 772  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static void iwl_pcie_irq_handle_error(struct iwl_trans *trans)
{
  
#line 774 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 777 
  if ((int)(trans->cfg)->internal_wimax_coex != 0 && ! (trans->cfg)->apmg_not_supported) {
    u32 tmp;
    
#line 778 
    tmp = iwl_read_prph(trans,12288U);
    
#line 778 
    if ((tmp & 1U) == 0U) 
#line 777 
                          goto _LOR;
    else {
      u32 tmp_0;
      
#line 780 
      tmp_0 = iwl_read_prph(trans,12300U);
      
#line 780 
      if ((tmp_0 & 67108864U) != 0U) {
        _LOR: {
                
#line 783 
                set_bit(0L,(unsigned long volatile *)(& trans->status));
                
#line 784 
                iwl_op_mode_wimax_active(trans->op_mode);
                
#line 785 
                __wake_up(& trans_pcie->wait_command_queue,3U,1,(void *)0);
                
#line 786 
                goto return_label;
              }
      }
      else ;
    }
  }
  else ;
  
#line 789 
  iwl_pcie_dump_csr(trans);
  
#line 790 
  iwl_dump_fh(trans,(char **)0);
  
#line 792 
  local_bh_disable();
  
#line 795 
  iwl_trans_fw_error(trans);
  
#line 796 
  local_bh_enable();
  
#line 798 
  set_bit(0L,(unsigned long volatile *)(& trans->status));
  
#line 799 
  __wake_up(& trans_pcie->wait_command_queue,3U,1,(void *)0);
  return_label: 
#line 800 
                return;
}


#line 802  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static u32 iwl_pcie_int_cause_non_ict(struct iwl_trans *trans)
{
  u32 inta;
  {
    int tmp_0;
    
#line 806 
    if (debug_locks != 0) {
      int tmp;
      
#line 806 
      tmp = lock_is_held(& ((struct iwl_trans_pcie *)(& trans->trans_specific))->irq_lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 806 
      if (tmp == 0) 
#line 806 
                    tmp_0 = 1; else 
#line 806 
                                    tmp_0 = 0;
    }
    else 
#line 806 
         tmp_0 = 0;
    
#line 806 
    int __ret_warn_on = tmp_0;
    
#line 806 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 806 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c",806); else ;
    
#line 806 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 808 
  trace_iwlwifi_dev_irq((struct device const *)trans->dev);
  
#line 811 
  inta = iwl_read32(trans,8U);
  
#line 814 
  return inta;
}


#line 853 
void __compiletime_assert_854(void);


#line 830  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
static u32 iwl_pcie_int_cause_ict(struct iwl_trans *trans)
{
  u32 __retres;
  u32 inta;
  u32 read;
  
#line 832 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 834 
  u32 val = 0U;
  
#line 837 
  trace_iwlwifi_dev_irq((struct device const *)trans->dev);
  
#line 842 
  read = *(trans_pcie->ict_tbl + trans_pcie->ict_index);
  
#line 843 
  trace_iwlwifi_dev_ict_read((struct device const *)trans->dev,(unsigned int)trans_pcie->ict_index,read);
  
#line 844 
  if (read == 0U) {
    
#line 845 
    __retres = 0U;
    
#line 845 
    goto return_label;
  }
  else ;
  ldv_54092: 
#line 846 
  ;
  
#line 852 
  val |= read;
  {
    
#line 853 
    bool __cond = (_Bool)((int)*("ICT index %d value 0x%08X\n" + 25UL) != 10);
    
#line 853 
    if ((int)__cond != 0) 
#line 853 
                          __compiletime_assert_854(); else ;
  }
  
#line 853 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_int_cause_ict","ICT index %d value 0x%08X\n",trans_pcie->ict_index,read);
  
#line 855 
  *(trans_pcie->ict_tbl + trans_pcie->ict_index) = 0U;
  
#line 856 
  trans_pcie->ict_index = (trans_pcie->ict_index + 1) & 1023;
  
#line 859 
  read = *(trans_pcie->ict_tbl + trans_pcie->ict_index);
  
#line 860 
  trace_iwlwifi_dev_ict_read((struct device const *)trans->dev,(unsigned int)trans_pcie->ict_index,read);
  
#line 862 
  if (read != 0U) 
#line 864 
                  goto ldv_54092; else 
#line 867 
                                       goto ldv_54093;
  ldv_54093: 
#line 868 
  ;
  
#line 865 
  if (val == 4294967295U) 
#line 866 
                          val = 0U; else ;
  
#line 875 
  if ((val & 786432U) != 0U) 
#line 876 
                             val |= 32768U; else ;
  
#line 878 
  inta = (val & 255U) | ((val << 16) & 4278190080U);
  
#line 879 
  __retres = inta;
  return_label: 
#line 879 
                return __retres;
}


#line 903 
void __compiletime_assert_907(void);


#line 909 
void __compiletime_assert_911(void);


#line 922 
void __compiletime_assert_922(void);


#line 939 
void __compiletime_assert_939(void);


#line 958 
void __compiletime_assert_959(void);


#line 965 
void __compiletime_assert_965(void);


#line 981 
void __compiletime_assert_982(void);


#line 988 
void __compiletime_assert_988(void);


#line 1001 
void __compiletime_assert_1002(void);


#line 1011 
void __compiletime_assert_1012(void);


#line 1023 
void __compiletime_assert_1023(void);


#line 1030 
void __compiletime_assert_1031(void);


#line 1039 
void __compiletime_assert_1039(void);


#line 1053 
void __compiletime_assert_1053(void);


#line 1100 
void __compiletime_assert_1100(void);


#line 1109 
void __compiletime_assert_1109(void);


#line 1114 
void __compiletime_assert_1115(void);


#line 882  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
{
  irqreturn_t __retres;
  bool tmp_1;
  bool tmp_4;
  bool tmp_5;
  int tmp_8;
  
#line 884 
  struct iwl_trans *trans = (struct iwl_trans *)dev_id;
  
#line 885 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 886 
  struct isr_statistics *isr_stats = & trans_pcie->isr_stats;
  
#line 887 
  u32 inta = 0U;
  
#line 888 
  u32 handled = 0U;
  __here_0: 
#line 890 
  ;
  
#line 890 
  ;
  
#line 890 
  lock_acquire(& trans->sync_cmd_lockdep_map,0U,0,0,1,(struct lockdep_map *)0,(unsigned long)((void *)0));
  
#line 892 
  ldv_spin_lock_99(& trans_pcie->irq_lock);
  
#line 897 
  if ((long)((int)trans_pcie->use_ict != 0) != 0L) 
#line 898 
                                                   inta = iwl_pcie_int_cause_ict(trans); else 
                                                                    
#line 900 
                                                                    inta = iwl_pcie_int_cause_non_ict(trans);
  
#line 902 
  tmp_1 = iwl_have_debug_level(33554432U);
  
#line 902 
  if ((int)tmp_1 != 0) {
    u32 tmp;
    u32 tmp_0;
    {
      
#line 903 
      bool __cond = (_Bool)((int)*("ISR inta 0x%08x, enabled 0x%08x(sw), enabled(hw) 0x%08x, fh 0x%08x\n" + 66UL) != 10);
      
#line 903 
      if ((int)__cond != 0) 
#line 903 
                            __compiletime_assert_907(); else ;
    }
    
#line 903 
    tmp = iwl_read32(trans,16U);
    
#line 903 
    tmp_0 = iwl_read32(trans,12U);
    
#line 903 
    ;
    
#line 903 
    ;
    
#line 903 
    ;
    
#line 903 
    __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","ISR inta 0x%08x, enabled 0x%08x(sw), enabled(hw) 0x%08x, fh 0x%08x\n",inta,trans_pcie->inta_mask,tmp_0,tmp);
    
#line 908 
    if ((~ trans_pcie->inta_mask & inta) != 0U) {
      {
        
#line 909 
        bool __cond_0 = (_Bool)((int)*("We got a masked interrupt (0x%08x)\n" + 34UL) != 10);
        
#line 909 
        if ((int)__cond_0 != 0) 
#line 909 
                                __compiletime_assert_911(); else ;
      }
      
#line 909 
      __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","We got a masked interrupt (0x%08x)\n",~ trans_pcie->inta_mask & inta);
    }
    else ;
  }
  else ;
  
#line 914 
  inta = trans_pcie->inta_mask & inta;
  
#line 921 
  if ((long)(inta == 0U) != 0L) {
    int tmp_2;
    {
      
#line 922 
      bool __cond_1 = (_Bool)((int)*("Ignore interrupt, inta == 0\n" + 27UL) != 10);
      
#line 922 
      if ((int)__cond_1 != 0) 
#line 922 
                              __compiletime_assert_922(); else ;
    }
    
#line 922 
    __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","Ignore interrupt, inta == 0\n");
    
#line 927 
    tmp_2 = constant_test_bit(3L,(unsigned long const volatile *)(& trans->status));
    
#line 927 
    if (tmp_2 != 0) 
#line 928 
                    iwl_enable_interrupts(trans); else ;
    
#line 929 
    ldv_spin_unlock_100(& trans_pcie->irq_lock);
    __here_1: 
#line 930 
    ;
    
#line 930 
    ;
    
#line 930 
    lock_release(& trans->sync_cmd_lockdep_map,1,(unsigned long)((void *)1));
    
#line 931 
    __retres = IRQ_NONE;
    
#line 931 
    goto return_label;
  }
  else ;
  
#line 934 
  if ((long)(inta == 4294967295U) != 0L || (long)((inta & 4294967280U) == 2779096480U) != 0L) {
    {
      
#line 939 
      bool __cond_2 = (_Bool)((int)*("HARDWARE GONE?\? INTA == 0x%08x\n" + 30UL) != 10);
      
#line 939 
      if ((int)__cond_2 != 0) 
#line 939 
                              __compiletime_assert_939(); else ;
    }
    
#line 939 
    __iwl_warn(trans->dev,"HARDWARE GONE?\? INTA == 0x%08x\n",inta);
    
#line 940 
    ldv_spin_unlock_101(& trans_pcie->irq_lock);
    
#line 941 
    goto out;
  }
  else ;
  
#line 955 
  iwl_write32(trans,8U,~ trans_pcie->inta_mask | inta);
  
#line 957 
  tmp_4 = iwl_have_debug_level(33554432U);
  
#line 957 
  if ((int)tmp_4 != 0) {
    u32 tmp_3;
    {
      
#line 958 
      bool __cond_3 = (_Bool)((int)*("inta 0x%08x, enabled 0x%08x\n" + 27UL) != 10);
      
#line 958 
      if ((int)__cond_3 != 0) 
#line 958 
                              __compiletime_assert_959(); else ;
    }
    
#line 958 
    tmp_3 = iwl_read32(trans,12U);
    
#line 958 
    ;
    
#line 958 
    ;
    
#line 958 
    __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","inta 0x%08x, enabled 0x%08x\n",inta,tmp_3);
  }
  else ;
  
#line 961 
  ldv_spin_unlock_102(& trans_pcie->irq_lock);
  
#line 964 
  if ((inta & 536870912U) != 0U) {
    {
      
#line 965 
      bool __cond_4 = (_Bool)((int)*("Hardware error detected.  Restarting.\n" + 37UL) != 10);
      
#line 965 
      if ((int)__cond_4 != 0) 
#line 965 
                              __compiletime_assert_965(); else ;
    }
    
#line 965 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Hardware error detected.  Restarting.\n");
    
#line 968 
    iwl_disable_interrupts(trans);
    
#line 970 
    isr_stats->hw += 1U;
    
#line 971 
    iwl_pcie_irq_handle_error(trans);
    
#line 973 
    handled |= 536870912U;
    
#line 975 
    goto out;
  }
  else ;
  
#line 978 
  tmp_5 = iwl_have_debug_level(33554432U);
  
#line 978 
  if ((int)tmp_5 != 0) {
    
#line 980 
    if ((inta & 67108864U) != 0U) {
      {
        
#line 981 
        bool __cond_5 = (_Bool)((int)*("Scheduler finished to transmit the frame/frames.\n" + 48UL) != 10);
        
#line 981 
        if ((int)__cond_5 != 0) 
#line 981 
                                __compiletime_assert_982(); else ;
      }
      
#line 981 
      __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","Scheduler finished to transmit the frame/frames.\n");
      
#line 983 
      isr_stats->sch += 1U;
    }
    else ;
    
#line 987 
    if ((inta & 1U) != 0U) {
      {
        
#line 988 
        bool __cond_6 = (_Bool)((int)*("Alive interrupt\n" + 15UL) != 10);
        
#line 988 
        if ((int)__cond_6 != 0) 
#line 988 
                                __compiletime_assert_988(); else ;
      }
      
#line 988 
      __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","Alive interrupt\n");
      
#line 989 
      isr_stats->alive += 1U;
    }
    else ;
  }
  else ;
  
#line 994 
  inta &= 4227858430U;
  
#line 997 
  if ((inta & 128U) != 0U) {
    bool hw_rfkill;
    char *tmp_6;
    
#line 1000 
    hw_rfkill = iwl_is_rfkill_set(trans);
    {
      
#line 1001 
      bool __cond_7 = (_Bool)((int)*("RF_KILL bit toggled to %s.\n" + 26UL) != 10);
      
#line 1001 
      if ((int)__cond_7 != 0) 
#line 1001 
                              __compiletime_assert_1002(); else ;
    }
    
#line 1001 
    if ((int)hw_rfkill != 0) 
#line 1001 
                             tmp_6 = (char *)"disable radio"; else 
#line 1001 
                                                                   tmp_6 = (char *)"enable radio";
    
#line 1001 
    ;
    
#line 1001 
    __iwl_warn(trans->dev,"RF_KILL bit toggled to %s.\n",tmp_6);
    
#line 1004 
    isr_stats->rfkill += 1U;
    
#line 1006 
    iwl_trans_pcie_rf_kill(trans,(_Bool)((bool)((int)hw_rfkill) != 0));
    
#line 1007 
    if ((int)hw_rfkill != 0) {
      int tmp_7;
      
#line 1008 
      set_bit(4L,(unsigned long volatile *)(& trans->status));
      
#line 1009 
      tmp_7 = test_and_set_bit(0L,(unsigned long volatile *)(& trans->status));
      
#line 1009 
      if (tmp_7 != 0) {
        {
          
#line 1011 
          bool __cond_8 = (_Bool)((int)*("Rfkill while SYNC HCMD in flight\n" + 32UL) != 10);
          
#line 1011 
          if ((int)__cond_8 != 0) 
#line 1011 
                                  __compiletime_assert_1012(); else ;
        }
        
#line 1011 
        __iwl_dbg(trans->dev,131072U,(_Bool)0,"iwl_pcie_irq_handler","Rfkill while SYNC HCMD in flight\n");
      }
      else ;
      
#line 1013 
      __wake_up(& trans_pcie->wait_command_queue,3U,1,(void *)0);
    }
    else 
#line 1015 
         set_bit(4L,(unsigned long volatile *)(& trans->status));
    
#line 1018 
    handled |= 128U;
  }
  else ;
  
#line 1022 
  if ((inta & 64U) != 0U) {
    {
      
#line 1023 
      bool __cond_9 = (_Bool)((int)*("Microcode CT kill error detected.\n" + 33UL) != 10);
      
#line 1023 
      if ((int)__cond_9 != 0) 
#line 1023 
                              __compiletime_assert_1023(); else ;
    }
    
#line 1023 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Microcode CT kill error detected.\n");
    
#line 1024 
    isr_stats->ctkill += 1U;
    
#line 1025 
    handled |= 64U;
  }
  else ;
  
#line 1029 
  if ((inta & 33554432U) != 0U) {
    {
      
#line 1030 
      bool __cond_10 = (_Bool)((int)*("Microcode SW error detected. " + 46UL) != 10);
      
#line 1030 
      if ((int)__cond_10 != 0) 
#line 1030 
                               __compiletime_assert_1031(); else ;
    }
    
#line 1030 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Microcode SW error detected. ",inta);
    
#line 1032 
    isr_stats->sw += 1U;
    
#line 1033 
    iwl_pcie_irq_handle_error(trans);
    
#line 1034 
    handled |= 33554432U;
  }
  else ;
  
#line 1038 
  if ((inta & 2U) != 0U) {
    {
      
#line 1039 
      bool __cond_11 = (_Bool)((int)*("Wakeup interrupt\n" + 16UL) != 10);
      
#line 1039 
      if ((int)__cond_11 != 0) 
#line 1039 
                               __compiletime_assert_1039(); else ;
    }
    
#line 1039 
    __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","Wakeup interrupt\n");
    
#line 1040 
    iwl_pcie_rxq_check_wrptr(trans);
    
#line 1041 
    iwl_pcie_txq_check_wrptrs(trans);
    
#line 1043 
    isr_stats->wakeup += 1U;
    
#line 1045 
    handled |= 2U;
  }
  else ;
  
#line 1051 
  if ((inta & 2415919112U) != 0U) {
    {
      
#line 1053 
      bool __cond_12 = (_Bool)((int)*("Rx interrupt\n" + 12UL) != 10);
      
#line 1053 
      if ((int)__cond_12 != 0) 
#line 1053 
                               __compiletime_assert_1053(); else ;
    }
    
#line 1053 
    __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","Rx interrupt\n");
    
#line 1054 
    if ((inta & 2147483656U) != 0U) {
      
#line 1055 
      handled |= 2147483656U;
      
#line 1056 
      iwl_write32(trans,16U,1073938432U);
    }
    else ;
    
#line 1059 
    if ((inta & 268435456U) != 0U) {
      
#line 1060 
      handled |= 268435456U;
      
#line 1061 
      iwl_write32(trans,8U,268435456U);
    }
    else ;
    
#line 1076 
    iwl_write8(trans,5U,(unsigned char)0);
    
#line 1086 
    if ((inta & 2147483656U) != 0U) 
#line 1087 
                                    iwl_write8(trans,5U,(unsigned char)255); else ;
    
#line 1090 
    isr_stats->rx += 1U;
    
#line 1092 
    local_bh_disable();
    
#line 1093 
    iwl_pcie_rx_handle(trans);
    
#line 1094 
    local_bh_enable();
  }
  else ;
  
#line 1098 
  if ((inta & 134217728U) != 0U) {
    
#line 1099 
    iwl_write32(trans,16U,3U);
    {
      
#line 1100 
      bool __cond_13 = (_Bool)((int)*("uCode load interrupt\n" + 20UL) != 10);
      
#line 1100 
      if ((int)__cond_13 != 0) 
#line 1100 
                               __compiletime_assert_1100(); else ;
    }
    
#line 1100 
    __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_irq_handler","uCode load interrupt\n");
    
#line 1101 
    isr_stats->tx += 1U;
    
#line 1102 
    handled |= 134217728U;
    
#line 1104 
    trans_pcie->ucode_write_complete = (_Bool)1;
    
#line 1105 
    __wake_up(& trans_pcie->ucode_write_waitq,3U,1,(void *)0);
  }
  else ;
  
#line 1108 
  if ((~ handled & inta) != 0U) {
    {
      
#line 1109 
      bool __cond_14 = (_Bool)((int)*("Unhandled INTA bits 0x%08x\n" + 26UL) != 10);
      
#line 1109 
      if ((int)__cond_14 != 0) 
#line 1109 
                               __compiletime_assert_1109(); else ;
    }
    
#line 1109 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Unhandled INTA bits 0x%08x\n",~ handled & inta);
    
#line 1110 
    isr_stats->unhandled += 1U;
  }
  else ;
  
#line 1113 
  if ((~ trans_pcie->inta_mask & inta) != 0U) {
    {
      
#line 1114 
      bool __cond_15 = (_Bool)((int)*("Disabled INTA bits 0x%08x were pending\n" + 38UL) != 10);
      
#line 1114 
      if ((int)__cond_15 != 0) 
#line 1114 
                               __compiletime_assert_1115(); else ;
    }
    
#line 1114 
    __iwl_warn(trans->dev,"Disabled INTA bits 0x%08x were pending\n",~ trans_pcie->inta_mask & inta);
  }
  else ;
  
#line 1120 
  tmp_8 = constant_test_bit(3L,(unsigned long const volatile *)(& trans->status));
  
#line 1120 
  if (tmp_8 != 0) 
#line 1121 
                  iwl_enable_interrupts(trans);
  else 
    
#line 1123 
    if ((handled & 128U) != 0U) 
#line 1124 
                                iwl_enable_rfkill_int(trans); else ;
  out: 
#line 1126 
  ;
  __here_2: 
#line 1127 
  ;
  
#line 1127 
  ;
  
#line 1127 
  lock_release(& trans->sync_cmd_lockdep_map,1,(unsigned long)((void *)2));
  
#line 1128 
  __retres = IRQ_HANDLED;
  return_label: 
#line 1128 
                return __retres;
}


#line 1138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
void iwl_pcie_free_ict(struct iwl_trans *trans)
{
  
#line 1140 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1142 
  if (trans_pcie->ict_tbl != (__le32 *)0U) {
    
#line 1143 
    dma_free_attrs(trans->dev,4096UL,(void *)trans_pcie->ict_tbl,trans_pcie->ict_tbl_dma,(struct dma_attrs *)0);
    
#line 1146 
    trans_pcie->ict_tbl = (__le32 *)0U;
    
#line 1147 
    trans_pcie->ict_tbl_dma = 0ULL;
  }
  else ;
  
#line 1149 
  return;
}


#line 1173 
void __compiletime_assert_1175(void);


#line 1156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
int iwl_pcie_alloc_ict(struct iwl_trans *trans)
{
  int __retres;
  int tmp_0;
  
#line 1158 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1161 
  trans_pcie->ict_tbl = (__le32 *)dma_zalloc_coherent(trans->dev,4096UL,& trans_pcie->ict_tbl_dma,208U);
  
#line 1164 
  if (trans_pcie->ict_tbl == (__le32 *)0U) {
    
#line 1165 
    __retres = -12;
    
#line 1165 
    goto return_label;
  }
  else ;
  {
    
#line 1168 
    int __ret_warn_on = (trans_pcie->ict_tbl_dma & 4095ULL) != 0ULL;
    
#line 1168 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1168 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c",1168); else ;
    
#line 1168 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 1168 
  if ((long)tmp_0 != 0L) {
    
#line 1169 
    iwl_pcie_free_ict(trans);
    
#line 1170 
    __retres = -22;
    
#line 1170 
    goto return_label;
  }
  else ;
  {
    
#line 1173 
    bool __cond = (_Bool)((int)*("ict dma addr %Lx ict vir addr %p\n" + 32UL) != 10);
    
#line 1173 
    if ((int)__cond != 0) 
#line 1173 
                          __compiletime_assert_1175(); else ;
  }
  
#line 1173 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_alloc_ict","ict dma addr %Lx ict vir addr %p\n",trans_pcie->ict_tbl_dma,trans_pcie->ict_tbl);
  
#line 1177 
  __retres = 0;
  return_label: 
#line 1177 
                return __retres;
}


#line 1201 
void __compiletime_assert_1201(void);


#line 1183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
void iwl_pcie_reset_ict(struct iwl_trans *trans)
{
  u32 val;
  
#line 1185 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1188 
  if (trans_pcie->ict_tbl == (__le32 *)0U) 
#line 1189 
                                           goto return_label; else ;
  
#line 1191 
  ldv_spin_lock_103(& trans_pcie->irq_lock);
  
#line 1192 
  iwl_disable_interrupts(trans);
  
#line 1194 
  memset((void *)trans_pcie->ict_tbl,0,4096UL);
  
#line 1196 
  val = (unsigned int)(trans_pcie->ict_tbl_dma >> 12);
  
#line 1198 
  val |= 2147483648U;
  
#line 1199 
  val |= 134217728U;
  {
    
#line 1201 
    bool __cond = (_Bool)((int)*("CSR_DRAM_INT_TBL_REG =0x%x\n" + 26UL) != 10);
    
#line 1201 
    if ((int)__cond != 0) 
#line 1201 
                          __compiletime_assert_1201(); else ;
  }
  
#line 1201 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_pcie_reset_ict","CSR_DRAM_INT_TBL_REG =0x%x\n",val);
  
#line 1203 
  iwl_write32(trans,160U,val);
  
#line 1204 
  trans_pcie->use_ict = (_Bool)1;
  
#line 1205 
  trans_pcie->ict_index = 0;
  
#line 1206 
  iwl_write32(trans,8U,trans_pcie->inta_mask);
  
#line 1207 
  iwl_enable_interrupts(trans);
  
#line 1208 
  ldv_spin_unlock_104(& trans_pcie->irq_lock);
  return_label: 
#line 1209 
                return;
}


#line 1212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
void iwl_pcie_disable_ict(struct iwl_trans *trans)
{
  
#line 1214 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1216 
  ldv_spin_lock_105(& trans_pcie->irq_lock);
  
#line 1217 
  trans_pcie->use_ict = (_Bool)0;
  
#line 1218 
  ldv_spin_unlock_106(& trans_pcie->irq_lock);
  
#line 1219 
  return;
}


#line 1221  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/rx.c"
irqreturn_t iwl_pcie_isr(int irq, void *data)
{
  irqreturn_t __retres;
  
#line 1223 
  struct iwl_trans *trans = (struct iwl_trans *)data;
  
#line 1225 
  if (trans == (struct iwl_trans *)0) {
    
#line 1226 
    __retres = IRQ_NONE;
    
#line 1226 
    goto return_label;
  }
  else ;
  
#line 1233 
  iwl_write32(trans,12U,0U);
  
#line 1235 
  __retres = IRQ_WAKE_THREAD;
  return_label: 
#line 1235 
                return __retres;
}


#line 63  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
_Bool ldv_emg_schedule_work(struct work_struct *arg0);


#line 745  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_73(spinlock_t *lock)
{
  
#line 749 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 751 
  spin_lock(lock);
  
#line 752 
  return;
}


#line 755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_74(spinlock_t *lock)
{
  
#line 759 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 761 
  spin_unlock(lock);
  
#line 762 
  return;
}


#line 765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_75(spinlock_t *lock)
{
  
#line 769 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 771 
  spin_lock(lock);
  
#line 772 
  return;
}


#line 775  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_76(spinlock_t *lock)
{
  
#line 779 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 781 
  spin_unlock(lock);
  
#line 782 
  return;
}


#line 785  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static bool ldv_schedule_work_77(struct work_struct *work)
{
  bool __retres;
  bool tmp;
  
#line 789 
  tmp = ldv_emg_schedule_work(work);
  
#line 789 
  __retres = tmp != 0;
  
#line 789 
  return __retres;
}


#line 793  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_78(spinlock_t *lock)
{
  
#line 797 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 799 
  spin_lock(lock);
  
#line 800 
  return;
}


#line 803  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_79(spinlock_t *lock)
{
  
#line 807 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 809 
  spin_unlock(lock);
  
#line 810 
  return;
}


#line 813  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_80(spinlock_t *lock)
{
  
#line 817 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 819 
  spin_lock(lock);
  
#line 820 
  return;
}


#line 823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_81(spinlock_t *lock)
{
  
#line 827 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 829 
  spin_unlock(lock);
  
#line 830 
  return;
}


#line 833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_82(spinlock_t *lock)
{
  
#line 837 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 839 
  spin_unlock(lock);
  
#line 840 
  return;
}


#line 843  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_83(spinlock_t *lock)
{
  
#line 847 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 849 
  spin_lock(lock);
  
#line 850 
  return;
}


#line 853  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_84(spinlock_t *lock)
{
  
#line 857 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 859 
  spin_unlock(lock);
  
#line 860 
  return;
}


#line 863  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_85(spinlock_t *lock)
{
  
#line 867 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 869 
  spin_unlock(lock);
  
#line 870 
  return;
}


#line 873  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_86(spinlock_t *lock)
{
  
#line 877 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 879 
  spin_lock(lock);
  
#line 880 
  return;
}


#line 883  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_87(spinlock_t *lock)
{
  
#line 887 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 889 
  spin_unlock(lock);
  
#line 890 
  return;
}


#line 893  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_88(spinlock_t *lock)
{
  
#line 897 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 899 
  spin_lock(lock);
  
#line 900 
  return;
}


#line 903  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_89(spinlock_t *lock)
{
  
#line 907 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 909 
  spin_unlock(lock);
  
#line 910 
  return;
}


#line 913  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_90(spinlock_t *lock)
{
  
#line 917 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 919 
  spin_lock(lock);
  
#line 920 
  return;
}


#line 923  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_91(spinlock_t *lock)
{
  
#line 927 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 929 
  spin_unlock(lock);
  
#line 930 
  return;
}


#line 933  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_92(spinlock_t *lock)
{
  
#line 937 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 939 
  spin_lock(lock);
  
#line 940 
  return;
}


#line 943  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_93(spinlock_t *lock)
{
  
#line 947 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 949 
  spin_unlock(lock);
  
#line 950 
  return;
}


#line 953  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_94(spinlock_t *lock)
{
  
#line 957 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 959 
  spin_lock(lock);
  
#line 960 
  return;
}


#line 963  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_95(spinlock_t *lock)
{
  
#line 967 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 969 
  spin_unlock(lock);
  
#line 970 
  return;
}


#line 973  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_96(spinlock_t *lock)
{
  
#line 977 
  ldv_spin_model_lock((char *)"lock_of_iwl_rxq");
  
#line 979 
  spin_lock(lock);
  
#line 980 
  return;
}


#line 983  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_97(spinlock_t *lock)
{
  
#line 987 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 989 
  spin_unlock(lock);
  
#line 990 
  return;
}


#line 993  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_98(spinlock_t *lock)
{
  
#line 997 
  ldv_spin_model_unlock((char *)"lock_of_iwl_rxq");
  
#line 999 
  spin_unlock(lock);
  
#line 1000 
  return;
}


#line 1003  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_99(spinlock_t *lock)
{
  
#line 1007 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 1009 
  spin_lock(lock);
  
#line 1010 
  return;
}


#line 1013  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_100(spinlock_t *lock)
{
  
#line 1017 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 1019 
  spin_unlock(lock);
  
#line 1020 
  return;
}


#line 1023  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_101(spinlock_t *lock)
{
  
#line 1027 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 1029 
  spin_unlock(lock);
  
#line 1030 
  return;
}


#line 1033  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_102(spinlock_t *lock)
{
  
#line 1037 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 1039 
  spin_unlock(lock);
  
#line 1040 
  return;
}


#line 1043  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_103(spinlock_t *lock)
{
  
#line 1047 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 1049 
  spin_lock(lock);
  
#line 1050 
  return;
}


#line 1053  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_104(spinlock_t *lock)
{
  
#line 1057 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 1059 
  spin_unlock(lock);
  
#line 1060 
  return;
}


#line 1063  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_lock_105(spinlock_t *lock)
{
  
#line 1067 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 1069 
  spin_lock(lock);
  
#line 1070 
  return;
}


#line 1073  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_rx.c.aux"
static void ldv_spin_unlock_106(spinlock_t *lock)
{
  
#line 1077 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 1079 
  spin_unlock(lock);
  
#line 1080 
  return;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __le16_to_cpup(__le16 const *p)
{
  __u16 __retres;
  
#line 65 
  __retres = *p;
  
#line 65 
  return __retres;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/string.h"
void *kmemdup(void const *, size_t, gfp_t);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size, gfp_t flags);


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist.h"
void __compiletime_assert_402(void);


#line 143  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
void kfree(void const *);


#line 581 
static void *kzalloc(size_t size, gfp_t flags);


#line 789  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
void __compiletime_assert_789(void);


#line 776  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static int iwl_trans_send_cmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd)
{
  int __retres;
  int ret;
  int tmp_0;
  
#line 781 
  if ((long)((cmd->flags & 4U) == 0U) != 0L) {
    int tmp;
    
#line 781 
    tmp = constant_test_bit(4L,(unsigned long const volatile *)(& trans->status));
    
#line 781 
    if ((long)(tmp != 0) != 0L) {
      
#line 783 
      __retres = -132;
      
#line 783 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 785 
  tmp_0 = constant_test_bit(5L,(unsigned long const volatile *)(& trans->status));
  
#line 785 
  if ((long)(tmp_0 != 0) != 0L) {
    
#line 786 
    __retres = -5;
    
#line 786 
    goto return_label;
  }
  else ;
  
#line 788 
  if ((long)(trans->state != (unsigned int)IWL_TRANS_FW_ALIVE) != 0L) {
    {
      
#line 789 
      bool __cond = (_Bool)((int)*("%s bad state = %d\n" + 17UL) != 10);
      
#line 789 
      if ((int)__cond != 0) 
#line 789 
                            __compiletime_assert_789(); else ;
    }
    
#line 789 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"%s bad state = %d\n","iwl_trans_send_cmd",(unsigned int)trans->state);
    
#line 790 
    __retres = -5;
    
#line 790 
    goto return_label;
  }
  else ;
  
#line 793 
  if ((cmd->flags & 1U) == 0U) {
    __here_0: 
#line 794 
    ;
    
#line 794 
    ;
    
#line 794 
    lock_acquire(& trans->sync_cmd_lockdep_map,0U,0,2,1,(struct lockdep_map *)0,(unsigned long)((void *)0));
  }
  else ;
  
#line 796 
  ret = (*((trans->ops)->send_cmd))(trans,cmd);
  
#line 798 
  if ((cmd->flags & 1U) == 0U) {
    __here_1: 
#line 799 
    ;
    
#line 799 
    ;
    
#line 799 
    lock_release(& trans->sync_cmd_lockdep_map,1,(unsigned long)((void *)1));
  }
  else ;
  
#line 801 
  __retres = ret;
  return_label: 
#line 801 
                return __retres;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.h"
struct iwl_phy_db *iwl_phy_db_init(struct iwl_trans *trans);


#line 74 
void iwl_phy_db_free(struct iwl_phy_db *phy_db);


#line 76 
int iwl_phy_db_set_section(struct iwl_phy_db *phy_db, struct iwl_rx_packet *pkt, gfp_t alloc_ctx);


#line 80 
int iwl_send_phy_db_data(struct iwl_phy_db *phy_db);


#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct iwl_phy_db *iwl_phy_db_init(struct iwl_trans *trans)
{
  struct iwl_phy_db *__retres;
  
#line 138 
  struct iwl_phy_db *phy_db = kzalloc(328UL,208U);
  
#line 141 
  if (phy_db == (struct iwl_phy_db *)0) {
    
#line 142 
    __retres = phy_db;
    
#line 142 
    goto return_label;
  }
  else ;
  
#line 144 
  phy_db->trans = trans;
  
#line 147 
  __retres = phy_db;
  return_label: 
#line 147 
                return __retres;
}


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static char const __kstrtab_iwl_phy_db_init[16U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'p', (char)'h', (char)'y', (char)'_', (char)'d', (char)'b', (char)'_', (char)'i', (char)'n', (char)'i', (char)'t', (char)'\000'};

#line 149 
struct kernel_symbol const __ksymtab_iwl_phy_db_init;


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct kernel_symbol const __ksymtab_iwl_phy_db_init = {.value = (unsigned long)(& iwl_phy_db_init), .name = (char const *)(& __kstrtab_iwl_phy_db_init)};

#line 156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static struct iwl_phy_db_entry *iwl_phy_db_get_section(struct iwl_phy_db *phy_db, enum iwl_phy_db_section_type type, u16 chg_id)
{
  struct iwl_phy_db_entry *__retres;
  
#line 160 
  if (phy_db == (struct iwl_phy_db *)0 || type > (unsigned int)IWL_PHY_DB_CALIB_CHG_TXP) {
    
#line 161 
    __retres = (struct iwl_phy_db_entry *)0;
    
#line 161 
    goto return_label;
  }
  else ;
  
#line 163 
  switch ((unsigned int)type) {
    case (unsigned int)1: 
#line 164 
    ;
    
#line 165 
    __retres = & phy_db->cfg;
    
#line 165 
    goto return_label;
    case (unsigned int)2: 
#line 166 
    ;
    
#line 167 
    __retres = & phy_db->calib_nch;
    
#line 167 
    goto return_label;
    case (unsigned int)4: 
#line 168 
    ;
    
#line 169 
    if ((unsigned int)chg_id > 8U) {
      
#line 170 
      __retres = (struct iwl_phy_db_entry *)0;
      
#line 170 
      goto return_label;
    }
    else ;
    
#line 171 
    __retres = & phy_db->calib_ch_group_papd[(int)chg_id];
    
#line 171 
    goto return_label;
    case (unsigned int)5: 
#line 172 
    ;
    
#line 173 
    if ((unsigned int)chg_id > 8U) {
      
#line 174 
      __retres = (struct iwl_phy_db_entry *)0;
      
#line 174 
      goto return_label;
    }
    else ;
    
#line 175 
    __retres = & phy_db->calib_ch_group_txp[(int)chg_id];
    
#line 175 
    goto return_label;
    default: 
#line 176 
    ;
    
#line 177 
    __retres = (struct iwl_phy_db_entry *)0;
    
#line 177 
    goto return_label;
  }
  
#line 179 
  __retres = (struct iwl_phy_db_entry *)0;
  return_label: 
#line 179 
                return __retres;
}


#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static void iwl_phy_db_free_section(struct iwl_phy_db *phy_db, enum iwl_phy_db_section_type type, u16 chg_id)
{
  
#line 186 
  struct iwl_phy_db_entry *entry = iwl_phy_db_get_section(phy_db,type,(unsigned short)((int)chg_id));
  
#line 188 
  if (entry == (struct iwl_phy_db_entry *)0) 
#line 189 
                                             goto return_label; else ;
  
#line 191 
  kfree((void const *)entry->data);
  
#line 192 
  entry->data = (u8 *)0U;
  
#line 193 
  entry->size = (unsigned short)0U;
  return_label: 
#line 194 
                return;
}


#line 196  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
void iwl_phy_db_free(struct iwl_phy_db *phy_db)
{
  int i;
  
#line 200 
  if (phy_db == (struct iwl_phy_db *)0) 
#line 201 
                                        goto return_label; else ;
  
#line 203 
  iwl_phy_db_free_section(phy_db,(enum iwl_phy_db_section_type)IWL_PHY_DB_CFG,(unsigned short)0);
  
#line 204 
  iwl_phy_db_free_section(phy_db,(enum iwl_phy_db_section_type)IWL_PHY_DB_CALIB_NCH,(unsigned short)0);
  
#line 205 
  i = 0;
  
#line 205 
  goto ldv_50286;
  ldv_50285: 
#line 206 
  ;
  
#line 206 
  iwl_phy_db_free_section(phy_db,(enum iwl_phy_db_section_type)IWL_PHY_DB_CALIB_CHG_PAPD,(unsigned short)((int)((unsigned short)i)));
  
#line 205 
  i += 1;
  ldv_50286: 
#line 206 
  ;
  
#line 205 
  if (i <= 8) 
#line 207 
              goto ldv_50285; else 
#line 210 
                                   goto ldv_50287;
  ldv_50287: 
#line 211 
  ;
  
#line 207 
  i = 0;
  
#line 207 
  goto ldv_50289;
  ldv_50288: 
#line 208 
  ;
  
#line 208 
  iwl_phy_db_free_section(phy_db,(enum iwl_phy_db_section_type)IWL_PHY_DB_CALIB_CHG_TXP,(unsigned short)((int)((unsigned short)i)));
  
#line 207 
  i += 1;
  ldv_50289: 
#line 208 
  ;
  
#line 207 
  if (i <= 8) 
#line 209 
              goto ldv_50288; else 
#line 212 
                                   goto ldv_50290;
  ldv_50290: 
#line 213 
  ;
  
#line 210 
  kfree((void const *)phy_db);
  return_label: 
#line 211 
                return;
}


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static char const __kstrtab_iwl_phy_db_free[16U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'p', (char)'h', (char)'y', (char)'_', (char)'d', (char)'b', (char)'_', (char)'f', (char)'r', (char)'e', (char)'e', (char)'\000'};

#line 212 
struct kernel_symbol const __ksymtab_iwl_phy_db_free;


#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct kernel_symbol const __ksymtab_iwl_phy_db_free = {.value = (unsigned long)(& iwl_phy_db_free), .name = (char const *)(& __kstrtab_iwl_phy_db_free)};

#line 244 
void __compiletime_assert_246(void);


#line 214  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
int iwl_phy_db_set_section(struct iwl_phy_db *phy_db, struct iwl_rx_packet *pkt, gfp_t alloc_ctx)
{
  int __retres;
  struct iwl_phy_db_entry *entry;
  
#line 217 
  struct iwl_calib_res_notif_phy_db *phy_db_notif = (struct iwl_calib_res_notif_phy_db *)(& pkt->data);
  
#line 219 
  enum iwl_phy_db_section_type type = (enum iwl_phy_db_section_type)phy_db_notif->type;
  
#line 220 
  u16 size = phy_db_notif->length;
  
#line 222 
  u16 chg_id = (unsigned short)0U;
  
#line 224 
  if (phy_db == (struct iwl_phy_db *)0) {
    
#line 225 
    __retres = -22;
    
#line 225 
    goto return_label;
  }
  else ;
  
#line 227 
  if ((unsigned int)type + 4294967292U <= 1U) 
#line 229 
                                              chg_id = __le16_to_cpup((__le16 const *)(& phy_db_notif->data)); else ;
  
#line 231 
  entry = iwl_phy_db_get_section(phy_db,type,(unsigned short)((int)chg_id));
  
#line 232 
  if (entry == (struct iwl_phy_db_entry *)0) {
    
#line 233 
    __retres = -22;
    
#line 233 
    goto return_label;
  }
  else ;
  
#line 235 
  kfree((void const *)entry->data);
  
#line 236 
  entry->data = (u8 *)kmemdup((void const *)(& phy_db_notif->data),(unsigned long)size,alloc_ctx);
  
#line 237 
  if (entry->data == (u8 *)0U) {
    
#line 238 
    entry->size = (unsigned short)0U;
    
#line 239 
    __retres = -12;
    
#line 239 
    goto return_label;
  }
  else ;
  
#line 242 
  entry->size = size;
  {
    
#line 244 
    bool __cond = (_Bool)((int)*("%s(%d): [PHYDB]SET: Type %d , Size: %d\n" + 38UL) != 10);
    
#line 244 
    if ((int)__cond != 0) 
#line 244 
                          __compiletime_assert_246(); else ;
  }
  
#line 244 
  __iwl_dbg((phy_db->trans)->dev,1U,(_Bool)0,"iwl_phy_db_set_section","%s(%d): [PHYDB]SET: Type %d , Size: %d\n","iwl_phy_db_set_section",246,(unsigned int)type,(int)size);
  
#line 248 
  __retres = 0;
  return_label: 
#line 248 
                return __retres;
}


#line 250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static char const __kstrtab_iwl_phy_db_set_section[23U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'p', (char)'h', (char)'y', (char)'_', (char)'d', (char)'b', (char)'_', (char)'s', (char)'e', (char)'t', (char)'_', (char)'s', (char)'e', (char)'c', (char)'t', (char)'i', (char)'o', (char)'n', (char)'\000'};

#line 250 
struct kernel_symbol const __ksymtab_iwl_phy_db_set_section;


#line 250  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct kernel_symbol const __ksymtab_iwl_phy_db_set_section = {.value = (unsigned long)(& iwl_phy_db_set_section), .name = (char const *)(& __kstrtab_iwl_phy_db_set_section)};

#line 252  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static int is_valid_channel(u16 ch_id)
{
  int __retres;
  
#line 254 
  if ((((unsigned int)ch_id <= 14U || ((unsigned int)ch_id + 65500U <= 28U && ((unsigned int)ch_id & 3U) == 0U)) || ((unsigned int)ch_id + 65436U <= 40U && ((unsigned int)ch_id & 3U) == 0U)) || ((unsigned int)ch_id + 65391U <= 20U && ((unsigned int)ch_id & 3U) == 1U)) {
    
#line 258 
    __retres = 1;
    
#line 258 
    goto return_label;
  }
  else ;
  
#line 259 
  __retres = 0;
  return_label: 
#line 259 
                return __retres;
}


#line 262  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static u8 ch_id_to_ch_index(u16 ch_id)
{
  u8 __retres;
  int tmp_0;
  {
    int tmp;
    
#line 264 
    tmp = is_valid_channel((unsigned short)((int)ch_id));
    
#line 264 
    int __ret_warn_on = tmp == 0;
    
#line 264 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 264 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c",264); else ;
    
#line 264 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 264 
  if ((long)tmp_0 != 0L) {
    
#line 265 
    __retres = (unsigned char)255U;
    
#line 265 
    goto return_label;
  }
  else ;
  
#line 267 
  if ((unsigned int)ch_id <= 14U) {
    
#line 268 
    __retres = (unsigned char)((unsigned int)((unsigned char)ch_id) + 255U);
    
#line 268 
    goto return_label;
  }
  else ;
  
#line 269 
  if ((unsigned int)ch_id <= 64U) {
    
#line 270 
    __retres = (unsigned char)(((int)ch_id + 20) / 4);
    
#line 270 
    goto return_label;
  }
  else ;
  
#line 271 
  if ((unsigned int)ch_id <= 140U) {
    
#line 272 
    __retres = (unsigned char)(((int)ch_id + -12) / 4);
    
#line 272 
    goto return_label;
  }
  else ;
  
#line 273 
  __retres = (unsigned char)(((int)ch_id + -13) / 4);
  return_label: 
#line 273 
                return __retres;
}


#line 277  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static u16 channel_id_to_papd(u16 ch_id)
{
  u16 __retres;
  int tmp_0;
  {
    int tmp;
    
#line 279 
    tmp = is_valid_channel((unsigned short)((int)ch_id));
    
#line 279 
    int __ret_warn_on = tmp == 0;
    
#line 279 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 279 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c",279); else ;
    
#line 279 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 279 
  if ((long)tmp_0 != 0L) {
    
#line 280 
    __retres = (unsigned short)255U;
    
#line 280 
    goto return_label;
  }
  else ;
  
#line 282 
  if ((unsigned int)ch_id + 65535U <= 13U) {
    
#line 283 
    __retres = (unsigned short)0U;
    
#line 283 
    goto return_label;
  }
  else ;
  
#line 284 
  if ((unsigned int)ch_id + 65500U <= 28U) {
    
#line 285 
    __retres = (unsigned short)1U;
    
#line 285 
    goto return_label;
  }
  else ;
  
#line 286 
  if ((unsigned int)ch_id + 65436U <= 40U) {
    
#line 287 
    __retres = (unsigned short)2U;
    
#line 287 
    goto return_label;
  }
  else ;
  
#line 288 
  __retres = (unsigned short)3U;
  return_label: 
#line 288 
                return __retres;
}


#line 291  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static u16 channel_id_to_txp(struct iwl_phy_db *phy_db, u16 ch_id)
{
  u16 __retres;
  struct iwl_phy_db_chg_txp *txp_chg;
  int i;
  
#line 295 
  u8 ch_index = ch_id_to_ch_index((unsigned short)((int)ch_id));
  
#line 296 
  if ((unsigned int)ch_index == 255U) {
    
#line 297 
    __retres = (unsigned short)255U;
    
#line 297 
    goto return_label;
  }
  else ;
  
#line 299 
  i = 0;
  
#line 299 
  goto ldv_50343;
  ldv_50342: 
#line 300 
  ;
  
#line 300 
  txp_chg = (struct iwl_phy_db_chg_txp *)phy_db->calib_ch_group_txp[i].data;
  
#line 301 
  if (txp_chg == (struct iwl_phy_db_chg_txp *)0) {
    
#line 302 
    __retres = (unsigned short)255U;
    
#line 302 
    goto return_label;
  }
  else ;
  
#line 307 
  if ((int)txp_chg->max_channel_idx >= (int)((unsigned short)ch_index)) {
    
#line 308 
    __retres = (unsigned short)i;
    
#line 308 
    goto return_label;
  }
  else ;
  
#line 299 
  i += 1;
  ldv_50343: 
#line 300 
  ;
  
#line 299 
  if (i <= 8) 
#line 301 
              goto ldv_50342; else 
#line 304 
                                   goto ldv_50344;
  ldv_50344: 
#line 305 
  ;
  
#line 310 
  __retres = (unsigned short)255U;
  return_label: 
#line 310 
                return __retres;
}


#line 335 
void __compiletime_assert_337(void);


#line 313  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static int iwl_phy_db_get_section_data(struct iwl_phy_db *phy_db, u32 type, u8 **data, u16 *size, u16 ch_id)
{
  int __retres;
  struct iwl_phy_db_entry *entry;
  
#line 317 
  u16 ch_group_id = (unsigned short)0U;
  
#line 319 
  if (phy_db == (struct iwl_phy_db *)0) {
    
#line 320 
    __retres = -22;
    
#line 320 
    goto return_label;
  }
  else ;
  
#line 323 
  if (type == 4U) 
#line 324 
                  ch_group_id = channel_id_to_papd((unsigned short)((int)ch_id));
  else 
    
#line 325 
    if (type == 5U) 
#line 326 
                    ch_group_id = channel_id_to_txp(phy_db,(unsigned short)((int)ch_id)); else ;
  
#line 328 
  entry = iwl_phy_db_get_section(phy_db,(enum iwl_phy_db_section_type)type,(unsigned short)((int)ch_group_id));
  
#line 329 
  if (entry == (struct iwl_phy_db_entry *)0) {
    
#line 330 
    __retres = -22;
    
#line 330 
    goto return_label;
  }
  else ;
  
#line 332 
  *data = entry->data;
  
#line 333 
  *size = entry->size;
  {
    
#line 335 
    bool __cond = (_Bool)((int)*("%s(%d): [PHYDB] GET: Type %d , Size: %d\n" + 39UL) != 10);
    
#line 335 
    if ((int)__cond != 0) 
#line 335 
                          __compiletime_assert_337(); else ;
  }
  
#line 335 
  __iwl_dbg((phy_db->trans)->dev,1U,(_Bool)0,"iwl_phy_db_get_section_data","%s(%d): [PHYDB] GET: Type %d , Size: %d\n","iwl_phy_db_get_section_data",337,type,(int)*size);
  
#line 339 
  __retres = 0;
  return_label: 
#line 339 
                return __retres;
}


#line 350 
void __compiletime_assert_352(void);


#line 342  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static int iwl_send_phy_db_cmd(struct iwl_phy_db *phy_db, u16 type, u16 length, void *data)
{
  struct iwl_phy_db_cmd phy_db_cmd;
  int tmp;
  
#line 346 
  struct iwl_host_cmd cmd = {.data = {(void const *)0, (void const *)0}, .resp_pkt = (struct iwl_rx_packet *)0, ._rx_page_addr = 0UL, ._rx_page_order = 0U, .handler_status = 0, .flags = 0U, .len = {(unsigned short)0, (unsigned short)0}, .dataflags = {(unsigned char)0, (unsigned char)0}, .id = (unsigned char)108U};
  {
    
#line 350 
    bool __cond = (_Bool)((int)*("Sending PHY-DB hcmd of type %d, of length %d\n" + 44UL) != 10);
    
#line 350 
    if ((int)__cond != 0) 
#line 350 
                          __compiletime_assert_352(); else ;
  }
  
#line 350 
  __iwl_dbg((phy_db->trans)->dev,1U,(_Bool)0,"iwl_send_phy_db_cmd","Sending PHY-DB hcmd of type %d, of length %d\n",(int)type,(int)length);
  
#line 355 
  phy_db_cmd.type = type;
  
#line 356 
  phy_db_cmd.length = length;
  
#line 359 
  cmd.data[0] = (void const *)(& phy_db_cmd);
  
#line 360 
  cmd.len[0] = (unsigned short)4U;
  
#line 361 
  cmd.data[1] = (void const *)data;
  
#line 362 
  cmd.len[1] = length;
  
#line 363 
  cmd.dataflags[1] = (unsigned char)1U;
  
#line 365 
  tmp = iwl_trans_send_cmd(phy_db->trans,& cmd);
  
#line 365 
  return tmp;
}


#line 394 
void __compiletime_assert_396(void);


#line 368  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static int iwl_phy_db_send_all_channel_groups(struct iwl_phy_db *phy_db, enum iwl_phy_db_section_type type, u8 max_ch_groups)
{
  int __retres;
  u16 i;
  int err;
  struct iwl_phy_db_entry *entry;
  
#line 378 
  i = (unsigned short)0U;
  
#line 378 
  goto ldv_50391;
  ldv_50390: 
#line 379 
  ;
  
#line 379 
  entry = iwl_phy_db_get_section(phy_db,type,(unsigned short)((int)i));
  
#line 382 
  if (entry == (struct iwl_phy_db_entry *)0) {
    
#line 383 
    __retres = -22;
    
#line 383 
    goto return_label;
  }
  else ;
  
#line 385 
  if ((unsigned int)entry->size == 0U) 
#line 386 
                                       goto ldv_50380; else ;
  
#line 389 
  err = iwl_send_phy_db_cmd(phy_db,(unsigned short)((int)((unsigned short)type)),(unsigned short)((int)entry->size),(void *)entry->data);
  
#line 393 
  if (err != 0) {
    {
      
#line 394 
      bool __cond = (_Bool)((int)*("Can\'t SEND phy_db section %d (%d), err %d\n" + 41UL) != 10);
      
#line 394 
      if ((int)__cond != 0) 
#line 394 
                            __compiletime_assert_396(); else ;
    }
    
#line 394 
    __iwl_err((phy_db->trans)->dev,(_Bool)0,(_Bool)0,"Can\'t SEND phy_db section %d (%d), err %d\n",(unsigned int)type,(int)i,err);
    
#line 397 
    __retres = err;
    
#line 397 
    goto return_label;
  }
  else ;
  {
    
#line 400 
    bool __cond_0 = (_Bool)((int)*("Sent PHY_DB HCMD, type = %d num = %d\n" + 36UL) != 10);
    
#line 400 
    if ((int)__cond_0 != 0) 
#line 400 
                            __compiletime_assert_402(); else ;
  }
  
#line 400 
  __iwl_dbg((phy_db->trans)->dev,1U,(_Bool)0,"iwl_phy_db_send_all_channel_groups","Sent PHY_DB HCMD, type = %d num = %d\n",(unsigned int)type,(int)i);
  ldv_50380: 
#line 401 
  ;
  
#line 378 
  i = (u16)((int)i + 1);
  ldv_50391: 
#line 379 
  ;
  
#line 378 
  if ((int)((unsigned short)max_ch_groups) > (int)i) 
#line 380 
                                                     goto ldv_50390; else 
                                                                    
#line 383 
                                                                    goto ldv_50392;
  ldv_50392: 
#line 384 
  ;
  
#line 405 
  __retres = 0;
  return_label: 
#line 405 
                return __retres;
}


#line 414 
void __compiletime_assert_415(void);


#line 421 
void __compiletime_assert_421(void);


#line 427 
void __compiletime_assert_428(void);


#line 435 
void __compiletime_assert_436(void);


#line 442 
void __compiletime_assert_443(void);


#line 452 
void __compiletime_assert_453(void);


#line 462 
void __compiletime_assert_463(void);


#line 467 
void __compiletime_assert_468(void);


#line 408  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
int iwl_send_phy_db_data(struct iwl_phy_db *phy_db)
{
  int __retres;
  int err;
  
#line 410 
  u8 *data = (u8 *)0U;
  
#line 411 
  u16 size = (unsigned short)0U;
  {
    
#line 414 
    bool __cond = (_Bool)((int)*("Sending phy db data and configuration to runtime image\n" + 54UL) != 10);
    
#line 414 
    if ((int)__cond != 0) 
#line 414 
                          __compiletime_assert_415(); else ;
  }
  
#line 414 
  __iwl_dbg((phy_db->trans)->dev,1U,(_Bool)0,"iwl_send_phy_db_data","Sending phy db data and configuration to runtime image\n");
  
#line 418 
  err = iwl_phy_db_get_section_data(phy_db,1U,& data,& size,(unsigned short)0);
  
#line 420 
  if (err != 0) {
    {
      
#line 421 
      bool __cond_0 = (_Bool)((int)*("Cannot get Phy DB cfg section\n" + 29UL) != 10);
      
#line 421 
      if ((int)__cond_0 != 0) 
#line 421 
                              __compiletime_assert_421(); else ;
    }
    
#line 421 
    __iwl_err((phy_db->trans)->dev,(_Bool)0,(_Bool)0,"Cannot get Phy DB cfg section\n");
    
#line 422 
    __retres = err;
    
#line 422 
    goto return_label;
  }
  else ;
  
#line 425 
  err = iwl_send_phy_db_cmd(phy_db,(unsigned short)1,(unsigned short)((int)size),(void *)data);
  
#line 426 
  if (err != 0) {
    {
      
#line 427 
      bool __cond_1 = (_Bool)((int)*("Cannot send HCMD of  Phy DB cfg section\n" + 39UL) != 10);
      
#line 427 
      if ((int)__cond_1 != 0) 
#line 427 
                              __compiletime_assert_428(); else ;
    }
    
#line 427 
    __iwl_err((phy_db->trans)->dev,(_Bool)0,(_Bool)0,"Cannot send HCMD of  Phy DB cfg section\n");
    
#line 429 
    __retres = err;
    
#line 429 
    goto return_label;
  }
  else ;
  
#line 432 
  err = iwl_phy_db_get_section_data(phy_db,2U,& data,& size,(unsigned short)0);
  
#line 434 
  if (err != 0) {
    {
      
#line 435 
      bool __cond_2 = (_Bool)((int)*("Cannot get Phy DB non specific channel section\n" + 46UL) != 10);
      
#line 435 
      if ((int)__cond_2 != 0) 
#line 435 
                              __compiletime_assert_436(); else ;
    }
    
#line 435 
    __iwl_err((phy_db->trans)->dev,(_Bool)0,(_Bool)0,"Cannot get Phy DB non specific channel section\n");
    
#line 437 
    __retres = err;
    
#line 437 
    goto return_label;
  }
  else ;
  
#line 440 
  err = iwl_send_phy_db_cmd(phy_db,(unsigned short)2,(unsigned short)((int)size),(void *)data);
  
#line 441 
  if (err != 0) {
    {
      
#line 442 
      bool __cond_3 = (_Bool)((int)*("Cannot send HCMD of Phy DB non specific channel section\n" + 55UL) != 10);
      
#line 442 
      if ((int)__cond_3 != 0) 
#line 442 
                              __compiletime_assert_443(); else ;
    }
    
#line 442 
    __iwl_err((phy_db->trans)->dev,(_Bool)0,(_Bool)0,"Cannot send HCMD of Phy DB non specific channel section\n");
    
#line 444 
    __retres = err;
    
#line 444 
    goto return_label;
  }
  else ;
  
#line 448 
  err = iwl_phy_db_send_all_channel_groups(phy_db,(enum iwl_phy_db_section_type)IWL_PHY_DB_CALIB_CHG_PAPD,(unsigned char)9);
  
#line 451 
  if (err != 0) {
    {
      
#line 452 
      bool __cond_4 = (_Bool)((int)*("Cannot send channel specific PAPD groups\n" + 40UL) != 10);
      
#line 452 
      if ((int)__cond_4 != 0) 
#line 452 
                              __compiletime_assert_453(); else ;
    }
    
#line 452 
    __iwl_err((phy_db->trans)->dev,(_Bool)0,(_Bool)0,"Cannot send channel specific PAPD groups\n");
    
#line 454 
    __retres = err;
    
#line 454 
    goto return_label;
  }
  else ;
  
#line 458 
  err = iwl_phy_db_send_all_channel_groups(phy_db,(enum iwl_phy_db_section_type)IWL_PHY_DB_CALIB_CHG_TXP,(unsigned char)9);
  
#line 461 
  if (err != 0) {
    {
      
#line 462 
      bool __cond_5 = (_Bool)((int)*("Cannot send channel specific TX power groups\n" + 44UL) != 10);
      
#line 462 
      if ((int)__cond_5 != 0) 
#line 462 
                              __compiletime_assert_463(); else ;
    }
    
#line 462 
    __iwl_err((phy_db->trans)->dev,(_Bool)0,(_Bool)0,"Cannot send channel specific TX power groups\n");
    
#line 464 
    __retres = err;
    
#line 464 
    goto return_label;
  }
  else ;
  {
    
#line 467 
    bool __cond_6 = (_Bool)((int)*("Finished sending phy db non channel data\n" + 40UL) != 10);
    
#line 467 
    if ((int)__cond_6 != 0) 
#line 467 
                            __compiletime_assert_468(); else ;
  }
  
#line 467 
  __iwl_dbg((phy_db->trans)->dev,1U,(_Bool)0,"iwl_send_phy_db_data","Finished sending phy db non channel data\n");
  
#line 469 
  __retres = 0;
  return_label: 
#line 469 
                return __retres;
}


#line 471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
static char const __kstrtab_iwl_send_phy_db_data[21U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'s', (char)'e', (char)'n', (char)'d', (char)'_', (char)'p', (char)'h', (char)'y', (char)'_', (char)'d', (char)'b', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'\000'};

#line 471 
struct kernel_symbol const __ksymtab_iwl_send_phy_db_data;


#line 471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-phy-db.c"
struct kernel_symbol const __ksymtab_iwl_send_phy_db_data = {.value = (unsigned long)(& iwl_send_phy_db_data), .name = (char const *)(& __kstrtab_iwl_send_phy_db_data)};

#line 418  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-phy-db.c.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 421 
  tmp = ldv_kzalloc(size,flags);
  
#line 421 
  return tmp;
}


#line 24  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight32(unsigned int w)
{
  
#line 26 
  unsigned int res = 0U;
  
#line 27 
  ldv_inline_asm();
  
#line 32 
  return res;
}


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight8(unsigned int w)
{
  unsigned int tmp;
  
#line 42 
  tmp = __arch_hweight32(w & 255U);
  
#line 42 
  return tmp;
}


#line 34  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
void *memcpy(void *, void const *, size_t);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_0(size_t size, gfp_t flags);


#line 3528  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
int ieee80211_channel_to_frequency(int, enum ieee80211_band);


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.h"
struct iwl_nvm_data *iwl_parse_eeprom_data(struct device *dev, struct iwl_cfg const *cfg, u8 const *eeprom, size_t eeprom_size);


#line 131 
int iwl_nvm_check_version(struct iwl_nvm_data *data, struct iwl_trans *trans);


#line 134 
int iwl_init_sband_channels(struct iwl_nvm_data *data, struct ieee80211_supported_band *sband, int n_channels, enum ieee80211_band band);


#line 138 
void iwl_init_ht_hw_capab(struct iwl_cfg const *cfg, struct iwl_nvm_data *data, struct ieee80211_sta_ht_cap *ht_info, enum ieee80211_band band, u8 tx_chains, u8 rx_chains);


#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u8 const iwl_eeprom_band_1[14U] = {(unsigned char)1U, (unsigned char)2U, (unsigned char)3U, (unsigned char)4U, (unsigned char)5U, (unsigned char)6U, (unsigned char)7U, (unsigned char)8U, (unsigned char)9U, (unsigned char)10U, (unsigned char)11U, (unsigned char)12U, (unsigned char)13U, (unsigned char)14U};

#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u8 const iwl_eeprom_band_2[13U] = {(unsigned char)183U, (unsigned char)184U, (unsigned char)185U, (unsigned char)187U, (unsigned char)188U, (unsigned char)189U, (unsigned char)192U, (unsigned char)196U, (unsigned char)7U, (unsigned char)8U, (unsigned char)11U, (unsigned char)12U, (unsigned char)16U};

#line 155  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u8 const iwl_eeprom_band_3[12U] = {(unsigned char)34U, (unsigned char)36U, (unsigned char)38U, (unsigned char)40U, (unsigned char)42U, (unsigned char)44U, (unsigned char)46U, (unsigned char)48U, (unsigned char)52U, (unsigned char)56U, (unsigned char)60U, (unsigned char)64U};

#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u8 const iwl_eeprom_band_4[11U] = {(unsigned char)100U, (unsigned char)104U, (unsigned char)108U, (unsigned char)112U, (unsigned char)116U, (unsigned char)120U, (unsigned char)124U, (unsigned char)128U, (unsigned char)132U, (unsigned char)136U, (unsigned char)140U};

#line 163  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u8 const iwl_eeprom_band_5[6U] = {(unsigned char)145U, (unsigned char)149U, (unsigned char)153U, (unsigned char)157U, (unsigned char)161U, (unsigned char)165U};

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u8 const iwl_eeprom_band_6[7U] = {(unsigned char)1U, (unsigned char)2U, (unsigned char)3U, (unsigned char)4U, (unsigned char)5U, (unsigned char)6U, (unsigned char)7U};

#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u8 const iwl_eeprom_band_7[11U] = {(unsigned char)36U, (unsigned char)44U, (unsigned char)52U, (unsigned char)60U, (unsigned char)100U, (unsigned char)108U, (unsigned char)116U, (unsigned char)124U, (unsigned char)132U, (unsigned char)149U, (unsigned char)157U};

#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static struct ieee80211_rate iwl_cfg80211_rates[12U] = {{.flags = 0U, .bitrate = (unsigned short)10U, .hw_value = (unsigned short)0U, .hw_value_short = (unsigned short)0U}, {.flags = 1U, .bitrate = (unsigned short)20U, .hw_value = (unsigned short)1U, .hw_value_short = (unsigned short)1U}, {.flags = 1U, .bitrate = (unsigned short)55U, .hw_value = (unsigned short)2U, .hw_value_short = (unsigned short)2U}, {.flags = 1U, .bitrate = (unsigned short)110U, .hw_value = (unsigned short)3U, .hw_value_short = (unsigned short)3U}, {.flags = 0U, .bitrate = (unsigned short)60U, .hw_value = (unsigned short)4U, .hw_value_short = (unsigned short)4U}, {.flags = 0U, .bitrate = (unsigned short)90U, .hw_value = (unsigned short)5U, .hw_value_short = (unsigned short)5U}, {.flags = 0U, .bitrate = (unsigned short)120U, .hw_value = (unsigned short)6U, .hw_value_short = (unsigned short)6U}, {.flags = 0U, .bitrate = (unsigned short)180U, .hw_value = (unsigned short)7U, .hw_value_short = (unsigned short)7U}, {.flags = 0U, .bitrate = (unsigned short)240U, .hw_value = (unsigned short)8U, .hw_value_short = (unsigned short)8U}, {.flags = 0U, .bitrate = (unsigned short)360U, .hw_value = (unsigned short)9U, .hw_value_short = (unsigned short)9U}, {.flags = 0U, .bitrate = (unsigned short)480U, .hw_value = (unsigned short)10U, .hw_value_short = (unsigned short)10U}, {.flags = 0U, .bitrate = (unsigned short)540U, .hw_value = (unsigned short)11U, .hw_value_short = (unsigned short)11U}};

#line 206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u16 iwl_eeprom_query16(u8 const *eeprom, size_t eeprom_size, int offset)
{
  u16 __retres;
  int tmp;
  u16 tmp_0;
  {
    
#line 208 
    int __ret_warn_on = (unsigned long)offset + 2UL > eeprom_size;
    
#line 208 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 208 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c",208); else ;
    
#line 208 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 208 
  if ((long)tmp != 0L) {
    
#line 209 
    __retres = (unsigned short)0U;
    
#line 209 
    goto return_label;
  }
  else ;
  
#line 210 
  tmp_0 = __le16_to_cpup((__le16 const *)(eeprom + offset));
  
#line 210 
  __retres = tmp_0;
  return_label: 
#line 210 
                return __retres;
}


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u32 eeprom_indirect_address(u8 const *eeprom, size_t eeprom_size, u32 address)
{
  u32 __retres;
  
#line 216 
  u16 offset = (unsigned short)0U;
  
#line 218 
  if ((address & 1048576U) == 0U) {
    
#line 219 
    __retres = address;
    
#line 219 
    goto return_label;
  }
  else ;
  
#line 221 
  switch (address & 983040U) {
    case (unsigned int)65536: 
#line 222 
    ;
    
#line 223 
    offset = iwl_eeprom_query16(eeprom,eeprom_size,200);
    
#line 225 
    goto ldv_50299;
    case (unsigned int)131072: 
#line 226 
    ;
    
#line 227 
    offset = iwl_eeprom_query16(eeprom,eeprom_size,202);
    
#line 229 
    goto ldv_50299;
    case (unsigned int)196608: 
#line 230 
    ;
    
#line 231 
    offset = iwl_eeprom_query16(eeprom,eeprom_size,204);
    
#line 233 
    goto ldv_50299;
    case (unsigned int)458752: 
#line 234 
    ;
    
#line 235 
    offset = iwl_eeprom_query16(eeprom,eeprom_size,212);
    
#line 237 
    goto ldv_50299;
    case (unsigned int)524288: 
#line 238 
    ;
    
#line 239 
    offset = iwl_eeprom_query16(eeprom,eeprom_size,214);
    
#line 241 
    goto ldv_50299;
    case (unsigned int)262144: 
#line 242 
    ;
    
#line 243 
    offset = iwl_eeprom_query16(eeprom,eeprom_size,206);
    
#line 245 
    goto ldv_50299;
    case (unsigned int)327680: 
#line 246 
    ;
    
#line 247 
    offset = iwl_eeprom_query16(eeprom,eeprom_size,208);
    
#line 249 
    goto ldv_50299;
    case (unsigned int)393216: 
#line 250 
    ;
    
#line 251 
    offset = iwl_eeprom_query16(eeprom,eeprom_size,210);
    
#line 253 
    goto ldv_50299;
    default: 
#line 254 
    ;
    {
      
#line 255 
      int __ret_warn_on = 1;
      
#line 255 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 255 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c",255); else ;
      
#line 255 
      long tmp = (long)(__ret_warn_on != 0);
    }
    
#line 256 
    goto ldv_50299;
  }
  ldv_50299: 
#line 260 
  ;
  
#line 260 
  __retres = (address & 65535U) + (unsigned int)((int)offset << 1);
  return_label: 
#line 260 
                return __retres;
}


#line 263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static u8 const *iwl_eeprom_query_addr(u8 const *eeprom, size_t eeprom_size, u32 offset)
{
  u8 const *__retres;
  int tmp_0;
  
#line 266 
  u32 address = eeprom_indirect_address(eeprom,eeprom_size,offset);
  {
    
#line 268 
    int __ret_warn_on = (unsigned long)address >= eeprom_size;
    
#line 268 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 268 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c",268); else ;
    
#line 268 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 268 
  if ((long)tmp_0 != 0L) {
    
#line 269 
    __retres = (u8 const *)0U;
    
#line 269 
    goto return_label;
  }
  else ;
  
#line 271 
  __retres = eeprom + address;
  return_label: 
#line 271 
                return __retres;
}


#line 274  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static int iwl_eeprom_read_calib(u8 const *eeprom, size_t eeprom_size, struct iwl_nvm_data *data)
{
  int __retres;
  struct iwl_eeprom_calib_hdr *hdr;
  
#line 279 
  hdr = (struct iwl_eeprom_calib_hdr *)iwl_eeprom_query_addr(eeprom,eeprom_size,1310720U);
  
#line 281 
  if (hdr == (struct iwl_eeprom_calib_hdr *)0) {
    
#line 282 
    __retres = -61;
    
#line 282 
    goto return_label;
  }
  else ;
  
#line 283 
  data->calib_version = hdr->version;
  
#line 284 
  data->calib_voltage = hdr->voltage;
  
#line 286 
  __retres = 0;
  return_label: 
#line 286 
                return __retres;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static s8 iwl_get_max_txpwr_half_dbm(struct iwl_nvm_data const *data, struct iwl_eeprom_enhanced_txpwr *txp)
{
  
#line 357 
  s8 result = (signed char)0;
  
#line 360 
  if (((unsigned long)data->valid_tx_ant & 1UL) != 0UL && (int)txp->chain_a_max > (int)result) 
    
#line 361 
    result = txp->chain_a_max; else ;
  
#line 363 
  if (((unsigned long)data->valid_tx_ant & 2UL) != 0UL && (int)txp->chain_b_max > (int)result) 
    
#line 364 
    result = txp->chain_b_max; else ;
  
#line 366 
  if (((unsigned long)data->valid_tx_ant & 4UL) != 0UL && (int)txp->chain_c_max > (int)result) 
    
#line 367 
    result = txp->chain_c_max; else ;
  
#line 369 
  if ((((unsigned int)data->valid_tx_ant == 3U || (unsigned int)data->valid_tx_ant == 6U) || (unsigned int)data->valid_tx_ant == 5U) && (int)txp->mimo2_max > (int)result) 
    
#line 372 
    result = txp->mimo2_max; else ;
  
#line 374 
  if ((unsigned int)data->valid_tx_ant == 7U && (int)txp->mimo3_max > (int)result) 
    
#line 375 
    result = txp->mimo3_max; else ;
  
#line 377 
  return result;
}


#line 388  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static void iwl_eeprom_enh_txp_read_element(struct iwl_nvm_data *data, struct iwl_eeprom_enhanced_txpwr *txp, int n_channels, s8 max_txpower_avg)
{
  int ch_idx;
  enum ieee80211_band band;
  
#line 395 
  band = (enum ieee80211_band)(((int)txp->flags >> 1) & 1);
  
#line 398 
  ch_idx = 0;
  
#line 398 
  goto ldv_50368;
  ldv_50367: 
#line 399 
  ;
  {
    
#line 399 
    struct ieee80211_channel *chan = & data->channels[ch_idx];
    
#line 402 
    if ((unsigned int)txp->channel != 0U && (int)chan->hw_value != (int)((unsigned short)txp->channel)) 
      
#line 403 
      goto ldv_50366; else ;
    
#line 406 
    if (chan->band != band) 
#line 407 
                            goto ldv_50366; else ;
    
#line 409 
    if (chan->max_power < (int)max_txpower_avg && ((int)txp->flags & 8) == 0) 
      
#line 411 
      chan->max_power = (int)max_txpower_avg; else ;
  }
  ldv_50366: 
#line 413 
  ;
  
#line 398 
  ch_idx += 1;
  ldv_50368: 
#line 399 
  ;
  
#line 398 
  if (ch_idx < n_channels) 
#line 400 
                           goto ldv_50367; else 
#line 403 
                                                goto ldv_50369;
  ldv_50369: 
#line 404 
  ;
  
#line 405 
  return;
}


#line 425 
void __compiletime_assert_425(void);


#line 441 
void __compiletime_assert_455(void);


#line 456 
void __compiletime_assert_459(void);


#line 460 
void __compiletime_assert_464(void);


#line 415  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static void iwl_eeprom_enhanced_txpower(struct device *dev, struct iwl_nvm_data *data, u8 const *eeprom, size_t eeprom_size, int n_channels)
{
  struct iwl_eeprom_enhanced_txpwr *txp_array;
  struct iwl_eeprom_enhanced_txpwr *txp;
  int idx;
  int entries;
  __le16 *txp_len;
  s8 max_txp_avg_halfdbm;
  __u16 tmp_0;
  char *tmp_2;
  char *tmp_3;
  char *tmp_4;
  char *tmp_5;
  char *tmp_6;
  char *tmp_7;
  char *tmp_8;
  char *tmp_9;
  char *tmp_11;
  {
    
#line 425 
    bool __cond = (_Bool)0;
    
#line 425 
    if ((int)__cond != 0) 
#line 425 
                          __compiletime_assert_425(); else ;
  }
  
#line 428 
  txp_len = (__le16 *)iwl_eeprom_query_addr(eeprom,eeprom_size,1572864U);
  
#line 430 
  tmp_0 = __le16_to_cpup((__le16 const *)txp_len);
  
#line 430 
  entries = (int)((unsigned long)((int)tmp_0 * 2) / 8UL);
  
#line 432 
  txp_array = (struct iwl_eeprom_enhanced_txpwr *)iwl_eeprom_query_addr(eeprom,eeprom_size,1507328U);
  
#line 435 
  idx = 0;
  
#line 435 
  goto ldv_50402;
  ldv_50401: 
#line 436 
  ;
  
#line 436 
  txp = txp_array + idx;
  
#line 438 
  if (((int)txp->flags & 1) == 0) 
#line 439 
                                  goto ldv_50387; else ;
  {
    
#line 441 
    bool __cond_0 = (_Bool)((int)*("%s %d:\t %s%s%s%s%s%s%s%s (0x%02x)\n" + 33UL) != 10);
    
#line 441 
    if ((int)__cond_0 != 0) 
#line 441 
                            __compiletime_assert_455(); else ;
  }
  
#line 441 
  ;
  
#line 441 
  if ((int)txp->flags < 0) 
#line 441 
                           tmp_2 = (char *)"COMMON_TYPE"; else 
#line 441 
                                                               tmp_2 = (char *)"";
  
#line 441 
  if (((int)txp->flags & 64) != 0) 
#line 441 
                                   tmp_3 = (char *)"RES2"; else 
#line 441 
                                                                tmp_3 = (char *)"";
  
#line 441 
  if (((int)txp->flags & 32) != 0) 
#line 441 
                                   tmp_4 = (char *)"RES1"; else 
#line 441 
                                                                tmp_4 = (char *)"";
  
#line 441 
  if (((int)txp->flags & 16) != 0) 
#line 441 
                                   tmp_5 = (char *)"HT_AP"; else 
#line 441 
                                                                 tmp_5 = (char *)"";
  
#line 441 
  if (((int)txp->flags & 8) != 0) 
#line 441 
                                  tmp_6 = (char *)"40MHZ"; else 
#line 441 
                                                                tmp_6 = (char *)"";
  
#line 441 
  if (((int)txp->flags & 4) != 0) 
#line 441 
                                  tmp_7 = (char *)"OFDM"; else 
#line 441 
                                                               tmp_7 = (char *)"";
  
#line 441 
  if (((int)txp->flags & 2) != 0) 
#line 441 
                                  tmp_8 = (char *)"BAND_52G"; else 
#line 441 
                                                                   tmp_8 = (char *)"";
  
#line 441 
  if (((int)txp->flags & 1) != 0) 
#line 441 
                                  tmp_9 = (char *)"VALID"; else 
#line 441 
                                                                tmp_9 = (char *)"";
  
#line 441 
  ;
  
#line 441 
  if ((unsigned int)txp->channel == 0U || (int)txp->flags >= 0) {
    char *tmp_10;
    
#line 441 
    if ((unsigned int)txp->channel != 0U) 
#line 441 
                                          tmp_10 = (char *)"Channel"; else 
                                                                    
#line 441 
                                                                    tmp_10 = (char *)"Common";
    
#line 441 
    tmp_11 = tmp_10;
  }
  else 
#line 441 
       tmp_11 = (char *)"Common ";
  
#line 441 
  ;
  
#line 441 
  __iwl_dbg(dev,64U,(_Bool)0,"iwl_eeprom_enhanced_txpower","%s %d:\t %s%s%s%s%s%s%s%s (0x%02x)\n",tmp_11,(int)txp->channel,tmp_9,tmp_8,tmp_7,tmp_6,tmp_5,tmp_4,tmp_3,tmp_2,(int)txp->flags);
  {
    
#line 456 
    bool __cond_1 = (_Bool)((int)*("\t\t chain_A: 0x%02x chain_B: 0X%02x chain_C: 0X%02x\n" + 50UL) != 10);
    
#line 456 
    if ((int)__cond_1 != 0) 
#line 456 
                            __compiletime_assert_459(); else ;
  }
  
#line 456 
  __iwl_dbg(dev,64U,(_Bool)0,"iwl_eeprom_enhanced_txpower","\t\t chain_A: 0x%02x chain_B: 0X%02x chain_C: 0X%02x\n",(int)txp->chain_a_max,(int)txp->chain_b_max,(int)txp->chain_c_max);
  {
    
#line 460 
    bool __cond_2 = (_Bool)((int)*("\t\t MIMO2: 0x%02x MIMO3: 0x%02x High 20_on_40: 0x%02x Low 20_on_40: 0x%02x\n" + 73UL) != 10);
    
#line 460 
    if ((int)__cond_2 != 0) 
#line 460 
                            __compiletime_assert_464(); else ;
  }
  
#line 460 
  __iwl_dbg(dev,64U,(_Bool)0,"iwl_eeprom_enhanced_txpower","\t\t MIMO2: 0x%02x MIMO3: 0x%02x High 20_on_40: 0x%02x Low 20_on_40: 0x%02x\n",(int)txp->mimo2_max,(int)txp->mimo3_max,(int)txp->delta_20_in_40 >> 4,(int)txp->delta_20_in_40 & 15);
  
#line 466 
  max_txp_avg_halfdbm = iwl_get_max_txpwr_half_dbm((struct iwl_nvm_data const *)data,txp);
  
#line 468 
  iwl_eeprom_enh_txp_read_element(data,txp,n_channels,(signed char)((int)((signed char)(((int)max_txp_avg_halfdbm + 1) / 2))));
  
#line 471 
  if ((int)data->max_tx_pwr_half_dbm < (int)max_txp_avg_halfdbm) 
#line 472 
                                                                 data->max_tx_pwr_half_dbm = max_txp_avg_halfdbm; else ;
  ldv_50387: 
#line 473 
  ;
  
#line 435 
  idx += 1;
  ldv_50402: 
#line 436 
  ;
  
#line 435 
  if (idx < entries) 
#line 437 
                     goto ldv_50401; else 
#line 440 
                                          goto ldv_50403;
  ldv_50403: 
#line 441 
  ;
  
#line 442 
  return;
}


#line 476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static void iwl_init_band_reference(struct iwl_cfg const *cfg, u8 const *eeprom, size_t eeprom_size, int eeprom_band, int *eeprom_ch_count, struct iwl_eeprom_channel const **ch_info, u8 const **eeprom_ch_array)
{
  
#line 482 
  u32 offset = (unsigned int)(cfg->eeprom_params)->regulatory_bands[eeprom_band + -1];
  
#line 484 
  offset |= 1245184U;
  
#line 486 
  *ch_info = (struct iwl_eeprom_channel const *)iwl_eeprom_query_addr(eeprom,eeprom_size,offset);
  
#line 488 
  switch (eeprom_band) {
    case 1: 
#line 489 
    ;
    
#line 490 
    *eeprom_ch_count = 14;
    
#line 491 
    *eeprom_ch_array = (u8 const *)(& iwl_eeprom_band_1);
    
#line 492 
    goto ldv_50418;
    case 2: 
#line 493 
    ;
    
#line 494 
    *eeprom_ch_count = 13;
    
#line 495 
    *eeprom_ch_array = (u8 const *)(& iwl_eeprom_band_2);
    
#line 496 
    goto ldv_50418;
    case 3: 
#line 497 
    ;
    
#line 498 
    *eeprom_ch_count = 12;
    
#line 499 
    *eeprom_ch_array = (u8 const *)(& iwl_eeprom_band_3);
    
#line 500 
    goto ldv_50418;
    case 4: 
#line 501 
    ;
    
#line 502 
    *eeprom_ch_count = 11;
    
#line 503 
    *eeprom_ch_array = (u8 const *)(& iwl_eeprom_band_4);
    
#line 504 
    goto ldv_50418;
    case 5: 
#line 505 
    ;
    
#line 506 
    *eeprom_ch_count = 6;
    
#line 507 
    *eeprom_ch_array = (u8 const *)(& iwl_eeprom_band_5);
    
#line 508 
    goto ldv_50418;
    case 6: 
#line 509 
    ;
    
#line 510 
    *eeprom_ch_count = 7;
    
#line 511 
    *eeprom_ch_array = (u8 const *)(& iwl_eeprom_band_6);
    
#line 512 
    goto ldv_50418;
    case 7: 
#line 513 
    ;
    
#line 514 
    *eeprom_ch_count = 11;
    
#line 515 
    *eeprom_ch_array = (u8 const *)(& iwl_eeprom_band_7);
    
#line 516 
    goto ldv_50418;
    default: 
#line 517 
    ;
    
#line 518 
    *eeprom_ch_count = 0;
    
#line 519 
    *eeprom_ch_array = (u8 const *)0U;
    {
      
#line 520 
      int __ret_warn_on = 1;
      
#line 520 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 520 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c",520); else ;
      
#line 520 
      long tmp_2 = (long)(__ret_warn_on != 0);
    }
  }
  ldv_50418: 
#line 522 
  ;
  
#line 523 
  return;
}


#line 548 
void __compiletime_assert_561(void);


#line 527  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static void iwl_mod_ht40_chan_info(struct device *dev, struct iwl_nvm_data *data, int n_channels, enum ieee80211_band band, u16 channel, struct iwl_eeprom_channel const *eeprom_ch, u8 clear_ht40_extension_channel)
{
  int i;
  char *tmp;
  char *tmp_0;
  char *tmp_1;
  char *tmp_2;
  char *tmp_3;
  char *tmp_4;
  char *tmp_5;
  
#line 533 
  struct ieee80211_channel *chan = (struct ieee80211_channel *)0;
  
#line 536 
  i = 0;
  
#line 536 
  goto ldv_50460;
  ldv_50459: 
#line 537 
  ;
  
#line 537 
  if (data->channels[i].band != band) 
#line 538 
                                      goto ldv_50457; else ;
  
#line 539 
  if ((int)data->channels[i].hw_value != (int)channel) 
#line 540 
                                                       goto ldv_50457; else ;
  
#line 541 
  chan = & data->channels[i];
  
#line 542 
  goto ldv_50458;
  ldv_50457: 
#line 543 
  ;
  
#line 536 
  i += 1;
  ldv_50460: 
#line 537 
  ;
  
#line 536 
  if (i < n_channels) 
#line 538 
                      goto ldv_50459; else 
#line 541 
                                           goto ldv_50458;
  ldv_50458: 
#line 542 
  ;
  
#line 545 
  if (chan == (struct ieee80211_channel *)0) 
#line 546 
                                             goto return_label; else ;
  {
    
#line 548 
    bool __cond = (_Bool)((int)*("HT40 Ch. %d [%sGHz] %s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n" + 64UL) != 10);
    
#line 548 
    if ((int)__cond != 0) 
#line 548 
                          __compiletime_assert_561(); else ;
  }
  
#line 548 
  if (((int)eeprom_ch->flags & 2) != 0 && ((int)eeprom_ch->flags & 16) == 0) 
    
#line 548 
    tmp = (char *)""; else 
#line 548 
                           tmp = (char *)"not ";
  
#line 548 
  ;
  
#line 548 
  ;
  
#line 548 
  if ((int)eeprom_ch->flags < 0) 
#line 548 
                                 tmp_0 = (char *)"DFS"; else 
#line 548 
                                                             tmp_0 = (char *)"";
  
#line 548 
  if (((int)eeprom_ch->flags & 32) != 0) 
#line 548 
                                         tmp_1 = (char *)"WIDE"; else 
                                                                   
#line 548 
                                                                   tmp_1 = (char *)"";
  
#line 548 
  if (((int)eeprom_ch->flags & 16) != 0) 
#line 548 
                                         tmp_2 = (char *)"RADAR"; else 
                                                                    
#line 548 
                                                                    tmp_2 = (char *)"";
  
#line 548 
  if (((int)eeprom_ch->flags & 8) != 0) 
#line 548 
                                        tmp_3 = (char *)"ACTIVE"; else 
                                                                    
#line 548 
                                                                    tmp_3 = (char *)"";
  
#line 548 
  if (((int)eeprom_ch->flags & 2) != 0) 
#line 548 
                                        tmp_4 = (char *)"IBSS"; else 
                                                                  
#line 548 
                                                                  tmp_4 = (char *)"";
  
#line 548 
  if (band == (unsigned int)IEEE80211_BAND_5GHZ) 
#line 548 
                                                 tmp_5 = (char *)"5.2"; else 
                                                                    
#line 548 
                                                                    tmp_5 = (char *)"2.4";
  
#line 548 
  ;
  
#line 548 
  ;
  
#line 548 
  __iwl_dbg(dev,64U,(_Bool)0,"iwl_mod_ht40_chan_info","HT40 Ch. %d [%sGHz] %s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n",(int)channel,tmp_5,tmp_4,tmp_3,tmp_2,tmp_1,tmp_0,(int)eeprom_ch->flags,(int)eeprom_ch->max_power_avg,tmp);
  
#line 563 
  if (((int)eeprom_ch->flags & 1) != 0) 
#line 564 
                                        chan->flags &= (unsigned int)(~ ((int)clear_ht40_extension_channel)); else ;
  return_label: 
#line 565 
                return;
}


#line 597 
void __compiletime_assert_601(void);


#line 630 
void __compiletime_assert_646(void);


#line 570  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static int iwl_init_channel_map(struct device *dev, struct iwl_cfg const *cfg, struct iwl_nvm_data *data, u8 const *eeprom, size_t eeprom_size)
{
  int __retres;
  int band;
  int ch_idx;
  struct iwl_eeprom_channel const *eeprom_ch_info;
  u8 const *eeprom_ch_array;
  int eeprom_ch_count;
  
#line 578 
  int n_channels = 0;
  
#line 583 
  band = 1;
  
#line 583 
  goto ldv_50495;
  ldv_50494: 
#line 584 
  ;
  {
    struct ieee80211_channel *channel;
    
#line 586 
    iwl_init_band_reference(cfg,eeprom,eeprom_size,band,& eeprom_ch_count,& eeprom_ch_info,& eeprom_ch_array);
    
#line 591 
    ch_idx = 0;
    
#line 591 
    goto ldv_50492;
    ldv_50491: 
#line 592 
    ;
    {
      struct iwl_eeprom_channel const *eeprom_ch;
      int tmp_0;
      char *tmp_1;
      char *tmp_2;
      char *tmp_3;
      char *tmp_4;
      char *tmp_5;
      char *tmp_6;
      char *tmp_7;
      char *tmp_8;
      
#line 594 
      eeprom_ch = eeprom_ch_info + ch_idx;
      
#line 596 
      if (((int)eeprom_ch->flags & 1) == 0) {
        char *tmp;
        {
          
#line 597 
          bool __cond = (_Bool)((int)*("Ch. %d Flags %x [%sGHz] - No traffic\n" + 36UL) != 10);
          
#line 597 
          if ((int)__cond != 0) 
#line 597 
                                __compiletime_assert_601(); else ;
        }
        
#line 597 
        if (band != 1) 
#line 597 
                       tmp = (char *)"5.2"; else 
#line 597 
                                                 tmp = (char *)"2.4";
        
#line 597 
        ;
        
#line 597 
        ;
        
#line 597 
        ;
        
#line 597 
        __iwl_dbg(dev,64U,(_Bool)0,"iwl_init_channel_map","Ch. %d Flags %x [%sGHz] - No traffic\n",(int)*(eeprom_ch_array + ch_idx),(int)(eeprom_ch_info + ch_idx)->flags,tmp);
        
#line 602 
        goto ldv_50486;
      }
      else ;
      
#line 605 
      channel = & data->channels[n_channels];
      
#line 606 
      n_channels += 1;
      
#line 608 
      channel->hw_value = (unsigned short)*(eeprom_ch_array + ch_idx);
      
#line 609 
      channel->band = (enum ieee80211_band)(band != 1);
      
#line 611 
      tmp_0 = ieee80211_channel_to_frequency((int)channel->hw_value,channel->band);
      
#line 611 
      channel->center_freq = (unsigned short)tmp_0;
      
#line 616 
      channel->flags = 48U;
      
#line 618 
      if (((int)eeprom_ch->flags & 2) == 0) 
#line 619 
                                            channel->flags |= 2U; else ;
      
#line 621 
      if (((int)eeprom_ch->flags & 8) == 0) 
#line 622 
                                            channel->flags |= 2U; else ;
      
#line 624 
      if (((int)eeprom_ch->flags & 16) != 0) 
#line 625 
                                             channel->flags |= 8U; else ;
      
#line 628 
      channel->max_power = (int)(eeprom_ch_info + ch_idx)->max_power_avg;
      {
        
#line 630 
        bool __cond_0 = (_Bool)((int)*("Ch. %d [%sGHz] %s%s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n" + 61UL) != 10);
        
#line 630 
        if ((int)__cond_0 != 0) 
#line 630 
                                __compiletime_assert_646(); else ;
      }
      
#line 630 
      if (((int)(eeprom_ch_info + ch_idx)->flags & 2) != 0 && ((int)(eeprom_ch_info + ch_idx)->flags & 16) == 0) 
        
#line 630 
        tmp_1 = (char *)""; else 
#line 630 
                                 tmp_1 = (char *)"not ";
      
#line 630 
      ;
      
#line 630 
      ;
      
#line 630 
      if ((int)(eeprom_ch_info + ch_idx)->flags < 0) 
#line 630 
                                                     tmp_2 = (char *)"DFS"; else 
                                                                    
#line 630 
                                                                    tmp_2 = (char *)"";
      
#line 630 
      if (((int)(eeprom_ch_info + ch_idx)->flags & 32) != 0) 
#line 630 
                                                             tmp_3 = (char *)"WIDE"; else 
                                                                    
#line 630 
                                                                    tmp_3 = (char *)"";
      
#line 630 
      if (((int)(eeprom_ch_info + ch_idx)->flags & 16) != 0) 
#line 630 
                                                             tmp_4 = (char *)"RADAR"; else 
                                                                    
#line 630 
                                                                    tmp_4 = (char *)"";
      
#line 630 
      if (((int)(eeprom_ch_info + ch_idx)->flags & 8) != 0) 
#line 630 
                                                            tmp_5 = (char *)"ACTIVE"; else 
                                                                    
#line 630 
                                                                    tmp_5 = (char *)"";
      
#line 630 
      if (((int)(eeprom_ch_info + ch_idx)->flags & 2) != 0) 
#line 630 
                                                            tmp_6 = (char *)"IBSS"; else 
                                                                    
#line 630 
                                                                    tmp_6 = (char *)"";
      
#line 630 
      if (((int)(eeprom_ch_info + ch_idx)->flags & 1) != 0) 
#line 630 
                                                            tmp_7 = (char *)"VALID"; else 
                                                                    
#line 630 
                                                                    tmp_7 = (char *)"";
      
#line 630 
      if (band != 1) 
#line 630 
                     tmp_8 = (char *)"5.2"; else 
#line 630 
                                                 tmp_8 = (char *)"2.4";
      
#line 630 
      ;
      
#line 630 
      ;
      
#line 630 
      __iwl_dbg(dev,64U,(_Bool)0,"iwl_init_channel_map","Ch. %d [%sGHz] %s%s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n",(int)channel->hw_value,tmp_8,tmp_7,tmp_6,tmp_5,tmp_4,tmp_3,tmp_2,(int)(eeprom_ch_info + ch_idx)->flags,(int)(eeprom_ch_info + ch_idx)->max_power_avg,tmp_1);
    }
    ldv_50486: 
#line 632 
    ;
    
#line 591 
    ch_idx += 1;
    ldv_50492: 
#line 592 
    ;
    
#line 591 
    if (ch_idx < eeprom_ch_count) 
#line 593 
                                  goto ldv_50491; else 
#line 596 
                                                       goto ldv_50493;
    ldv_50493: 
#line 597 
    ;
  }
  
#line 583 
  band += 1;
  ldv_50495: 
#line 584 
  ;
  
#line 583 
  if (band <= 5) 
#line 585 
                 goto ldv_50494; else 
#line 588 
                                      goto ldv_50496;
  ldv_50496: 
#line 589 
  ;
  
#line 650 
  if ((int)(cfg->eeprom_params)->enhanced_txpower != 0) 
#line 657 
                                                        iwl_eeprom_enhanced_txpower(dev,data,eeprom,eeprom_size,n_channels);
  else {
    int i;
    int tmp_10;
    
#line 663 
    data->max_tx_pwr_half_dbm = (signed char)(-128);
    
#line 665 
    i = 0;
    
#line 665 
    goto ldv_50502;
    ldv_50501: 
#line 666 
    ;
    {
      int tmp_9;
      
#line 667 
      s8 __max1 = data->max_tx_pwr_half_dbm;
      
#line 667 
      s8 __max2 = (signed char)((unsigned int)data->channels[i].max_power * 2U);
      
#line 667 
      if ((int)__max1 > (int)__max2) 
#line 667 
                                     tmp_9 = (int)__max1; else 
#line 667 
                                                               tmp_9 = (int)__max2;
      
#line 667 
      tmp_10 = tmp_9;
    }
    
#line 666 
    data->max_tx_pwr_half_dbm = (signed char)tmp_10;
    
#line 665 
    i += 1;
    ldv_50502: 
#line 666 
    ;
    
#line 665 
    if (i < n_channels) 
#line 667 
                        goto ldv_50501; else 
#line 670 
                                             goto ldv_50503;
    ldv_50503: 
#line 671 
    ;
  }
  
#line 672 
  if ((unsigned int)(cfg->eeprom_params)->regulatory_bands[5] == 0U && (unsigned int)(cfg->eeprom_params)->regulatory_bands[6] == 0U) {
    
#line 676 
    __retres = n_channels;
    
#line 676 
    goto return_label;
  }
  else ;
  
#line 679 
  band = 6;
  
#line 679 
  goto ldv_50509;
  ldv_50508: 
#line 680 
  ;
  {
    enum ieee80211_band ieeeband;
    
#line 682 
    iwl_init_band_reference(cfg,eeprom,eeprom_size,band,& eeprom_ch_count,& eeprom_ch_info,& eeprom_ch_array);
    
#line 687 
    ieeeband = (enum ieee80211_band)(band != 6);
    
#line 691 
    ch_idx = 0;
    
#line 691 
    goto ldv_50506;
    ldv_50505: 
#line 692 
    ;
    
#line 693 
    iwl_mod_ht40_chan_info(dev,data,n_channels,ieeeband,(unsigned short)((int)*(eeprom_ch_array + ch_idx)),eeprom_ch_info + ch_idx,(unsigned char)16);
    
#line 699 
    iwl_mod_ht40_chan_info(dev,data,n_channels,ieeeband,(unsigned short)((int)((unsigned int)((unsigned short)*(eeprom_ch_array + ch_idx)) + 4U)),eeprom_ch_info + ch_idx,(unsigned char)32);
    
#line 691 
    ch_idx += 1;
    ldv_50506: 
#line 692 
    ;
    
#line 691 
    if (ch_idx < eeprom_ch_count) 
#line 693 
                                  goto ldv_50505; else 
#line 696 
                                                       goto ldv_50507;
    ldv_50507: 
#line 697 
    ;
  }
  
#line 679 
  band += 1;
  ldv_50509: 
#line 680 
  ;
  
#line 679 
  if (band <= 7) 
#line 681 
                 goto ldv_50508; else 
#line 684 
                                      goto ldv_50510;
  ldv_50510: 
#line 685 
  ;
  
#line 706 
  __retres = n_channels;
  return_label: 
#line 706 
                return __retres;
}


#line 709  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
int iwl_init_sband_channels(struct iwl_nvm_data *data, struct ieee80211_supported_band *sband, int n_channels, enum ieee80211_band band)
{
  
#line 713 
  struct ieee80211_channel *chan = & data->channels[0];
  
#line 714 
  int n = 0;
  
#line 714 
  int idx = 0;
  
#line 716 
  goto ldv_50521;
  ldv_50520: 
#line 717 
  ;
  
#line 717 
  idx += 1;
  
#line 717 
  chan = & data->channels[idx];
  ldv_50521: 
#line 718 
  ;
  
#line 716 
  if (chan->band != band && idx < n_channels) 
#line 718 
                                              goto ldv_50520; else 
#line 721 
                                                                   goto ldv_50522;
  ldv_50522: 
#line 722 
  ;
  
#line 719 
  sband->channels = & data->channels[idx];
  
#line 721 
  goto ldv_50524;
  ldv_50523: 
#line 722 
  ;
  
#line 722 
  idx += 1;
  
#line 722 
  chan = & data->channels[idx];
  
#line 723 
  n += 1;
  ldv_50524: 
#line 724 
  ;
  
#line 721 
  if (chan->band == band && idx < n_channels) 
#line 723 
                                              goto ldv_50523; else 
#line 726 
                                                                   goto ldv_50525;
  ldv_50525: 
#line 727 
  ;
  
#line 726 
  sband->n_channels = n;
  
#line 728 
  return n;
}


#line 734  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
void iwl_init_ht_hw_capab(struct iwl_cfg const *cfg, struct iwl_nvm_data *data, struct ieee80211_sta_ht_cap *ht_info, enum ieee80211_band band, u8 tx_chains, u8 rx_chains)
{
  
#line 740 
  int max_bit_rate = 0;
  
#line 742 
  if (0 != 0) 
#line 742 
              tx_chains = (unsigned char)((((((((((unsigned long long)tx_chains & 1ULL) != 0ULL) + (((unsigned long long)tx_chains & 2ULL) != 0ULL)) + (((unsigned long long)tx_chains & 4ULL) != 0ULL)) + (((unsigned long long)tx_chains & 8ULL) != 0ULL)) + (((unsigned long long)tx_chains & 16ULL) != 0ULL)) + (((unsigned long long)tx_chains & 32ULL) != 0ULL)) + (((unsigned long long)tx_chains & 64ULL) != 0ULL)) + ((int)tx_chains < 0));
  else {
    unsigned int tmp;
    
#line 742 
    tmp = __arch_hweight8((unsigned int)tx_chains);
    
#line 742 
    tx_chains = (unsigned char)tmp;
  }
  
#line 743 
  if ((int)cfg->rx_with_siso_diversity != 0) 
#line 744 
                                             rx_chains = (unsigned char)1U;
  else 
    
#line 746 
    if (0 != 0) 
#line 746 
                rx_chains = (unsigned char)((((((((((unsigned long long)rx_chains & 1ULL) != 0ULL) + (((unsigned long long)rx_chains & 2ULL) != 0ULL)) + (((unsigned long long)rx_chains & 4ULL) != 0ULL)) + (((unsigned long long)rx_chains & 8ULL) != 0ULL)) + (((unsigned long long)rx_chains & 16ULL) != 0ULL)) + (((unsigned long long)rx_chains & 32ULL) != 0ULL)) + (((unsigned long long)rx_chains & 64ULL) != 0ULL)) + ((int)rx_chains < 0));
    else {
      unsigned int tmp_0;
      
#line 746 
      tmp_0 = __arch_hweight8((unsigned int)rx_chains);
      
#line 746 
      rx_chains = (unsigned char)tmp_0;
    }
  
#line 748 
  if (! data->sku_cap_11n_enable || cfg->ht_params == (struct iwl_ht_params const *)0) {
    
#line 749 
    ht_info->ht_supported = (_Bool)0;
    
#line 750 
    goto return_label;
  }
  else ;
  
#line 753 
  if ((int)data->sku_cap_mimo_disabled != 0) 
#line 754 
                                             rx_chains = (unsigned char)1U; else ;
  
#line 756 
  ht_info->ht_supported = (_Bool)1;
  
#line 757 
  ht_info->cap = (unsigned short)4096U;
  
#line 759 
  if ((int)(cfg->ht_params)->stbc != 0) {
    
#line 760 
    ht_info->cap = (unsigned short)((unsigned int)ht_info->cap | 256U);
    
#line 762 
    if ((unsigned int)tx_chains > 1U) 
#line 763 
                                      ht_info->cap = (unsigned short)((unsigned int)ht_info->cap | 128U); else ;
  }
  else ;
  
#line 766 
  if ((int)(cfg->ht_params)->ldpc != 0) 
#line 767 
                                        ht_info->cap = (unsigned short)((unsigned int)ht_info->cap | 1U); else ;
  
#line 769 
  if (iwlwifi_mod_params.amsdu_size_8K != 0) 
#line 770 
                                             ht_info->cap = (unsigned short)((unsigned int)ht_info->cap | 2048U); else ;
  
#line 772 
  ht_info->ampdu_factor = (unsigned char)cfg->max_ht_ampdu_exponent;
  
#line 773 
  ht_info->ampdu_density = (unsigned char)5U;
  
#line 775 
  ht_info->mcs.rx_mask[0] = (unsigned char)255U;
  
#line 776 
  if ((unsigned int)rx_chains > 1U) 
#line 777 
                                    ht_info->mcs.rx_mask[1] = (unsigned char)255U; else ;
  
#line 778 
  if ((unsigned int)rx_chains > 2U) 
#line 779 
                                    ht_info->mcs.rx_mask[2] = (unsigned char)255U; else ;
  
#line 781 
  if ((int)(cfg->ht_params)->ht_greenfield_support != 0) 
#line 782 
                                                         ht_info->cap = (unsigned short)((unsigned int)ht_info->cap | 16U); else ;
  
#line 783 
  ht_info->cap = (unsigned short)((unsigned int)ht_info->cap | 32U);
  
#line 785 
  max_bit_rate = 72;
  
#line 787 
  if ((((unsigned long)(cfg->ht_params)->ht40_bands >> (unsigned int)band) & 1UL) != 0UL) {
    
#line 788 
    ht_info->cap = (unsigned short)((unsigned int)ht_info->cap | 2U);
    
#line 789 
    ht_info->cap = (unsigned short)((unsigned int)ht_info->cap | 64U);
    
#line 790 
    max_bit_rate = 150;
  }
  else ;
  
#line 794 
  max_bit_rate = (int)rx_chains * max_bit_rate;
  {
    
#line 795 
    int __ret_warn_on = (max_bit_rate & -1024) != 0;
    
#line 795 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 795 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c",795); else ;
    
#line 795 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 796 
  ht_info->mcs.rx_highest = (unsigned short)max_bit_rate;
  
#line 799 
  ht_info->mcs.tx_params = (unsigned char)1U;
  
#line 800 
  if ((int)tx_chains != (int)rx_chains) {
    
#line 801 
    ht_info->mcs.tx_params = (unsigned char)((unsigned int)ht_info->mcs.tx_params | 2U);
    
#line 802 
    ht_info->mcs.tx_params = (unsigned char)((int)ht_info->mcs.tx_params | (((int)tx_chains + -1) << 2));
  }
  else ;
  return_label: 
#line 804 
                return;
}


#line 835 
void __compiletime_assert_836(void);


#line 807  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static void iwl_init_sbands(struct device *dev, struct iwl_cfg const *cfg, struct iwl_nvm_data *data, u8 const *eeprom, size_t eeprom_size)
{
  struct ieee80211_supported_band *sband;
  int tmp_0;
  int tmp_1;
  
#line 811 
  int n_channels = iwl_init_channel_map(dev,cfg,data,eeprom,eeprom_size);
  
#line 813 
  int n_used = 0;
  
#line 816 
  sband = & data->bands[0];
  
#line 817 
  sband->band = IEEE80211_BAND_2GHZ;
  
#line 818 
  sband->bitrates = &(iwl_cfg80211_rates[0]);
  
#line 819 
  sband->n_bitrates = 12;
  
#line 820 
  tmp_0 = iwl_init_sband_channels(data,sband,n_channels,(enum ieee80211_band)IEEE80211_BAND_2GHZ);
  
#line 821 
  n_used = tmp_0 + n_used;
  
#line 822 
  iwl_init_ht_hw_capab(cfg,data,& sband->ht_cap,(enum ieee80211_band)IEEE80211_BAND_2GHZ,(unsigned char)((int)data->valid_tx_ant),(unsigned char)((int)data->valid_rx_ant));
  
#line 825 
  sband = & data->bands[1];
  
#line 826 
  sband->band = IEEE80211_BAND_5GHZ;
  
#line 827 
  sband->bitrates = & iwl_cfg80211_rates[4];
  
#line 828 
  sband->n_bitrates = 8;
  
#line 829 
  tmp_1 = iwl_init_sband_channels(data,sband,n_channels,(enum ieee80211_band)IEEE80211_BAND_5GHZ);
  
#line 830 
  n_used = tmp_1 + n_used;
  
#line 831 
  iwl_init_ht_hw_capab(cfg,data,& sband->ht_cap,(enum ieee80211_band)IEEE80211_BAND_5GHZ,(unsigned char)((int)data->valid_tx_ant),(unsigned char)((int)data->valid_rx_ant));
  
#line 834 
  if (n_channels != n_used) {
    {
      
#line 835 
      bool __cond = (_Bool)((int)*("EEPROM: used only %d of %d channels\n" + 35UL) != 10);
      
#line 835 
      if ((int)__cond != 0) 
#line 835 
                            __compiletime_assert_836(); else ;
    }
    
#line 835 
    __iwl_err(dev,(_Bool)0,(_Bool)0,"EEPROM: used only %d of %d channels\n",n_used,n_channels);
  }
  else ;
  
#line 837 
  return;
}


#line 916 
void __compiletime_assert_917(void);


#line 842  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
struct iwl_nvm_data *iwl_parse_eeprom_data(struct device *dev, struct iwl_cfg const *cfg, u8 const *eeprom, size_t eeprom_size)
{
  struct iwl_nvm_data *__retres;
  struct iwl_nvm_data *data;
  void const *tmp;
  u16 radio_cfg;
  u16 sku;
  int tmp_0;
  u16 tmp_3;
  int tmp_4;
  u16 tmp_8;
  {
    
#line 849 
    int __ret_warn_on = (cfg == (struct iwl_cfg const *)0 || cfg->eeprom_params == (struct iwl_eeprom_params const *)0) != 0;
    
#line 849 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 849 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c",849); else ;
    
#line 849 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 849 
  if ((long)tmp_0 != 0L) {
    
#line 850 
    __retres = (struct iwl_nvm_data *)0;
    
#line 850 
    goto return_label;
  }
  else ;
  
#line 852 
  data = (struct iwl_nvm_data *)kzalloc_0(3848UL,208U);
  
#line 855 
  if (data == (struct iwl_nvm_data *)0) {
    
#line 856 
    __retres = (struct iwl_nvm_data *)0;
    
#line 856 
    goto return_label;
  }
  else ;
  
#line 859 
  tmp = (void const *)iwl_eeprom_query_addr(eeprom,eeprom_size,42U);
  
#line 860 
  if (tmp == (void const *)0) 
#line 861 
                              goto err_free; else ;
  
#line 862 
  memcpy((void *)(& data->hw_addr),tmp,6UL);
  
#line 863 
  tmp_3 = iwl_eeprom_query16(eeprom,eeprom_size,152);
  
#line 863 
  data->n_hw_addrs = (int)tmp_3;
  
#line 866 
  tmp_4 = iwl_eeprom_read_calib(eeprom,eeprom_size,data);
  
#line 866 
  if (tmp_4 != 0) 
#line 867 
                  goto err_free; else ;
  
#line 869 
  tmp = (void const *)iwl_eeprom_query_addr(eeprom,eeprom_size,1311312U);
  
#line 870 
  if (tmp == (void const *)0) 
#line 871 
                              goto err_free; else ;
  
#line 872 
  memcpy((void *)(& data->xtal_calib),tmp,4UL);
  
#line 874 
  tmp = (void const *)iwl_eeprom_query_addr(eeprom,eeprom_size,1311318U);
  
#line 876 
  if (tmp == (void const *)0) 
#line 877 
                              goto err_free; else ;
  
#line 878 
  data->raw_temperature = *((__le16 *)tmp);
  
#line 880 
  tmp = (void const *)iwl_eeprom_query_addr(eeprom,eeprom_size,1311316U);
  
#line 882 
  if (tmp == (void const *)0) 
#line 883 
                              goto err_free; else ;
  
#line 884 
  data->kelvin_temperature = *((__le16 *)tmp);
  
#line 885 
  data->kelvin_voltage = *((__le16 *)tmp + 1U);
  
#line 887 
  radio_cfg = iwl_eeprom_query16(eeprom,eeprom_size,144);
  
#line 889 
  data->radio_cfg_dash = (unsigned char)((unsigned int)((unsigned char)((int)radio_cfg >> 4)) & 3U);
  
#line 890 
  data->radio_cfg_pnum = (unsigned char)((unsigned int)((unsigned char)((int)radio_cfg >> 6)) & 3U);
  
#line 891 
  data->radio_cfg_step = (unsigned char)((unsigned int)((unsigned char)((int)radio_cfg >> 2)) & 3U);
  
#line 892 
  data->radio_cfg_type = (unsigned short)((unsigned int)radio_cfg & 3U);
  
#line 893 
  data->valid_rx_ant = (unsigned char)((unsigned int)((unsigned char)((int)radio_cfg >> 12)) & 15U);
  
#line 894 
  data->valid_tx_ant = (unsigned char)((unsigned int)((unsigned char)((int)radio_cfg >> 8)) & 15U);
  
#line 896 
  sku = iwl_eeprom_query16(eeprom,eeprom_size,138);
  
#line 898 
  data->sku_cap_11n_enable = (_Bool)(((int)sku & 64) != 0);
  
#line 899 
  data->sku_cap_amt_enable = (_Bool)(((int)sku & 128) != 0);
  
#line 900 
  data->sku_cap_band_24GHz_enable = (_Bool)(((int)sku & 16) != 0);
  
#line 901 
  data->sku_cap_band_52GHz_enable = (_Bool)(((int)sku & 32) != 0);
  
#line 902 
  data->sku_cap_ipan_enable = (_Bool)(((int)sku & 256) != 0);
  
#line 903 
  if ((iwlwifi_mod_params.disable_11n & 1U) != 0U) 
#line 904 
                                                   data->sku_cap_11n_enable = (_Bool)0; else ;
  
#line 906 
  tmp_8 = iwl_eeprom_query16(eeprom,eeprom_size,136);
  
#line 906 
  data->nvm_version = (unsigned int)tmp_8;
  
#line 910 
  if ((unsigned int)cfg->valid_tx_ant != 0U) 
#line 911 
                                             data->valid_tx_ant = cfg->valid_tx_ant; else ;
  
#line 912 
  if ((unsigned int)cfg->valid_rx_ant != 0U) 
#line 913 
                                             data->valid_rx_ant = cfg->valid_rx_ant; else ;
  
#line 915 
  if ((unsigned int)data->valid_tx_ant == 0U || (unsigned int)data->valid_rx_ant == 0U) {
    {
      
#line 916 
      bool __cond = (_Bool)((int)*("invalid antennas (0x%x, 0x%x)\n" + 29UL) != 10);
      
#line 916 
      if ((int)__cond != 0) 
#line 916 
                            __compiletime_assert_917(); else ;
    }
    
#line 916 
    __iwl_err(dev,(_Bool)0,(_Bool)0,"invalid antennas (0x%x, 0x%x)\n",(int)data->valid_tx_ant,(int)data->valid_rx_ant);
    
#line 918 
    goto err_free;
  }
  else ;
  
#line 921 
  iwl_init_sbands(dev,cfg,data,eeprom,eeprom_size);
  
#line 923 
  __retres = data;
  
#line 923 
  goto return_label;
  err_free: 
#line 924 
  ;
  
#line 925 
  kfree((void const *)data);
  
#line 926 
  __retres = (struct iwl_nvm_data *)0;
  return_label: 
#line 926 
                return __retres;
}


#line 928  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static char const __kstrtab_iwl_parse_eeprom_data[22U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'p', (char)'a', (char)'r', (char)'s', (char)'e', (char)'_', (char)'e', (char)'e', (char)'p', (char)'r', (char)'o', (char)'m', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'\000'};

#line 928 
struct kernel_symbol const __ksymtab_iwl_parse_eeprom_data;


#line 928  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
struct kernel_symbol const __ksymtab_iwl_parse_eeprom_data = {.value = (unsigned long)(& iwl_parse_eeprom_data), .name = (char const *)(& __kstrtab_iwl_parse_eeprom_data)};

#line 936 
void __compiletime_assert_937(void);


#line 941 
void __compiletime_assert_944(void);


#line 931  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
int iwl_nvm_check_version(struct iwl_nvm_data *data, struct iwl_trans *trans)
{
  int __retres;
  
#line 934 
  if (data->nvm_version >= (unsigned int)(trans->cfg)->nvm_ver || (int)((unsigned short)data->calib_version) >= (int)(trans->cfg)->nvm_calib_ver) {
    {
      
#line 936 
      bool __cond = (_Bool)((int)*("device EEPROM VER=0x%x, CALIB=0x%x\n" + 34UL) != 10);
      
#line 936 
      if ((int)__cond != 0) 
#line 936 
                            __compiletime_assert_937(); else ;
    }
    
#line 936 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_nvm_check_version","device EEPROM VER=0x%x, CALIB=0x%x\n",data->nvm_version,(int)data->calib_version);
    
#line 938 
    __retres = 0;
    
#line 938 
    goto return_label;
  }
  else ;
  {
    
#line 941 
    bool __cond_0 = (_Bool)((int)*("Unsupported (too old) EEPROM VER=0x%x < 0x%x CALIB=0x%x < 0x%x\n" + 62UL) != 10);
    
#line 941 
    if ((int)__cond_0 != 0) 
#line 941 
                            __compiletime_assert_944(); else ;
  }
  
#line 941 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Unsupported (too old) EEPROM VER=0x%x < 0x%x CALIB=0x%x < 0x%x\n",data->nvm_version,(int)(trans->cfg)->nvm_ver,(int)data->calib_version,(int)(trans->cfg)->nvm_calib_ver);
  
#line 945 
  __retres = -22;
  return_label: 
#line 945 
                return __retres;
}


#line 947  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
static char const __kstrtab_iwl_nvm_check_version[22U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'n', (char)'v', (char)'m', (char)'_', (char)'c', (char)'h', (char)'e', (char)'c', (char)'k', (char)'_', (char)'v', (char)'e', (char)'r', (char)'s', (char)'i', (char)'o', (char)'n', (char)'\000'};

#line 947 
struct kernel_symbol const __ksymtab_iwl_nvm_check_version;


#line 947  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c"
struct kernel_symbol const __ksymtab_iwl_nvm_check_version = {.value = (unsigned long)(& iwl_nvm_check_version), .name = (char const *)(& __kstrtab_iwl_nvm_check_version)};

#line 418  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-eeprom-parse.c.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 421 
  tmp = ldv_kzalloc(size,flags);
  
#line 421 
  return tmp;
}


#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_cfg const iwl8260_2n_cfg;


#line 429 
struct iwl_cfg const iwl8260_2ac_cfg;


#line 430 
struct iwl_cfg const iwl4165_2ac_cfg;


#line 431 
struct iwl_cfg const iwl8260_2ac_sdio_cfg;


#line 432 
struct iwl_cfg const iwl4165_2ac_sdio_cfg;


#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-8000.c"
static struct iwl_base_params const iwl8000_base_params = {.eeprom_size = 32768, .num_of_queues = 20, .pll_cfg_val = 0U, .max_ll_items = (unsigned short)0, .shadow_ram_support = (_Bool)1, .led_compensation = (unsigned short)57U, .wd_timeout = 10000U, .max_event_log_size = 512U, .shadow_reg_enable = (_Bool)1, .pcie_l1_allowed = (_Bool)1, .apmg_wake_up_wa = (_Bool)0, .scd_chain_ext_wa = (_Bool)0};

#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-8000.c"
static struct iwl_ht_params const iwl8000_ht_params = {.smps_mode = 0, .ht_greenfield_support = (_Bool)0, .stbc = (_Bool)1, .ldpc = (_Bool)1, .use_rts_for_aggregation = (_Bool)0, .ht40_bands = (unsigned char)3U};

#line 125  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-8000.c"
static struct iwl_tt_params const iwl8000_tt_params = {.ct_kill_entry = 115, .ct_kill_exit = 93, .ct_kill_duration = 5U, .dynamic_smps_entry = 111, .dynamic_smps_exit = 107, .tx_protection_entry = 112, .tx_protection_exit = 105, .tx_backoff = {{.temperature = 110, .backoff = 200U}, {.temperature = 111, .backoff = 600U}, {.temperature = 112, .backoff = 1200U}, {.temperature = 113, .backoff = 2000U}, {.temperature = 114, .backoff = 4000U}}, .support_ct_kill = (_Bool)1, .support_dynamic_smps = (_Bool)1, .support_tx_protection = (_Bool)1, .support_tx_backoff = (_Bool)1};

#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-8000.c"
struct iwl_cfg const iwl8260_2n_cfg = {.name = "Intel(R) Dual Band Wireless N 8260", .fw_name_pre = "iwlwifi-8000", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_8000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl8000_base_params, .ht_params = & iwl8000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)1, .nvm_hw_section_num = (unsigned char)10U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = "nvmData-8000B", .default_nvm_file_C_step = "nvmData-8000C", .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 0U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 98304U, .dccm2_offset = 8912896U, .dccm2_len = 32768U, .smem_offset = 4194304U, .smem_len = 425984U, .thermal_params = & iwl8000_tt_params, .apmg_not_supported = (_Bool)1};

#line 178  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-8000.c"
struct iwl_cfg const iwl8260_2ac_cfg = {.name = "Intel(R) Dual Band Wireless AC 8260", .fw_name_pre = "iwlwifi-8000", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_8000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl8000_base_params, .ht_params = & iwl8000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)1, .nvm_hw_section_num = (unsigned char)10U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = "nvmData-8000B", .default_nvm_file_C_step = "nvmData-8000C", .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 98304U, .dccm2_offset = 8912896U, .dccm2_len = 32768U, .smem_offset = 4194304U, .smem_len = 425984U, .thermal_params = & iwl8000_tt_params, .apmg_not_supported = (_Bool)1};

#line 188  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-8000.c"
struct iwl_cfg const iwl4165_2ac_cfg = {.name = "Intel(R) Dual Band Wireless AC 4165", .fw_name_pre = "iwlwifi-8000", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_8000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl8000_base_params, .ht_params = & iwl8000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)1, .nvm_hw_section_num = (unsigned char)10U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = "nvmData-8000B", .default_nvm_file_C_step = "nvmData-8000C", .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 98304U, .dccm2_offset = 8912896U, .dccm2_len = 32768U, .smem_offset = 4194304U, .smem_len = 425984U, .thermal_params = & iwl8000_tt_params, .apmg_not_supported = (_Bool)1};

#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-8000.c"
struct iwl_cfg const iwl8260_2ac_sdio_cfg = {.name = "Intel(R) Dual Band Wireless-AC 8260", .fw_name_pre = "iwlwifi-8000", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_8000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl8000_base_params, .ht_params = & iwl8000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)1, .nvm_hw_section_num = (unsigned char)10U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = "nvmData-8000B", .default_nvm_file_C_step = "nvmData-8000C", .max_rx_agg_size = 28U, .disable_dummy_notification = (_Bool)1, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 2U, .max_vht_ampdu_exponent = 2U, .dccm_offset = 8388608U, .dccm_len = 98304U, .dccm2_offset = 8912896U, .dccm2_len = 32768U, .smem_offset = 4194304U, .smem_len = 425984U, .thermal_params = & iwl8000_tt_params, .apmg_not_supported = (_Bool)1};

#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-8000.c"
struct iwl_cfg const iwl4165_2ac_sdio_cfg = {.name = "Intel(R) Dual Band Wireless-AC 4165", .fw_name_pre = "iwlwifi-8000", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_8000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)1, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl8000_base_params, .ht_params = & iwl8000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)1, .nvm_hw_section_num = (unsigned char)10U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = "nvmData-8000B", .default_nvm_file_C_step = "nvmData-8000C", .max_rx_agg_size = 28U, .disable_dummy_notification = (_Bool)1, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 2U, .max_vht_ampdu_exponent = 2U, .dccm_offset = 8388608U, .dccm_len = 98304U, .dccm2_offset = 8912896U, .dccm2_len = 32768U, .smem_offset = 4194304U, .smem_len = 425984U, .thermal_params = & iwl8000_tt_params, .apmg_not_supported = (_Bool)1};

#line 414  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_cfg const iwl7260_2ac_cfg;


#line 415 
struct iwl_cfg const iwl7260_2ac_cfg_high_temp;


#line 416 
struct iwl_cfg const iwl7260_2n_cfg;


#line 417 
struct iwl_cfg const iwl7260_n_cfg;


#line 418 
struct iwl_cfg const iwl3160_2ac_cfg;


#line 419 
struct iwl_cfg const iwl3160_2n_cfg;


#line 420 
struct iwl_cfg const iwl3160_n_cfg;


#line 421 
struct iwl_cfg const iwl3165_2ac_cfg;


#line 422 
struct iwl_cfg const iwl7265_2ac_cfg;


#line 423 
struct iwl_cfg const iwl7265_2n_cfg;


#line 424 
struct iwl_cfg const iwl7265_n_cfg;


#line 425 
struct iwl_cfg const iwl7265d_2ac_cfg;


#line 426 
struct iwl_cfg const iwl7265d_2n_cfg;


#line 427 
struct iwl_cfg const iwl7265d_n_cfg;


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
static struct iwl_base_params const iwl7000_base_params = {.eeprom_size = 16384, .num_of_queues = 20, .pll_cfg_val = 0U, .max_ll_items = (unsigned short)0, .shadow_ram_support = (_Bool)1, .led_compensation = (unsigned short)57U, .wd_timeout = 10000U, .max_event_log_size = 512U, .shadow_reg_enable = (_Bool)1, .pcie_l1_allowed = (_Bool)1, .apmg_wake_up_wa = (_Bool)1, .scd_chain_ext_wa = (_Bool)0};

#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
static struct iwl_tt_params const iwl7000_high_temp_tt_params = {.ct_kill_entry = 118, .ct_kill_exit = 96, .ct_kill_duration = 5U, .dynamic_smps_entry = 114, .dynamic_smps_exit = 110, .tx_protection_entry = 114, .tx_protection_exit = 108, .tx_backoff = {{.temperature = 112, .backoff = 300U}, {.temperature = 113, .backoff = 800U}, {.temperature = 114, .backoff = 1500U}, {.temperature = 115, .backoff = 3000U}, {.temperature = 116, .backoff = 5000U}, {.temperature = 117, .backoff = 10000U}}, .support_ct_kill = (_Bool)1, .support_dynamic_smps = (_Bool)1, .support_tx_protection = (_Bool)1, .support_tx_backoff = (_Bool)1};

#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
static struct iwl_ht_params const iwl7000_ht_params = {.smps_mode = 0, .ht_greenfield_support = (_Bool)0, .stbc = (_Bool)1, .ldpc = (_Bool)0, .use_rts_for_aggregation = (_Bool)0, .ht40_bands = (unsigned char)3U};

#line 168  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7260_2ac_cfg = {.name = "Intel(R) Dual Band Wireless AC 7260", .fw_name_pre = "iwlwifi-7260-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)1, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)1, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 81920U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7260_2ac_cfg_high_temp = {.name = "Intel(R) Dual Band Wireless AC 7260", .fw_name_pre = "iwlwifi-7260-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)1, .high_temp = (_Bool)1, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)1, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 81920U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = & iwl7000_high_temp_tt_params, .apmg_not_supported = (_Bool)0};

#line 194  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7260_2n_cfg = {.name = "Intel(R) Dual Band Wireless N 7260", .fw_name_pre = "iwlwifi-7260-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)1, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)1, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 81920U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7260_n_cfg = {.name = "Intel(R) Wireless N 7260", .fw_name_pre = "iwlwifi-7260-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)1, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)1, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 81920U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 218  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl3160_2ac_cfg = {.name = "Intel(R) Dual Band Wireless AC 3160", .fw_name_pre = "iwlwifi-3160-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)1, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 65536U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl3160_2n_cfg = {.name = "Intel(R) Dual Band Wireless N 3160", .fw_name_pre = "iwlwifi-3160-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)1, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 65536U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 240  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl3160_n_cfg = {.name = "Intel(R) Wireless N 3160", .fw_name_pre = "iwlwifi-3160-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)1, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 65536U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 251  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
static struct iwl_pwr_tx_backoff const iwl7265_pwr_tx_backoffs[8U] = {{.pwr = 1600U, .backoff = 0U}, {.pwr = 1300U, .backoff = 467U}, {.pwr = 900U, .backoff = 1900U}, {.pwr = 800U, .backoff = 2630U}, {.pwr = 700U, .backoff = 3720U}, {.pwr = 600U, .backoff = 5550U}, {.pwr = 500U, .backoff = 9350U}, {.pwr = 0U, .backoff = 0U}};

#line 262  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
static struct iwl_ht_params const iwl7265_ht_params = {.smps_mode = 0, .ht_greenfield_support = (_Bool)0, .stbc = (_Bool)1, .ldpc = (_Bool)1, .use_rts_for_aggregation = (_Bool)0, .ht40_bands = (unsigned char)3U};

#line 268  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl3165_2ac_cfg = {.name = "Intel(R) Dual Band Wireless AC 3165", .fw_name_pre = "iwlwifi-7265D-", .ucode_api_max = 15U, .ucode_api_ok = 13U, .ucode_api_min = 13U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7000_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)(& iwl7265_pwr_tx_backoffs), .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 96768U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7265_2ac_cfg = {.name = "Intel(R) Dual Band Wireless AC 7265", .fw_name_pre = "iwlwifi-7265-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7265_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)(& iwl7265_pwr_tx_backoffs), .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 96768U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 295  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7265_2n_cfg = {.name = "Intel(R) Dual Band Wireless N 7265", .fw_name_pre = "iwlwifi-7265-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7265_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)(& iwl7265_pwr_tx_backoffs), .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 96768U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 306  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7265_n_cfg = {.name = "Intel(R) Wireless N 7265", .fw_name_pre = "iwlwifi-7265-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2589U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7265_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)(& iwl7265_pwr_tx_backoffs), .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 96768U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7265d_2ac_cfg = {.name = "Intel(R) Dual Band Wireless AC 7265", .fw_name_pre = "iwlwifi-7265D-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)3089U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7265_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)(& iwl7265_pwr_tx_backoffs), .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 96768U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 328  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7265d_2n_cfg = {.name = "Intel(R) Dual Band Wireless N 7265", .fw_name_pre = "iwlwifi-7265D-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)3089U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7265_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)(& iwl7265_pwr_tx_backoffs), .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 96768U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-7000.c"
struct iwl_cfg const iwl7265d_n_cfg = {.name = "Intel(R) Wireless N 7265", .fw_name_pre = "iwlwifi-7265D-", .ucode_api_max = 15U, .ucode_api_ok = 12U, .ucode_api_min = 10U, .device_family = IWL_DEVICE_FAMILY_7000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)1U, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)3089U, .nvm_calib_ver = (unsigned short)65535U, .base_params = & iwl7000_base_params, .ht_params = & iwl7265_ht_params, .eeprom_params = (struct iwl_eeprom_params const *)0, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0U, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)(& iwl7265_pwr_tx_backoffs), .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 8388608U, .dccm_len = 96768U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const *p)
{
  __u32 __retres;
  
#line 57 
  __retres = *p;
  
#line 57 
  return __retres;
}


#line 63  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
int memcmp(void const *, void const *, size_t);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static void *ERR_PTR(long error);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
void *ldv_err_ptr(long error);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_1(size_t size, gfp_t flags);


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 96 
  __retres = (_Bool)((*((u32 const *)addr) | (unsigned int)*((u16 const *)(addr + 4U))) == 0U);
  
#line 96 
  return __retres;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const *addr)
{
  bool __retres;
  
#line 114 
  u32 a = *((u32 const *)addr);
  
#line 121 
  __retres = (_Bool)((a & 1U) != 0U);
  
#line 121 
  return __retres;
}


#line 186  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const *addr)
{
  bool __retres;
  int tmp_3;
  int tmp_0;
  bool tmp;
  
#line 190 
  tmp = is_multicast_ether_addr(addr);
  
#line 190 
  if (tmp) 
#line 190 
           tmp_0 = 0; else 
#line 190 
                           tmp_0 = 1;
  
#line 190 
  if (tmp_0) {
    int tmp_2;
    bool tmp_1;
    
#line 190 
    tmp_1 = is_zero_ether_addr(addr);
    
#line 190 
    if (tmp_1) 
#line 190 
               tmp_2 = 0; else 
#line 190 
                               tmp_2 = 1;
    
#line 190 
    if (tmp_2) 
#line 190 
               tmp_3 = 1; else 
#line 190 
                               tmp_3 = 0;
  }
  else 
#line 190 
       tmp_3 = 0;
  
#line 190 
  __retres = (_Bool)(tmp_3 != 0);
  
#line 190 
  return __retres;
}


#line 145  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
__inline static u8 num_of_ant(u8 mask)
{
  u8 __retres;
  
#line 148 
  __retres = (unsigned char)(((((unsigned long)mask & 1UL) != 0UL) + (((unsigned long)mask & 2UL) != 0UL)) + (((unsigned long)mask & 4UL) != 0UL));
  
#line 148 
  return __retres;
}


#line 77  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.h"
struct iwl_nvm_data *iwl_parse_nvm_data(struct device *dev, struct iwl_cfg const *cfg, __le16 const *nvm_hw, __le16 const *nvm_sw, __le16 const *nvm_calib, __le16 const *regulatory, __le16 const *mac_override, __le16 const *phy_sku, u8 tx_chains, u8 rx_chains, bool lar_fw_supported, u32 mac_addr0, u32 mac_addr1);


#line 94 
struct ieee80211_regdomain *iwl_parse_nvm_mcc_info(struct device *dev, struct iwl_cfg const *cfg, int num_of_ch, __le32 *channels, u16 fw_mcc);


#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static u8 const iwl_nvm_channels[39U] = {(unsigned char)1U, (unsigned char)2U, (unsigned char)3U, (unsigned char)4U, (unsigned char)5U, (unsigned char)6U, (unsigned char)7U, (unsigned char)8U, (unsigned char)9U, (unsigned char)10U, (unsigned char)11U, (unsigned char)12U, (unsigned char)13U, (unsigned char)14U, (unsigned char)36U, (unsigned char)40U, (unsigned char)44U, (unsigned char)48U, (unsigned char)52U, (unsigned char)56U, (unsigned char)60U, (unsigned char)64U, (unsigned char)100U, (unsigned char)104U, (unsigned char)108U, (unsigned char)112U, (unsigned char)116U, (unsigned char)120U, (unsigned char)124U, (unsigned char)128U, (unsigned char)132U, (unsigned char)136U, (unsigned char)140U, (unsigned char)144U, (unsigned char)149U, (unsigned char)153U, (unsigned char)157U, (unsigned char)161U, (unsigned char)165U};

#line 138  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static u8 const iwl_nvm_channels_family_8000[51U] = {(unsigned char)1U, (unsigned char)2U, (unsigned char)3U, (unsigned char)4U, (unsigned char)5U, (unsigned char)6U, (unsigned char)7U, (unsigned char)8U, (unsigned char)9U, (unsigned char)10U, (unsigned char)11U, (unsigned char)12U, (unsigned char)13U, (unsigned char)14U, (unsigned char)36U, (unsigned char)40U, (unsigned char)44U, (unsigned char)48U, (unsigned char)52U, (unsigned char)56U, (unsigned char)60U, (unsigned char)64U, (unsigned char)68U, (unsigned char)72U, (unsigned char)76U, (unsigned char)80U, (unsigned char)84U, (unsigned char)88U, (unsigned char)92U, (unsigned char)96U, (unsigned char)100U, (unsigned char)104U, (unsigned char)108U, (unsigned char)112U, (unsigned char)116U, (unsigned char)120U, (unsigned char)124U, (unsigned char)128U, (unsigned char)132U, (unsigned char)136U, (unsigned char)140U, (unsigned char)144U, (unsigned char)149U, (unsigned char)153U, (unsigned char)157U, (unsigned char)161U, (unsigned char)165U, (unsigned char)169U, (unsigned char)173U, (unsigned char)177U, (unsigned char)181U};

#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static struct ieee80211_rate iwl_cfg80211_rates_0[12U] = {{.flags = 0U, .bitrate = (unsigned short)10U, .hw_value = (unsigned short)0U, .hw_value_short = (unsigned short)0U}, {.flags = 1U, .bitrate = (unsigned short)20U, .hw_value = (unsigned short)1U, .hw_value_short = (unsigned short)1U}, {.flags = 1U, .bitrate = (unsigned short)55U, .hw_value = (unsigned short)2U, .hw_value_short = (unsigned short)2U}, {.flags = 1U, .bitrate = (unsigned short)110U, .hw_value = (unsigned short)3U, .hw_value_short = (unsigned short)3U}, {.flags = 0U, .bitrate = (unsigned short)60U, .hw_value = (unsigned short)4U, .hw_value_short = (unsigned short)4U}, {.flags = 0U, .bitrate = (unsigned short)90U, .hw_value = (unsigned short)5U, .hw_value_short = (unsigned short)5U}, {.flags = 0U, .bitrate = (unsigned short)120U, .hw_value = (unsigned short)6U, .hw_value_short = (unsigned short)6U}, {.flags = 0U, .bitrate = (unsigned short)180U, .hw_value = (unsigned short)7U, .hw_value_short = (unsigned short)7U}, {.flags = 0U, .bitrate = (unsigned short)240U, .hw_value = (unsigned short)8U, .hw_value_short = (unsigned short)8U}, {.flags = 0U, .bitrate = (unsigned short)360U, .hw_value = (unsigned short)9U, .hw_value_short = (unsigned short)9U}, {.flags = 0U, .bitrate = (unsigned short)480U, .hw_value = (unsigned short)10U, .hw_value_short = (unsigned short)10U}, {.flags = 0U, .bitrate = (unsigned short)540U, .hw_value = (unsigned short)11U, .hw_value_short = (unsigned short)11U}};

#line 210  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static u32 iwl_get_channel_flags(u8 ch_num, int ch_idx, bool is_5ghz, u16 nvm_flags, struct iwl_cfg const *cfg)
{
  
#line 213 
  u32 flags = 48U;
  
#line 214 
  u32 last_5ghz_ht = 165U;
  
#line 216 
  if (cfg->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) 
#line 217 
                                                                  last_5ghz_ht = 181U; else ;
  
#line 219 
  if (! is_5ghz && ((int)nvm_flags & 512) != 0) {
    
#line 220 
    if ((unsigned int)ch_num <= 9U) 
#line 221 
                                    flags &= 4294967279U; else ;
    
#line 222 
    if ((unsigned int)ch_num > 4U) 
#line 223 
                                   flags &= 4294967263U; else ;
  }
  else 
    
#line 224 
    if ((unsigned int)ch_num <= last_5ghz_ht && ((int)nvm_flags & 512) != 0) 
      
#line 225 
      if (((unsigned int)ch_idx & 1U) == 0U) 
#line 226 
                                             flags &= 4294967279U; else 
                                                                    
#line 228 
                                                                    flags &= 4294967263U;
    else ;
  
#line 230 
  if (((int)nvm_flags & 1024) == 0) 
#line 231 
                                    flags |= 128U; else ;
  
#line 232 
  if (((int)nvm_flags & 2048) == 0) 
#line 233 
                                    flags |= 256U; else ;
  
#line 235 
  if (((int)nvm_flags & 2) == 0) 
#line 236 
                                 flags |= 2U; else ;
  
#line 238 
  if (((int)nvm_flags & 8) == 0) 
#line 239 
                                 flags |= 2U; else ;
  
#line 241 
  if (((int)nvm_flags & 16) != 0) 
#line 242 
                                  flags |= 8U; else ;
  
#line 244 
  if (((int)nvm_flags & 32) != 0) 
#line 245 
                                  flags |= 512U; else ;
  
#line 250 
  if (((int)nvm_flags & 64) != 0 && (flags & 2U) != 0U) 
#line 252 
                                                        flags |= 1024U; else ;
  
#line 254 
  return flags;
}


#line 293 
void __compiletime_assert_298(void);


#line 329 
void __compiletime_assert_344(void);


#line 257  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static int iwl_init_channel_map_0(struct device *dev, struct iwl_cfg const *cfg, struct iwl_nvm_data *data, __le16 const * const nvm_ch_flags, bool lar_supported)
{
  int ch_idx;
  struct ieee80211_channel *channel;
  u16 ch_flags;
  bool is_5ghz;
  int num_of_ch;
  int num_2ghz_channels;
  u8 const *nvm_chan;
  int tmp_0;
  char *tmp_1;
  char *tmp_2;
  char *tmp_3;
  char *tmp_4;
  char *tmp_5;
  char *tmp_6;
  char *tmp_7;
  char *tmp_8;
  char *tmp_9;
  
#line 263 
  int n_channels = 0;
  
#line 270 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    
#line 271 
    num_of_ch = 39;
    
#line 272 
    nvm_chan = &(iwl_nvm_channels[0]);
    
#line 273 
    num_2ghz_channels = 14;
  }
  else {
    
#line 275 
    num_of_ch = 51;
    
#line 276 
    nvm_chan = &(iwl_nvm_channels_family_8000[0]);
    
#line 277 
    num_2ghz_channels = 14;
  }
  
#line 280 
  ch_idx = 0;
  
#line 280 
  goto ldv_52161;
  ldv_52160: 
#line 281 
  ;
  
#line 281 
  ch_flags = __le16_to_cpup(nvm_ch_flags + ch_idx);
  
#line 283 
  if (ch_idx >= num_2ghz_channels && ! data->sku_cap_band_52GHz_enable) 
    
#line 285 
    goto ldv_52150; else ;
  
#line 287 
  if (! lar_supported && ((int)ch_flags & 1) == 0) {
    char *tmp;
    {
      
#line 293 
      bool __cond = (_Bool)((int)*("Ch. %d Flags %x [%sGHz] - No traffic\n" + 36UL) != 10);
      
#line 293 
      if ((int)__cond != 0) 
#line 293 
                            __compiletime_assert_298(); else ;
    }
    
#line 293 
    if (ch_idx >= num_2ghz_channels) 
#line 293 
                                     tmp = (char *)"5.2"; else 
#line 293 
                                                               tmp = (char *)"2.4";
    
#line 293 
    ;
    
#line 293 
    ;
    
#line 293 
    ;
    
#line 293 
    __iwl_dbg(dev,64U,(_Bool)0,"iwl_init_channel_map","Ch. %d Flags %x [%sGHz] - No traffic\n",(int)*(nvm_chan + ch_idx),(int)ch_flags,tmp);
    
#line 299 
    goto ldv_52150;
  }
  else ;
  
#line 302 
  channel = & data->channels[n_channels];
  
#line 303 
  n_channels += 1;
  
#line 305 
  channel->hw_value = (unsigned short)*(nvm_chan + ch_idx);
  
#line 306 
  channel->band = (enum ieee80211_band)(ch_idx >= num_2ghz_channels);
  
#line 308 
  tmp_0 = ieee80211_channel_to_frequency((int)channel->hw_value,channel->band);
  
#line 308 
  channel->center_freq = (unsigned short)tmp_0;
  
#line 318 
  channel->max_power = 22;
  
#line 319 
  is_5ghz = (_Bool)(channel->band == (unsigned int)IEEE80211_BAND_5GHZ);
  
#line 322 
  if (! lar_supported) 
#line 323 
                       channel->flags = iwl_get_channel_flags((unsigned char)((int)*(nvm_chan + ch_idx)),ch_idx,(_Bool)((bool)((int)is_5ghz) != 0),(unsigned short)((int)ch_flags),cfg); else 
                                                                    
#line 327 
                                                                    channel->flags = 0U;
  {
    
#line 329 
    bool __cond_0 = (_Bool)((int)*("Ch. %d [%sGHz] %s%s%s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n" + 63UL) != 10);
    
#line 329 
    if ((int)__cond_0 != 0) 
#line 329 
                            __compiletime_assert_344(); else ;
  }
  
#line 329 
  if (((int)ch_flags & 2) != 0 && ((int)ch_flags & 16) == 0) 
#line 329 
                                                             tmp_1 = (char *)""; else 
                                                                    
#line 329 
                                                                    tmp_1 = (char *)"not ";
  
#line 329 
  ;
  
#line 329 
  ;
  
#line 329 
  if (((int)ch_flags & 64) != 0) 
#line 329 
                                 tmp_2 = (char *)"GO_CONCURRENT"; else 
                                                                    
#line 329 
                                                                    tmp_2 = (char *)"";
  
#line 329 
  if (((int)ch_flags & 32) != 0) 
#line 329 
                                 tmp_3 = (char *)"INDOOR_ONLY"; else 
                                                                  
#line 329 
                                                                  tmp_3 = (char *)"";
  
#line 329 
  if (((int)ch_flags & 256) != 0) 
#line 329 
                                  tmp_4 = (char *)"WIDE"; else 
#line 329 
                                                               tmp_4 = (char *)"";
  
#line 329 
  if (((int)ch_flags & 16) != 0) 
#line 329 
                                 tmp_5 = (char *)"RADAR"; else 
#line 329 
                                                               tmp_5 = (char *)"";
  
#line 329 
  if (((int)ch_flags & 8) != 0) 
#line 329 
                                tmp_6 = (char *)"ACTIVE"; else 
#line 329 
                                                               tmp_6 = (char *)"";
  
#line 329 
  if (((int)ch_flags & 2) != 0) 
#line 329 
                                tmp_7 = (char *)"IBSS"; else 
#line 329 
                                                             tmp_7 = (char *)"";
  
#line 329 
  if (((int)ch_flags & 1) != 0) 
#line 329 
                                tmp_8 = (char *)"VALID"; else 
#line 329 
                                                              tmp_8 = (char *)"";
  
#line 329 
  if ((int)is_5ghz != 0) 
#line 329 
                         tmp_9 = (char *)"5.2"; else 
#line 329 
                                                     tmp_9 = (char *)"2.4";
  
#line 329 
  ;
  
#line 329 
  ;
  
#line 329 
  __iwl_dbg(dev,64U,(_Bool)0,"iwl_init_channel_map","Ch. %d [%sGHz] %s%s%s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n",(int)channel->hw_value,tmp_9,tmp_8,tmp_7,tmp_6,tmp_5,tmp_4,tmp_3,tmp_2,(int)ch_flags,channel->max_power,tmp_1);
  ldv_52150: 
#line 330 
  ;
  
#line 280 
  ch_idx += 1;
  ldv_52161: 
#line 281 
  ;
  
#line 280 
  if (ch_idx < num_of_ch) 
#line 282 
                          goto ldv_52160; else 
#line 285 
                                               goto ldv_52162;
  ldv_52162: 
#line 286 
  ;
  
#line 347 
  return n_channels;
}


#line 350  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static void iwl_init_vht_hw_capab(struct iwl_cfg const *cfg, struct iwl_nvm_data *data, struct ieee80211_sta_vht_cap *vht_cap, u8 tx_chains, u8 rx_chains)
{
  u8 tmp;
  u8 tmp_0;
  unsigned int tmp_1;
  
#line 355 
  tmp = num_of_ant((unsigned char)((int)rx_chains));
  
#line 355 
  int num_rx_ants = (int)tmp;
  
#line 356 
  tmp_0 = num_of_ant((unsigned char)((int)tx_chains));
  
#line 356 
  int num_tx_ants = (int)tmp_0;
  
#line 357 
  if (cfg->max_vht_ampdu_exponent != 0U) 
#line 357 
                                         tmp_1 = cfg->max_vht_ampdu_exponent; else 
                                                                    
#line 357 
                                                                    tmp_1 = 7U;
  
#line 357 
  unsigned int max_ampdu_exponent = tmp_1;
  
#line 360 
  vht_cap->vht_supported = (_Bool)1;
  
#line 362 
  vht_cap->cap = (max_ampdu_exponent << 23) | 28960U;
  
#line 369 
  if ((int)(cfg->ht_params)->ldpc != 0) 
#line 370 
                                        vht_cap->cap |= 16U; else ;
  
#line 372 
  if ((int)data->sku_cap_mimo_disabled != 0) {
    
#line 373 
    num_rx_ants = 1;
    
#line 374 
    num_tx_ants = 1;
  }
  else ;
  
#line 377 
  if (num_tx_ants > 1) 
#line 378 
                       vht_cap->cap |= 128U; else 
#line 380 
                                                  vht_cap->cap |= 536870912U;
  
#line 382 
  if (iwlwifi_mod_params.amsdu_size_8K != 0) 
#line 383 
                                             vht_cap->cap |= 1U; else ;
  
#line 385 
  vht_cap->vht_mcs.rx_mcs_map = (unsigned short)65530U;
  
#line 395 
  if (num_rx_ants == 1 || (int)cfg->rx_with_siso_diversity != 0) {
    
#line 396 
    vht_cap->cap |= 268435456U;
    
#line 398 
    vht_cap->vht_mcs.rx_mcs_map = (unsigned short)((unsigned int)vht_cap->vht_mcs.rx_mcs_map | 12U);
  }
  else ;
  
#line 402 
  vht_cap->vht_mcs.tx_mcs_map = vht_cap->vht_mcs.rx_mcs_map;
  
#line 403 
  return;
}


#line 446 
void __compiletime_assert_447(void);


#line 405  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static void iwl_init_sbands_0(struct device *dev, struct iwl_cfg const *cfg, struct iwl_nvm_data *data, __le16 const *ch_section, u8 tx_chains, u8 rx_chains, bool lar_supported)
{
  int n_channels;
  struct ieee80211_supported_band *sband;
  int tmp;
  int tmp_0;
  
#line 411 
  int n_used = 0;
  
#line 414 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) 
#line 415 
                                                                  n_channels = iwl_init_channel_map_0(dev,cfg,data,ch_section + 32U,(_Bool)((bool)((int)lar_supported) != 0)); else 
                                                                    
#line 419 
                                                                    n_channels = iwl_init_channel_map_0(dev,cfg,data,ch_section,(_Bool)((bool)((int)lar_supported) != 0));
  
#line 424 
  sband = & data->bands[0];
  
#line 425 
  sband->band = IEEE80211_BAND_2GHZ;
  
#line 426 
  sband->bitrates = &(iwl_cfg80211_rates_0[0]);
  
#line 427 
  sband->n_bitrates = 12;
  
#line 428 
  tmp = iwl_init_sband_channels(data,sband,n_channels,(enum ieee80211_band)IEEE80211_BAND_2GHZ);
  
#line 429 
  n_used = tmp + n_used;
  
#line 430 
  iwl_init_ht_hw_capab(cfg,data,& sband->ht_cap,(enum ieee80211_band)IEEE80211_BAND_2GHZ,(unsigned char)((int)tx_chains),(unsigned char)((int)rx_chains));
  
#line 433 
  sband = & data->bands[1];
  
#line 434 
  sband->band = IEEE80211_BAND_5GHZ;
  
#line 435 
  sband->bitrates = & iwl_cfg80211_rates_0[4];
  
#line 436 
  sband->n_bitrates = 8;
  
#line 437 
  tmp_0 = iwl_init_sband_channels(data,sband,n_channels,(enum ieee80211_band)IEEE80211_BAND_5GHZ);
  
#line 438 
  n_used = tmp_0 + n_used;
  
#line 439 
  iwl_init_ht_hw_capab(cfg,data,& sband->ht_cap,(enum ieee80211_band)IEEE80211_BAND_5GHZ,(unsigned char)((int)tx_chains),(unsigned char)((int)rx_chains));
  
#line 441 
  if ((int)data->sku_cap_11ac_enable != 0) 
#line 442 
                                           iwl_init_vht_hw_capab(cfg,data,& sband->vht_cap,(unsigned char)((int)tx_chains),(unsigned char)((int)rx_chains)); else ;
  
#line 445 
  if (n_channels != n_used) {
    {
      
#line 446 
      bool __cond = (_Bool)((int)*("NVM: used only %d of %d channels\n" + 32UL) != 10);
      
#line 446 
      if ((int)__cond != 0) 
#line 446 
                            __compiletime_assert_447(); else ;
    }
    
#line 446 
    __iwl_err(dev,(_Bool)0,(_Bool)0,"NVM: used only %d of %d channels\n",n_used,n_channels);
  }
  else ;
  
#line 448 
  return;
}


#line 450  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static int iwl_get_sku(struct iwl_cfg const *cfg, __le16 const *nvm_sw, __le16 const *phy_sku)
{
  int __retres;
  __u32 tmp_0;
  
#line 453 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    __u16 tmp;
    
#line 454 
    tmp = __le16_to_cpup(nvm_sw + 2U);
    
#line 454 
    __retres = (int)tmp;
    
#line 454 
    goto return_label;
  }
  else ;
  
#line 456 
  tmp_0 = __le32_to_cpup((__le32 const *)(phy_sku + 2U));
  
#line 456 
  __retres = (int)tmp_0;
  return_label: 
#line 456 
                return __retres;
}


#line 459  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static int iwl_get_nvm_version(struct iwl_cfg const *cfg, __le16 const *nvm_sw)
{
  int __retres;
  
#line 461 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    __u16 tmp;
    
#line 462 
    tmp = __le16_to_cpup(nvm_sw);
    
#line 462 
    __retres = (int)tmp;
    
#line 462 
    goto return_label;
  }
  else {
    __u32 tmp_0;
    
#line 464 
    tmp_0 = __le32_to_cpup((__le32 const *)nvm_sw);
    
#line 464 
    __retres = (int)tmp_0;
    
#line 464 
    goto return_label;
  }
  return_label: 
#line 461 
                return __retres;
}


#line 468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static int iwl_get_radio_cfg(struct iwl_cfg const *cfg, __le16 const *nvm_sw, __le16 const *phy_sku)
{
  int __retres;
  __u32 tmp_0;
  
#line 471 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    __u16 tmp;
    
#line 472 
    tmp = __le16_to_cpup(nvm_sw + 1U);
    
#line 472 
    __retres = (int)tmp;
    
#line 472 
    goto return_label;
  }
  else ;
  
#line 474 
  tmp_0 = __le32_to_cpup((__le32 const *)phy_sku);
  
#line 474 
  __retres = (int)tmp_0;
  return_label: 
#line 474 
                return __retres;
}


#line 478  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static int iwl_get_n_hw_addrs(struct iwl_cfg const *cfg, __le16 const *nvm_sw)
{
  int __retres;
  int n_hw_addr;
  __u32 tmp_0;
  
#line 482 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    __u16 tmp;
    
#line 483 
    tmp = __le16_to_cpup(nvm_sw + 3U);
    
#line 483 
    __retres = (int)tmp;
    
#line 483 
    goto return_label;
  }
  else ;
  
#line 485 
  tmp_0 = __le32_to_cpup((__le32 const *)(nvm_sw + 3U));
  
#line 485 
  n_hw_addr = (int)tmp_0;
  
#line 487 
  __retres = n_hw_addr & 15;
  return_label: 
#line 487 
                return __retres;
}


#line 490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static void iwl_set_radio_cfg(struct iwl_cfg const *cfg, struct iwl_nvm_data *data, u32 radio_cfg)
{
  
#line 494 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    
#line 495 
    data->radio_cfg_type = (unsigned short)((unsigned int)((unsigned short)(radio_cfg >> 4)) & 3U);
    
#line 496 
    data->radio_cfg_step = (unsigned char)((unsigned int)((unsigned char)(radio_cfg >> 2)) & 3U);
    
#line 497 
    data->radio_cfg_dash = (unsigned char)((unsigned int)((unsigned char)radio_cfg) & 3U);
    
#line 498 
    data->radio_cfg_pnum = (unsigned char)((unsigned int)((unsigned char)(radio_cfg >> 6)) & 3U);
    
#line 499 
    goto return_label;
  }
  else ;
  
#line 503 
  data->radio_cfg_type = (unsigned short)((unsigned int)((unsigned short)(radio_cfg >> 12)) & 4095U);
  
#line 504 
  data->radio_cfg_step = (unsigned char)((unsigned int)((unsigned char)(radio_cfg >> 8)) & 15U);
  
#line 505 
  data->radio_cfg_dash = (unsigned char)((unsigned int)((unsigned char)(radio_cfg >> 4)) & 15U);
  
#line 506 
  data->radio_cfg_pnum = (unsigned char)((unsigned int)((unsigned char)radio_cfg) & 15U);
  
#line 507 
  data->valid_tx_ant = (unsigned char)((unsigned int)((unsigned char)(radio_cfg >> 24)) & 15U);
  
#line 508 
  data->valid_rx_ant = (unsigned char)(radio_cfg >> 28);
  return_label: 
#line 509 
                return;
}


#line 511  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static void iwl_set_hw_address(struct iwl_cfg const *cfg, struct iwl_nvm_data *data, __le16 const *nvm_sec)
{
  
#line 515 
  u8 const *hw_addr = (u8 const *)(nvm_sec + 21U);
  
#line 518 
  data->hw_addr[0] = *(hw_addr + 1U);
  
#line 519 
  data->hw_addr[1] = *hw_addr;
  
#line 520 
  data->hw_addr[2] = *(hw_addr + 3U);
  
#line 521 
  data->hw_addr[3] = *(hw_addr + 2U);
  
#line 522 
  data->hw_addr[4] = *(hw_addr + 5U);
  
#line 523 
  data->hw_addr[5] = *(hw_addr + 4U);
  
#line 524 
  return;
}


#line 557 
void __compiletime_assert_558(void);


#line 574 
void __compiletime_assert_575(void);


#line 580 
void __compiletime_assert_580(void);


#line 526  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static void iwl_set_hw_address_family_8000(struct device *dev, struct iwl_cfg const *cfg, struct iwl_nvm_data *data, __le16 const *mac_override, __le16 const *nvm_hw, u32 mac_addr0, u32 mac_addr1)
{
  u8 const *hw_addr;
  
#line 535 
  if (mac_override != (__le16 const *)0U) {
    bool tmp;
    
#line 536 
    u8 const reserved_mac[6U] = {(unsigned char)2U, (unsigned char)204U, (unsigned char)170U, (unsigned char)255U, (unsigned char)238U, (unsigned char)0U};
    
#line 540 
    hw_addr = (u8 const *)(mac_override + 1U);
    
#line 547 
    memcpy((void *)(& data->hw_addr),(void const *)hw_addr,6UL);
    
#line 553 
    tmp = is_valid_ether_addr((u8 const *)(& data->hw_addr));
    
#line 553 
    if ((int)tmp != 0) {
      int tmp_0;
      
#line 553 
      tmp_0 = memcmp((void const *)(& reserved_mac),(void const *)hw_addr,6UL);
      
#line 553 
      if (tmp_0 != 0) 
#line 555 
                      goto return_label; else ;
    }
    else ;
    {
      
#line 557 
      bool __cond = (_Bool)((int)*("mac address from nvm override section is not valid\n" + 50UL) != 10);
      
#line 557 
      if ((int)__cond != 0) 
#line 557 
                            __compiletime_assert_558(); else ;
    }
    
#line 557 
    __iwl_err(dev,(_Bool)0,(_Bool)0,"mac address from nvm override section is not valid\n");
  }
  else ;
  
#line 561 
  if (nvm_hw != (__le16 const *)0U) {
    int tmp_2;
    bool tmp_1;
    
#line 563 
    hw_addr = (u8 const *)(& mac_addr0);
    
#line 564 
    data->hw_addr[0] = *(hw_addr + 3U);
    
#line 565 
    data->hw_addr[1] = *(hw_addr + 2U);
    
#line 566 
    data->hw_addr[2] = *(hw_addr + 1U);
    
#line 567 
    data->hw_addr[3] = *hw_addr;
    
#line 569 
    hw_addr = (u8 const *)(& mac_addr1);
    
#line 570 
    data->hw_addr[4] = *(hw_addr + 1U);
    
#line 571 
    data->hw_addr[5] = *hw_addr;
    
#line 573 
    tmp_1 = is_valid_ether_addr((u8 const *)(& data->hw_addr));
    
#line 573 
    if (tmp_1) 
#line 573 
               tmp_2 = 0; else 
#line 573 
                               tmp_2 = 1;
    
#line 573 
    if (tmp_2) {
      {
        
#line 574 
        bool __cond_0 = (_Bool)((int)*("mac address from hw section is not valid\n" + 40UL) != 10);
        
#line 574 
        if ((int)__cond_0 != 0) 
#line 574 
                                __compiletime_assert_575(); else ;
      }
      
#line 574 
      __iwl_err(dev,(_Bool)0,(_Bool)0,"mac address from hw section is not valid\n");
    }
    else ;
    
#line 577 
    goto return_label;
  }
  else ;
  {
    
#line 580 
    bool __cond_1 = (_Bool)((int)*("mac address is not found\n" + 24UL) != 10);
    
#line 580 
    if ((int)__cond_1 != 0) 
#line 580 
                            __compiletime_assert_580(); else ;
  }
  
#line 580 
  __iwl_err(dev,(_Bool)0,(_Bool)0,"mac address is not found\n");
  return_label: 
#line 581 
                return;
}


#line 633 
void __compiletime_assert_634(void);


#line 584  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
struct iwl_nvm_data *iwl_parse_nvm_data(struct device *dev, struct iwl_cfg const *cfg, __le16 const *nvm_hw, __le16 const *nvm_sw, __le16 const *nvm_calib, __le16 const *regulatory, __le16 const *mac_override, __le16 const *phy_sku, u8 tx_chains, u8 rx_chains, bool lar_fw_supported, u32 mac_addr0, u32 mac_addr1)
{
  struct iwl_nvm_data *__retres;
  struct iwl_nvm_data *data;
  u32 sku;
  u32 radio_cfg;
  u16 lar_config;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  
#line 596 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) 
#line 597 
                                                                  data = (struct iwl_nvm_data *)kzalloc_1(2760UL,208U); else 
                                                                    
#line 602 
                                                                    data = (struct iwl_nvm_data *)kzalloc_1(3528UL,208U);
  
#line 606 
  if (data == (struct iwl_nvm_data *)0) {
    
#line 607 
    __retres = (struct iwl_nvm_data *)0;
    
#line 607 
    goto return_label;
  }
  else ;
  
#line 609 
  tmp_1 = iwl_get_nvm_version(cfg,nvm_sw);
  
#line 609 
  data->nvm_version = (unsigned int)tmp_1;
  
#line 611 
  tmp_2 = iwl_get_radio_cfg(cfg,nvm_sw,phy_sku);
  
#line 611 
  radio_cfg = (unsigned int)tmp_2;
  
#line 612 
  iwl_set_radio_cfg(cfg,data,radio_cfg);
  
#line 613 
  if ((unsigned int)data->valid_tx_ant != 0U) 
#line 614 
                                              tx_chains = (unsigned char)((int)data->valid_tx_ant & (int)tx_chains); else ;
  
#line 615 
  if ((unsigned int)data->valid_rx_ant != 0U) 
#line 616 
                                              rx_chains = (unsigned char)((int)data->valid_rx_ant & (int)rx_chains); else ;
  
#line 618 
  tmp_3 = iwl_get_sku(cfg,nvm_sw,phy_sku);
  
#line 618 
  sku = (unsigned int)tmp_3;
  
#line 619 
  data->sku_cap_band_24GHz_enable = (_Bool)((sku & 1U) != 0U);
  
#line 620 
  data->sku_cap_band_52GHz_enable = (_Bool)((sku & 2U) != 0U);
  
#line 621 
  data->sku_cap_11n_enable = (_Bool)((sku & 4U) != 0U);
  
#line 622 
  if ((iwlwifi_mod_params.disable_11n & 1U) != 0U) 
#line 623 
                                                   data->sku_cap_11n_enable = (_Bool)0; else ;
  
#line 624 
  data->sku_cap_11ac_enable = (_Bool)(((int)data->sku_cap_11n_enable != 0 && (sku & 8U) != 0U) != 0);
  
#line 626 
  data->sku_cap_mimo_disabled = (_Bool)((sku & 32U) != 0U);
  
#line 628 
  data->n_hw_addrs = iwl_get_n_hw_addrs(cfg,nvm_sw);
  
#line 630 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    
#line 632 
    if (nvm_calib == (__le16 const *)0U) {
      {
        
#line 633 
        bool __cond = (_Bool)((int)*("Can\'t parse empty Calib NVM sections\n" + 36UL) != 10);
        
#line 633 
        if ((int)__cond != 0) 
#line 633 
                              __compiletime_assert_634(); else ;
      }
      
#line 633 
      __iwl_err(dev,(_Bool)0,(_Bool)0,"Can\'t parse empty Calib NVM sections\n");
      
#line 635 
      kfree((void const *)data);
      
#line 636 
      __retres = (struct iwl_nvm_data *)0;
      
#line 636 
      goto return_label;
    }
    else ;
    
#line 639 
    data->xtal_calib[0] = *(nvm_calib + 94U);
    
#line 640 
    data->xtal_calib[1] = *(nvm_calib + 95U);
  }
  else ;
  
#line 643 
  if (cfg->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    
#line 644 
    iwl_set_hw_address(cfg,data,nvm_hw);
    
#line 646 
    iwl_init_sbands_0(dev,cfg,data,nvm_sw,(unsigned char)((int)tx_chains),(unsigned char)((int)rx_chains),(_Bool)((bool)((int)lar_fw_supported) != 0));
  }
  else {
    unsigned int tmp_4;
    
#line 649 
    if (data->nvm_version <= 3640U) 
#line 649 
                                    tmp_4 = 1223U; else 
#line 649 
                                                        tmp_4 = 1287U;
    
#line 649 
    u16 lar_offset = (unsigned short)tmp_4;
    
#line 653 
    lar_config = __le16_to_cpup(regulatory + (int)lar_offset);
    
#line 654 
    data->lar_enabled = (_Bool)(((int)lar_config & 7) != 0);
    
#line 658 
    iwl_set_hw_address_family_8000(dev,cfg,data,mac_override,nvm_hw,mac_addr0,mac_addr1);
    
#line 661 
    iwl_init_sbands_0(dev,cfg,data,regulatory,(unsigned char)((int)tx_chains),(unsigned char)((int)rx_chains),(_Bool)((int)((_Bool)(((int)lar_fw_supported != 0 && (int)data->lar_enabled != 0) != 0))));
  }
  
#line 666 
  data->calib_version = (unsigned char)255U;
  
#line 668 
  __retres = data;
  return_label: 
#line 668 
                return __retres;
}


#line 670  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static char const __kstrtab_iwl_parse_nvm_data[19U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'p', (char)'a', (char)'r', (char)'s', (char)'e', (char)'_', (char)'n', (char)'v', (char)'m', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'\000'};

#line 670 
struct kernel_symbol const __ksymtab_iwl_parse_nvm_data;


#line 670  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
struct kernel_symbol const __ksymtab_iwl_parse_nvm_data = {.value = (unsigned long)(& iwl_parse_nvm_data), .name = (char const *)(& __kstrtab_iwl_parse_nvm_data)};

#line 672  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static u32 iwl_nvm_get_regdom_bw_flags(u8 const *nvm_chan, int ch_idx, u16 nvm_flags, struct iwl_cfg const *cfg)
{
  
#line 676 
  u32 flags = 24576U;
  
#line 677 
  u32 last_5ghz_ht = 165U;
  
#line 679 
  if (cfg->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) 
#line 680 
                                                                  last_5ghz_ht = 181U; else ;
  
#line 682 
  if (ch_idx <= 13 && ((int)nvm_flags & 512) != 0) {
    
#line 684 
    if ((unsigned int)*(nvm_chan + ch_idx) <= 9U) 
#line 685 
                                                  flags &= 4294950911U; else ;
    
#line 686 
    if ((unsigned int)*(nvm_chan + ch_idx) > 4U) 
#line 687 
                                                 flags &= 4294959103U; else ;
  }
  else 
    
#line 688 
    if ((unsigned int)*(nvm_chan + ch_idx) <= last_5ghz_ht && ((int)nvm_flags & 512) != 0) 
      
#line 690 
      if (((unsigned int)ch_idx & 1U) == 0U) 
#line 691 
                                             flags &= 4294950911U; else 
                                                                    
#line 693 
                                                                    flags &= 4294959103U;
    else ;
  
#line 696 
  if (((int)nvm_flags & 1024) == 0) 
#line 697 
                                    flags |= 32768U; else ;
  
#line 698 
  if (((int)nvm_flags & 2048) == 0) 
#line 699 
                                    flags |= 65536U; else ;
  
#line 701 
  if (((int)nvm_flags & 8) == 0) 
#line 702 
                                 flags |= 128U; else ;
  
#line 704 
  if (((int)nvm_flags & 16) != 0) 
#line 705 
                                  flags |= 16U; else ;
  
#line 707 
  if (((int)nvm_flags & 32) != 0) 
#line 708 
                                  flags |= 8U; else ;
  
#line 713 
  if (((int)nvm_flags & 64) != 0 && (flags & 128U) != 0U) 
#line 715 
                                                          flags |= 4096U; else ;
  
#line 717 
  return flags;
}


#line 744 
void __compiletime_assert_745(void);


#line 765 
void __compiletime_assert_770(void);


#line 804 
void __compiletime_assert_820(void);


#line 721  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
struct ieee80211_regdomain *iwl_parse_nvm_mcc_info(struct device *dev, struct iwl_cfg const *cfg, int num_of_ch, __le32 *channels, u16 fw_mcc)
{
  struct ieee80211_regdomain *__retres;
  int ch_idx;
  u16 ch_flags;
  u8 const *tmp;
  struct ieee80211_regdomain *regd;
  int size_of_regd;
  struct ieee80211_reg_rule *rule;
  enum ieee80211_band band;
  int center_freq;
  bool new_rule;
  int tmp_0;
  int tmp_3;
  int tmp_4;
  __u32 tmp_7;
  char *tmp_9;
  char *tmp_10;
  char *tmp_11;
  char *tmp_12;
  char *tmp_13;
  char *tmp_14;
  char *tmp_15;
  char *tmp_16;
  char *tmp_17;
  char *tmp_18;
  char *tmp_19;
  
#line 725 
  u16 prev_ch_flags = (unsigned short)0U;
  
#line 726 
  if (cfg->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) 
#line 726 
                                                                  tmp = (u8 const *)(& iwl_nvm_channels_family_8000); else 
                                                                    
#line 726 
                                                                    tmp = (u8 const *)(& iwl_nvm_channels);
  
#line 726 
  u8 const *nvm_chan = tmp;
  
#line 732 
  int prev_center_freq = 0;
  
#line 733 
  int valid_rules = 0;
  
#line 735 
  if (cfg->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) 
#line 735 
                                                                  tmp_0 = 51; else 
                                                                    
#line 735 
                                                                    tmp_0 = 39;
  
#line 735 
  int max_num_ch = tmp_0;
  {
    bool __warned;
    
#line 738 
    int __ret_warn_once = num_of_ch > 64;
    
#line 738 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp_2;
      {
        
#line 738 
        int __ret_warn_on = ! __warned;
        
#line 738 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 738 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c",738); else ;
        
#line 738 
        tmp_2 = (long)(__ret_warn_on != 0);
      }
      
#line 738 
      if ((long)tmp_2 != 0L) 
#line 738 
                             __warned = (_Bool)1; else ;
    }
    else ;
    
#line 738 
    tmp_3 = (long)(__ret_warn_once != 0);
  }
  
#line 738 
  if ((long)tmp_3 != 0L) {
    struct ieee80211_regdomain *tmp_1;
    
#line 739 
    tmp_1 = (struct ieee80211_regdomain *)ERR_PTR(-22L);
    
#line 739 
    __retres = tmp_1;
    
#line 739 
    goto return_label;
  }
  else ;
  {
    
#line 741 
    int __ret_warn_on_0 = num_of_ch > max_num_ch;
    
#line 741 
    if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 741 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c",741); else ;
    
#line 741 
    tmp_4 = (long)(__ret_warn_on_0 != 0);
  }
  
#line 741 
  if ((long)tmp_4 != 0L) 
#line 742 
                         num_of_ch = max_num_ch; else ;
  {
    
#line 744 
    bool __cond = (_Bool)((int)*("building regdom for %d channels\n" + 31UL) != 10);
    
#line 744 
    if ((int)__cond != 0) 
#line 744 
                          __compiletime_assert_745(); else ;
  }
  
#line 744 
  __iwl_dbg(dev,16384U,(_Bool)0,"iwl_parse_nvm_mcc_info","building regdom for %d channels\n",num_of_ch);
  
#line 748 
  size_of_regd = (int)((unsigned long)num_of_ch * (unsigned long)28U + (unsigned long)32U);
  
#line 752 
  regd = (struct ieee80211_regdomain *)kzalloc_1((unsigned long)size_of_regd,208U);
  
#line 753 
  if (regd == (struct ieee80211_regdomain *)0) {
    struct ieee80211_regdomain *tmp_6;
    
#line 754 
    tmp_6 = (struct ieee80211_regdomain *)ERR_PTR(-12L);
    
#line 754 
    __retres = tmp_6;
    
#line 754 
    goto return_label;
  }
  else ;
  
#line 756 
  ch_idx = 0;
  
#line 756 
  goto ldv_52353;
  ldv_52352: 
#line 757 
  ;
  
#line 757 
  tmp_7 = __le32_to_cpup((__le32 const *)(channels + ch_idx));
  
#line 757 
  ch_flags = (unsigned short)tmp_7;
  
#line 758 
  band = (enum ieee80211_band)(ch_idx > 13);
  
#line 760 
  center_freq = ieee80211_channel_to_frequency((int)*(nvm_chan + ch_idx),band);
  
#line 762 
  new_rule = (_Bool)0;
  
#line 764 
  if (((int)ch_flags & 1) == 0) {
    char *tmp_8;
    {
      
#line 765 
      bool __cond_0 = (_Bool)((int)*("Ch. %d Flags %x [%sGHz] - No traffic\n" + 36UL) != 10);
      
#line 765 
      if ((int)__cond_0 != 0) 
#line 765 
                              __compiletime_assert_770(); else ;
    }
    
#line 765 
    if (ch_idx > 13) 
#line 765 
                     tmp_8 = (char *)"5.2"; else 
#line 765 
                                                 tmp_8 = (char *)"2.4";
    
#line 765 
    ;
    
#line 765 
    ;
    
#line 765 
    ;
    
#line 765 
    __iwl_dbg(dev,16384U,(_Bool)0,"iwl_parse_nvm_mcc_info","Ch. %d Flags %x [%sGHz] - No traffic\n",(int)*(nvm_chan + ch_idx),(int)ch_flags,tmp_8);
    
#line 771 
    goto ldv_52347;
  }
  else ;
  
#line 775 
  if ((ch_idx == 0 || (int)prev_ch_flags != (int)ch_flags) || center_freq - prev_center_freq > 20) {
    
#line 777 
    valid_rules += 1;
    
#line 778 
    new_rule = (_Bool)1;
  }
  else ;
  
#line 781 
  rule = & regd->reg_rules[valid_rules + -1];
  
#line 783 
  if ((int)new_rule != 0) 
#line 784 
                          rule->freq_range.start_freq_khz = (unsigned int)((center_freq + -10) * 1000); else ;
  
#line 787 
  rule->freq_range.end_freq_khz = (unsigned int)((center_freq + 10) * 1000);
  
#line 790 
  rule->power_rule.max_antenna_gain = 600U;
  
#line 791 
  rule->power_rule.max_eirp = 2200U;
  
#line 794 
  rule->flags = iwl_nvm_get_regdom_bw_flags(nvm_chan,ch_idx,(unsigned short)((int)ch_flags),cfg);
  
#line 798 
  rule->flags |= 2048U;
  
#line 799 
  rule->freq_range.max_bandwidth_khz = 0U;
  
#line 801 
  prev_ch_flags = ch_flags;
  
#line 802 
  prev_center_freq = center_freq;
  {
    
#line 804 
    bool __cond_1 = (_Bool)((int)*("Ch. %d [%sGHz] %s%s%s%s%s%s%s%s%s(0x%02x): Ad-Hoc %ssupported\n" + 61UL) != 10);
    
#line 804 
    if ((int)__cond_1 != 0) 
#line 804 
                            __compiletime_assert_820(); else ;
  }
  
#line 804 
  if (((int)ch_flags & 8) != 0 && ((int)ch_flags & 16) == 0) 
#line 804 
                                                             tmp_9 = (char *)""; else 
                                                                    
#line 804 
                                                                    tmp_9 = (char *)"not ";
  
#line 804 
  ;
  
#line 804 
  if (((int)ch_flags & 64) != 0) 
#line 804 
                                 tmp_10 = (char *)"GO_CONCURRENT"; else 
                                                                    
#line 804 
                                                                    tmp_10 = (char *)"";
  
#line 804 
  if (((int)ch_flags & 32) != 0) 
#line 804 
                                 tmp_11 = (char *)"INDOOR_ONLY"; else 
                                                                   
#line 804 
                                                                   tmp_11 = (char *)"";
  
#line 804 
  if (((int)ch_flags & 2048) != 0) 
#line 804 
                                   tmp_12 = (char *)"160MHZ"; else 
#line 804 
                                                                   tmp_12 = (char *)"";
  
#line 804 
  if (((int)ch_flags & 1024) != 0) 
#line 804 
                                   tmp_13 = (char *)"80MHZ"; else 
#line 804 
                                                                  tmp_13 = (char *)"";
  
#line 804 
  if (((int)ch_flags & 512) != 0) 
#line 804 
                                  tmp_14 = (char *)"40MHZ"; else 
#line 804 
                                                                 tmp_14 = (char *)"";
  
#line 804 
  if (((int)ch_flags & 256) != 0) 
#line 804 
                                  tmp_15 = (char *)"WIDE"; else 
#line 804 
                                                                tmp_15 = (char *)"";
  
#line 804 
  if (((int)ch_flags & 16) != 0) 
#line 804 
                                 tmp_16 = (char *)"RADAR"; else 
#line 804 
                                                                tmp_16 = (char *)"";
  
#line 804 
  if (((int)ch_flags & 8) != 0) 
#line 804 
                                tmp_17 = (char *)"ACTIVE"; else 
#line 804 
                                                                tmp_17 = (char *)"";
  
#line 804 
  if (((int)ch_flags & 1) != 0) 
#line 804 
                                tmp_18 = (char *)"VALID"; else 
#line 804 
                                                               tmp_18 = (char *)"";
  
#line 804 
  if (band == (unsigned int)IEEE80211_BAND_5GHZ) 
#line 804 
                                                 tmp_19 = (char *)"5.2"; else 
                                                                    
#line 804 
                                                                    tmp_19 = (char *)"2.4";
  
#line 804 
  ;
  
#line 804 
  ;
  
#line 804 
  __iwl_dbg(dev,16384U,(_Bool)0,"iwl_parse_nvm_mcc_info","Ch. %d [%sGHz] %s%s%s%s%s%s%s%s%s(0x%02x): Ad-Hoc %ssupported\n",center_freq,tmp_19,tmp_18,tmp_17,tmp_16,tmp_15,tmp_14,tmp_13,tmp_12,tmp_11,tmp_10,(int)ch_flags,tmp_9);
  ldv_52347: 
#line 805 
  ;
  
#line 756 
  ch_idx += 1;
  ldv_52353: 
#line 757 
  ;
  
#line 756 
  if (ch_idx < num_of_ch) 
#line 758 
                          goto ldv_52352; else 
#line 761 
                                               goto ldv_52354;
  ldv_52354: 
#line 762 
  ;
  
#line 823 
  regd->n_reg_rules = (unsigned int)valid_rules;
  
#line 826 
  regd->alpha2[0] = (char)((int)fw_mcc >> 8);
  
#line 827 
  regd->alpha2[1] = (char)fw_mcc;
  
#line 829 
  __retres = regd;
  return_label: 
#line 829 
                return __retres;
}


#line 831  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
static char const __kstrtab_iwl_parse_nvm_mcc_info[23U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'p', (char)'a', (char)'r', (char)'s', (char)'e', (char)'_', (char)'n', (char)'v', (char)'m', (char)'_', (char)'m', (char)'c', (char)'c', (char)'_', (char)'i', (char)'n', (char)'f', (char)'o', (char)'\000'};

#line 831 
struct kernel_symbol const __ksymtab_iwl_parse_nvm_mcc_info;


#line 831  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c"
struct kernel_symbol const __ksymtab_iwl_parse_nvm_mcc_info = {.value = (unsigned long)(& iwl_parse_nvm_mcc_info), .name = (char const *)(& __kstrtab_iwl_parse_nvm_mcc_info)};

#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-nvm-parse.c.aux"
static void *ERR_PTR(long error)
{
  void *tmp;
  
#line 70 
  tmp = ldv_err_ptr(error);
  
#line 70 
  return tmp;
}


#line 420  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-nvm-parse.c.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 423 
  tmp = ldv_kzalloc(size,flags);
  
#line 423 
  return tmp;
}


#line 370  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_cfg const iwl5300_agn_cfg;


#line 371 
struct iwl_cfg const iwl5100_agn_cfg;


#line 372 
struct iwl_cfg const iwl5350_agn_cfg;


#line 373 
struct iwl_cfg const iwl5100_bgn_cfg;


#line 374 
struct iwl_cfg const iwl5100_abg_cfg;


#line 375 
struct iwl_cfg const iwl5150_agn_cfg;


#line 376 
struct iwl_cfg const iwl5150_abg_cfg;


#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
static struct iwl_base_params const iwl5000_base_params = {.eeprom_size = 2048, .num_of_queues = 20, .pll_cfg_val = 8913664U, .max_ll_items = (unsigned short)0, .shadow_ram_support = (_Bool)0, .led_compensation = (unsigned short)51U, .wd_timeout = 0U, .max_event_log_size = 512U, .shadow_reg_enable = (_Bool)0, .pcie_l1_allowed = (_Bool)0, .apmg_wake_up_wa = (_Bool)0, .scd_chain_ext_wa = (_Bool)1};

#line 67  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
static struct iwl_ht_params const iwl5000_ht_params = {.smps_mode = 0, .ht_greenfield_support = (_Bool)1, .stbc = (_Bool)0, .ldpc = (_Bool)0, .use_rts_for_aggregation = (_Bool)0, .ht40_bands = (unsigned char)3U};

#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
static struct iwl_eeprom_params const iwl5000_eeprom_params = {.regulatory_bands = {(unsigned char)8U, (unsigned char)38U, (unsigned char)66U, (unsigned char)92U, (unsigned char)116U, (unsigned char)130U, (unsigned char)146U}, .enhanced_txpower = (_Bool)0};

#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
struct iwl_cfg const iwl5300_agn_cfg = {.name = "Intel(R) Ultimate N WiFi Link 5300 AGN", .fw_name_pre = "iwlwifi-5000-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_5000, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)7U, .valid_rx_ant = (unsigned char)7U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)282U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl5000_base_params, .ht_params = & iwl5000_ht_params, .eeprom_params = & iwl5000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 108  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
struct iwl_cfg const iwl5100_bgn_cfg = {.name = "Intel(R) WiFi Link 5100 BGN", .fw_name_pre = "iwlwifi-5000-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_5000, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)2U, .valid_rx_ant = (unsigned char)3U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)282U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl5000_base_params, .ht_params = & iwl5000_ht_params, .eeprom_params = & iwl5000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
struct iwl_cfg const iwl5100_abg_cfg = {.name = "Intel(R) WiFi Link 5100 ABG", .fw_name_pre = "iwlwifi-5000-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_5000, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)2U, .valid_rx_ant = (unsigned char)3U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)282U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl5000_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl5000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
struct iwl_cfg const iwl5100_agn_cfg = {.name = "Intel(R) WiFi Link 5100 AGN", .fw_name_pre = "iwlwifi-5000-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_5000, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)2U, .valid_rx_ant = (unsigned char)3U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)282U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl5000_base_params, .ht_params = & iwl5000_ht_params, .eeprom_params = & iwl5000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
struct iwl_cfg const iwl5350_agn_cfg = {.name = "Intel(R) WiMAX/WiFi Link 5350 AGN", .fw_name_pre = "iwlwifi-5000-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_5000, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)542U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl5000_base_params, .ht_params = & iwl5000_ht_params, .eeprom_params = & iwl5000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)1, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 0U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
struct iwl_cfg const iwl5150_agn_cfg = {.name = "Intel(R) WiMAX/WiFi Link 5150 AGN", .fw_name_pre = "iwlwifi-5150-", .ucode_api_max = 2U, .ucode_api_ok = 2U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_5150, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)542U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl5000_base_params, .ht_params = & iwl5000_ht_params, .eeprom_params = & iwl5000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)1, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-5000.c"
struct iwl_cfg const iwl5150_abg_cfg = {.name = "Intel(R) WiMAX/WiFi Link 5150 ABG", .fw_name_pre = "iwlwifi-5150-", .ucode_api_max = 2U, .ucode_api_ok = 2U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_5150, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)542U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl5000_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl5000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)1, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_iowrite_prph32;


#line 103 
struct tracepoint __tracepoint_iwlwifi_dev_ioread_prph32;


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
static char const __tpstrtab_iwlwifi_dev_ioread32[21U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'o', (char)'r', (char)'e', (char)'a', (char)'d', (char)'3', (char)'2', (char)'\000'};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_ioread32 = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_ioread32), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
static char const __tpstrtab_iwlwifi_dev_iowrite8[21U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'o', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'8', (char)'\000'};

#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_iowrite8 = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_iowrite8), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
static char const __tpstrtab_iwlwifi_dev_iowrite32[22U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'o', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'3', (char)'2', (char)'\000'};

#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_iowrite32 = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_iowrite32), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
static char const __tpstrtab_iwlwifi_dev_iowrite_prph32[27U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'o', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'_', (char)'p', (char)'r', (char)'p', (char)'h', (char)'3', (char)'2', (char)'\000'};

#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_iowrite_prph32 = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_iowrite_prph32), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
static char const __tpstrtab_iwlwifi_dev_ioread_prph32[26U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'o', (char)'r', (char)'e', (char)'a', (char)'d', (char)'_', (char)'p', (char)'r', (char)'p', (char)'h', (char)'3', (char)'2', (char)'\000'};

#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_ioread_prph32 = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_ioread_prph32), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
static char const __tpstrtab_iwlwifi_dev_irq[16U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'r', (char)'q', (char)'\000'};

#line 120  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_irq = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_irq), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
static char const __tpstrtab_iwlwifi_dev_ict_read[21U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'c', (char)'t', (char)'_', (char)'r', (char)'e', (char)'a', (char)'d', (char)'\000'};

#line 133  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
struct tracepoint __tracepoint_iwlwifi_dev_ict_read = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_ict_read), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-ucode.h"
struct tracepoint __tracepoint_iwlwifi_dev_ucode_cont_event;


#line 55 
struct tracepoint __tracepoint_iwlwifi_dev_ucode_wrap_event;


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-ucode.h"
static char const __tpstrtab_iwlwifi_dev_ucode_cont_event[29U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'u', (char)'c', (char)'o', (char)'d', (char)'e', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'_', (char)'e', (char)'v', (char)'e', (char)'n', (char)'t', (char)'\000'};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-ucode.h"
struct tracepoint __tracepoint_iwlwifi_dev_ucode_cont_event = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_ucode_cont_event), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-ucode.h"
static char const __tpstrtab_iwlwifi_dev_ucode_wrap_event[29U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'u', (char)'c', (char)'o', (char)'d', (char)'e', (char)'_', (char)'w', (char)'r', (char)'a', (char)'p', (char)'_', (char)'e', (char)'v', (char)'e', (char)'n', (char)'t', (char)'\000'};

#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-ucode.h"
struct tracepoint __tracepoint_iwlwifi_dev_ucode_wrap_event = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_ucode_wrap_event), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
struct tracepoint __tracepoint_iwlwifi_err;


#line 56 
struct tracepoint __tracepoint_iwlwifi_warn;


#line 61 
struct tracepoint __tracepoint_iwlwifi_info;


#line 66 
struct tracepoint __tracepoint_iwlwifi_crit;


#line 71 
struct tracepoint __tracepoint_iwlwifi_dbg;


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
static char const __tpstrtab_iwlwifi_err[12U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'};

#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
struct tracepoint __tracepoint_iwlwifi_err = {.name = (char const *)(& __tpstrtab_iwlwifi_err), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
static char const __tpstrtab_iwlwifi_warn[13U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'w', (char)'a', (char)'r', (char)'n', (char)'\000'};

#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
struct tracepoint __tracepoint_iwlwifi_warn = {.name = (char const *)(& __tpstrtab_iwlwifi_warn), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
static char const __tpstrtab_iwlwifi_info[13U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'i', (char)'n', (char)'f', (char)'o', (char)'\000'};

#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
struct tracepoint __tracepoint_iwlwifi_info = {.name = (char const *)(& __tpstrtab_iwlwifi_info), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
static char const __tpstrtab_iwlwifi_crit[13U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'c', (char)'r', (char)'i', (char)'t', (char)'\000'};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
struct tracepoint __tracepoint_iwlwifi_crit = {.name = (char const *)(& __tpstrtab_iwlwifi_crit), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
static char const __tpstrtab_iwlwifi_dbg[12U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'b', (char)'g', (char)'\000'};

#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
struct tracepoint __tracepoint_iwlwifi_dbg = {.name = (char const *)(& __tpstrtab_iwlwifi_dbg), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
struct tracepoint __tracepoint_iwlwifi_dev_tx_data;


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
static char const __tpstrtab_iwlwifi_dev_tx_data[20U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'t', (char)'x', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'\000'};

#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
struct tracepoint __tracepoint_iwlwifi_dev_tx_data = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_tx_data), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
static char const __tpstrtab_iwlwifi_dev_rx_data[20U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'r', (char)'x', (char)'_', (char)'d', (char)'a', (char)'t', (char)'a', (char)'\000'};

#line 53  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
struct tracepoint __tracepoint_iwlwifi_dev_rx_data = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_rx_data), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
struct tracepoint __tracepoint_iwlwifi_dev_hcmd;


#line 85 
struct tracepoint __tracepoint_iwlwifi_dev_tx;


#line 118 
struct tracepoint __tracepoint_iwlwifi_dev_ucode_error;


#line 180 
struct tracepoint __tracepoint_iwlwifi_dev_ucode_event;


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
static char const __tpstrtab_iwlwifi_dev_hcmd[17U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'h', (char)'c', (char)'m', (char)'d', (char)'\000'};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
struct tracepoint __tracepoint_iwlwifi_dev_hcmd = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_hcmd), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
static char const __tpstrtab_iwlwifi_dev_rx[15U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'r', (char)'x', (char)'\000'};

#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
struct tracepoint __tracepoint_iwlwifi_dev_rx = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_rx), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
static char const __tpstrtab_iwlwifi_dev_tx[15U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'t', (char)'x', (char)'\000'};

#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
struct tracepoint __tracepoint_iwlwifi_dev_tx = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_tx), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
static char const __tpstrtab_iwlwifi_dev_ucode_error[24U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'u', (char)'c', (char)'o', (char)'d', (char)'e', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'\000'};

#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
struct tracepoint __tracepoint_iwlwifi_dev_ucode_error = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_ucode_error), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
static char const __tpstrtab_iwlwifi_dev_ucode_event[24U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'u', (char)'c', (char)'o', (char)'d', (char)'e', (char)'_', (char)'e', (char)'v', (char)'e', (char)'n', (char)'t', (char)'\000'};

#line 180  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
struct tracepoint __tracepoint_iwlwifi_dev_ucode_event = {.name = (char const *)(& __tpstrtab_iwlwifi_dev_ucode_event), .key = {.enabled = {.counter = 0}, .entries = (struct jump_entry *)0, .next = (struct static_key_mod *)0}, .regfunc = (void (*)(void))0, .unregfunc = (void (*)(void))0, .funcs = (struct tracepoint_func *)0};

#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
static char const __kstrtab___tracepoint_iwlwifi_dev_iowrite8[34U] = {(char)'_', (char)'_', (char)'t', (char)'r', (char)'a', (char)'c', (char)'e', (char)'p', (char)'o', (char)'i', (char)'n', (char)'t', (char)'_', (char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'o', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'8', (char)'\000'};

#line 36 
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_iowrite8;


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_iowrite8 = {.value = (unsigned long)(& __tracepoint_iwlwifi_dev_iowrite8), .name = (char const *)(& __kstrtab___tracepoint_iwlwifi_dev_iowrite8)};

#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
static char const __kstrtab___tracepoint_iwlwifi_dev_ioread32[34U] = {(char)'_', (char)'_', (char)'t', (char)'r', (char)'a', (char)'c', (char)'e', (char)'p', (char)'o', (char)'i', (char)'n', (char)'t', (char)'_', (char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'o', (char)'r', (char)'e', (char)'a', (char)'d', (char)'3', (char)'2', (char)'\000'};

#line 37 
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ioread32;


#line 37  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ioread32 = {.value = (unsigned long)(& __tracepoint_iwlwifi_dev_ioread32), .name = (char const *)(& __kstrtab___tracepoint_iwlwifi_dev_ioread32)};

#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
static char const __kstrtab___tracepoint_iwlwifi_dev_iowrite32[35U] = {(char)'_', (char)'_', (char)'t', (char)'r', (char)'a', (char)'c', (char)'e', (char)'p', (char)'o', (char)'i', (char)'n', (char)'t', (char)'_', (char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'i', (char)'o', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'3', (char)'2', (char)'\000'};

#line 38 
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_iowrite32;


#line 38  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_iowrite32 = {.value = (unsigned long)(& __tracepoint_iwlwifi_dev_iowrite32), .name = (char const *)(& __kstrtab___tracepoint_iwlwifi_dev_iowrite32)};

#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
static char const __kstrtab___tracepoint_iwlwifi_dev_ucode_event[37U] = {(char)'_', (char)'_', (char)'t', (char)'r', (char)'a', (char)'c', (char)'e', (char)'p', (char)'o', (char)'i', (char)'n', (char)'t', (char)'_', (char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'u', (char)'c', (char)'o', (char)'d', (char)'e', (char)'_', (char)'e', (char)'v', (char)'e', (char)'n', (char)'t', (char)'\000'};

#line 39 
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ucode_event;


#line 39  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ucode_event = {.value = (unsigned long)(& __tracepoint_iwlwifi_dev_ucode_event), .name = (char const *)(& __kstrtab___tracepoint_iwlwifi_dev_ucode_event)};

#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
static char const __kstrtab___tracepoint_iwlwifi_dev_ucode_error[37U] = {(char)'_', (char)'_', (char)'t', (char)'r', (char)'a', (char)'c', (char)'e', (char)'p', (char)'o', (char)'i', (char)'n', (char)'t', (char)'_', (char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'u', (char)'c', (char)'o', (char)'d', (char)'e', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'\000'};

#line 40 
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ucode_error;


#line 40  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ucode_error = {.value = (unsigned long)(& __tracepoint_iwlwifi_dev_ucode_error), .name = (char const *)(& __kstrtab___tracepoint_iwlwifi_dev_ucode_error)};

#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
static char const __kstrtab___tracepoint_iwlwifi_dev_ucode_cont_event[42U] = {(char)'_', (char)'_', (char)'t', (char)'r', (char)'a', (char)'c', (char)'e', (char)'p', (char)'o', (char)'i', (char)'n', (char)'t', (char)'_', (char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'u', (char)'c', (char)'o', (char)'d', (char)'e', (char)'_', (char)'c', (char)'o', (char)'n', (char)'t', (char)'_', (char)'e', (char)'v', (char)'e', (char)'n', (char)'t', (char)'\000'};

#line 41 
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ucode_cont_event;


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ucode_cont_event = {.value = (unsigned long)(& __tracepoint_iwlwifi_dev_ucode_cont_event), .name = (char const *)(& __kstrtab___tracepoint_iwlwifi_dev_ucode_cont_event)};

#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
static char const __kstrtab___tracepoint_iwlwifi_dev_ucode_wrap_event[42U] = {(char)'_', (char)'_', (char)'t', (char)'r', (char)'a', (char)'c', (char)'e', (char)'p', (char)'o', (char)'i', (char)'n', (char)'t', (char)'_', (char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'d', (char)'e', (char)'v', (char)'_', (char)'u', (char)'c', (char)'o', (char)'d', (char)'e', (char)'_', (char)'w', (char)'r', (char)'a', (char)'p', (char)'_', (char)'e', (char)'v', (char)'e', (char)'n', (char)'t', (char)'\000'};

#line 42 
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ucode_wrap_event;


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace.c"
struct kernel_symbol const __ksymtab___tracepoint_iwlwifi_dev_ucode_wrap_event = {.value = (unsigned long)(& __tracepoint_iwlwifi_dev_ucode_wrap_event), .name = (char const *)(& __kstrtab___tracepoint_iwlwifi_dev_ucode_wrap_event)};

#line 33  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/export.h"
extern struct module __this_module;


#line 142  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
int printk(char const * , ...);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static long PTR_ERR(void const *ptr);


#line 41 
static bool IS_ERR(void const *ptr);


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
static bool static_key_false_0(struct static_key *key)
{
  bool tmp;
  
#line 125 
  tmp = arch_static_branch(key);
  
#line 125 
  return tmp;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err(void const *ptr);


#line 30 
long ldv_ptr_err(void const *ptr);


#line 864  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 866 
  __retres = dev->driver_data;
  
#line 866 
  return __retres;
}


#line 869  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  
#line 871 
  dev->driver_data = data;
  
#line 872 
  return;
}


#line 865  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_bus_write_config_byte(struct pci_bus *, unsigned int, int, u8);


#line 896  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev const *dev, int where, u8 val)
{
  int tmp;
  
#line 898 
  tmp = pci_bus_write_config_byte(dev->bus,dev->devfn,where,(unsigned char)((int)val));
  
#line 898 
  return tmp;
}


#line 1146 
static int ldv___pci_register_driver_73(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3);


#line 1158 
static void ldv_pci_unregister_driver_74(struct pci_driver *ldv_func_arg1);


#line 1471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  void *tmp;
  
#line 1473 
  tmp = dev_get_drvdata((struct device const *)(& pdev->dev));
  
#line 1473 
  return tmp;
}


#line 1476  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  
#line 1478 
  dev_set_drvdata(& pdev->dev,data);
  
#line 1479 
  return;
}


#line 491  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpixf.h"
acpi_status acpi_get_handle(acpi_handle, acpi_string, acpi_handle **);


#line 513 
acpi_status acpi_evaluate_object(acpi_handle, acpi_string, struct acpi_object_list *, struct acpi_buffer *);


#line 490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/quota.h"
void __compiletime_assert_490(void);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
__inline static bool is_acpi_node(struct fwnode_handle *fwnode)
{
  bool __retres;
  
#line 420 
  __retres = (_Bool)((fwnode != (struct fwnode_handle *)0 && fwnode->type == (unsigned int)FWNODE_ACPI) != 0);
  
#line 420 
  return __retres;
}


#line 423  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/acpi/acpi_bus.h"
__inline static struct acpi_device *to_acpi_node(struct fwnode_handle *fwnode)
{
  struct acpi_device *tmp_1;
  bool tmp;
  
#line 426 
  tmp = is_acpi_node(fwnode);
  
#line 426 
  if ((int)tmp != 0) {
    struct acpi_device *tmp_0;
    {
      
#line 426 
      struct fwnode_handle const *__mptr = (struct fwnode_handle const *)fwnode;
      
#line 426 
      tmp_0 = (struct acpi_device *)__mptr + 18446744073709551600U;
    }
    
#line 426 
    tmp_1 = tmp_0;
  }
  else 
#line 426 
       tmp_1 = (struct acpi_device *)0;
  
#line 426 
  return tmp_1;
}


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/acpi.h"
__inline static acpi_handle acpi_device_handle(struct acpi_device *adev)
{
  void *tmp;
  
#line 53 
  if (adev != (struct acpi_device *)0) 
#line 53 
                                       tmp = adev->handle; else 
#line 53 
                                                                tmp = (void *)0;
  
#line 53 
  return tmp;
}


#line 377  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-config.h"
struct iwl_cfg const iwl6005_2agn_cfg;


#line 378 
struct iwl_cfg const iwl6005_2abg_cfg;


#line 379 
struct iwl_cfg const iwl6005_2bg_cfg;


#line 380 
struct iwl_cfg const iwl6005_2agn_sff_cfg;


#line 381 
struct iwl_cfg const iwl6005_2agn_d_cfg;


#line 382 
struct iwl_cfg const iwl6005_2agn_mow1_cfg;


#line 383 
struct iwl_cfg const iwl6005_2agn_mow2_cfg;


#line 384 
struct iwl_cfg const iwl1030_bgn_cfg;


#line 385 
struct iwl_cfg const iwl1030_bg_cfg;


#line 386 
struct iwl_cfg const iwl6030_2agn_cfg;


#line 387 
struct iwl_cfg const iwl6030_2abg_cfg;


#line 388 
struct iwl_cfg const iwl6030_2bgn_cfg;


#line 389 
struct iwl_cfg const iwl6030_2bg_cfg;


#line 390 
struct iwl_cfg const iwl6000i_2agn_cfg;


#line 391 
struct iwl_cfg const iwl6000i_2abg_cfg;


#line 392 
struct iwl_cfg const iwl6000i_2bg_cfg;


#line 393 
struct iwl_cfg const iwl6000_3agn_cfg;


#line 394 
struct iwl_cfg const iwl6050_2agn_cfg;


#line 395 
struct iwl_cfg const iwl6050_2abg_cfg;


#line 396 
struct iwl_cfg const iwl6150_bgn_cfg;


#line 397 
struct iwl_cfg const iwl6150_bg_cfg;


#line 398 
struct iwl_cfg const iwl1000_bgn_cfg;


#line 399 
struct iwl_cfg const iwl1000_bg_cfg;


#line 400 
struct iwl_cfg const iwl100_bgn_cfg;


#line 401 
struct iwl_cfg const iwl100_bg_cfg;


#line 402 
struct iwl_cfg const iwl130_bgn_cfg;


#line 403 
struct iwl_cfg const iwl130_bg_cfg;


#line 404 
struct iwl_cfg const iwl2000_2bgn_cfg;


#line 405 
struct iwl_cfg const iwl2000_2bgn_d_cfg;


#line 406 
struct iwl_cfg const iwl2030_2bgn_cfg;


#line 407 
struct iwl_cfg const iwl6035_2agn_cfg;


#line 408 
struct iwl_cfg const iwl6035_2agn_sff_cfg;


#line 409 
struct iwl_cfg const iwl105_bgn_cfg;


#line 410 
struct iwl_cfg const iwl105_bgn_d_cfg;


#line 411 
struct iwl_cfg const iwl135_bgn_cfg;


#line 915  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static int iwl_trans_dbgfs_register(struct iwl_trans *trans, struct dentry *dir)
{
  int tmp;
  
#line 918 
  tmp = (*((trans->ops)->dbgfs_register))(trans,dir);
  
#line 918 
  return tmp;
}


#line 1028 
int iwl_pci_register_driver(void);


#line 1029 
void iwl_pci_unregister_driver(void);


#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.h"
struct iwl_drv *iwl_drv_start(struct iwl_trans *trans, struct iwl_cfg const *cfg);


#line 140 
void iwl_drv_stop(struct iwl_drv *drv);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32_0(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 35 
  tmp_4 = static_key_false_0(& __tracepoint_iwlwifi_dev_ioread32.key);
  
#line 35 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 35 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_3633 __u;
          
#line 35 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u.__c),8);
          
#line 35 
          tmp = __u.__val;
        }
        
#line 35 
        struct tracepoint_func *_________p1 = tmp;
        
#line 35 
        tmp_0 = _________p1;
      }
      
#line 35 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 35 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 35 
        if (tmp_1 != 0) {
          
#line 35 
          if (! __warned) {
            int tmp_2;
            
#line 35 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 35 
            if (tmp_2 == 0) {
              
#line 35 
              __warned = (_Bool)1;
              
#line 35 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 35 
      tmp_3 = ________p1;
    }
    
#line 35 
    it_func_ptr = tmp_3;
    
#line 35 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_56611: 
#line 37 
      ;
      
#line 35 
      it_func = it_func_ptr->func;
      
#line 35 
      __data = it_func_ptr->data;
      
#line 35 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 35 
      it_func_ptr += 1;
      
#line 35 
      ;
      
#line 35 
      if (it_func_ptr->func != (void *)0) 
#line 37 
                                          goto ldv_56611; else 
#line 40 
                                                               goto ldv_56612;
      ldv_56612: 
#line 41 
      ;
    }
    else ;
    
#line 35 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 35 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_3635 __u_0;
        
#line 35 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u_0.__c),8);
        
#line 35 
        tmp_5 = __u_0.__val;
      }
      
#line 35 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 35 
      tmp_6 = _________p1_0;
    }
    
#line 35 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 35 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 35 
      if (tmp_7 != 0) {
        
#line 35 
        if (! __warned_0) {
          int tmp_8;
          
#line 35 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 35 
          if (tmp_8 == 0) {
            
#line 35 
            __warned_0 = (_Bool)1;
            
#line 35 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 35 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 35 
  rcu_read_unlock_sched_notrace();
  
#line 37 
  return;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32_0(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 69 
  tmp_4 = static_key_false_0(& __tracepoint_iwlwifi_dev_iowrite32.key);
  
#line 69 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 69 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_3641 __u;
          
#line 69 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u.__c),8);
          
#line 69 
          tmp = __u.__val;
        }
        
#line 69 
        struct tracepoint_func *_________p1 = tmp;
        
#line 69 
        tmp_0 = _________p1;
      }
      
#line 69 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 69 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 69 
        if (tmp_1 != 0) {
          
#line 69 
          if (! __warned) {
            int tmp_2;
            
#line 69 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 69 
            if (tmp_2 == 0) {
              
#line 69 
              __warned = (_Bool)1;
              
#line 69 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 69 
      tmp_3 = ________p1;
    }
    
#line 69 
    it_func_ptr = tmp_3;
    
#line 69 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_56733: 
#line 71 
      ;
      
#line 69 
      it_func = it_func_ptr->func;
      
#line 69 
      __data = it_func_ptr->data;
      
#line 69 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 69 
      it_func_ptr += 1;
      
#line 69 
      ;
      
#line 69 
      if (it_func_ptr->func != (void *)0) 
#line 71 
                                          goto ldv_56733; else 
#line 74 
                                                               goto ldv_56734;
      ldv_56734: 
#line 75 
      ;
    }
    else ;
    
#line 69 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 69 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_3643 __u_0;
        
#line 69 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u_0.__c),8);
        
#line 69 
        tmp_5 = __u_0.__val;
      }
      
#line 69 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 69 
      tmp_6 = _________p1_0;
    }
    
#line 69 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 69 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 69 
      if (tmp_7 != 0) {
        
#line 69 
        if (! __warned_0) {
          int tmp_8;
          
#line 69 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 69 
          if (tmp_8 == 0) {
            
#line 69 
            __warned_0 = (_Bool)1;
            
#line 69 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 69 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 69 
  rcu_read_unlock_sched_notrace();
  
#line 71 
  return;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_write32_0(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 43 
  trace_iwlwifi_dev_iowrite32_0((struct device const *)trans->dev,ofs,val);
  
#line 44 
  iwl_trans_write32(trans,ofs,val);
  
#line 45 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static u32 iwl_read32_0(struct iwl_trans *trans, u32 ofs)
{
  
#line 49 
  u32 val = iwl_trans_read32(trans,ofs);
  
#line 50 
  trace_iwlwifi_dev_ioread32_0((struct device const *)trans->dev,ofs,val);
  
#line 51 
  return val;
}


#line 349  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev, struct pci_device_id const *ent, struct iwl_cfg const *cfg);


#line 352 
void iwl_trans_pcie_free(struct iwl_trans *trans);


#line 425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_enable_interrupts_0(struct iwl_trans *trans)
{
  
#line 427 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    
#line 429 
    bool __cond = (_Bool)((int)*("Enabling interrupts\n" + 19UL) != 10);
    
#line 429 
    if ((int)__cond != 0) 
#line 429 
                          __compiletime_assert_429(); else ;
  }
  
#line 429 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_enable_interrupts","Enabling interrupts\n");
  
#line 430 
  set_bit(3L,(unsigned long volatile *)(& trans->status));
  
#line 431 
  trans_pcie->inta_mask = 3120562315U;
  
#line 432 
  iwl_write32_0(trans,12U,trans_pcie->inta_mask);
  
#line 433 
  return;
}


#line 435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_enable_rfkill_int_0(struct iwl_trans *trans)
{
  
#line 437 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    
#line 439 
    bool __cond = (_Bool)((int)*("Enabling rfkill interrupt\n" + 25UL) != 10);
    
#line 439 
    if ((int)__cond != 0) 
#line 439 
                          __compiletime_assert_439(); else ;
  }
  
#line 439 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_enable_rfkill_int","Enabling rfkill interrupt\n");
  
#line 440 
  trans_pcie->inta_mask = 128U;
  
#line 441 
  iwl_write32_0(trans,12U,trans_pcie->inta_mask);
  
#line 442 
  return;
}


#line 488  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static bool iwl_is_rfkill_set_0(struct iwl_trans *trans)
{
  bool __retres;
  u32 tmp;
  
#line 490 
  tmp = iwl_read32_0(trans,36U);
  
#line 490 
  __retres = (_Bool)((tmp & 134217728U) == 0U);
  
#line 490 
  return __retres;
}


#line 83  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static struct pci_device_id const iwl_hw_card_ids[324U] = {{.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4609U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4865U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4612U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4868U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4613U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_bgn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4869U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_bgn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4614U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_abg_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4870U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_abg_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4641U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4897U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4644U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4900U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4645U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_bgn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4901U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_bgn_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4646U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_abg_cfg)}, {.vendor = 32902U, .device = 16946U, .subvendor = 4294967295U, .subdevice = 4902U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_abg_cfg)}, {.vendor = 32902U, .device = 16951U, .subvendor = 4294967295U, .subdevice = 4625U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16951U, .subvendor = 4294967295U, .subdevice = 4881U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16951U, .subvendor = 4294967295U, .subdevice = 4628U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16951U, .subvendor = 4294967295U, .subdevice = 4884U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_agn_cfg)}, {.vendor = 32902U, .device = 16951U, .subvendor = 4294967295U, .subdevice = 4629U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_bgn_cfg)}, {.vendor = 32902U, .device = 16951U, .subvendor = 4294967295U, .subdevice = 4885U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_bgn_cfg)}, {.vendor = 32902U, .device = 16951U, .subvendor = 4294967295U, .subdevice = 4630U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_abg_cfg)}, {.vendor = 32902U, .device = 16951U, .subvendor = 4294967295U, .subdevice = 4886U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5100_abg_cfg)}, {.vendor = 32902U, .device = 16949U, .subvendor = 4294967295U, .subdevice = 4129U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16949U, .subvendor = 4294967295U, .subdevice = 4385U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16949U, .subvendor = 4294967295U, .subdevice = 4132U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16949U, .subvendor = 4294967295U, .subdevice = 4388U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16949U, .subvendor = 4294967295U, .subdevice = 4097U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16949U, .subvendor = 4294967295U, .subdevice = 4353U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16949U, .subvendor = 4294967295U, .subdevice = 4100U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16949U, .subvendor = 4294967295U, .subdevice = 4356U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16950U, .subvendor = 4294967295U, .subdevice = 4113U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16950U, .subvendor = 4294967295U, .subdevice = 4369U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16950U, .subvendor = 4294967295U, .subdevice = 4116U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16950U, .subvendor = 4294967295U, .subdevice = 4372U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5300_agn_cfg)}, {.vendor = 32902U, .device = 16954U, .subvendor = 4294967295U, .subdevice = 4097U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5350_agn_cfg)}, {.vendor = 32902U, .device = 16954U, .subvendor = 4294967295U, .subdevice = 4129U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5350_agn_cfg)}, {.vendor = 32902U, .device = 16955U, .subvendor = 4294967295U, .subdevice = 4113U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5350_agn_cfg)}, {.vendor = 32902U, .device = 16956U, .subvendor = 4294967295U, .subdevice = 4609U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_agn_cfg)}, {.vendor = 32902U, .device = 16956U, .subvendor = 4294967295U, .subdevice = 4865U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_agn_cfg)}, {.vendor = 32902U, .device = 16956U, .subvendor = 4294967295U, .subdevice = 4614U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_abg_cfg)}, {.vendor = 32902U, .device = 16956U, .subvendor = 4294967295U, .subdevice = 4870U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_abg_cfg)}, {.vendor = 32902U, .device = 16956U, .subvendor = 4294967295U, .subdevice = 4641U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_agn_cfg)}, {.vendor = 32902U, .device = 16956U, .subvendor = 4294967295U, .subdevice = 4897U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_agn_cfg)}, {.vendor = 32902U, .device = 16956U, .subvendor = 4294967295U, .subdevice = 4902U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_abg_cfg)}, {.vendor = 32902U, .device = 16957U, .subvendor = 4294967295U, .subdevice = 4625U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_agn_cfg)}, {.vendor = 32902U, .device = 16957U, .subvendor = 4294967295U, .subdevice = 4881U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_agn_cfg)}, {.vendor = 32902U, .device = 16957U, .subvendor = 4294967295U, .subdevice = 4630U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_abg_cfg)}, {.vendor = 32902U, .device = 16957U, .subvendor = 4294967295U, .subdevice = 4886U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl5150_abg_cfg)}, {.vendor = 32902U, .device = 16939U, .subvendor = 4294967295U, .subdevice = 4353U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000_3agn_cfg)}, {.vendor = 32902U, .device = 16939U, .subvendor = 4294967295U, .subdevice = 4360U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000_3agn_cfg)}, {.vendor = 32902U, .device = 16939U, .subvendor = 4294967295U, .subdevice = 4385U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000_3agn_cfg)}, {.vendor = 32902U, .device = 16939U, .subvendor = 4294967295U, .subdevice = 4392U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000_3agn_cfg)}, {.vendor = 32902U, .device = 16940U, .subvendor = 4294967295U, .subdevice = 4865U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000i_2agn_cfg)}, {.vendor = 32902U, .device = 16940U, .subvendor = 4294967295U, .subdevice = 4870U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000i_2abg_cfg)}, {.vendor = 32902U, .device = 16940U, .subvendor = 4294967295U, .subdevice = 4871U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000i_2bg_cfg)}, {.vendor = 32902U, .device = 16940U, .subvendor = 4294967295U, .subdevice = 4897U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000i_2agn_cfg)}, {.vendor = 32902U, .device = 16940U, .subvendor = 4294967295U, .subdevice = 4902U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000i_2abg_cfg)}, {.vendor = 32902U, .device = 16952U, .subvendor = 4294967295U, .subdevice = 4369U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000_3agn_cfg)}, {.vendor = 32902U, .device = 16952U, .subvendor = 4294967295U, .subdevice = 4376U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000_3agn_cfg)}, {.vendor = 32902U, .device = 16953U, .subvendor = 4294967295U, .subdevice = 4881U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000i_2agn_cfg)}, {.vendor = 32902U, .device = 16953U, .subvendor = 4294967295U, .subdevice = 4886U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6000i_2abg_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4865U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4870U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2abg_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4871U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2bg_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4872U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4897U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4902U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2abg_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4904U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_cfg)}, {.vendor = 32902U, .device = 133U, .subvendor = 4294967295U, .subdevice = 4881U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_cfg)}, {.vendor = 32902U, .device = 133U, .subvendor = 4294967295U, .subdevice = 4888U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_cfg)}, {.vendor = 32902U, .device = 133U, .subvendor = 4294967295U, .subdevice = 4886U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2abg_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 49184U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_sff_cfg)}, {.vendor = 32902U, .device = 133U, .subvendor = 4294967295U, .subdevice = 49696U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_sff_cfg)}, {.vendor = 32902U, .device = 133U, .subvendor = 4294967295U, .subdevice = 49704U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_sff_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 18464U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_d_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4868U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_mow1_cfg)}, {.vendor = 32902U, .device = 130U, .subvendor = 4294967295U, .subdevice = 4869U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6005_2agn_mow2_cfg)}, {.vendor = 32902U, .device = 138U, .subvendor = 4294967295U, .subdevice = 21253U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1030_bgn_cfg)}, {.vendor = 32902U, .device = 138U, .subvendor = 4294967295U, .subdevice = 21255U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1030_bg_cfg)}, {.vendor = 32902U, .device = 138U, .subvendor = 4294967295U, .subdevice = 21285U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1030_bgn_cfg)}, {.vendor = 32902U, .device = 138U, .subvendor = 4294967295U, .subdevice = 21287U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1030_bg_cfg)}, {.vendor = 32902U, .device = 139U, .subvendor = 4294967295U, .subdevice = 21269U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1030_bgn_cfg)}, {.vendor = 32902U, .device = 139U, .subvendor = 4294967295U, .subdevice = 21271U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1030_bg_cfg)}, {.vendor = 32902U, .device = 144U, .subvendor = 4294967295U, .subdevice = 21009U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2agn_cfg)}, {.vendor = 32902U, .device = 144U, .subvendor = 4294967295U, .subdevice = 21013U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2bgn_cfg)}, {.vendor = 32902U, .device = 144U, .subvendor = 4294967295U, .subdevice = 21014U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2abg_cfg)}, {.vendor = 32902U, .device = 145U, .subvendor = 4294967295U, .subdevice = 20993U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2agn_cfg)}, {.vendor = 32902U, .device = 145U, .subvendor = 4294967295U, .subdevice = 20997U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2bgn_cfg)}, {.vendor = 32902U, .device = 145U, .subvendor = 4294967295U, .subdevice = 20998U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2abg_cfg)}, {.vendor = 32902U, .device = 145U, .subvendor = 4294967295U, .subdevice = 20999U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2bg_cfg)}, {.vendor = 32902U, .device = 145U, .subvendor = 4294967295U, .subdevice = 21025U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2agn_cfg)}, {.vendor = 32902U, .device = 145U, .subvendor = 4294967295U, .subdevice = 21029U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2bgn_cfg)}, {.vendor = 32902U, .device = 145U, .subvendor = 4294967295U, .subdevice = 21030U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6030_2abg_cfg)}, {.vendor = 32902U, .device = 135U, .subvendor = 4294967295U, .subdevice = 4865U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6050_2agn_cfg)}, {.vendor = 32902U, .device = 135U, .subvendor = 4294967295U, .subdevice = 4870U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6050_2abg_cfg)}, {.vendor = 32902U, .device = 135U, .subvendor = 4294967295U, .subdevice = 4897U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6050_2agn_cfg)}, {.vendor = 32902U, .device = 135U, .subvendor = 4294967295U, .subdevice = 4902U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6050_2abg_cfg)}, {.vendor = 32902U, .device = 137U, .subvendor = 4294967295U, .subdevice = 4881U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6050_2agn_cfg)}, {.vendor = 32902U, .device = 137U, .subvendor = 4294967295U, .subdevice = 4886U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6050_2abg_cfg)}, {.vendor = 32902U, .device = 2181U, .subvendor = 4294967295U, .subdevice = 4869U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6150_bgn_cfg)}, {.vendor = 32902U, .device = 2181U, .subvendor = 4294967295U, .subdevice = 4871U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6150_bg_cfg)}, {.vendor = 32902U, .device = 2181U, .subvendor = 4294967295U, .subdevice = 4901U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6150_bgn_cfg)}, {.vendor = 32902U, .device = 2181U, .subvendor = 4294967295U, .subdevice = 4903U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6150_bg_cfg)}, {.vendor = 32902U, .device = 2182U, .subvendor = 4294967295U, .subdevice = 4885U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6150_bgn_cfg)}, {.vendor = 32902U, .device = 2182U, .subvendor = 4294967295U, .subdevice = 4887U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6150_bg_cfg)}, {.vendor = 32902U, .device = 131U, .subvendor = 4294967295U, .subdevice = 4613U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bgn_cfg)}, {.vendor = 32902U, .device = 131U, .subvendor = 4294967295U, .subdevice = 4869U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bgn_cfg)}, {.vendor = 32902U, .device = 131U, .subvendor = 4294967295U, .subdevice = 4645U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bgn_cfg)}, {.vendor = 32902U, .device = 131U, .subvendor = 4294967295U, .subdevice = 4901U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bgn_cfg)}, {.vendor = 32902U, .device = 132U, .subvendor = 4294967295U, .subdevice = 4629U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bgn_cfg)}, {.vendor = 32902U, .device = 132U, .subvendor = 4294967295U, .subdevice = 4885U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bgn_cfg)}, {.vendor = 32902U, .device = 131U, .subvendor = 4294967295U, .subdevice = 4614U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bg_cfg)}, {.vendor = 32902U, .device = 131U, .subvendor = 4294967295U, .subdevice = 4870U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bg_cfg)}, {.vendor = 32902U, .device = 131U, .subvendor = 4294967295U, .subdevice = 4646U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bg_cfg)}, {.vendor = 32902U, .device = 131U, .subvendor = 4294967295U, .subdevice = 4902U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bg_cfg)}, {.vendor = 32902U, .device = 132U, .subvendor = 4294967295U, .subdevice = 4630U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bg_cfg)}, {.vendor = 32902U, .device = 132U, .subvendor = 4294967295U, .subdevice = 4886U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl1000_bg_cfg)}, {.vendor = 32902U, .device = 2222U, .subvendor = 4294967295U, .subdevice = 4101U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl100_bgn_cfg)}, {.vendor = 32902U, .device = 2222U, .subvendor = 4294967295U, .subdevice = 4103U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl100_bg_cfg)}, {.vendor = 32902U, .device = 2223U, .subvendor = 4294967295U, .subdevice = 4117U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl100_bgn_cfg)}, {.vendor = 32902U, .device = 2223U, .subvendor = 4294967295U, .subdevice = 4119U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl100_bg_cfg)}, {.vendor = 32902U, .device = 2222U, .subvendor = 4294967295U, .subdevice = 4133U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl100_bgn_cfg)}, {.vendor = 32902U, .device = 2222U, .subvendor = 4294967295U, .subdevice = 4135U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl100_bg_cfg)}, {.vendor = 32902U, .device = 2198U, .subvendor = 4294967295U, .subdevice = 20485U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl130_bgn_cfg)}, {.vendor = 32902U, .device = 2198U, .subvendor = 4294967295U, .subdevice = 20487U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl130_bg_cfg)}, {.vendor = 32902U, .device = 2199U, .subvendor = 4294967295U, .subdevice = 20501U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl130_bgn_cfg)}, {.vendor = 32902U, .device = 2199U, .subvendor = 4294967295U, .subdevice = 20503U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl130_bg_cfg)}, {.vendor = 32902U, .device = 2198U, .subvendor = 4294967295U, .subdevice = 20517U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl130_bgn_cfg)}, {.vendor = 32902U, .device = 2198U, .subvendor = 4294967295U, .subdevice = 20519U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl130_bg_cfg)}, {.vendor = 32902U, .device = 2192U, .subvendor = 4294967295U, .subdevice = 16418U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl2000_2bgn_cfg)}, {.vendor = 32902U, .device = 2193U, .subvendor = 4294967295U, .subdevice = 16930U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl2000_2bgn_cfg)}, {.vendor = 32902U, .device = 2192U, .subvendor = 4294967295U, .subdevice = 17442U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl2000_2bgn_cfg)}, {.vendor = 32902U, .device = 2192U, .subvendor = 4294967295U, .subdevice = 18466U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl2000_2bgn_d_cfg)}, {.vendor = 32902U, .device = 2183U, .subvendor = 4294967295U, .subdevice = 16482U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl2030_2bgn_cfg)}, {.vendor = 32902U, .device = 2184U, .subvendor = 4294967295U, .subdevice = 16994U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl2030_2bgn_cfg)}, {.vendor = 32902U, .device = 2183U, .subvendor = 4294967295U, .subdevice = 17506U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl2030_2bgn_cfg)}, {.vendor = 32902U, .device = 2190U, .subvendor = 4294967295U, .subdevice = 16480U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6035_2agn_cfg)}, {.vendor = 32902U, .device = 2190U, .subvendor = 4294967295U, .subdevice = 16490U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6035_2agn_sff_cfg)}, {.vendor = 32902U, .device = 2191U, .subvendor = 4294967295U, .subdevice = 16992U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6035_2agn_cfg)}, {.vendor = 32902U, .device = 2191U, .subvendor = 4294967295U, .subdevice = 17002U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6035_2agn_sff_cfg)}, {.vendor = 32902U, .device = 2190U, .subvendor = 4294967295U, .subdevice = 17504U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6035_2agn_cfg)}, {.vendor = 32902U, .device = 2190U, .subvendor = 4294967295U, .subdevice = 17514U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6035_2agn_sff_cfg)}, {.vendor = 32902U, .device = 2190U, .subvendor = 4294967295U, .subdevice = 18528U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6035_2agn_cfg)}, {.vendor = 32902U, .device = 2191U, .subvendor = 4294967295U, .subdevice = 21088U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl6035_2agn_cfg)}, {.vendor = 32902U, .device = 2196U, .subvendor = 4294967295U, .subdevice = 34U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl105_bgn_cfg)}, {.vendor = 32902U, .device = 2197U, .subvendor = 4294967295U, .subdevice = 546U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl105_bgn_cfg)}, {.vendor = 32902U, .device = 2196U, .subvendor = 4294967295U, .subdevice = 1058U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl105_bgn_cfg)}, {.vendor = 32902U, .device = 2196U, .subvendor = 4294967295U, .subdevice = 2082U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl105_bgn_d_cfg)}, {.vendor = 32902U, .device = 2194U, .subvendor = 4294967295U, .subdevice = 98U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl135_bgn_cfg)}, {.vendor = 32902U, .device = 2195U, .subvendor = 4294967295U, .subdevice = 610U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl135_bgn_cfg)}, {.vendor = 32902U, .device = 2194U, .subvendor = 4294967295U, .subdevice = 1122U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl135_bgn_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16496U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16498U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16752U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 19552U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 19568U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16480U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16490U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16736U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16482U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16738U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 17008U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 17010U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 16992U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 17002U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 16994U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 17520U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 17522U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 17504U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 17514U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 17506U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 18544U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 18542U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 19056U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg_high_temp)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 19054U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg_high_temp)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 19052U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg_high_temp)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 17776U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 17760U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 17264U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 17248U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 20592U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 20594U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 20848U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 22384U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16416U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 16426U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 16928U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 17440U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49264U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49266U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49520U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49248U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49258U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49504U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49250U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49506U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 51056U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 51040U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 49776U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 52336U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 52320U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 49778U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 49760U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 49770U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 49762U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 50288U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 50290U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 50272U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 50274U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 50544U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 50528U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 50032U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2ac_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 50016U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49184U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 49194U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2226U, .subvendor = 4294967295U, .subdevice = 49696U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2225U, .subvendor = 4294967295U, .subdevice = 50208U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7260_2n_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 112U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 114U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 368U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 370U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 96U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2n_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 98U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_n_cfg)}, {.vendor = 32902U, .device = 2228U, .subvendor = 4294967295U, .subdevice = 624U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2228U, .subvendor = 4294967295U, .subdevice = 626U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 1136U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 1138U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2228U, .subvendor = 4294967295U, .subdevice = 880U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 32880U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 32882U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 33136U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 33138U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 32864U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2n_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 32866U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_n_cfg)}, {.vendor = 32902U, .device = 2228U, .subvendor = 4294967295U, .subdevice = 33392U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2228U, .subvendor = 4294967295U, .subdevice = 33648U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2228U, .subvendor = 4294967295U, .subdevice = 33394U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 33904U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 34160U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 4208U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 2227U, .subvendor = 4294967295U, .subdevice = 4464U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3160_2ac_cfg)}, {.vendor = 32902U, .device = 12645U, .subvendor = 4294967295U, .subdevice = 16400U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12645U, .subvendor = 4294967295U, .subdevice = 16402U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12646U, .subvendor = 4294967295U, .subdevice = 16914U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12645U, .subvendor = 4294967295U, .subdevice = 17424U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12645U, .subvendor = 4294967295U, .subdevice = 17680U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12645U, .subvendor = 4294967295U, .subdevice = 16656U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12646U, .subvendor = 4294967295U, .subdevice = 17168U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12646U, .subvendor = 4294967295U, .subdevice = 16912U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12645U, .subvendor = 4294967295U, .subdevice = 32784U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 12645U, .subvendor = 4294967295U, .subdevice = 33040U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl3165_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20496U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20752U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20736U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 21264U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 21250U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_n_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 21008U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20498U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 21522U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 21520U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 21776U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 21504U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 4112U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20480U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2n_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20490U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2n_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 20992U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2n_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20482U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_n_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20738U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_n_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 20994U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_n_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 36880U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 36882U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 36874U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 37136U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 37138U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 37392U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 37376U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 38160U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 37648U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 37904U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20512U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2n_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20522U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2n_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 21536U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2n_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20624U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 20880U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 21904U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 21136U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 21648U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 24336U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 21010U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2395U, .subvendor = 4294967295U, .subdevice = 21002U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 36864U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 2394U, .subvendor = 4294967295U, .subdevice = 37888U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl7265_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 16U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 4112U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 272U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 4368U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 80U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 592U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 4176U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 336U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9460U, .subvendor = 4294967295U, .subdevice = 48U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9460U, .subvendor = 4294967295U, .subdevice = 4400U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9460U, .subvendor = 4294967295U, .subdevice = 4144U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 49168U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 49424U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 53264U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 49232U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 53328U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 32784U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 36880U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9460U, .subvendor = 4294967295U, .subdevice = 32816U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9460U, .subvendor = 4294967295U, .subdevice = 36912U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 32848U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 36944U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 4U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2n_cfg)}, {.vendor = 32902U, .device = 9461U, .subvendor = 4294967295U, .subdevice = 16U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl4165_2ac_cfg)}, {.vendor = 32902U, .device = 9462U, .subvendor = 4294967295U, .subdevice = 48U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl4165_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 2064U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 2320U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 2128U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 32902U, .device = 9459U, .subvendor = 4294967295U, .subdevice = 2384U, .class = 0U, .class_mask = 0U, .driver_data = (unsigned long)(& iwl8260_2ac_cfg)}, {.vendor = 0U, .device = 0U, .subvendor = 0U, .subdevice = 0U, .class = 0U, .class_mask = 0U, .driver_data = 0UL}};

#line 457  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
struct pci_device_id const __mod_pci__iwl_hw_card_ids_device_table[324U];

#line 474 
void __compiletime_assert_474(void);


#line 483 
void __compiletime_assert_483(void);


#line 466  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static u64 splx_get_pwr_limit(struct iwl_trans *trans, union acpi_object *splx)
{
  u64 __retres;
  union acpi_object *limits;
  union acpi_object *domain_type;
  union acpi_object *power_limit;
  
#line 470 
  if (((splx->type != 4U || splx->package.count != 2U) || (splx->package.elements)->type != 1U) || (splx->package.elements)->integer.value != 0ULL) {
    {
      
#line 474 
      bool __cond = (_Bool)((int)*("Unsupported splx structure\n" + 26UL) != 10);
      
#line 474 
      if ((int)__cond != 0) 
#line 474 
                            __compiletime_assert_474(); else ;
    }
    
#line 474 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Unsupported splx structure\n");
    
#line 475 
    __retres = 0ULL;
    
#line 475 
    goto return_label;
  }
  else ;
  
#line 478 
  limits = splx->package.elements + 1U;
  
#line 479 
  if (((limits->type != 4U || limits->package.count <= 1U) || (limits->package.elements)->type != 1U) || (limits->package.elements + 1U)->type != 1U) {
    {
      
#line 483 
      bool __cond_0 = (_Bool)((int)*("Invalid limits element\n" + 22UL) != 10);
      
#line 483 
      if ((int)__cond_0 != 0) 
#line 483 
                              __compiletime_assert_483(); else ;
    }
    
#line 483 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Invalid limits element\n");
    
#line 484 
    __retres = 0ULL;
    
#line 484 
    goto return_label;
  }
  else ;
  
#line 487 
  domain_type = limits->package.elements;
  
#line 488 
  power_limit = limits->package.elements + 1U;
  
#line 489 
  if ((domain_type->integer.value & 2ULL) == 0ULL) {
    {
      
#line 490 
      bool __cond_1 = (_Bool)((int)*("WiFi power is not limited\n" + 25UL) != 10);
      
#line 490 
      if ((int)__cond_1 != 0) 
#line 490 
                              __compiletime_assert_490(); else ;
    }
    
#line 490 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"splx_get_pwr_limit","WiFi power is not limited\n");
    
#line 491 
    __retres = 0ULL;
    
#line 491 
    goto return_label;
  }
  else ;
  
#line 494 
  __retres = power_limit->integer.value;
  return_label: 
#line 494 
                return __retres;
}


#line 506 
void __compiletime_assert_507(void);


#line 514 
void __compiletime_assert_514(void);


#line 521 
void __compiletime_assert_521(void);


#line 526 
void __compiletime_assert_527(void);


#line 497  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static void set_dflt_pwr_limit(struct iwl_trans *trans, struct pci_dev *pdev)
{
  acpi_handle pxsx_handle;
  acpi_handle handle;
  acpi_status status;
  struct acpi_device *tmp;
  
#line 501 
  struct acpi_buffer splx = {.length = 18446744073709551615ULL, .pointer = (void *)0};
  
#line 504 
  tmp = to_acpi_node(pdev->dev.fwnode);
  
#line 504 
  pxsx_handle = acpi_device_handle(tmp);
  
#line 505 
  if (pxsx_handle == (void *)0) {
    {
      
#line 506 
      bool __cond = (_Bool)((int)*("Could not retrieve root port ACPI handle\n" + 40UL) != 10);
      
#line 506 
      if ((int)__cond != 0) 
#line 506 
                            __compiletime_assert_507(); else ;
    }
    
#line 506 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"set_dflt_pwr_limit","Could not retrieve root port ACPI handle\n");
    
#line 508 
    goto return_label;
  }
  else ;
  
#line 512 
  status = acpi_get_handle(pxsx_handle,(char *)"SPLC",(acpi_handle **)(& handle));
  
#line 513 
  if (status != 0U) {
    {
      
#line 514 
      bool __cond_0 = (_Bool)((int)*("SPL method not found\n" + 20UL) != 10);
      
#line 514 
      if ((int)__cond_0 != 0) 
#line 514 
                              __compiletime_assert_514(); else ;
    }
    
#line 514 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"set_dflt_pwr_limit","SPL method not found\n");
    
#line 515 
    goto return_label;
  }
  else ;
  
#line 519 
  status = acpi_evaluate_object(handle,(char *)0,(struct acpi_object_list *)0,& splx);
  
#line 520 
  if (status != 0U) {
    {
      
#line 521 
      bool __cond_1 = (_Bool)((int)*("SPLC invocation failed (0x%x)\n" + 29UL) != 10);
      
#line 521 
      if ((int)__cond_1 != 0) 
#line 521 
                              __compiletime_assert_521(); else ;
    }
    
#line 521 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"SPLC invocation failed (0x%x)\n",status);
    
#line 522 
    goto return_label;
  }
  else ;
  
#line 525 
  trans->dflt_pwr_limit = splx_get_pwr_limit(trans,(union acpi_object *)splx.pointer);
  {
    
#line 526 
    bool __cond_2 = (_Bool)((int)*("Default power limit set to %lld\n" + 31UL) != 10);
    
#line 526 
    if ((int)__cond_2 != 0) 
#line 526 
                            __compiletime_assert_527(); else ;
  }
  
#line 526 
  __iwl_dbg(trans->dev,1U,(_Bool)0,"set_dflt_pwr_limit","Default power limit set to %lld\n",trans->dflt_pwr_limit);
  
#line 528 
  kfree((void const *)splx.pointer);
  return_label: 
#line 529 
                return;
}


#line 538  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static int iwl_pci_probe(struct pci_dev *pdev, struct pci_device_id const *ent)
{
  int __retres;
  struct iwl_trans *iwl_trans;
  struct iwl_trans_pcie *trans_pcie;
  int ret;
  bool tmp_0;
  bool tmp_2;
  
#line 540 
  struct iwl_cfg const *cfg = (struct iwl_cfg const *)ent->driver_data;
  
#line 541 
  struct iwl_cfg const *cfg_7265d = (struct iwl_cfg const *)0;
  
#line 546 
  iwl_trans = iwl_trans_pcie_alloc(pdev,ent,cfg);
  
#line 547 
  tmp_0 = IS_ERR((void const *)iwl_trans);
  
#line 547 
  if ((int)tmp_0 != 0) {
    long tmp;
    
#line 548 
    tmp = PTR_ERR((void const *)iwl_trans);
    
#line 548 
    __retres = (int)tmp;
    
#line 548 
    goto return_label;
  }
  else ;
  
#line 558 
  if (cfg == & iwl7265_2ac_cfg) 
#line 559 
                                cfg_7265d = & iwl7265d_2ac_cfg;
  else 
    
#line 560 
    if (cfg == & iwl7265_2n_cfg) 
#line 561 
                                 cfg_7265d = & iwl7265d_2n_cfg;
    else 
      
#line 562 
      if (cfg == & iwl7265_n_cfg) 
#line 563 
                                  cfg_7265d = & iwl7265d_n_cfg; else ;
  
#line 564 
  if (cfg_7265d != (struct iwl_cfg const *)0 && (iwl_trans->hw_rev & 65520U) == 528U) {
    
#line 566 
    cfg = cfg_7265d;
    
#line 567 
    iwl_trans->cfg = cfg_7265d;
  }
  else ;
  
#line 571 
  pci_set_drvdata(pdev,(void *)iwl_trans);
  
#line 573 
  trans_pcie = (struct iwl_trans_pcie *)(& iwl_trans->trans_specific);
  
#line 574 
  trans_pcie->drv = iwl_drv_start(iwl_trans,cfg);
  
#line 576 
  tmp_2 = IS_ERR((void const *)trans_pcie->drv);
  
#line 576 
  if ((int)tmp_2 != 0) {
    long tmp_1;
    
#line 577 
    tmp_1 = PTR_ERR((void const *)trans_pcie->drv);
    
#line 577 
    ret = (int)tmp_1;
    
#line 578 
    goto out_free_trans;
  }
  else ;
  
#line 581 
  set_dflt_pwr_limit(iwl_trans,pdev);
  
#line 584 
  ret = iwl_trans_dbgfs_register(iwl_trans,iwl_trans->dbgfs_dir);
  
#line 585 
  if (ret != 0) 
#line 586 
                goto out_free_drv; else ;
  
#line 588 
  __retres = 0;
  
#line 588 
  goto return_label;
  out_free_drv: 
#line 590 
  ;
  
#line 591 
  iwl_drv_stop(trans_pcie->drv);
  out_free_trans: 
#line 592 
  ;
  
#line 593 
  iwl_trans_pcie_free(iwl_trans);
  
#line 594 
  __retres = ret;
  return_label: 
#line 594 
                return __retres;
}


#line 597  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static void iwl_pci_remove(struct pci_dev *pdev)
{
  
#line 599 
  struct iwl_trans *trans = pci_get_drvdata(pdev);
  
#line 600 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 602 
  iwl_drv_stop(trans_pcie->drv);
  
#line 603 
  iwl_trans_pcie_free(trans);
  
#line 604 
  return;
}


#line 608  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static int iwl_pci_suspend(struct device *device)
{
  int __retres;
  
#line 615 
  __retres = 0;
  
#line 615 
  return __retres;
}


#line 618  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static int iwl_pci_resume(struct device *device)
{
  int __retres;
  struct pci_dev *tmp;
  bool hw_rfkill;
  {
    
#line 620 
    struct device const *__mptr = (struct device const *)device;
    
#line 620 
    tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
  }
  
#line 620 
  struct pci_dev *pdev = tmp;
  
#line 621 
  struct iwl_trans *trans = pci_get_drvdata(pdev);
  
#line 633 
  pci_write_config_byte((struct pci_dev const *)pdev,65,(unsigned char)0);
  
#line 635 
  if (trans->op_mode == (struct iwl_op_mode *)0) {
    
#line 636 
    __retres = 0;
    
#line 636 
    goto return_label;
  }
  else ;
  
#line 644 
  if ((int)trans->wowlan_d0i3 != 0) {
    
#line 645 
    iwl_pcie_reset_ict(trans);
    
#line 646 
    iwl_enable_interrupts_0(trans);
  }
  else 
#line 648 
       iwl_enable_rfkill_int_0(trans);
  
#line 651 
  hw_rfkill = iwl_is_rfkill_set_0(trans);
  
#line 652 
  iwl_trans_pcie_rf_kill(trans,(_Bool)((bool)((int)hw_rfkill) != 0));
  
#line 654 
  __retres = 0;
  return_label: 
#line 654 
                return __retres;
}


#line 657  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static struct dev_pm_ops const iwl_dev_pm_ops = {.prepare = (int (*)(struct device *))0, .complete = (void (*)(struct device *))0, .suspend = & iwl_pci_suspend, .resume = & iwl_pci_resume, .freeze = & iwl_pci_suspend, .thaw = & iwl_pci_resume, .poweroff = & iwl_pci_suspend, .restore = & iwl_pci_resume, .suspend_late = (int (*)(struct device *))0, .resume_early = (int (*)(struct device *))0, .freeze_late = (int (*)(struct device *))0, .thaw_early = (int (*)(struct device *))0, .poweroff_late = (int (*)(struct device *))0, .restore_early = (int (*)(struct device *))0, .suspend_noirq = (int (*)(struct device *))0, .resume_noirq = (int (*)(struct device *))0, .freeze_noirq = (int (*)(struct device *))0, .thaw_noirq = (int (*)(struct device *))0, .poweroff_noirq = (int (*)(struct device *))0, .restore_noirq = (int (*)(struct device *))0, .runtime_suspend = (int (*)(struct device *))0, .runtime_resume = (int (*)(struct device *))0, .runtime_idle = (int (*)(struct device *))0};

#line 667  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
static struct pci_driver iwl_pci_driver = {.node = {.next = (struct list_head *)0, .prev = (struct list_head *)0}, .name = "iwlwifi", .id_table = (struct pci_device_id const *)(& iwl_hw_card_ids), .probe = & iwl_pci_probe, .remove = & iwl_pci_remove, .suspend = (int (*)(struct pci_dev *, pm_message_t ))0, .suspend_late = (int (*)(struct pci_dev *, pm_message_t ))0, .resume_early = (int (*)(struct pci_dev *))0, .resume = (int (*)(struct pci_dev *))0, .shutdown = (void (*)(struct pci_dev *))0, .sriov_configure = (int (*)(struct pci_dev *, int ))0, .err_handler = (struct pci_error_handlers const *)0, .driver = {.name = (char const *)0, .bus = (struct bus_type *)0, .owner = (struct module *)0, .mod_name = (char const *)0, .suppress_bind_attrs = (_Bool)0, .probe_type = 0, .of_match_table = (struct of_device_id const *)0, .acpi_match_table = (struct acpi_device_id const *)0, .probe = (int (*)(struct device *))0, .remove = (int (*)(struct device *))0, .shutdown = (void (*)(struct device *))0, .suspend = (int (*)(struct device *, pm_message_t ))0, .resume = (int (*)(struct device *))0, .groups = (struct attribute_group const **)0, .pm = & iwl_dev_pm_ops, .p = (struct driver_private *)0}, .dynids = {.lock = {.__anonCompField_spinlock_18 = {.rlock = {.raw_lock = {.val = {.counter = 0}}, .magic = 0U, .owner_cpu = 0U, .owner = (void *)0, .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char const *)0, .cpu = 0, .ip = 0UL}}}}, .list = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 675  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
int iwl_pci_register_driver(void)
{
  int ret;
  
#line 678 
  ret = ldv___pci_register_driver_73(& iwl_pci_driver,& __this_module,"iwlwifi");
  
#line 679 
  if (ret != 0) 
#line 680 
                printk("\001"); else ;
  
#line 682 
  return ret;
}


#line 685  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/drv.c"
void iwl_pci_unregister_driver(void)
{
  
#line 687 
  ldv_pci_unregister_driver_74(& iwl_pci_driver);
  
#line 688 
  return;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
struct dev_pm_ops *ldv_emg_alias_iwl_dev_pm_ops_3 = (struct dev_pm_ops *)(& iwl_dev_pm_ops);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
struct pci_driver *ldv_emg_alias_iwl_pci_driver_2 = & iwl_pci_driver;

#line 62 
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0);


#line 65 
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);


#line 72  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
int ldv_emg_wrapper_iwl_pci_resume_4(struct device *arg0)
{
  int tmp;
  
#line 73 
  tmp = iwl_pci_resume(arg0);
  
#line 73 
  return tmp;
}


#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
int ldv_emg_wrapper_iwl_pci_probe_2(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  int tmp;
  
#line 78 
  tmp = iwl_pci_probe(arg0,(struct pci_device_id const *)arg1);
  
#line 78 
  return tmp;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
void ldv_emg_wrapper_iwl_pci_remove_3(struct pci_dev *arg0)
{
  
#line 83 
  iwl_pci_remove(arg0);
  
#line 84 
  return;
}


#line 87  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
int ldv_emg_wrapper_iwl_pci_suspend_2(struct device *arg0)
{
  int tmp;
  
#line 88 
  tmp = iwl_pci_suspend(arg0);
  
#line 88 
  return tmp;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
static long PTR_ERR(void const *ptr)
{
  long tmp;
  
#line 103 
  tmp = ldv_ptr_err(ptr);
  
#line 103 
  return tmp;
}


#line 107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
static bool IS_ERR(void const *ptr)
{
  bool __retres;
  long ret;
  
#line 111 
  ret = ldv_is_err(ptr);
  
#line 112 
  __retres = (_Bool)(ret != 0L);
  
#line 112 
  return __retres;
}


#line 771  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
static int ldv___pci_register_driver_73(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char const *ldv_func_arg3)
{
  int tmp;
  
#line 775 
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,(char *)ldv_func_arg3);
  
#line 775 
  return tmp;
}


#line 779  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_drv.c.aux"
static void ldv_pci_unregister_driver_74(struct pci_driver *ldv_func_arg1)
{
  
#line 783 
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  
#line 784 
  return;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
static struct iwl_base_params const iwl6000_base_params = {.eeprom_size = 2048, .num_of_queues = 20, .pll_cfg_val = 0U, .max_ll_items = (unsigned short)4U, .shadow_ram_support = (_Bool)1, .led_compensation = (unsigned short)51U, .wd_timeout = 2500U, .max_event_log_size = 512U, .shadow_reg_enable = (_Bool)0, .pcie_l1_allowed = (_Bool)0, .apmg_wake_up_wa = (_Bool)0, .scd_chain_ext_wa = (_Bool)1};

#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
static struct iwl_base_params const iwl6050_base_params = {.eeprom_size = 2048, .num_of_queues = 20, .pll_cfg_val = 0U, .max_ll_items = (unsigned short)7U, .shadow_ram_support = (_Bool)1, .led_compensation = (unsigned short)51U, .wd_timeout = 2500U, .max_event_log_size = 1024U, .shadow_reg_enable = (_Bool)0, .pcie_l1_allowed = (_Bool)0, .apmg_wake_up_wa = (_Bool)0, .scd_chain_ext_wa = (_Bool)1};

#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
static struct iwl_base_params const iwl6000_g2_base_params = {.eeprom_size = 2048, .num_of_queues = 20, .pll_cfg_val = 0U, .max_ll_items = (unsigned short)4U, .shadow_ram_support = (_Bool)1, .led_compensation = (unsigned short)57U, .wd_timeout = 10000U, .max_event_log_size = 512U, .shadow_reg_enable = (_Bool)0, .pcie_l1_allowed = (_Bool)0, .apmg_wake_up_wa = (_Bool)0, .scd_chain_ext_wa = (_Bool)1};

#line 117  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
static struct iwl_ht_params const iwl6000_ht_params = {.smps_mode = 0, .ht_greenfield_support = (_Bool)1, .stbc = (_Bool)0, .ldpc = (_Bool)0, .use_rts_for_aggregation = (_Bool)1, .ht40_bands = (unsigned char)3U};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
static struct iwl_eeprom_params const iwl6000_eeprom_params = {.regulatory_bands = {(unsigned char)8U, (unsigned char)38U, (unsigned char)66U, (unsigned char)92U, (unsigned char)116U, (unsigned char)128U, (unsigned char)146U}, .enhanced_txpower = (_Bool)1};

#line 151  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6005_2agn_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6205 AGN", .fw_name_pre = "iwlwifi-6000g2a-", .ucode_api_max = 6U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6005, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6005_2abg_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6205 ABG", .fw_name_pre = "iwlwifi-6000g2a-", .ucode_api_max = 6U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6005, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 162  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6005_2bg_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6205 BG", .fw_name_pre = "iwlwifi-6000g2a-", .ucode_api_max = 6U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6005, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 167  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6005_2agn_sff_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6205S AGN", .fw_name_pre = "iwlwifi-6000g2a-", .ucode_api_max = 6U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6005, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6005_2agn_d_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6205D AGN", .fw_name_pre = "iwlwifi-6000g2a-", .ucode_api_max = 6U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6005, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6005_2agn_mow1_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6206 AGN", .fw_name_pre = "iwlwifi-6000g2a-", .ucode_api_max = 6U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6005, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6005_2agn_mow2_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6207 AGN", .fw_name_pre = "iwlwifi-6000g2a-", .ucode_api_max = 6U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6005, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6030_2agn_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6230 AGN", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 212  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6030_2abg_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6230 ABG", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6030_2bgn_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6230 BGN", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 223  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6030_2bg_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6230 BG", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 243  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6035_2agn_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6235 AGN", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 6U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 249  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6035_2agn_sff_cfg = {.name = "Intel(R) Centrino(R) Ultimate-N 6235 AGN", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 6U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 255  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl1030_bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 1030 BGN", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 261  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl1030_bg_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 1030 BG", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 266  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl130_bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 130 BGN", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)1, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 273  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl130_bg_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 130 BG", .fw_name_pre = "iwlwifi-6000g2b-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_6030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1801U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6000_g2_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)1, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6000i_2agn_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6200 AGN", .fw_name_pre = "iwlwifi-6000-", .ucode_api_max = 6U, .ucode_api_ok = 4U, .ucode_api_min = 4U, .device_family = IWL_DEVICE_FAMILY_6000i, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)6U, .valid_rx_ant = (unsigned char)6U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1059U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl6000_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 305  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6000i_2abg_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6200 ABG", .fw_name_pre = "iwlwifi-6000-", .ucode_api_max = 6U, .ucode_api_ok = 4U, .ucode_api_min = 4U, .device_family = IWL_DEVICE_FAMILY_6000i, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)6U, .valid_rx_ant = (unsigned char)6U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1059U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl6000_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6000i_2bg_cfg = {.name = "Intel(R) Centrino(R) Advanced-N 6200 BG", .fw_name_pre = "iwlwifi-6000-", .ucode_api_max = 6U, .ucode_api_ok = 4U, .ucode_api_min = 4U, .device_family = IWL_DEVICE_FAMILY_6000i, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)6U, .valid_rx_ant = (unsigned char)6U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1059U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl6000_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 332  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6050_2agn_cfg = {.name = "Intel(R) Centrino(R) Advanced-N + WiMAX 6250 AGN", .fw_name_pre = "iwlwifi-6050-", .ucode_api_max = 5U, .ucode_api_ok = 0U, .ucode_api_min = 4U, .device_family = IWL_DEVICE_FAMILY_6050, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)3U, .valid_rx_ant = (unsigned char)3U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1330U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl6050_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)1, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 338  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6050_2abg_cfg = {.name = "Intel(R) Centrino(R) Advanced-N + WiMAX 6250 ABG", .fw_name_pre = "iwlwifi-6050-", .ucode_api_max = 5U, .ucode_api_ok = 0U, .ucode_api_min = 4U, .device_family = IWL_DEVICE_FAMILY_6050, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)3U, .valid_rx_ant = (unsigned char)3U, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1330U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl6050_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)1, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6150_bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N + WiMAX 6150 BGN", .fw_name_pre = "iwlwifi-6050-", .ucode_api_max = 5U, .ucode_api_ok = 0U, .ucode_api_min = 4U, .device_family = IWL_DEVICE_FAMILY_6150, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1363U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6050_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)1, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 364  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6150_bg_cfg = {.name = "Intel(R) Centrino(R) Wireless-N + WiMAX 6150 BG", .fw_name_pre = "iwlwifi-6050-", .ucode_api_max = 5U, .ucode_api_ok = 0U, .ucode_api_min = 4U, .device_family = IWL_DEVICE_FAMILY_6150, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1363U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl6050_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)1, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 369  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-6000.c"
struct iwl_cfg const iwl6000_3agn_cfg = {.name = "Intel(R) Centrino(R) Ultimate-N 6300 AGN", .fw_name_pre = "iwlwifi-6000-", .ucode_api_max = 6U, .ucode_api_ok = 4U, .ucode_api_min = 4U, .device_family = IWL_DEVICE_FAMILY_6000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)1059U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl6000_base_params, .ht_params = & iwl6000_ht_params, .eeprom_params = & iwl6000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 0U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 409  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int scnprintf(char *, size_t, char const * , ...);


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
static bool static_key_false_1(struct static_key *key)
{
  bool tmp;
  
#line 125 
  tmp = arch_static_branch(key);
  
#line 125 
  return tmp;
}


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size, gfp_t flags);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/delay.h"
void __const_udelay(unsigned long);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc(size_t size, gfp_t flags);


#line 936  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static u32 iwl_trans_read_prph(struct iwl_trans *trans, u32 ofs)
{
  u32 tmp;
  
#line 938 
  tmp = (*((trans->ops)->read_prph))(trans,ofs);
  
#line 938 
  return tmp;
}


#line 941  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_trans_write_prph(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 944 
  (*((trans->ops)->write_prph))(trans,ofs,val);
  
#line 945 
  return;
}


#line 999  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_trans_release_nic_access(struct iwl_trans *trans, unsigned long *flags)
{
  
#line 1001 
  (*((trans->ops)->release_nic_access))(trans,flags);
  
#line 1003 
  return;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32_1(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 35 
  tmp_4 = static_key_false_1(& __tracepoint_iwlwifi_dev_ioread32.key);
  
#line 35 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 35 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_4474 __u;
          
#line 35 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u.__c),8);
          
#line 35 
          tmp = __u.__val;
        }
        
#line 35 
        struct tracepoint_func *_________p1 = tmp;
        
#line 35 
        tmp_0 = _________p1;
      }
      
#line 35 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 35 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 35 
        if (tmp_1 != 0) {
          
#line 35 
          if (! __warned) {
            int tmp_2;
            
#line 35 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 35 
            if (tmp_2 == 0) {
              
#line 35 
              __warned = (_Bool)1;
              
#line 35 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 35 
      tmp_3 = ________p1;
    }
    
#line 35 
    it_func_ptr = tmp_3;
    
#line 35 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50296: 
#line 37 
      ;
      
#line 35 
      it_func = it_func_ptr->func;
      
#line 35 
      __data = it_func_ptr->data;
      
#line 35 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 35 
      it_func_ptr += 1;
      
#line 35 
      ;
      
#line 35 
      if (it_func_ptr->func != (void *)0) 
#line 37 
                                          goto ldv_50296; else 
#line 40 
                                                               goto ldv_50297;
      ldv_50297: 
#line 41 
      ;
    }
    else ;
    
#line 35 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 35 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_4476 __u_0;
        
#line 35 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u_0.__c),8);
        
#line 35 
        tmp_5 = __u_0.__val;
      }
      
#line 35 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 35 
      tmp_6 = _________p1_0;
    }
    
#line 35 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 35 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 35 
      if (tmp_7 != 0) {
        
#line 35 
        if (! __warned_0) {
          int tmp_8;
          
#line 35 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 35 
          if (tmp_8 == 0) {
            
#line 35 
            __warned_0 = (_Bool)1;
            
#line 35 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 35 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 35 
  rcu_read_unlock_sched_notrace();
  
#line 37 
  return;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32_1(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 69 
  tmp_4 = static_key_false_1(& __tracepoint_iwlwifi_dev_iowrite32.key);
  
#line 69 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 69 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_4482 __u;
          
#line 69 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u.__c),8);
          
#line 69 
          tmp = __u.__val;
        }
        
#line 69 
        struct tracepoint_func *_________p1 = tmp;
        
#line 69 
        tmp_0 = _________p1;
      }
      
#line 69 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 69 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 69 
        if (tmp_1 != 0) {
          
#line 69 
          if (! __warned) {
            int tmp_2;
            
#line 69 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 69 
            if (tmp_2 == 0) {
              
#line 69 
              __warned = (_Bool)1;
              
#line 69 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 69 
      tmp_3 = ________p1;
    }
    
#line 69 
    it_func_ptr = tmp_3;
    
#line 69 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50418: 
#line 71 
      ;
      
#line 69 
      it_func = it_func_ptr->func;
      
#line 69 
      __data = it_func_ptr->data;
      
#line 69 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 69 
      it_func_ptr += 1;
      
#line 69 
      ;
      
#line 69 
      if (it_func_ptr->func != (void *)0) 
#line 71 
                                          goto ldv_50418; else 
#line 74 
                                                               goto ldv_50419;
      ldv_50419: 
#line 75 
      ;
    }
    else ;
    
#line 69 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 69 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_4484 __u_0;
        
#line 69 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u_0.__c),8);
        
#line 69 
        tmp_5 = __u_0.__val;
      }
      
#line 69 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 69 
      tmp_6 = _________p1_0;
    }
    
#line 69 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 69 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 69 
      if (tmp_7 != 0) {
        
#line 69 
        if (! __warned_0) {
          int tmp_8;
          
#line 69 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 69 
          if (tmp_8 == 0) {
            
#line 69 
            __warned_0 = (_Bool)1;
            
#line 69 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 69 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 69 
  rcu_read_unlock_sched_notrace();
  
#line 71 
  return;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite_prph32(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 86 
  tmp_4 = static_key_false_1(& __tracepoint_iwlwifi_dev_iowrite_prph32.key);
  
#line 86 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 86 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_4486 __u;
          
#line 86 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite_prph32.funcs),(void *)(& __u.__c),8);
          
#line 86 
          tmp = __u.__val;
        }
        
#line 86 
        struct tracepoint_func *_________p1 = tmp;
        
#line 86 
        tmp_0 = _________p1;
      }
      
#line 86 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 86 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 86 
        if (tmp_1 != 0) {
          
#line 86 
          if (! __warned) {
            int tmp_2;
            
#line 86 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 86 
            if (tmp_2 == 0) {
              
#line 86 
              __warned = (_Bool)1;
              
#line 86 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",101,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 86 
      tmp_3 = ________p1;
    }
    
#line 86 
    it_func_ptr = tmp_3;
    
#line 86 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50479: 
#line 88 
      ;
      
#line 86 
      it_func = it_func_ptr->func;
      
#line 86 
      __data = it_func_ptr->data;
      
#line 86 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 86 
      it_func_ptr += 1;
      
#line 86 
      ;
      
#line 86 
      if (it_func_ptr->func != (void *)0) 
#line 88 
                                          goto ldv_50479; else 
#line 91 
                                                               goto ldv_50480;
      ldv_50480: 
#line 92 
      ;
    }
    else ;
    
#line 86 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 86 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_4488 __u_0;
        
#line 86 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite_prph32.funcs),(void *)(& __u_0.__c),8);
        
#line 86 
        tmp_5 = __u_0.__val;
      }
      
#line 86 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 86 
      tmp_6 = _________p1_0;
    }
    
#line 86 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 86 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 86 
      if (tmp_7 != 0) {
        
#line 86 
        if (! __warned_0) {
          int tmp_8;
          
#line 86 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 86 
          if (tmp_8 == 0) {
            
#line 86 
            __warned_0 = (_Bool)1;
            
#line 86 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",101,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 86 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 86 
  rcu_read_unlock_sched_notrace();
  
#line 88 
  return;
}


#line 103  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread_prph32(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 103 
  tmp_4 = static_key_false_1(& __tracepoint_iwlwifi_dev_ioread_prph32.key);
  
#line 103 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 103 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_4490 __u;
          
#line 103 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread_prph32.funcs),(void *)(& __u.__c),8);
          
#line 103 
          tmp = __u.__val;
        }
        
#line 103 
        struct tracepoint_func *_________p1 = tmp;
        
#line 103 
        tmp_0 = _________p1;
      }
      
#line 103 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 103 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 103 
        if (tmp_1 != 0) {
          
#line 103 
          if (! __warned) {
            int tmp_2;
            
#line 103 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 103 
            if (tmp_2 == 0) {
              
#line 103 
              __warned = (_Bool)1;
              
#line 103 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",118,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 103 
      tmp_3 = ________p1;
    }
    
#line 103 
    it_func_ptr = tmp_3;
    
#line 103 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50540: 
#line 105 
      ;
      
#line 103 
      it_func = it_func_ptr->func;
      
#line 103 
      __data = it_func_ptr->data;
      
#line 103 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 103 
      it_func_ptr += 1;
      
#line 103 
      ;
      
#line 103 
      if (it_func_ptr->func != (void *)0) 
#line 105 
                                          goto ldv_50540; else 
#line 108 
                                                               goto ldv_50541;
      ldv_50541: 
#line 109 
      ;
    }
    else ;
    
#line 103 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 103 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_4492 __u_0;
        
#line 103 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread_prph32.funcs),(void *)(& __u_0.__c),8);
        
#line 103 
        tmp_5 = __u_0.__val;
      }
      
#line 103 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 103 
      tmp_6 = _________p1_0;
    }
    
#line 103 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 103 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 103 
      if (tmp_7 != 0) {
        
#line 103 
        if (! __warned_0) {
          int tmp_8;
          
#line 103 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 103 
          if (tmp_8 == 0) {
            
#line 103 
            __warned_0 = (_Bool)1;
            
#line 103 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",118,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 103 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 103 
  rcu_read_unlock_sched_notrace();
  
#line 105 
  return;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_write32_1(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 43 
  trace_iwlwifi_dev_iowrite32_1((struct device const *)trans->dev,ofs,val);
  
#line 44 
  iwl_trans_write32(trans,ofs,val);
  
#line 45 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static u32 iwl_read32_1(struct iwl_trans *trans, u32 ofs)
{
  
#line 49 
  u32 val = iwl_trans_read32(trans,ofs);
  
#line 50 
  trace_iwlwifi_dev_ioread32_1((struct device const *)trans->dev,ofs,val);
  
#line 51 
  return val;
}


#line 64 
int iwl_poll_bit(struct iwl_trans *trans, u32 addr, u32 bits, u32 mask, int timeout);


#line 69 
u32 iwl_read_direct32(struct iwl_trans *trans, u32 reg);


#line 73 
u32 __iwl_read_prph(struct iwl_trans *trans, u32 ofs);


#line 75 
void __iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val);


#line 76 
void iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val);


#line 77 
int iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr, u32 bits, u32 mask, int timeout);


#line 79 
void iwl_set_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask);


#line 80 
void iwl_set_bits_mask_prph(struct iwl_trans *trans, u32 ofs, u32 bits, u32 mask);


#line 82 
void iwl_clear_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask);


#line 83 
void iwl_force_nmi(struct iwl_trans *trans);


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
int iwl_poll_bit(struct iwl_trans *trans, u32 addr, u32 bits, u32 mask, int timeout)
{
  int __retres;
  u32 tmp;
  
#line 44 
  int t = 0;
  ldv_51790: 
#line 45 
  ;
  
#line 47 
  tmp = iwl_read32_1(trans,addr);
  
#line 47 
  ;
  
#line 47 
  if (((tmp ^ bits) & mask) == 0U) {
    
#line 48 
    __retres = t;
    
#line 48 
    goto return_label;
  }
  else ;
  
#line 49 
  __const_udelay(42950UL);
  
#line 50 
  t += 10;
  
#line 51 
  if (t < timeout) 
#line 53 
                   goto ldv_51790; else 
#line 56 
                                        goto ldv_51791;
  ldv_51791: 
#line 57 
  ;
  
#line 53 
  __retres = -110;
  return_label: 
#line 53 
                return __retres;
}


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_poll_bit[13U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'p', (char)'o', (char)'l', (char)'l', (char)'_', (char)'b', (char)'i', (char)'t', (char)'\000'};

#line 55 
struct kernel_symbol const __ksymtab_iwl_poll_bit;


#line 55  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_poll_bit = {.value = (unsigned long)(& iwl_poll_bit), .name = (char const *)(& __kstrtab_iwl_poll_bit)};

#line 57  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
u32 iwl_read_direct32(struct iwl_trans *trans, u32 reg)
{
  unsigned long flags;
  bool tmp;
  
#line 59 
  u32 value = 1515870810U;
  
#line 61 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 61 
  if ((long)((int)tmp != 0) != 0L) {
    
#line 62 
    value = iwl_read32_1(trans,reg);
    
#line 63 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else ;
  
#line 66 
  return value;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_read_direct32[18U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'r', (char)'e', (char)'a', (char)'d', (char)'_', (char)'d', (char)'i', (char)'r', (char)'e', (char)'c', (char)'t', (char)'3', (char)'2', (char)'\000'};

#line 68 
struct kernel_symbol const __ksymtab_iwl_read_direct32;


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_read_direct32 = {.value = (unsigned long)(& iwl_read_direct32), .name = (char const *)(& __kstrtab_iwl_read_direct32)};

#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
void iwl_write_direct32(struct iwl_trans *trans, u32 reg, u32 value)
{
  unsigned long flags;
  bool tmp;
  
#line 74 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 74 
  if ((long)((int)tmp != 0) != 0L) {
    
#line 75 
    iwl_write32_1(trans,reg,value);
    
#line 76 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else ;
  
#line 78 
  return;
}


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_write_direct32[19U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'_', (char)'d', (char)'i', (char)'r', (char)'e', (char)'c', (char)'t', (char)'3', (char)'2', (char)'\000'};

#line 79 
struct kernel_symbol const __ksymtab_iwl_write_direct32;


#line 79  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_write_direct32 = {.value = (unsigned long)(& iwl_write_direct32), .name = (char const *)(& __kstrtab_iwl_write_direct32)};

#line 81  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
int iwl_poll_direct_bit(struct iwl_trans *trans, u32 addr, u32 mask, int timeout)
{
  int __retres;
  u32 tmp;
  
#line 84 
  int t = 0;
  ldv_51839: 
#line 85 
  ;
  
#line 87 
  tmp = iwl_read_direct32(trans,addr);
  
#line 87 
  ;
  
#line 87 
  if ((tmp & mask) == mask) {
    
#line 88 
    __retres = t;
    
#line 88 
    goto return_label;
  }
  else ;
  
#line 89 
  __const_udelay(42950UL);
  
#line 90 
  t += 10;
  
#line 91 
  if (t < timeout) 
#line 93 
                   goto ldv_51839; else 
#line 96 
                                        goto ldv_51840;
  ldv_51840: 
#line 97 
  ;
  
#line 93 
  __retres = -110;
  return_label: 
#line 93 
                return __retres;
}


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_poll_direct_bit[20U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'p', (char)'o', (char)'l', (char)'l', (char)'_', (char)'d', (char)'i', (char)'r', (char)'e', (char)'c', (char)'t', (char)'_', (char)'b', (char)'i', (char)'t', (char)'\000'};

#line 95 
struct kernel_symbol const __ksymtab_iwl_poll_direct_bit;


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_poll_direct_bit = {.value = (unsigned long)(& iwl_poll_direct_bit), .name = (char const *)(& __kstrtab_iwl_poll_direct_bit)};

#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
u32 __iwl_read_prph(struct iwl_trans *trans, u32 ofs)
{
  
#line 99 
  u32 val = iwl_trans_read_prph(trans,ofs);
  
#line 100 
  trace_iwlwifi_dev_ioread_prph32((struct device const *)trans->dev,ofs,val);
  
#line 101 
  return val;
}


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
void __iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 106 
  trace_iwlwifi_dev_iowrite_prph32((struct device const *)trans->dev,ofs,val);
  
#line 107 
  iwl_trans_write_prph(trans,ofs,val);
  
#line 108 
  return;
}


#line 110  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
u32 iwl_read_prph(struct iwl_trans *trans, u32 ofs)
{
  unsigned long flags;
  bool tmp;
  
#line 113 
  u32 val = 1515870810U;
  
#line 115 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 115 
  if ((long)((int)tmp != 0) != 0L) {
    
#line 116 
    val = __iwl_read_prph(trans,ofs);
    
#line 117 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else ;
  
#line 119 
  return val;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_read_prph[14U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'r', (char)'e', (char)'a', (char)'d', (char)'_', (char)'p', (char)'r', (char)'p', (char)'h', (char)'\000'};

#line 121 
struct kernel_symbol const __ksymtab_iwl_read_prph;


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_read_prph = {.value = (unsigned long)(& iwl_read_prph), .name = (char const *)(& __kstrtab_iwl_read_prph)};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
void iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val)
{
  unsigned long flags;
  bool tmp;
  
#line 127 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 127 
  if ((long)((int)tmp != 0) != 0L) {
    
#line 128 
    __iwl_write_prph(trans,ofs,val);
    
#line 129 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else ;
  
#line 131 
  return;
}


#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_write_prph[15U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'w', (char)'r', (char)'i', (char)'t', (char)'e', (char)'_', (char)'p', (char)'r', (char)'p', (char)'h', (char)'\000'};

#line 132 
struct kernel_symbol const __ksymtab_iwl_write_prph;


#line 132  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_write_prph = {.value = (unsigned long)(& iwl_write_prph), .name = (char const *)(& __kstrtab_iwl_write_prph)};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
int iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr, u32 bits, u32 mask, int timeout)
{
  int __retres;
  u32 tmp;
  
#line 137 
  int t = 0;
  ldv_51898: 
#line 138 
  ;
  
#line 140 
  tmp = iwl_read_prph(trans,addr);
  
#line 140 
  ;
  
#line 140 
  if (((tmp ^ bits) & mask) == 0U) {
    
#line 141 
    __retres = t;
    
#line 141 
    goto return_label;
  }
  else ;
  
#line 142 
  __const_udelay(42950UL);
  
#line 143 
  t += 10;
  
#line 144 
  if (t < timeout) 
#line 146 
                   goto ldv_51898; else 
#line 149 
                                        goto ldv_51899;
  ldv_51899: 
#line 150 
  ;
  
#line 146 
  __retres = -110;
  return_label: 
#line 146 
                return __retres;
}


#line 149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
void iwl_set_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask)
{
  unsigned long flags;
  bool tmp_0;
  
#line 153 
  tmp_0 = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 153 
  if ((long)((int)tmp_0 != 0) != 0L) {
    u32 tmp;
    
#line 154 
    tmp = __iwl_read_prph(trans,ofs);
    
#line 154 
    ;
    
#line 154 
    ;
    
#line 154 
    ;
    
#line 154 
    __iwl_write_prph(trans,ofs,tmp | mask);
    
#line 156 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else ;
  
#line 158 
  return;
}


#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_set_bits_prph[18U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'s', (char)'e', (char)'t', (char)'_', (char)'b', (char)'i', (char)'t', (char)'s', (char)'_', (char)'p', (char)'r', (char)'p', (char)'h', (char)'\000'};

#line 159 
struct kernel_symbol const __ksymtab_iwl_set_bits_prph;


#line 159  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_set_bits_prph = {.value = (unsigned long)(& iwl_set_bits_prph), .name = (char const *)(& __kstrtab_iwl_set_bits_prph)};

#line 161  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
void iwl_set_bits_mask_prph(struct iwl_trans *trans, u32 ofs, u32 bits, u32 mask)
{
  unsigned long flags;
  bool tmp_0;
  
#line 166 
  tmp_0 = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 166 
  if ((long)((int)tmp_0 != 0) != 0L) {
    u32 tmp;
    
#line 167 
    tmp = __iwl_read_prph(trans,ofs);
    
#line 167 
    ;
    
#line 167 
    ;
    
#line 167 
    ;
    
#line 167 
    __iwl_write_prph(trans,ofs,(tmp & mask) | bits);
    
#line 169 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else ;
  
#line 171 
  return;
}


#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_set_bits_mask_prph[23U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'s', (char)'e', (char)'t', (char)'_', (char)'b', (char)'i', (char)'t', (char)'s', (char)'_', (char)'m', (char)'a', (char)'s', (char)'k', (char)'_', (char)'p', (char)'r', (char)'p', (char)'h', (char)'\000'};

#line 172 
struct kernel_symbol const __ksymtab_iwl_set_bits_mask_prph;


#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_set_bits_mask_prph = {.value = (unsigned long)(& iwl_set_bits_mask_prph), .name = (char const *)(& __kstrtab_iwl_set_bits_mask_prph)};

#line 174  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
void iwl_clear_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask)
{
  unsigned long flags;
  u32 val;
  bool tmp;
  
#line 179 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 179 
  if ((long)((int)tmp != 0) != 0L) {
    
#line 180 
    val = __iwl_read_prph(trans,ofs);
    
#line 181 
    __iwl_write_prph(trans,ofs,~ mask & val);
    
#line 182 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else ;
  
#line 184 
  return;
}


#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_clear_bits_prph[20U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'c', (char)'l', (char)'e', (char)'a', (char)'r', (char)'_', (char)'b', (char)'i', (char)'t', (char)'s', (char)'_', (char)'p', (char)'r', (char)'p', (char)'h', (char)'\000'};

#line 185 
struct kernel_symbol const __ksymtab_iwl_clear_bits_prph;


#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_clear_bits_prph = {.value = (unsigned long)(& iwl_clear_bits_prph), .name = (char const *)(& __kstrtab_iwl_clear_bits_prph)};

#line 187  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
void iwl_force_nmi(struct iwl_trans *trans)
{
  
#line 189 
  if ((trans->cfg)->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) {
    
#line 190 
    iwl_write_prph(trans,10492976U,128U);
    
#line 192 
    iwl_write_prph(trans,10492976U,1U);
  }
  else {
    
#line 195 
    iwl_write_prph(trans,10492964U,16777216U);
    
#line 197 
    iwl_write_prph(trans,10492976U,128U);
  }
  
#line 199 
  return;
}


#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const __kstrtab_iwl_force_nmi[14U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'f', (char)'o', (char)'r', (char)'c', (char)'e', (char)'_', (char)'n', (char)'m', (char)'i', (char)'\000'};

#line 201 
struct kernel_symbol const __ksymtab_iwl_force_nmi;


#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
struct kernel_symbol const __ksymtab_iwl_force_nmi = {.value = (unsigned long)(& iwl_force_nmi), .name = (char const *)(& __kstrtab_iwl_force_nmi)};

#line 203  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
static char const *get_fh_string(int cmd)
{
  char const *__retres;
  
#line 206 
  switch (cmd) {
    case 7104: 
#line 207 
    ;
    
#line 207 
    __retres = "FH_RSCSR_CHNL0_STTS_WPTR_REG";
    
#line 207 
    goto return_label;
    case 7108: 
#line 208 
    ;
    
#line 208 
    __retres = "FH_RSCSR_CHNL0_RBDCB_BASE_REG";
    
#line 208 
    goto return_label;
    case 7112: 
#line 209 
    ;
    
#line 209 
    __retres = "FH_RSCSR_CHNL0_WPTR";
    
#line 209 
    goto return_label;
    case 7168: 
#line 210 
    ;
    
#line 210 
    __retres = "FH_MEM_RCSR_CHNL0_CONFIG_REG";
    
#line 210 
    goto return_label;
    case 7232: 
#line 211 
    ;
    
#line 211 
    __retres = "FH_MEM_RSSR_SHARED_CTRL_REG";
    
#line 211 
    goto return_label;
    case 7236: 
#line 212 
    ;
    
#line 212 
    __retres = "FH_MEM_RSSR_RX_STATUS_REG";
    
#line 212 
    goto return_label;
    case 7240: 
#line 213 
    ;
    
#line 213 
    __retres = "FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV";
    
#line 213 
    goto return_label;
    case 7856: 
#line 214 
    ;
    
#line 214 
    __retres = "FH_TSSR_TX_STATUS_REG";
    
#line 214 
    goto return_label;
    case 7864: 
#line 215 
    ;
    
#line 215 
    __retres = "FH_TSSR_TX_ERROR_REG";
    
#line 215 
    goto return_label;
    default: 
#line 216 
    ;
    
#line 217 
    __retres = "UNKNOWN";
    
#line 217 
    goto return_label;
  }
  return_label: 
#line 206 
                return __retres;
}


#line 259 
void __compiletime_assert_259(void);


#line 261 
void __compiletime_assert_263(void);


#line 222  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.c"
int iwl_dump_fh(struct iwl_trans *trans, char **buf)
{
  int __retres;
  int i;
  u32 tmp_4;
  char const *tmp_5;
  
#line 225 
  u32 const fh_tbl[9U] = {7104U, 7108U, 7112U, 7168U, 7232U, 7236U, 7240U, 7856U, 7864U};
  
#line 238 
  if (buf != (char **)0) {
    int tmp_0;
    int tmp_3;
    u32 tmp_1;
    char const *tmp_2;
    
#line 239 
    int pos = 0;
    
#line 240 
    size_t bufsz = 472UL;
    
#line 242 
    *buf = (char *)kmalloc(bufsz,208U);
    
#line 243 
    if (*buf == (char *)0) {
      
#line 244 
      __retres = -12;
      
#line 244 
      goto return_label;
    }
    else ;
    
#line 246 
    tmp_0 = scnprintf(*buf + pos,bufsz - (unsigned long)pos,"FH register values:\n");
    
#line 247 
    pos = tmp_0 + pos;
    
#line 249 
    i = 0;
    
#line 249 
    goto ldv_51986;
    ldv_51985: 
#line 250 
    ;
    
#line 252 
    tmp_1 = iwl_read_direct32(trans,fh_tbl[i]);
    
#line 251 
    tmp_2 = get_fh_string((int)fh_tbl[i]);
    
#line 250 
    ;
    
#line 250 
    ;
    
#line 250 
    tmp_3 = scnprintf(*buf + pos,bufsz - (unsigned long)pos,"  %34s: 0X%08x\n",tmp_2,tmp_1);
    
#line 253 
    pos = tmp_3 + pos;
    
#line 249 
    i += 1;
    ldv_51986: 
#line 250 
    ;
    
#line 249 
    if ((unsigned int)i <= 8U) 
#line 251 
                               goto ldv_51985; else 
#line 254 
                                                    goto ldv_51987;
    ldv_51987: 
#line 255 
    ;
    
#line 255 
    __retres = pos;
    
#line 255 
    goto return_label;
  }
  else ;
  {
    
#line 259 
    bool __cond = (_Bool)((int)*("FH register values:\n" + 19UL) != 10);
    
#line 259 
    if ((int)__cond != 0) 
#line 259 
                          __compiletime_assert_259(); else ;
  }
  
#line 259 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"FH register values:\n");
  
#line 260 
  i = 0;
  
#line 260 
  goto ldv_52000;
  ldv_51999: 
#line 261 
  ;
  {
    
#line 261 
    bool __cond_0 = (_Bool)((int)*("  %34s: 0X%08x\n" + 14UL) != 10);
    
#line 261 
    if ((int)__cond_0 != 0) 
#line 261 
                            __compiletime_assert_263(); else ;
  }
  
#line 261 
  tmp_4 = iwl_read_direct32(trans,fh_tbl[i]);
  
#line 261 
  tmp_5 = get_fh_string((int)fh_tbl[i]);
  
#line 261 
  ;
  
#line 261 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"  %34s: 0X%08x\n",tmp_5,tmp_4);
  
#line 260 
  i += 1;
  ldv_52000: 
#line 261 
  ;
  
#line 260 
  if ((unsigned int)i <= 8U) 
#line 262 
                             goto ldv_51999; else 
#line 265 
                                                  goto ldv_52001;
  ldv_52001: 
#line 266 
  ;
  
#line 265 
  __retres = 0;
  return_label: 
#line 265 
                return __retres;
}


#line 468  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-io.c.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 471 
  tmp = ldv_kmalloc(size,flags);
  
#line 471 
  return tmp;
}


#line 314  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr, unsigned long const volatile *addr)
{
  int oldbit;
  
#line 317 
  ldv_inline_asm();
  
#line 323 
  return oldbit;
}


#line 437  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int fls(int x)
{
  int __retres;
  int r;
  
#line 440 
  ldv_inline_asm();
  
#line 464 
  __retres = r + 1;
  
#line 464 
  return __retres;
}


#line 479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x)
{
  int __retres;
  
#line 481 
  int bitpos = -1;
  
#line 482 
  ldv_inline_asm();
  
#line 490 
  __retres = bitpos + 1;
  
#line 490 
  return __retres;
}


#line 14  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bitops/find.h"
unsigned long find_next_bit(unsigned long const *, unsigned long, unsigned long);


#line 42 
unsigned long find_first_bit(unsigned long const *, unsigned long);


#line 22  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
int ____ilog2_NaN(void);


#line 32  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n)
{
  int __retres;
  int tmp;
  
#line 34 
  tmp = fls((int)n);
  
#line 34 
  __retres = tmp + -1;
  
#line 34 
  return __retres;
}


#line 431  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
void print_hex_dump(char const *, char const *, int, int, int, void const *, size_t, bool);


#line 248  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
void __might_fault(char const *, int);


#line 405 
int snprintf(char *, size_t, char const * , ...);


#line 418 
int sscanf(char const *, char const * , ...);


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/bug.h"
void warn_slowpath_fmt(char const *, int const, char const * , ...);


#line 13  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size)
{
  int order;
  
#line 17 
  size -= 1UL;
  
#line 18 
  size >>= 12;
  
#line 22 
  order = fls64((unsigned long long)size);
  
#line 24 
  return order;
}


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static void *ERR_PTR_0(long error);


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
static bool static_key_false_2(struct static_key *key)
{
  bool tmp;
  
#line 125 
  tmp = arch_static_branch(key);
  
#line 125 
  return tmp;
}


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock_api_smp.h"
void _raw_spin_lock_bh(raw_spinlock_t *);


#line 42 
void _raw_spin_unlock_bh(raw_spinlock_t *);


#line 45 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_0(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_73_0(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_75_0(spinlock_t *lock);


#line 366 
static void ldv_spin_lock_77(spinlock_t *lock);


#line 370 
static void ldv_spin_lock_79(spinlock_t *lock);


#line 374 
static void ldv_spin_lock_81(spinlock_t *lock);


#line 375  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh(spinlock_t *lock)
{
  
#line 377 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 378 
  return;
}


#line 403 
static void ldv_spin_lock_bh_87(spinlock_t *lock);


#line 407 
static void ldv_spin_lock_bh_103(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_0(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_74_0(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_76_0(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_78(spinlock_t *lock);


#line 419 
static void ldv_spin_unlock_80(spinlock_t *lock);


#line 423 
static void ldv_spin_unlock_82_0(spinlock_t *lock);


#line 424  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh(spinlock_t *lock)
{
  
#line 426 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 427 
  return;
}


#line 452 
static void ldv_spin_unlock_bh_90(spinlock_t *lock);


#line 456 
static void ldv_spin_unlock_bh_104(spinlock_t *lock);


#line 470  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 472 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 473 
  return;
}


#line 502 
static void ldv_spin_unlock_irqrestore_85(spinlock_t *lock, unsigned long flags);


#line 506 
static void ldv_spin_unlock_irqrestore_86(spinlock_t *lock, unsigned long flags);


#line 510 
static void ldv_spin_unlock_irqrestore_92(spinlock_t *lock, unsigned long flags);


#line 514 
static void ldv_spin_unlock_irqrestore_94(spinlock_t *lock, unsigned long flags);


#line 518 
static void ldv_spin_unlock_irqrestore_96(spinlock_t *lock, unsigned long flags);


#line 522 
static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock, unsigned long flags);


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
void __ldv_spin_lock(spinlock_t *);


#line 70 
static void ldv___ldv_spin_lock_84(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_91(spinlock_t *ldv_func_arg1);


#line 78 
static void ldv___ldv_spin_lock_93(spinlock_t *ldv_func_arg1);


#line 82 
static void ldv___ldv_spin_lock_95(spinlock_t *ldv_func_arg1);


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/wait.h"
void __init_waitqueue_head(wait_queue_head_t *, char const *, struct lock_class_key *);


#line 926 
long prepare_to_wait_event(wait_queue_head_t *, wait_queue_t *, int);


#line 927 
void finish_wait(wait_queue_head_t *, wait_queue_t *);


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
extern unsigned long volatile jiffies;


#line 292 
unsigned long __msecs_to_jiffies(unsigned int const);


#line 299  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long _msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 301 
  __retres = (unsigned long)(((long)m + 3L) / 4L);
  
#line 301 
  return __retres;
}


#line 354  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const m)
{
  unsigned long __retres;
  
#line 356 
  if (0 != 0) {
    unsigned long tmp;
    
#line 357 
    if ((int)m < 0) {
      
#line 358 
      __retres = 4611686018427387902UL;
      
#line 358 
      goto return_label;
    }
    else ;
    
#line 359 
    tmp = _msecs_to_jiffies(m);
    
#line 359 
    __retres = tmp;
    
#line 359 
    goto return_label;
  }
  else {
    unsigned long tmp_0;
    
#line 361 
    tmp_0 = __msecs_to_jiffies(m);
    
#line 361 
    __retres = tmp_0;
    
#line 361 
    goto return_label;
  }
  return_label: 
#line 356 
                return __retres;
}


#line 172  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
static int ldv_del_timer_88(struct timer_list *ldv_func_arg1);


#line 177 
static int ldv_mod_timer_89(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile *addr)
{
  unsigned int ret;
  
#line 59 
  ldv_inline_asm();
  
#line 58 
  return ret;
}


#line 64  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val, void volatile *addr)
{
  
#line 66 
  ldv_inline_asm();
  
#line 67 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void volatile *addr)
{
  
#line 68 
  ldv_inline_asm();
  
#line 69 
  return;
}


#line 195 
void iounmap(void volatile *);


#line 1083  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
void dev_err(struct device const *, char const * , ...);


#line 1089 
void _dev_info(struct device const *, char const * , ...);


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/sched.h"
long schedule_timeout(long);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_2(size_t size, gfp_t flags);


#line 861  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
int pci_bus_read_config_word(struct pci_bus *, unsigned int, int, u16 *);


#line 867 
int pci_bus_write_config_word(struct pci_bus *, unsigned int, int, u16);


#line 887  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev const *dev, int where, u16 *val)
{
  int tmp;
  
#line 889 
  tmp = pci_bus_read_config_word(dev->bus,dev->devfn,where,val);
  
#line 889 
  return tmp;
}


#line 900  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev const *dev, int where, u16 val)
{
  int tmp;
  
#line 902 
  tmp = pci_bus_write_config_word(dev->bus,dev->devfn,where,(unsigned short)((int)val));
  
#line 902 
  return tmp;
}


#line 910 
int pcie_capability_read_word(struct pci_dev *, int, u16 *);


#line 951 
int pci_enable_device(struct pci_dev *);


#line 968 
void pci_disable_device(struct pci_dev *);


#line 971 
void pci_set_master(struct pci_dev *);


#line 1042 
bool pci_pme_capable(struct pci_dev *, pci_power_t);


#line 1094 
int pci_request_regions(struct pci_dev *, char const *);


#line 1096 
void pci_release_regions(struct pci_dev *);


#line 1212 
void pci_disable_msi(struct pci_dev *);


#line 1219 
int pci_enable_msi_range(struct pci_dev *, int, int);


#line 1220  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev, int nvec)
{
  int __retres;
  
#line 1222 
  int rc = pci_enable_msi_range(dev,nvec,nvec);
  
#line 1223 
  if (rc < 0) {
    
#line 1224 
    __retres = rc;
    
#line 1224 
    goto return_label;
  }
  else ;
  
#line 1225 
  __retres = 0;
  return_label: 
#line 1225 
                return __retres;
}


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-debug.h"
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);


#line 63 
void debug_dma_sync_single_for_device(struct device *, dma_addr_t, size_t, int);


#line 102  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 106 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 108 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 108 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 110 
    ldv_inline_asm();
    
#line 108 
    ;
  }
  else ;
  
#line 109 
  if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 110 
    (*(ops->sync_single_for_cpu))(dev,addr,size,dir); else ;
  
#line 111 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  
#line 112 
  return;
}


#line 114  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  int tmp_0;
  
#line 118 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 120 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 120 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 122 
    ldv_inline_asm();
    
#line 120 
    ;
  }
  else ;
  
#line 121 
  if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
    
#line 122 
    (*(ops->sync_single_for_device))(dev,addr,size,dir); else ;
  
#line 123 
  debug_dma_sync_single_for_device(dev,addr,size,(int)dir);
  
#line 124 
  return;
}


#line 60  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/dma-mapping.h"
int dma_supported(struct device *, u64);


#line 61 
int dma_set_mask(struct device *, u64);


#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev, u64 mask)
{
  int __retres;
  int tmp;
  
#line 103 
  tmp = dma_supported(dev,mask);
  
#line 103 
  if (tmp == 0) {
    
#line 104 
    __retres = -5;
    
#line 104 
    goto return_label;
  }
  else ;
  
#line 105 
  dev->coherent_dma_mask = mask;
  
#line 106 
  __retres = 0;
  return_label: 
#line 106 
                return __retres;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
{
  int tmp;
  
#line 115 
  tmp = dma_set_mask(& dev->dev,mask);
  
#line 115 
  return tmp;
}


#line 118  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
{
  int tmp;
  
#line 120 
  tmp = dma_set_coherent_mask(& dev->dev,mask);
  
#line 120 
  return tmp;
}


#line 1666  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci.h"
void *pci_ioremap_bar(struct pci_dev *, int);


#line 30  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/pci-aspm.h"
void pci_disable_link_state(struct pci_dev *, int);


#line 650  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
unsigned long _copy_from_user(void *, void const *, unsigned int);


#line 662 
void copy_from_user_overflow(void);


#line 672 
void __copy_from_user_overflow(void);


#line 693  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void const *from, unsigned long n)
{
  
#line 695 
  int sz = -1;
  
#line 697 
  __might_fault("./arch/x86/include/asm/uaccess.h",697);
  
#line 717 
  if ((long)(sz < 0) != 0L || (long)((unsigned long)sz >= n) != 0L) 
#line 718 
                                                                    n = _copy_from_user(to,from,(unsigned int)n);
  else 
    
#line 719 
    if (0 != 0) 
#line 720 
                copy_from_user_overflow(); else 
#line 722 
                                                __copy_from_user_overflow();
  
#line 724 
  return n;
}


#line 11  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/hardirq.h"
void synchronize_irq(unsigned int);


#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/interrupt.h"
static int ldv_request_threaded_irq_105(unsigned int ldv_func_arg1, irqreturn_t (*ldv_func_arg2)(int , void *), irqreturn_t (*ldv_func_arg3)(int , void *), unsigned long ldv_func_arg4, char const *ldv_func_arg5, void *ldv_func_arg6);


#line 157 
static void ldv_free_irq_83(unsigned int ldv_func_arg1, void *ldv_func_arg2);


#line 2662  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/fs.h"
loff_t generic_file_llseek(struct file *, loff_t, int);


#line 2812 
int simple_open(struct inode *, struct file *);


#line 2843 
ssize_t simple_read_from_buffer(void *, size_t, loff_t *, void const *, size_t);


#line 54  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
static struct dentry *ldv_debugfs_create_file_98(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 58 
static struct dentry *ldv_debugfs_create_file_99(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 62 
static struct dentry *ldv_debugfs_create_file_100(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 66 
static struct dentry *ldv_debugfs_create_file_101(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 70 
static struct dentry *ldv_debugfs_create_file_102(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5);


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vzalloc(unsigned long);


#line 46  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/delay.h"
void msleep(unsigned int);


#line 48 
void usleep_range(unsigned long, unsigned long);


#line 1920  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/netdevice.h"
void netif_napi_del(struct napi_struct *);


#line 2205 
int init_dummy_netdev(struct net_device *);


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.h"
void __iwl_info(struct device *dev, char const *fmt , ...);


#line 231  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h"
__inline static struct iwl_fw_error_dump_data *iwl_fw_error_next_data(struct iwl_fw_error_dump_data *data)
{
  struct iwl_fw_error_dump_data *__retres;
  
#line 233 
  __retres = (struct iwl_fw_error_dump_data *)(& data->data) + data->len;
  
#line 233 
  return __retres;
}


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw.h"
__inline static char const *get_fw_dbg_mode_string(int mode)
{
  char const *__retres;
  
#line 215 
  switch (mode) {
    case 0: 
#line 216 
    ;
    
#line 217 
    __retres = "SMEM";
    
#line 217 
    goto return_label;
    case 1: 
#line 218 
    ;
    
#line 219 
    __retres = "EXTERNAL_DRAM";
    
#line 219 
    goto return_label;
    case 2: 
#line 220 
    ;
    
#line 221 
    __retres = "MARBH";
    
#line 221 
    goto return_label;
    case 3: 
#line 222 
    ;
    
#line 223 
    __retres = "MIPI";
    
#line 223 
    goto return_label;
    default: 
#line 224 
    ;
    
#line 225 
    __retres = "UNKNOWN";
    
#line 225 
    goto return_label;
  }
  return_label: 
#line 215 
                return __retres;
}


#line 211  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static bool iwl_op_mode_hw_rf_kill(struct iwl_op_mode *op_mode, bool state)
{
  bool tmp;
  
#line 213 
  __might_sleep("drivers/net/wireless/iwlwifi/iwl-op-mode.h",213,0);
  
#line 214 
  tmp = (*((op_mode->ops)->hw_rf_kill))(op_mode,(_Bool)((bool)((int)state) != 0));
  
#line 214 
  return tmp;
}


#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_nic_config(struct iwl_op_mode *op_mode)
{
  
#line 235 
  __might_sleep("drivers/net/wireless/iwlwifi/iwl-op-mode.h",235,0);
  
#line 236 
  (*((op_mode->ops)->nic_config))(op_mode);
  
#line 237 
  return;
}


#line 263  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_napi_add(struct iwl_op_mode *op_mode, struct napi_struct *napi, struct net_device *napi_dev, int (*poll)(struct napi_struct *, int ), int weight)
{
  
#line 269 
  if ((op_mode->ops)->napi_add == (void (*)(struct iwl_op_mode *, struct napi_struct *, struct net_device *, int (*)(struct napi_struct *, int ), int ))0) 
    
#line 270 
    goto return_label; else ;
  
#line 271 
  (*((op_mode->ops)->napi_add))(op_mode,napi,napi_dev,poll,weight);
  return_label: 
#line 272 
                return;
}


#line 947  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static int iwl_trans_read_mem(struct iwl_trans *trans, u32 addr, void *buf, int dwords)
{
  int tmp;
  
#line 950 
  tmp = (*((trans->ops)->read_mem))(trans,addr,buf,dwords);
  
#line 950 
  return tmp;
}


#line 960  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static u32 iwl_trans_read_mem32(struct iwl_trans *trans, u32 addr)
{
  u32 __retres;
  u32 value;
  int tmp_0;
  {
    int tmp;
    
#line 964 
    tmp = iwl_trans_read_mem(trans,addr,(void *)(& value),1);
    
#line 964 
    int __ret_warn_on = tmp != 0;
    
#line 964 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 964 
                                          warn_slowpath_null("drivers/net/wireless/iwlwifi/iwl-trans.h",964); else ;
    
#line 964 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 964 
  if ((long)tmp_0 != 0L) {
    
#line 965 
    __retres = 2779096485U;
    
#line 965 
    goto return_label;
  }
  else ;
  
#line 967 
  __retres = value;
  return_label: 
#line 967 
                return __retres;
}


#line 1018 
struct iwl_trans *iwl_trans_alloc(unsigned int priv_size, struct device *dev, struct iwl_cfg const *cfg, struct iwl_trans_ops const *ops, size_t dev_cmd_headroom);


#line 1023 
void iwl_trans_free(struct iwl_trans *trans);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32_2(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 35 
  tmp_4 = static_key_false_2(& __tracepoint_iwlwifi_dev_ioread32.key);
  
#line 35 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 35 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_4935 __u;
          
#line 35 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u.__c),8);
          
#line 35 
          tmp = __u.__val;
        }
        
#line 35 
        struct tracepoint_func *_________p1 = tmp;
        
#line 35 
        tmp_0 = _________p1;
      }
      
#line 35 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 35 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 35 
        if (tmp_1 != 0) {
          
#line 35 
          if (! __warned) {
            int tmp_2;
            
#line 35 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 35 
            if (tmp_2 == 0) {
              
#line 35 
              __warned = (_Bool)1;
              
#line 35 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 35 
      tmp_3 = ________p1;
    }
    
#line 35 
    it_func_ptr = tmp_3;
    
#line 35 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_52357: 
#line 37 
      ;
      
#line 35 
      it_func = it_func_ptr->func;
      
#line 35 
      __data = it_func_ptr->data;
      
#line 35 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 35 
      it_func_ptr += 1;
      
#line 35 
      ;
      
#line 35 
      if (it_func_ptr->func != (void *)0) 
#line 37 
                                          goto ldv_52357; else 
#line 40 
                                                               goto ldv_52358;
      ldv_52358: 
#line 41 
      ;
    }
    else ;
    
#line 35 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 35 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_4937 __u_0;
        
#line 35 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u_0.__c),8);
        
#line 35 
        tmp_5 = __u_0.__val;
      }
      
#line 35 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 35 
      tmp_6 = _________p1_0;
    }
    
#line 35 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 35 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 35 
      if (tmp_7 != 0) {
        
#line 35 
        if (! __warned_0) {
          int tmp_8;
          
#line 35 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 35 
          if (tmp_8 == 0) {
            
#line 35 
            __warned_0 = (_Bool)1;
            
#line 35 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 35 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 35 
  rcu_read_unlock_sched_notrace();
  
#line 37 
  return;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32_2(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 69 
  tmp_4 = static_key_false_2(& __tracepoint_iwlwifi_dev_iowrite32.key);
  
#line 69 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 69 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_4943 __u;
          
#line 69 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u.__c),8);
          
#line 69 
          tmp = __u.__val;
        }
        
#line 69 
        struct tracepoint_func *_________p1 = tmp;
        
#line 69 
        tmp_0 = _________p1;
      }
      
#line 69 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 69 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 69 
        if (tmp_1 != 0) {
          
#line 69 
          if (! __warned) {
            int tmp_2;
            
#line 69 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 69 
            if (tmp_2 == 0) {
              
#line 69 
              __warned = (_Bool)1;
              
#line 69 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 69 
      tmp_3 = ________p1;
    }
    
#line 69 
    it_func_ptr = tmp_3;
    
#line 69 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_52479: 
#line 71 
      ;
      
#line 69 
      it_func = it_func_ptr->func;
      
#line 69 
      __data = it_func_ptr->data;
      
#line 69 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 69 
      it_func_ptr += 1;
      
#line 69 
      ;
      
#line 69 
      if (it_func_ptr->func != (void *)0) 
#line 71 
                                          goto ldv_52479; else 
#line 74 
                                                               goto ldv_52480;
      ldv_52480: 
#line 75 
      ;
    }
    else ;
    
#line 69 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 69 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_4945 __u_0;
        
#line 69 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u_0.__c),8);
        
#line 69 
        tmp_5 = __u_0.__val;
      }
      
#line 69 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 69 
      tmp_6 = _________p1_0;
    }
    
#line 69 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 69 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 69 
      if (tmp_7 != 0) {
        
#line 69 
        if (! __warned_0) {
          int tmp_8;
          
#line 69 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 69 
          if (tmp_8 == 0) {
            
#line 69 
            __warned_0 = (_Bool)1;
            
#line 69 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 69 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 69 
  rcu_read_unlock_sched_notrace();
  
#line 71 
  return;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_write32_2(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 43 
  trace_iwlwifi_dev_iowrite32_2((struct device const *)trans->dev,ofs,val);
  
#line 44 
  iwl_trans_write32(trans,ofs,val);
  
#line 45 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static u32 iwl_read32_2(struct iwl_trans *trans, u32 ofs)
{
  
#line 49 
  u32 val = iwl_trans_read32(trans,ofs);
  
#line 50 
  trace_iwlwifi_dev_ioread32_2((struct device const *)trans->dev,ofs,val);
  
#line 51 
  return val;
}


#line 59  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_clear_bit(struct iwl_trans *trans, u32 reg, u32 mask)
{
  
#line 61 
  iwl_trans_set_bits_mask(trans,reg,mask,0U);
  
#line 62 
  return;
}


#line 111  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static unsigned int SCD_QUEUE_WRPTR(unsigned int chnl)
{
  unsigned int __retres;
  
#line 113 
  if (chnl <= 19U) {
    
#line 114 
    __retres = (chnl + 2624262U) * 4U;
    
#line 114 
    goto return_label;
  }
  else ;
  {
    bool __warned;
    
#line 115 
    int __ret_warn_once = chnl > 31U;
    
#line 115 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 115 
        int __ret_warn_on = ! __warned;
        
#line 115 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 115 
                                              warn_slowpath_null("drivers/net/wireless/iwlwifi/iwl-scd.h",115); else ;
        
#line 115 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 115 
      if ((long)tmp != 0L) 
#line 115 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 115 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 116 
  __retres = (chnl + 2624397U) * 4U;
  return_label: 
#line 116 
                return __retres;
}


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static unsigned int SCD_QUEUE_RDPTR(unsigned int chnl)
{
  unsigned int __retres;
  
#line 121 
  if (chnl <= 19U) {
    
#line 122 
    __retres = (chnl + 2624282U) * 4U;
    
#line 122 
    goto return_label;
  }
  else ;
  {
    bool __warned;
    
#line 123 
    int __ret_warn_once = chnl > 31U;
    
#line 123 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 123 
        int __ret_warn_on = ! __warned;
        
#line 123 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 123 
                                              warn_slowpath_null("drivers/net/wireless/iwlwifi/iwl-scd.h",123); else ;
        
#line 123 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 123 
      if ((long)tmp != 0L) 
#line 123 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 123 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 124 
  __retres = (chnl + 2624429U) * 4U;
  return_label: 
#line 124 
                return __retres;
}


#line 127  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static unsigned int SCD_QUEUE_STATUS_BITS(unsigned int chnl)
{
  unsigned int __retres;
  
#line 129 
  if (chnl <= 19U) {
    
#line 130 
    __retres = (chnl + 2624323U) * 4U;
    
#line 130 
    goto return_label;
  }
  else ;
  {
    bool __warned;
    
#line 131 
    int __ret_warn_once = chnl > 31U;
    
#line 131 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 131 
        int __ret_warn_on = ! __warned;
        
#line 131 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 131 
                                              warn_slowpath_null("drivers/net/wireless/iwlwifi/iwl-scd.h",131); else ;
        
#line 131 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 131 
      if ((long)tmp != 0L) 
#line 131 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 131 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 132 
  __retres = (chnl + 2624461U) * 4U;
  return_label: 
#line 132 
                return __retres;
}


#line 472  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fh.h"
__inline static u8 iwl_get_dma_hi_addr(dma_addr_t addr)
{
  u8 __retres;
  
#line 474 
  __retres = (unsigned char)((unsigned int)((unsigned char)(addr >> 32)) & 15U);
  
#line 474 
  return __retres;
}


#line 131  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static int iwl_queue_dec_wrap(int index)
{
  int __retres;
  
#line 133 
  index -= 1;
  
#line 133 
  __retres = index & 255;
  
#line 133 
  return __retres;
}


#line 374 
int iwl_pcie_tx_init(struct iwl_trans *trans);


#line 375 
void iwl_pcie_tx_start(struct iwl_trans *trans, u32 scd_base_addr);


#line 376 
int iwl_pcie_tx_stop(struct iwl_trans *trans);


#line 377 
void iwl_pcie_tx_free(struct iwl_trans *trans);


#line 378 
void iwl_trans_pcie_txq_enable(struct iwl_trans *trans, int txq_id, u16 ssn, struct iwl_trans_txq_scd_cfg const *cfg, unsigned int wdg_timeout);


#line 381 
void iwl_trans_pcie_txq_disable(struct iwl_trans *trans, int txq_id, bool configure_scd);


#line 383 
int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb, struct iwl_device_cmd *dev_cmd, int txq_id);


#line 386 
int iwl_trans_pcie_send_hcmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd);


#line 389 
void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn, struct sk_buff_head *skbs);


#line 391 
void iwl_trans_pcie_tx_reset(struct iwl_trans *trans);


#line 393 
void iwl_trans_pcie_ref(struct iwl_trans *trans);


#line 394 
void iwl_trans_pcie_unref(struct iwl_trans *trans);


#line 396  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static u16 iwl_pcie_tfd_tb_get_len(struct iwl_tfd *tfd, u8 idx)
{
  u16 __retres;
  
#line 398 
  struct iwl_tfd_tb *tb = & tfd->tbs[(int)idx];
  
#line 400 
  __retres = (unsigned short)((int)tb->hi_n_len >> 4);
  
#line 400 
  return __retres;
}


#line 411  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_disable_interrupts_0(struct iwl_trans *trans)
{
  
#line 413 
  set_bit(3L,(unsigned long volatile *)(& trans->status));
  
#line 416 
  iwl_write32_2(trans,12U,0U);
  
#line 420 
  iwl_write32_2(trans,8U,4294967295U);
  
#line 421 
  iwl_write32_2(trans,16U,4294967295U);
  {
    
#line 422 
    bool __cond = (_Bool)((int)*("Disabled interrupts\n" + 19UL) != 10);
    
#line 422 
    if ((int)__cond != 0) 
#line 422 
                          __compiletime_assert_422(); else ;
  }
  
#line 422 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_disable_interrupts","Disabled interrupts\n");
  
#line 423 
  return;
}


#line 425  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_enable_interrupts_1(struct iwl_trans *trans)
{
  
#line 427 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    
#line 429 
    bool __cond = (_Bool)((int)*("Enabling interrupts\n" + 19UL) != 10);
    
#line 429 
    if ((int)__cond != 0) 
#line 429 
                          __compiletime_assert_429(); else ;
  }
  
#line 429 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_enable_interrupts","Enabling interrupts\n");
  
#line 430 
  set_bit(3L,(unsigned long volatile *)(& trans->status));
  
#line 431 
  trans_pcie->inta_mask = 3120562315U;
  
#line 432 
  iwl_write32_2(trans,12U,trans_pcie->inta_mask);
  
#line 433 
  return;
}


#line 435  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_enable_rfkill_int_1(struct iwl_trans *trans)
{
  
#line 437 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    
#line 439 
    bool __cond = (_Bool)((int)*("Enabling rfkill interrupt\n" + 25UL) != 10);
    
#line 439 
    if ((int)__cond != 0) 
#line 439 
                          __compiletime_assert_439(); else ;
  }
  
#line 439 
  __iwl_dbg(trans->dev,33554432U,(_Bool)0,"iwl_enable_rfkill_int","Enabling rfkill interrupt\n");
  
#line 440 
  trans_pcie->inta_mask = 128U;
  
#line 441 
  iwl_write32_2(trans,12U,trans_pcie->inta_mask);
  
#line 442 
  return;
}


#line 462 
void __compiletime_assert_462(void);


#line 488  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static bool iwl_is_rfkill_set_1(struct iwl_trans *trans)
{
  bool __retres;
  u32 tmp;
  
#line 490 
  tmp = iwl_read32_2(trans,36U);
  
#line 490 
  __retres = (_Bool)((tmp & 134217728U) == 0U);
  
#line 490 
  return __retres;
}


#line 494  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void __iwl_trans_pcie_set_bits_mask(struct iwl_trans *trans, u32 reg, u32 mask, u32 value)
{
  u32 v;
  {
    bool __warned;
    
#line 500 
    int __ret_warn_once = (~ mask & value) != 0U;
    
#line 500 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 500 
        int __ret_warn_on = ! __warned;
        
#line 500 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 500 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h",500); else ;
        
#line 500 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 500 
      if ((long)tmp != 0L) 
#line 500 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 500 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 503 
  v = iwl_read32_2(trans,reg);
  
#line 504 
  v = ~ mask & v;
  
#line 505 
  v |= value;
  
#line 506 
  iwl_write32_2(trans,reg,v);
  
#line 507 
  return;
}


#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void __iwl_trans_pcie_clear_bit(struct iwl_trans *trans, u32 reg, u32 mask)
{
  
#line 512 
  __iwl_trans_pcie_set_bits_mask(trans,reg,mask,0U);
  
#line 513 
  return;
}


#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void __iwl_trans_pcie_set_bit(struct iwl_trans *trans, u32 reg, u32 mask)
{
  
#line 518 
  __iwl_trans_pcie_set_bits_mask(trans,reg,mask,mask);
  
#line 519 
  return;
}


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_pcie_free_fw_monitor(struct iwl_trans *trans)
{
  int tmp_70;
  
#line 90 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 92 
  if (trans_pcie->fw_mon_page == (struct page *)0) 
#line 93 
                                                   goto return_label; else ;
  
#line 95 
  dma_unmap_page(trans->dev,trans_pcie->fw_mon_phys,(unsigned long)trans_pcie->fw_mon_size,(enum dma_data_direction)DMA_FROM_DEVICE);
  
#line 98 
  if (0 != 0) {
    int tmp_68;
    
#line 98 
    if (trans_pcie->fw_mon_size != 0U) {
      int tmp_67;
      
#line 98 
      if (trans_pcie->fw_mon_size > 4095U) {
        int tmp_66;
        
#line 98 
        if (0 != 0) {
          int tmp_64;
          
#line 98 
          if (trans_pcie->fw_mon_size == 1U) {
            int tmp;
            
#line 98 
            tmp = ____ilog2_NaN();
            
#line 98 
            tmp_64 = tmp + -11;
          }
          else {
            int tmp_63;
            
#line 98 
            if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 4611686018427387904ULL) == 0ULL) {
              int tmp_62;
              
#line 98 
              if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 2305843009213693952ULL) == 0ULL) {
                int tmp_61;
                
#line 98 
                if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 1152921504606846976ULL) == 0ULL) {
                  int tmp_60;
                  
#line 98 
                  if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 576460752303423488ULL) == 0ULL) {
                    int tmp_59;
                    
#line 98 
                    if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 288230376151711744ULL) == 0ULL) {
                      int tmp_58;
                      
#line 98 
                      if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 144115188075855872ULL) == 0ULL) {
                        int tmp_57;
                        
#line 98 
                        if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 72057594037927936ULL) == 0ULL) {
                          int tmp_56;
                          
#line 98 
                          if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 36028797018963968ULL) == 0ULL) {
                            int tmp_55;
                            
#line 98 
                            if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 18014398509481984ULL) == 0ULL) {
                              int tmp_54;
                              
#line 98 
                              if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 9007199254740992ULL) == 0ULL) {
                                int tmp_53;
                                
#line 98 
                                if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 4503599627370496ULL) == 0ULL) {
                                  int tmp_52;
                                  
#line 98 
                                  if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 2251799813685248ULL) == 0ULL) {
                                    int tmp_51;
                                    
#line 98 
                                    if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 1125899906842624ULL) == 0ULL) {
                                      int tmp_50;
                                      
#line 98 
                                      if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 562949953421312ULL) == 0ULL) {
                                        int tmp_49;
                                        
#line 98 
                                        if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 281474976710656ULL) == 0ULL) {
                                          int tmp_48;
                                          
#line 98 
                                          if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 140737488355328ULL) == 0ULL) {
                                            int tmp_47;
                                            
#line 98 
                                            if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 70368744177664ULL) == 0ULL) {
                                              int tmp_46;
                                              
#line 98 
                                              if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 35184372088832ULL) == 0ULL) {
                                                int tmp_45;
                                                
#line 98 
                                                if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 17592186044416ULL) == 0ULL) {
                                                  int tmp_44;
                                                  
#line 98 
                                                  if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 8796093022208ULL) == 0ULL) {
                                                    int tmp_43;
                                                    
#line 98 
                                                    if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 4398046511104ULL) == 0ULL) {
                                                      int tmp_42;
                                                      
#line 98 
                                                      if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 2199023255552ULL) == 0ULL) {
                                                        int tmp_41;
                                                        
#line 98 
                                                        if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 1099511627776ULL) == 0ULL) {
                                                          int tmp_40;
                                                          
#line 98 
                                                          if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 549755813888ULL) == 0ULL) {
                                                            int tmp_39;
                                                            
#line 98 
                                                            if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 274877906944ULL) == 0ULL) {
                                                              int tmp_38;
                                                              
#line 98 
                                                              if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 137438953472ULL) == 0ULL) {
                                                                int tmp_37;
                                                                
#line 98 
                                                                if (((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 68719476736ULL) == 0ULL) {
                                                                  int tmp_36;
                                                                  
#line 98 
                                                                  if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 34359738368ULL) == 0ULL) {
                                                                    int tmp_35;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 17179869184ULL) == 0ULL) {
                                                                    int tmp_34;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 8589934592ULL) == 0ULL) {
                                                                    int tmp_33;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 4294967296ULL) == 0ULL) {
                                                                    int tmp_32;
                                                                    
#line 98 
                                                                    if (
                                                                    trans_pcie->fw_mon_size + 4294967295U >= (u32)0) {
                                                                    int tmp_31;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 1073741824ULL) == 0ULL) {
                                                                    int tmp_30;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 536870912ULL) == 0ULL) {
                                                                    int tmp_29;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 268435456ULL) == 0ULL) {
                                                                    int tmp_28;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 134217728ULL) == 0ULL) {
                                                                    int tmp_27;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 67108864ULL) == 0ULL) {
                                                                    int tmp_26;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 33554432ULL) == 0ULL) {
                                                                    int tmp_25;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 16777216ULL) == 0ULL) {
                                                                    int tmp_24;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 8388608ULL) == 0ULL) {
                                                                    int tmp_23;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 4194304ULL) == 0ULL) {
                                                                    int tmp_22;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 2097152ULL) == 0ULL) {
                                                                    int tmp_21;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 1048576ULL) == 0ULL) {
                                                                    int tmp_20;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 524288ULL) == 0ULL) {
                                                                    int tmp_19;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 262144ULL) == 0ULL) {
                                                                    int tmp_18;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 131072ULL) == 0ULL) {
                                                                    int tmp_17;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 65536ULL) == 0ULL) {
                                                                    int tmp_16;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 32768ULL) == 0ULL) {
                                                                    int tmp_15;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 16384ULL) == 0ULL) {
                                                                    int tmp_14;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 8192ULL) == 0ULL) {
                                                                    int tmp_13;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 4096ULL) == 0ULL) {
                                                                    int tmp_12;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 2048ULL) == 0ULL) {
                                                                    int tmp_11;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 1024ULL) == 0ULL) {
                                                                    int tmp_10;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 512ULL) == 0ULL) {
                                                                    int tmp_9;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 256ULL) == 0ULL) {
                                                                    int tmp_8;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 128ULL) == 0ULL) {
                                                                    int tmp_7;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 64ULL) == 0ULL) {
                                                                    int tmp_6;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 32ULL) == 0ULL) {
                                                                    int tmp_5;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 16ULL) == 0ULL) {
                                                                    int tmp_4;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 8ULL) == 0ULL) {
                                                                    int tmp_3;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 4ULL) == 0ULL) {
                                                                    int tmp_2;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 2ULL) == 0ULL) {
                                                                    int tmp_1;
                                                                    
#line 98 
                                                                    if (
                                                                    ((unsigned long long)(trans_pcie->fw_mon_size + 4294967295U) & 1ULL) == 0ULL) {
                                                                    int tmp_0;
                                                                    
#line 98 
                                                                    tmp_0 = ____ilog2_NaN();
                                                                    
#line 98 
                                                                    tmp_1 = tmp_0 + -11;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_1 = -11;
                                                                    
#line 98 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_2 = -10;
                                                                    
#line 98 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_3 = -9;
                                                                    
#line 98 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_4 = -8;
                                                                    
#line 98 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_5 = -7;
                                                                    
#line 98 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_6 = -6;
                                                                    
#line 98 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_7 = -5;
                                                                    
#line 98 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_8 = -4;
                                                                    
#line 98 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_9 = -3;
                                                                    
#line 98 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_10 = -2;
                                                                    
#line 98 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_11 = -1;
                                                                    
#line 98 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_12 = 0;
                                                                    
#line 98 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_13 = 1;
                                                                    
#line 98 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_14 = 2;
                                                                    
#line 98 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_15 = 3;
                                                                    
#line 98 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_16 = 4;
                                                                    
#line 98 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_17 = 5;
                                                                    
#line 98 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_18 = 6;
                                                                    
#line 98 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_19 = 7;
                                                                    
#line 98 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_20 = 8;
                                                                    
#line 98 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_21 = 9;
                                                                    
#line 98 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_22 = 10;
                                                                    
#line 98 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_23 = 11;
                                                                    
#line 98 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_24 = 12;
                                                                    
#line 98 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_25 = 13;
                                                                    
#line 98 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_26 = 14;
                                                                    
#line 98 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_27 = 15;
                                                                    
#line 98 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_28 = 16;
                                                                    
#line 98 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_29 = 17;
                                                                    
#line 98 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_30 = 18;
                                                                    
#line 98 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_31 = 19;
                                                                    
#line 98 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_32 = 20;
                                                                    
#line 98 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_33 = 21;
                                                                    
#line 98 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_34 = 22;
                                                                    
#line 98 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 98 
                                                                    tmp_35 = 23;
                                                                    
#line 98 
                                                                    tmp_36 = tmp_35;
                                                                  }
                                                                  else 
                                                                    
#line 98 
                                                                    tmp_36 = 24;
                                                                  
#line 98 
                                                                  tmp_37 = tmp_36;
                                                                }
                                                                else 
                                                                  
#line 98 
                                                                  tmp_37 = 25;
                                                                
#line 98 
                                                                tmp_38 = tmp_37;
                                                              }
                                                              else 
#line 98 
                                                                   tmp_38 = 26;
                                                              
#line 98 
                                                              tmp_39 = tmp_38;
                                                            }
                                                            else 
#line 98 
                                                                 tmp_39 = 27;
                                                            
#line 98 
                                                            tmp_40 = tmp_39;
                                                          }
                                                          else 
#line 98 
                                                               tmp_40 = 28;
                                                          
#line 98 
                                                          tmp_41 = tmp_40;
                                                        }
                                                        else 
#line 98 
                                                             tmp_41 = 29;
                                                        
#line 98 
                                                        tmp_42 = tmp_41;
                                                      }
                                                      else 
#line 98 
                                                           tmp_42 = 30;
                                                      
#line 98 
                                                      tmp_43 = tmp_42;
                                                    }
                                                    else 
#line 98 
                                                         tmp_43 = 31;
                                                    
#line 98 
                                                    tmp_44 = tmp_43;
                                                  }
                                                  else 
#line 98 
                                                       tmp_44 = 32;
                                                  
#line 98 
                                                  tmp_45 = tmp_44;
                                                }
                                                else 
#line 98 
                                                     tmp_45 = 33;
                                                
#line 98 
                                                tmp_46 = tmp_45;
                                              }
                                              else 
#line 98 
                                                   tmp_46 = 34;
                                              
#line 98 
                                              tmp_47 = tmp_46;
                                            }
                                            else 
#line 98 
                                                 tmp_47 = 35;
                                            
#line 98 
                                            tmp_48 = tmp_47;
                                          }
                                          else 
#line 98 
                                               tmp_48 = 36;
                                          
#line 98 
                                          tmp_49 = tmp_48;
                                        }
                                        else 
#line 98 
                                             tmp_49 = 37;
                                        
#line 98 
                                        tmp_50 = tmp_49;
                                      }
                                      else 
#line 98 
                                           tmp_50 = 38;
                                      
#line 98 
                                      tmp_51 = tmp_50;
                                    }
                                    else 
#line 98 
                                         tmp_51 = 39;
                                    
#line 98 
                                    tmp_52 = tmp_51;
                                  }
                                  else 
#line 98 
                                       tmp_52 = 40;
                                  
#line 98 
                                  tmp_53 = tmp_52;
                                }
                                else 
#line 98 
                                     tmp_53 = 41;
                                
#line 98 
                                tmp_54 = tmp_53;
                              }
                              else 
#line 98 
                                   tmp_54 = 42;
                              
#line 98 
                              tmp_55 = tmp_54;
                            }
                            else 
#line 98 
                                 tmp_55 = 43;
                            
#line 98 
                            tmp_56 = tmp_55;
                          }
                          else 
#line 98 
                               tmp_56 = 44;
                          
#line 98 
                          tmp_57 = tmp_56;
                        }
                        else 
#line 98 
                             tmp_57 = 45;
                        
#line 98 
                        tmp_58 = tmp_57;
                      }
                      else 
#line 98 
                           tmp_58 = 46;
                      
#line 98 
                      tmp_59 = tmp_58;
                    }
                    else 
#line 98 
                         tmp_59 = 47;
                    
#line 98 
                    tmp_60 = tmp_59;
                  }
                  else 
#line 98 
                       tmp_60 = 48;
                  
#line 98 
                  tmp_61 = tmp_60;
                }
                else 
#line 98 
                     tmp_61 = 49;
                
#line 98 
                tmp_62 = tmp_61;
              }
              else 
#line 98 
                   tmp_62 = 50;
              
#line 98 
              tmp_63 = tmp_62;
            }
            else 
#line 98 
                 tmp_63 = 51;
            
#line 98 
            tmp_64 = tmp_63;
          }
          
#line 98 
          tmp_66 = tmp_64;
        }
        else {
          int tmp_65;
          
#line 98 
          tmp_65 = __ilog2_u32(trans_pcie->fw_mon_size + 4294967295U);
          
#line 98 
          tmp_66 = tmp_65 + -11;
        }
        
#line 98 
        tmp_67 = tmp_66;
      }
      else 
#line 98 
           tmp_67 = 0;
      
#line 98 
      tmp_68 = tmp_67;
    }
    else 
#line 98 
         tmp_68 = 52;
    
#line 98 
    tmp_70 = tmp_68;
  }
  else 
#line 98 
       tmp_70 = __get_order((unsigned long)trans_pcie->fw_mon_size);
  
#line 97 
  ;
  
#line 97 
  __free_pages(trans_pcie->fw_mon_page,(unsigned int)tmp_70);
  
#line 99 
  trans_pcie->fw_mon_page = (struct page *)0;
  
#line 100 
  trans_pcie->fw_mon_phys = 0ULL;
  
#line 101 
  trans_pcie->fw_mon_size = 0U;
  return_label: 
#line 102 
                return;
}


#line 149 
void __compiletime_assert_151(void);


#line 159 
void __compiletime_assert_162(void);


#line 104  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_pcie_alloc_fw_monitor(struct iwl_trans *trans, u8 max_power)
{
  dma_addr_t phys;
  u8 power;
  int tmp;
  int tmp_73;
  
#line 106 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 107 
  struct page *page = (struct page *)0;
  
#line 109 
  u32 size = 0U;
  
#line 112 
  if ((unsigned int)max_power == 0U) 
#line 114 
                                     max_power = (unsigned char)26U; else 
                                                                    
#line 116 
                                                                    max_power = (unsigned char)((unsigned int)max_power + 11U);
  {
    
#line 119 
    int __ret_warn_on = (unsigned int)max_power > 26U;
    
#line 119 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 119 
                                          warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",121,"External buffer size for monitor is too big %d, check the FW TLV\n",(int)max_power); else ;
    
#line 119 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 119 
  if ((long)tmp != 0L) 
#line 122 
                       goto return_label; else ;
  
#line 124 
  if (trans_pcie->fw_mon_page != (struct page *)0) {
    
#line 125 
    dma_sync_single_for_device(trans->dev,trans_pcie->fw_mon_phys,(unsigned long)trans_pcie->fw_mon_size,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 128 
    goto return_label;
  }
  else ;
  
#line 131 
  phys = 0ULL;
  
#line 132 
  power = max_power;
  
#line 132 
  goto ldv_54184;
  ldv_54183: 
#line 133 
  ;
  {
    int order;
    int tmp_71;
    
#line 135 
    size = (unsigned int)(1UL << (int)power);
    
#line 136 
    if (0 != 0) {
      int tmp_69;
      
#line 136 
      if (size != 0U) {
        int tmp_68;
        
#line 136 
        if (size > 4095U) {
          int tmp_67;
          
#line 136 
          if (0 != 0) {
            int tmp_65;
            
#line 136 
            if (size == 1U) {
              int tmp_0;
              
#line 136 
              tmp_0 = ____ilog2_NaN();
              
#line 136 
              tmp_65 = tmp_0 + -11;
            }
            else {
              int tmp_64;
              
#line 136 
              if (((unsigned long long)(size + 4294967295U) & 4611686018427387904ULL) == 0ULL) {
                int tmp_63;
                
#line 136 
                if (((unsigned long long)(size + 4294967295U) & 2305843009213693952ULL) == 0ULL) {
                  int tmp_62;
                  
#line 136 
                  if (((unsigned long long)(size + 4294967295U) & 1152921504606846976ULL) == 0ULL) {
                    int tmp_61;
                    
#line 136 
                    if (((unsigned long long)(size + 4294967295U) & 576460752303423488ULL) == 0ULL) {
                      int tmp_60;
                      
#line 136 
                      if (((unsigned long long)(size + 4294967295U) & 288230376151711744ULL) == 0ULL) {
                        int tmp_59;
                        
#line 136 
                        if (((unsigned long long)(size + 4294967295U) & 144115188075855872ULL) == 0ULL) {
                          int tmp_58;
                          
#line 136 
                          if (((unsigned long long)(size + 4294967295U) & 72057594037927936ULL) == 0ULL) {
                            int tmp_57;
                            
#line 136 
                            if (((unsigned long long)(size + 4294967295U) & 36028797018963968ULL) == 0ULL) {
                              int tmp_56;
                              
#line 136 
                              if (((unsigned long long)(size + 4294967295U) & 18014398509481984ULL) == 0ULL) {
                                int tmp_55;
                                
#line 136 
                                if (((unsigned long long)(size + 4294967295U) & 9007199254740992ULL) == 0ULL) {
                                  int tmp_54;
                                  
#line 136 
                                  if (((unsigned long long)(size + 4294967295U) & 4503599627370496ULL) == 0ULL) {
                                    int tmp_53;
                                    
#line 136 
                                    if (((unsigned long long)(size + 4294967295U) & 2251799813685248ULL) == 0ULL) {
                                      int tmp_52;
                                      
#line 136 
                                      if (((unsigned long long)(size + 4294967295U) & 1125899906842624ULL) == 0ULL) {
                                        int tmp_51;
                                        
#line 136 
                                        if (((unsigned long long)(size + 4294967295U) & 562949953421312ULL) == 0ULL) {
                                          int tmp_50;
                                          
#line 136 
                                          if (((unsigned long long)(size + 4294967295U) & 281474976710656ULL) == 0ULL) {
                                            int tmp_49;
                                            
#line 136 
                                            if (((unsigned long long)(size + 4294967295U) & 140737488355328ULL) == 0ULL) {
                                              int tmp_48;
                                              
#line 136 
                                              if (((unsigned long long)(size + 4294967295U) & 70368744177664ULL) == 0ULL) {
                                                int tmp_47;
                                                
#line 136 
                                                if (((unsigned long long)(size + 4294967295U) & 35184372088832ULL) == 0ULL) {
                                                  int tmp_46;
                                                  
#line 136 
                                                  if (((unsigned long long)(size + 4294967295U) & 17592186044416ULL) == 0ULL) {
                                                    int tmp_45;
                                                    
#line 136 
                                                    if (((unsigned long long)(size + 4294967295U) & 8796093022208ULL) == 0ULL) {
                                                      int tmp_44;
                                                      
#line 136 
                                                      if (((unsigned long long)(size + 4294967295U) & 4398046511104ULL) == 0ULL) {
                                                        int tmp_43;
                                                        
#line 136 
                                                        if (((unsigned long long)(size + 4294967295U) & 2199023255552ULL) == 0ULL) {
                                                          int tmp_42;
                                                          
#line 136 
                                                          if (((unsigned long long)(size + 4294967295U) & 1099511627776ULL) == 0ULL) {
                                                            int tmp_41;
                                                            
#line 136 
                                                            if (((unsigned long long)(size + 4294967295U) & 549755813888ULL) == 0ULL) {
                                                              int tmp_40;
                                                              
#line 136 
                                                              if (((unsigned long long)(size + 4294967295U) & 274877906944ULL) == 0ULL) {
                                                                int tmp_39;
                                                                
#line 136 
                                                                if (((unsigned long long)(size + 4294967295U) & 137438953472ULL) == 0ULL) {
                                                                  int tmp_38;
                                                                  
#line 136 
                                                                  if (
                                                                    ((unsigned long long)(size + 4294967295U) & 68719476736ULL) == 0ULL) {
                                                                    int tmp_37;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 34359738368ULL) == 0ULL) {
                                                                    int tmp_36;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 17179869184ULL) == 0ULL) {
                                                                    int tmp_35;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8589934592ULL) == 0ULL) {
                                                                    int tmp_34;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4294967296ULL) == 0ULL) {
                                                                    int tmp_33;
                                                                    
#line 136 
                                                                    if (
                                                                    size + 4294967295U >= (u32)0) {
                                                                    int tmp_32;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1073741824ULL) == 0ULL) {
                                                                    int tmp_31;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 536870912ULL) == 0ULL) {
                                                                    int tmp_30;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 268435456ULL) == 0ULL) {
                                                                    int tmp_29;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 134217728ULL) == 0ULL) {
                                                                    int tmp_28;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 67108864ULL) == 0ULL) {
                                                                    int tmp_27;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 33554432ULL) == 0ULL) {
                                                                    int tmp_26;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16777216ULL) == 0ULL) {
                                                                    int tmp_25;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8388608ULL) == 0ULL) {
                                                                    int tmp_24;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4194304ULL) == 0ULL) {
                                                                    int tmp_23;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2097152ULL) == 0ULL) {
                                                                    int tmp_22;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1048576ULL) == 0ULL) {
                                                                    int tmp_21;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 524288ULL) == 0ULL) {
                                                                    int tmp_20;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 262144ULL) == 0ULL) {
                                                                    int tmp_19;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 131072ULL) == 0ULL) {
                                                                    int tmp_18;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 65536ULL) == 0ULL) {
                                                                    int tmp_17;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 32768ULL) == 0ULL) {
                                                                    int tmp_16;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16384ULL) == 0ULL) {
                                                                    int tmp_15;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8192ULL) == 0ULL) {
                                                                    int tmp_14;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4096ULL) == 0ULL) {
                                                                    int tmp_13;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2048ULL) == 0ULL) {
                                                                    int tmp_12;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1024ULL) == 0ULL) {
                                                                    int tmp_11;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 512ULL) == 0ULL) {
                                                                    int tmp_10;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 256ULL) == 0ULL) {
                                                                    int tmp_9;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 128ULL) == 0ULL) {
                                                                    int tmp_8;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 64ULL) == 0ULL) {
                                                                    int tmp_7;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 32ULL) == 0ULL) {
                                                                    int tmp_6;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 16ULL) == 0ULL) {
                                                                    int tmp_5;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 8ULL) == 0ULL) {
                                                                    int tmp_4;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 4ULL) == 0ULL) {
                                                                    int tmp_3;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 2ULL) == 0ULL) {
                                                                    int tmp_2;
                                                                    
#line 136 
                                                                    if (
                                                                    ((unsigned long long)(size + 4294967295U) & 1ULL) == 0ULL) {
                                                                    int tmp_1;
                                                                    
#line 136 
                                                                    tmp_1 = ____ilog2_NaN();
                                                                    
#line 136 
                                                                    tmp_2 = tmp_1 + -11;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_2 = -11;
                                                                    
#line 136 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_3 = -10;
                                                                    
#line 136 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_4 = -9;
                                                                    
#line 136 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_5 = -8;
                                                                    
#line 136 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_6 = -7;
                                                                    
#line 136 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_7 = -6;
                                                                    
#line 136 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_8 = -5;
                                                                    
#line 136 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_9 = -4;
                                                                    
#line 136 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_10 = -3;
                                                                    
#line 136 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_11 = -2;
                                                                    
#line 136 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_12 = -1;
                                                                    
#line 136 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_13 = 0;
                                                                    
#line 136 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_14 = 1;
                                                                    
#line 136 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_15 = 2;
                                                                    
#line 136 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_16 = 3;
                                                                    
#line 136 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_17 = 4;
                                                                    
#line 136 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_18 = 5;
                                                                    
#line 136 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_19 = 6;
                                                                    
#line 136 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_20 = 7;
                                                                    
#line 136 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_21 = 8;
                                                                    
#line 136 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_22 = 9;
                                                                    
#line 136 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_23 = 10;
                                                                    
#line 136 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_24 = 11;
                                                                    
#line 136 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_25 = 12;
                                                                    
#line 136 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_26 = 13;
                                                                    
#line 136 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_27 = 14;
                                                                    
#line 136 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_28 = 15;
                                                                    
#line 136 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_29 = 16;
                                                                    
#line 136 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_30 = 17;
                                                                    
#line 136 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_31 = 18;
                                                                    
#line 136 
                                                                    tmp_32 = tmp_31;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_32 = 19;
                                                                    
#line 136 
                                                                    tmp_33 = tmp_32;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_33 = 20;
                                                                    
#line 136 
                                                                    tmp_34 = tmp_33;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_34 = 21;
                                                                    
#line 136 
                                                                    tmp_35 = tmp_34;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_35 = 22;
                                                                    
#line 136 
                                                                    tmp_36 = tmp_35;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_36 = 23;
                                                                    
#line 136 
                                                                    tmp_37 = tmp_36;
                                                                    }
                                                                    else 
                                                                    
#line 136 
                                                                    tmp_37 = 24;
                                                                    
#line 136 
                                                                    tmp_38 = tmp_37;
                                                                  }
                                                                  else 
                                                                    
#line 136 
                                                                    tmp_38 = 25;
                                                                  
#line 136 
                                                                  tmp_39 = tmp_38;
                                                                }
                                                                else 
                                                                  
#line 136 
                                                                  tmp_39 = 26;
                                                                
#line 136 
                                                                tmp_40 = tmp_39;
                                                              }
                                                              else 
#line 136 
                                                                   tmp_40 = 27;
                                                              
#line 136 
                                                              tmp_41 = tmp_40;
                                                            }
                                                            else 
#line 136 
                                                                 tmp_41 = 28;
                                                            
#line 136 
                                                            tmp_42 = tmp_41;
                                                          }
                                                          else 
#line 136 
                                                               tmp_42 = 29;
                                                          
#line 136 
                                                          tmp_43 = tmp_42;
                                                        }
                                                        else 
#line 136 
                                                             tmp_43 = 30;
                                                        
#line 136 
                                                        tmp_44 = tmp_43;
                                                      }
                                                      else 
#line 136 
                                                           tmp_44 = 31;
                                                      
#line 136 
                                                      tmp_45 = tmp_44;
                                                    }
                                                    else 
#line 136 
                                                         tmp_45 = 32;
                                                    
#line 136 
                                                    tmp_46 = tmp_45;
                                                  }
                                                  else 
#line 136 
                                                       tmp_46 = 33;
                                                  
#line 136 
                                                  tmp_47 = tmp_46;
                                                }
                                                else 
#line 136 
                                                     tmp_47 = 34;
                                                
#line 136 
                                                tmp_48 = tmp_47;
                                              }
                                              else 
#line 136 
                                                   tmp_48 = 35;
                                              
#line 136 
                                              tmp_49 = tmp_48;
                                            }
                                            else 
#line 136 
                                                 tmp_49 = 36;
                                            
#line 136 
                                            tmp_50 = tmp_49;
                                          }
                                          else 
#line 136 
                                               tmp_50 = 37;
                                          
#line 136 
                                          tmp_51 = tmp_50;
                                        }
                                        else 
#line 136 
                                             tmp_51 = 38;
                                        
#line 136 
                                        tmp_52 = tmp_51;
                                      }
                                      else 
#line 136 
                                           tmp_52 = 39;
                                      
#line 136 
                                      tmp_53 = tmp_52;
                                    }
                                    else 
#line 136 
                                         tmp_53 = 40;
                                    
#line 136 
                                    tmp_54 = tmp_53;
                                  }
                                  else 
#line 136 
                                       tmp_54 = 41;
                                  
#line 136 
                                  tmp_55 = tmp_54;
                                }
                                else 
#line 136 
                                     tmp_55 = 42;
                                
#line 136 
                                tmp_56 = tmp_55;
                              }
                              else 
#line 136 
                                   tmp_56 = 43;
                              
#line 136 
                              tmp_57 = tmp_56;
                            }
                            else 
#line 136 
                                 tmp_57 = 44;
                            
#line 136 
                            tmp_58 = tmp_57;
                          }
                          else 
#line 136 
                               tmp_58 = 45;
                          
#line 136 
                          tmp_59 = tmp_58;
                        }
                        else 
#line 136 
                             tmp_59 = 46;
                        
#line 136 
                        tmp_60 = tmp_59;
                      }
                      else 
#line 136 
                           tmp_60 = 47;
                      
#line 136 
                      tmp_61 = tmp_60;
                    }
                    else 
#line 136 
                         tmp_61 = 48;
                    
#line 136 
                    tmp_62 = tmp_61;
                  }
                  else 
#line 136 
                       tmp_62 = 49;
                  
#line 136 
                  tmp_63 = tmp_62;
                }
                else 
#line 136 
                     tmp_63 = 50;
                
#line 136 
                tmp_64 = tmp_63;
              }
              else 
#line 136 
                   tmp_64 = 51;
              
#line 136 
              tmp_65 = tmp_64;
            }
            
#line 136 
            tmp_67 = tmp_65;
          }
          else {
            int tmp_66;
            
#line 136 
            tmp_66 = __ilog2_u32(size + 4294967295U);
            
#line 136 
            tmp_67 = tmp_66 + -11;
          }
          
#line 136 
          tmp_68 = tmp_67;
        }
        else 
#line 136 
             tmp_68 = 0;
        
#line 136 
        tmp_69 = tmp_68;
      }
      else 
#line 136 
           tmp_69 = 52;
      
#line 136 
      order = tmp_69;
    }
    else 
#line 136 
         order = __get_order((unsigned long)size);
    
#line 137 
    page = alloc_pages(49664U,(unsigned int)order);
    
#line 139 
    if (page == (struct page *)0) 
#line 140 
                                  goto ldv_54177; else ;
    
#line 142 
    phys = dma_map_page(trans->dev,page,0UL,4096UL << order,(enum dma_data_direction)DMA_FROM_DEVICE);
    
#line 144 
    tmp_71 = dma_mapping_error(trans->dev,phys);
    
#line 144 
    if (tmp_71 != 0) {
      
#line 145 
      __free_pages(page,(unsigned int)order);
      
#line 146 
      page = (struct page *)0;
      
#line 147 
      goto ldv_54177;
    }
    else ;
    {
      
#line 149 
      bool __cond = (_Bool)((int)*("Allocated 0x%08x bytes (order %d) for firmware monitor.\n" + 55UL) != 10);
      
#line 149 
      if ((int)__cond != 0) 
#line 149 
                            __compiletime_assert_151(); else ;
    }
    
#line 149 
    __iwl_info(trans->dev,"Allocated 0x%08x bytes (order %d) for firmware monitor.\n",size,order);
    
#line 152 
    goto ldv_54182;
  }
  ldv_54177: 
#line 154 
  ;
  
#line 132 
  power = (u8)((int)power - 1);
  ldv_54184: 
#line 133 
  ;
  
#line 132 
  if ((unsigned int)power > 10U) 
#line 134 
                                 goto ldv_54183; else 
#line 137 
                                                      goto ldv_54182;
  ldv_54182: 
#line 138 
  ;
  {
    bool __warned;
    
#line 155 
    int __ret_warn_once = page == (struct page *)0;
    
#line 155 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp_72;
      {
        
#line 155 
        int __ret_warn_on_0 = ! __warned;
        
#line 155 
        if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 155 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",155); else ;
        
#line 155 
        tmp_72 = (long)(__ret_warn_on_0 != 0);
      }
      
#line 155 
      if ((long)tmp_72 != 0L) 
#line 155 
                              __warned = (_Bool)1; else ;
    }
    else ;
    
#line 155 
    tmp_73 = (long)(__ret_warn_once != 0);
  }
  
#line 155 
  if ((long)tmp_73 != 0L) 
#line 156 
                          goto return_label; else ;
  
#line 158 
  if ((int)power != (int)max_power) {
    {
      
#line 159 
      bool __cond_0 = (_Bool)((int)*("Sorry - debug buffer is only %luK while you requested %luK\n" + 58UL) != 10);
      
#line 159 
      if ((int)__cond_0 != 0) 
#line 159 
                              __compiletime_assert_162(); else ;
    }
    
#line 159 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Sorry - debug buffer is only %luK while you requested %luK\n",1UL << ((int)power + -10),1UL << ((int)max_power + -10));
  }
  else ;
  
#line 164 
  trans_pcie->fw_mon_page = page;
  
#line 165 
  trans_pcie->fw_mon_phys = phys;
  
#line 166 
  trans_pcie->fw_mon_size = size;
  return_label: 
#line 167 
                return;
}


#line 169  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static u32 iwl_trans_pcie_read_shr(struct iwl_trans *trans, u32 reg)
{
  u32 tmp;
  
#line 171 
  iwl_write32_2(trans,236U,(reg & 65535U) | 536870912U);
  
#line 173 
  tmp = iwl_read32_2(trans,244U);
  
#line 173 
  return tmp;
}


#line 176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_write_shr(struct iwl_trans *trans, u32 reg, u32 val)
{
  
#line 178 
  iwl_write32_2(trans,244U,val);
  
#line 179 
  iwl_write32_2(trans,236U,(reg & 65535U) | 805306368U);
  
#line 181 
  return;
}


#line 183  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_pcie_set_pwr(struct iwl_trans *trans, bool vaux)
{
  
#line 185 
  if ((int)(trans->cfg)->apmg_not_supported != 0) 
#line 186 
                                                  goto return_label; else ;
  
#line 188 
  if ((int)vaux != 0) {
    bool tmp_0;
    struct pci_dev *tmp;
    {
      
#line 188 
      struct device const *__mptr = (struct device const *)trans->dev;
      
#line 188 
      tmp = (struct pci_dev *)__mptr + 18446744073709551464U;
    }
    
#line 188 
    tmp_0 = pci_pme_capable(tmp,4);
    
#line 188 
    if ((int)tmp_0 != 0) 
#line 189 
                         iwl_set_bits_mask_prph(trans,12300U,33554432U,4244635647U); else 
                                                                    
#line 193 
                                                                    iwl_set_bits_mask_prph(trans,12300U,0U,4244635647U);
  }
  else 
#line 193 
       iwl_set_bits_mask_prph(trans,12300U,0U,4244635647U);
  return_label: 
#line 194 
                return;
}


#line 201  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_pcie_apm_config(struct iwl_trans *trans)
{
  u16 lctl;
  u16 cap;
  char *tmp;
  char *tmp_0;
  
#line 203 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 215 
  pcie_capability_read_word(trans_pcie->pci_dev,16,& lctl);
  
#line 216 
  if (((int)lctl & 2) != 0) 
#line 217 
                            iwl_set_bit(trans,60U,2U); else 
#line 219 
                                                            iwl_clear_bit(trans,60U,2U);
  
#line 220 
  trans->pm_support = (_Bool)(((int)lctl & 1) == 0);
  
#line 222 
  pcie_capability_read_word(trans_pcie->pci_dev,40,& cap);
  
#line 223 
  trans->ltr_enabled = (_Bool)(((int)cap & 1024) != 0);
  
#line 224 
  if ((int)trans->ltr_enabled != 0) 
#line 224 
                                    tmp = (char *)"En"; else 
#line 224 
                                                             tmp = (char *)"Dis";
  
#line 224 
  if (((int)lctl & 2) != 0) 
#line 224 
                            tmp_0 = (char *)"En"; else 
#line 224 
                                                       tmp_0 = (char *)"Dis";
  
#line 224 
  ;
  
#line 224 
  _dev_info((struct device const *)trans->dev,"L1 %sabled - LTR %sabled\n",tmp_0,tmp);
  
#line 225 
  return;
}


#line 237 
void __compiletime_assert_237(void);


#line 288 
void __compiletime_assert_288(void);


#line 234  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_apm_init(struct iwl_trans *trans)
{
  
#line 236 
  int ret = 0;
  {
    
#line 237 
    bool __cond = (_Bool)((int)*("Init card\'s basic functions\n" + 27UL) != 10);
    
#line 237 
    if ((int)__cond != 0) 
#line 237 
                          __compiletime_assert_237(); else ;
  }
  
#line 237 
  __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_apm_init","Init card\'s basic functions\n");
  
#line 245 
  if ((trans->cfg)->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) 
    
#line 246 
    iwl_set_bit(trans,256U,536870912U); else ;
  
#line 253 
  iwl_set_bit(trans,256U,8388608U);
  
#line 257 
  iwl_set_bit(trans,576U,4294901760U);
  
#line 263 
  iwl_set_bit(trans,0U,524288U);
  
#line 266 
  iwl_pcie_apm_config(trans);
  
#line 269 
  if (((trans->cfg)->base_params)->pll_cfg_val != 0U) 
#line 270 
                                                      iwl_set_bit(trans,524U,((trans->cfg)->base_params)->pll_cfg_val); else ;
  
#line 277 
  iwl_set_bit(trans,36U,4U);
  
#line 284 
  ret = iwl_poll_bit(trans,36U,1U,1U,25000);
  
#line 287 
  if (ret < 0) {
    {
      
#line 288 
      bool __cond_0 = (_Bool)((int)*("Failed to init the card\n" + 23UL) != 10);
      
#line 288 
      if ((int)__cond_0 != 0) 
#line 288 
                              __compiletime_assert_288(); else ;
    }
    
#line 288 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_apm_init","Failed to init the card\n");
    
#line 289 
    goto out;
  }
  else ;
  
#line 292 
  if ((int)(trans->cfg)->host_interrupt_operation_mode != 0) {
    
#line 307 
    iwl_read_prph(trans,10502248U);
    
#line 308 
    iwl_read_prph(trans,10502248U);
    
#line 309 
    iwl_set_bits_prph(trans,10502248U,8U);
    
#line 310 
    iwl_read_prph(trans,10502248U);
    
#line 311 
    iwl_read_prph(trans,10502248U);
  }
  else ;
  
#line 321 
  if (! (trans->cfg)->apmg_not_supported) {
    
#line 322 
    iwl_write_prph(trans,12292U,512U);
    
#line 324 
    __const_udelay(85900UL);
    
#line 327 
    iwl_set_bits_prph(trans,12304U,2048U);
    
#line 331 
    iwl_write_prph(trans,12316U,268435456U);
  }
  else ;
  
#line 335 
  set_bit(1L,(unsigned long volatile *)(& trans->status));
  out: 
#line 337 
  ;
  
#line 338 
  return ret;
}


#line 379 
void __compiletime_assert_379(void);


#line 348  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_pcie_apm_lp_xtal_enable(struct iwl_trans *trans)
{
  int ret;
  u32 apmg_gp1_reg;
  u32 apmg_xtal_cfg_reg;
  u32 dl_cfg_reg;
  int tmp;
  
#line 356 
  __iwl_trans_pcie_set_bit(trans,36U,1024U);
  
#line 360 
  iwl_set_bit(trans,32U,128U);
  
#line 362 
  __const_udelay(42950UL);
  
#line 368 
  iwl_set_bit(trans,36U,4U);
  
#line 374 
  ret = iwl_poll_bit(trans,36U,1U,1U,25000);
  {
    
#line 378 
    int __ret_warn_on = ret < 0;
    
#line 378 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 378 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",378); else ;
    
#line 378 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 378 
  if ((long)tmp != 0L) {
    {
      
#line 379 
      bool __cond = (_Bool)((int)*("Access time out - failed to enable LP XTAL\n" + 42UL) != 10);
      
#line 379 
      if ((int)__cond != 0) 
#line 379 
                            __compiletime_assert_379(); else ;
    }
    
#line 379 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Access time out - failed to enable LP XTAL\n");
    
#line 381 
    __iwl_trans_pcie_clear_bit(trans,36U,1024U);
    
#line 383 
    goto return_label;
  }
  else ;
  
#line 390 
  iwl_clear_bits_prph(trans,12304U,512U);
  
#line 397 
  apmg_xtal_cfg_reg = iwl_trans_pcie_read_shr(trans,448U);
  
#line 399 
  iwl_trans_pcie_write_shr(trans,448U,apmg_xtal_cfg_reg | 2147483648U);
  
#line 407 
  iwl_set_bit(trans,32U,128U);
  
#line 409 
  __const_udelay(42950UL);
  
#line 412 
  apmg_gp1_reg = iwl_trans_pcie_read_shr(trans,476U);
  
#line 413 
  iwl_trans_pcie_write_shr(trans,476U,apmg_gp1_reg | 2147483652U);
  
#line 418 
  dl_cfg_reg = iwl_trans_pcie_read_shr(trans,452U);
  
#line 419 
  iwl_trans_pcie_write_shr(trans,452U,dl_cfg_reg & 4294967039U);
  
#line 426 
  iwl_set_bit(trans,0U,1073741824U);
  
#line 433 
  iwl_clear_bit(trans,36U,4U);
  
#line 437 
  __iwl_trans_pcie_set_bit(trans,532U,16U);
  
#line 441 
  __iwl_trans_pcie_clear_bit(trans,36U,1024U);
  
#line 443 
  __const_udelay(42950UL);
  
#line 446 
  iwl_trans_pcie_write_shr(trans,448U,apmg_xtal_cfg_reg & 2147483647U);
  return_label: 
#line 448 
                return;
}


#line 451  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_apm_stop_master(struct iwl_trans *trans)
{
  
#line 453 
  int ret = 0;
  
#line 456 
  iwl_set_bit(trans,32U,512U);
  
#line 458 
  ret = iwl_poll_bit(trans,32U,256U,256U,100);
  
#line 461 
  if (ret < 0) {
    {
      
#line 462 
      bool __cond = (_Bool)((int)*("Master Disable Timed Out, 100 usec\n" + 34UL) != 10);
      
#line 462 
      if ((int)__cond != 0) 
#line 462 
                            __compiletime_assert_462(); else ;
    }
    
#line 462 
    __iwl_warn(trans->dev,"Master Disable Timed Out, 100 usec\n");
  }
  else ;
  {
    
#line 464 
    bool __cond_0 = (_Bool)((int)*("stop master\n" + 11UL) != 10);
    
#line 464 
    if ((int)__cond_0 != 0) 
#line 464 
                            __compiletime_assert_464(); else ;
  }
  
#line 464 
  __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_apm_stop_master","stop master\n");
  
#line 466 
  return ret;
}


#line 471 
void __compiletime_assert_471(void);


#line 469  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_pcie_apm_stop(struct iwl_trans *trans, bool op_mode_leave)
{
  {
    
#line 471 
    bool __cond = (_Bool)((int)*("Stop card, put in low power state\n" + 33UL) != 10);
    
#line 471 
    if ((int)__cond != 0) 
#line 471 
                          __compiletime_assert_471(); else ;
  }
  
#line 471 
  __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_apm_stop","Stop card, put in low power state\n");
  
#line 473 
  if ((int)op_mode_leave != 0) {
    int tmp;
    
#line 474 
    tmp = constant_test_bit(1L,(unsigned long const volatile *)(& trans->status));
    
#line 474 
    if (tmp == 0) 
#line 475 
                  iwl_pcie_apm_init(trans); else ;
    
#line 478 
    if ((trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_7000) 
      
#line 479 
      iwl_set_bits_prph(trans,12304U,16384U);
    else 
      
#line 481 
      if ((trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) {
        
#line 482 
        iwl_set_bit(trans,592U,2147483648U);
        
#line 484 
        iwl_set_bit(trans,0U,402653184U);
        
#line 487 
        if (1) 
#line 487 
               __const_udelay(4295000UL);
        else {
          
#line 487 
          unsigned long __ms = 1UL;
          {
            unsigned long tmp_0;
            
#line 487 
            goto ldv_54266;
            ldv_54265: 
#line 488 
            ;
            
#line 487 
            __const_udelay(4295000UL);
            ldv_54266: 
#line 489 
            ;
            
#line 487 
            tmp_0 = __ms;
            
#line 487 
            __ms -= 1UL;
            
#line 487 
            ;
            
#line 487 
            if (tmp_0 != 0UL) 
#line 489 
                              goto ldv_54265; else 
#line 492 
                                                   goto ldv_54267;
            ldv_54267: 
#line 493 
            ;
          }
        }
        
#line 488 
        iwl_clear_bit(trans,592U,2147483648U);
      }
      else ;
    
#line 491 
    if (1) 
#line 491 
           __const_udelay(21475000UL);
    else {
      
#line 491 
      unsigned long __ms_0 = 5UL;
      {
        unsigned long tmp_1;
        
#line 491 
        goto ldv_54270;
        ldv_54269: 
#line 492 
        ;
        
#line 491 
        __const_udelay(4295000UL);
        ldv_54270: 
#line 493 
        ;
        
#line 491 
        tmp_1 = __ms_0;
        
#line 491 
        __ms_0 -= 1UL;
        
#line 491 
        ;
        
#line 491 
        if (tmp_1 != 0UL) 
#line 493 
                          goto ldv_54269; else 
#line 496 
                                               goto ldv_54271;
        ldv_54271: 
#line 497 
        ;
      }
    }
  }
  else ;
  
#line 494 
  set_bit(1L,(unsigned long volatile *)(& trans->status));
  
#line 497 
  iwl_pcie_apm_stop_master(trans);
  
#line 499 
  if ((int)(trans->cfg)->lp_xtal_workaround != 0) {
    
#line 500 
    iwl_pcie_apm_lp_xtal_enable(trans);
    
#line 501 
    goto return_label;
  }
  else ;
  
#line 505 
  iwl_set_bit(trans,32U,128U);
  
#line 507 
  __const_udelay(42950UL);
  
#line 513 
  iwl_clear_bit(trans,36U,4U);
  return_label: 
#line 514 
                return;
}


#line 541 
void __compiletime_assert_541(void);


#line 517  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_nic_init(struct iwl_trans *trans)
{
  int __retres;
  int tmp;
  
#line 519 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 522 
  ldv_spin_lock_73_0(& trans_pcie->irq_lock);
  
#line 523 
  iwl_pcie_apm_init(trans);
  
#line 525 
  ldv_spin_unlock_74_0(& trans_pcie->irq_lock);
  
#line 527 
  iwl_pcie_set_pwr(trans,(_Bool)0);
  
#line 529 
  iwl_op_mode_nic_config(trans->op_mode);
  
#line 532 
  iwl_pcie_rx_init(trans);
  
#line 535 
  tmp = iwl_pcie_tx_init(trans);
  
#line 535 
  if (tmp != 0) {
    
#line 536 
    __retres = -12;
    
#line 536 
    goto return_label;
  }
  else ;
  
#line 538 
  if ((int)((trans->cfg)->base_params)->shadow_reg_enable != 0) {
    
#line 540 
    iwl_set_bit(trans,168U,2148532223U);
    {
      
#line 541 
      bool __cond = (_Bool)((int)*("Enabling shadow registers in device\n" + 35UL) != 10);
      
#line 541 
      if ((int)__cond != 0) 
#line 541 
                            __compiletime_assert_541(); else ;
    }
    
#line 541 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_nic_init","Enabling shadow registers in device\n");
  }
  else ;
  
#line 544 
  __retres = 0;
  return_label: 
#line 544 
                return __retres;
}


#line 566 
void __compiletime_assert_566(void);


#line 550  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_set_hw_ready(struct iwl_trans *trans)
{
  int ret;
  char *tmp;
  
#line 554 
  iwl_set_bit(trans,0U,4194304U);
  
#line 558 
  ret = iwl_poll_bit(trans,0U,4194304U,4194304U,50);
  
#line 563 
  if (ret >= 0) 
#line 564 
                iwl_set_bit(trans,136U,32U); else ;
  {
    
#line 566 
    bool __cond = (_Bool)((int)*("hardware%s ready\n" + 16UL) != 10);
    
#line 566 
    if ((int)__cond != 0) 
#line 566 
                          __compiletime_assert_566(); else ;
  }
  
#line 566 
  if (ret < 0) 
#line 566 
               tmp = (char *)" not"; else 
#line 566 
                                          tmp = (char *)"";
  
#line 566 
  ;
  
#line 566 
  __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_set_hw_ready","hardware%s ready\n",tmp);
  
#line 567 
  return ret;
}


#line 577 
void __compiletime_assert_577(void);


#line 606 
void __compiletime_assert_606(void);


#line 571  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_prepare_card_hw(struct iwl_trans *trans)
{
  int __retres;
  int ret;
  int iter;
  
#line 574 
  int t = 0;
  {
    
#line 577 
    bool __cond = (_Bool)((int)*("iwl_trans_prepare_card_hw enter\n" + 31UL) != 10);
    
#line 577 
    if ((int)__cond != 0) 
#line 577 
                          __compiletime_assert_577(); else ;
  }
  
#line 577 
  __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_prepare_card_hw","iwl_trans_prepare_card_hw enter\n");
  
#line 579 
  ret = iwl_pcie_set_hw_ready(trans);
  
#line 581 
  if (ret >= 0) {
    
#line 582 
    __retres = 0;
    
#line 582 
    goto return_label;
  }
  else ;
  
#line 584 
  iwl_set_bit(trans,592U,2147483648U);
  
#line 586 
  msleep(1U);
  
#line 588 
  iter = 0;
  
#line 588 
  goto ldv_54305;
  ldv_54304: 
#line 589 
  ;
  
#line 590 
  iwl_set_bit(trans,0U,134217728U);
  ldv_54302: 
#line 591 
  ;
  
#line 594 
  ret = iwl_pcie_set_hw_ready(trans);
  
#line 595 
  if (ret >= 0) {
    
#line 596 
    ret = 0;
    
#line 597 
    goto out;
  }
  else ;
  
#line 600 
  usleep_range(200UL,1000UL);
  
#line 601 
  t += 200;
  
#line 602 
  if (t <= 149999) 
#line 604 
                   goto ldv_54302; else 
#line 607 
                                        goto ldv_54303;
  ldv_54303: 
#line 608 
  ;
  
#line 603 
  msleep(25U);
  
#line 588 
  iter += 1;
  ldv_54305: 
#line 589 
  ;
  
#line 588 
  if (iter <= 9) 
#line 590 
                 goto ldv_54304; else 
#line 593 
                                      goto ldv_54306;
  ldv_54306: 
#line 594 
  ;
  {
    
#line 606 
    bool __cond_0 = (_Bool)((int)*("Couldn\'t prepare the card\n" + 25UL) != 10);
    
#line 606 
    if ((int)__cond_0 != 0) 
#line 606 
                            __compiletime_assert_606(); else ;
  }
  
#line 606 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Couldn\'t prepare the card\n");
  out: 
#line 608 
  ;
  
#line 609 
  iwl_clear_bit(trans,592U,2147483648U);
  
#line 612 
  __retres = ret;
  return_label: 
#line 612 
                return __retres;
}


#line 658 
void __compiletime_assert_658(void);


#line 618  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_load_firmware_chunk(struct iwl_trans *trans, u32 dst_addr, dma_addr_t phy_addr, u32 byte_cnt)
{
  int __retres;
  int ret;
  u8 tmp;
  long tmp_4;
  
#line 621 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 624 
  trans_pcie->ucode_write_complete = (_Bool)0;
  
#line 626 
  iwl_write_direct32(trans,7712U,0U);
  
#line 630 
  iwl_write_direct32(trans,6600U,dst_addr);
  
#line 634 
  iwl_write_direct32(trans,6472U,(unsigned int)phy_addr);
  
#line 640 
  tmp = iwl_get_dma_hi_addr(phy_addr);
  
#line 638 
  ;
  
#line 638 
  ;
  
#line 638 
  iwl_write_direct32(trans,6476U,(unsigned int)((int)tmp << 28) | byte_cnt);
  
#line 643 
  iwl_write_direct32(trans,7720U,1052675U);
  
#line 649 
  iwl_write_direct32(trans,7712U,2148532224U);
  {
    
#line 655 
    long __ret = 1250L;
    
#line 655 
    __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",656,0);
    {
      int tmp_3;
      {
        
#line 655 
        bool __cond_0 = trans_pcie->ucode_write_complete;
        
#line 655 
        if ((int)__cond_0 != 0 && __ret == 0L) 
#line 655 
                                               __ret = 1L; else ;
        
#line 655 
        tmp_3 = ((int)__cond_0 != 0 || __ret == 0L) != 0;
      }
      
#line 655 
      if (tmp_3 == 0) {
        long tmp_2;
        {
          wait_queue_t __wait;
          
#line 655 
          long __ret_0 = 1250L;
          
#line 655 
          INIT_LIST_HEAD(& __wait.task_list);
          
#line 655 
          __wait.flags = 0U;
          ldv_54329: 
#line 658 
          ;
          {
            int tmp_1;
            
#line 655 
            long __int = prepare_to_wait_event(& trans_pcie->ucode_write_waitq,& __wait,2);
            {
              
#line 655 
              bool __cond = trans_pcie->ucode_write_complete;
              
#line 655 
              if ((int)__cond != 0 && __ret_0 == 0L) 
#line 655 
                                                     __ret_0 = 1L; else ;
              
#line 655 
              tmp_1 = ((int)__cond != 0 || __ret_0 == 0L) != 0;
            }
            
#line 655 
            if (tmp_1 != 0) 
#line 655 
                            goto ldv_54328; else ;
            
#line 655 
            __ret_0 = schedule_timeout(__ret_0);
          }
          
#line 655 
          goto ldv_54329;
          ldv_54328: 
#line 656 
          ;
          
#line 655 
          finish_wait(& trans_pcie->ucode_write_waitq,& __wait);
          __out_0: 
#line 655 
          ;
          
#line 655 
          tmp_2 = __ret_0;
        }
        
#line 655 
        __ret = tmp_2;
      }
      else ;
    }
    
#line 655 
    tmp_4 = __ret;
  }
  
#line 655 
  ret = (int)tmp_4;
  
#line 657 
  if (ret == 0) {
    {
      
#line 658 
      bool __cond_1 = (_Bool)((int)*("Failed to load firmware chunk!\n" + 30UL) != 10);
      
#line 658 
      if ((int)__cond_1 != 0) 
#line 658 
                              __compiletime_assert_658(); else ;
    }
    
#line 658 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Failed to load firmware chunk!\n");
    
#line 659 
    __retres = -110;
    
#line 659 
    goto return_label;
  }
  else ;
  
#line 662 
  __retres = 0;
  return_label: 
#line 662 
                return __retres;
}


#line 673 
void __compiletime_assert_674(void);


#line 679 
void __compiletime_assert_679(void);


#line 711 
void __compiletime_assert_713(void);


#line 665  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_load_section(struct iwl_trans *trans, u8 section_num, struct fw_desc const *section)
{
  int __retres;
  u8 *v_addr;
  dma_addr_t p_addr;
  u32 offset;
  u32 tmp_0;
  {
    u32 tmp;
    
#line 670 
    u32 __min1 = 131072U;
    
#line 670 
    u32 __min2 = section->len;
    
#line 670 
    if (__min1 < __min2) 
#line 670 
                         tmp = __min1; else 
#line 670 
                                            tmp = __min2;
    
#line 670 
    tmp_0 = tmp;
  }
  
#line 670 
  u32 chunk_sz = tmp_0;
  
#line 671 
  int ret = 0;
  {
    
#line 673 
    bool __cond = (_Bool)((int)*("[%d] uCode section being loaded...\n" + 34UL) != 10);
    
#line 673 
    if ((int)__cond != 0) 
#line 673 
                          __compiletime_assert_674(); else ;
  }
  
#line 673 
  __iwl_dbg(trans->dev,65536U,(_Bool)0,"iwl_pcie_load_section","[%d] uCode section being loaded...\n",(int)section_num);
  
#line 676 
  v_addr = (u8 *)dma_alloc_attrs(trans->dev,(unsigned long)chunk_sz,& p_addr,720U,(struct dma_attrs *)0);
  
#line 678 
  if (v_addr == (u8 *)0U) {
    {
      
#line 679 
      bool __cond_0 = (_Bool)((int)*("Falling back to small chunks of DMA\n" + 35UL) != 10);
      
#line 679 
      if ((int)__cond_0 != 0) 
#line 679 
                              __compiletime_assert_679(); else ;
    }
    
#line 679 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_load_section","Falling back to small chunks of DMA\n");
    
#line 680 
    chunk_sz = 4096U;
    
#line 681 
    v_addr = (u8 *)dma_alloc_attrs(trans->dev,(unsigned long)chunk_sz,& p_addr,208U,(struct dma_attrs *)0);
    
#line 683 
    if (v_addr == (u8 *)0U) {
      
#line 684 
      __retres = -12;
      
#line 684 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 687 
  offset = 0U;
  
#line 687 
  goto ldv_54370;
  ldv_54369: 
#line 688 
  ;
  {
    u32 copy_size;
    u32 dst_addr;
    u32 tmp_4;
    
#line 689 
    bool extended_addr = (_Bool)0;
    {
      u32 tmp_3;
      
#line 691 
      u32 __min1_0 = chunk_sz;
      
#line 691 
      u32 __min2_0 = section->len - offset;
      
#line 691 
      if (__min1_0 < __min2_0) 
#line 691 
                               tmp_3 = __min1_0; else 
#line 691 
                                                      tmp_3 = __min2_0;
      
#line 691 
      tmp_4 = tmp_3;
    }
    
#line 691 
    copy_size = tmp_4;
    
#line 692 
    dst_addr = section->offset + offset;
    
#line 694 
    if (dst_addr + 4294705152U <= 98303U) 
#line 696 
                                          extended_addr = (_Bool)1; else ;
    
#line 698 
    if ((int)extended_addr != 0) 
#line 699 
                                 iwl_set_bits_prph(trans,10493944U,1U); else ;
    
#line 702 
    memcpy((void *)v_addr,section->data + offset,(unsigned long)copy_size);
    
#line 703 
    ret = iwl_pcie_load_firmware_chunk(trans,dst_addr,p_addr,copy_size);
    
#line 706 
    if ((int)extended_addr != 0) 
#line 707 
                                 iwl_clear_bits_prph(trans,10493944U,1U); else ;
    
#line 710 
    if (ret != 0) {
      {
        
#line 711 
        bool __cond_1 = (_Bool)((int)*("Could not load the [%d] uCode section\n" + 37UL) != 10);
        
#line 711 
        if ((int)__cond_1 != 0) 
#line 711 
                                __compiletime_assert_713(); else ;
      }
      
#line 711 
      __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Could not load the [%d] uCode section\n",(int)section_num);
      
#line 714 
      goto ldv_54368;
    }
    else ;
  }
  
#line 687 
  offset += chunk_sz;
  ldv_54370: 
#line 688 
  ;
  
#line 687 
  if (section->len > offset) 
#line 689 
                             goto ldv_54369; else 
#line 692 
                                                  goto ldv_54368;
  ldv_54368: 
#line 693 
  ;
  
#line 718 
  dma_free_attrs(trans->dev,(unsigned long)chunk_sz,(void *)v_addr,p_addr,(struct dma_attrs *)0);
  
#line 719 
  __retres = ret;
  return_label: 
#line 719 
                return __retres;
}


#line 738 
void __compiletime_assert_739(void);


#line 759 
void __compiletime_assert_759(void);


#line 727  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_rsa_race_bug_wa(struct iwl_trans *trans)
{
  int __retres;
  u32 val;
  
#line 729 
  u32 loop = 1000U;
  
#line 736 
  val = iwl_read_prph(trans,10505408U);
  
#line 737 
  if (((unsigned long)val & 131074UL) != 0UL) {
    {
      
#line 738 
      bool __cond = (_Bool)((int)*("can\'t access the RSA semaphore it is write protected\n" + 52UL) != 10);
      
#line 738 
      if ((int)__cond != 0) 
#line 738 
                            __compiletime_assert_739(); else ;
    }
    
#line 738 
    __iwl_info(trans->dev,"can\'t access the RSA semaphore it is write protected\n");
    
#line 740 
    __retres = 0;
    
#line 740 
    goto return_label;
  }
  else ;
  
#line 744 
  iwl_write_prph(trans,10498096U,2147483648U);
  
#line 745 
  iwl_write_prph(trans,10618904U,1U);
  ldv_54380: 
#line 746 
  ;
  
#line 748 
  iwl_write_prph(trans,10618880U,1U);
  
#line 749 
  val = iwl_read_prph(trans,10618880U);
  
#line 750 
  if (val == 1U) {
    
#line 751 
    iwl_write_prph(trans,10636040U,0U);
    
#line 752 
    __retres = 0;
    
#line 752 
    goto return_label;
  }
  else ;
  
#line 755 
  __const_udelay(42950UL);
  
#line 756 
  loop -= 1U;
  
#line 757 
  if (loop != 0U) 
#line 759 
                  goto ldv_54380; else 
#line 762 
                                       goto ldv_54381;
  ldv_54381: 
#line 763 
  ;
  {
    
#line 759 
    bool __cond_0 = (_Bool)((int)*("Failed to take ownership on secure machine\n" + 42UL) != 10);
    
#line 759 
    if ((int)__cond_0 != 0) 
#line 759 
                            __compiletime_assert_759(); else ;
  }
  
#line 759 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Failed to take ownership on secure machine\n");
  
#line 760 
  __retres = -5;
  return_label: 
#line 760 
                return __retres;
}


#line 785 
void __compiletime_assert_787(void);


#line 763  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_load_cpu_sections_8000(struct iwl_trans *trans, struct fw_img const *image, int cpu, int *first_ucode_section)
{
  int __retres;
  int shift_param;
  int i;
  u32 val;
  
#line 769 
  int ret = 0;
  
#line 769 
  int sec_num = 1;
  
#line 770 
  u32 last_read_idx = 0U;
  
#line 772 
  if (cpu == 1) {
    
#line 773 
    shift_param = 0;
    
#line 774 
    *first_ucode_section = 0;
  }
  else {
    
#line 776 
    shift_param = 16;
    
#line 777 
    *first_ucode_section += 1;
  }
  
#line 780 
  i = *first_ucode_section;
  
#line 780 
  goto ldv_54405;
  ldv_54404: 
#line 781 
  ;
  
#line 781 
  last_read_idx = (unsigned int)i;
  
#line 783 
  if (image->sec[i].data == (void const *)0 || image->sec[i].offset == 4294954188U) {
    {
      
#line 785 
      bool __cond = (_Bool)((int)*("Break since Data not valid or Empty section, sec = %d\n" + 53UL) != 10);
      
#line 785 
      if ((int)__cond != 0) 
#line 785 
                            __compiletime_assert_787(); else ;
    }
    
#line 785 
    __iwl_dbg(trans->dev,65536U,(_Bool)0,"iwl_pcie_load_cpu_sections_8000","Break since Data not valid or Empty section, sec = %d\n",i);
    
#line 788 
    goto ldv_54403;
  }
  else ;
  
#line 791 
  ret = iwl_pcie_load_section(trans,(unsigned char)((int)((unsigned char)i)),& image->sec[i]);
  
#line 792 
  if (ret != 0) {
    
#line 793 
    __retres = ret;
    
#line 793 
    goto return_label;
  }
  else ;
  
#line 796 
  val = iwl_read_direct32(trans,6896U);
  
#line 797 
  val = (unsigned int)(sec_num << shift_param) | val;
  
#line 798 
  iwl_write_direct32(trans,6896U,val);
  
#line 799 
  sec_num = (sec_num << 1) | 1;
  
#line 780 
  i += 1;
  ldv_54405: 
#line 781 
  ;
  
#line 780 
  if (i <= 11) 
#line 782 
               goto ldv_54404; else 
#line 785 
                                    goto ldv_54403;
  ldv_54403: 
#line 786 
  ;
  
#line 802 
  *first_ucode_section = (int)last_read_idx;
  
#line 804 
  if (cpu == 1) 
#line 805 
                iwl_write_direct32(trans,6896U,65535U); else 
#line 807 
                                                             iwl_write_direct32(trans,6896U,4294967295U);
  
#line 809 
  __retres = 0;
  return_label: 
#line 809 
                return __retres;
}


#line 812  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_load_cpu_sections(struct iwl_trans *trans, struct fw_img const *image, int cpu, int *first_ucode_section)
{
  int __retres;
  int shift_param;
  int i;
  
#line 818 
  int ret = 0;
  
#line 819 
  u32 last_read_idx = 0U;
  
#line 821 
  if (cpu == 1) {
    
#line 822 
    shift_param = 0;
    
#line 823 
    *first_ucode_section = 0;
  }
  else {
    
#line 825 
    shift_param = 16;
    
#line 826 
    *first_ucode_section += 1;
  }
  
#line 829 
  i = *first_ucode_section;
  
#line 829 
  goto ldv_54423;
  ldv_54422: 
#line 830 
  ;
  
#line 830 
  last_read_idx = (unsigned int)i;
  
#line 832 
  if (image->sec[i].data == (void const *)0 || image->sec[i].offset == 4294954188U) {
    {
      
#line 834 
      bool __cond = (_Bool)((int)*("Break since Data not valid or Empty section, sec = %d\n" + 53UL) != 10);
      
#line 834 
      if ((int)__cond != 0) 
#line 834 
                            __compiletime_assert_836(); else ;
    }
    
#line 834 
    __iwl_dbg(trans->dev,65536U,(_Bool)0,"iwl_pcie_load_cpu_sections","Break since Data not valid or Empty section, sec = %d\n",i);
    
#line 837 
    goto ldv_54421;
  }
  else ;
  
#line 840 
  ret = iwl_pcie_load_section(trans,(unsigned char)((int)((unsigned char)i)),& image->sec[i]);
  
#line 841 
  if (ret != 0) {
    
#line 842 
    __retres = ret;
    
#line 842 
    goto return_label;
  }
  else ;
  
#line 829 
  i += 1;
  ldv_54423: 
#line 830 
  ;
  
#line 829 
  if (i <= 11) 
#line 831 
               goto ldv_54422; else 
#line 834 
                                    goto ldv_54421;
  ldv_54421: 
#line 835 
  ;
  
#line 845 
  if ((trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) 
    
#line 846 
    iwl_set_bits_prph(trans,7792U,(unsigned int)(7 << shift_param)); else ;
  
#line 853 
  *first_ucode_section = (int)last_read_idx;
  
#line 855 
  __retres = 0;
  return_label: 
#line 855 
                return __retres;
}


#line 865 
void __compiletime_assert_867(void);


#line 869 
void __compiletime_assert_870(void);


#line 875 
void __compiletime_assert_875(void);


#line 901 
void __compiletime_assert_902(void);


#line 858  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_pcie_apply_destination(struct iwl_trans *trans)
{
  int i;
  char const *tmp;
  
#line 860 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 861 
  struct iwl_fw_dbg_dest_tlv const *dest = trans->dbg_dest_tlv;
  
#line 864 
  if ((unsigned int)dest->version != 0U) {
    {
      
#line 865 
      bool __cond = (_Bool)((int)*("DBG DEST version is %d - expect issues\n" + 38UL) != 10);
      
#line 865 
      if ((int)__cond != 0) 
#line 865 
                            __compiletime_assert_867(); else ;
    }
    
#line 865 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"DBG DEST version is %d - expect issues\n",(int)dest->version);
  }
  else ;
  {
    
#line 869 
    bool __cond_0 = (_Bool)((int)*("Applying debug destination %s\n" + 29UL) != 10);
    
#line 869 
    if ((int)__cond_0 != 0) 
#line 869 
                            __compiletime_assert_870(); else ;
  }
  
#line 869 
  tmp = get_fw_dbg_mode_string((int)dest->monitor_mode);
  
#line 869 
  ;
  
#line 869 
  __iwl_info(trans->dev,"Applying debug destination %s\n",tmp);
  
#line 872 
  if ((unsigned int)dest->monitor_mode == 1U) 
#line 873 
                                              iwl_pcie_alloc_fw_monitor(trans,(unsigned char)((int)dest->size_power));
  else {
    {
      
#line 875 
      bool __cond_1 = (_Bool)((int)*("PCI should have external buffer debug\n" + 37UL) != 10);
      
#line 875 
      if ((int)__cond_1 != 0) 
#line 875 
                              __compiletime_assert_875(); else ;
    }
    
#line 875 
    __iwl_warn(trans->dev,"PCI should have external buffer debug\n");
  }
  
#line 877 
  i = 0;
  
#line 877 
  goto ldv_54457;
  ldv_54456: 
#line 878 
  ;
  {
    
#line 878 
    u32 addr = dest->reg_ops[i].addr;
    
#line 879 
    u32 val = dest->reg_ops[i].val;
    
#line 881 
    switch ((int)dest->reg_ops[i].op) {
      case 0: 
#line 882 
      ;
      
#line 883 
      iwl_write32_2(trans,addr,val);
      
#line 884 
      goto ldv_54445;
      case 1: 
#line 885 
      ;
      
#line 886 
      iwl_set_bit(trans,addr,(unsigned int)(1UL << val));
      
#line 887 
      goto ldv_54445;
      case 2: 
#line 888 
      ;
      
#line 889 
      iwl_clear_bit(trans,addr,(unsigned int)(1UL << val));
      
#line 890 
      goto ldv_54445;
      case 3: 
#line 891 
      ;
      
#line 892 
      iwl_write_prph(trans,addr,val);
      
#line 893 
      goto ldv_54445;
      case 4: 
#line 894 
      ;
      
#line 895 
      iwl_set_bits_prph(trans,addr,(unsigned int)(1UL << val));
      
#line 896 
      goto ldv_54445;
      case 5: 
#line 897 
      ;
      
#line 898 
      iwl_clear_bits_prph(trans,addr,(unsigned int)(1UL << val));
      
#line 899 
      goto ldv_54445;
      default: 
#line 900 
      ;
      {
        
#line 901 
        bool __cond_2 = (_Bool)((int)*("FW debug - unknown OP %d\n" + 24UL) != 10);
        
#line 901 
        if ((int)__cond_2 != 0) 
#line 901 
                                __compiletime_assert_902(); else ;
      }
      
#line 901 
      __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"FW debug - unknown OP %d\n",(int)dest->reg_ops[i].op);
      
#line 903 
      goto ldv_54445;
    }
    ldv_54445: 
#line 905 
    ;
  }
  
#line 877 
  i += 1;
  ldv_54457: 
#line 878 
  ;
  
#line 877 
  if ((int)trans->dbg_dest_reg_num > i) 
#line 879 
                                        goto ldv_54456; else 
#line 882 
                                                             goto ldv_54458;
  ldv_54458: 
#line 883 
  ;
  
#line 907 
  if ((unsigned int)dest->monitor_mode == 1U && trans_pcie->fw_mon_size != 0U) {
    
#line 908 
    iwl_write_prph(trans,dest->base_reg,(unsigned int)(trans_pcie->fw_mon_phys >> (int)dest->base_shift));
    
#line 910 
    iwl_write_prph(trans,dest->end_reg,(unsigned int)((trans_pcie->fw_mon_phys + (unsigned long long)trans_pcie->fw_mon_size) >> (int)dest->end_shift));
  }
  else ;
  
#line 914 
  return;
}


#line 923 
void __compiletime_assert_924(void);


#line 916  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_load_given_ucode(struct iwl_trans *trans, struct fw_img const *image)
{
  int __retres;
  int first_ucode_section;
  char *tmp;
  
#line 919 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 920 
  int ret = 0;
  {
    
#line 923 
    bool __cond = (_Bool)((int)*("working with %s CPU\n" + 19UL) != 10);
    
#line 923 
    if ((int)__cond != 0) 
#line 923 
                          __compiletime_assert_924(); else ;
  }
  
#line 923 
  if ((int)image->is_dual_cpus != 0) 
#line 923 
                                     tmp = (char *)"Dual"; else 
#line 923 
                                                                tmp = (char *)"Single";
  
#line 923 
  ;
  
#line 923 
  __iwl_dbg(trans->dev,65536U,(_Bool)0,"iwl_pcie_load_given_ucode","working with %s CPU\n",tmp);
  
#line 927 
  ret = iwl_pcie_load_cpu_sections(trans,image,1,& first_ucode_section);
  
#line 928 
  if (ret != 0) {
    
#line 929 
    __retres = ret;
    
#line 929 
    goto return_label;
  }
  else ;
  
#line 931 
  if ((int)image->is_dual_cpus != 0) {
    
#line 933 
    iwl_write_prph(trans,7804U,4326400U);
    
#line 938 
    ret = iwl_pcie_load_cpu_sections(trans,image,2,& first_ucode_section);
    
#line 940 
    if (ret != 0) {
      
#line 941 
      __retres = ret;
      
#line 941 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 945 
  if ((int)iwlwifi_mod_params.fw_monitor != 0 && (trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_7000) {
    
#line 947 
    iwl_pcie_alloc_fw_monitor(trans,(unsigned char)0);
    
#line 949 
    if (trans_pcie->fw_mon_size != 0U) {
      
#line 950 
      iwl_write_prph(trans,10501180U,(unsigned int)(trans_pcie->fw_mon_phys >> 4));
      
#line 952 
      iwl_write_prph(trans,10501184U,(unsigned int)((trans_pcie->fw_mon_phys + (unsigned long long)trans_pcie->fw_mon_size) >> 4));
    }
    else ;
  }
  else 
    
#line 956 
    if (trans->dbg_dest_tlv != (struct iwl_fw_dbg_dest_tlv const *)0) 
      
#line 957 
      iwl_pcie_apply_destination(trans); else ;
  
#line 961 
  iwl_write32_2(trans,32U,0U);
  
#line 963 
  __retres = 0;
  return_label: 
#line 963 
                return __retres;
}


#line 972 
void __compiletime_assert_973(void);


#line 966  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_load_given_ucode_8000(struct iwl_trans *trans, struct fw_img const *image)
{
  int __retres;
  int first_ucode_section;
  char *tmp;
  int tmp_0;
  
#line 969 
  int ret = 0;
  {
    
#line 972 
    bool __cond = (_Bool)((int)*("working with %s CPU\n" + 19UL) != 10);
    
#line 972 
    if ((int)__cond != 0) 
#line 972 
                          __compiletime_assert_973(); else ;
  }
  
#line 972 
  if ((int)image->is_dual_cpus != 0) 
#line 972 
                                     tmp = (char *)"Dual"; else 
#line 972 
                                                                tmp = (char *)"Single";
  
#line 972 
  ;
  
#line 972 
  __iwl_dbg(trans->dev,65536U,(_Bool)0,"iwl_pcie_load_given_ucode_8000","working with %s CPU\n",tmp);
  
#line 975 
  if (trans->dbg_dest_tlv != (struct iwl_fw_dbg_dest_tlv const *)0) 
#line 976 
                                                                    iwl_pcie_apply_destination(trans); else ;
  
#line 979 
  ret = iwl_pcie_rsa_race_bug_wa(trans);
  
#line 980 
  if (ret != 0) {
    
#line 981 
    __retres = ret;
    
#line 981 
    goto return_label;
  }
  else ;
  
#line 985 
  iwl_write_prph(trans,12300U,16777216U);
  
#line 988 
  ret = iwl_pcie_load_cpu_sections_8000(trans,image,1,& first_ucode_section);
  
#line 990 
  if (ret != 0) {
    
#line 991 
    __retres = ret;
    
#line 991 
    goto return_label;
  }
  else ;
  
#line 994 
  tmp_0 = iwl_pcie_load_cpu_sections_8000(trans,image,2,& first_ucode_section);
  
#line 994 
  __retres = tmp_0;
  return_label: 
#line 994 
                return __retres;
}


#line 1006 
void __compiletime_assert_1006(void);


#line 1026 
void __compiletime_assert_1026(void);


#line 998  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_trans_pcie_start_fw(struct iwl_trans *trans, struct fw_img const *fw, bool run_in_rfkill)
{
  int __retres;
  int ret;
  bool hw_rfkill;
  int tmp;
  
#line 1005 
  tmp = iwl_pcie_prepare_card_hw(trans);
  
#line 1005 
  if (tmp != 0) {
    {
      
#line 1006 
      bool __cond = (_Bool)((int)*("Exit HW not ready\n" + 17UL) != 10);
      
#line 1006 
      if ((int)__cond != 0) 
#line 1006 
                            __compiletime_assert_1006(); else ;
    }
    
#line 1006 
    __iwl_warn(trans->dev,"Exit HW not ready\n");
    
#line 1007 
    __retres = -5;
    
#line 1007 
    goto return_label;
  }
  else ;
  
#line 1010 
  iwl_enable_rfkill_int_1(trans);
  
#line 1013 
  hw_rfkill = iwl_is_rfkill_set_1(trans);
  
#line 1014 
  if ((int)hw_rfkill != 0) 
#line 1015 
                           set_bit(4L,(unsigned long volatile *)(& trans->status)); else 
                                                                    
#line 1017 
                                                                    set_bit(4L,(unsigned long volatile *)(& trans->status));
  
#line 1018 
  iwl_trans_pcie_rf_kill(trans,(_Bool)((bool)((int)hw_rfkill) != 0));
  
#line 1019 
  if ((int)hw_rfkill != 0 && ! run_in_rfkill) {
    
#line 1020 
    __retres = -132;
    
#line 1020 
    goto return_label;
  }
  else ;
  
#line 1022 
  iwl_write32_2(trans,8U,4294967295U);
  
#line 1024 
  ret = iwl_pcie_nic_init(trans);
  
#line 1025 
  if (ret != 0) {
    {
      
#line 1026 
      bool __cond_0 = (_Bool)((int)*("Unable to init nic\n" + 18UL) != 10);
      
#line 1026 
      if ((int)__cond_0 != 0) 
#line 1026 
                              __compiletime_assert_1026(); else ;
    }
    
#line 1026 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Unable to init nic\n");
    
#line 1027 
    __retres = ret;
    
#line 1027 
    goto return_label;
  }
  else ;
  
#line 1031 
  iwl_write32_2(trans,92U,2U);
  
#line 1032 
  iwl_write32_2(trans,92U,4U);
  
#line 1036 
  iwl_write32_2(trans,8U,4294967295U);
  
#line 1037 
  iwl_enable_interrupts_1(trans);
  
#line 1040 
  iwl_write32_2(trans,92U,2U);
  
#line 1041 
  iwl_write32_2(trans,92U,2U);
  
#line 1044 
  if ((trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) {
    int tmp_0;
    
#line 1045 
    tmp_0 = iwl_pcie_load_given_ucode_8000(trans,fw);
    
#line 1045 
    __retres = tmp_0;
    
#line 1045 
    goto return_label;
  }
  else {
    int tmp_1;
    
#line 1047 
    tmp_1 = iwl_pcie_load_given_ucode(trans,fw);
    
#line 1047 
    __retres = tmp_1;
    
#line 1047 
    goto return_label;
  }
  return_label: 
#line 1044 
                return __retres;
}


#line 1050  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_fw_alive(struct iwl_trans *trans, u32 scd_addr)
{
  
#line 1052 
  iwl_pcie_reset_ict(trans);
  
#line 1053 
  iwl_pcie_tx_start(trans,scd_addr);
  
#line 1054 
  return;
}


#line 1079 
void __compiletime_assert_1079(void);


#line 1056  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_stop_device(struct iwl_trans *trans, bool low_power)
{
  bool hw_rfkill;
  bool was_hw_rfkill;
  int tmp;
  
#line 1058 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1061 
  was_hw_rfkill = iwl_is_rfkill_set_1(trans);
  
#line 1064 
  ldv_spin_lock_75_0(& trans_pcie->irq_lock);
  
#line 1065 
  iwl_disable_interrupts_0(trans);
  
#line 1066 
  ldv_spin_unlock_76_0(& trans_pcie->irq_lock);
  
#line 1069 
  iwl_pcie_disable_ict(trans);
  
#line 1078 
  tmp = test_and_set_bit(1L,(unsigned long volatile *)(& trans->status));
  
#line 1078 
  if (tmp != 0) {
    {
      
#line 1079 
      bool __cond = (_Bool)((int)*("DEVICE_ENABLED bit was set and is now cleared\n" + 45UL) != 10);
      
#line 1079 
      if ((int)__cond != 0) 
#line 1079 
                            __compiletime_assert_1079(); else ;
    }
    
#line 1079 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_trans_pcie_stop_device","DEVICE_ENABLED bit was set and is now cleared\n");
    
#line 1080 
    iwl_pcie_tx_stop(trans);
    
#line 1081 
    iwl_pcie_rx_stop(trans);
    
#line 1084 
    if (! (trans->cfg)->apmg_not_supported) {
      
#line 1085 
      iwl_write_prph(trans,12296U,512U);
      
#line 1087 
      __const_udelay(21475UL);
    }
    else ;
  }
  else ;
  
#line 1092 
  iwl_clear_bit(trans,36U,8U);
  
#line 1096 
  iwl_pcie_apm_stop(trans,(_Bool)0);
  
#line 1099 
  iwl_write32_2(trans,32U,128U);
  
#line 1100 
  __const_udelay(85900UL);
  
#line 1109 
  ldv_spin_lock_77(& trans_pcie->irq_lock);
  
#line 1110 
  iwl_disable_interrupts_0(trans);
  
#line 1111 
  ldv_spin_unlock_78(& trans_pcie->irq_lock);
  
#line 1115 
  set_bit(0L,(unsigned long volatile *)(& trans->status));
  
#line 1116 
  set_bit(3L,(unsigned long volatile *)(& trans->status));
  
#line 1117 
  set_bit(2L,(unsigned long volatile *)(& trans->status));
  
#line 1118 
  set_bit(4L,(unsigned long volatile *)(& trans->status));
  
#line 1124 
  iwl_enable_rfkill_int_1(trans);
  
#line 1138 
  hw_rfkill = iwl_is_rfkill_set_1(trans);
  
#line 1139 
  if ((int)hw_rfkill != 0) 
#line 1140 
                           set_bit(4L,(unsigned long volatile *)(& trans->status)); else 
                                                                    
#line 1142 
                                                                    set_bit(4L,(unsigned long volatile *)(& trans->status));
  
#line 1143 
  if ((int)hw_rfkill != (int)was_hw_rfkill) 
#line 1144 
                                            iwl_trans_pcie_rf_kill(trans,(_Bool)((bool)((int)hw_rfkill) != 0)); else ;
  
#line 1147 
  iwl_pcie_prepare_card_hw(trans);
  
#line 1148 
  return;
}


#line 1150  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
void iwl_trans_pcie_rf_kill(struct iwl_trans *trans, bool state)
{
  bool tmp;
  
#line 1152 
  tmp = iwl_op_mode_hw_rf_kill(trans->op_mode,(_Bool)((bool)((int)state) != 0));
  
#line 1152 
  if ((int)tmp != 0) 
#line 1153 
                     iwl_trans_pcie_stop_device(trans,(_Bool)1); else ;
  
#line 1154 
  return;
}


#line 1156  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_d3_suspend(struct iwl_trans *trans, bool test)
{
  
#line 1158 
  iwl_disable_interrupts_0(trans);
  
#line 1164 
  if ((int)test != 0) 
#line 1165 
                      goto return_label; else ;
  
#line 1167 
  iwl_pcie_disable_ict(trans);
  
#line 1169 
  iwl_clear_bit(trans,36U,8U);
  
#line 1171 
  iwl_clear_bit(trans,36U,4U);
  
#line 1179 
  iwl_trans_pcie_tx_reset(trans);
  
#line 1181 
  iwl_pcie_set_pwr(trans,(_Bool)1);
  return_label: 
#line 1182 
                return;
}


#line 1215 
void __compiletime_assert_1215(void);


#line 1225 
void __compiletime_assert_1225(void);


#line 1184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_trans_pcie_d3_resume(struct iwl_trans *trans, enum iwl_d3_status *status, bool test)
{
  int __retres;
  u32 val;
  int ret;
  
#line 1191 
  if ((int)test != 0) {
    
#line 1192 
    iwl_enable_interrupts_1(trans);
    
#line 1193 
    *status = IWL_D3_STATUS_ALIVE;
    
#line 1194 
    __retres = 0;
    
#line 1194 
    goto return_label;
  }
  else ;
  
#line 1202 
  iwl_pcie_reset_ict(trans);
  
#line 1204 
  iwl_set_bit(trans,36U,8U);
  
#line 1205 
  iwl_set_bit(trans,36U,4U);
  
#line 1207 
  if ((trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) 
    
#line 1208 
    __const_udelay(8590UL); else ;
  
#line 1210 
  ret = iwl_poll_bit(trans,36U,1U,1U,25000);
  
#line 1214 
  if (ret < 0) {
    {
      
#line 1215 
      bool __cond = (_Bool)((int)*("Failed to resume the device (mac ready)\n" + 39UL) != 10);
      
#line 1215 
      if ((int)__cond != 0) 
#line 1215 
                            __compiletime_assert_1215(); else ;
    }
    
#line 1215 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Failed to resume the device (mac ready)\n");
    
#line 1216 
    __retres = ret;
    
#line 1216 
    goto return_label;
  }
  else ;
  
#line 1219 
  iwl_pcie_set_pwr(trans,(_Bool)0);
  
#line 1221 
  iwl_trans_pcie_tx_reset(trans);
  
#line 1223 
  ret = iwl_pcie_rx_init(trans);
  
#line 1224 
  if (ret != 0) {
    {
      
#line 1225 
      bool __cond_0 = (_Bool)((int)*("Failed to resume the device (RX reset)\n" + 38UL) != 10);
      
#line 1225 
      if ((int)__cond_0 != 0) 
#line 1225 
                              __compiletime_assert_1225(); else ;
    }
    
#line 1225 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Failed to resume the device (RX reset)\n");
    
#line 1226 
    __retres = ret;
    
#line 1226 
    goto return_label;
  }
  else ;
  
#line 1229 
  val = iwl_read32_2(trans,32U);
  
#line 1230 
  if ((val & 1U) != 0U) 
#line 1231 
                        *status = IWL_D3_STATUS_RESET; else 
#line 1233 
                                                            *status = IWL_D3_STATUS_ALIVE;
  
#line 1235 
  __retres = 0;
  return_label: 
#line 1235 
                return __retres;
}


#line 1245 
void __compiletime_assert_1245(void);


#line 1238  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_trans_pcie_start_hw(struct iwl_trans *trans, bool low_power)
{
  int __retres;
  bool hw_rfkill;
  int err;
  
#line 1243 
  err = iwl_pcie_prepare_card_hw(trans);
  
#line 1244 
  if (err != 0) {
    {
      
#line 1245 
      bool __cond = (_Bool)((int)*("Error while preparing HW: %d\n" + 28UL) != 10);
      
#line 1245 
      if ((int)__cond != 0) 
#line 1245 
                            __compiletime_assert_1245(); else ;
    }
    
#line 1245 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Error while preparing HW: %d\n",err);
    
#line 1246 
    __retres = err;
    
#line 1246 
    goto return_label;
  }
  else ;
  
#line 1250 
  iwl_write32_2(trans,32U,128U);
  
#line 1252 
  usleep_range(10UL,15UL);
  
#line 1254 
  iwl_pcie_apm_init(trans);
  
#line 1257 
  iwl_enable_rfkill_int_1(trans);
  
#line 1259 
  hw_rfkill = iwl_is_rfkill_set_1(trans);
  
#line 1260 
  if ((int)hw_rfkill != 0) 
#line 1261 
                           set_bit(4L,(unsigned long volatile *)(& trans->status)); else 
                                                                    
#line 1263 
                                                                    set_bit(4L,(unsigned long volatile *)(& trans->status));
  
#line 1264 
  iwl_trans_pcie_rf_kill(trans,(_Bool)((bool)((int)hw_rfkill) != 0));
  
#line 1266 
  __retres = 0;
  return_label: 
#line 1266 
                return __retres;
}


#line 1269  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_op_mode_leave(struct iwl_trans *trans)
{
  
#line 1271 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1274 
  ldv_spin_lock_79(& trans_pcie->irq_lock);
  
#line 1275 
  iwl_disable_interrupts_0(trans);
  
#line 1276 
  ldv_spin_unlock_80(& trans_pcie->irq_lock);
  
#line 1278 
  iwl_pcie_apm_stop(trans,(_Bool)1);
  
#line 1280 
  ldv_spin_lock_81(& trans_pcie->irq_lock);
  
#line 1281 
  iwl_disable_interrupts_0(trans);
  
#line 1282 
  ldv_spin_unlock_82_0(& trans_pcie->irq_lock);
  
#line 1284 
  iwl_pcie_disable_ict(trans);
  
#line 1285 
  return;
}


#line 1287  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_write8(struct iwl_trans *trans, u32 ofs, u8 val)
{
  
#line 1289 
  writeb((unsigned char)((int)val),(void volatile *)(((struct iwl_trans_pcie *)(& trans->trans_specific))->hw_base + ofs));
  
#line 1290 
  return;
}


#line 1292  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_write32(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 1294 
  writel(val,(void volatile *)(((struct iwl_trans_pcie *)(& trans->trans_specific))->hw_base + ofs));
  
#line 1295 
  return;
}


#line 1297  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static u32 iwl_trans_pcie_read32(struct iwl_trans *trans, u32 ofs)
{
  u32 tmp;
  
#line 1299 
  tmp = readl((void const volatile *)(((struct iwl_trans_pcie *)(& trans->trans_specific))->hw_base + ofs));
  
#line 1299 
  return tmp;
}


#line 1302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static u32 iwl_trans_pcie_read_prph(struct iwl_trans *trans, u32 reg)
{
  u32 tmp;
  
#line 1304 
  iwl_trans_pcie_write32(trans,1096U,(reg & 1048575U) | 50331648U);
  
#line 1306 
  tmp = iwl_trans_pcie_read32(trans,1104U);
  
#line 1306 
  return tmp;
}


#line 1309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_write_prph(struct iwl_trans *trans, u32 addr, u32 val)
{
  
#line 1312 
  iwl_trans_pcie_write32(trans,1092U,(addr & 1048575U) | 50331648U);
  
#line 1314 
  iwl_trans_pcie_write32(trans,1100U,val);
  
#line 1315 
  return;
}


#line 1317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_pcie_dummy_napi_poll(struct napi_struct *napi, int budget)
{
  int __retres;
  {
    
#line 1319 
    int __ret_warn_on = 1;
    
#line 1319 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1319 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",1319); else ;
    
#line 1319 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 1320 
  __retres = 0;
  
#line 1320 
  return __retres;
}


#line 1323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_configure(struct iwl_trans *trans, struct iwl_trans_config const *trans_cfg)
{
  int tmp;
  
#line 1326 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1328 
  trans_pcie->cmd_queue = trans_cfg->cmd_queue;
  
#line 1329 
  trans_pcie->cmd_fifo = trans_cfg->cmd_fifo;
  
#line 1330 
  trans_pcie->cmd_q_wdg_timeout = trans_cfg->cmd_q_wdg_timeout;
  {
    
#line 1331 
    int __ret_warn_on = trans_cfg->n_no_reclaim_cmds > 6U;
    
#line 1331 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1331 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",1331); else ;
    
#line 1331 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 1331 
  if ((long)tmp != 0L) 
#line 1332 
                       trans_pcie->n_no_reclaim_cmds = (unsigned char)0U; else 
                                                                    
#line 1334 
                                                                    trans_pcie->n_no_reclaim_cmds = (unsigned char)trans_cfg->n_no_reclaim_cmds;
  
#line 1335 
  if ((unsigned int)trans_pcie->n_no_reclaim_cmds != 0U) 
#line 1336 
                                                         memcpy((void *)(& trans_pcie->no_reclaim_cmds),(void const *)trans_cfg->no_reclaim_cmds,(unsigned long)trans_pcie->n_no_reclaim_cmds); else ;
  
#line 1339 
  trans_pcie->rx_buf_size_8k = trans_cfg->rx_buf_size_8k;
  
#line 1340 
  if ((int)trans_pcie->rx_buf_size_8k != 0) 
#line 1341 
                                            trans_pcie->rx_page_order = 1U; else 
                                                                    
#line 1343 
                                                                    trans_pcie->rx_page_order = 0U;
  
#line 1345 
  trans_pcie->command_names = trans_cfg->command_names;
  
#line 1346 
  trans_pcie->bc_table_dword = trans_cfg->bc_table_dword;
  
#line 1347 
  trans_pcie->scd_set_active = trans_cfg->scd_set_active;
  
#line 1350 
  trans_pcie->ref_count = 1U;
  
#line 1357 
  if (trans_pcie->napi.poll == (int (*)(struct napi_struct *, int ))0 && ((trans->op_mode)->ops)->napi_add != (void (*)(struct iwl_op_mode *, struct napi_struct *, struct net_device *, int (*)(struct napi_struct *, int ), int ))0) {
    
#line 1358 
    init_dummy_netdev(& trans_pcie->napi_dev);
    
#line 1359 
    iwl_op_mode_napi_add(trans->op_mode,& trans_pcie->napi,& trans_pcie->napi_dev,& iwl_pcie_dummy_napi_poll,64);
  }
  else ;
  
#line 1363 
  return;
}


#line 1365  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
void iwl_trans_pcie_free(struct iwl_trans *trans)
{
  
#line 1367 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1369 
  synchronize_irq((trans_pcie->pci_dev)->irq);
  
#line 1371 
  iwl_pcie_tx_free(trans);
  
#line 1372 
  iwl_pcie_rx_free(trans);
  
#line 1374 
  ldv_free_irq_83((trans_pcie->pci_dev)->irq,(void *)trans);
  
#line 1375 
  iwl_pcie_free_ict(trans);
  
#line 1377 
  pci_disable_msi(trans_pcie->pci_dev);
  
#line 1378 
  iounmap((void volatile *)trans_pcie->hw_base);
  
#line 1379 
  pci_release_regions(trans_pcie->pci_dev);
  
#line 1380 
  pci_disable_device(trans_pcie->pci_dev);
  
#line 1382 
  if (trans_pcie->napi.poll != (int (*)(struct napi_struct *, int ))0) 
    
#line 1383 
    netif_napi_del(& trans_pcie->napi); else ;
  
#line 1385 
  iwl_pcie_free_fw_monitor(trans);
  
#line 1387 
  iwl_trans_free(trans);
  
#line 1388 
  return;
}


#line 1390  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_set_pmi(struct iwl_trans *trans, bool state)
{
  
#line 1392 
  if ((int)state != 0) 
#line 1393 
                       set_bit(2L,(unsigned long volatile *)(& trans->status)); else 
                                                                    
#line 1395 
                                                                    set_bit(2L,(unsigned long volatile *)(& trans->status));
  
#line 1396 
  return;
}


#line 1398  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static bool iwl_trans_pcie_grab_nic_access(struct iwl_trans *trans, bool silent, unsigned long *flags)
{
  bool __retres;
  int ret;
  
#line 1402 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1404 
  ldv___ldv_spin_lock_84(& trans_pcie->reg_lock);
  
#line 1406 
  if ((int)trans_pcie->cmd_hold_nic_awake != 0) 
#line 1407 
                                                goto out; else ;
  
#line 1410 
  __iwl_trans_pcie_set_bit(trans,36U,8U);
  
#line 1412 
  if ((trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) 
    
#line 1413 
    __const_udelay(8590UL); else ;
  
#line 1434 
  ret = iwl_poll_bit(trans,36U,1U,17U,15000);
  
#line 1438 
  if ((long)(ret < 0) != 0L) {
    
#line 1439 
    iwl_write32_2(trans,32U,2U);
    
#line 1440 
    if (! silent) {
      
#line 1441 
      u32 val = iwl_read32_2(trans,36U);
      {
        bool __warned;
        
#line 1442 
        int __ret_warn_once = 1;
        
#line 1442 
        if ((long)(__ret_warn_once != 0) != 0L) {
          int tmp_0;
          {
            
#line 1442 
            int __ret_warn_on = ! __warned;
            
#line 1442 
            if ((long)(__ret_warn_on != 0) != 0L) 
#line 1442 
                                                  warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",1444,"Timeout waiting for hardware access (CSR_GP_CNTRL 0x%08x)\n",val); else ;
            
#line 1442 
            tmp_0 = (long)(__ret_warn_on != 0);
          }
          
#line 1442 
          if ((long)tmp_0 != 0L) 
#line 1442 
                                 __warned = (_Bool)1; else ;
        }
        else ;
        
#line 1442 
        long tmp_2 = (long)(__ret_warn_once != 0);
      }
      
#line 1445 
      ldv_spin_unlock_irqrestore_85(& trans_pcie->reg_lock,*flags);
      
#line 1446 
      __retres = (_Bool)0;
      
#line 1446 
      goto return_label;
    }
    else ;
  }
  else ;
  out: 
#line 1450 
  ;
  
#line 1456 
  __retres = (_Bool)1;
  return_label: 
#line 1456 
                return __retres;
}


#line 1459  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_release_nic_access(struct iwl_trans *trans, unsigned long *flags)
{
  
#line 1462 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    int tmp_0;
    
#line 1464 
    if (debug_locks != 0) {
      int tmp;
      
#line 1464 
      tmp = lock_is_held(& trans_pcie->reg_lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 1464 
      if (tmp == 0) 
#line 1464 
                    tmp_0 = 1; else 
#line 1464 
                                    tmp_0 = 0;
    }
    else 
#line 1464 
         tmp_0 = 0;
    
#line 1464 
    int __ret_warn_on = tmp_0;
    
#line 1464 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1464 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",1464); else ;
    
#line 1464 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1472 
  if ((int)trans_pcie->cmd_hold_nic_awake != 0) 
#line 1473 
                                                goto out; else ;
  
#line 1475 
  __iwl_trans_pcie_clear_bit(trans,36U,8U);
  
#line 1476 
  ldv_inline_asm();
  out: 
#line 1484 
  ;
  
#line 1485 
  ldv_spin_unlock_irqrestore_86(& trans_pcie->reg_lock,*flags);
  
#line 1486 
  return;
}


#line 1488  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_trans_pcie_read_mem(struct iwl_trans *trans, u32 addr, void *buf, int dwords)
{
  unsigned long flags;
  int offs;
  bool tmp;
  
#line 1492 
  int ret = 0;
  
#line 1493 
  u32 *vals = (u32 *)buf;
  
#line 1495 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 1495 
  if ((long)((int)tmp != 0) != 0L) {
    
#line 1496 
    iwl_write32_2(trans,1036U,addr);
    
#line 1497 
    offs = 0;
    
#line 1497 
    goto ldv_54627;
    ldv_54626: 
#line 1498 
    ;
    
#line 1498 
    *(vals + offs) = iwl_read32_2(trans,1052U);
    
#line 1497 
    offs += 1;
    ldv_54627: 
#line 1498 
    ;
    
#line 1497 
    if (offs < dwords) 
#line 1499 
                       goto ldv_54626; else 
#line 1502 
                                            goto ldv_54628;
    ldv_54628: 
#line 1503 
    ;
    
#line 1499 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else 
#line 1501 
       ret = -16;
  
#line 1503 
  return ret;
}


#line 1506  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_trans_pcie_write_mem(struct iwl_trans *trans, u32 addr, void const *buf, int dwords)
{
  unsigned long flags;
  int offs;
  bool tmp_0;
  
#line 1510 
  int ret = 0;
  
#line 1511 
  u32 const *vals = (u32 const *)buf;
  
#line 1513 
  tmp_0 = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 1513 
  if ((long)((int)tmp_0 != 0) != 0L) {
    unsigned int tmp;
    
#line 1514 
    iwl_write32_2(trans,1040U,addr);
    
#line 1515 
    offs = 0;
    
#line 1515 
    goto ldv_54640;
    ldv_54639: 
#line 1516 
    ;
    
#line 1516 
    if (vals != (u32 const *)0U) 
#line 1516 
                                 tmp = *(vals + offs); else 
#line 1516 
                                                            tmp = 0U;
    
#line 1516 
    ;
    
#line 1516 
    iwl_write32_2(trans,1048U,tmp);
    
#line 1515 
    offs += 1;
    ldv_54640: 
#line 1516 
    ;
    
#line 1515 
    if (offs < dwords) 
#line 1517 
                       goto ldv_54639; else 
#line 1520 
                                            goto ldv_54641;
    ldv_54641: 
#line 1521 
    ;
    
#line 1518 
    iwl_trans_release_nic_access(trans,& flags);
  }
  else 
#line 1520 
       ret = -16;
  
#line 1522 
  return ret;
}


#line 1543 
void __compiletime_assert_1544(void);


#line 1525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_freeze_txq_timer(struct iwl_trans *trans, unsigned long txqs, bool freeze)
{
  int queue;
  unsigned long tmp;
  unsigned long tmp_4;
  
#line 1529 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1532 
  tmp = find_first_bit((unsigned long const *)(& txqs),64UL);
  
#line 1532 
  queue = (int)tmp;
  
#line 1532 
  goto ldv_54664;
  ldv_54663: 
#line 1533 
  ;
  {
    unsigned long now;
    char *tmp_0;
    
#line 1533 
    struct iwl_txq *txq = trans_pcie->txq + queue;
    
#line 1536 
    ldv_spin_lock_bh_87(& txq->lock);
    
#line 1538 
    now = jiffies;
    
#line 1540 
    if ((int)txq->frozen == (int)freeze) 
#line 1541 
                                         goto next_queue; else ;
    {
      
#line 1543 
      bool __cond = (_Bool)((int)*("%s TXQ %d\n" + 9UL) != 10);
      
#line 1543 
      if ((int)__cond != 0) 
#line 1543 
                            __compiletime_assert_1544(); else ;
    }
    
#line 1543 
    ;
    
#line 1543 
    if ((int)freeze != 0) 
#line 1543 
                          tmp_0 = (char *)"Freezing"; else 
#line 1543 
                                                           tmp_0 = (char *)"Waking";
    
#line 1543 
    ;
    
#line 1543 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_trans_pcie_freeze_txq_timer","%s TXQ %d\n",tmp_0,queue);
    
#line 1546 
    txq->frozen = freeze;
    
#line 1548 
    if (txq->q.read_ptr == txq->q.write_ptr) 
#line 1549 
                                             goto next_queue; else ;
    
#line 1551 
    if ((int)freeze != 0) {
      int tmp_3;
      int tmp_1;
      {
        unsigned long __dummy;
        unsigned long __dummy2;
        
#line 1552 
        tmp_1 = 1;
      }
      
#line 1552 
      if ((long)(tmp_1 != 0) != 0L) {
        int tmp_2;
        {
          unsigned long __dummy_0;
          unsigned long __dummy2_0;
          
#line 1552 
          tmp_2 = 1;
        }
        
#line 1552 
        if ((long)(tmp_2 != 0) != 0L) 
#line 1552 
                                      tmp_3 = 1; else 
#line 1552 
                                                      tmp_3 = 0;
      }
      else 
#line 1552 
           tmp_3 = 0;
      
#line 1552 
      if (tmp_3 != 0) {
        
#line 1552 
        if ((long)((long)(txq->stuck_timer.expires - now) < 0L) != 0L) 
          
#line 1558 
          goto next_queue; else ;
      }
      else ;
      
#line 1561 
      txq->frozen_expiry_remainder = txq->stuck_timer.expires - now;
      
#line 1563 
      ldv_del_timer_88(& txq->stuck_timer);
      
#line 1564 
      goto next_queue;
    }
    else ;
    
#line 1571 
    ldv_mod_timer_89(& txq->stuck_timer,txq->frozen_expiry_remainder + now);
    next_queue: 
#line 1574 
    ;
    
#line 1575 
    ldv_spin_unlock_bh_90(& txq->lock);
  }
  
#line 1532 
  tmp_4 = find_next_bit((unsigned long const *)(& txqs),64UL,(unsigned long)(queue + 1));
  
#line 1532 
  queue = (int)tmp_4;
  ldv_54664: 
#line 1533 
  ;
  
#line 1532 
  if (queue <= 63) 
#line 1534 
                   goto ldv_54663; else 
#line 1537 
                                        goto ldv_54665;
  ldv_54665: 
#line 1538 
  ;
  
#line 1539 
  return;
}


#line 1603 
void __compiletime_assert_1603(void);


#line 1621 
void __compiletime_assert_1622(void);


#line 1626 
void __compiletime_assert_1626(void);


#line 1632 
void __compiletime_assert_1633(void);


#line 1637 
void __compiletime_assert_1637(void);


#line 1642 
void __compiletime_assert_1643(void);


#line 1658 
void __compiletime_assert_1663(void);


#line 1581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans, u32 txq_bm)
{
  int __retres;
  struct iwl_txq *txq;
  struct iwl_queue *q;
  int cnt;
  u32 scd_sram_addr;
  u8 buf[16U];
  u32 tmp_10;
  
#line 1583 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1587 
  unsigned long now = jiffies;
  
#line 1590 
  int ret = 0;
  
#line 1593 
  cnt = 0;
  
#line 1593 
  goto ldv_54716;
  ldv_54715: 
#line 1594 
  ;
  {
    u8 wr_ptr;
    int tmp_1;
    int volatile *tmp_2;
    int volatile *tmp_6;
    
#line 1596 
    if ((int)trans_pcie->cmd_queue == cnt) 
#line 1597 
                                           goto ldv_54679; else ;
    
#line 1598 
    if (0 != 0) {
      int tmp;
      
#line 1598 
      tmp = constant_test_bit((long)cnt,(unsigned long const volatile *)(& trans_pcie->queue_used));
      
#line 1598 
      tmp_1 = tmp == 0;
    }
    else {
      int tmp_0;
      
#line 1598 
      tmp_0 = variable_test_bit((long)cnt,(unsigned long const volatile *)(& trans_pcie->queue_used));
      
#line 1598 
      tmp_1 = tmp_0 == 0;
    }
    
#line 1598 
    if (tmp_1) 
#line 1599 
               goto ldv_54679; else ;
    
#line 1600 
    if ((((unsigned long)txq_bm >> cnt) & 1UL) == 0UL) 
#line 1601 
                                                       goto ldv_54679; else ;
    {
      
#line 1603 
      bool __cond = (_Bool)((int)*("Emptying queue %d...\n" + 20UL) != 10);
      
#line 1603 
      if ((int)__cond != 0) 
#line 1603 
                            __compiletime_assert_1603(); else ;
    }
    
#line 1603 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_trans_pcie_wait_txq_empty","Emptying queue %d...\n",cnt);
    
#line 1604 
    txq = trans_pcie->txq + cnt;
    
#line 1605 
    q = & txq->q;
    {
      
#line 1606 
      int __var = 0;
      
#line 1606 
      tmp_2 = (int volatile *)(& q->write_ptr);
    }
    
#line 1606 
    wr_ptr = (unsigned char)*tmp_2;
    
#line 1608 
    goto ldv_54704;
    ldv_54703: 
#line 1609 
    ;
    {
      int volatile *tmp_3;
      int tmp_5;
      {
        
#line 1611 
        int __var_0 = 0;
        
#line 1611 
        tmp_3 = (int volatile *)(& q->write_ptr);
      }
      
#line 1611 
      u8 write_ptr = (unsigned char)*tmp_3;
      {
        bool __warned;
        
#line 1613 
        int __ret_warn_once = (int)wr_ptr != (int)write_ptr;
        
#line 1613 
        if ((long)(__ret_warn_once != 0) != 0L) {
          int tmp_4;
          {
            
#line 1613 
            int __ret_warn_on = ! __warned;
            
#line 1613 
            if ((long)(__ret_warn_on != 0) != 0L) 
#line 1613 
                                                  warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",1615,"WR pointer moved while flushing %d -> %d\n",(int)wr_ptr,(int)write_ptr); else ;
            
#line 1613 
            tmp_4 = (long)(__ret_warn_on != 0);
          }
          
#line 1613 
          if ((long)tmp_4 != 0L) 
#line 1613 
                                 __warned = (_Bool)1; else ;
        }
        else ;
        
#line 1613 
        tmp_5 = (long)(__ret_warn_once != 0);
      }
      
#line 1613 
      if ((long)tmp_5 != 0L) {
        
#line 1616 
        __retres = -110;
        
#line 1616 
        goto return_label;
      }
      else ;
      
#line 1617 
      msleep(1U);
    }
    ldv_54704: 
#line 1619 
    ;
    {
      
#line 1608 
      int __var_1 = 0;
      
#line 1608 
      tmp_6 = (int volatile *)(& q->write_ptr);
    }
    
#line 1608 
    ;
    
#line 1608 
    if (q->read_ptr != *tmp_6) {
      int tmp_7;
      {
        unsigned long __dummy;
        unsigned long volatile __dummy2;
        
#line 1609 
        tmp_7 = 1;
      }
      
#line 1608 
      if (tmp_7 == 0) 
#line 1608 
                      goto _LOR;
      else {
        int tmp_8;
        {
          unsigned long __dummy_0;
          unsigned long __dummy2_0;
          
#line 1609 
          tmp_8 = 1;
        }
        
#line 1609 
        if (tmp_8 == 0) 
#line 1608 
                        goto _LOR;
        else {
          unsigned long tmp_9;
          
#line 1609 
          tmp_9 = msecs_to_jiffies(2000U);
          
#line 1609 
          ;
          
#line 1609 
          if ((long)((tmp_9 + now) - jiffies) >= 0L) _LOR: 
#line 1611 
                                                           goto ldv_54703; else 
                                                                    
#line 1614 
                                                                    goto ldv_54705;
        }
      }
    }
    else 
#line 1614 
         goto ldv_54705;
    ldv_54705: 
#line 1615 
    ;
    
#line 1620 
    if (q->read_ptr != q->write_ptr) {
      {
        
#line 1621 
        bool __cond_0 = (_Bool)((int)*("fail to flush all tx fifo queues Q %d\n" + 37UL) != 10);
        
#line 1621 
        if ((int)__cond_0 != 0) 
#line 1621 
                                __compiletime_assert_1622(); else ;
      }
      
#line 1621 
      __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"fail to flush all tx fifo queues Q %d\n",cnt);
      
#line 1623 
      ret = -110;
      
#line 1624 
      goto ldv_54710;
    }
    else ;
    {
      
#line 1626 
      bool __cond_1 = (_Bool)((int)*("Queue %d is now empty.\n" + 22UL) != 10);
      
#line 1626 
      if ((int)__cond_1 != 0) 
#line 1626 
                              __compiletime_assert_1626(); else ;
    }
    
#line 1626 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_trans_pcie_wait_txq_empty","Queue %d is now empty.\n",cnt);
  }
  ldv_54679: 
#line 1628 
  ;
  
#line 1593 
  cnt += 1;
  ldv_54716: 
#line 1594 
  ;
  
#line 1593 
  if (((trans->cfg)->base_params)->num_of_queues > cnt) 
#line 1595 
                                                        goto ldv_54715; else 
                                                                    
#line 1598 
                                                                    goto ldv_54710;
  ldv_54710: 
#line 1599 
  ;
  
#line 1629 
  if (ret == 0) {
    
#line 1630 
    __retres = 0;
    
#line 1630 
    goto return_label;
  }
  else ;
  {
    
#line 1632 
    bool __cond_2 = (_Bool)((int)*("Current SW read_ptr %d write_ptr %d\n" + 35UL) != 10);
    
#line 1632 
    if ((int)__cond_2 != 0) 
#line 1632 
                            __compiletime_assert_1633(); else ;
  }
  
#line 1632 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Current SW read_ptr %d write_ptr %d\n",txq->q.read_ptr,txq->q.write_ptr);
  
#line 1635 
  scd_sram_addr = trans_pcie->scd_base_addr + (txq->q.id + 106U) * 16U;
  {
    
#line 1637 
    bool __cond_3 = (_Bool)0;
    
#line 1637 
    if ((int)__cond_3 != 0) 
#line 1637 
                            __compiletime_assert_1637(); else ;
  }
  
#line 1637 
  iwl_trans_read_mem(trans,scd_sram_addr,(void *)(& buf),4);
  
#line 1639 
  print_hex_dump("\001","iwl data: ",2,16,1,(void const *)(& buf),16UL,(_Bool)1);
  
#line 1641 
  cnt = 0;
  
#line 1641 
  goto ldv_54730;
  ldv_54729: 
#line 1642 
  ;
  {
    
#line 1642 
    bool __cond_4 = (_Bool)((int)*("FH TRBs(%d) = 0x%08x\n" + 20UL) != 10);
    
#line 1642 
    if ((int)__cond_4 != 0) 
#line 1642 
                            __compiletime_assert_1643(); else ;
  }
  
#line 1642 
  tmp_10 = iwl_read_direct32(trans,(unsigned int)((cnt + 1622) * 4));
  
#line 1642 
  ;
  
#line 1642 
  ;
  
#line 1642 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"FH TRBs(%d) = 0x%08x\n",cnt,tmp_10);
  
#line 1641 
  cnt += 1;
  ldv_54730: 
#line 1642 
  ;
  
#line 1641 
  if (cnt <= 7) 
#line 1643 
                goto ldv_54729; else 
#line 1646 
                                     goto ldv_54731;
  ldv_54731: 
#line 1647 
  ;
  
#line 1645 
  cnt = 0;
  
#line 1645 
  goto ldv_54741;
  ldv_54740: 
#line 1646 
  ;
  {
    u32 tmp_12;
    unsigned int tmp_11;
    u32 tmp_15;
    unsigned int tmp_14;
    u32 tmp_17;
    unsigned int tmp_16;
    char *tmp_18;
    
#line 1646 
    tmp_11 = SCD_QUEUE_STATUS_BITS((unsigned int)cnt);
    
#line 1646 
    ;
    
#line 1646 
    tmp_12 = iwl_read_prph(trans,tmp_11);
    
#line 1646 
    u32 status = tmp_12;
    
#line 1647 
    u8 fifo = (unsigned char)((unsigned int)((unsigned char)status) & 7U);
    
#line 1648 
    bool active = (_Bool)(((unsigned long)status & 8UL) != 0UL);
    
#line 1649 
    u32 tbl_dw = iwl_trans_read_mem32(trans,trans_pcie->scd_base_addr + ((unsigned int)((cnt + 1008) * 2) & 65532U));
    
#line 1653 
    if ((cnt & 1) != 0) 
#line 1654 
                        tbl_dw >>= 16; else 
#line 1656 
                                            tbl_dw &= 65535U;
    {
      
#line 1658 
      bool __cond_5 = (_Bool)((int)*("Q %d is %sactive and mapped to fifo %d ra_tid 0x%04x [%d,%d]\n" + 60UL) != 10);
      
#line 1658 
      if ((int)__cond_5 != 0) 
#line 1658 
                              __compiletime_assert_1663(); else ;
    }
    
#line 1658 
    tmp_14 = SCD_QUEUE_WRPTR((unsigned int)cnt);
    
#line 1658 
    ;
    
#line 1658 
    tmp_15 = iwl_read_prph(trans,tmp_14);
    
#line 1658 
    tmp_16 = SCD_QUEUE_RDPTR((unsigned int)cnt);
    
#line 1658 
    ;
    
#line 1658 
    tmp_17 = iwl_read_prph(trans,tmp_16);
    
#line 1658 
    ;
    
#line 1658 
    ;
    
#line 1658 
    if ((int)active != 0) 
#line 1658 
                          tmp_18 = (char *)""; else 
#line 1658 
                                                    tmp_18 = (char *)"in";
    
#line 1658 
    ;
    
#line 1658 
    ;
    
#line 1658 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Q %d is %sactive and mapped to fifo %d ra_tid 0x%04x [%d,%d]\n",cnt,tmp_18,(int)fifo,tbl_dw,tmp_17 & 255U,tmp_15);
  }
  
#line 1645 
  cnt += 1;
  ldv_54741: 
#line 1646 
  ;
  
#line 1645 
  if (((trans->cfg)->base_params)->num_of_queues > cnt) 
#line 1647 
                                                        goto ldv_54740; else 
                                                                    
#line 1650 
                                                                    goto ldv_54742;
  ldv_54742: 
#line 1651 
  ;
  
#line 1666 
  __retres = ret;
  return_label: 
#line 1666 
                return __retres;
}


#line 1669  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static void iwl_trans_pcie_set_bits_mask(struct iwl_trans *trans, u32 reg, u32 mask, u32 value)
{
  unsigned long flags;
  
#line 1672 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1675 
  ldv___ldv_spin_lock_91(& trans_pcie->reg_lock);
  
#line 1676 
  __iwl_trans_pcie_set_bits_mask(trans,reg,mask,value);
  
#line 1677 
  ldv_spin_unlock_irqrestore_92(& trans_pcie->reg_lock,flags);
  
#line 1678 
  return;
}


#line 1689 
void __compiletime_assert_1689(void);


#line 1680  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
void iwl_trans_pcie_ref(struct iwl_trans *trans)
{
  unsigned long flags;
  
#line 1682 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1685 
  if ((int)iwlwifi_mod_params.d0i3_disable != 0) 
#line 1686 
                                                 goto return_label; else ;
  
#line 1688 
  ldv___ldv_spin_lock_93(& trans_pcie->ref_lock);
  {
    
#line 1689 
    bool __cond = (_Bool)((int)*("ref_counter: %d\n" + 15UL) != 10);
    
#line 1689 
    if ((int)__cond != 0) 
#line 1689 
                          __compiletime_assert_1689(); else ;
  }
  
#line 1689 
  __iwl_dbg(trans->dev,1024U,(_Bool)0,"iwl_trans_pcie_ref","ref_counter: %d\n",trans_pcie->ref_count);
  
#line 1690 
  trans_pcie->ref_count += 1U;
  
#line 1691 
  ldv_spin_unlock_irqrestore_94(& trans_pcie->ref_lock,flags);
  return_label: 
#line 1692 
                return;
}


#line 1703 
void __compiletime_assert_1703(void);


#line 1694  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
void iwl_trans_pcie_unref(struct iwl_trans *trans)
{
  unsigned long flags;
  int tmp_0;
  
#line 1696 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1699 
  if ((int)iwlwifi_mod_params.d0i3_disable != 0) 
#line 1700 
                                                 goto return_label; else ;
  
#line 1702 
  ldv___ldv_spin_lock_95(& trans_pcie->ref_lock);
  {
    
#line 1703 
    bool __cond = (_Bool)((int)*("ref_counter: %d\n" + 15UL) != 10);
    
#line 1703 
    if ((int)__cond != 0) 
#line 1703 
                          __compiletime_assert_1703(); else ;
  }
  
#line 1703 
  __iwl_dbg(trans->dev,1024U,(_Bool)0,"iwl_trans_pcie_unref","ref_counter: %d\n",trans_pcie->ref_count);
  {
    bool __warned;
    
#line 1704 
    int __ret_warn_once = trans_pcie->ref_count == 0U;
    
#line 1704 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 1704 
        int __ret_warn_on = ! __warned;
        
#line 1704 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 1704 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c",1704); else ;
        
#line 1704 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 1704 
      if ((long)tmp != 0L) 
#line 1704 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 1704 
    tmp_0 = (long)(__ret_warn_once != 0);
  }
  
#line 1704 
  if ((long)tmp_0 != 0L) {
    
#line 1705 
    ldv_spin_unlock_irqrestore_96(& trans_pcie->ref_lock,flags);
    
#line 1706 
    goto return_label;
  }
  else ;
  
#line 1708 
  trans_pcie->ref_count -= 1U;
  
#line 1709 
  ldv_spin_unlock_irqrestore_97(& trans_pcie->ref_lock,flags);
  return_label: 
#line 1710 
                return;
}


#line 1712  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static char const *get_csr_string(int cmd)
{
  char const *__retres;
  
#line 1715 
  switch (cmd) {
    case 0: 
#line 1716 
    ;
    
#line 1716 
    __retres = "CSR_HW_IF_CONFIG_REG";
    
#line 1716 
    goto return_label;
    case 4: 
#line 1717 
    ;
    
#line 1717 
    __retres = "CSR_INT_COALESCING";
    
#line 1717 
    goto return_label;
    case 8: 
#line 1718 
    ;
    
#line 1718 
    __retres = "CSR_INT";
    
#line 1718 
    goto return_label;
    case 12: 
#line 1719 
    ;
    
#line 1719 
    __retres = "CSR_INT_MASK";
    
#line 1719 
    goto return_label;
    case 16: 
#line 1720 
    ;
    
#line 1720 
    __retres = "CSR_FH_INT_STATUS";
    
#line 1720 
    goto return_label;
    case 24: 
#line 1721 
    ;
    
#line 1721 
    __retres = "CSR_GPIO_IN";
    
#line 1721 
    goto return_label;
    case 32: 
#line 1722 
    ;
    
#line 1722 
    __retres = "CSR_RESET";
    
#line 1722 
    goto return_label;
    case 36: 
#line 1723 
    ;
    
#line 1723 
    __retres = "CSR_GP_CNTRL";
    
#line 1723 
    goto return_label;
    case 40: 
#line 1724 
    ;
    
#line 1724 
    __retres = "CSR_HW_REV";
    
#line 1724 
    goto return_label;
    case 44: 
#line 1725 
    ;
    
#line 1725 
    __retres = "CSR_EEPROM_REG";
    
#line 1725 
    goto return_label;
    case 48: 
#line 1726 
    ;
    
#line 1726 
    __retres = "CSR_EEPROM_GP";
    
#line 1726 
    goto return_label;
    case 52: 
#line 1727 
    ;
    
#line 1727 
    __retres = "CSR_OTP_GP_REG";
    
#line 1727 
    goto return_label;
    case 60: 
#line 1728 
    ;
    
#line 1728 
    __retres = "CSR_GIO_REG";
    
#line 1728 
    goto return_label;
    case 72: 
#line 1729 
    ;
    
#line 1729 
    __retres = "CSR_GP_UCODE_REG";
    
#line 1729 
    goto return_label;
    case 80: 
#line 1730 
    ;
    
#line 1730 
    __retres = "CSR_GP_DRIVER_REG";
    
#line 1730 
    goto return_label;
    case 84: 
#line 1731 
    ;
    
#line 1731 
    __retres = "CSR_UCODE_DRV_GP1";
    
#line 1731 
    goto return_label;
    case 96: 
#line 1732 
    ;
    
#line 1732 
    __retres = "CSR_UCODE_DRV_GP2";
    
#line 1732 
    goto return_label;
    case 148: 
#line 1733 
    ;
    
#line 1733 
    __retres = "CSR_LED_REG";
    
#line 1733 
    goto return_label;
    case 160: 
#line 1734 
    ;
    
#line 1734 
    __retres = "CSR_DRAM_INT_TBL_REG";
    
#line 1734 
    goto return_label;
    case 256: 
#line 1735 
    ;
    
#line 1735 
    __retres = "CSR_GIO_CHICKEN_BITS";
    
#line 1735 
    goto return_label;
    case 524: 
#line 1736 
    ;
    
#line 1736 
    __retres = "CSR_ANA_PLL_CFG";
    
#line 1736 
    goto return_label;
    case 556: 
#line 1737 
    ;
    
#line 1737 
    __retres = "CSR_HW_REV_WA_REG";
    
#line 1737 
    goto return_label;
    case 552: 
#line 1738 
    ;
    
#line 1738 
    __retres = "CSR_MONITOR_STATUS_REG";
    
#line 1738 
    goto return_label;
    case 576: 
#line 1739 
    ;
    
#line 1739 
    __retres = "CSR_DBG_HPET_MEM_REG";
    
#line 1739 
    goto return_label;
    default: 
#line 1740 
    ;
    
#line 1741 
    __retres = "UNKNOWN";
    
#line 1741 
    goto return_label;
  }
  return_label: 
#line 1715 
                return __retres;
}


#line 1775 
void __compiletime_assert_1775(void);


#line 1776 
void __compiletime_assert_1777(void);


#line 1779 
void __compiletime_assert_1781(void);


#line 1746  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
void iwl_pcie_dump_csr(struct iwl_trans *trans)
{
  int i;
  u32 tmp;
  char const *tmp_0;
  
#line 1749 
  u32 const csr_tbl[24U] = {0U, 4U, 8U, 12U, 16U, 24U, 32U, 36U, 40U, 44U, 48U, 52U, 60U, 72U, 80U, 84U, 96U, 148U, 160U, 256U, 524U, 552U, 556U, 576U};
  {
    
#line 1775 
    bool __cond = (_Bool)((int)*("CSR values:\n" + 11UL) != 10);
    
#line 1775 
    if ((int)__cond != 0) 
#line 1775 
                          __compiletime_assert_1775(); else ;
  }
  
#line 1775 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"CSR values:\n");
  {
    
#line 1776 
    bool __cond_0 = (_Bool)((int)*("(2nd byte of CSR_INT_COALESCING is " + 56UL) != 10);
    
#line 1776 
    if ((int)__cond_0 != 0) 
#line 1776 
                            __compiletime_assert_1777(); else ;
  }
  
#line 1776 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"(2nd byte of CSR_INT_COALESCING is ");
  
#line 1778 
  i = 0;
  
#line 1778 
  goto ldv_54825;
  ldv_54824: 
#line 1779 
  ;
  {
    
#line 1779 
    bool __cond_1 = (_Bool)((int)*("  %25s: 0X%08x\n" + 14UL) != 10);
    
#line 1779 
    if ((int)__cond_1 != 0) 
#line 1779 
                            __compiletime_assert_1781(); else ;
  }
  
#line 1779 
  tmp = iwl_read32_2(trans,csr_tbl[i]);
  
#line 1779 
  tmp_0 = get_csr_string((int)csr_tbl[i]);
  
#line 1779 
  ;
  
#line 1779 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"  %25s: 0X%08x\n",tmp_0,tmp);
  
#line 1778 
  i += 1;
  ldv_54825: 
#line 1779 
  ;
  
#line 1778 
  if ((unsigned int)i <= 23U) 
#line 1780 
                              goto ldv_54824; else 
#line 1783 
                                                   goto ldv_54826;
  ldv_54826: 
#line 1784 
  ;
  
#line 1785 
  return;
}


#line 1816  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static ssize_t iwl_dbgfs_tx_queue_read(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  struct iwl_txq *txq;
  struct iwl_queue *q;
  char *buf;
  int cnt;
  int ret;
  size_t bufsz;
  int tmp_7;
  char *tmp_0;
  int tmp_3;
  int tmp_6;
  ssize_t tmp_8;
  
#line 1820 
  struct iwl_trans *trans = (struct iwl_trans *)file->private_data;
  
#line 1821 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1825 
  int pos = 0;
  
#line 1830 
  bufsz = (unsigned long)((trans->cfg)->base_params)->num_of_queues * 75UL;
  
#line 1832 
  if (trans_pcie->txq == (struct iwl_txq *)0) {
    
#line 1833 
    __retres = -11L;
    
#line 1833 
    goto return_label;
  }
  else ;
  
#line 1835 
  buf = (char *)kzalloc_2(bufsz,208U);
  
#line 1836 
  if (buf == (char *)0) {
    
#line 1837 
    __retres = -12L;
    
#line 1837 
    goto return_label;
  }
  else ;
  
#line 1839 
  cnt = 0;
  
#line 1839 
  goto ldv_54843;
  ldv_54842: 
#line 1840 
  ;
  
#line 1840 
  txq = trans_pcie->txq + cnt;
  
#line 1841 
  q = & txq->q;
  
#line 1848 
  if ((int)trans_pcie->cmd_queue == cnt) 
#line 1848 
                                         tmp_0 = (char *)" HCMD"; else 
                                                                    
#line 1848 
                                                                    tmp_0 = (char *)"";
  
#line 1842 
  ;
  
#line 1842 
  ;
  
#line 1845 
  if (0 != 0) {
    int tmp_1;
    
#line 1846 
    tmp_1 = constant_test_bit((long)cnt,(unsigned long const volatile *)(& trans_pcie->queue_stopped));
    
#line 1845 
    tmp_3 = tmp_1 != 0;
  }
  else {
    int tmp_2;
    
#line 1846 
    tmp_2 = variable_test_bit((long)cnt,(unsigned long const volatile *)(& trans_pcie->queue_stopped));
    
#line 1845 
    tmp_3 = tmp_2 != 0;
  }
  
#line 1844 
  if (0 != 0) {
    int tmp_4;
    
#line 1845 
    tmp_4 = constant_test_bit((long)cnt,(unsigned long const volatile *)(& trans_pcie->queue_used));
    
#line 1844 
    tmp_6 = tmp_4 != 0;
  }
  else {
    int tmp_5;
    
#line 1845 
    tmp_5 = variable_test_bit((long)cnt,(unsigned long const volatile *)(& trans_pcie->queue_used));
    
#line 1844 
    tmp_6 = tmp_5 != 0;
  }
  
#line 1842 
  ;
  
#line 1842 
  ;
  
#line 1842 
  ;
  
#line 1842 
  ;
  
#line 1842 
  ;
  
#line 1842 
  tmp_7 = scnprintf(buf + pos,bufsz - (unsigned long)pos,"hwq %.2d: read=%u write=%u use=%d stop=%d need_update=%d frozen=%d%s\n",cnt,q->read_ptr,q->write_ptr,tmp_6,tmp_3,(int)txq->need_update,(int)txq->frozen,tmp_0);
  
#line 1848 
  pos = tmp_7 + pos;
  
#line 1839 
  cnt += 1;
  ldv_54843: 
#line 1840 
  ;
  
#line 1839 
  if (((trans->cfg)->base_params)->num_of_queues > cnt) 
#line 1841 
                                                        goto ldv_54842; else 
                                                                    
#line 1844 
                                                                    goto ldv_54844;
  ldv_54844: 
#line 1845 
  ;
  
#line 1850 
  tmp_8 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)pos);
  
#line 1850 
  ret = (int)tmp_8;
  
#line 1851 
  kfree((void const *)buf);
  
#line 1852 
  __retres = (long)ret;
  return_label: 
#line 1852 
                return __retres;
}


#line 1855  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static ssize_t iwl_dbgfs_rx_queue_read(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  char buf[256U];
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  ssize_t tmp_6;
  
#line 1859 
  struct iwl_trans *trans = (struct iwl_trans *)file->private_data;
  
#line 1860 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1861 
  struct iwl_rxq *rxq = & trans_pcie->rxq;
  
#line 1863 
  int pos = 0;
  
#line 1864 
  size_t const bufsz = 256UL;
  
#line 1866 
  tmp = scnprintf((char *)(& buf) + pos,256UL - (unsigned long)pos,"read: %u\n",rxq->read);
  
#line 1867 
  pos = tmp + pos;
  
#line 1868 
  tmp_0 = scnprintf((char *)(& buf) + pos,256UL - (unsigned long)pos,"write: %u\n",rxq->write);
  
#line 1869 
  pos = tmp_0 + pos;
  
#line 1870 
  tmp_1 = scnprintf((char *)(& buf) + pos,256UL - (unsigned long)pos,"write_actual: %u\n",rxq->write_actual);
  
#line 1871 
  pos = tmp_1 + pos;
  
#line 1872 
  tmp_2 = scnprintf((char *)(& buf) + pos,256UL - (unsigned long)pos,"need_update: %d\n",(int)rxq->need_update);
  
#line 1873 
  pos = tmp_2 + pos;
  
#line 1874 
  tmp_3 = scnprintf((char *)(& buf) + pos,256UL - (unsigned long)pos,"free_count: %u\n",rxq->free_count);
  
#line 1875 
  pos = tmp_3 + pos;
  
#line 1876 
  if (rxq->rb_stts != (struct iwl_rb_status *)0) {
    int tmp_4;
    
#line 1877 
    tmp_4 = scnprintf((char *)(& buf) + pos,256UL - (unsigned long)pos,"closed_rb_num: %u\n",(int)(rxq->rb_stts)->closed_rb_num & 4095);
    
#line 1878 
    pos = tmp_4 + pos;
  }
  else {
    int tmp_5;
    
#line 1880 
    tmp_5 = scnprintf((char *)(& buf) + pos,256UL - (unsigned long)pos,"closed_rb_num: Not Allocated\n");
    
#line 1881 
    pos = tmp_5 + pos;
  }
  
#line 1883 
  tmp_6 = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)(& buf),(unsigned long)pos);
  
#line 1883 
  return tmp_6;
}


#line 1886  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static ssize_t iwl_dbgfs_interrupt_read(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  char *buf;
  ssize_t ret;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  
#line 1890 
  struct iwl_trans *trans = (struct iwl_trans *)file->private_data;
  
#line 1891 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1892 
  struct isr_statistics *isr_stats = & trans_pcie->isr_stats;
  
#line 1894 
  int pos = 0;
  
#line 1896 
  int bufsz = 1536;
  
#line 1899 
  buf = (char *)kzalloc_2((unsigned long)bufsz,208U);
  
#line 1900 
  if (buf == (char *)0) {
    
#line 1901 
    __retres = -12L;
    
#line 1901 
    goto return_label;
  }
  else ;
  
#line 1903 
  tmp_0 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"Interrupt Statistics Report:\n");
  
#line 1904 
  pos = tmp_0 + pos;
  
#line 1906 
  tmp_1 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"HW Error:\t\t\t %u\n",isr_stats->hw);
  
#line 1907 
  pos = tmp_1 + pos;
  
#line 1908 
  tmp_2 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"SW Error:\t\t\t %u\n",isr_stats->sw);
  
#line 1909 
  pos = tmp_2 + pos;
  
#line 1910 
  if (isr_stats->sw != 0U || isr_stats->hw != 0U) {
    int tmp_3;
    
#line 1911 
    tmp_3 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"\tLast Restarting Code:  0x%X\n",isr_stats->err_code);
    
#line 1913 
    pos = tmp_3 + pos;
  }
  else ;
  
#line 1916 
  tmp_4 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"Frame transmitted:\t\t %u\n",isr_stats->sch);
  
#line 1917 
  pos = tmp_4 + pos;
  
#line 1918 
  tmp_5 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"Alive interrupt:\t\t %u\n",isr_stats->alive);
  
#line 1919 
  pos = tmp_5 + pos;
  
#line 1921 
  tmp_6 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"HW RF KILL switch toggled:\t %u\n",isr_stats->rfkill);
  
#line 1922 
  pos = tmp_6 + pos;
  
#line 1924 
  tmp_7 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"CT KILL:\t\t\t %u\n",isr_stats->ctkill);
  
#line 1925 
  pos = tmp_7 + pos;
  
#line 1927 
  tmp_8 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"Wakeup Interrupt:\t\t %u\n",isr_stats->wakeup);
  
#line 1928 
  pos = tmp_8 + pos;
  
#line 1930 
  tmp_9 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"Rx command responses:\t\t %u\n",isr_stats->rx);
  
#line 1931 
  pos = tmp_9 + pos;
  
#line 1933 
  tmp_10 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"Tx/FH interrupt:\t\t %u\n",isr_stats->tx);
  
#line 1934 
  pos = tmp_10 + pos;
  
#line 1936 
  tmp_11 = scnprintf(buf + pos,(unsigned long)(bufsz - pos),"Unexpected INTA:\t\t %u\n",isr_stats->unhandled);
  
#line 1937 
  pos = tmp_11 + pos;
  
#line 1939 
  ret = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)pos);
  
#line 1940 
  kfree((void const *)buf);
  
#line 1941 
  __retres = ret;
  return_label: 
#line 1941 
                return __retres;
}


#line 1944  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static ssize_t iwl_dbgfs_interrupt_write(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  char buf[8U];
  int buf_size;
  u32 reset_flag;
  unsigned long tmp_0;
  unsigned long tmp_1;
  int tmp_2;
  
#line 1948 
  struct iwl_trans *trans = (struct iwl_trans *)file->private_data;
  
#line 1949 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1950 
  struct isr_statistics *isr_stats = & trans_pcie->isr_stats;
  
#line 1956 
  memset((void *)(& buf),0,8UL);
  {
    unsigned long tmp;
    
#line 1957 
    size_t _min1 = count;
    
#line 1957 
    unsigned long _min2 = 7UL;
    
#line 1957 
    if (_min1 < _min2) 
#line 1957 
                       tmp = _min1; else 
#line 1957 
                                         tmp = _min2;
    
#line 1957 
    tmp_0 = tmp;
  }
  
#line 1957 
  buf_size = (int)tmp_0;
  
#line 1958 
  tmp_1 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)buf_size);
  
#line 1958 
  if (tmp_1 != 0UL) {
    
#line 1959 
    __retres = -14L;
    
#line 1959 
    goto return_label;
  }
  else ;
  
#line 1960 
  tmp_2 = sscanf((char const *)(& buf),"%x",& reset_flag);
  
#line 1960 
  if (tmp_2 != 1) {
    
#line 1961 
    __retres = -14L;
    
#line 1961 
    goto return_label;
  }
  else ;
  
#line 1962 
  if (reset_flag == 0U) 
#line 1963 
                        memset((void *)isr_stats,0,44UL); else ;
  
#line 1965 
  __retres = (long)count;
  return_label: 
#line 1965 
                return __retres;
}


#line 1968  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static ssize_t iwl_dbgfs_csr_write(struct file *file, char const *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  char buf[8U];
  int buf_size;
  int csr;
  unsigned long tmp_0;
  unsigned long tmp_1;
  int tmp_2;
  
#line 1972 
  struct iwl_trans *trans = (struct iwl_trans *)file->private_data;
  
#line 1977 
  memset((void *)(& buf),0,8UL);
  {
    unsigned long tmp;
    
#line 1978 
    size_t _min1 = count;
    
#line 1978 
    unsigned long _min2 = 7UL;
    
#line 1978 
    if (_min1 < _min2) 
#line 1978 
                       tmp = _min1; else 
#line 1978 
                                         tmp = _min2;
    
#line 1978 
    tmp_0 = tmp;
  }
  
#line 1978 
  buf_size = (int)tmp_0;
  
#line 1979 
  tmp_1 = copy_from_user((void *)(& buf),(void const *)user_buf,(unsigned long)buf_size);
  
#line 1979 
  if (tmp_1 != 0UL) {
    
#line 1980 
    __retres = -14L;
    
#line 1980 
    goto return_label;
  }
  else ;
  
#line 1981 
  tmp_2 = sscanf((char const *)(& buf),"%d",& csr);
  
#line 1981 
  if (tmp_2 != 1) {
    
#line 1982 
    __retres = -14L;
    
#line 1982 
    goto return_label;
  }
  else ;
  
#line 1984 
  iwl_pcie_dump_csr(trans);
  
#line 1986 
  __retres = (long)count;
  return_label: 
#line 1986 
                return __retres;
}


#line 1989  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static ssize_t iwl_dbgfs_fh_reg_read(struct file *file, char *user_buf, size_t count, loff_t *ppos)
{
  ssize_t __retres;
  ssize_t ret;
  int tmp;
  
#line 1993 
  struct iwl_trans *trans = (struct iwl_trans *)file->private_data;
  
#line 1994 
  char *buf = (char *)0;
  
#line 1997 
  tmp = iwl_dump_fh(trans,& buf);
  
#line 1997 
  ret = (long)tmp;
  
#line 1998 
  if (ret < 0L) {
    
#line 1999 
    __retres = ret;
    
#line 1999 
    goto return_label;
  }
  else ;
  
#line 2000 
  if (buf == (char *)0) {
    
#line 2001 
    __retres = -22L;
    
#line 2001 
    goto return_label;
  }
  else ;
  
#line 2002 
  ret = simple_read_from_buffer((void *)user_buf,count,ppos,(void const *)buf,(unsigned long)ret);
  
#line 2003 
  kfree((void const *)buf);
  
#line 2004 
  __retres = ret;
  return_label: 
#line 2004 
                return __retres;
}


#line 2007  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static struct file_operations const iwl_dbgfs_interrupt_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & iwl_dbgfs_interrupt_read, .write = & iwl_dbgfs_interrupt_write, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 2008  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static struct file_operations const iwl_dbgfs_fh_reg_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & iwl_dbgfs_fh_reg_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 2009  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static struct file_operations const iwl_dbgfs_rx_queue_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & iwl_dbgfs_rx_queue_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 2010  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static struct file_operations const iwl_dbgfs_tx_queue_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = & iwl_dbgfs_tx_queue_read, .write = (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 2011  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static struct file_operations const iwl_dbgfs_csr_ops = {.owner = (struct module *)0, .llseek = & generic_file_llseek, .read = (ssize_t (*)(struct file *, char *, size_t , loff_t *))0, .write = & iwl_dbgfs_csr_write, .read_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .write_iter = (ssize_t (*)(struct kiocb *, struct iov_iter *))0, .iterate = (int (*)(struct file *, struct dir_context *))0, .poll = (unsigned int (*)(struct file *, struct poll_table_struct *))0, .unlocked_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .compat_ioctl = (long (*)(struct file *, unsigned int , unsigned long ))0, .mmap = (int (*)(struct file *, struct vm_area_struct *))0, .mremap = (int (*)(struct file *, struct vm_area_struct *))0, .open = & simple_open, .flush = (int (*)(struct file *, fl_owner_t ))0, .release = (int (*)(struct inode *, struct file *))0, .fsync = (int (*)(struct file *, loff_t , loff_t , int ))0, .aio_fsync = (int (*)(struct kiocb *, int ))0, .fasync = (int (*)(int , struct file *, int ))0, .lock = (int (*)(struct file *, int , struct file_lock *))0, .sendpage = (ssize_t (*)(struct file *, struct page *, int , size_t , loff_t *, int ))0, .get_unmapped_area = (unsigned long (*)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ))0, .check_flags = (int (*)(int ))0, .flock = (int (*)(struct file *, int , struct file_lock *))0, .splice_write = (ssize_t (*)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ))0, .splice_read = (ssize_t (*)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ))0, .setlease = (int (*)(struct file *, long , struct file_lock **, void **))0, .fallocate = (long (*)(struct file *, int , loff_t , loff_t ))0, .show_fdinfo = (void (*)(struct seq_file *, struct file *))0};

#line 2028 
void __compiletime_assert_2028(void);


#line 2017  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static int iwl_trans_pcie_dbgfs_register(struct iwl_trans *trans, struct dentry *dir)
{
  int __retres;
  struct dentry *tmp;
  struct dentry *tmp_0;
  struct dentry *tmp_1;
  struct dentry *tmp_2;
  struct dentry *tmp_3;
  
#line 2020 
  tmp = ldv_debugfs_create_file_98("rx_queue",(unsigned short)256,dir,(void *)trans,& iwl_dbgfs_rx_queue_ops);
  
#line 2020 
  if (tmp == (struct dentry *)0) 
#line 2020 
                                 goto err; else ;
  
#line 2021 
  tmp_0 = ldv_debugfs_create_file_99("tx_queue",(unsigned short)256,dir,(void *)trans,& iwl_dbgfs_tx_queue_ops);
  
#line 2021 
  if (tmp_0 == (struct dentry *)0) 
#line 2021 
                                   goto err; else ;
  
#line 2022 
  tmp_1 = ldv_debugfs_create_file_100("interrupt",(unsigned short)384,dir,(void *)trans,& iwl_dbgfs_interrupt_ops);
  
#line 2022 
  if (tmp_1 == (struct dentry *)0) 
#line 2022 
                                   goto err; else ;
  
#line 2023 
  tmp_2 = ldv_debugfs_create_file_101("csr",(unsigned short)128,dir,(void *)trans,& iwl_dbgfs_csr_ops);
  
#line 2023 
  if (tmp_2 == (struct dentry *)0) 
#line 2023 
                                   goto err; else ;
  
#line 2024 
  tmp_3 = ldv_debugfs_create_file_102("fh_reg",(unsigned short)256,dir,(void *)trans,& iwl_dbgfs_fh_reg_ops);
  
#line 2024 
  if (tmp_3 == (struct dentry *)0) 
#line 2024 
                                   goto err; else ;
  
#line 2025 
  __retres = 0;
  
#line 2025 
  goto return_label;
  err: 
#line 2027 
  ;
  {
    
#line 2028 
    bool __cond = (_Bool)((int)*("failed to create the trans debugfs entry\n" + 40UL) != 10);
    
#line 2028 
    if ((int)__cond != 0) 
#line 2028 
                          __compiletime_assert_2028(); else ;
  }
  
#line 2028 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"failed to create the trans debugfs entry\n");
  
#line 2029 
  __retres = -12;
  return_label: 
#line 2029 
                return __retres;
}


#line 2039  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static u32 iwl_trans_pcie_get_cmdlen(struct iwl_tfd *tfd)
{
  int i;
  u16 tmp;
  
#line 2041 
  u32 cmdlen = 0U;
  
#line 2044 
  i = 0;
  
#line 2044 
  goto ldv_54927;
  ldv_54926: 
#line 2045 
  ;
  
#line 2045 
  tmp = iwl_pcie_tfd_tb_get_len(tfd,(unsigned char)((int)((unsigned char)i)));
  
#line 2045 
  cmdlen = (unsigned int)tmp + cmdlen;
  
#line 2044 
  i += 1;
  ldv_54927: 
#line 2045 
  ;
  
#line 2044 
  if (i <= 19) 
#line 2046 
               goto ldv_54926; else 
#line 2049 
                                    goto ldv_54928;
  ldv_54928: 
#line 2050 
  ;
  
#line 2047 
  return cmdlen;
}


#line 2052  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static struct __anonstruct_iwl_prph_dump_addr_5019 const iwl_prph_dump_addr[94U] = {{.start = 10485760U, .end = 10485760U}, {.start = 10485772U, .end = 10485796U}, {.start = 10485804U, .end = 10485820U}, {.start = 10486800U, .end = 10486808U}, {.start = 10486816U, .end = 10486816U}, {.start = 10486824U, .end = 10486824U}, {.start = 10486832U, .end = 10486844U}, {.start = 10486852U, .end = 10486852U}, {.start = 10486976U, .end = 10486988U}, {.start = 10487000U, .end = 10487000U}, {.start = 10487008U, .end = 10487024U}, {.start = 10487872U, .end = 10487872U}, {.start = 10487888U, .end = 10487896U}, {.start = 10489860U, .end = 10489864U}, {.start = 10489872U, .end = 10489872U}, {.start = 10489880U, .end = 10489880U}, {.start = 10489892U, .end = 10489892U}, {.start = 10489900U, .end = 10489908U}, {.start = 10489916U, .end = 10489920U}, {.start = 10489928U, .end = 10490004U}, {.start = 10492928U, .end = 10492960U}, {.start = 10493016U, .end = 10493016U}, {.start = 10493052U, .end = 10493052U}, {.start = 10492968U, .end = 10493012U}, {.start = 10493020U, .end = 10493020U}, {.start = 10493024U, .end = 10493148U}, {.start = 10493152U, .end = 10493196U}, {.start = 10493208U, .end = 10493216U}, {.start = 10493228U, .end = 10493232U}, {.start = 10493248U, .end = 10493276U}, {.start = 10493312U, .end = 10493312U}, {.start = 10493336U, .end = 10493340U}, {.start = 10493352U, .end = 10493352U}, {.start = 10493368U, .end = 10493428U}, {.start = 10493376U, .end = 10493436U}, {.start = 10493440U, .end = 10493484U}, {.start = 10493504U, .end = 10493536U}, {.start = 10493544U, .end = 10493548U}, {.start = 10493556U, .end = 10493556U}, {.start = 10493572U, .end = 10493584U}, {.start = 10493596U, .end = 10493636U}, {.start = 10493648U, .end = 10493664U}, {.start = 10493696U, .end = 10493724U}, {.start = 10493764U, .end = 10493948U}, {.start = 10493952U, .end = 10494024U}, {.start = 10494056U, .end = 10494192U}, {.start = 10494208U, .end = 10494232U}, {.start = 10494272U, .end = 10494284U}, {.start = 10494312U, .end = 10494348U}, {.start = 10494400U, .end = 10494400U}, {.start = 10494976U, .end = 10494992U}, {.start = 10495000U, .end = 10495008U}, {.start = 10495016U, .end = 10495020U}, {.start = 10495028U, .end = 10495028U}, {.start = 10495040U, .end = 10495072U}, {.start = 10495080U, .end = 10495152U}, {.start = 10495176U, .end = 10495180U}, {.start = 10495232U, .end = 10495236U}, {.start = 10495244U, .end = 10495248U}, {.start = 10495296U, .end = 10495316U}, {.start = 10495360U, .end = 10495476U}, {.start = 10495488U, .end = 10495500U}, {.start = 10495560U, .end = 10495568U}, {.start = 10495616U, .end = 10495616U}, {.start = 10495680U, .end = 10495696U}, {.start = 10495744U, .end = 10495756U}, {.start = 10496004U, .end = 10496004U}, {.start = 10496024U, .end = 10496028U}, {.start = 10497024U, .end = 10497460U}, {.start = 10497524U, .end = 10497968U}, {.start = 10498048U, .end = 10498068U}, {.start = 10498076U, .end = 10498092U}, {.start = 10498100U, .end = 10498104U}, {.start = 10498112U, .end = 10498120U}, {.start = 10498144U, .end = 10498152U}, {.start = 10498160U, .end = 10498164U}, {.start = 10498172U, .end = 10498172U}, {.start = 10498176U, .end = 10498180U}, {.start = 10498188U, .end = 10498192U}, {.start = 10498200U, .end = 10498200U}, {.start = 10498208U, .end = 10498208U}, {.start = 10498216U, .end = 10498228U}, {.start = 10498236U, .end = 10498236U}, {.start = 10498240U, .end = 10498348U}, {.start = 10501120U, .end = 10501212U}, {.start = 10503168U, .end = 10503252U}, {.start = 10503264U, .end = 10503284U}, {.start = 10503360U, .end = 10503404U}, {.start = 10503424U, .end = 10503428U}, {.start = 10503440U, .end = 10503480U}, {.start = 10503488U, .end = 10503496U}, {.start = 10503520U, .end = 10503548U}, {.start = 10503568U, .end = 10503576U}, {.start = 10503616U, .end = 10503668U}};

#line 2149  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static u32 iwl_trans_pcie_dump_prph(struct iwl_trans *trans, struct iwl_fw_error_dump_data **data)
{
  u32 __retres;
  struct iwl_fw_error_dump_prph *prph;
  unsigned long flags;
  u32 i;
  bool tmp;
  
#line 2154 
  u32 prph_len = 0U;
  
#line 2156 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 2156 
  if ((long)((int)tmp != 0) == 0L) {
    
#line 2157 
    __retres = 0U;
    
#line 2157 
    goto return_label;
  }
  else ;
  
#line 2159 
  i = 0U;
  
#line 2159 
  goto ldv_54951;
  ldv_54950: 
#line 2160 
  ;
  {
    int reg;
    __le32 *val;
    __le32 *tmp_0;
    
#line 2161 
    int num_bytes_in_chunk = (int)((iwl_prph_dump_addr[i].end - iwl_prph_dump_addr[i].start) + 4U);
    
#line 2166 
    prph_len = (prph_len + (unsigned int)num_bytes_in_chunk) + 12U;
    
#line 2168 
    (*data)->type = 6U;
    
#line 2169 
    (*data)->len = (unsigned int)num_bytes_in_chunk + 4U;
    
#line 2171 
    prph = (struct iwl_fw_error_dump_prph *)(& (*data)->data);
    
#line 2172 
    prph->prph_start = iwl_prph_dump_addr[i].start;
    
#line 2173 
    val = (__le32 *)(& prph->data);
    
#line 2175 
    reg = (int)iwl_prph_dump_addr[i].start;
    
#line 2175 
    goto ldv_54948;
    ldv_54947: 
#line 2176 
    ;
    
#line 2178 
    tmp_0 = val;
    
#line 2178 
    val += 1;
    
#line 2178 
    *tmp_0 = iwl_trans_pcie_read_prph(trans,(unsigned int)reg);
    
#line 2177 
    reg += 4;
    ldv_54948: 
#line 2178 
    ;
    
#line 2176 
    if (iwl_prph_dump_addr[i].end >= (unsigned int)reg) 
#line 2178 
                                                        goto ldv_54947; else 
                                                                    
#line 2181 
                                                                    goto ldv_54949;
    ldv_54949: 
#line 2182 
    ;
    
#line 2180 
    *data = iwl_fw_error_next_data(*data);
  }
  
#line 2159 
  i += 1U;
  ldv_54951: 
#line 2160 
  ;
  
#line 2159 
  if (i <= 93U) 
#line 2161 
                goto ldv_54950; else 
#line 2164 
                                     goto ldv_54952;
  ldv_54952: 
#line 2165 
  ;
  
#line 2183 
  iwl_trans_release_nic_access(trans,& flags);
  
#line 2185 
  __retres = prph_len;
  return_label: 
#line 2185 
                return __retres;
}


#line 2190  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static u32 iwl_trans_pcie_dump_csr(struct iwl_trans *trans, struct iwl_fw_error_dump_data **data)
{
  __le32 *val;
  int i;
  __le32 *tmp;
  
#line 2193 
  u32 csr_len = 600U;
  
#line 2197 
  (*data)->type = 1U;
  
#line 2198 
  (*data)->len = 592U;
  
#line 2199 
  val = (__le32 *)(& (*data)->data);
  
#line 2201 
  i = 0;
  
#line 2201 
  goto ldv_54961;
  ldv_54960: 
#line 2202 
  ;
  
#line 2202 
  tmp = val;
  
#line 2202 
  val += 1;
  
#line 2202 
  *tmp = iwl_trans_pcie_read32(trans,(unsigned int)i);
  
#line 2201 
  i += 4;
  ldv_54961: 
#line 2202 
  ;
  
#line 2201 
  if (i <= 591) 
#line 2203 
                goto ldv_54960; else 
#line 2206 
                                     goto ldv_54962;
  ldv_54962: 
#line 2207 
  ;
  
#line 2204 
  *data = iwl_fw_error_next_data(*data);
  
#line 2206 
  return csr_len;
}


#line 2209  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static u32 iwl_trans_pcie_fh_regs_dump(struct iwl_trans *trans, struct iwl_fw_error_dump_data **data)
{
  u32 __retres;
  unsigned long flags;
  __le32 *val;
  int i;
  bool tmp;
  __le32 *tmp_0;
  
#line 2212 
  u32 fh_regs_len = 4096U;
  
#line 2217 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 2217 
  if ((long)((int)tmp != 0) == 0L) {
    
#line 2218 
    __retres = 0U;
    
#line 2218 
    goto return_label;
  }
  else ;
  
#line 2220 
  (*data)->type = 8U;
  
#line 2221 
  (*data)->len = fh_regs_len;
  
#line 2222 
  val = (__le32 *)(& (*data)->data);
  
#line 2224 
  i = 4096;
  
#line 2224 
  goto ldv_54972;
  ldv_54971: 
#line 2225 
  ;
  
#line 2225 
  tmp_0 = val;
  
#line 2225 
  val += 1;
  
#line 2225 
  *tmp_0 = iwl_trans_pcie_read32(trans,(unsigned int)i);
  
#line 2224 
  i = (int)((unsigned int)i + 4U);
  ldv_54972: 
#line 2225 
  ;
  
#line 2224 
  if (i <= 8191) 
#line 2226 
                 goto ldv_54971; else 
#line 2229 
                                      goto ldv_54973;
  ldv_54973: 
#line 2230 
  ;
  
#line 2227 
  iwl_trans_release_nic_access(trans,& flags);
  
#line 2229 
  *data = iwl_fw_error_next_data(*data);
  
#line 2231 
  __retres = fh_regs_len + 8U;
  return_label: 
#line 2231 
                return __retres;
}


#line 2235  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static u32 iwl_trans_pci_dump_marbh_monitor(struct iwl_trans *trans, struct iwl_fw_error_dump_fw_mon *fw_mon_data, u32 monitor_len)
{
  u32 __retres;
  unsigned long flags;
  u32 i;
  bool tmp;
  
#line 2239 
  u32 buf_size_in_dwords = monitor_len >> 2;
  
#line 2240 
  u32 *buffer = (u32 *)(& fw_mon_data->data);
  
#line 2244 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 2244 
  if ((long)((int)tmp != 0) == 0L) {
    
#line 2245 
    __retres = 0U;
    
#line 2245 
    goto return_label;
  }
  else ;
  
#line 2247 
  __iwl_write_prph(trans,10501216U,1U);
  
#line 2248 
  i = 0U;
  
#line 2248 
  goto ldv_54984;
  ldv_54983: 
#line 2249 
  ;
  
#line 2249 
  *(buffer + i) = __iwl_read_prph(trans,10501212U);
  
#line 2248 
  i += 1U;
  ldv_54984: 
#line 2249 
  ;
  
#line 2248 
  if (i < buf_size_in_dwords) 
#line 2250 
                              goto ldv_54983; else 
#line 2253 
                                                   goto ldv_54985;
  ldv_54985: 
#line 2254 
  ;
  
#line 2250 
  __iwl_write_prph(trans,10501216U,0U);
  
#line 2252 
  iwl_trans_release_nic_access(trans,& flags);
  
#line 2254 
  __retres = monitor_len;
  return_label: 
#line 2254 
                return __retres;
}


#line 2258  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static struct iwl_trans_dump_data *iwl_trans_pcie_dump_data(struct iwl_trans *trans)
{
  struct iwl_trans_dump_data *__retres;
  struct iwl_fw_error_dump_data *data;
  struct iwl_fw_error_dump_txcmd *txcmd;
  struct iwl_trans_dump_data *dump_data;
  u32 len;
  u32 monitor_len;
  int i;
  int ptr;
  u32 tmp_5;
  u32 tmp_6;
  u32 tmp_7;
  
#line 2260 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 2262 
  struct iwl_txq *cmdq = trans_pcie->txq + (int)trans_pcie->cmd_queue;
  
#line 2270 
  len = 4U;
  
#line 2273 
  len = ((unsigned int)((unsigned long)cmdq->q.n_window) * 332U + len) + 8U;
  
#line 2277 
  len += 600U;
  
#line 2280 
  i = 0;
  
#line 2280 
  goto ldv_55003;
  ldv_55002: 
#line 2281 
  ;
  {
    
#line 2282 
    int num_bytes_in_chunk = (int)((iwl_prph_dump_addr[i].end - iwl_prph_dump_addr[i].start) + 4U);
    
#line 2285 
    len = (len + (unsigned int)num_bytes_in_chunk) + 12U;
  }
  
#line 2280 
  i += 1;
  ldv_55003: 
#line 2281 
  ;
  
#line 2280 
  if ((unsigned int)i <= 93U) 
#line 2282 
                              goto ldv_55002; else 
#line 2285 
                                                   goto ldv_55004;
  ldv_55004: 
#line 2286 
  ;
  
#line 2290 
  len += 4104U;
  
#line 2293 
  if (trans_pcie->fw_mon_page != (struct page *)0) {
    
#line 2294 
    len = (trans_pcie->fw_mon_size + len) + 32U;
    
#line 2296 
    monitor_len = trans_pcie->fw_mon_size;
  }
  else 
    
#line 2297 
    if (trans->dbg_dest_tlv != (struct iwl_fw_dbg_dest_tlv const *)0) {
      u32 base;
      u32 end;
      u32 tmp;
      u32 tmp_0;
      
#line 2300 
      base = (trans->dbg_dest_tlv)->base_reg;
      
#line 2301 
      end = (trans->dbg_dest_tlv)->end_reg;
      
#line 2303 
      tmp = iwl_read_prph(trans,base);
      
#line 2303 
      base = tmp << (int)(trans->dbg_dest_tlv)->base_shift;
      
#line 2305 
      tmp_0 = iwl_read_prph(trans,end);
      
#line 2305 
      end = tmp_0 << (int)(trans->dbg_dest_tlv)->end_shift;
      
#line 2309 
      if ((trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000 || (unsigned int)(trans->dbg_dest_tlv)->monitor_mode == 2U) 
        
#line 2311 
        end = (unsigned int)(1 << (int)(trans->dbg_dest_tlv)->end_shift) + end; else ;
      
#line 2312 
      monitor_len = end - base;
      
#line 2313 
      len = (len + monitor_len) + 32U;
    }
    else 
#line 2316 
         monitor_len = 0U;
  
#line 2319 
  dump_data = (struct iwl_trans_dump_data *)vzalloc((unsigned long)len);
  
#line 2320 
  if (dump_data == (struct iwl_trans_dump_data *)0) {
    
#line 2321 
    __retres = (struct iwl_trans_dump_data *)0;
    
#line 2321 
    goto return_label;
  }
  else ;
  
#line 2323 
  len = 0U;
  
#line 2324 
  data = (struct iwl_fw_error_dump_data *)(& dump_data->data);
  
#line 2325 
  data->type = 3U;
  
#line 2326 
  txcmd = (struct iwl_fw_error_dump_txcmd *)(& data->data);
  
#line 2327 
  ldv_spin_lock_bh_103(& cmdq->lock);
  
#line 2328 
  ptr = cmdq->q.write_ptr;
  
#line 2329 
  i = 0;
  
#line 2329 
  goto ldv_55014;
  ldv_55013: 
#line 2330 
  ;
  {
    u32 caplen;
    u32 cmdlen;
    u32 tmp_4;
    
#line 2330 
    u8 idx = get_cmd_index(& cmdq->q,(unsigned int)ptr);
    
#line 2333 
    cmdlen = iwl_trans_pcie_get_cmdlen(cmdq->tfds + ptr);
    {
      u32 tmp_3;
      
#line 2334 
      u32 __min1 = 324U;
      
#line 2334 
      u32 __min2 = cmdlen;
      
#line 2334 
      if (__min1 < __min2) 
#line 2334 
                           tmp_3 = __min1; else 
#line 2334 
                                                tmp_3 = __min2;
      
#line 2334 
      tmp_4 = tmp_3;
    }
    
#line 2334 
    caplen = tmp_4;
    
#line 2336 
    if (cmdlen != 0U) {
      
#line 2337 
      len = (len + caplen) + 8U;
      
#line 2338 
      txcmd->cmdlen = cmdlen;
      
#line 2339 
      txcmd->caplen = caplen;
      
#line 2340 
      memcpy((void *)(& txcmd->data),(void const *)(cmdq->entries + (int)idx)->cmd,(unsigned long)caplen);
      
#line 2341 
      txcmd = (struct iwl_fw_error_dump_txcmd *)(& txcmd->data) + caplen;
    }
    else ;
    
#line 2344 
    ptr = iwl_queue_dec_wrap(ptr);
  }
  
#line 2329 
  i += 1;
  ldv_55014: 
#line 2330 
  ;
  
#line 2329 
  if (cmdq->q.n_window > i) 
#line 2331 
                            goto ldv_55013; else 
#line 2334 
                                                 goto ldv_55015;
  ldv_55015: 
#line 2335 
  ;
  
#line 2346 
  ldv_spin_unlock_bh_104(& cmdq->lock);
  
#line 2348 
  data->len = len;
  
#line 2349 
  len += 8U;
  
#line 2350 
  data = iwl_fw_error_next_data(data);
  
#line 2352 
  tmp_5 = iwl_trans_pcie_dump_prph(trans,& data);
  
#line 2352 
  len = tmp_5 + len;
  
#line 2353 
  tmp_6 = iwl_trans_pcie_dump_csr(trans,& data);
  
#line 2353 
  len = tmp_6 + len;
  
#line 2354 
  tmp_7 = iwl_trans_pcie_fh_regs_dump(trans,& data);
  
#line 2354 
  len = tmp_7 + len;
  
#line 2357 
  if ((trans_pcie->fw_mon_page != (struct page *)0 && (trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_7000) || trans->dbg_dest_tlv != (struct iwl_fw_dbg_dest_tlv const *)0) {
    struct iwl_fw_error_dump_fw_mon *fw_mon_data;
    u32 base_0;
    u32 write_ptr;
    u32 wrap_cnt;
    
#line 2364 
    if (trans->dbg_dest_tlv != (struct iwl_fw_dbg_dest_tlv const *)0) {
      
#line 2365 
      write_ptr = (trans->dbg_dest_tlv)->write_ptr_reg;
      
#line 2367 
      wrap_cnt = (trans->dbg_dest_tlv)->wrap_count;
      
#line 2368 
      base_0 = (trans->dbg_dest_tlv)->base_reg;
    }
    else {
      
#line 2370 
      base_0 = 10501180U;
      
#line 2371 
      write_ptr = 10501188U;
      
#line 2372 
      wrap_cnt = 10501192U;
    }
    
#line 2375 
    data->type = 5U;
    
#line 2376 
    fw_mon_data = (struct iwl_fw_error_dump_fw_mon *)(& data->data);
    
#line 2378 
    fw_mon_data->fw_mon_wr_ptr = iwl_read_prph(trans,write_ptr);
    
#line 2380 
    fw_mon_data->fw_mon_cycle_cnt = iwl_read_prph(trans,wrap_cnt);
    
#line 2382 
    fw_mon_data->fw_mon_base_ptr = iwl_read_prph(trans,base_0);
    
#line 2384 
    len += 32U;
    
#line 2385 
    if (trans_pcie->fw_mon_page != (struct page *)0) {
      void *tmp_11;
      
#line 2392 
      dma_sync_single_for_cpu(trans->dev,trans_pcie->fw_mon_phys,(unsigned long)trans_pcie->fw_mon_size,(enum dma_data_direction)DMA_FROM_DEVICE);
      
#line 2396 
      ;
      
#line 2397 
      tmp_11 = lowmem_page_address((struct page const *)trans_pcie->fw_mon_page);
      
#line 2396 
      ;
      
#line 2396 
      memcpy((void *)(& fw_mon_data->data),(void const *)tmp_11,(unsigned long)trans_pcie->fw_mon_size);
      
#line 2400 
      monitor_len = trans_pcie->fw_mon_size;
    }
    else 
      
#line 2401 
      if ((unsigned int)(trans->dbg_dest_tlv)->monitor_mode == 0U) {
        u32 tmp_12;
        
#line 2406 
        tmp_12 = iwl_read_prph(trans,base_0);
        
#line 2406 
        base_0 = tmp_12 << (int)(trans->dbg_dest_tlv)->base_shift;
        
#line 2408 
        iwl_trans_read_mem(trans,base_0,(void *)(& fw_mon_data->data),(int)(monitor_len / 4U));
      }
      else 
        
#line 2410 
        if ((unsigned int)(trans->dbg_dest_tlv)->monitor_mode == 2U) 
          
#line 2411 
          monitor_len = iwl_trans_pci_dump_marbh_monitor(trans,fw_mon_data,monitor_len); else 
                                                                    
#line 2417 
                                                                    monitor_len = 0U;
    
#line 2420 
    len += monitor_len;
    
#line 2421 
    data->len = monitor_len + 24U;
  }
  else ;
  
#line 2424 
  dump_data->len = len;
  
#line 2426 
  __retres = dump_data;
  return_label: 
#line 2426 
                return __retres;
}


#line 2429  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
static struct iwl_trans_ops const trans_ops_pcie = {.start_hw = & iwl_trans_pcie_start_hw, .op_mode_leave = & iwl_trans_pcie_op_mode_leave, .start_fw = & iwl_trans_pcie_start_fw, .update_sf = (int (*)(struct iwl_trans *, struct iwl_sf_region *))0, .fw_alive = & iwl_trans_pcie_fw_alive, .stop_device = & iwl_trans_pcie_stop_device, .d3_suspend = & iwl_trans_pcie_d3_suspend, .d3_resume = & iwl_trans_pcie_d3_resume, .send_cmd = & iwl_trans_pcie_send_hcmd, .tx = & iwl_trans_pcie_tx, .reclaim = & iwl_trans_pcie_reclaim, .txq_enable = & iwl_trans_pcie_txq_enable, .txq_disable = & iwl_trans_pcie_txq_disable, .dbgfs_register = & iwl_trans_pcie_dbgfs_register, .wait_tx_queue_empty = & iwl_trans_pcie_wait_txq_empty, .freeze_txq_timer = & iwl_trans_pcie_freeze_txq_timer, .write8 = & iwl_trans_pcie_write8, .write32 = & iwl_trans_pcie_write32, .read32 = & iwl_trans_pcie_read32, .read_prph = & iwl_trans_pcie_read_prph, .write_prph = & iwl_trans_pcie_write_prph, .read_mem = & iwl_trans_pcie_read_mem, .write_mem = & iwl_trans_pcie_write_mem, .configure = & iwl_trans_pcie_configure, .set_pmi = & iwl_trans_pcie_set_pmi, .grab_nic_access = & iwl_trans_pcie_grab_nic_access, .release_nic_access = & iwl_trans_pcie_release_nic_access, .set_bits_mask = & iwl_trans_pcie_set_bits_mask, .ref = & iwl_trans_pcie_ref, .unref = & iwl_trans_pcie_unref, .suspend = (void (*)(struct iwl_trans *))0, .resume = (void (*)(struct iwl_trans *))0, .dump_data = & iwl_trans_pcie_dump_data};

#line 2572 
void __compiletime_assert_2572(void);


#line 2589 
void __compiletime_assert_2589(void);


#line 2623 
void __compiletime_assert_2623(void);


#line 2471  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/trans.c"
struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev, struct pci_device_id const *ent, struct iwl_cfg const *cfg)
{
  struct iwl_trans *__retres;
  struct iwl_trans_pcie *trans_pcie;
  struct iwl_trans *trans;
  u16 pci_cmd;
  int ret;
  struct iwl_trans *tmp_1;
  
#line 2480 
  trans = iwl_trans_alloc(16512U,& pdev->dev,cfg,& trans_ops_pcie,0UL);
  
#line 2482 
  if (trans == (struct iwl_trans *)0) {
    struct iwl_trans *tmp;
    
#line 2483 
    tmp = (struct iwl_trans *)ERR_PTR_0(-12L);
    
#line 2483 
    __retres = tmp;
    
#line 2483 
    goto return_label;
  }
  else ;
  
#line 2485 
  trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 2487 
  trans_pcie->trans = trans;
  
#line 2488 
  spinlock_check(& trans_pcie->irq_lock);
  {
    struct lock_class_key __key;
    
#line 2488 
    __raw_spin_lock_init(& trans_pcie->irq_lock.__anonCompField_spinlock_18.rlock,"&(&trans_pcie->irq_lock)->rlock",& __key);
  }
  
#line 2489 
  spinlock_check(& trans_pcie->reg_lock);
  {
    struct lock_class_key __key_0;
    
#line 2489 
    __raw_spin_lock_init(& trans_pcie->reg_lock.__anonCompField_spinlock_18.rlock,"&(&trans_pcie->reg_lock)->rlock",& __key_0);
  }
  
#line 2490 
  spinlock_check(& trans_pcie->ref_lock);
  {
    struct lock_class_key __key_1;
    
#line 2490 
    __raw_spin_lock_init(& trans_pcie->ref_lock.__anonCompField_spinlock_18.rlock,"&(&trans_pcie->ref_lock)->rlock",& __key_1);
  }
  {
    struct lock_class_key __key_2;
    
#line 2491 
    __init_waitqueue_head(& trans_pcie->ucode_write_waitq,"&trans_pcie->ucode_write_waitq",& __key_2);
  }
  
#line 2493 
  ret = pci_enable_device(pdev);
  
#line 2494 
  if (ret != 0) 
#line 2495 
                goto out_no_pci; else ;
  
#line 2497 
  if (! (cfg->base_params)->pcie_l1_allowed) 
#line 2503 
                                             pci_disable_link_state(pdev,7); else ;
  
#line 2508 
  pci_set_master(pdev);
  
#line 2510 
  ret = pci_set_dma_mask(pdev,68719476735ULL);
  
#line 2511 
  if (ret == 0) 
#line 2512 
                ret = pci_set_consistent_dma_mask(pdev,68719476735ULL); else ;
  
#line 2513 
  if (ret != 0) {
    
#line 2514 
    ret = pci_set_dma_mask(pdev,4294967295ULL);
    
#line 2515 
    if (ret == 0) 
#line 2516 
                  ret = pci_set_consistent_dma_mask(pdev,4294967295ULL); else ;
    
#line 2519 
    if (ret != 0) {
      
#line 2520 
      dev_err((struct device const *)(& pdev->dev),"No suitable DMA available\n");
      
#line 2521 
      goto out_pci_disable_device;
    }
    else ;
  }
  else ;
  
#line 2525 
  ret = pci_request_regions(pdev,"iwlwifi");
  
#line 2526 
  if (ret != 0) {
    
#line 2527 
    dev_err((struct device const *)(& pdev->dev),"pci_request_regions failed\n");
    
#line 2528 
    goto out_pci_disable_device;
  }
  else ;
  
#line 2531 
  trans_pcie->hw_base = pci_ioremap_bar(pdev,0);
  
#line 2532 
  if (trans_pcie->hw_base == (void *)0) {
    
#line 2533 
    dev_err((struct device const *)(& pdev->dev),"pci_ioremap_bar failed\n");
    
#line 2534 
    ret = -19;
    
#line 2535 
    goto out_pci_release_regions;
  }
  else ;
  
#line 2540 
  pci_write_config_byte((struct pci_dev const *)pdev,65,(unsigned char)0);
  
#line 2542 
  trans->dev = & pdev->dev;
  
#line 2543 
  trans_pcie->pci_dev = pdev;
  
#line 2544 
  iwl_disable_interrupts_0(trans);
  
#line 2546 
  ret = pci_enable_msi_exact(pdev,1);
  
#line 2547 
  if (ret != 0) {
    
#line 2548 
    dev_err((struct device const *)(& pdev->dev),"pci_enable_msi failed(0X%x)\n",ret);
    
#line 2550 
    pci_read_config_word((struct pci_dev const *)pdev,4,& pci_cmd);
    
#line 2551 
    if (((int)pci_cmd & 1024) != 0) {
      
#line 2552 
      pci_cmd = (unsigned short)((unsigned int)pci_cmd & 64511U);
      
#line 2553 
      pci_write_config_word((struct pci_dev const *)pdev,4,(unsigned short)((int)pci_cmd));
    }
    else ;
  }
  else ;
  
#line 2557 
  trans->hw_rev = iwl_read32_2(trans,40U);
  
#line 2564 
  if ((trans->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) {
    unsigned long flags;
    bool tmp_0;
    
#line 2567 
    trans->hw_rev = (trans->hw_rev & 65520U) | ((trans->hw_rev << 2) & 12U);
    
#line 2570 
    ret = iwl_pcie_prepare_card_hw(trans);
    
#line 2571 
    if (ret != 0) {
      {
        
#line 2572 
        bool __cond = (_Bool)((int)*("Exit HW not ready\n" + 17UL) != 10);
        
#line 2572 
        if ((int)__cond != 0) 
#line 2572 
                              __compiletime_assert_2572(); else ;
      }
      
#line 2572 
      __iwl_warn(trans->dev,"Exit HW not ready\n");
      
#line 2573 
      goto out_pci_disable_msi;
    }
    else ;
    
#line 2580 
    iwl_set_bit(trans,36U,4U);
    
#line 2582 
    __const_udelay(8590UL);
    
#line 2584 
    ret = iwl_poll_bit(trans,36U,1U,1U,25000);
    
#line 2588 
    if (ret < 0) {
      {
        
#line 2589 
        bool __cond_0 = (_Bool)((int)*("Failed to wake up the nic\n" + 25UL) != 10);
        
#line 2589 
        if ((int)__cond_0 != 0) 
#line 2589 
                                __compiletime_assert_2589(); else ;
      }
      
#line 2589 
      __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_trans_pcie_alloc","Failed to wake up the nic\n");
      
#line 2590 
      goto out_pci_disable_msi;
    }
    else ;
    
#line 2593 
    tmp_0 = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
    
#line 2593 
    if ((long)((int)tmp_0 != 0) != 0L) {
      u32 hw_step;
      
#line 2596 
      hw_step = __iwl_read_prph(trans,10498096U);
      
#line 2597 
      hw_step |= 2147483648U;
      
#line 2598 
      __iwl_write_prph(trans,10498096U,hw_step);
      
#line 2599 
      hw_step = __iwl_read_prph(trans,10617008U);
      
#line 2600 
      hw_step = (hw_step >> 24) & 15U;
      
#line 2601 
      if (hw_step == 3U) 
#line 2602 
                         trans->hw_rev = (trans->hw_rev & 4294967283U) | 8U; else ;
      
#line 2604 
      iwl_trans_release_nic_access(trans,& flags);
    }
    else ;
  }
  else ;
  
#line 2608 
  trans->hw_id = (unsigned int)(((int)pdev->device << 16) + (int)pdev->subsystem_device);
  
#line 2609 
  snprintf((char *)(& trans->hw_id_str),52UL,"PCI ID: 0x%04X:0x%04X",(int)pdev->device,(int)pdev->subsystem_device);
  {
    struct lock_class_key __key_3;
    
#line 2613 
    __init_waitqueue_head(& trans_pcie->wait_command_queue,"&trans_pcie->wait_command_queue",& __key_3);
  }
  
#line 2615 
  ret = iwl_pcie_alloc_ict(trans);
  
#line 2616 
  if (ret != 0) 
#line 2617 
                goto out_pci_disable_msi; else ;
  
#line 2619 
  ret = ldv_request_threaded_irq_105(pdev->irq,& iwl_pcie_isr,& iwl_pcie_irq_handler,128UL,"iwlwifi",(void *)trans);
  
#line 2622 
  if (ret != 0) {
    {
      
#line 2623 
      bool __cond_1 = (_Bool)((int)*("Error allocating IRQ %d\n" + 23UL) != 10);
      
#line 2623 
      if ((int)__cond_1 != 0) 
#line 2623 
                              __compiletime_assert_2623(); else ;
    }
    
#line 2623 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Error allocating IRQ %d\n",pdev->irq);
    
#line 2624 
    goto out_free_ict;
  }
  else ;
  
#line 2627 
  trans_pcie->inta_mask = 3120562315U;
  
#line 2628 
  trans->d0i3_mode = IWL_D0I3_MODE_ON_SUSPEND;
  
#line 2630 
  __retres = trans;
  
#line 2630 
  goto return_label;
  out_free_ict: 
#line 2632 
  ;
  
#line 2633 
  iwl_pcie_free_ict(trans);
  out_pci_disable_msi: 
#line 2634 
  ;
  
#line 2635 
  pci_disable_msi(pdev);
  out_pci_release_regions: 
#line 2636 
  ;
  
#line 2637 
  pci_release_regions(pdev);
  out_pci_disable_device: 
#line 2638 
  ;
  
#line 2639 
  pci_disable_device(pdev);
  out_no_pci: 
#line 2640 
  ;
  
#line 2641 
  iwl_trans_free(trans);
  
#line 2642 
  tmp_1 = (struct iwl_trans *)ERR_PTR_0((long)ret);
  
#line 2642 
  __retres = tmp_1;
  return_label: 
#line 2642 
                return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
struct file_operations *ldv_emg_alias_iwl_dbgfs_csr_ops_2 = (struct file_operations *)(& iwl_dbgfs_csr_ops);

#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
long long (*ldv_emg_alias_generic_file_llseek_3)(struct file *, long long , int ) = & generic_file_llseek;

#line 58  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
struct file_operations *ldv_emg_alias_iwl_dbgfs_tx_queue_ops_2 = (struct file_operations *)(& iwl_dbgfs_tx_queue_ops);

#line 59  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
struct file_operations *ldv_emg_alias_iwl_dbgfs_interrupt_ops_2 = (struct file_operations *)(& iwl_dbgfs_interrupt_ops);

#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
struct file_operations *ldv_emg_alias_iwl_dbgfs_rx_queue_ops_2 = (struct file_operations *)(& iwl_dbgfs_rx_queue_ops);

#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
struct file_operations *ldv_emg_alias_iwl_dbgfs_fh_reg_ops_2 = (struct file_operations *)(& iwl_dbgfs_fh_reg_ops);

#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
int (*ldv_emg_alias_simple_open_5)(struct inode *, struct file *) = & simple_open;

#line 66 
int ldv_emg_del_timer(struct timer_list *arg0);


#line 68 
int ldv_emg_request_threaded_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), unsigned long arg3, char *arg4, void *arg5);


#line 69 
void ldv_emg_free_irq(unsigned int arg0, void *arg1);


#line 71 
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4);


#line 73 
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1);


#line 77  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
long ldv_emg_wrapper_iwl_dbgfs_interrupt_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 78 
  tmp = iwl_dbgfs_interrupt_read(arg0,arg1,arg2,arg3);
  
#line 78 
  return tmp;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
long ldv_emg_wrapper_iwl_dbgfs_interrupt_write_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 83 
  tmp = iwl_dbgfs_interrupt_write(arg0,(char const *)arg1,arg2,arg3);
  
#line 83 
  return tmp;
}


#line 87  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
long ldv_emg_wrapper_iwl_dbgfs_csr_write_4(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 88 
  tmp = iwl_dbgfs_csr_write(arg0,(char const *)arg1,arg2,arg3);
  
#line 88 
  return tmp;
}


#line 92  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
long ldv_emg_wrapper_iwl_dbgfs_rx_queue_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 93 
  tmp = iwl_dbgfs_rx_queue_read(arg0,arg1,arg2,arg3);
  
#line 93 
  return tmp;
}


#line 97  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
long ldv_emg_wrapper_iwl_dbgfs_fh_reg_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 98 
  tmp = iwl_dbgfs_fh_reg_read(arg0,arg1,arg2,arg3);
  
#line 98 
  return tmp;
}


#line 102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
long ldv_emg_wrapper_iwl_dbgfs_tx_queue_read_3(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  long tmp;
  
#line 103 
  tmp = iwl_dbgfs_tx_queue_read(arg0,arg1,arg2,arg3);
  
#line 103 
  return tmp;
}


#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void *ERR_PTR_0(long error)
{
  void *tmp;
  
#line 111 
  tmp = ldv_err_ptr(error);
  
#line 111 
  return tmp;
}


#line 532  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void *kzalloc_2(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 535 
  tmp = ldv_kzalloc(size,flags);
  
#line 535 
  return tmp;
}


#line 786  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_lock_73_0(spinlock_t *lock)
{
  
#line 790 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 792 
  spin_lock_0(lock);
  
#line 793 
  return;
}


#line 796  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_74_0(spinlock_t *lock)
{
  
#line 800 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 802 
  spin_unlock_0(lock);
  
#line 803 
  return;
}


#line 806  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_lock_75_0(spinlock_t *lock)
{
  
#line 810 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 812 
  spin_lock_0(lock);
  
#line 813 
  return;
}


#line 816  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_76_0(spinlock_t *lock)
{
  
#line 820 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 822 
  spin_unlock_0(lock);
  
#line 823 
  return;
}


#line 826  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_lock_77(spinlock_t *lock)
{
  
#line 830 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 832 
  spin_lock_0(lock);
  
#line 833 
  return;
}


#line 836  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_78(spinlock_t *lock)
{
  
#line 840 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 842 
  spin_unlock_0(lock);
  
#line 843 
  return;
}


#line 846  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_lock_79(spinlock_t *lock)
{
  
#line 850 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 852 
  spin_lock_0(lock);
  
#line 853 
  return;
}


#line 856  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_80(spinlock_t *lock)
{
  
#line 860 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 862 
  spin_unlock_0(lock);
  
#line 863 
  return;
}


#line 866  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_lock_81(spinlock_t *lock)
{
  
#line 870 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 872 
  spin_lock_0(lock);
  
#line 873 
  return;
}


#line 876  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_82_0(spinlock_t *lock)
{
  
#line 880 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 882 
  spin_unlock_0(lock);
  
#line 883 
  return;
}


#line 886  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_free_irq_83(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  
#line 890 
  ldv_emg_free_irq(ldv_func_arg1,ldv_func_arg2);
  
#line 891 
  return;
}


#line 894  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv___ldv_spin_lock_84(spinlock_t *ldv_func_arg1)
{
  
#line 898 
  ldv_spin_model_lock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 900 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 901 
  return;
}


#line 904  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_irqrestore_85(spinlock_t *lock, unsigned long flags)
{
  
#line 908 
  ldv_spin_model_unlock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 910 
  spin_unlock_irqrestore(lock,flags);
  
#line 911 
  return;
}


#line 914  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_irqrestore_86(spinlock_t *lock, unsigned long flags)
{
  
#line 918 
  ldv_spin_model_unlock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 920 
  spin_unlock_irqrestore(lock,flags);
  
#line 921 
  return;
}


#line 924  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_lock_bh_87(spinlock_t *lock)
{
  
#line 928 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 930 
  spin_lock_bh(lock);
  
#line 931 
  return;
}


#line 934  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static int ldv_del_timer_88(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 938 
  tmp = ldv_emg_del_timer(ldv_func_arg1);
  
#line 938 
  return tmp;
}


#line 942  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static int ldv_mod_timer_89(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 946 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 946 
  return tmp;
}


#line 950  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_bh_90(spinlock_t *lock)
{
  
#line 954 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 956 
  spin_unlock_bh(lock);
  
#line 957 
  return;
}


#line 960  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv___ldv_spin_lock_91(spinlock_t *ldv_func_arg1)
{
  
#line 964 
  ldv_spin_model_lock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 966 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 967 
  return;
}


#line 970  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_irqrestore_92(spinlock_t *lock, unsigned long flags)
{
  
#line 974 
  ldv_spin_model_unlock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 976 
  spin_unlock_irqrestore(lock,flags);
  
#line 977 
  return;
}


#line 980  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv___ldv_spin_lock_93(spinlock_t *ldv_func_arg1)
{
  
#line 984 
  ldv_spin_model_lock((char *)"ref_lock_of_iwl_trans_pcie");
  
#line 986 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 987 
  return;
}


#line 990  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_irqrestore_94(spinlock_t *lock, unsigned long flags)
{
  
#line 994 
  ldv_spin_model_unlock((char *)"ref_lock_of_iwl_trans_pcie");
  
#line 996 
  spin_unlock_irqrestore(lock,flags);
  
#line 997 
  return;
}


#line 1000  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv___ldv_spin_lock_95(spinlock_t *ldv_func_arg1)
{
  
#line 1004 
  ldv_spin_model_lock((char *)"ref_lock_of_iwl_trans_pcie");
  
#line 1006 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 1007 
  return;
}


#line 1010  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_irqrestore_96(spinlock_t *lock, unsigned long flags)
{
  
#line 1014 
  ldv_spin_model_unlock((char *)"ref_lock_of_iwl_trans_pcie");
  
#line 1016 
  spin_unlock_irqrestore(lock,flags);
  
#line 1017 
  return;
}


#line 1020  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock, unsigned long flags)
{
  
#line 1024 
  ldv_spin_model_unlock((char *)"ref_lock_of_iwl_trans_pcie");
  
#line 1026 
  spin_unlock_irqrestore(lock,flags);
  
#line 1027 
  return;
}


#line 1030  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static struct dentry *ldv_debugfs_create_file_98(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1034 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1034 
  return tmp;
}


#line 1038  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static struct dentry *ldv_debugfs_create_file_99(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1042 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1042 
  return tmp;
}


#line 1046  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static struct dentry *ldv_debugfs_create_file_100(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1050 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1050 
  return tmp;
}


#line 1054  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static struct dentry *ldv_debugfs_create_file_101(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1058 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1058 
  return tmp;
}


#line 1062  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static struct dentry *ldv_debugfs_create_file_102(char const *ldv_func_arg1, umode_t ldv_func_arg2, struct dentry *ldv_func_arg3, void *ldv_func_arg4, struct file_operations const *ldv_func_arg5)
{
  struct dentry *tmp;
  
#line 1066 
  tmp = ldv_emg_debugfs_create_file((char *)ldv_func_arg1,(unsigned short)((int)ldv_func_arg2),ldv_func_arg3,ldv_func_arg4,(struct file_operations *)ldv_func_arg5);
  
#line 1066 
  return tmp;
}


#line 1070  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_lock_bh_103(spinlock_t *lock)
{
  
#line 1074 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 1076 
  spin_lock_bh(lock);
  
#line 1077 
  return;
}


#line 1080  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static void ldv_spin_unlock_bh_104(spinlock_t *lock)
{
  
#line 1084 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 1086 
  spin_unlock_bh(lock);
  
#line 1087 
  return;
}


#line 1090  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_trans.c.aux"
static int ldv_request_threaded_irq_105(unsigned int ldv_func_arg1, irqreturn_t (*ldv_func_arg2)(int , void *), irqreturn_t (*ldv_func_arg3)(int , void *), unsigned long ldv_func_arg4, char const *ldv_func_arg5, void *ldv_func_arg6)
{
  int tmp;
  
#line 1094 
  tmp = ldv_emg_request_threaded_irq(ldv_func_arg1,ldv_func_arg2,ldv_func_arg3,ldv_func_arg4,(char *)ldv_func_arg5,ldv_func_arg6);
  
#line 1094 
  return tmp;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_1(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_73_1(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_75_1(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_0(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 391 
static void ldv_spin_lock_bh_77(spinlock_t *lock);


#line 395 
static void ldv_spin_lock_bh_79(spinlock_t *lock);


#line 399 
static void ldv_spin_lock_bh_81(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_1(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_74_1(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_76_1(spinlock_t *lock);


#line 412  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_0(spinlock_t *lock)
{
  
#line 414 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 415 
  return;
}


#line 440 
static void ldv_spin_unlock_bh_78(spinlock_t *lock);


#line 444 
static void ldv_spin_unlock_bh_80(spinlock_t *lock);


#line 448 
static void ldv_spin_unlock_bh_82(spinlock_t *lock);


#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.h"
void iwl_notification_wait_init(struct iwl_notif_wait_data *notif_wait);


#line 116 
void iwl_notification_wait_notify(struct iwl_notif_wait_data *notif_wait, struct iwl_rx_packet *pkt);


#line 118 
void iwl_abort_notification_waits(struct iwl_notif_wait_data *notif_wait);


#line 122 
void iwl_init_notification_wait(struct iwl_notif_wait_data *notif_wait, struct iwl_notification_wait *wait_entry, u8 const *cmds, int n_cmds, bool (*fn)(struct iwl_notif_wait_data *, struct iwl_rx_packet *, void *), void *fn_data);


#line 130 
int iwl_wait_notification(struct iwl_notif_wait_data *notif_wait, struct iwl_notification_wait *wait_entry, unsigned long timeout);


#line 135 
void iwl_remove_notification(struct iwl_notif_wait_data *notif_wait, struct iwl_notification_wait *wait_entry);


#line 70  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
void iwl_notification_wait_init(struct iwl_notif_wait_data *notif_wait)
{
  
#line 72 
  spinlock_check(& notif_wait->notif_wait_lock);
  {
    struct lock_class_key __key;
    
#line 72 
    __raw_spin_lock_init(& notif_wait->notif_wait_lock.__anonCompField_spinlock_18.rlock,"&(&notif_wait->notif_wait_lock)->rlock",& __key);
  }
  
#line 73 
  INIT_LIST_HEAD(& notif_wait->notif_waits);
  {
    struct lock_class_key __key_0;
    
#line 74 
    __init_waitqueue_head(& notif_wait->notif_waitq,"&notif_wait->notif_waitq",& __key_0);
  }
  
#line 76 
  return;
}


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
static char const __kstrtab_iwl_notification_wait_init[27U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'n', (char)'o', (char)'t', (char)'i', (char)'f', (char)'i', (char)'c', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'_', (char)'w', (char)'a', (char)'i', (char)'t', (char)'_', (char)'i', (char)'n', (char)'i', (char)'t', (char)'\000'};

#line 76 
struct kernel_symbol const __ksymtab_iwl_notification_wait_init;


#line 76  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
struct kernel_symbol const __ksymtab_iwl_notification_wait_init = {.value = (unsigned long)(& iwl_notification_wait_init), .name = (char const *)(& __kstrtab_iwl_notification_wait_init)};

#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
void iwl_notification_wait_notify(struct iwl_notif_wait_data *notif_wait, struct iwl_rx_packet *pkt)
{
  int tmp_2;
  
#line 81 
  bool triggered = (_Bool)0;
  
#line 83 
  tmp_2 = list_empty((struct list_head const *)(& notif_wait->notif_waits));
  
#line 83 
  if (tmp_2 == 0) {
    struct iwl_notification_wait *w;
    struct iwl_notification_wait *tmp;
    struct iwl_notification_wait *tmp_1;
    
#line 86 
    ldv_spin_lock_73_1(& notif_wait->notif_wait_lock);
    {
      
#line 87 
      struct list_head const *__mptr = (struct list_head const *)notif_wait->notif_waits.next;
      
#line 87 
      tmp = (struct iwl_notification_wait *)__mptr;
    }
    
#line 87 
    w = tmp;
    
#line 87 
    goto ldv_50335;
    ldv_50334: 
#line 88 
    ;
    {
      int i;
      
#line 89 
      bool found = (_Bool)0;
      
#line 97 
      if ((int)w->triggered != 0 || (int)w->aborted != 0) 
#line 98 
                                                          goto ldv_50330; else ;
      
#line 100 
      i = 0;
      
#line 100 
      goto ldv_50333;
      ldv_50332: 
#line 101 
      ;
      
#line 101 
      if ((int)w->cmds[i] == (int)pkt->hdr.cmd) {
        
#line 102 
        found = (_Bool)1;
        
#line 103 
        goto ldv_50331;
      }
      else ;
      
#line 100 
      i += 1;
      ldv_50333: 
#line 101 
      ;
      
#line 100 
      if ((int)w->n_cmds > i) 
#line 102 
                              goto ldv_50332; else 
#line 105 
                                                   goto ldv_50331;
      ldv_50331: 
#line 106 
      ;
      
#line 106 
      if (! found) 
#line 107 
                   goto ldv_50330; else ;
      
#line 109 
      if (w->fn == (bool (*)(struct iwl_notif_wait_data *, struct iwl_rx_packet *, void *))0) 
        
#line 109 
        goto _LOR;
      else {
        bool tmp_0;
        
#line 109 
        tmp_0 = (*(w->fn))(notif_wait,pkt,w->fn_data);
        
#line 109 
        if ((int)tmp_0 != 0) {
          _LOR: {
                  
#line 110 
                  w->triggered = (_Bool)1;
                  
#line 111 
                  triggered = (_Bool)1;
                }
        }
        else ;
      }
    }
    ldv_50330: 
#line 114 
    ;
    {
      
#line 87 
      struct list_head const *__mptr_0 = (struct list_head const *)w->list.next;
      
#line 87 
      tmp_1 = (struct iwl_notification_wait *)__mptr_0;
    }
    
#line 87 
    w = tmp_1;
    ldv_50335: 
#line 89 
    ;
    
#line 87 
    if ((void *)w != (void *)notif_wait) 
#line 89 
                                         goto ldv_50334; else 
#line 92 
                                                              goto ldv_50336;
    ldv_50336: 
#line 93 
    ;
    
#line 114 
    ldv_spin_unlock_74_1(& notif_wait->notif_wait_lock);
  }
  else ;
  
#line 118 
  if ((int)triggered != 0) 
#line 119 
                           __wake_up(& notif_wait->notif_waitq,3U,0,(void *)0); else ;
  
#line 120 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
static char const __kstrtab_iwl_notification_wait_notify[29U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'n', (char)'o', (char)'t', (char)'i', (char)'f', (char)'i', (char)'c', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'_', (char)'w', (char)'a', (char)'i', (char)'t', (char)'_', (char)'n', (char)'o', (char)'t', (char)'i', (char)'f', (char)'y', (char)'\000'};

#line 121 
struct kernel_symbol const __ksymtab_iwl_notification_wait_notify;


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
struct kernel_symbol const __ksymtab_iwl_notification_wait_notify = {.value = (unsigned long)(& iwl_notification_wait_notify), .name = (char const *)(& __kstrtab_iwl_notification_wait_notify)};

#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
void iwl_abort_notification_waits(struct iwl_notif_wait_data *notif_wait)
{
  struct iwl_notification_wait *wait_entry;
  struct iwl_notification_wait *tmp;
  struct iwl_notification_wait *tmp_0;
  
#line 127 
  ldv_spin_lock_75_1(& notif_wait->notif_wait_lock);
  {
    
#line 128 
    struct list_head const *__mptr = (struct list_head const *)notif_wait->notif_waits.next;
    
#line 128 
    tmp = (struct iwl_notification_wait *)__mptr;
  }
  
#line 128 
  wait_entry = tmp;
  
#line 128 
  goto ldv_50354;
  ldv_50353: 
#line 129 
  ;
  
#line 129 
  wait_entry->aborted = (_Bool)1;
  {
    
#line 128 
    struct list_head const *__mptr_0 = (struct list_head const *)wait_entry->list.next;
    
#line 128 
    tmp_0 = (struct iwl_notification_wait *)__mptr_0;
  }
  
#line 128 
  wait_entry = tmp_0;
  ldv_50354: 
#line 130 
  ;
  
#line 128 
  if ((void *)wait_entry != (void *)notif_wait) 
#line 130 
                                                goto ldv_50353; else 
                                                                  
#line 133 
                                                                  goto ldv_50355;
  ldv_50355: 
#line 134 
  ;
  
#line 130 
  ldv_spin_unlock_76_1(& notif_wait->notif_wait_lock);
  
#line 132 
  __wake_up(& notif_wait->notif_waitq,3U,0,(void *)0);
  
#line 133 
  return;
}


#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
static char const __kstrtab_iwl_abort_notification_waits[29U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'a', (char)'b', (char)'o', (char)'r', (char)'t', (char)'_', (char)'n', (char)'o', (char)'t', (char)'i', (char)'f', (char)'i', (char)'c', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'_', (char)'w', (char)'a', (char)'i', (char)'t', (char)'s', (char)'\000'};

#line 134 
struct kernel_symbol const __ksymtab_iwl_abort_notification_waits;


#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
struct kernel_symbol const __ksymtab_iwl_abort_notification_waits = {.value = (unsigned long)(& iwl_abort_notification_waits), .name = (char const *)(& __kstrtab_iwl_abort_notification_waits)};

#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
void iwl_init_notification_wait(struct iwl_notif_wait_data *notif_wait, struct iwl_notification_wait *wait_entry, u8 const *cmds, int n_cmds, bool (*fn)(struct iwl_notif_wait_data *, struct iwl_rx_packet *, void *), void *fn_data)
{
  int tmp;
  {
    
#line 144 
    int __ret_warn_on = n_cmds > 5;
    
#line 144 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 144 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c",144); else ;
    
#line 144 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 144 
  if ((long)tmp != 0L) 
#line 145 
                       n_cmds = 5; else ;
  
#line 147 
  wait_entry->fn = fn;
  
#line 148 
  wait_entry->fn_data = fn_data;
  
#line 149 
  wait_entry->n_cmds = (unsigned char)n_cmds;
  
#line 150 
  memcpy((void *)(& wait_entry->cmds),(void const *)cmds,(unsigned long)n_cmds);
  
#line 151 
  wait_entry->triggered = (_Bool)0;
  
#line 152 
  wait_entry->aborted = (_Bool)0;
  
#line 154 
  ldv_spin_lock_bh_77(& notif_wait->notif_wait_lock);
  
#line 155 
  list_add(& wait_entry->list,& notif_wait->notif_waits);
  
#line 156 
  ldv_spin_unlock_bh_78(& notif_wait->notif_wait_lock);
  
#line 157 
  return;
}


#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
static char const __kstrtab_iwl_init_notification_wait[27U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'i', (char)'n', (char)'i', (char)'t', (char)'_', (char)'n', (char)'o', (char)'t', (char)'i', (char)'f', (char)'i', (char)'c', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'_', (char)'w', (char)'a', (char)'i', (char)'t', (char)'\000'};

#line 158 
struct kernel_symbol const __ksymtab_iwl_init_notification_wait;


#line 158  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
struct kernel_symbol const __ksymtab_iwl_init_notification_wait = {.value = (unsigned long)(& iwl_init_notification_wait), .name = (char const *)(& __kstrtab_iwl_init_notification_wait)};

#line 160  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
int iwl_wait_notification(struct iwl_notif_wait_data *notif_wait, struct iwl_notification_wait *wait_entry, unsigned long timeout)
{
  int __retres;
  int ret;
  long tmp_3;
  {
    
#line 166 
    long __ret = (long)timeout;
    
#line 166 
    __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c",168,0);
    {
      int tmp_2;
      {
        
#line 166 
        bool __cond_0 = (_Bool)(((int)wait_entry->triggered != 0 || (int)wait_entry->aborted != 0) != 0);
        
#line 166 
        if ((int)__cond_0 != 0 && __ret == 0L) 
#line 166 
                                               __ret = 1L; else ;
        
#line 166 
        tmp_2 = ((int)__cond_0 != 0 || __ret == 0L) != 0;
      }
      
#line 166 
      if (tmp_2 == 0) {
        long tmp_1;
        {
          wait_queue_t __wait;
          
#line 166 
          long __ret_0 = (long)timeout;
          
#line 166 
          INIT_LIST_HEAD(& __wait.task_list);
          
#line 166 
          __wait.flags = 0U;
          ldv_50404: 
#line 169 
          ;
          {
            int tmp_0;
            
#line 166 
            long __int = prepare_to_wait_event(& notif_wait->notif_waitq,& __wait,2);
            {
              
#line 166 
              bool __cond = (_Bool)(((int)wait_entry->triggered != 0 || (int)wait_entry->aborted != 0) != 0);
              
#line 166 
              if ((int)__cond != 0 && __ret_0 == 0L) 
#line 166 
                                                     __ret_0 = 1L; else ;
              
#line 166 
              tmp_0 = ((int)__cond != 0 || __ret_0 == 0L) != 0;
            }
            
#line 166 
            if (tmp_0 != 0) 
#line 166 
                            goto ldv_50403; else ;
            
#line 166 
            __ret_0 = schedule_timeout(__ret_0);
          }
          
#line 166 
          goto ldv_50404;
          ldv_50403: 
#line 167 
          ;
          
#line 166 
          finish_wait(& notif_wait->notif_waitq,& __wait);
          __out_0: 
#line 166 
          ;
          
#line 166 
          tmp_1 = __ret_0;
        }
        
#line 166 
        __ret = tmp_1;
      }
      else ;
    }
    
#line 166 
    tmp_3 = __ret;
  }
  
#line 166 
  ret = (int)tmp_3;
  
#line 170 
  ldv_spin_lock_bh_79(& notif_wait->notif_wait_lock);
  
#line 171 
  list_del(& wait_entry->list);
  
#line 172 
  ldv_spin_unlock_bh_80(& notif_wait->notif_wait_lock);
  
#line 174 
  if ((int)wait_entry->aborted != 0) {
    
#line 175 
    __retres = -5;
    
#line 175 
    goto return_label;
  }
  else ;
  
#line 178 
  if (ret <= 0) {
    
#line 179 
    __retres = -110;
    
#line 179 
    goto return_label;
  }
  else ;
  
#line 180 
  __retres = 0;
  return_label: 
#line 180 
                return __retres;
}


#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
static char const __kstrtab_iwl_wait_notification[22U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'w', (char)'a', (char)'i', (char)'t', (char)'_', (char)'n', (char)'o', (char)'t', (char)'i', (char)'f', (char)'i', (char)'c', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'\000'};

#line 182 
struct kernel_symbol const __ksymtab_iwl_wait_notification;


#line 182  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
struct kernel_symbol const __ksymtab_iwl_wait_notification = {.value = (unsigned long)(& iwl_wait_notification), .name = (char const *)(& __kstrtab_iwl_wait_notification)};

#line 184  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
void iwl_remove_notification(struct iwl_notif_wait_data *notif_wait, struct iwl_notification_wait *wait_entry)
{
  
#line 187 
  ldv_spin_lock_bh_81(& notif_wait->notif_wait_lock);
  
#line 188 
  list_del(& wait_entry->list);
  
#line 189 
  ldv_spin_unlock_bh_82(& notif_wait->notif_wait_lock);
  
#line 190 
  return;
}


#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
static char const __kstrtab_iwl_remove_notification[24U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'r', (char)'e', (char)'m', (char)'o', (char)'v', (char)'e', (char)'_', (char)'n', (char)'o', (char)'t', (char)'i', (char)'f', (char)'i', (char)'c', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'\000'};

#line 191 
struct kernel_symbol const __ksymtab_iwl_remove_notification;


#line 191  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-notif-wait.c"
struct kernel_symbol const __ksymtab_iwl_remove_notification = {.value = (unsigned long)(& iwl_remove_notification), .name = (char const *)(& __kstrtab_iwl_remove_notification)};

#line 743  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_lock_73_1(spinlock_t *lock)
{
  
#line 747 
  ldv_spin_model_lock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 749 
  spin_lock_1(lock);
  
#line 750 
  return;
}


#line 753  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_unlock_74_1(spinlock_t *lock)
{
  
#line 757 
  ldv_spin_model_unlock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 759 
  spin_unlock_1(lock);
  
#line 760 
  return;
}


#line 763  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_lock_75_1(spinlock_t *lock)
{
  
#line 767 
  ldv_spin_model_lock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 769 
  spin_lock_1(lock);
  
#line 770 
  return;
}


#line 773  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_unlock_76_1(spinlock_t *lock)
{
  
#line 777 
  ldv_spin_model_unlock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 779 
  spin_unlock_1(lock);
  
#line 780 
  return;
}


#line 783  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_lock_bh_77(spinlock_t *lock)
{
  
#line 787 
  ldv_spin_model_lock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 789 
  spin_lock_bh_0(lock);
  
#line 790 
  return;
}


#line 793  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_unlock_bh_78(spinlock_t *lock)
{
  
#line 797 
  ldv_spin_model_unlock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 799 
  spin_unlock_bh_0(lock);
  
#line 800 
  return;
}


#line 803  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_lock_bh_79(spinlock_t *lock)
{
  
#line 807 
  ldv_spin_model_lock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 809 
  spin_lock_bh_0(lock);
  
#line 810 
  return;
}


#line 813  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_unlock_bh_80(spinlock_t *lock)
{
  
#line 817 
  ldv_spin_model_unlock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 819 
  spin_unlock_bh_0(lock);
  
#line 820 
  return;
}


#line 823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_lock_bh_81(spinlock_t *lock)
{
  
#line 827 
  ldv_spin_model_lock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 829 
  spin_lock_bh_0(lock);
  
#line 830 
  return;
}


#line 833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-notif-wait.c.aux"
static void ldv_spin_unlock_bh_82(spinlock_t *lock)
{
  
#line 837 
  ldv_spin_model_unlock((char *)"notif_wait_lock_of_iwl_notif_wait_data");
  
#line 839 
  spin_unlock_bh_0(lock);
  
#line 840 
  return;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
static struct iwl_base_params const iwl2000_base_params = {.eeprom_size = 2048, .num_of_queues = 20, .pll_cfg_val = 0U, .max_ll_items = (unsigned short)4U, .shadow_ram_support = (_Bool)1, .led_compensation = (unsigned short)51U, .wd_timeout = 2500U, .max_event_log_size = 512U, .shadow_reg_enable = (_Bool)0, .pcie_l1_allowed = (_Bool)0, .apmg_wake_up_wa = (_Bool)0, .scd_chain_ext_wa = (_Bool)1};

#line 82  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
static struct iwl_base_params const iwl2030_base_params = {.eeprom_size = 2048, .num_of_queues = 20, .pll_cfg_val = 0U, .max_ll_items = (unsigned short)4U, .shadow_ram_support = (_Bool)1, .led_compensation = (unsigned short)57U, .wd_timeout = 10000U, .max_event_log_size = 512U, .shadow_reg_enable = (_Bool)0, .pcie_l1_allowed = (_Bool)0, .apmg_wake_up_wa = (_Bool)0, .scd_chain_ext_wa = (_Bool)1};

#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
static struct iwl_ht_params const iwl2000_ht_params = {.smps_mode = 0, .ht_greenfield_support = (_Bool)1, .stbc = (_Bool)0, .ldpc = (_Bool)0, .use_rts_for_aggregation = (_Bool)1, .ht40_bands = (unsigned char)1U};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
static struct iwl_eeprom_params const iwl20x0_eeprom_params = {.regulatory_bands = {(unsigned char)8U, (unsigned char)38U, (unsigned char)66U, (unsigned char)92U, (unsigned char)116U, (unsigned char)128U, (unsigned char)0U}, .enhanced_txpower = (_Bool)1};

#line 130  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
struct iwl_cfg const iwl2000_2bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 2200 BGN", .fw_name_pre = "iwlwifi-2000-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_2000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2053U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl2000_base_params, .ht_params = & iwl2000_ht_params, .eeprom_params = & iwl20x0_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 136  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
struct iwl_cfg const iwl2000_2bgn_d_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 2200D BGN", .fw_name_pre = "iwlwifi-2000-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_2000, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2053U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl2000_base_params, .ht_params = & iwl2000_ht_params, .eeprom_params = & iwl20x0_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
struct iwl_cfg const iwl2030_2bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 2230 BGN", .fw_name_pre = "iwlwifi-2030-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_2030, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2053U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl2030_base_params, .ht_params = & iwl2000_ht_params, .eeprom_params = & iwl20x0_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 179  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
struct iwl_cfg const iwl105_bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 105 BGN", .fw_name_pre = "iwlwifi-105-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_105, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2053U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl2000_base_params, .ht_params = & iwl2000_ht_params, .eeprom_params = & iwl20x0_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)1, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
struct iwl_cfg const iwl105_bgn_d_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 105D BGN", .fw_name_pre = "iwlwifi-105-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_105, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2053U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl2000_base_params, .ht_params = & iwl2000_ht_params, .eeprom_params = & iwl20x0_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)1, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 207  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-2000.c"
struct iwl_cfg const iwl135_bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 135 BGN", .fw_name_pre = "iwlwifi-135-", .ucode_api_max = 6U, .ucode_api_ok = 6U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_135, .max_data_size = 81920U, .max_inst_size = 262144U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)2053U, .nvm_calib_ver = (unsigned short)6U, .base_params = & iwl2030_base_params, .ht_params = & iwl2000_ht_params, .eeprom_params = & iwl20x0_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)1, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 7  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
void ldv_atomic_inc(atomic_t *v);


#line 52  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/log2.h"
__inline static bool is_power_of_2(unsigned long n)
{
  bool __retres;
  
#line 54 
  __retres = (_Bool)((n != 0UL && ((n + 18446744073709551615UL) & n) == 0UL) != 0);
  
#line 54 
  return __retres;
}


#line 233  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/printk.h"
void dump_stack(void);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/page_64.h"
unsigned long __phys_addr(unsigned long);


#line 25  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const *v)
{
  int __retres;
  int const volatile *tmp;
  {
    
#line 27 
    int const __var = 0;
    
#line 27 
    tmp = (int const volatile *)(& v->counter);
  }
  
#line 27 
  __retres = *tmp;
  
#line 27 
  return __retres;
}


#line 98 
static void atomic_inc(atomic_t *v);


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
static bool static_key_false_3(struct static_key *key)
{
  bool tmp;
  
#line 125 
  tmp = arch_static_branch(key);
  
#line 125 
  return tmp;
}


#line 310  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_2(spinlock_t *lock)
{
  
#line 312 
  _raw_spin_lock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 313 
  return;
}


#line 358 
static void ldv_spin_lock_73_2(spinlock_t *lock);


#line 362 
static void ldv_spin_lock_81_0(spinlock_t *lock);


#line 366 
static void ldv_spin_lock_83_0(spinlock_t *lock);


#line 370 
static void ldv_spin_lock_100(spinlock_t *lock);


#line 371  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_lock_bh_1(spinlock_t *lock)
{
  
#line 373 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 374 
  return;
}


#line 399 
static void ldv_spin_lock_bh_76(spinlock_t *lock);


#line 403 
static void ldv_spin_lock_bh_78(spinlock_t *lock);


#line 407 
static void ldv_spin_lock_bh_87_0(spinlock_t *lock);


#line 411 
static void ldv_spin_lock_bh_91(spinlock_t *lock);


#line 415 
static void ldv_spin_lock_bh_98(spinlock_t *lock);


#line 363  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_2(spinlock_t *lock)
{
  
#line 365 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_18.rlock);
  
#line 366 
  return;
}


#line 407 
static void ldv_spin_unlock_74_2(spinlock_t *lock);


#line 411 
static void ldv_spin_unlock_75(spinlock_t *lock);


#line 415 
static void ldv_spin_unlock_82_1(spinlock_t *lock);


#line 419 
static void ldv_spin_unlock_84_0(spinlock_t *lock);


#line 423 
static void ldv_spin_unlock_102_0(spinlock_t *lock);


#line 427 
static void ldv_spin_unlock_103(spinlock_t *lock);


#line 428  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_bh_1(spinlock_t *lock)
{
  
#line 430 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_18.rlock);
  
#line 431 
  return;
}


#line 456 
static void ldv_spin_unlock_bh_77(spinlock_t *lock);


#line 460 
static void ldv_spin_unlock_bh_79(spinlock_t *lock);


#line 464 
static void ldv_spin_unlock_bh_88(spinlock_t *lock);


#line 468 
static void ldv_spin_unlock_bh_92(spinlock_t *lock);


#line 472 
static void ldv_spin_unlock_bh_97(spinlock_t *lock);


#line 476 
static void ldv_spin_unlock_bh_99(spinlock_t *lock);


#line 490  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/spinlock.h"
static void spin_unlock_irqrestore_0(spinlock_t *lock, unsigned long flags)
{
  {
    unsigned long __dummy;
    unsigned long __dummy2;
    
  }
  
#line 492 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_18.rlock,flags);
  
#line 493 
  return;
}


#line 522 
static void ldv_spin_unlock_irqrestore_90(spinlock_t *lock, unsigned long flags);


#line 526 
static void ldv_spin_unlock_irqrestore_95(spinlock_t *lock, unsigned long flags);


#line 530 
static void ldv_spin_unlock_irqrestore_96_0(spinlock_t *lock, unsigned long flags);


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv___ldv_spin_lock_89(spinlock_t *ldv_func_arg1);


#line 74 
static void ldv___ldv_spin_lock_94(spinlock_t *ldv_func_arg1);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);


#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jiffies.h"
unsigned int jiffies_to_msecs(unsigned long const);


#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/timer.h"
void init_timer_key(struct timer_list *, unsigned int, char const *, struct lock_class_key *);


#line 172 
static int ldv_del_timer_85(struct timer_list *ldv_func_arg1);


#line 177 
static int ldv_mod_timer_86(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 181 
static int ldv_mod_timer_93(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 185 
static int ldv_mod_timer_101(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2);


#line 232 
static int ldv_del_timer_sync_80(struct timer_list *ldv_func_arg1);


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mmdebug.h"
void dump_page(struct page *, char const *);


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/gfp.h"
void free_pages(unsigned long, unsigned int);


#line 176  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist.h"
void __compiletime_assert_176(void);


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_0(size_t size, gfp_t flags);


#line 542 
static void *kcalloc(size_t n, size_t size, gfp_t flags);


#line 400  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/page-flags.h"
__inline static int PageTail(struct page const *page)
{
  int tmp;
  
#line 400 
  tmp = constant_test_bit(15L,(unsigned long const volatile *)(& page->flags));
  
#line 400 
  return tmp;
}


#line 532  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
bool __get_page_tail(struct page *);


#line 534  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mm.h"
__inline static void get_page(struct page *page)
{
  int tmp_0;
  int tmp_1;
  
#line 536 
  tmp_0 = PageTail((struct page const *)page);
  
#line 536 
  if ((long)(tmp_0 != 0) != 0L) {
    bool tmp;
    
#line 537 
    tmp = __get_page_tail(page);
    
#line 537 
    if ((long)((int)tmp != 0) != 0L) 
#line 538 
                                     goto return_label; else ;
  }
  else ;
  
#line 543 
  tmp_1 = atomic_read((atomic_t const *)(& page->__anonCompField_page_32.__anonCompField___anonstruct_59_31.__anonCompField___anonunion_61_30._count));
  
#line 543 
  if ((long)(tmp_1 <= 0) != 0L) {
    
#line 543 
    dump_page(page,"VM_BUG_ON_PAGE(");
    
#line 544 
    ldv_inline_asm();
    
#line 543 
    ;
  }
  else ;
  
#line 544 
  atomic_inc(& page->__anonCompField_page_32.__anonCompField___anonstruct_59_31.__anonCompField___anonunion_61_30._count);
  return_label: 
#line 545 
                return;
}


#line 10  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  dma_addr_t addr;
  int tmp_0;
  unsigned long tmp_1;
  unsigned long tmp_2;
  
#line 15 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 18 
  kmemcheck_mark_initialized(ptr,(unsigned int)size);
  
#line 19 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 19 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 21 
    ldv_inline_asm();
    
#line 19 
    ;
  }
  else ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  ;
  
#line 20 
  tmp_1 = __phys_addr((unsigned long)ptr);
  
#line 20 
  ;
  
#line 20 
  addr = (*(ops->map_page))(dev,(struct page *)(-24189255811072) + (tmp_1 >> 12),(unsigned long)ptr & 4095UL,size,dir,attrs);
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  ;
  
#line 23 
  tmp_2 = __phys_addr((unsigned long)ptr);
  
#line 23 
  ;
  
#line 23 
  debug_dma_map_page(dev,(struct page *)(-24189255811072) + (tmp_2 >> 12),(unsigned long)ptr & 4095UL,size,(int)dir,addr,(_Bool)1);
  
#line 26 
  return addr;
}


#line 29  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, struct dma_attrs *attrs)
{
  int tmp_0;
  
#line 34 
  struct dma_map_ops *ops = get_dma_ops(dev);
  
#line 36 
  tmp_0 = valid_dma_direction((int)dir);
  
#line 36 
  if ((long)(tmp_0 == 0) != 0L) {
    
#line 38 
    ldv_inline_asm();
    
#line 36 
    ;
  }
  else ;
  
#line 37 
  if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , struct dma_attrs *))0) 
    
#line 38 
    (*(ops->unmap_page))(dev,addr,size,dir,attrs); else ;
  
#line 39 
  debug_dma_unmap_page(dev,addr,size,(int)dir,(_Bool)1);
  
#line 40 
  return;
}


#line 1011  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static int skb_queue_empty(struct sk_buff_head const *list)
{
  int __retres;
  
#line 1013 
  __retres = (struct sk_buff const *)list->next == (struct sk_buff const *)list;
  
#line 1013 
  return __retres;
}


#line 1366  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_insert(struct sk_buff *newsk, struct sk_buff *prev, struct sk_buff *next, struct sk_buff_head *list)
{
  struct sk_buff *tmp;
  
#line 1370 
  newsk->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = next;
  
#line 1371 
  newsk->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = prev;
  
#line 1372 
  tmp = newsk;
  
#line 1372 
  prev->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.next = tmp;
  
#line 1372 
  next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev = tmp;
  
#line 1373 
  list->qlen += 1U;
  
#line 1374 
  return;
}


#line 1474  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_before(struct sk_buff_head *list, struct sk_buff *next, struct sk_buff *newsk)
{
  
#line 1478 
  __skb_insert(newsk,next->__anonCompField_sk_buff_67.__anonCompField___anonunion_217_66.prev,next,list);
  
#line 1479 
  return;
}


#line 1509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/skbuff.h"
__inline static void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
  
#line 1512 
  __skb_queue_before(list,(struct sk_buff *)list,newsk);
  
#line 1513 
  return;
}


#line 197  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/flow.h"
void __compiletime_assert_197(void);


#line 12  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/unaligned/access_ok.h"
__inline static u32 get_unaligned_le32(void const *p)
{
  u32 tmp;
  
#line 14 
  tmp = __le32_to_cpup((__le32 const *)p);
  
#line 14 
  return tmp;
}


#line 42  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_le32(u32 val, void *p)
{
  
#line 44 
  *((__le32 *)p) = val;
  
#line 45 
  return;
}


#line 281  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/ieee80211.h"
__inline static int ieee80211_has_morefrags(__le16 fc)
{
  int __retres;
  
#line 283 
  __retres = ((int)fc & 1024) != 0;
  
#line 283 
  return __retres;
}


#line 3689  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/net/cfg80211.h"
unsigned int ieee80211_hdrlen(__le16);


#line 198  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_queue_full(struct iwl_op_mode *op_mode, int queue)
{
  
#line 201 
  (*((op_mode->ops)->queue_full))(op_mode,queue);
  
#line 202 
  return;
}


#line 204  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_queue_not_full(struct iwl_op_mode *op_mode, int queue)
{
  
#line 207 
  (*((op_mode->ops)->queue_not_full))(op_mode,queue);
  
#line 208 
  return;
}


#line 217  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_free_skb(struct iwl_op_mode *op_mode, struct sk_buff *skb)
{
  
#line 220 
  (*((op_mode->ops)->free_skb))(op_mode,skb);
  
#line 221 
  return;
}


#line 228  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_cmd_queue_full(struct iwl_op_mode *op_mode)
{
  
#line 230 
  (*((op_mode->ops)->cmd_queue_full))(op_mode);
  
#line 231 
  return;
}


#line 284  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_free_resp(struct iwl_host_cmd *cmd)
{
  
#line 286 
  free_pages(cmd->_rx_page_addr,cmd->_rx_page_order);
  
#line 287 
  return;
}


#line 307  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static struct page *rxb_steal_page(struct iwl_rx_cmd_buffer *r)
{
  struct page *__retres;
  
#line 309 
  r->_page_stolen = (_Bool)1;
  
#line 310 
  get_page(r->_page);
  
#line 311 
  __retres = r->_page;
  
#line 311 
  return __retres;
}


#line 859 
void __compiletime_assert_859(void);


#line 852  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_trans_txq_enable_cfg(struct iwl_trans *trans, int queue, u16 ssn, struct iwl_trans_txq_scd_cfg const *cfg, unsigned int queue_wdg_timeout)
{
  
#line 856 
  __might_sleep("drivers/net/wireless/iwlwifi/iwl-trans.h",856,0);
  
#line 858 
  if ((long)(trans->state != (unsigned int)IWL_TRANS_FW_ALIVE) != 0L) {
    {
      
#line 859 
      bool __cond = (_Bool)((int)*("%s bad state = %d\n" + 17UL) != 10);
      
#line 859 
      if ((int)__cond != 0) 
#line 859 
                            __compiletime_assert_859(); else ;
    }
    
#line 859 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"%s bad state = %d\n","iwl_trans_txq_enable_cfg",(unsigned int)trans->state);
  }
  else ;
  
#line 861 
  (*((trans->ops)->txq_enable))(trans,queue,(unsigned short)((int)ssn),cfg,queue_wdg_timeout);
  
#line 862 
  return;
}


#line 881  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static void iwl_trans_ac_txq_enable(struct iwl_trans *trans, int queue, int fifo, unsigned int queue_wdg_timeout)
{
  
#line 884 
  struct iwl_trans_txq_scd_cfg cfg = {.fifo = (unsigned char)fifo, .sta_id = (signed char)(-1), .tid = (unsigned char)8U, .aggregate = (_Bool)0, .frame_limit = 64};
  
#line 892 
  iwl_trans_txq_enable_cfg(trans,queue,(unsigned short)0,(struct iwl_trans_txq_scd_cfg const *)(& cfg),queue_wdg_timeout);
  
#line 893 
  return;
}


#line 970  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static int iwl_trans_write_mem(struct iwl_trans *trans, u32 addr, void const *buf, int dwords)
{
  int tmp;
  
#line 973 
  tmp = (*((trans->ops)->write_mem))(trans,addr,buf,dwords);
  
#line 973 
  return tmp;
}


#line 976  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.h"
__inline static u32 iwl_trans_write_mem32(struct iwl_trans *trans, u32 addr, u32 val)
{
  u32 __retres;
  int tmp;
  
#line 979 
  tmp = iwl_trans_write_mem(trans,addr,(void const *)(& val),1);
  
#line 979 
  __retres = (unsigned int)tmp;
  
#line 979 
  return __retres;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32_3(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 35 
  tmp_4 = static_key_false_3(& __tracepoint_iwlwifi_dev_ioread32.key);
  
#line 35 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 35 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_6157 __u;
          
#line 35 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u.__c),8);
          
#line 35 
          tmp = __u.__val;
        }
        
#line 35 
        struct tracepoint_func *_________p1 = tmp;
        
#line 35 
        tmp_0 = _________p1;
      }
      
#line 35 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 35 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 35 
        if (tmp_1 != 0) {
          
#line 35 
          if (! __warned) {
            int tmp_2;
            
#line 35 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 35 
            if (tmp_2 == 0) {
              
#line 35 
              __warned = (_Bool)1;
              
#line 35 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 35 
      tmp_3 = ________p1;
    }
    
#line 35 
    it_func_ptr = tmp_3;
    
#line 35 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50643: 
#line 37 
      ;
      
#line 35 
      it_func = it_func_ptr->func;
      
#line 35 
      __data = it_func_ptr->data;
      
#line 35 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 35 
      it_func_ptr += 1;
      
#line 35 
      ;
      
#line 35 
      if (it_func_ptr->func != (void *)0) 
#line 37 
                                          goto ldv_50643; else 
#line 40 
                                                               goto ldv_50644;
      ldv_50644: 
#line 41 
      ;
    }
    else ;
    
#line 35 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 35 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_6159 __u_0;
        
#line 35 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u_0.__c),8);
        
#line 35 
        tmp_5 = __u_0.__val;
      }
      
#line 35 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 35 
      tmp_6 = _________p1_0;
    }
    
#line 35 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 35 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 35 
      if (tmp_7 != 0) {
        
#line 35 
        if (! __warned_0) {
          int tmp_8;
          
#line 35 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 35 
          if (tmp_8 == 0) {
            
#line 35 
            __warned_0 = (_Bool)1;
            
#line 35 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 35 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 35 
  rcu_read_unlock_sched_notrace();
  
#line 37 
  return;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32_3(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 69 
  tmp_4 = static_key_false_3(& __tracepoint_iwlwifi_dev_iowrite32.key);
  
#line 69 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 69 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_6165 __u;
          
#line 69 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u.__c),8);
          
#line 69 
          tmp = __u.__val;
        }
        
#line 69 
        struct tracepoint_func *_________p1 = tmp;
        
#line 69 
        tmp_0 = _________p1;
      }
      
#line 69 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 69 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 69 
        if (tmp_1 != 0) {
          
#line 69 
          if (! __warned) {
            int tmp_2;
            
#line 69 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 69 
            if (tmp_2 == 0) {
              
#line 69 
              __warned = (_Bool)1;
              
#line 69 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 69 
      tmp_3 = ________p1;
    }
    
#line 69 
    it_func_ptr = tmp_3;
    
#line 69 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50765: 
#line 71 
      ;
      
#line 69 
      it_func = it_func_ptr->func;
      
#line 69 
      __data = it_func_ptr->data;
      
#line 69 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 69 
      it_func_ptr += 1;
      
#line 69 
      ;
      
#line 69 
      if (it_func_ptr->func != (void *)0) 
#line 71 
                                          goto ldv_50765; else 
#line 74 
                                                               goto ldv_50766;
      ldv_50766: 
#line 75 
      ;
    }
    else ;
    
#line 69 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 69 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_6167 __u_0;
        
#line 69 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u_0.__c),8);
        
#line 69 
        tmp_5 = __u_0.__val;
      }
      
#line 69 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 69 
      tmp_6 = _________p1_0;
    }
    
#line 69 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 69 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 69 
      if (tmp_7 != 0) {
        
#line 69 
        if (! __warned_0) {
          int tmp_8;
          
#line 69 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 69 
          if (tmp_8 == 0) {
            
#line 69 
            __warned_0 = (_Bool)1;
            
#line 69 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 69 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 69 
  rcu_read_unlock_sched_notrace();
  
#line 71 
  return;
}


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-data.h"
__inline static void trace_iwlwifi_dev_tx_data(struct device const *dev, struct sk_buff *skb, void *data, size_t data_len)
{
  bool tmp_4;
  
#line 35 
  tmp_4 = static_key_false_3(& __tracepoint_iwlwifi_dev_tx_data.key);
  
#line 35 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 35 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_6213 __u;
          
#line 35 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_tx_data.funcs),(void *)(& __u.__c),8);
          
#line 35 
          tmp = __u.__val;
        }
        
#line 35 
        struct tracepoint_func *_________p1 = tmp;
        
#line 35 
        tmp_0 = _________p1;
      }
      
#line 35 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 35 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 35 
        if (tmp_1 != 0) {
          
#line 35 
          if (! __warned) {
            int tmp_2;
            
#line 35 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 35 
            if (tmp_2 == 0) {
              
#line 35 
              __warned = (_Bool)1;
              
#line 35 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-data.h",51,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 35 
      tmp_3 = ________p1;
    }
    
#line 35 
    it_func_ptr = tmp_3;
    
#line 35 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_51464: 
#line 37 
      ;
      
#line 35 
      it_func = it_func_ptr->func;
      
#line 35 
      __data = it_func_ptr->data;
      
#line 35 
      (*((void (*)(void *, struct device const *, struct sk_buff *, void *, size_t ))it_func))(__data,dev,skb,data,data_len);
      
#line 35 
      it_func_ptr += 1;
      
#line 35 
      ;
      
#line 35 
      if (it_func_ptr->func != (void *)0) 
#line 37 
                                          goto ldv_51464; else 
#line 40 
                                                               goto ldv_51465;
      ldv_51465: 
#line 41 
      ;
    }
    else ;
    
#line 35 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 35 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_6215 __u_0;
        
#line 35 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_tx_data.funcs),(void *)(& __u_0.__c),8);
        
#line 35 
        tmp_5 = __u_0.__val;
      }
      
#line 35 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 35 
      tmp_6 = _________p1_0;
    }
    
#line 35 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 35 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 35 
      if (tmp_7 != 0) {
        
#line 35 
        if (! __warned_0) {
          int tmp_8;
          
#line 35 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 35 
          if (tmp_8 == 0) {
            
#line 35 
            __warned_0 = (_Bool)1;
            
#line 35 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-data.h",51,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 35 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 35 
  rcu_read_unlock_sched_notrace();
  
#line 37 
  return;
}


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
__inline static void trace_iwlwifi_dev_hcmd(struct device const *dev, struct iwl_host_cmd *cmd, u16 total_size, struct iwl_cmd_header *hdr)
{
  bool tmp_4;
  
#line 36 
  tmp_4 = static_key_false_3(& __tracepoint_iwlwifi_dev_hcmd.key);
  
#line 36 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 36 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_6221 __u;
          
#line 36 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_hcmd.funcs),(void *)(& __u.__c),8);
          
#line 36 
          tmp = __u.__val;
        }
        
#line 36 
        struct tracepoint_func *_________p1 = tmp;
        
#line 36 
        tmp_0 = _________p1;
      }
      
#line 36 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 36 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 36 
        if (tmp_1 != 0) {
          
#line 36 
          if (! __warned) {
            int tmp_2;
            
#line 36 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 36 
            if (tmp_2 == 0) {
              
#line 36 
              __warned = (_Bool)1;
              
#line 36 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h",64,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 36 
      tmp_3 = ________p1;
    }
    
#line 36 
    it_func_ptr = tmp_3;
    
#line 36 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_51596: 
#line 38 
      ;
      
#line 36 
      it_func = it_func_ptr->func;
      
#line 36 
      __data = it_func_ptr->data;
      
#line 36 
      (*((void (*)(void *, struct device const *, struct iwl_host_cmd *, u16 , struct iwl_cmd_header *))it_func))(__data,dev,cmd,(unsigned short)((int)total_size),hdr);
      
#line 36 
      it_func_ptr += 1;
      
#line 36 
      ;
      
#line 36 
      if (it_func_ptr->func != (void *)0) 
#line 38 
                                          goto ldv_51596; else 
#line 41 
                                                               goto ldv_51597;
      ldv_51597: 
#line 42 
      ;
    }
    else ;
    
#line 36 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 36 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_6223 __u_0;
        
#line 36 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_hcmd.funcs),(void *)(& __u_0.__c),8);
        
#line 36 
        tmp_5 = __u_0.__val;
      }
      
#line 36 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 36 
      tmp_6 = _________p1_0;
    }
    
#line 36 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 36 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 36 
      if (tmp_7 != 0) {
        
#line 36 
        if (! __warned_0) {
          int tmp_8;
          
#line 36 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 36 
          if (tmp_8 == 0) {
            
#line 36 
            __warned_0 = (_Bool)1;
            
#line 36 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h",64,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 36 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 36 
  rcu_read_unlock_sched_notrace();
  
#line 38 
  return;
}


#line 85  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h"
__inline static void trace_iwlwifi_dev_tx(struct device const *dev, struct sk_buff *skb, void *tfd, size_t tfdlen, void *buf0, size_t buf0_len, void *buf1, size_t buf1_len)
{
  bool tmp_4;
  
#line 85 
  tmp_4 = static_key_false_3(& __tracepoint_iwlwifi_dev_tx.key);
  
#line 85 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 85 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_6229 __u;
          
#line 85 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_tx.funcs),(void *)(& __u.__c),8);
          
#line 85 
          tmp = __u.__val;
        }
        
#line 85 
        struct tracepoint_func *_________p1 = tmp;
        
#line 85 
        tmp_0 = _________p1;
      }
      
#line 85 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 85 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 85 
        if (tmp_1 != 0) {
          
#line 85 
          if (! __warned) {
            int tmp_2;
            
#line 85 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 85 
            if (tmp_2 == 0) {
              
#line 85 
              __warned = (_Bool)1;
              
#line 85 
              lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h",116,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 85 
      tmp_3 = ________p1;
    }
    
#line 85 
    it_func_ptr = tmp_3;
    
#line 85 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_51736: 
#line 87 
      ;
      
#line 85 
      it_func = it_func_ptr->func;
      
#line 85 
      __data = it_func_ptr->data;
      
#line 85 
      (*((void (*)(void *, struct device const *, struct sk_buff *, void *, size_t , void *, size_t , void *, size_t ))it_func))(__data,dev,skb,tfd,tfdlen,buf0,buf0_len,buf1,buf1_len);
      
#line 85 
      it_func_ptr += 1;
      
#line 85 
      ;
      
#line 85 
      if (it_func_ptr->func != (void *)0) 
#line 87 
                                          goto ldv_51736; else 
#line 90 
                                                               goto ldv_51737;
      ldv_51737: 
#line 91 
      ;
    }
    else ;
    
#line 85 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 85 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_6231 __u_0;
        
#line 85 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_tx.funcs),(void *)(& __u_0.__c),8);
        
#line 85 
        tmp_5 = __u_0.__val;
      }
      
#line 85 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 85 
      tmp_6 = _________p1_0;
    }
    
#line 85 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 85 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 85 
      if (tmp_7 != 0) {
        
#line 85 
        if (! __warned_0) {
          int tmp_8;
          
#line 85 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 85 
          if (tmp_8 == 0) {
            
#line 85 
            __warned_0 = (_Bool)1;
            
#line 85 
            lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/iwl-devtrace-iwlwifi.h",116,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 85 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 85 
  rcu_read_unlock_sched_notrace();
  
#line 87 
  return;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_write32_3(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 43 
  trace_iwlwifi_dev_iowrite32_3((struct device const *)trans->dev,ofs,val);
  
#line 44 
  iwl_trans_write32(trans,ofs,val);
  
#line 45 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static u32 iwl_read32_3(struct iwl_trans *trans, u32 ofs)
{
  
#line 49 
  u32 val = iwl_trans_read32(trans,ofs);
  
#line 50 
  trace_iwlwifi_dev_ioread32_3((struct device const *)trans->dev,ofs,val);
  
#line 51 
  return val;
}


#line 72  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static void iwl_scd_txq_set_chain(struct iwl_trans *trans, u16 txq_id)
{
  
#line 75 
  iwl_set_bits_prph(trans,10497256U,(unsigned int)(1UL << (int)txq_id));
  
#line 76 
  return;
}


#line 78  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static void iwl_scd_txq_enable_agg(struct iwl_trans *trans, u16 txq_id)
{
  
#line 81 
  iwl_set_bits_prph(trans,10497608U,(unsigned int)(1UL << (int)txq_id));
  
#line 82 
  return;
}


#line 84  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static void iwl_scd_txq_disable_agg(struct iwl_trans *trans, u16 txq_id)
{
  
#line 87 
  iwl_clear_bits_prph(trans,10497608U,(unsigned int)(1UL << (int)txq_id));
  
#line 88 
  return;
}


#line 95  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static void iwl_scd_activate_fifos(struct iwl_trans *trans)
{
  
#line 97 
  iwl_write_prph(trans,10497040U,255U);
  
#line 98 
  return;
}


#line 100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static void iwl_scd_deactivate_fifos(struct iwl_trans *trans)
{
  
#line 102 
  iwl_write_prph(trans,10497040U,0U);
  
#line 103 
  return;
}


#line 105  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static void iwl_scd_enable_set_active(struct iwl_trans *trans, u32 value)
{
  
#line 108 
  iwl_write_prph(trans,10497620U,value);
  
#line 109 
  return;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-scd.h"
__inline static void iwl_scd_txq_set_inactive(struct iwl_trans *trans, u16 txq_id)
{
  unsigned int tmp;
  
#line 138 
  tmp = SCD_QUEUE_STATUS_BITS((unsigned int)txq_id);
  
#line 138 
  ;
  
#line 138 
  iwl_write_prph(trans,tmp,524288U);
  
#line 139 
  return;
}


#line 121  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fh.h"
__inline static unsigned int FH_MEM_CBBC_QUEUE(unsigned int chnl)
{
  unsigned int __retres;
  
#line 123 
  if (chnl <= 15U) {
    
#line 124 
    __retres = (chnl + 1652U) * 4U;
    
#line 124 
    goto return_label;
  }
  else ;
  
#line 125 
  if (chnl <= 19U) {
    
#line 126 
    __retres = (chnl + 1772U) * 4U;
    
#line 126 
    goto return_label;
  }
  else ;
  {
    bool __warned;
    
#line 127 
    int __ret_warn_once = chnl > 31U;
    
#line 127 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 127 
        int __ret_warn_on = ! __warned;
        
#line 127 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 127 
                                              warn_slowpath_null("drivers/net/wireless/iwlwifi/iwl-fh.h",127); else ;
        
#line 127 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 127 
      if ((long)tmp != 0L) 
#line 127 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 127 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 128 
  __retres = (chnl + 1716U) * 4U;
  return_label: 
#line 128 
                return __retres;
}


#line 122  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static int iwl_queue_inc_wrap(int index)
{
  int __retres;
  
#line 124 
  index += 1;
  
#line 124 
  __retres = index & 255;
  
#line 124 
  return __retres;
}


#line 244  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static dma_addr_t iwl_pcie_get_scratchbuf_dma(struct iwl_txq *txq, int idx)
{
  dma_addr_t __retres;
  
#line 246 
  __retres = txq->scratchbufs_dma + (unsigned long long)((unsigned long)idx * 16UL);
  
#line 246 
  return __retres;
}


#line 339  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static struct iwl_trans *iwl_trans_pcie_get_trans(struct iwl_trans_pcie *trans_pcie)
{
  struct iwl_trans *tmp;
  {
    
#line 341 
    char const (*__mptr)[0U] = (char const (*)[0U])trans_pcie;
    
#line 341 
    tmp = (struct iwl_trans *)__mptr + 18446744073709551080U;
  }
  
#line 341 
  return tmp;
}


#line 450 
void __compiletime_assert_450(void);


#line 444  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_wake_queue(struct iwl_trans *trans, struct iwl_txq *txq)
{
  int tmp;
  
#line 447 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 449 
  tmp = test_and_set_bit((long)txq->q.id,(unsigned long volatile *)(& trans_pcie->queue_stopped));
  
#line 449 
  if (tmp != 0) {
    {
      
#line 450 
      bool __cond = (_Bool)((int)*("Wake hwq %d\n" + 11UL) != 10);
      
#line 450 
      if ((int)__cond != 0) 
#line 450 
                            __compiletime_assert_450(); else ;
    }
    
#line 450 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_wake_queue","Wake hwq %d\n",txq->q.id);
    
#line 451 
    iwl_op_mode_queue_not_full(trans->op_mode,(int)txq->q.id);
  }
  else ;
  
#line 453 
  return;
}


#line 464 
void __compiletime_assert_465(void);


#line 455  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void iwl_stop_queue(struct iwl_trans *trans, struct iwl_txq *txq)
{
  int tmp;
  
#line 458 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 460 
  tmp = test_and_set_bit((long)txq->q.id,(unsigned long volatile *)(& trans_pcie->queue_stopped));
  
#line 460 
  if (tmp == 0) {
    
#line 461 
    iwl_op_mode_queue_full(trans->op_mode,(int)txq->q.id);
    {
      
#line 462 
      bool __cond = (_Bool)((int)*("Stop hwq %d\n" + 11UL) != 10);
      
#line 462 
      if ((int)__cond != 0) 
#line 462 
                            __compiletime_assert_462(); else ;
    }
    
#line 462 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_stop_queue","Stop hwq %d\n",txq->q.id);
  }
  else {
    {
      
#line 464 
      bool __cond_0 = (_Bool)((int)*("hwq %d already stopped\n" + 22UL) != 10);
      
#line 464 
      if ((int)__cond_0 != 0) 
#line 464 
                              __compiletime_assert_465(); else ;
    }
    
#line 464 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_stop_queue","hwq %d already stopped\n",txq->q.id);
  }
  
#line 466 
  return;
}


#line 468  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static bool iwl_queue_used(struct iwl_queue const *q, int i)
{
  bool __retres;
  int tmp;
  
#line 471 
  if (q->write_ptr >= q->read_ptr) 
#line 471 
                                   tmp = (q->read_ptr <= i && q->write_ptr > i) != 0; else 
                                                                    
#line 471 
                                                                    tmp = (q->read_ptr <= i || q->write_ptr > i) != 0;
  
#line 471 
  __retres = (_Bool)(tmp != 0);
  
#line 471 
  return __retres;
}


#line 494  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void __iwl_trans_pcie_set_bits_mask_0(struct iwl_trans *trans, u32 reg, u32 mask, u32 value)
{
  u32 v;
  {
    bool __warned;
    
#line 500 
    int __ret_warn_once = (~ mask & value) != 0U;
    
#line 500 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 500 
        int __ret_warn_on = ! __warned;
        
#line 500 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 500 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h",500); else ;
        
#line 500 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 500 
      if ((long)tmp != 0L) 
#line 500 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 500 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  
#line 503 
  v = iwl_read32_3(trans,reg);
  
#line 504 
  v = ~ mask & v;
  
#line 505 
  v |= value;
  
#line 506 
  iwl_write32_3(trans,reg,v);
  
#line 507 
  return;
}


#line 509  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void __iwl_trans_pcie_clear_bit_0(struct iwl_trans *trans, u32 reg, u32 mask)
{
  
#line 512 
  __iwl_trans_pcie_set_bits_mask_0(trans,reg,mask,0U);
  
#line 513 
  return;
}


#line 515  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/internal.h"
__inline static void __iwl_trans_pcie_set_bit_0(struct iwl_trans *trans, u32 reg, u32 mask)
{
  
#line 518 
  __iwl_trans_pcie_set_bits_mask_0(trans,reg,mask,mask);
  
#line 519 
  return;
}


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_queue_space(struct iwl_queue const *q)
{
  int __retres;
  unsigned int max;
  unsigned int used;
  int tmp;
  
#line 79 
  if (q->n_window <= 255) 
#line 80 
                          max = (unsigned int)q->n_window; else 
#line 82 
                                                                max = 255U;
  
#line 88 
  used = (unsigned int)(q->write_ptr - q->read_ptr) & 255U;
  {
    
#line 90 
    int __ret_warn_on = used > max;
    
#line 90 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 90 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",90); else ;
    
#line 90 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 90 
  if ((long)tmp != 0L) {
    
#line 91 
    __retres = 0;
    
#line 91 
    goto return_label;
  }
  else ;
  
#line 93 
  __retres = (int)(max - used);
  return_label: 
#line 93 
                return __retres;
}


#line 99  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_queue_init(struct iwl_queue *q, int slots_num, u32 id)
{
  int __retres;
  int tmp_1;
  
#line 101 
  q->n_window = slots_num;
  
#line 102 
  q->id = id;
  {
    int tmp_0;
    bool tmp;
    
#line 106 
    tmp = is_power_of_2((unsigned long)slots_num);
    
#line 106 
    if (tmp) 
#line 106 
             tmp_0 = 0; else 
#line 106 
                             tmp_0 = 1;
    
#line 106 
    int __ret_warn_on = tmp_0;
    
#line 106 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 106 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",106); else ;
    
#line 106 
    tmp_1 = (long)(__ret_warn_on != 0);
  }
  
#line 106 
  if ((long)tmp_1 != 0L) {
    
#line 107 
    __retres = -22;
    
#line 107 
    goto return_label;
  }
  else ;
  
#line 109 
  q->low_mark = q->n_window / 4;
  
#line 110 
  if (q->low_mark <= 3) 
#line 111 
                        q->low_mark = 4; else ;
  
#line 113 
  q->high_mark = q->n_window / 8;
  
#line 114 
  if (q->high_mark <= 1) 
#line 115 
                         q->high_mark = 2; else ;
  
#line 117 
  q->write_ptr = 0;
  
#line 118 
  q->read_ptr = 0;
  
#line 120 
  __retres = 0;
  return_label: 
#line 120 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_alloc_dma_ptr(struct iwl_trans *trans, struct iwl_dma_ptr *ptr, size_t size)
{
  int __retres;
  int tmp;
  {
    
#line 126 
    int __ret_warn_on = ptr->addr != (void *)0;
    
#line 126 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 126 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",126); else ;
    
#line 126 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 126 
  if ((long)tmp != 0L) {
    
#line 127 
    __retres = -22;
    
#line 127 
    goto return_label;
  }
  else ;
  
#line 129 
  ptr->addr = dma_alloc_attrs(trans->dev,size,& ptr->dma,208U,(struct dma_attrs *)0);
  
#line 131 
  if (ptr->addr == (void *)0) {
    
#line 132 
    __retres = -12;
    
#line 132 
    goto return_label;
  }
  else ;
  
#line 133 
  ptr->size = size;
  
#line 134 
  __retres = 0;
  return_label: 
#line 134 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_free_dma_ptr(struct iwl_trans *trans, struct iwl_dma_ptr *ptr)
{
  
#line 140 
  if ((long)(ptr->addr == (void *)0) != 0L) 
#line 141 
                                            goto return_label; else ;
  
#line 143 
  dma_free_attrs(trans->dev,ptr->size,ptr->addr,ptr->dma,(struct dma_attrs *)0);
  
#line 144 
  memset((void *)ptr,0,24UL);
  return_label: 
#line 145 
                return;
}


#line 165 
void __compiletime_assert_166(void);


#line 170 
void __compiletime_assert_170(void);


#line 147  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_txq_stuck_timer(unsigned long data)
{
  u8 buf[16U];
  int i;
  unsigned int tmp_0;
  u32 tmp_1;
  
#line 149 
  struct iwl_txq *txq = (struct iwl_txq *)data;
  
#line 150 
  struct iwl_trans_pcie *trans_pcie = txq->trans_pcie;
  
#line 151 
  struct iwl_trans *trans = iwl_trans_pcie_get_trans(trans_pcie);
  
#line 152 
  u32 scd_sram_addr = trans_pcie->scd_base_addr + (txq->q.id + 106U) * 16U;
  
#line 157 
  ldv_spin_lock_73_2(& txq->lock);
  
#line 159 
  if (txq->q.read_ptr == txq->q.write_ptr) {
    
#line 160 
    ldv_spin_unlock_74_2(& txq->lock);
    
#line 161 
    goto return_label;
  }
  else ;
  
#line 163 
  ldv_spin_unlock_75(& txq->lock);
  {
    
#line 165 
    bool __cond = (_Bool)((int)*("Queue %d stuck for %u ms.\n" + 25UL) != 10);
    
#line 165 
    if ((int)__cond != 0) 
#line 165 
                          __compiletime_assert_166(); else ;
  }
  
#line 165 
  tmp_0 = jiffies_to_msecs(txq->wd_timeout);
  
#line 165 
  ;
  
#line 165 
  ;
  
#line 165 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Queue %d stuck for %u ms.\n",txq->q.id,tmp_0);
  {
    
#line 167 
    bool __cond_0 = (_Bool)((int)*("Current SW read_ptr %d write_ptr %d\n" + 35UL) != 10);
    
#line 167 
    if ((int)__cond_0 != 0) 
#line 167 
                            __compiletime_assert_168(); else ;
  }
  
#line 167 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Current SW read_ptr %d write_ptr %d\n",txq->q.read_ptr,txq->q.write_ptr);
  {
    
#line 170 
    bool __cond_1 = (_Bool)0;
    
#line 170 
    if ((int)__cond_1 != 0) 
#line 170 
                            __compiletime_assert_170(); else ;
  }
  
#line 170 
  iwl_trans_read_mem(trans,scd_sram_addr,(void *)(& buf),4);
  
#line 172 
  print_hex_dump("\001","iwl data: ",2,16,1,(void const *)(& buf),16UL,(_Bool)1);
  
#line 174 
  i = 0;
  
#line 174 
  goto ldv_55221;
  ldv_55220: 
#line 175 
  ;
  {
    
#line 175 
    bool __cond_2 = (_Bool)((int)*("FH TRBs(%d) = 0x%08x\n" + 20UL) != 10);
    
#line 175 
    if ((int)__cond_2 != 0) 
#line 175 
                            __compiletime_assert_176(); else ;
  }
  
#line 175 
  tmp_1 = iwl_read_direct32(trans,(unsigned int)((i + 1622) * 4));
  
#line 175 
  ;
  
#line 175 
  ;
  
#line 175 
  __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"FH TRBs(%d) = 0x%08x\n",i,tmp_1);
  
#line 174 
  i += 1;
  ldv_55221: 
#line 175 
  ;
  
#line 174 
  if (i <= 7) 
#line 176 
              goto ldv_55220; else 
#line 179 
                                   goto ldv_55222;
  ldv_55222: 
#line 180 
  ;
  
#line 178 
  i = 0;
  
#line 178 
  goto ldv_55232;
  ldv_55231: 
#line 179 
  ;
  {
    u32 tmp_3;
    unsigned int tmp_2;
    u32 tmp_6;
    unsigned int tmp_5;
    u32 tmp_8;
    unsigned int tmp_7;
    char *tmp_9;
    
#line 179 
    tmp_2 = SCD_QUEUE_STATUS_BITS((unsigned int)i);
    
#line 179 
    ;
    
#line 179 
    tmp_3 = iwl_read_prph(trans,tmp_2);
    
#line 179 
    u32 status = tmp_3;
    
#line 180 
    u8 fifo = (unsigned char)((unsigned int)((unsigned char)status) & 7U);
    
#line 181 
    bool active = (_Bool)(((unsigned long)status & 8UL) != 0UL);
    
#line 182 
    u32 tbl_dw = iwl_trans_read_mem32(trans,trans_pcie->scd_base_addr + ((unsigned int)((i + 1008) * 2) & 65532U));
    
#line 187 
    if ((i & 1) != 0) 
#line 188 
                      tbl_dw >>= 16; else 
#line 190 
                                          tbl_dw &= 65535U;
    {
      
#line 192 
      bool __cond_3 = (_Bool)((int)*("Q %d is %sactive and mapped to fifo %d ra_tid 0x%04x [%d,%d]\n" + 60UL) != 10);
      
#line 192 
      if ((int)__cond_3 != 0) 
#line 192 
                              __compiletime_assert_197(); else ;
    }
    
#line 192 
    tmp_5 = SCD_QUEUE_WRPTR((unsigned int)i);
    
#line 192 
    ;
    
#line 192 
    tmp_6 = iwl_read_prph(trans,tmp_5);
    
#line 192 
    tmp_7 = SCD_QUEUE_RDPTR((unsigned int)i);
    
#line 192 
    ;
    
#line 192 
    tmp_8 = iwl_read_prph(trans,tmp_7);
    
#line 192 
    ;
    
#line 192 
    ;
    
#line 192 
    if ((int)active != 0) 
#line 192 
                          tmp_9 = (char *)""; else 
#line 192 
                                                   tmp_9 = (char *)"in";
    
#line 192 
    ;
    
#line 192 
    ;
    
#line 192 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Q %d is %sactive and mapped to fifo %d ra_tid 0x%04x [%d,%d]\n",i,tmp_9,(int)fifo,tbl_dw,tmp_8 & 255U,tmp_6);
  }
  
#line 178 
  i += 1;
  ldv_55232: 
#line 179 
  ;
  
#line 178 
  if (((trans->cfg)->base_params)->num_of_queues > i) 
#line 180 
                                                      goto ldv_55231; else 
                                                                    
#line 183 
                                                                    goto ldv_55233;
  ldv_55233: 
#line 184 
  ;
  
#line 200 
  iwl_force_nmi(trans);
  return_label: 
#line 201 
                return;
}


#line 206  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_txq_update_byte_cnt_tbl(struct iwl_trans *trans, struct iwl_txq *txq, u16 byte_cnt)
{
  struct iwlagn_scd_bc_tbl *scd_bc_tbl;
  __le16 bc_ent;
  
#line 210 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 211 
  int write_ptr = txq->q.write_ptr;
  
#line 212 
  int txq_id = (int)txq->q.id;
  
#line 213 
  u8 sec_ctl = (unsigned char)0U;
  
#line 214 
  u8 sta_id = (unsigned char)0U;
  
#line 215 
  u16 len = (unsigned short)((unsigned int)byte_cnt + 8U);
  
#line 217 
  struct iwl_tx_cmd *tx_cmd = (struct iwl_tx_cmd *)(& ((txq->entries + txq->q.write_ptr)->cmd)->payload);
  
#line 220 
  scd_bc_tbl = (struct iwlagn_scd_bc_tbl *)trans_pcie->scd_bc_tbls.addr;
  {
    
#line 222 
    int __ret_warn_on = ((unsigned int)len > 4095U || write_ptr > 255) != 0;
    
#line 222 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 222 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",222); else ;
    
#line 222 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 224 
  sta_id = tx_cmd->sta_id;
  
#line 225 
  sec_ctl = tx_cmd->sec_ctl;
  
#line 227 
  switch ((int)sec_ctl & 3) {
    case 2: 
#line 228 
    ;
    
#line 229 
    len = (unsigned short)((unsigned int)len + 8U);
    
#line 230 
    goto ldv_55251;
    case 3: 
#line 231 
    ;
    
#line 232 
    len = (unsigned short)((unsigned int)len + 4U);
    
#line 233 
    goto ldv_55251;
    case 1: 
#line 234 
    ;
    
#line 235 
    len = (unsigned short)((unsigned int)len + 8U);
    
#line 236 
    goto ldv_55251;
  }
  ldv_55251: 
#line 239 
  ;
  
#line 239 
  if ((int)trans_pcie->bc_table_dword != 0) 
#line 240 
                                            len = (unsigned short)(((int)len + 3) / 4); else ;
  
#line 242 
  bc_ent = (unsigned short)(((int)sta_id << 12) | (int)len);
  
#line 244 
  (scd_bc_tbl + txq_id)->tfd_offset[write_ptr] = bc_ent;
  
#line 246 
  if (write_ptr <= 63) 
#line 248 
                       (scd_bc_tbl + txq_id)->tfd_offset[write_ptr + 256] = bc_ent; else ;
  
#line 249 
  return;
}


#line 251  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_txq_inval_byte_cnt_tbl(struct iwl_trans *trans, struct iwl_txq *txq)
{
  __le16 bc_ent;
  
#line 254 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 256 
  struct iwlagn_scd_bc_tbl *scd_bc_tbl = (struct iwlagn_scd_bc_tbl *)trans_pcie->scd_bc_tbls.addr;
  
#line 257 
  int txq_id = (int)txq->q.id;
  
#line 258 
  int read_ptr = txq->q.read_ptr;
  
#line 259 
  u8 sta_id = (unsigned char)0U;
  
#line 261 
  struct iwl_tx_cmd *tx_cmd = (struct iwl_tx_cmd *)(& ((txq->entries + txq->q.read_ptr)->cmd)->payload);
  {
    
#line 264 
    int __ret_warn_on = read_ptr > 255;
    
#line 264 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 264 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",264); else ;
    
#line 264 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 266 
  if ((int)trans_pcie->cmd_queue != txq_id) 
#line 267 
                                            sta_id = tx_cmd->sta_id; else ;
  
#line 269 
  bc_ent = (unsigned short)(((int)sta_id << 12) | 1);
  
#line 270 
  (scd_bc_tbl + txq_id)->tfd_offset[read_ptr] = bc_ent;
  
#line 272 
  if (read_ptr <= 63) 
#line 274 
                      (scd_bc_tbl + txq_id)->tfd_offset[read_ptr + 256] = bc_ent; else ;
  
#line 275 
  return;
}


#line 306 
void __compiletime_assert_307(void);


#line 319 
void __compiletime_assert_319(void);


#line 280  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_txq_inc_wr_ptr(struct iwl_trans *trans, struct iwl_txq *txq)
{
  
#line 283 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 284 
  u32 reg = 0U;
  
#line 285 
  int txq_id = (int)txq->q.id;
  {
    int tmp_0;
    
#line 287 
    if (debug_locks != 0) {
      int tmp;
      
#line 287 
      tmp = lock_is_held(& txq->lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 287 
      if (tmp == 0) 
#line 287 
                    tmp_0 = 1; else 
#line 287 
                                    tmp_0 = 0;
    }
    else 
#line 287 
         tmp_0 = 0;
    
#line 287 
    int __ret_warn_on = tmp_0;
    
#line 287 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 287 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",287); else ;
    
#line 287 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 295 
  if (! ((trans->cfg)->base_params)->shadow_reg_enable && (int)trans_pcie->cmd_queue != txq_id) {
    int tmp_1;
    
#line 296 
    tmp_1 = constant_test_bit(2L,(unsigned long const volatile *)(& trans->status));
    
#line 296 
    if (tmp_1 != 0) {
      
#line 303 
      reg = iwl_read32_3(trans,84U);
      
#line 305 
      if ((reg & 1U) != 0U) {
        {
          
#line 306 
          bool __cond = (_Bool)((int)*("Tx queue %d requesting wakeup, GP1 = 0x%x\n" + 41UL) != 10);
          
#line 306 
          if ((int)__cond != 0) 
#line 306 
                                __compiletime_assert_307(); else ;
        }
        
#line 306 
        __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_txq_inc_wr_ptr","Tx queue %d requesting wakeup, GP1 = 0x%x\n",txq_id,reg);
        
#line 308 
        iwl_set_bit(trans,36U,8U);
        
#line 310 
        txq->need_update = (_Bool)1;
        
#line 311 
        goto return_label;
      }
      else ;
    }
    else ;
  }
  else ;
  {
    
#line 319 
    bool __cond_0 = (_Bool)((int)*("Q:%d WR: 0x%x\n" + 13UL) != 10);
    
#line 319 
    if ((int)__cond_0 != 0) 
#line 319 
                            __compiletime_assert_319(); else ;
  }
  
#line 319 
  __iwl_dbg(trans->dev,8388608U,(_Bool)0,"iwl_pcie_txq_inc_wr_ptr","Q:%d WR: 0x%x\n",txq_id,txq->q.write_ptr);
  
#line 320 
  iwl_write32_3(trans,1120U,(unsigned int)(txq->q.write_ptr | (txq_id << 8)));
  return_label: 
#line 321 
                return;
}


#line 323  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
void iwl_pcie_txq_check_wrptrs(struct iwl_trans *trans)
{
  int i;
  
#line 325 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 328 
  i = 0;
  
#line 328 
  goto ldv_55292;
  ldv_55291: 
#line 329 
  ;
  {
    
#line 329 
    struct iwl_txq *txq = trans_pcie->txq + i;
    
#line 331 
    ldv_spin_lock_bh_76(& txq->lock);
    
#line 332 
    if ((int)(trans_pcie->txq + i)->need_update != 0) {
      
#line 333 
      iwl_pcie_txq_inc_wr_ptr(trans,txq);
      
#line 334 
      (trans_pcie->txq + i)->need_update = (_Bool)0;
    }
    else ;
    
#line 336 
    ldv_spin_unlock_bh_77(& txq->lock);
  }
  
#line 328 
  i += 1;
  ldv_55292: 
#line 329 
  ;
  
#line 328 
  if (((trans->cfg)->base_params)->num_of_queues > i) 
#line 330 
                                                      goto ldv_55291; else 
                                                                    
#line 333 
                                                                    goto ldv_55293;
  ldv_55293: 
#line 334 
  ;
  
#line 335 
  return;
}


#line 340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
__inline static dma_addr_t iwl_pcie_tfd_tb_get_addr(struct iwl_tfd *tfd, u8 idx)
{
  u32 tmp;
  
#line 342 
  struct iwl_tfd_tb *tb = & tfd->tbs[(int)idx];
  
#line 344 
  tmp = get_unaligned_le32((void const *)(& tb->lo));
  
#line 344 
  dma_addr_t addr = (unsigned long long)tmp;
  
#line 346 
  addr = (((unsigned long long)tb->hi_n_len << 32) & 64424509440ULL) | addr;
  
#line 349 
  return addr;
}


#line 352  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
__inline static void iwl_pcie_tfd_set_tb(struct iwl_tfd *tfd, u8 idx, dma_addr_t addr, u16 len)
{
  
#line 355 
  struct iwl_tfd_tb *tb = & tfd->tbs[(int)idx];
  
#line 356 
  u16 hi_n_len = (unsigned short)((int)len << 4U);
  
#line 358 
  put_unaligned_le32((unsigned int)addr,(void *)(& tb->lo));
  
#line 360 
  hi_n_len = (unsigned short)(((unsigned int)((unsigned short)(addr >> 32)) & 15U) | (unsigned int)hi_n_len);
  
#line 362 
  tb->hi_n_len = hi_n_len;
  
#line 364 
  tfd->num_tbs = (unsigned char)((unsigned int)idx + 1U);
  
#line 365 
  return;
}


#line 367  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
__inline static u8 iwl_pcie_tfd_get_num_tbs(struct iwl_tfd *tfd)
{
  u8 __retres;
  
#line 369 
  __retres = (unsigned char)((unsigned int)tfd->num_tbs & 31U);
  
#line 369 
  return __retres;
}


#line 383 
void __compiletime_assert_383(void);


#line 372  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_tfd_unmap(struct iwl_trans *trans, struct iwl_cmd_meta *meta, struct iwl_tfd *tfd)
{
  int i;
  int num_tbs;
  u8 tmp;
  u16 tmp_0;
  dma_addr_t tmp_1;
  
#line 380 
  tmp = iwl_pcie_tfd_get_num_tbs(tfd);
  
#line 380 
  num_tbs = (int)tmp;
  
#line 382 
  if (num_tbs > 19) {
    {
      
#line 383 
      bool __cond = (_Bool)((int)*("Too many chunks: %i\n" + 19UL) != 10);
      
#line 383 
      if ((int)__cond != 0) 
#line 383 
                            __compiletime_assert_383(); else ;
    }
    
#line 383 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Too many chunks: %i\n",num_tbs);
    
#line 385 
    goto return_label;
  }
  else ;
  
#line 390 
  i = 1;
  
#line 390 
  goto ldv_55323;
  ldv_55322: 
#line 391 
  ;
  
#line 391 
  tmp_0 = iwl_pcie_tfd_tb_get_len(tfd,(unsigned char)((int)((unsigned char)i)));
  
#line 391 
  tmp_1 = iwl_pcie_tfd_tb_get_addr(tfd,(unsigned char)((int)((unsigned char)i)));
  
#line 391 
  ;
  
#line 391 
  dma_unmap_single_attrs(trans->dev,tmp_1,(unsigned long)tmp_0,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 390 
  i += 1;
  ldv_55323: 
#line 391 
  ;
  
#line 390 
  if (i < num_tbs) 
#line 392 
                   goto ldv_55322; else 
#line 395 
                                        goto ldv_55324;
  ldv_55324: 
#line 396 
  ;
  
#line 395 
  tfd->num_tbs = (unsigned char)0U;
  return_label: 
#line 396 
                return;
}


#line 407  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_txq_free_tfd(struct iwl_trans *trans, struct iwl_txq *txq)
{
  u8 tmp;
  
#line 409 
  struct iwl_tfd *tfd_tmp = txq->tfds;
  
#line 414 
  int rd_ptr = txq->q.read_ptr;
  
#line 415 
  tmp = get_cmd_index(& txq->q,(unsigned int)rd_ptr);
  
#line 415 
  int idx = (int)tmp;
  {
    int tmp_1;
    
#line 417 
    if (debug_locks != 0) {
      int tmp_0;
      
#line 417 
      tmp_0 = lock_is_held(& txq->lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 417 
      if (tmp_0 == 0) 
#line 417 
                      tmp_1 = 1; else 
#line 417 
                                      tmp_1 = 0;
    }
    else 
#line 417 
         tmp_1 = 0;
    
#line 417 
    int __ret_warn_on = tmp_1;
    
#line 417 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 417 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",417); else ;
    
#line 417 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 422 
  iwl_pcie_tfd_unmap(trans,& (txq->entries + idx)->meta,tfd_tmp + rd_ptr);
  
#line 425 
  if (txq->entries != (struct iwl_pcie_txq_entry *)0) {
    struct sk_buff *skb;
    
#line 428 
    skb = (txq->entries + idx)->skb;
    
#line 434 
    if (skb != (struct sk_buff *)0) {
      
#line 435 
      iwl_op_mode_free_skb(trans->op_mode,skb);
      
#line 436 
      (txq->entries + idx)->skb = (struct sk_buff *)0;
    }
    else ;
  }
  else ;
  
#line 439 
  return;
}


#line 459 
void __compiletime_assert_460(void);


#line 441  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_txq_build_tfd(struct iwl_trans *trans, struct iwl_txq *txq, dma_addr_t addr, u16 len, bool reset)
{
  int __retres;
  struct iwl_queue *q;
  struct iwl_tfd *tfd;
  struct iwl_tfd *tfd_tmp;
  u32 num_tbs;
  u8 tmp;
  int tmp_0;
  
#line 448 
  q = & txq->q;
  
#line 449 
  tfd_tmp = txq->tfds;
  
#line 450 
  tfd = tfd_tmp + q->write_ptr;
  
#line 452 
  if ((int)reset != 0) 
#line 453 
                       memset((void *)tfd,0,128UL); else ;
  
#line 455 
  tmp = iwl_pcie_tfd_get_num_tbs(tfd);
  
#line 455 
  num_tbs = (unsigned int)tmp;
  
#line 458 
  if (num_tbs > 19U) {
    {
      
#line 459 
      bool __cond = (_Bool)((int)*("Error can not send more than %d chunks\n" + 38UL) != 10);
      
#line 459 
      if ((int)__cond != 0) 
#line 459 
                            __compiletime_assert_460(); else ;
    }
    
#line 459 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Error can not send more than %d chunks\n",20);
    
#line 461 
    __retres = -22;
    
#line 461 
    goto return_label;
  }
  else ;
  {
    
#line 464 
    int __ret_warn_on = (addr & 18446744004990074880ULL) != 0ULL;
    
#line 464 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 464 
                                          warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",465,"Unaligned address = %llx\n",addr); else ;
    
#line 464 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 464 
  if ((long)tmp_0 != 0L) {
    
#line 466 
    __retres = -22;
    
#line 466 
    goto return_label;
  }
  else ;
  
#line 468 
  iwl_pcie_tfd_set_tb(tfd,(unsigned char)((int)((unsigned char)num_tbs)),addr,(unsigned short)((int)len));
  
#line 470 
  __retres = 0;
  return_label: 
#line 470 
                return __retres;
}


#line 515 
void __compiletime_assert_517(void);


#line 473  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_txq_alloc(struct iwl_trans *trans, struct iwl_txq *txq, int slots_num, u32 txq_id)
{
  int __retres;
  size_t scratchbuf_sz;
  int i;
  int tmp;
  
#line 477 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 478 
  size_t tfd_sz = 32768UL;
  {
    
#line 482 
    int __ret_warn_on = (txq->entries != (struct iwl_pcie_txq_entry *)0 || txq->tfds != (struct iwl_tfd *)0) != 0;
    
#line 482 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 482 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",482); else ;
    
#line 482 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 482 
  if ((long)tmp != 0L) {
    
#line 483 
    __retres = -22;
    
#line 483 
    goto return_label;
  }
  else ;
  {
    struct lock_class_key __key;
    
#line 485 
    init_timer_key(& txq->stuck_timer,0U,"((&txq->stuck_timer))",& __key);
  }
  
#line 485 
  txq->stuck_timer.function = & iwl_pcie_txq_stuck_timer;
  
#line 485 
  txq->stuck_timer.data = (unsigned long)txq;
  
#line 487 
  txq->trans_pcie = trans_pcie;
  
#line 489 
  txq->q.n_window = slots_num;
  
#line 491 
  txq->entries = (struct iwl_pcie_txq_entry *)kcalloc((unsigned long)slots_num,40UL,208U);
  
#line 495 
  if (txq->entries == (struct iwl_pcie_txq_entry *)0) 
#line 496 
                                                      goto error; else ;
  
#line 498 
  if ((unsigned int)trans_pcie->cmd_queue == txq_id) {
    
#line 499 
    i = 0;
    
#line 499 
    goto ldv_55367;
    ldv_55366: 
#line 500 
    ;
    
#line 501 
    (txq->entries + i)->cmd = (struct iwl_device_cmd *)kmalloc_0(324UL,208U);
    
#line 503 
    if ((txq->entries + i)->cmd == (struct iwl_device_cmd *)0) 
#line 504 
                                                               goto error; else ;
    
#line 499 
    i += 1;
    ldv_55367: 
#line 500 
    ;
    
#line 499 
    if (i < slots_num) 
#line 501 
                       goto ldv_55366; else 
#line 504 
                                            goto ldv_55368;
    ldv_55368: 
#line 505 
    ;
  }
  else ;
  
#line 509 
  txq->tfds = (struct iwl_tfd *)dma_alloc_attrs(trans->dev,tfd_sz,& txq->q.dma_addr,208U,(struct dma_attrs *)0);
  
#line 511 
  if (txq->tfds == (struct iwl_tfd *)0) 
#line 512 
                                        goto error; else ;
  {
    
#line 514 
    bool __cond = (_Bool)0;
    
#line 514 
    if ((int)__cond != 0) 
#line 514 
                          __compiletime_assert_514(); else ;
  }
  {
    
#line 515 
    bool __cond_0 = (_Bool)0;
    
#line 515 
    if ((int)__cond_0 != 0) 
#line 515 
                            __compiletime_assert_517(); else ;
  }
  
#line 519 
  scratchbuf_sz = (unsigned long)slots_num * 16UL;
  
#line 521 
  txq->scratchbufs = (struct iwl_pcie_txq_scratch_buf *)dma_alloc_attrs(trans->dev,scratchbuf_sz,& txq->scratchbufs_dma,208U,(struct dma_attrs *)0);
  
#line 524 
  if (txq->scratchbufs == (struct iwl_pcie_txq_scratch_buf *)0) 
#line 525 
                                                                goto err_free_tfds; else ;
  
#line 527 
  txq->q.id = txq_id;
  
#line 529 
  __retres = 0;
  
#line 529 
  goto return_label;
  err_free_tfds: 
#line 530 
  ;
  
#line 531 
  dma_free_attrs(trans->dev,tfd_sz,(void *)txq->tfds,txq->q.dma_addr,(struct dma_attrs *)0);
  error: 
#line 532 
  ;
  
#line 533 
  if (txq->entries != (struct iwl_pcie_txq_entry *)0 && (unsigned int)trans_pcie->cmd_queue == txq_id) {
    
#line 534 
    i = 0;
    
#line 534 
    goto ldv_55379;
    ldv_55378: 
#line 535 
    ;
    
#line 535 
    kfree((void const *)(txq->entries + i)->cmd);
    
#line 534 
    i += 1;
    ldv_55379: 
#line 535 
    ;
    
#line 534 
    if (i < slots_num) 
#line 536 
                       goto ldv_55378; else 
#line 539 
                                            goto ldv_55380;
    ldv_55380: 
#line 540 
    ;
  }
  else ;
  
#line 536 
  kfree((void const *)txq->entries);
  
#line 537 
  txq->entries = (struct iwl_pcie_txq_entry *)0;
  
#line 539 
  __retres = -12;
  return_label: 
#line 539 
                return __retres;
}


#line 552 
void __compiletime_assert_552(void);


#line 543  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_txq_init(struct iwl_trans *trans, struct iwl_txq *txq, int slots_num, u32 txq_id)
{
  int __retres;
  int ret;
  unsigned int tmp;
  
#line 548 
  txq->need_update = (_Bool)0;
  {
    
#line 552 
    bool __cond = (_Bool)0;
    
#line 552 
    if ((int)__cond != 0) 
#line 552 
                          __compiletime_assert_552(); else ;
  }
  
#line 555 
  ret = iwl_queue_init(& txq->q,slots_num,txq_id);
  
#line 556 
  if (ret != 0) {
    
#line 557 
    __retres = ret;
    
#line 557 
    goto return_label;
  }
  else ;
  
#line 559 
  spinlock_check(& txq->lock);
  {
    struct lock_class_key __key;
    
#line 559 
    __raw_spin_lock_init(& txq->lock.__anonCompField_spinlock_18.rlock,"&(&txq->lock)->rlock",& __key);
  }
  
#line 565 
  ;
  
#line 565 
  tmp = FH_MEM_CBBC_QUEUE(txq_id);
  
#line 565 
  ;
  
#line 565 
  iwl_write_direct32(trans,tmp,(unsigned int)(txq->q.dma_addr >> 8));
  
#line 568 
  __retres = 0;
  return_label: 
#line 568 
                return __retres;
}


#line 582 
void __compiletime_assert_583(void);


#line 574  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_txq_unmap(struct iwl_trans *trans, int txq_id)
{
  
#line 576 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 577 
  struct iwl_txq *txq = trans_pcie->txq + txq_id;
  
#line 578 
  struct iwl_queue *q = & txq->q;
  
#line 580 
  ldv_spin_lock_bh_78(& txq->lock);
  
#line 581 
  goto ldv_55406;
  ldv_55405: 
#line 582 
  ;
  {
    
#line 582 
    bool __cond = (_Bool)((int)*("Q %d Free %d\n" + 12UL) != 10);
    
#line 582 
    if ((int)__cond != 0) 
#line 582 
                          __compiletime_assert_583(); else ;
  }
  
#line 582 
  __iwl_dbg(trans->dev,1073741824U,(_Bool)0,"iwl_pcie_txq_unmap","Q %d Free %d\n",txq_id,q->read_ptr);
  
#line 584 
  iwl_pcie_txq_free_tfd(trans,txq);
  
#line 585 
  q->read_ptr = iwl_queue_inc_wrap(q->read_ptr);
  ldv_55406: 
#line 586 
  ;
  
#line 581 
  if (q->write_ptr != q->read_ptr) 
#line 583 
                                   goto ldv_55405; else 
#line 586 
                                                        goto ldv_55407;
  ldv_55407: 
#line 587 
  ;
  
#line 587 
  txq->active = (unsigned char)0U;
  
#line 588 
  ldv_spin_unlock_bh_79(& txq->lock);
  
#line 591 
  iwl_wake_queue(trans,txq);
  
#line 592 
  return;
}


#line 602  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_txq_free(struct iwl_trans *trans, int txq_id)
{
  int i;
  int tmp;
  
#line 604 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 605 
  struct iwl_txq *txq = trans_pcie->txq + txq_id;
  
#line 606 
  struct device *dev = trans->dev;
  {
    
#line 609 
    int __ret_warn_on = txq == (struct iwl_txq *)0;
    
#line 609 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 609 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",609); else ;
    
#line 609 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 609 
  if ((long)tmp != 0L) 
#line 610 
                       goto return_label; else ;
  
#line 612 
  iwl_pcie_txq_unmap(trans,txq_id);
  
#line 615 
  if ((int)trans_pcie->cmd_queue == txq_id) {
    
#line 616 
    i = 0;
    
#line 616 
    goto ldv_55419;
    ldv_55418: 
#line 617 
    ;
    
#line 617 
    kzfree((void const *)(txq->entries + i)->cmd);
    
#line 618 
    kzfree((txq->entries + i)->free_buf);
    
#line 616 
    i += 1;
    ldv_55419: 
#line 617 
    ;
    
#line 616 
    if (txq->q.n_window > i) 
#line 618 
                             goto ldv_55418; else 
#line 621 
                                                  goto ldv_55420;
    ldv_55420: 
#line 622 
    ;
  }
  else ;
  
#line 622 
  if (txq->tfds != (struct iwl_tfd *)0) {
    
#line 623 
    dma_free_attrs(dev,32768UL,(void *)txq->tfds,txq->q.dma_addr,(struct dma_attrs *)0);
    
#line 626 
    txq->q.dma_addr = 0ULL;
    
#line 627 
    txq->tfds = (struct iwl_tfd *)0;
    
#line 629 
    dma_free_attrs(dev,(unsigned long)txq->q.n_window * 16UL,(void *)txq->scratchbufs,txq->scratchbufs_dma,(struct dma_attrs *)0);
  }
  else ;
  
#line 634 
  kfree((void const *)txq->entries);
  
#line 635 
  txq->entries = (struct iwl_pcie_txq_entry *)0;
  
#line 637 
  ldv_del_timer_sync_80(& txq->stuck_timer);
  
#line 640 
  memset((void *)txq,0,296UL);
  return_label: 
#line 641 
                return;
}


#line 643  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
void iwl_pcie_tx_start(struct iwl_trans *trans, u32 scd_base_addr)
{
  int chan;
  u32 reg_val;
  
#line 645 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 646 
  int nq = ((trans->cfg)->base_params)->num_of_queues;
  
#line 649 
  int clear_dwords = (int)((unsigned long)(((nq + 1008) * 2 & 65532) + -1536) / 4UL);
  
#line 653 
  memset((void *)(& trans_pcie->queue_stopped),0,8UL);
  
#line 654 
  memset((void *)(& trans_pcie->queue_used),0,8UL);
  
#line 656 
  trans_pcie->scd_base_addr = iwl_read_prph(trans,10497024U);
  {
    
#line 659 
    int __ret_warn_on = (scd_base_addr != 0U && trans_pcie->scd_base_addr != scd_base_addr) != 0;
    
#line 659 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 659 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",660); else ;
    
#line 659 
    long tmp = (long)(__ret_warn_on != 0);
  }
  
#line 663 
  iwl_trans_write_mem(trans,trans_pcie->scd_base_addr + 1536U,(void const *)0,clear_dwords);
  
#line 667 
  iwl_write_prph(trans,10497032U,(unsigned int)(trans_pcie->scd_bc_tbls.dma >> 10));
  
#line 673 
  if ((int)((trans->cfg)->base_params)->scd_chain_ext_wa != 0) 
#line 674 
                                                               iwl_write_prph(trans,10497604U,0U); else ;
  
#line 676 
  iwl_trans_ac_txq_enable(trans,(int)trans_pcie->cmd_queue,(int)trans_pcie->cmd_fifo,trans_pcie->cmd_q_wdg_timeout);
  
#line 681 
  iwl_scd_activate_fifos(trans);
  
#line 684 
  chan = 0;
  
#line 684 
  goto ldv_55433;
  ldv_55432: 
#line 685 
  ;
  
#line 685 
  iwl_write_direct32(trans,(unsigned int)((chan + 232) * 32),2147483656U);
  
#line 684 
  chan += 1;
  ldv_55433: 
#line 685 
  ;
  
#line 684 
  if (chan <= 7) 
#line 686 
                 goto ldv_55432; else 
#line 689 
                                      goto ldv_55434;
  ldv_55434: 
#line 690 
  ;
  
#line 690 
  reg_val = iwl_read_direct32(trans,7832U);
  
#line 691 
  iwl_write_direct32(trans,7832U,reg_val | 2U);
  
#line 695 
  if ((trans->cfg)->device_family != (unsigned int)IWL_DEVICE_FAMILY_8000) 
    
#line 696 
    iwl_clear_bits_prph(trans,12304U,2048U); else ;
  
#line 697 
  return;
}


#line 700  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
void iwl_trans_pcie_tx_reset(struct iwl_trans *trans)
{
  int txq_id;
  
#line 702 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 705 
  txq_id = 0;
  
#line 705 
  goto ldv_55442;
  ldv_55441: 
#line 706 
  ;
  {
    unsigned int tmp;
    
#line 707 
    struct iwl_txq *txq = trans_pcie->txq + txq_id;
    
#line 709 
    ;
    
#line 709 
    tmp = FH_MEM_CBBC_QUEUE((unsigned int)txq_id);
    
#line 709 
    ;
    
#line 709 
    iwl_write_direct32(trans,tmp,(unsigned int)(txq->q.dma_addr >> 8));
    
#line 711 
    iwl_pcie_txq_unmap(trans,txq_id);
    
#line 712 
    txq->q.read_ptr = 0;
    
#line 713 
    txq->q.write_ptr = 0;
  }
  
#line 706 
  txq_id += 1;
  ldv_55442: 
#line 707 
  ;
  
#line 705 
  if (((trans->cfg)->base_params)->num_of_queues > txq_id) 
#line 707 
                                                           goto ldv_55441; else 
                                                                    
#line 710 
                                                                    goto ldv_55443;
  ldv_55443: 
#line 711 
  ;
  
#line 717 
  iwl_write_direct32(trans,6524U,(unsigned int)(trans_pcie->kw.dma >> 4));
  
#line 725 
  iwl_pcie_tx_start(trans,0U);
  
#line 726 
  return;
}


#line 749 
void __compiletime_assert_751(void);


#line 728  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_tx_stop_fh(struct iwl_trans *trans)
{
  unsigned long flags;
  int ch;
  int ret;
  bool tmp;
  
#line 730 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 733 
  u32 mask = 0U;
  
#line 735 
  ldv_spin_lock_81_0(& trans_pcie->irq_lock);
  
#line 737 
  tmp = (*((trans->ops)->grab_nic_access))(trans,(_Bool)0,& flags);
  
#line 737 
  if ((long)((int)tmp != 0) == 0L) 
#line 738 
                                   goto out; else ;
  
#line 741 
  ch = 0;
  
#line 741 
  goto ldv_55454;
  ldv_55453: 
#line 742 
  ;
  
#line 742 
  iwl_write32_3(trans,(unsigned int)((ch + 232) * 32),0U);
  
#line 743 
  mask = (unsigned int)((1 << ch) << 16) | mask;
  
#line 741 
  ch += 1;
  ldv_55454: 
#line 742 
  ;
  
#line 741 
  if (ch <= 7) 
#line 743 
               goto ldv_55453; else 
#line 746 
                                    goto ldv_55455;
  ldv_55455: 
#line 747 
  ;
  
#line 747 
  ret = iwl_poll_bit(trans,7856U,mask,mask,5000);
  
#line 748 
  if (ret < 0) {
    u32 tmp_0;
    {
      
#line 749 
      bool __cond = (_Bool)((int)*("Failing on timeout while stopping DMA channel %d [0x%08x]\n" + 57UL) != 10);
      
#line 749 
      if ((int)__cond != 0) 
#line 749 
                            __compiletime_assert_751(); else ;
    }
    
#line 749 
    tmp_0 = iwl_read32_3(trans,7856U);
    
#line 749 
    ;
    
#line 749 
    ;
    
#line 749 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Failing on timeout while stopping DMA channel %d [0x%08x]\n",ch,tmp_0);
  }
  else ;
  
#line 753 
  iwl_trans_release_nic_access(trans,& flags);
  out: 
#line 755 
  ;
  
#line 756 
  ldv_spin_unlock_82_1(& trans_pcie->irq_lock);
  
#line 757 
  return;
}


#line 762  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
int iwl_pcie_tx_stop(struct iwl_trans *trans)
{
  int __retres;
  int txq_id;
  
#line 764 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 768 
  iwl_scd_deactivate_fifos(trans);
  
#line 771 
  iwl_pcie_tx_stop_fh(trans);
  
#line 778 
  memset((void *)(& trans_pcie->queue_stopped),0,8UL);
  
#line 779 
  memset((void *)(& trans_pcie->queue_used),0,8UL);
  
#line 782 
  if (trans_pcie->txq == (struct iwl_txq *)0) {
    
#line 783 
    __retres = 0;
    
#line 783 
    goto return_label;
  }
  else ;
  
#line 786 
  txq_id = 0;
  
#line 786 
  goto ldv_55466;
  ldv_55465: 
#line 787 
  ;
  
#line 788 
  iwl_pcie_txq_unmap(trans,txq_id);
  
#line 787 
  txq_id += 1;
  ldv_55466: 
#line 788 
  ;
  
#line 786 
  if (((trans->cfg)->base_params)->num_of_queues > txq_id) 
#line 788 
                                                           goto ldv_55465; else 
                                                                    
#line 791 
                                                                    goto ldv_55467;
  ldv_55467: 
#line 792 
  ;
  
#line 790 
  __retres = 0;
  return_label: 
#line 790 
                return __retres;
}


#line 798  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
void iwl_pcie_tx_free(struct iwl_trans *trans)
{
  int txq_id;
  
#line 801 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 804 
  if (trans_pcie->txq != (struct iwl_txq *)0) {
    
#line 805 
    txq_id = 0;
    
#line 805 
    goto ldv_55474;
    ldv_55473: 
#line 806 
    ;
    
#line 807 
    iwl_pcie_txq_free(trans,txq_id);
    
#line 806 
    txq_id += 1;
    ldv_55474: 
#line 807 
    ;
    
#line 806 
    if (((trans->cfg)->base_params)->num_of_queues > txq_id) 
#line 808 
                                                             goto ldv_55473; else 
                                                                    
#line 811 
                                                                    goto ldv_55475;
    ldv_55475: 
#line 812 
    ;
  }
  else ;
  
#line 810 
  kfree((void const *)trans_pcie->txq);
  
#line 811 
  trans_pcie->txq = (struct iwl_txq *)0;
  
#line 813 
  iwl_pcie_free_dma_ptr(trans,& trans_pcie->kw);
  
#line 815 
  iwl_pcie_free_dma_ptr(trans,& trans_pcie->scd_bc_tbls);
  
#line 816 
  return;
}


#line 841 
void __compiletime_assert_841(void);


#line 848 
void __compiletime_assert_848(void);


#line 855 
void __compiletime_assert_855(void);


#line 868 
void __compiletime_assert_868(void);


#line 822  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_tx_alloc(struct iwl_trans *trans)
{
  int __retres;
  int ret;
  int txq_id;
  int slots_num;
  int tmp;
  
#line 826 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 828 
  u16 scd_bc_tbls_size = (unsigned short)((unsigned int)((unsigned short)((unsigned long)((trans->cfg)->base_params)->num_of_queues)) * 640U);
  {
    
#line 833 
    int __ret_warn_on = trans_pcie->txq != (struct iwl_txq *)0;
    
#line 833 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 833 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",833); else ;
    
#line 833 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 833 
  if ((long)tmp != 0L) {
    
#line 834 
    ret = -22;
    
#line 835 
    goto error;
  }
  else ;
  
#line 838 
  ret = iwl_pcie_alloc_dma_ptr(trans,& trans_pcie->scd_bc_tbls,(unsigned long)scd_bc_tbls_size);
  
#line 840 
  if (ret != 0) {
    {
      
#line 841 
      bool __cond = (_Bool)((int)*("Scheduler BC Table allocation failed\n" + 36UL) != 10);
      
#line 841 
      if ((int)__cond != 0) 
#line 841 
                            __compiletime_assert_841(); else ;
    }
    
#line 841 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Scheduler BC Table allocation failed\n");
    
#line 842 
    goto error;
  }
  else ;
  
#line 846 
  ret = iwl_pcie_alloc_dma_ptr(trans,& trans_pcie->kw,4096UL);
  
#line 847 
  if (ret != 0) {
    {
      
#line 848 
      bool __cond_0 = (_Bool)((int)*("Keep Warm allocation failed\n" + 27UL) != 10);
      
#line 848 
      if ((int)__cond_0 != 0) 
#line 848 
                              __compiletime_assert_848(); else ;
    }
    
#line 848 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Keep Warm allocation failed\n");
    
#line 849 
    goto error;
  }
  else ;
  
#line 852 
  trans_pcie->txq = (struct iwl_txq *)kcalloc((unsigned long)((trans->cfg)->base_params)->num_of_queues,296UL,208U);
  
#line 854 
  if (trans_pcie->txq == (struct iwl_txq *)0) {
    {
      
#line 855 
      bool __cond_1 = (_Bool)((int)*("Not enough memory for txq\n" + 25UL) != 10);
      
#line 855 
      if ((int)__cond_1 != 0) 
#line 855 
                              __compiletime_assert_855(); else ;
    }
    
#line 855 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Not enough memory for txq\n");
    
#line 856 
    ret = -12;
    
#line 857 
    goto error;
  }
  else ;
  
#line 861 
  txq_id = 0;
  
#line 861 
  goto ldv_55504;
  ldv_55503: 
#line 862 
  ;
  
#line 863 
  if ((int)trans_pcie->cmd_queue == txq_id) 
#line 863 
                                            slots_num = 32; else 
#line 863 
                                                                 slots_num = 256;
  
#line 865 
  ret = iwl_pcie_txq_alloc(trans,trans_pcie->txq + txq_id,slots_num,(unsigned int)txq_id);
  
#line 867 
  if (ret != 0) {
    {
      
#line 868 
      bool __cond_2 = (_Bool)((int)*("Tx %d queue alloc failed\n" + 24UL) != 10);
      
#line 868 
      if ((int)__cond_2 != 0) 
#line 868 
                              __compiletime_assert_868(); else ;
    }
    
#line 868 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Tx %d queue alloc failed\n",txq_id);
    
#line 869 
    goto error;
  }
  else ;
  
#line 862 
  txq_id += 1;
  ldv_55504: 
#line 863 
  ;
  
#line 861 
  if (((trans->cfg)->base_params)->num_of_queues > txq_id) 
#line 863 
                                                           goto ldv_55503; else 
                                                                    
#line 866 
                                                                    goto ldv_55505;
  ldv_55505: 
#line 867 
  ;
  
#line 873 
  __retres = 0;
  
#line 873 
  goto return_label;
  error: 
#line 875 
  ;
  
#line 876 
  iwl_pcie_tx_free(trans);
  
#line 878 
  __retres = ret;
  return_label: 
#line 878 
                return __retres;
}


#line 913 
void __compiletime_assert_913(void);


#line 880  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
int iwl_pcie_tx_init(struct iwl_trans *trans)
{
  int __retres;
  int ret;
  int txq_id;
  int slots_num;
  
#line 882 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 885 
  bool alloc = (_Bool)0;
  
#line 887 
  if (trans_pcie->txq == (struct iwl_txq *)0) {
    
#line 888 
    ret = iwl_pcie_tx_alloc(trans);
    
#line 889 
    if (ret != 0) 
#line 890 
                  goto error; else ;
    
#line 891 
    alloc = (_Bool)1;
  }
  else ;
  
#line 894 
  ldv_spin_lock_83_0(& trans_pcie->irq_lock);
  
#line 897 
  iwl_scd_deactivate_fifos(trans);
  
#line 900 
  iwl_write_direct32(trans,6524U,(unsigned int)(trans_pcie->kw.dma >> 4));
  
#line 903 
  ldv_spin_unlock_84_0(& trans_pcie->irq_lock);
  
#line 906 
  txq_id = 0;
  
#line 906 
  goto ldv_55520;
  ldv_55519: 
#line 907 
  ;
  
#line 908 
  if ((int)trans_pcie->cmd_queue == txq_id) 
#line 908 
                                            slots_num = 32; else 
#line 908 
                                                                 slots_num = 256;
  
#line 910 
  ret = iwl_pcie_txq_init(trans,trans_pcie->txq + txq_id,slots_num,(unsigned int)txq_id);
  
#line 912 
  if (ret != 0) {
    {
      
#line 913 
      bool __cond = (_Bool)((int)*("Tx %d queue init failed\n" + 23UL) != 10);
      
#line 913 
      if ((int)__cond != 0) 
#line 913 
                            __compiletime_assert_913(); else ;
    }
    
#line 913 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Tx %d queue init failed\n",txq_id);
    
#line 914 
    goto error;
  }
  else ;
  
#line 907 
  txq_id += 1;
  ldv_55520: 
#line 908 
  ;
  
#line 906 
  if (((trans->cfg)->base_params)->num_of_queues > txq_id) 
#line 908 
                                                           goto ldv_55519; else 
                                                                    
#line 911 
                                                                    goto ldv_55521;
  ldv_55521: 
#line 912 
  ;
  
#line 918 
  if (((trans->cfg)->base_params)->num_of_queues > 20) 
#line 919 
                                                       iwl_set_bits_prph(trans,10497448U,1U); else ;
  
#line 922 
  __retres = 0;
  
#line 922 
  goto return_label;
  error: 
#line 923 
  ;
  
#line 925 
  if ((int)alloc != 0) 
#line 926 
                       iwl_pcie_tx_free(trans); else ;
  
#line 927 
  __retres = ret;
  return_label: 
#line 927 
                return __retres;
}


#line 930  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
__inline static void iwl_pcie_txq_progress(struct iwl_txq *txq)
{
  {
    int tmp_0;
    
#line 932 
    if (debug_locks != 0) {
      int tmp;
      
#line 932 
      tmp = lock_is_held(& txq->lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 932 
      if (tmp == 0) 
#line 932 
                    tmp_0 = 1; else 
#line 932 
                                    tmp_0 = 0;
    }
    else 
#line 932 
         tmp_0 = 0;
    
#line 932 
    int __ret_warn_on = tmp_0;
    
#line 932 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 932 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",932); else ;
    
#line 932 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 934 
  if (txq->wd_timeout == 0UL) 
#line 935 
                              goto return_label; else ;
  
#line 941 
  if ((int)txq->frozen != 0) 
#line 942 
                             goto return_label; else ;
  
#line 948 
  if (txq->q.read_ptr == txq->q.write_ptr) 
#line 949 
                                           ldv_del_timer_85(& txq->stuck_timer); else 
                                                                    
#line 951 
                                                                    ldv_mod_timer_86(& txq->stuck_timer,txq->wd_timeout + jiffies);
  return_label: 
#line 952 
                return;
}


#line 971 
void __compiletime_assert_972(void);


#line 979 
void __compiletime_assert_980(void);


#line 987 
void __compiletime_assert_990(void);


#line 1019 
void __compiletime_assert_1019(void);


#line 955  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn, struct sk_buff_head *skbs)
{
  int last_to_free;
  int tmp;
  int tmp_1;
  bool tmp_0;
  int tmp_3;
  int tmp_5;
  int tmp_6;
  
#line 958 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 959 
  struct iwl_txq *txq = trans_pcie->txq + txq_id;
  
#line 960 
  int tfd_num = ssn & 255;
  
#line 961 
  struct iwl_queue *q = & txq->q;
  {
    
#line 965 
    int __ret_warn_on = (int)trans_pcie->cmd_queue == txq_id;
    
#line 965 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 965 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",965); else ;
    
#line 965 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 965 
  if ((long)tmp != 0L) 
#line 966 
                       goto return_label; else ;
  
#line 968 
  ldv_spin_lock_bh_87_0(& txq->lock);
  
#line 970 
  if ((unsigned int)txq->active == 0U) {
    {
      
#line 971 
      bool __cond = (_Bool)((int)*("Q %d inactive - ignoring idx %d\n" + 31UL) != 10);
      
#line 971 
      if ((int)__cond != 0) 
#line 971 
                            __compiletime_assert_972(); else ;
    }
    
#line 971 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_trans_pcie_reclaim","Q %d inactive - ignoring idx %d\n",txq_id,ssn);
    
#line 973 
    goto out;
  }
  else ;
  
#line 976 
  if (txq->q.read_ptr == tfd_num) 
#line 977 
                                  goto out; else ;
  {
    
#line 979 
    bool __cond_0 = (_Bool)((int)*("[Q %d] %d -> %d (%d)\n" + 20UL) != 10);
    
#line 979 
    if ((int)__cond_0 != 0) 
#line 979 
                            __compiletime_assert_980(); else ;
  }
  
#line 979 
  __iwl_dbg(trans->dev,1073741824U,(_Bool)0,"iwl_trans_pcie_reclaim","[Q %d] %d -> %d (%d)\n",txq_id,txq->q.read_ptr,tfd_num,ssn);
  
#line 984 
  last_to_free = iwl_queue_dec_wrap(tfd_num);
  
#line 986 
  tmp_0 = iwl_queue_used((struct iwl_queue const *)q,last_to_free);
  
#line 986 
  if (tmp_0) 
#line 986 
             tmp_1 = 0; else 
#line 986 
                             tmp_1 = 1;
  
#line 986 
  if (tmp_1) {
    {
      
#line 987 
      bool __cond_1 = (_Bool)((int)*("%s: Read index for DMA queue txq id (%d), last_to_free %d is out of range [0-%d] %d %d.\n" + 87UL) != 10);
      
#line 987 
      if ((int)__cond_1 != 0) 
#line 987 
                              __compiletime_assert_990(); else ;
    }
    
#line 987 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"%s: Read index for DMA queue txq id (%d), last_to_free %d is out of range [0-%d] %d %d.\n","iwl_trans_pcie_reclaim",txq_id,last_to_free,256,q->write_ptr,q->read_ptr);
    
#line 991 
    goto out;
  }
  else ;
  {
    int tmp_2;
    
#line 994 
    tmp_2 = skb_queue_empty((struct sk_buff_head const *)skbs);
    
#line 994 
    int __ret_warn_on_0 = tmp_2 == 0;
    
#line 994 
    if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 994 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",994); else ;
    
#line 994 
    tmp_3 = (long)(__ret_warn_on_0 != 0);
  }
  
#line 994 
  if ((long)tmp_3 != 0L) 
#line 995 
                         goto out; else ;
  
#line 997 
  goto ldv_55563;
  ldv_55562: 
#line 998 
  ;
  {
    bool __warned;
    
#line 1001 
    int __ret_warn_once = (txq->entries + txq->q.read_ptr)->skb == (struct sk_buff *)0;
    
#line 1001 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp_4;
      {
        
#line 1001 
        int __ret_warn_on_1 = ! __warned;
        
#line 1001 
        if ((long)(__ret_warn_on_1 != 0) != 0L) 
#line 1001 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1001); else ;
        
#line 1001 
        tmp_4 = (long)(__ret_warn_on_1 != 0);
      }
      
#line 1001 
      if ((long)tmp_4 != 0L) 
#line 1001 
                             __warned = (_Bool)1; else ;
    }
    else ;
    
#line 1001 
    tmp_5 = (long)(__ret_warn_once != 0);
  }
  
#line 1001 
  if ((long)tmp_5 != 0L) 
#line 1002 
                         goto ldv_55561; else ;
  
#line 1004 
  __skb_queue_tail(skbs,(txq->entries + txq->q.read_ptr)->skb);
  
#line 1006 
  (txq->entries + txq->q.read_ptr)->skb = (struct sk_buff *)0;
  
#line 1008 
  iwl_pcie_txq_inval_byte_cnt_tbl(trans,txq);
  
#line 1010 
  iwl_pcie_txq_free_tfd(trans,txq);
  ldv_55561: 
#line 1011 
  ;
  
#line 999 
  q->read_ptr = iwl_queue_inc_wrap(q->read_ptr);
  ldv_55563: 
#line 1000 
  ;
  
#line 997 
  if (q->read_ptr != tfd_num) 
#line 1000 
                              goto ldv_55562; else 
#line 1003 
                                                   goto ldv_55564;
  ldv_55564: 
#line 1004 
  ;
  
#line 1013 
  iwl_pcie_txq_progress(txq);
  
#line 1015 
  tmp_6 = iwl_queue_space((struct iwl_queue const *)(& txq->q));
  
#line 1015 
  ;
  
#line 1015 
  if (tmp_6 > txq->q.low_mark) 
#line 1016 
                               iwl_wake_queue(trans,txq); else ;
  
#line 1018 
  if (q->read_ptr == q->write_ptr) {
    {
      
#line 1019 
      bool __cond_2 = (_Bool)((int)*("Q %d - last tx reclaimed\n" + 24UL) != 10);
      
#line 1019 
      if ((int)__cond_2 != 0) 
#line 1019 
                              __compiletime_assert_1019(); else ;
    }
    
#line 1019 
    __iwl_dbg(trans->dev,1024U,(_Bool)0,"iwl_trans_pcie_reclaim","Q %d - last tx reclaimed\n",q->id);
    
#line 1020 
    iwl_trans_pcie_unref(trans);
  }
  else ;
  out: 
#line 1023 
  ;
  
#line 1024 
  ldv_spin_unlock_bh_88(& txq->lock);
  return_label: 
#line 1025 
                return;
}


#line 1038 
void __compiletime_assert_1038(void);


#line 1061 
void __compiletime_assert_1061(void);


#line 1027  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_set_cmd_in_flight(struct iwl_trans *trans, struct iwl_host_cmd const *cmd)
{
  int __retres;
  int ret;
  
#line 1030 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    int tmp_0;
    
#line 1033 
    if (debug_locks != 0) {
      int tmp;
      
#line 1033 
      tmp = lock_is_held(& trans_pcie->reg_lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 1033 
      if (tmp == 0) 
#line 1033 
                    tmp_0 = 1; else 
#line 1033 
                                    tmp_0 = 0;
    }
    else 
#line 1033 
         tmp_0 = 0;
    
#line 1033 
    int __ret_warn_on = tmp_0;
    
#line 1033 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1033 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1033); else ;
    
#line 1033 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1035 
  if ((cmd->flags & 16U) == 0U && ! trans_pcie->ref_cmd_in_flight) {
    
#line 1037 
    trans_pcie->ref_cmd_in_flight = (_Bool)1;
    {
      
#line 1038 
      bool __cond = (_Bool)((int)*("set ref_cmd_in_flight - ref\n" + 27UL) != 10);
      
#line 1038 
      if ((int)__cond != 0) 
#line 1038 
                            __compiletime_assert_1038(); else ;
    }
    
#line 1038 
    __iwl_dbg(trans->dev,1024U,(_Bool)0,"iwl_pcie_set_cmd_in_flight","set ref_cmd_in_flight - ref\n");
    
#line 1039 
    iwl_trans_pcie_ref(trans);
  }
  else ;
  
#line 1048 
  if ((int)((trans->cfg)->base_params)->apmg_wake_up_wa != 0 && ! trans_pcie->cmd_hold_nic_awake) {
    
#line 1050 
    __iwl_trans_pcie_set_bit_0(trans,36U,8U);
    
#line 1053 
    ret = iwl_poll_bit(trans,36U,1U,17U,15000);
    
#line 1058 
    if (ret < 0) {
      
#line 1059 
      __iwl_trans_pcie_clear_bit_0(trans,36U,8U);
      {
        
#line 1061 
        bool __cond_0 = (_Bool)((int)*("Failed to wake NIC for hcmd\n" + 27UL) != 10);
        
#line 1061 
        if ((int)__cond_0 != 0) 
#line 1061 
                                __compiletime_assert_1061(); else ;
      }
      
#line 1061 
      __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Failed to wake NIC for hcmd\n");
      
#line 1062 
      __retres = -5;
      
#line 1062 
      goto return_label;
    }
    else ;
    
#line 1064 
    trans_pcie->cmd_hold_nic_awake = (_Bool)1;
  }
  else ;
  
#line 1067 
  __retres = 0;
  return_label: 
#line 1067 
                return __retres;
}


#line 1078 
void __compiletime_assert_1078(void);


#line 1070  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_clear_cmd_in_flight(struct iwl_trans *trans)
{
  int __retres;
  
#line 1072 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    int tmp_0;
    
#line 1074 
    if (debug_locks != 0) {
      int tmp;
      
#line 1074 
      tmp = lock_is_held(& trans_pcie->reg_lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 1074 
      if (tmp == 0) 
#line 1074 
                    tmp_0 = 1; else 
#line 1074 
                                    tmp_0 = 0;
    }
    else 
#line 1074 
         tmp_0 = 0;
    
#line 1074 
    int __ret_warn_on = tmp_0;
    
#line 1074 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1074 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1074); else ;
    
#line 1074 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1076 
  if ((int)trans_pcie->ref_cmd_in_flight != 0) {
    
#line 1077 
    trans_pcie->ref_cmd_in_flight = (_Bool)0;
    {
      
#line 1078 
      bool __cond = (_Bool)((int)*("clear ref_cmd_in_flight - unref\n" + 31UL) != 10);
      
#line 1078 
      if ((int)__cond != 0) 
#line 1078 
                            __compiletime_assert_1078(); else ;
    }
    
#line 1078 
    __iwl_dbg(trans->dev,1024U,(_Bool)0,"iwl_pcie_clear_cmd_in_flight","clear ref_cmd_in_flight - unref\n");
    
#line 1079 
    iwl_trans_pcie_unref(trans);
  }
  else ;
  
#line 1082 
  if ((int)((trans->cfg)->base_params)->apmg_wake_up_wa != 0) {
    int tmp_1;
    {
      
#line 1083 
      int __ret_warn_on_0 = ! trans_pcie->cmd_hold_nic_awake;
      
#line 1083 
      if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 1083 
                                              warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1083); else ;
      
#line 1083 
      tmp_1 = (long)(__ret_warn_on_0 != 0);
    }
    
#line 1083 
    if ((long)tmp_1 != 0L) {
      
#line 1084 
      __retres = 0;
      
#line 1084 
      goto return_label;
    }
    else ;
    
#line 1086 
    trans_pcie->cmd_hold_nic_awake = (_Bool)0;
    
#line 1087 
    __iwl_trans_pcie_clear_bit_0(trans,36U,8U);
  }
  else ;
  
#line 1090 
  __retres = 0;
  return_label: 
#line 1090 
                return __retres;
}


#line 1111 
void __compiletime_assert_1114(void);


#line 1122 
void __compiletime_assert_1123(void);


#line 1100  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static void iwl_pcie_cmdq_reclaim(struct iwl_trans *trans, int txq_id, int idx)
{
  unsigned long flags;
  int tmp_3;
  
#line 1102 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1103 
  struct iwl_txq *txq = trans_pcie->txq + txq_id;
  
#line 1104 
  struct iwl_queue *q = & txq->q;
  
#line 1106 
  int nfreed = 0;
  {
    int tmp_0;
    
#line 1108 
    if (debug_locks != 0) {
      int tmp;
      
#line 1108 
      tmp = lock_is_held(& txq->lock.__anonCompField_spinlock_18.__anonCompField___anonunion_34_17.dep_map);
      
#line 1108 
      if (tmp == 0) 
#line 1108 
                    tmp_0 = 1; else 
#line 1108 
                                    tmp_0 = 0;
    }
    else 
#line 1108 
         tmp_0 = 0;
    
#line 1108 
    int __ret_warn_on = tmp_0;
    
#line 1108 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1108 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1108); else ;
    
#line 1108 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1110 
  if (idx > 255) 
#line 1110 
                 goto _LOR;
  else {
    int tmp_2_0;
    bool tmp_1;
    
#line 1110 
    tmp_1 = iwl_queue_used((struct iwl_queue const *)q,idx);
    
#line 1110 
    if (tmp_1) 
#line 1110 
               tmp_2_0 = 0; else 
#line 1110 
                                 tmp_2_0 = 1;
    
#line 1110 
    if (tmp_2_0) {
      _LOR: {
              {
                
#line 1111 
                bool __cond = (_Bool)((int)*("%s: Read index for DMA queue txq id (%d), index %d is out of range [0-%d] %d %d.\n" + 80UL) != 10);
                
#line 1111 
                if ((int)__cond != 0) 
#line 1111 
                                      __compiletime_assert_1114(); else ;
              }
              
#line 1111 
              __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"%s: Read index for DMA queue txq id (%d), index %d is out of range [0-%d] %d %d.\n","iwl_pcie_cmdq_reclaim",txq_id,idx,256,q->write_ptr,q->read_ptr);
              
#line 1115 
              goto return_label;
            }
    }
    else ;
  }
  
#line 1118 
  idx = iwl_queue_inc_wrap(idx);
  
#line 1118 
  goto ldv_55621;
  ldv_55620: 
#line 1119 
  ;
  
#line 1121 
  tmp_3 = nfreed;
  
#line 1121 
  nfreed += 1;
  
#line 1121 
  ;
  
#line 1121 
  if (tmp_3 > 0) {
    {
      
#line 1122 
      bool __cond_0 = (_Bool)((int)*("HCMD skipped: index (%d) %d %d\n" + 30UL) != 10);
      
#line 1122 
      if ((int)__cond_0 != 0) 
#line 1122 
                              __compiletime_assert_1123(); else ;
    }
    
#line 1122 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"HCMD skipped: index (%d) %d %d\n",idx,q->write_ptr,q->read_ptr);
    
#line 1124 
    iwl_force_nmi(trans);
  }
  else ;
  
#line 1119 
  q->read_ptr = iwl_queue_inc_wrap(q->read_ptr);
  ldv_55621: 
#line 1120 
  ;
  
#line 1118 
  if (q->read_ptr != idx) 
#line 1120 
                          goto ldv_55620; else 
#line 1123 
                                               goto ldv_55622;
  ldv_55622: 
#line 1124 
  ;
  
#line 1128 
  if (q->read_ptr == q->write_ptr) {
    
#line 1129 
    ldv___ldv_spin_lock_89(& trans_pcie->reg_lock);
    
#line 1130 
    iwl_pcie_clear_cmd_in_flight(trans);
    
#line 1131 
    ldv_spin_unlock_irqrestore_90(& trans_pcie->reg_lock,flags);
  }
  else ;
  
#line 1134 
  iwl_pcie_txq_progress(txq);
  return_label: 
#line 1135 
                return;
}


#line 1137  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_txq_set_ratid_map(struct iwl_trans *trans, u16 ra_tid, u16 txq_id)
{
  int __retres;
  u32 tbl_dw_addr;
  u32 tbl_dw;
  u16 scd_q2ratid;
  
#line 1140 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1145 
  scd_q2ratid = (unsigned short)((unsigned int)ra_tid & 511U);
  
#line 1147 
  tbl_dw_addr = trans_pcie->scd_base_addr + ((unsigned int)(((int)txq_id + 1008) * 2) & 65532U);
  
#line 1150 
  tbl_dw = iwl_trans_read_mem32(trans,tbl_dw_addr);
  
#line 1152 
  if (((int)txq_id & 1) != 0) 
#line 1153 
                              tbl_dw = (unsigned int)((int)scd_q2ratid << 16) | (tbl_dw & 65535U); else 
                                                                    
#line 1155 
                                                                    tbl_dw = (unsigned int)scd_q2ratid | (tbl_dw & 4294901760U);
  
#line 1157 
  iwl_trans_write_mem32(trans,tbl_dw_addr,tbl_dw);
  
#line 1159 
  __retres = 0;
  
#line 1159 
  return __retres;
}


#line 1250 
void __compiletime_assert_1252(void);


#line 1254 
void __compiletime_assert_1256(void);


#line 1166  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
void iwl_trans_pcie_txq_enable(struct iwl_trans *trans, int txq_id, u16 ssn, struct iwl_trans_txq_scd_cfg const *cfg, unsigned int wdg_timeout)
{
  int tmp_0;
  
#line 1170 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1171 
  struct iwl_txq *txq = trans_pcie->txq + txq_id;
  
#line 1172 
  int fifo = -1;
  
#line 1174 
  tmp_0 = test_and_set_bit((long)txq_id,(unsigned long volatile *)(& trans_pcie->queue_used));
  
#line 1174 
  if (tmp_0 != 0) {
    bool __warned;
    
#line 1175 
    int __ret_warn_once = 1;
    
#line 1175 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp;
      {
        
#line 1175 
        int __ret_warn_on = ! __warned;
        
#line 1175 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 1175 
                                              warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1175,"queue %d already used - expect issues",txq_id); else ;
        
#line 1175 
        tmp = (long)(__ret_warn_on != 0);
      }
      
#line 1175 
      if ((long)tmp != 0L) 
#line 1175 
                           __warned = (_Bool)1; else ;
    }
    else ;
    
#line 1175 
    long tmp_2 = (long)(__ret_warn_once != 0);
  }
  else ;
  
#line 1177 
  txq->wd_timeout = msecs_to_jiffies(wdg_timeout);
  
#line 1179 
  if (cfg != (struct iwl_trans_txq_scd_cfg const *)0) {
    
#line 1180 
    fifo = (int)cfg->fifo;
    
#line 1183 
    if ((int)trans_pcie->cmd_queue == txq_id && (int)trans_pcie->scd_set_active != 0) 
      
#line 1185 
      iwl_scd_enable_set_active(trans,0U); else ;
    
#line 1188 
    iwl_scd_txq_set_inactive(trans,(unsigned short)((int)((unsigned short)txq_id)));
    
#line 1191 
    if ((int)trans_pcie->cmd_queue != txq_id) 
#line 1192 
                                              iwl_scd_txq_set_chain(trans,(unsigned short)((int)((unsigned short)txq_id))); else ;
    
#line 1194 
    if ((int)cfg->aggregate != 0) {
      
#line 1195 
      u16 ra_tid = (unsigned short)(((int)((unsigned short)cfg->sta_id) << 4U) + (int)((unsigned short)cfg->tid));
      
#line 1198 
      iwl_pcie_txq_set_ratid_map(trans,(unsigned short)((int)ra_tid),(unsigned short)((int)((unsigned short)txq_id)));
      
#line 1201 
      iwl_scd_txq_enable_agg(trans,(unsigned short)((int)((unsigned short)txq_id)));
      
#line 1202 
      txq->ampdu = (_Bool)1;
    }
    else {
      
#line 1209 
      iwl_scd_txq_disable_agg(trans,(unsigned short)((int)((unsigned short)txq_id)));
      
#line 1211 
      ssn = (unsigned short)txq->q.read_ptr;
    }
  }
  else ;
  
#line 1217 
  txq->q.read_ptr = (int)ssn & 255;
  
#line 1218 
  txq->q.write_ptr = (int)ssn & 255;
  
#line 1219 
  iwl_write_direct32(trans,1120U,(unsigned int)(((int)ssn & 255) | (txq_id << 8)));
  
#line 1222 
  if (cfg != (struct iwl_trans_txq_scd_cfg const *)0) {
    unsigned int tmp_1;
    unsigned int tmp_2_0;
    
#line 1223 
    u8 frame_limit = (unsigned char)cfg->frame_limit;
    
#line 1225 
    ;
    
#line 1225 
    tmp_1 = SCD_QUEUE_RDPTR((unsigned int)txq_id);
    
#line 1225 
    ;
    
#line 1225 
    iwl_write_prph(trans,tmp_1,(unsigned int)ssn);
    
#line 1228 
    iwl_trans_write_mem32(trans,trans_pcie->scd_base_addr + (unsigned int)((txq_id + 192) * 8),0U);
    
#line 1230 
    iwl_trans_write_mem32(trans,(trans_pcie->scd_base_addr + (unsigned int)((txq_id + 192) * 8)) + 4U,(unsigned int)(((int)frame_limit & 127) | (((int)frame_limit << 16) & 8323072)));
    
#line 1239 
    ;
    
#line 1239 
    tmp_2_0 = SCD_QUEUE_STATUS_BITS((unsigned int)txq_id);
    
#line 1239 
    ;
    
#line 1239 
    iwl_write_prph(trans,tmp_2_0,(unsigned int)((int)((unsigned int)cfg->fifo | 24U) | 25100288));
    
#line 1246 
    if ((int)trans_pcie->cmd_queue == txq_id && (int)trans_pcie->scd_set_active != 0) 
      
#line 1248 
      iwl_scd_enable_set_active(trans,(unsigned int)(1UL << txq_id)); else ;
    {
      
#line 1250 
      bool __cond = (_Bool)((int)*("Activate queue %d on FIFO %d WrPtr: %d\n" + 38UL) != 10);
      
#line 1250 
      if ((int)__cond != 0) 
#line 1250 
                            __compiletime_assert_1252(); else ;
    }
    
#line 1250 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_trans_pcie_txq_enable","Activate queue %d on FIFO %d WrPtr: %d\n",txq_id,fifo,(int)ssn & 255);
  }
  else {
    {
      
#line 1254 
      bool __cond_0 = (_Bool)((int)*("Activate queue %d WrPtr: %d\n" + 27UL) != 10);
      
#line 1254 
      if ((int)__cond_0 != 0) 
#line 1254 
                              __compiletime_assert_1256(); else ;
    }
    
#line 1254 
    __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_trans_pcie_txq_enable","Activate queue %d WrPtr: %d\n",txq_id,(int)ssn & 255);
  }
  
#line 1259 
  txq->active = (unsigned char)1U;
  
#line 1260 
  return;
}


#line 1295 
void __compiletime_assert_1295(void);


#line 1262  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
void iwl_trans_pcie_txq_disable(struct iwl_trans *trans, int txq_id, bool configure_scd)
{
  int tmp_1;
  
#line 1265 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1266 
  u32 stts_addr = trans_pcie->scd_base_addr + (unsigned int)((txq_id + 106) * 16);
  
#line 1268 
  u32 const zero_val[4U] = {};
  
#line 1270 
  (trans_pcie->txq + txq_id)->frozen_expiry_remainder = 0UL;
  
#line 1271 
  (trans_pcie->txq + txq_id)->frozen = (_Bool)0;
  
#line 1279 
  tmp_1 = test_and_set_bit((long)txq_id,(unsigned long volatile *)(& trans_pcie->queue_used));
  
#line 1279 
  if (tmp_1 == 0) {
    {
      bool __warned;
      int tmp;
      
#line 1280 
      tmp = constant_test_bit(1L,(unsigned long const volatile *)(& trans->status));
      
#line 1280 
      int __ret_warn_once = tmp != 0;
      
#line 1280 
      if ((long)(__ret_warn_once != 0) != 0L) {
        int tmp_0;
        {
          
#line 1280 
          int __ret_warn_on = ! __warned;
          
#line 1280 
          if ((long)(__ret_warn_on != 0) != 0L) 
#line 1280 
                                                warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1281,"queue %d not used",txq_id); else ;
          
#line 1280 
          tmp_0 = (long)(__ret_warn_on != 0);
        }
        
#line 1280 
        if ((long)tmp_0 != 0L) 
#line 1280 
                               __warned = (_Bool)1; else ;
      }
      else ;
      
#line 1280 
      long tmp_2 = (long)(__ret_warn_once != 0);
    }
    
#line 1282 
    goto return_label;
  }
  else ;
  
#line 1285 
  if ((int)configure_scd != 0) {
    
#line 1286 
    iwl_scd_txq_set_inactive(trans,(unsigned short)((int)((unsigned short)txq_id)));
    
#line 1288 
    iwl_trans_write_mem(trans,stts_addr,(void const *)(& zero_val),4);
  }
  else ;
  
#line 1292 
  iwl_pcie_txq_unmap(trans,txq_id);
  
#line 1293 
  (trans_pcie->txq + txq_id)->ampdu = (_Bool)0;
  {
    
#line 1295 
    bool __cond = (_Bool)((int)*("Deactivate queue %d\n" + 19UL) != 10);
    
#line 1295 
    if ((int)__cond != 0) 
#line 1295 
                          __compiletime_assert_1295(); else ;
  }
  
#line 1295 
  __iwl_dbg(trans->dev,2147483648U,(_Bool)0,"iwl_trans_pcie_txq_disable","Deactivate queue %d\n",txq_id);
  return_label: 
#line 1296 
                return;
}


#line 1332 
void __compiletime_assert_1332(void);


#line 1404 
void __compiletime_assert_1404(void);


#line 1466 
void __compiletime_assert_1470(void);


#line 1309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd)
{
  int __retres;
  struct iwl_device_cmd *out_cmd;
  struct iwl_cmd_meta *out_meta;
  unsigned long flags;
  dma_addr_t phys_addr;
  int idx;
  u16 copy_size;
  u16 cmd_size;
  u16 scratch_size;
  int i;
  int ret;
  u32 cmd_pos;
  u8 const *cmddata[2U];
  u16 cmdlen[2U];
  int tmp_3;
  int tmp_4;
  int tmp_5;
  u8 tmp_6;
  char const *tmp_9;
  int tmp_11;
  dma_addr_t tmp_12;
  int tmp_16;
  
#line 1312 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1313 
  struct iwl_txq *txq = trans_pcie->txq + (int)trans_pcie->cmd_queue;
  
#line 1314 
  struct iwl_queue *q = & txq->q;
  
#line 1318 
  void *dup_buf = (void *)0;
  
#line 1322 
  bool had_nocopy = (_Bool)0;
  
#line 1328 
  copy_size = (unsigned short)4U;
  
#line 1329 
  cmd_size = (unsigned short)4U;
  {
    
#line 1332 
    bool __cond = (_Bool)0;
    
#line 1332 
    if ((int)__cond != 0) 
#line 1332 
                          __compiletime_assert_1332(); else ;
  }
  
#line 1334 
  i = 0;
  
#line 1334 
  goto ldv_55715;
  ldv_55714: 
#line 1335 
  ;
  
#line 1335 
  cmddata[i] = (u8 const *)cmd->data[i];
  
#line 1336 
  cmdlen[i] = cmd->len[i];
  
#line 1338 
  if ((unsigned int)cmd->len[i] == 0U) 
#line 1339 
                                       goto ldv_55705; else ;
  
#line 1342 
  if ((unsigned int)copy_size <= 15U) {
    
#line 1343 
    int copy = 16 - (int)copy_size;
    
#line 1345 
    if ((int)cmdlen[i] < copy) 
#line 1346 
                               copy = (int)cmdlen[i]; else ;
    
#line 1347 
    cmdlen[i] = (unsigned short)((int)cmdlen[i] - (int)((unsigned short)copy));
    
#line 1348 
    cmddata[i] += copy;
    
#line 1349 
    copy_size = (unsigned short)((int)((unsigned short)copy) + (int)copy_size);
  }
  else ;
  
#line 1352 
  if (((int)cmd->dataflags[i] & 1) != 0) {
    int tmp;
    
#line 1353 
    had_nocopy = (_Bool)1;
    {
      
#line 1354 
      int __ret_warn_on = ((int)cmd->dataflags[i] & 2) != 0;
      
#line 1354 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 1354 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1354); else ;
      
#line 1354 
      tmp = (long)(__ret_warn_on != 0);
    }
    
#line 1354 
    if ((long)tmp != 0L) {
      
#line 1355 
      idx = -22;
      
#line 1356 
      goto free_dup_buf;
    }
    else ;
  }
  else 
    
#line 1358 
    if (((int)cmd->dataflags[i] & 2) != 0) {
      int tmp_0;
      
#line 1363 
      had_nocopy = (_Bool)1;
      {
        
#line 1366 
        int __ret_warn_on_0 = dup_buf != (void *)0;
        
#line 1366 
        if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 1366 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1366); else ;
        
#line 1366 
        tmp_0 = (long)(__ret_warn_on_0 != 0);
      }
      
#line 1366 
      if ((long)tmp_0 != 0L) {
        
#line 1367 
        idx = -22;
        
#line 1368 
        goto free_dup_buf;
      }
      else ;
      
#line 1371 
      dup_buf = kmemdup((void const *)cmddata[i],(unsigned long)cmdlen[i],32U);
      
#line 1373 
      if (dup_buf == (void *)0) {
        
#line 1374 
        __retres = -12;
        
#line 1374 
        goto return_label;
      }
      else ;
    }
    else {
      int tmp_1;
      {
        
#line 1377 
        int __ret_warn_on_1 = (int)had_nocopy != 0;
        
#line 1377 
        if ((long)(__ret_warn_on_1 != 0) != 0L) 
#line 1377 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1377); else ;
        
#line 1377 
        tmp_1 = (long)(__ret_warn_on_1 != 0);
      }
      
#line 1377 
      if ((long)tmp_1 != 0L) {
        
#line 1378 
        idx = -22;
        
#line 1379 
        goto free_dup_buf;
      }
      else ;
      
#line 1381 
      copy_size = (unsigned short)((int)cmdlen[i] + (int)copy_size);
    }
  
#line 1383 
  cmd_size = (unsigned short)((int)cmd->len[i] + (int)cmd_size);
  ldv_55705: 
#line 1384 
  ;
  
#line 1334 
  i += 1;
  ldv_55715: 
#line 1335 
  ;
  
#line 1334 
  if (i <= 1) 
#line 1336 
              goto ldv_55714; else 
#line 1339 
                                   goto ldv_55716;
  ldv_55716: 
#line 1340 
  ;
  {
    
#line 1392 
    int __ret_warn_on_2 = (unsigned int)copy_size > 324U;
    
#line 1392 
    if ((long)(__ret_warn_on_2 != 0) != 0L) {
      char const *tmp_2;
      
#line 1392 
      ;
      
#line 1392 
      ;
      
#line 1392 
      tmp_2 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
      
#line 1392 
      warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1394,"Command %s (%#x) is too large (%d bytes)\n",tmp_2,(int)cmd->id,(int)copy_size);
    }
    else ;
    
#line 1392 
    tmp_3 = (long)(__ret_warn_on_2 != 0);
  }
  
#line 1392 
  if ((long)tmp_3 != 0L) {
    
#line 1395 
    idx = -22;
    
#line 1396 
    goto free_dup_buf;
  }
  else ;
  
#line 1399 
  ldv_spin_lock_bh_91(& txq->lock);
  
#line 1401 
  tmp_4 = iwl_queue_space((struct iwl_queue const *)q);
  
#line 1401 
  if ((cmd->flags & 1U) != 0U) 
#line 1401 
                               tmp_5 = 2; else 
#line 1401 
                                               tmp_5 = 1;
  
#line 1401 
  if (tmp_4 < tmp_5) {
    
#line 1402 
    ldv_spin_unlock_bh_92(& txq->lock);
    {
      
#line 1404 
      bool __cond_0 = (_Bool)((int)*("No space in command queue\n" + 25UL) != 10);
      
#line 1404 
      if ((int)__cond_0 != 0) 
#line 1404 
                              __compiletime_assert_1404(); else ;
    }
    
#line 1404 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"No space in command queue\n");
    
#line 1405 
    iwl_op_mode_cmd_queue_full(trans->op_mode);
    
#line 1406 
    idx = -28;
    
#line 1407 
    goto free_dup_buf;
  }
  else ;
  
#line 1410 
  tmp_6 = get_cmd_index(q,(unsigned int)q->write_ptr);
  
#line 1410 
  idx = (int)tmp_6;
  
#line 1411 
  out_cmd = (txq->entries + idx)->cmd;
  
#line 1412 
  out_meta = & (txq->entries + idx)->meta;
  
#line 1414 
  memset((void *)out_meta,0,16UL);
  
#line 1415 
  if ((cmd->flags & 2U) != 0U) 
#line 1416 
                               out_meta->source = cmd; else ;
  
#line 1420 
  out_cmd->hdr.cmd = cmd->id;
  
#line 1421 
  out_cmd->hdr.flags = (unsigned char)0U;
  
#line 1422 
  out_cmd->hdr.sequence = (unsigned short)((((int)trans_pcie->cmd_queue << 8) & 7936) | (q->write_ptr & 255));
  
#line 1427 
  cmd_pos = 4U;
  
#line 1428 
  copy_size = (unsigned short)4U;
  
#line 1429 
  i = 0;
  
#line 1429 
  goto ldv_55729;
  ldv_55728: 
#line 1430 
  ;
  {
    int copy_0;
    int tmp_8;
    
#line 1432 
    if ((unsigned int)cmd->len[i] == 0U) 
#line 1433 
                                         goto ldv_55724; else ;
    
#line 1436 
    if (((int)cmd->dataflags[i] & 3) == 0) {
      
#line 1438 
      copy_0 = (int)cmd->len[i];
      
#line 1440 
      memcpy((void *)out_cmd + cmd_pos,cmd->data[i],(unsigned long)copy_0);
      
#line 1441 
      cmd_pos += (unsigned int)copy_0;
      
#line 1442 
      copy_size = (unsigned short)((int)((unsigned short)copy_0) + (int)copy_size);
      
#line 1443 
      goto ldv_55724;
    }
    else ;
    {
      int tmp_7;
      
#line 1451 
      int __min1 = (int)(324U - cmd_pos);
      
#line 1451 
      int __min2 = (int)cmd->len[i];
      
#line 1451 
      if (__min1 < __min2) 
#line 1451 
                           tmp_7 = __min1; else 
#line 1451 
                                                tmp_7 = __min2;
      
#line 1451 
      tmp_8 = tmp_7;
    }
    
#line 1451 
    copy_0 = tmp_8;
    
#line 1453 
    memcpy((void *)out_cmd + cmd_pos,cmd->data[i],(unsigned long)copy_0);
    
#line 1454 
    cmd_pos += (unsigned int)copy_0;
    
#line 1457 
    if ((unsigned int)copy_size <= 15U) {
      
#line 1458 
      copy_0 = 16 - (int)copy_size;
      
#line 1460 
      if ((int)cmd->len[i] < copy_0) 
#line 1461 
                                     copy_0 = (int)cmd->len[i]; else ;
      
#line 1462 
      copy_size = (unsigned short)((int)((unsigned short)copy_0) + (int)copy_size);
    }
    else ;
  }
  ldv_55724: 
#line 1465 
  ;
  
#line 1429 
  i += 1;
  ldv_55729: 
#line 1430 
  ;
  
#line 1429 
  if (i <= 1) 
#line 1431 
              goto ldv_55728; else 
#line 1434 
                                   goto ldv_55730;
  ldv_55730: 
#line 1435 
  ;
  {
    
#line 1466 
    bool __cond_1 = (_Bool)((int)*("Sending command %s (#%x), seq: 0x%04X, %d bytes at %d[%d]:%d\n" + 60UL) != 10);
    
#line 1466 
    if ((int)__cond_1 != 0) 
#line 1466 
                            __compiletime_assert_1470(); else ;
  }
  
#line 1466 
  ;
  
#line 1466 
  ;
  
#line 1466 
  ;
  
#line 1466 
  ;
  
#line 1466 
  ;
  
#line 1466 
  ;
  
#line 1466 
  tmp_9 = get_cmd_string(trans_pcie,(unsigned char)((int)out_cmd->hdr.cmd));
  
#line 1466 
  ;
  
#line 1466 
  __iwl_dbg(trans->dev,4U,(_Bool)0,"iwl_pcie_enqueue_hcmd","Sending command %s (#%x), seq: 0x%04X, %d bytes at %d[%d]:%d\n",tmp_9,(int)out_cmd->hdr.cmd,(int)out_cmd->hdr.sequence,(int)cmd_size,q->write_ptr,idx,(int)trans_pcie->cmd_queue);
  {
    int tmp_10;
    
#line 1473 
    int __min1_0 = (int)copy_size;
    
#line 1473 
    int __min2_0 = 16;
    
#line 1473 
    if (__min1_0 < __min2_0) 
#line 1473 
                             tmp_10 = __min1_0; else 
#line 1473 
                                                     tmp_10 = __min2_0;
    
#line 1473 
    tmp_11 = tmp_10;
  }
  
#line 1473 
  scratch_size = (unsigned short)tmp_11;
  
#line 1474 
  memcpy((void *)(txq->scratchbufs + q->write_ptr),(void const *)(& out_cmd->hdr),(unsigned long)scratch_size);
  
#line 1475 
  ;
  
#line 1475 
  tmp_12 = iwl_pcie_get_scratchbuf_dma(txq,q->write_ptr);
  
#line 1475 
  ;
  
#line 1475 
  ;
  
#line 1475 
  iwl_pcie_txq_build_tfd(trans,txq,tmp_12,(unsigned short)((int)scratch_size),(_Bool)1);
  
#line 1480 
  if ((int)copy_size > (int)scratch_size) {
    int tmp_13;
    
#line 1481 
    phys_addr = dma_map_single_attrs(trans->dev,(void *)(& out_cmd->hdr) + (int)scratch_size,(unsigned long)((int)copy_size - (int)scratch_size),(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 1485 
    tmp_13 = dma_mapping_error(trans->dev,phys_addr);
    
#line 1485 
    if (tmp_13 != 0) {
      
#line 1486 
      iwl_pcie_tfd_unmap(trans,out_meta,txq->tfds + q->write_ptr);
      
#line 1488 
      idx = -12;
      
#line 1489 
      goto out;
    }
    else ;
    
#line 1492 
    iwl_pcie_txq_build_tfd(trans,txq,phys_addr,(unsigned short)((int)copy_size - (int)scratch_size),(_Bool)0);
  }
  else ;
  
#line 1497 
  i = 0;
  
#line 1497 
  goto ldv_55743;
  ldv_55742: 
#line 1498 
  ;
  {
    int tmp_14;
    
#line 1498 
    void const *data = (void const *)cmddata[i];
    
#line 1500 
    if ((unsigned int)cmdlen[i] == 0U) 
#line 1501 
                                       goto ldv_55741; else ;
    
#line 1502 
    if (((int)cmd->dataflags[i] & 3) == 0) 
#line 1504 
                                           goto ldv_55741; else ;
    
#line 1505 
    if (((int)cmd->dataflags[i] & 2) != 0) 
#line 1506 
                                           data = (void const *)dup_buf; else ;
    
#line 1507 
    phys_addr = dma_map_single_attrs(trans->dev,(void *)data,(unsigned long)cmdlen[i],(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 1509 
    tmp_14 = dma_mapping_error(trans->dev,phys_addr);
    
#line 1509 
    if (tmp_14 != 0) {
      
#line 1510 
      iwl_pcie_tfd_unmap(trans,out_meta,txq->tfds + q->write_ptr);
      
#line 1512 
      idx = -12;
      
#line 1513 
      goto out;
    }
    else ;
    
#line 1516 
    iwl_pcie_txq_build_tfd(trans,txq,phys_addr,(unsigned short)((int)cmdlen[i]),(_Bool)0);
  }
  ldv_55741: 
#line 1518 
  ;
  
#line 1497 
  i += 1;
  ldv_55743: 
#line 1498 
  ;
  
#line 1497 
  if (i <= 1) 
#line 1499 
              goto ldv_55742; else 
#line 1502 
                                   goto ldv_55744;
  ldv_55744: 
#line 1503 
  ;
  
#line 1519 
  out_meta->flags = cmd->flags;
  {
    bool __warned;
    
#line 1520 
    int __ret_warn_once = (txq->entries + idx)->free_buf != (void const *)0;
    
#line 1520 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp_15;
      {
        
#line 1520 
        int __ret_warn_on_3 = ! __warned;
        
#line 1520 
        if ((long)(__ret_warn_on_3 != 0) != 0L) 
#line 1520 
                                                warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1520); else ;
        
#line 1520 
        tmp_15 = (long)(__ret_warn_on_3 != 0);
      }
      
#line 1520 
      if ((long)tmp_15 != 0L) 
#line 1520 
                              __warned = (_Bool)1; else ;
    }
    else ;
    
#line 1520 
    tmp_16 = (long)(__ret_warn_once != 0);
  }
  
#line 1520 
  if ((long)tmp_16 != 0L) 
#line 1521 
                          kzfree((txq->entries + idx)->free_buf); else ;
  
#line 1522 
  (txq->entries + idx)->free_buf = (void const *)dup_buf;
  
#line 1524 
  trace_iwlwifi_dev_hcmd((struct device const *)trans->dev,cmd,(unsigned short)((int)cmd_size),& out_cmd->hdr);
  
#line 1527 
  if (q->read_ptr == q->write_ptr && txq->wd_timeout != 0UL) 
#line 1528 
                                                             ldv_mod_timer_93(& txq->stuck_timer,txq->wd_timeout + jiffies); else ;
  
#line 1530 
  ldv___ldv_spin_lock_94(& trans_pcie->reg_lock);
  
#line 1531 
  ret = iwl_pcie_set_cmd_in_flight(trans,(struct iwl_host_cmd const *)cmd);
  
#line 1532 
  if (ret < 0) {
    
#line 1533 
    idx = ret;
    
#line 1534 
    ldv_spin_unlock_irqrestore_95(& trans_pcie->reg_lock,flags);
    
#line 1535 
    goto out;
  }
  else ;
  
#line 1539 
  q->write_ptr = iwl_queue_inc_wrap(q->write_ptr);
  
#line 1540 
  iwl_pcie_txq_inc_wr_ptr(trans,txq);
  
#line 1542 
  ldv_spin_unlock_irqrestore_96_0(& trans_pcie->reg_lock,flags);
  out: 
#line 1544 
  ;
  
#line 1545 
  ldv_spin_unlock_bh_97(& txq->lock);
  free_dup_buf: 
#line 1546 
  ;
  
#line 1547 
  if (idx < 0) 
#line 1548 
               kfree((void const *)dup_buf); else ;
  
#line 1549 
  __retres = idx;
  return_label: 
#line 1549 
                return __retres;
}


#line 1609 
void __compiletime_assert_1611(void);


#line 1614 
void __compiletime_assert_1615(void);


#line 1562  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
void iwl_pcie_hcmd_complete(struct iwl_trans *trans, struct iwl_rx_cmd_buffer *rxb, int handler_status)
{
  int cmd_index;
  struct iwl_device_cmd *cmd;
  struct iwl_cmd_meta *meta;
  int tmp_0;
  u8 tmp_1;
  
#line 1565 
  struct iwl_rx_packet *pkt = rxb_addr(rxb);
  
#line 1566 
  u16 sequence = pkt->hdr.sequence;
  
#line 1567 
  int txq_id = ((int)sequence >> 8) & 31;
  
#line 1568 
  int index = (int)sequence & 255;
  
#line 1572 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1573 
  struct iwl_txq *txq = trans_pcie->txq + (int)trans_pcie->cmd_queue;
  {
    
#line 1578 
    int __ret_warn_on = (int)trans_pcie->cmd_queue != txq_id;
    
#line 1578 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1578 
                                          warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1582,"wrong command queue %d (should be %d), sequence 0x%X readp=%d writep=%d\n",txq_id,(int)trans_pcie->cmd_queue,(int)sequence,(trans_pcie->txq + (int)trans_pcie->cmd_queue)->q.read_ptr,(trans_pcie->txq + (int)trans_pcie->cmd_queue)->q.write_ptr); else ;
    
#line 1578 
    tmp_0 = (long)(__ret_warn_on != 0);
  }
  
#line 1578 
  if ((long)tmp_0 != 0L) {
    
#line 1583 
    print_hex_dump("\001","iwl data: ",2,16,1,(void const *)pkt,32UL,(_Bool)1);
    
#line 1584 
    goto return_label;
  }
  else ;
  
#line 1587 
  ldv_spin_lock_bh_98(& txq->lock);
  
#line 1589 
  tmp_1 = get_cmd_index(& txq->q,(unsigned int)index);
  
#line 1589 
  cmd_index = (int)tmp_1;
  
#line 1590 
  cmd = (txq->entries + cmd_index)->cmd;
  
#line 1591 
  meta = & (txq->entries + cmd_index)->meta;
  
#line 1593 
  iwl_pcie_tfd_unmap(trans,meta,txq->tfds + index);
  
#line 1596 
  if ((meta->flags & 2U) != 0U) {
    void *tmp_3;
    
#line 1597 
    struct page *p = rxb_steal_page(rxb);
    
#line 1599 
    (meta->source)->resp_pkt = pkt;
    
#line 1600 
    tmp_3 = lowmem_page_address((struct page const *)p);
    
#line 1600 
    (meta->source)->_rx_page_addr = (unsigned long)tmp_3;
    
#line 1601 
    (meta->source)->_rx_page_order = trans_pcie->rx_page_order;
    
#line 1602 
    (meta->source)->handler_status = handler_status;
  }
  else ;
  
#line 1605 
  iwl_pcie_cmdq_reclaim(trans,txq_id,index);
  
#line 1607 
  if ((meta->flags & 1U) == 0U) {
    int tmp_5;
    char const *tmp_6;
    
#line 1608 
    tmp_5 = constant_test_bit(0L,(unsigned long const volatile *)(& trans->status));
    
#line 1608 
    if (tmp_5 == 0) {
      char const *tmp_4;
      {
        
#line 1609 
        bool __cond = (_Bool)((int)*("HCMD_ACTIVE already clear for command %s\n" + 40UL) != 10);
        
#line 1609 
        if ((int)__cond != 0) 
#line 1609 
                              __compiletime_assert_1611(); else ;
      }
      
#line 1609 
      tmp_4 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->hdr.cmd));
      
#line 1609 
      ;
      
#line 1609 
      __iwl_warn(trans->dev,"HCMD_ACTIVE already clear for command %s\n",tmp_4);
    }
    else ;
    
#line 1613 
    set_bit(0L,(unsigned long volatile *)(& trans->status));
    {
      
#line 1614 
      bool __cond_0 = (_Bool)((int)*("Clearing HCMD_ACTIVE for command %s\n" + 35UL) != 10);
      
#line 1614 
      if ((int)__cond_0 != 0) 
#line 1614 
                              __compiletime_assert_1615(); else ;
    }
    
#line 1614 
    tmp_6 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->hdr.cmd));
    
#line 1614 
    ;
    
#line 1614 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_hcmd_complete","Clearing HCMD_ACTIVE for command %s\n",tmp_6);
    
#line 1616 
    __wake_up(& trans_pcie->wait_command_queue,3U,1,(void *)0);
  }
  else ;
  
#line 1619 
  meta->flags = 0U;
  
#line 1621 
  ldv_spin_unlock_bh_99(& txq->lock);
  return_label: 
#line 1622 
                return;
}


#line 1638 
void __compiletime_assert_1640(void);


#line 1626  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_send_hcmd_async(struct iwl_trans *trans, struct iwl_host_cmd *cmd)
{
  int __retres;
  int ret;
  int tmp;
  
#line 1629 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    
#line 1633 
    int __ret_warn_on = (cmd->flags & 2U) != 0U;
    
#line 1633 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 1633 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1633); else ;
    
#line 1633 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 1633 
  if ((long)tmp != 0L) {
    
#line 1634 
    __retres = -22;
    
#line 1634 
    goto return_label;
  }
  else ;
  
#line 1636 
  ret = iwl_pcie_enqueue_hcmd(trans,cmd);
  
#line 1637 
  if (ret < 0) {
    char const *tmp_0;
    {
      
#line 1638 
      bool __cond = (_Bool)((int)*("Error sending %s: enqueue_hcmd failed: %d\n" + 41UL) != 10);
      
#line 1638 
      if ((int)__cond != 0) 
#line 1638 
                            __compiletime_assert_1640(); else ;
    }
    
#line 1638 
    ;
    
#line 1638 
    tmp_0 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
    
#line 1638 
    ;
    
#line 1638 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Error sending %s: enqueue_hcmd failed: %d\n",tmp_0,ret);
    
#line 1641 
    __retres = ret;
    
#line 1641 
    goto return_label;
  }
  else ;
  
#line 1643 
  __retres = 0;
  return_label: 
#line 1643 
                return __retres;
}


#line 1653 
void __compiletime_assert_1654(void);


#line 1669 
void __compiletime_assert_1671(void);


#line 1683 
void __compiletime_assert_1685(void);


#line 1687 
void __compiletime_assert_1688(void);


#line 1691 
void __compiletime_assert_1692(void);


#line 1711 
void __compiletime_assert_1711(void);


#line 1717 
void __compiletime_assert_1718(void);


#line 1646  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
static int iwl_pcie_send_hcmd_sync(struct iwl_trans *trans, struct iwl_host_cmd *cmd)
{
  int __retres;
  int cmd_idx;
  int ret;
  char const *tmp;
  int tmp_2;
  char const *tmp_3;
  long tmp_11;
  int tmp_16;
  
#line 1649 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  {
    
#line 1653 
    bool __cond = (_Bool)((int)*("Attempting to send sync command %s\n" + 34UL) != 10);
    
#line 1653 
    if ((int)__cond != 0) 
#line 1653 
                          __compiletime_assert_1654(); else ;
  }
  
#line 1653 
  tmp = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
  
#line 1653 
  ;
  
#line 1653 
  __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_send_hcmd_sync","Attempting to send sync command %s\n",tmp);
  {
    int tmp_0;
    
#line 1656 
    tmp_0 = test_and_set_bit(0L,(unsigned long volatile *)(& trans->status));
    
#line 1656 
    int __ret_warn_on = tmp_0 != 0;
    
#line 1656 
    if ((long)(__ret_warn_on != 0) != 0L) {
      char const *tmp_1;
      
#line 1656 
      tmp_1 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
      
#line 1656 
      warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1659,"Command %s: a command is already active!\n",tmp_1);
    }
    else ;
    
#line 1656 
    tmp_2 = (long)(__ret_warn_on != 0);
  }
  
#line 1656 
  if ((long)tmp_2 != 0L) {
    
#line 1660 
    __retres = -5;
    
#line 1660 
    goto return_label;
  }
  else ;
  {
    
#line 1662 
    bool __cond_0 = (_Bool)((int)*("Setting HCMD_ACTIVE for command %s\n" + 34UL) != 10);
    
#line 1662 
    if ((int)__cond_0 != 0) 
#line 1662 
                            __compiletime_assert_1663(); else ;
  }
  
#line 1662 
  tmp_3 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
  
#line 1662 
  ;
  
#line 1662 
  __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_send_hcmd_sync","Setting HCMD_ACTIVE for command %s\n",tmp_3);
  
#line 1665 
  cmd_idx = iwl_pcie_enqueue_hcmd(trans,cmd);
  
#line 1666 
  if (cmd_idx < 0) {
    char const *tmp_4;
    
#line 1667 
    ret = cmd_idx;
    
#line 1668 
    set_bit(0L,(unsigned long volatile *)(& trans->status));
    {
      
#line 1669 
      bool __cond_1 = (_Bool)((int)*("Error sending %s: enqueue_hcmd failed: %d\n" + 41UL) != 10);
      
#line 1669 
      if ((int)__cond_1 != 0) 
#line 1669 
                              __compiletime_assert_1671(); else ;
    }
    
#line 1669 
    ;
    
#line 1669 
    tmp_4 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
    
#line 1669 
    ;
    
#line 1669 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Error sending %s: enqueue_hcmd failed: %d\n",tmp_4,ret);
    
#line 1672 
    __retres = ret;
    
#line 1672 
    goto return_label;
  }
  else ;
  {
    
#line 1675 
    long __ret = 500L;
    
#line 1675 
    __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1678,0);
    {
      int tmp_10;
      {
        int tmp_9;
        
#line 1675 
        tmp_9 = constant_test_bit(0L,(unsigned long const volatile *)(& trans->status));
        
#line 1675 
        bool __cond_3 = (_Bool)(tmp_9 == 0);
        
#line 1675 
        if ((int)__cond_3 != 0 && __ret == 0L) 
#line 1675 
                                               __ret = 1L; else ;
        
#line 1675 
        tmp_10 = ((int)__cond_3 != 0 || __ret == 0L) != 0;
      }
      
#line 1675 
      if (tmp_10 == 0) {
        long tmp_8;
        {
          wait_queue_t __wait;
          
#line 1675 
          long __ret_0 = 500L;
          
#line 1675 
          INIT_LIST_HEAD(& __wait.task_list);
          
#line 1675 
          __wait.flags = 0U;
          ldv_55820: 
#line 1678 
          ;
          {
            int tmp_7;
            
#line 1675 
            long __int = prepare_to_wait_event(& trans_pcie->wait_command_queue,& __wait,2);
            {
              int tmp_6;
              
#line 1675 
              tmp_6 = constant_test_bit(0L,(unsigned long const volatile *)(& trans->status));
              
#line 1675 
              bool __cond_2 = (_Bool)(tmp_6 == 0);
              
#line 1675 
              if ((int)__cond_2 != 0 && __ret_0 == 0L) 
#line 1675 
                                                       __ret_0 = 1L; else ;
              
#line 1675 
              tmp_7 = ((int)__cond_2 != 0 || __ret_0 == 0L) != 0;
            }
            
#line 1675 
            if (tmp_7 != 0) 
#line 1675 
                            goto ldv_55819; else ;
            
#line 1675 
            __ret_0 = schedule_timeout(__ret_0);
          }
          
#line 1675 
          goto ldv_55820;
          ldv_55819: 
#line 1676 
          ;
          
#line 1675 
          finish_wait(& trans_pcie->wait_command_queue,& __wait);
          __out_0: 
#line 1675 
          ;
          
#line 1675 
          tmp_8 = __ret_0;
        }
        
#line 1675 
        __ret = tmp_8;
      }
      else ;
    }
    
#line 1675 
    tmp_11 = __ret;
  }
  
#line 1675 
  ret = (int)tmp_11;
  
#line 1679 
  if (ret == 0) {
    unsigned int tmp_12;
    char const *tmp_13;
    char const *tmp_14;
    
#line 1680 
    struct iwl_txq *txq = trans_pcie->txq + (int)trans_pcie->cmd_queue;
    
#line 1681 
    struct iwl_queue *q = & txq->q;
    {
      
#line 1683 
      bool __cond_4 = (_Bool)((int)*("Error sending %s: time out after %dms.\n" + 38UL) != 10);
      
#line 1683 
      if ((int)__cond_4 != 0) 
#line 1683 
                              __compiletime_assert_1685(); else ;
    }
    
#line 1683 
    tmp_12 = jiffies_to_msecs(500UL);
    
#line 1683 
    tmp_13 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
    
#line 1683 
    ;
    
#line 1683 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Error sending %s: time out after %dms.\n",tmp_13,tmp_12);
    {
      
#line 1687 
      bool __cond_5 = (_Bool)((int)*("Current CMD queue read_ptr %d write_ptr %d\n" + 42UL) != 10);
      
#line 1687 
      if ((int)__cond_5 != 0) 
#line 1687 
                              __compiletime_assert_1688(); else ;
    }
    
#line 1687 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Current CMD queue read_ptr %d write_ptr %d\n",q->read_ptr,q->write_ptr);
    
#line 1690 
    set_bit(0L,(unsigned long volatile *)(& trans->status));
    {
      
#line 1691 
      bool __cond_6 = (_Bool)((int)*("Clearing HCMD_ACTIVE for command %s\n" + 35UL) != 10);
      
#line 1691 
      if ((int)__cond_6 != 0) 
#line 1691 
                              __compiletime_assert_1692(); else ;
    }
    
#line 1691 
    tmp_14 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
    
#line 1691 
    ;
    
#line 1691 
    __iwl_dbg(trans->dev,1U,(_Bool)0,"iwl_pcie_send_hcmd_sync","Clearing HCMD_ACTIVE for command %s\n",tmp_14);
    
#line 1693 
    ret = -110;
    
#line 1695 
    iwl_force_nmi(trans);
    
#line 1696 
    iwl_trans_fw_error(trans);
    
#line 1698 
    goto cancel;
  }
  else ;
  
#line 1701 
  tmp_16 = constant_test_bit(5L,(unsigned long const volatile *)(& trans->status));
  
#line 1701 
  if (tmp_16 != 0) {
    char const *tmp_15;
    {
      
#line 1702 
      bool __cond_7 = (_Bool)((int)*("FW error in SYNC CMD %s\n" + 23UL) != 10);
      
#line 1702 
      if ((int)__cond_7 != 0) 
#line 1702 
                              __compiletime_assert_1703(); else ;
    }
    
#line 1702 
    tmp_15 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
    
#line 1702 
    ;
    
#line 1702 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"FW error in SYNC CMD %s\n",tmp_15);
    
#line 1704 
    dump_stack();
    
#line 1705 
    ret = -5;
    
#line 1706 
    goto cancel;
  }
  else ;
  
#line 1709 
  if ((cmd->flags & 4U) == 0U) {
    int tmp_17;
    
#line 1709 
    tmp_17 = constant_test_bit(4L,(unsigned long const volatile *)(& trans->status));
    
#line 1709 
    if (tmp_17 != 0) {
      {
        
#line 1711 
        bool __cond_8 = (_Bool)((int)*("RFKILL in SYNC CMD... no rsp\n" + 28UL) != 10);
        
#line 1711 
        if ((int)__cond_8 != 0) 
#line 1711 
                                __compiletime_assert_1711(); else ;
      }
      
#line 1711 
      __iwl_dbg(trans->dev,131072U,(_Bool)0,"iwl_pcie_send_hcmd_sync","RFKILL in SYNC CMD... no rsp\n");
      
#line 1712 
      ret = -132;
      
#line 1713 
      goto cancel;
    }
    else ;
  }
  else ;
  
#line 1716 
  if ((cmd->flags & 2U) != 0U && cmd->resp_pkt == (struct iwl_rx_packet *)0) {
    char const *tmp_18;
    {
      
#line 1717 
      bool __cond_9 = (_Bool)((int)*("Error: Response NULL in \'%s\'\n" + 28UL) != 10);
      
#line 1717 
      if ((int)__cond_9 != 0) 
#line 1717 
                              __compiletime_assert_1718(); else ;
    }
    
#line 1717 
    tmp_18 = get_cmd_string(trans_pcie,(unsigned char)((int)cmd->id));
    
#line 1717 
    ;
    
#line 1717 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Error: Response NULL in \'%s\'\n",tmp_18);
    
#line 1719 
    ret = -5;
    
#line 1720 
    goto cancel;
  }
  else ;
  
#line 1723 
  __retres = 0;
  
#line 1723 
  goto return_label;
  cancel: 
#line 1725 
  ;
  
#line 1726 
  if ((cmd->flags & 2U) != 0U) 
#line 1734 
                               ((trans_pcie->txq + (int)trans_pcie->cmd_queue)->entries + cmd_idx)->meta.flags &= 4294967293U; else ;
  
#line 1737 
  if (cmd->resp_pkt != (struct iwl_rx_packet *)0) {
    
#line 1738 
    iwl_free_resp(cmd);
    
#line 1739 
    cmd->resp_pkt = (struct iwl_rx_packet *)0;
  }
  else ;
  
#line 1742 
  __retres = ret;
  return_label: 
#line 1742 
                return __retres;
}


#line 1749 
void __compiletime_assert_1750(void);


#line 1745  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
int iwl_trans_pcie_send_hcmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd)
{
  int __retres;
  int tmp_1;
  
#line 1747 
  if ((cmd->flags & 4U) == 0U) {
    int tmp;
    
#line 1747 
    tmp = constant_test_bit(4L,(unsigned long const volatile *)(& trans->status));
    
#line 1747 
    if (tmp != 0) {
      {
        
#line 1749 
        bool __cond = (_Bool)((int)*("Dropping CMD 0x%x: RF KILL\n" + 26UL) != 10);
        
#line 1749 
        if ((int)__cond != 0) 
#line 1749 
                              __compiletime_assert_1750(); else ;
      }
      
#line 1749 
      __iwl_dbg(trans->dev,131072U,(_Bool)0,"iwl_trans_pcie_send_hcmd","Dropping CMD 0x%x: RF KILL\n",(int)cmd->id);
      
#line 1751 
      __retres = -132;
      
#line 1751 
      goto return_label;
    }
    else ;
  }
  else ;
  
#line 1754 
  if ((cmd->flags & 1U) != 0U) {
    int tmp_0;
    
#line 1755 
    tmp_0 = iwl_pcie_send_hcmd_async(trans,cmd);
    
#line 1755 
    __retres = tmp_0;
    
#line 1755 
    goto return_label;
  }
  else ;
  
#line 1758 
  tmp_1 = iwl_pcie_send_hcmd_sync(trans,cmd);
  
#line 1758 
  __retres = tmp_1;
  return_label: 
#line 1758 
                return __retres;
}


#line 1837 
void __compiletime_assert_1837(void);


#line 1891 
void __compiletime_assert_1891(void);


#line 1761  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c"
int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb, struct iwl_device_cmd *dev_cmd, int txq_id)
{
  int __retres;
  struct iwl_cmd_meta *out_meta;
  struct iwl_txq *txq;
  struct iwl_queue *q;
  dma_addr_t tb0_phys;
  dma_addr_t tb1_phys;
  dma_addr_t scratch_phys;
  void *tb1_addr;
  u16 len;
  u16 tb1_len;
  u16 tb2_len;
  bool wait_write_ptr;
  unsigned int tmp;
  u16 wifi_seq;
  int tmp_4;
  int tmp_6_0;
  int tmp_9;
  int tmp_10;
  
#line 1764 
  struct iwl_trans_pcie *trans_pcie = (struct iwl_trans_pcie *)(& trans->trans_specific);
  
#line 1765 
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
  
#line 1766 
  struct iwl_tx_cmd *tx_cmd = (struct iwl_tx_cmd *)(& dev_cmd->payload);
  
#line 1774 
  __le16 fc = hdr->frame_control;
  
#line 1775 
  tmp = ieee80211_hdrlen((unsigned short)((int)fc));
  
#line 1775 
  u8 hdr_len = (unsigned char)tmp;
  
#line 1778 
  txq = trans_pcie->txq + txq_id;
  
#line 1779 
  q = & txq->q;
  {
    bool __warned;
    int tmp_2;
    
#line 1781 
    if (0 != 0) {
      int tmp_0;
      
#line 1781 
      tmp_0 = constant_test_bit((long)txq_id,(unsigned long const volatile *)(& trans_pcie->queue_used));
      
#line 1781 
      tmp_2 = tmp_0 == 0;
    }
    else {
      int tmp_1;
      
#line 1781 
      tmp_1 = variable_test_bit((long)txq_id,(unsigned long const volatile *)(& trans_pcie->queue_used));
      
#line 1781 
      tmp_2 = tmp_1 == 0;
    }
    
#line 1781 
    int __ret_warn_once = tmp_2;
    
#line 1781 
    if ((long)(__ret_warn_once != 0) != 0L) {
      int tmp_3;
      {
        
#line 1781 
        int __ret_warn_on = ! __warned;
        
#line 1781 
        if ((long)(__ret_warn_on != 0) != 0L) 
#line 1781 
                                              warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1782,"TX on unused queue %d\n",txq_id); else ;
        
#line 1781 
        tmp_3 = (long)(__ret_warn_on != 0);
      }
      
#line 1781 
      if ((long)tmp_3 != 0L) 
#line 1781 
                             __warned = (_Bool)1; else ;
    }
    else ;
    
#line 1781 
    tmp_4 = (long)(__ret_warn_once != 0);
  }
  
#line 1781 
  if ((long)tmp_4 != 0L) {
    
#line 1783 
    __retres = -22;
    
#line 1783 
    goto return_label;
  }
  else ;
  
#line 1785 
  ldv_spin_lock_100(& txq->lock);
  
#line 1792 
  wifi_seq = (unsigned short)((int)hdr->seq_ctrl >> 4);
  {
    bool __warned_0;
    
#line 1793 
    int __ret_warn_once_0 = ((int)txq->ampdu != 0 && ((int)wifi_seq & 255) != q->write_ptr) != 0;
    
#line 1793 
    if ((long)(__ret_warn_once_0 != 0) != 0L) {
      int tmp_5;
      {
        
#line 1793 
        int __ret_warn_on_0 = ! __warned_0;
        
#line 1793 
        if ((long)(__ret_warn_on_0 != 0) != 0L) 
#line 1793 
                                                warn_slowpath_fmt("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/pcie/tx.c",1796,"Q: %d WiFi Seq %d tfdNum %d",txq_id,(int)wifi_seq,q->write_ptr); else ;
        
#line 1793 
        tmp_5 = (long)(__ret_warn_on_0 != 0);
      }
      
#line 1793 
      if ((long)tmp_5 != 0L) 
#line 1793 
                             __warned_0 = (_Bool)1; else ;
    }
    else ;
    
#line 1793 
    long tmp_6 = (long)(__ret_warn_once_0 != 0);
  }
  
#line 1799 
  (txq->entries + q->write_ptr)->skb = skb;
  
#line 1800 
  (txq->entries + q->write_ptr)->cmd = dev_cmd;
  
#line 1802 
  dev_cmd->hdr.sequence = (unsigned short)(((txq_id << 8) & 7936) | (q->write_ptr & 255));
  
#line 1806 
  tb0_phys = iwl_pcie_get_scratchbuf_dma(txq,q->write_ptr);
  
#line 1807 
  scratch_phys = tb0_phys + 12ULL;
  
#line 1810 
  tx_cmd->dram_lsb_ptr = (unsigned int)scratch_phys;
  
#line 1811 
  tx_cmd->dram_msb_ptr = iwl_get_dma_hi_addr(scratch_phys);
  
#line 1814 
  out_meta = & (txq->entries + q->write_ptr)->meta;
  
#line 1822 
  len = (unsigned short)((unsigned int)((unsigned short)hdr_len) + 44U);
  
#line 1824 
  tb1_len = (unsigned short)((unsigned int)((unsigned short)((unsigned int)len + 3U)) & 65532U);
  
#line 1827 
  if ((int)tb1_len != (int)len) 
#line 1828 
                                tx_cmd->tx_flags |= 1048576U; else ;
  
#line 1831 
  memcpy((void *)(txq->scratchbufs + q->write_ptr),(void const *)(& dev_cmd->hdr),16UL);
  
#line 1833 
  iwl_pcie_txq_build_tfd(trans,txq,tb0_phys,(unsigned short)16,(_Bool)1);
  {
    
#line 1837 
    bool __cond = (_Bool)0;
    
#line 1837 
    if ((int)__cond != 0) 
#line 1837 
                          __compiletime_assert_1837(); else ;
  }
  
#line 1840 
  tb1_addr = (void *)(& dev_cmd->hdr) + 16U;
  
#line 1841 
  tb1_phys = dma_map_single_attrs(trans->dev,tb1_addr,(unsigned long)tb1_len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
  
#line 1842 
  tmp_6_0 = dma_mapping_error(trans->dev,tb1_phys);
  
#line 1842 
  if ((long)(tmp_6_0 != 0) != 0L) 
#line 1843 
                                  goto out_err; else ;
  
#line 1844 
  iwl_pcie_txq_build_tfd(trans,txq,tb1_phys,(unsigned short)((int)tb1_len),(_Bool)0);
  
#line 1850 
  tb2_len = (unsigned short)((int)((unsigned short)skb->len) - (int)((unsigned short)hdr_len));
  
#line 1851 
  if ((unsigned int)tb2_len != 0U) {
    int tmp_8;
    
#line 1852 
    dma_addr_t tb2_phys = dma_map_single_attrs(trans->dev,(void *)(skb->data + (int)hdr_len),(unsigned long)tb2_len,(enum dma_data_direction)DMA_TO_DEVICE,(struct dma_attrs *)0);
    
#line 1855 
    tmp_8 = dma_mapping_error(trans->dev,tb2_phys);
    
#line 1855 
    if ((long)(tmp_8 != 0) != 0L) {
      
#line 1856 
      iwl_pcie_tfd_unmap(trans,out_meta,txq->tfds + q->write_ptr);
      
#line 1858 
      goto out_err;
    }
    else ;
    
#line 1860 
    iwl_pcie_txq_build_tfd(trans,txq,tb2_phys,(unsigned short)((int)tb2_len),(_Bool)0);
  }
  else ;
  
#line 1864 
  iwl_pcie_txq_update_byte_cnt_tbl(trans,txq,(unsigned short)((int)tx_cmd->len));
  
#line 1866 
  trace_iwlwifi_dev_tx((struct device const *)trans->dev,skb,(void *)(txq->tfds + txq->q.write_ptr),128UL,(void *)(& dev_cmd->hdr),(unsigned long)((int)tb1_len + 16),(void *)(skb->data + (int)hdr_len),(unsigned long)tb2_len);
  
#line 1871 
  trace_iwlwifi_dev_tx_data((struct device const *)trans->dev,skb,(void *)(skb->data + (int)hdr_len),(unsigned long)tb2_len);
  
#line 1874 
  tmp_9 = ieee80211_has_morefrags((unsigned short)((int)fc));
  
#line 1874 
  wait_write_ptr = (_Bool)(tmp_9 != 0);
  
#line 1877 
  if (q->read_ptr == q->write_ptr) {
    
#line 1878 
    if (txq->wd_timeout != 0UL) 
      
#line 1885 
      if (! txq->frozen) 
#line 1886 
                         ldv_mod_timer_101(& txq->stuck_timer,txq->wd_timeout + jiffies); else 
                                                                    
#line 1889 
                                                                    txq->frozen_expiry_remainder = txq->wd_timeout;
    else ;
    {
      
#line 1891 
      bool __cond_0 = (_Bool)((int)*("Q: %d first tx - take ref\n" + 25UL) != 10);
      
#line 1891 
      if ((int)__cond_0 != 0) 
#line 1891 
                              __compiletime_assert_1891(); else ;
    }
    
#line 1891 
    __iwl_dbg(trans->dev,1024U,(_Bool)0,"iwl_trans_pcie_tx","Q: %d first tx - take ref\n",q->id);
    
#line 1892 
    iwl_trans_pcie_ref(trans);
  }
  else ;
  
#line 1896 
  q->write_ptr = iwl_queue_inc_wrap(q->write_ptr);
  
#line 1897 
  if (! wait_write_ptr) 
#line 1898 
                        iwl_pcie_txq_inc_wr_ptr(trans,txq); else ;
  
#line 1904 
  tmp_10 = iwl_queue_space((struct iwl_queue const *)q);
  
#line 1904 
  ;
  
#line 1904 
  if (tmp_10 < q->high_mark) 
    
#line 1905 
    if ((int)wait_write_ptr != 0) 
#line 1906 
                                  iwl_pcie_txq_inc_wr_ptr(trans,txq); else 
                                                                    
#line 1908 
                                                                    iwl_stop_queue(trans,txq);
  else ;
  
#line 1910 
  ldv_spin_unlock_102_0(& txq->lock);
  
#line 1911 
  __retres = 0;
  
#line 1911 
  goto return_label;
  out_err: 
#line 1912 
  ;
  
#line 1913 
  ldv_spin_unlock_103(& txq->lock);
  
#line 1914 
  __retres = -1;
  return_label: 
#line 1914 
                return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
int ldv_emg_del_timer_sync(struct timer_list *arg0);


#line 120  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void atomic_inc(atomic_t *v)
{
  
#line 123 
  ldv_atomic_inc(v);
  
#line 124 
  return;
}


#line 399  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void *kmalloc_0(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 402 
  tmp = ldv_kmalloc(size,flags);
  
#line 402 
  return tmp;
}


#line 413  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *tmp;
  
#line 416 
  tmp = ldv_kcalloc(n,size,flags);
  
#line 416 
  return tmp;
}


#line 745  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_73_2(spinlock_t *lock)
{
  
#line 749 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 751 
  spin_lock_2(lock);
  
#line 752 
  return;
}


#line 755  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_74_2(spinlock_t *lock)
{
  
#line 759 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 761 
  spin_unlock_2(lock);
  
#line 762 
  return;
}


#line 765  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_75(spinlock_t *lock)
{
  
#line 769 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 771 
  spin_unlock_2(lock);
  
#line 772 
  return;
}


#line 775  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_bh_76(spinlock_t *lock)
{
  
#line 779 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 781 
  spin_lock_bh_1(lock);
  
#line 782 
  return;
}


#line 785  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_bh_77(spinlock_t *lock)
{
  
#line 789 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 791 
  spin_unlock_bh_1(lock);
  
#line 792 
  return;
}


#line 795  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_bh_78(spinlock_t *lock)
{
  
#line 799 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 801 
  spin_lock_bh_1(lock);
  
#line 802 
  return;
}


#line 805  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_bh_79(spinlock_t *lock)
{
  
#line 809 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 811 
  spin_unlock_bh_1(lock);
  
#line 812 
  return;
}


#line 815  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static int ldv_del_timer_sync_80(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 819 
  tmp = ldv_emg_del_timer_sync(ldv_func_arg1);
  
#line 819 
  return tmp;
}


#line 823  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_81_0(spinlock_t *lock)
{
  
#line 827 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 829 
  spin_lock_2(lock);
  
#line 830 
  return;
}


#line 833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_82_1(spinlock_t *lock)
{
  
#line 837 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 839 
  spin_unlock_2(lock);
  
#line 840 
  return;
}


#line 843  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_83_0(spinlock_t *lock)
{
  
#line 847 
  ldv_spin_model_lock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 849 
  spin_lock_2(lock);
  
#line 850 
  return;
}


#line 853  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_84_0(spinlock_t *lock)
{
  
#line 857 
  ldv_spin_model_unlock((char *)"irq_lock_of_iwl_trans_pcie");
  
#line 859 
  spin_unlock_2(lock);
  
#line 860 
  return;
}


#line 863  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static int ldv_del_timer_85(struct timer_list *ldv_func_arg1)
{
  int tmp;
  
#line 867 
  tmp = ldv_emg_del_timer(ldv_func_arg1);
  
#line 867 
  return tmp;
}


#line 871  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static int ldv_mod_timer_86(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 875 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 875 
  return tmp;
}


#line 879  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_bh_87_0(spinlock_t *lock)
{
  
#line 883 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 885 
  spin_lock_bh_1(lock);
  
#line 886 
  return;
}


#line 889  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_bh_88(spinlock_t *lock)
{
  
#line 893 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 895 
  spin_unlock_bh_1(lock);
  
#line 896 
  return;
}


#line 899  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv___ldv_spin_lock_89(spinlock_t *ldv_func_arg1)
{
  
#line 903 
  ldv_spin_model_lock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 905 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 906 
  return;
}


#line 909  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_irqrestore_90(spinlock_t *lock, unsigned long flags)
{
  
#line 913 
  ldv_spin_model_unlock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 915 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 916 
  return;
}


#line 919  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_bh_91(spinlock_t *lock)
{
  
#line 923 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 925 
  spin_lock_bh_1(lock);
  
#line 926 
  return;
}


#line 929  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_bh_92(spinlock_t *lock)
{
  
#line 933 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 935 
  spin_unlock_bh_1(lock);
  
#line 936 
  return;
}


#line 939  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static int ldv_mod_timer_93(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 943 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 943 
  return tmp;
}


#line 947  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv___ldv_spin_lock_94(spinlock_t *ldv_func_arg1)
{
  
#line 951 
  ldv_spin_model_lock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 953 
  __ldv_spin_lock(ldv_func_arg1);
  
#line 954 
  return;
}


#line 957  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_irqrestore_95(spinlock_t *lock, unsigned long flags)
{
  
#line 961 
  ldv_spin_model_unlock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 963 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 964 
  return;
}


#line 967  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_irqrestore_96_0(spinlock_t *lock, unsigned long flags)
{
  
#line 971 
  ldv_spin_model_unlock((char *)"reg_lock_of_iwl_trans_pcie");
  
#line 973 
  spin_unlock_irqrestore_0(lock,flags);
  
#line 974 
  return;
}


#line 977  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_bh_97(spinlock_t *lock)
{
  
#line 981 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 983 
  spin_unlock_bh_1(lock);
  
#line 984 
  return;
}


#line 987  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_bh_98(spinlock_t *lock)
{
  
#line 991 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 993 
  spin_lock_bh_1(lock);
  
#line 994 
  return;
}


#line 997  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_bh_99(spinlock_t *lock)
{
  
#line 1001 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 1003 
  spin_unlock_bh_1(lock);
  
#line 1004 
  return;
}


#line 1007  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_lock_100(spinlock_t *lock)
{
  
#line 1011 
  ldv_spin_model_lock((char *)"lock_of_iwl_txq");
  
#line 1013 
  spin_lock_2(lock);
  
#line 1014 
  return;
}


#line 1017  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static int ldv_mod_timer_101(struct timer_list *ldv_func_arg1, unsigned long ldv_func_arg2)
{
  int tmp;
  
#line 1021 
  tmp = ldv_emg_mod_timer(ldv_func_arg1,ldv_func_arg2);
  
#line 1021 
  return tmp;
}


#line 1025  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_102_0(spinlock_t *lock)
{
  
#line 1029 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 1031 
  spin_unlock_2(lock);
  
#line 1032 
  return;
}


#line 1035  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_tx.c.aux"
static void ldv_spin_unlock_103(spinlock_t *lock)
{
  
#line 1039 
  ldv_spin_model_unlock((char *)"lock_of_iwl_txq");
  
#line 1041 
  spin_unlock_2(lock);
  
#line 1042 
  return;
}


#line 94  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/bitops.h"
__inline static void __set_bit(long nr, unsigned long volatile *addr)
{
  
#line 96 
  ldv_inline_asm();
  
#line 97 
  return;
}


#line 402  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kernel.h"
int sprintf(char *, char const * , ...);


#line 65  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/arch/x86/include/asm/string_64.h"
char *strcpy(char *, char const *);


#line 67 
int strcmp(char const *, char const *);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
static void *ERR_PTR_1(long error);


#line 37  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_lock_73(struct mutex *ldv_func_arg1);


#line 41 
static void ldv_mutex_lock_76(struct mutex *ldv_func_arg1);


#line 45 
static void ldv_mutex_lock_78(struct mutex *ldv_func_arg1);


#line 49 
static void ldv_mutex_lock_81(struct mutex *ldv_func_arg1);


#line 55 
void ldv_mutex_model_lock(struct mutex *, char *);


#line 57 
void ldv_mutex_model_unlock(struct mutex *, char *);


#line 73  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/completion.h"
__inline static void init_completion(struct completion *x)
{
  
#line 75 
  x->done = 0U;
  {
    struct lock_class_key __key;
    
#line 76 
    __init_waitqueue_head(& x->wait,"&x->wait",& __key);
  }
  
#line 78 
  return;
}


#line 91 
void wait_for_completion(struct completion *);


#line 106 
void complete(struct completion *);


#line 119  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/mutex.h"
void __mutex_init(struct mutex *, char const *, struct lock_class_key *);


#line 193 
static void ldv_mutex_unlock_74(struct mutex *ldv_func_arg1);


#line 197 
static void ldv_mutex_unlock_75(struct mutex *ldv_func_arg1);


#line 201 
static void ldv_mutex_unlock_77(struct mutex *ldv_func_arg1);


#line 205 
static void ldv_mutex_unlock_79(struct mutex *ldv_func_arg1);


#line 209 
static void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1);


#line 213 
static void ldv_mutex_unlock_82(struct mutex *ldv_func_arg1);


#line 217 
static void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1);


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kobject.h"
__inline static char const *kobject_name(struct kobject const *kobj)
{
  char const *__retres;
  
#line 89 
  __retres = kobj->name;
  
#line 89 
  return __retres;
}


#line 833  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
__inline static char const *dev_name(struct device const *dev)
{
  char const *__retres;
  char const *tmp;
  
#line 836 
  if (dev->init_name != (char const *)0) {
    
#line 837 
    __retres = dev->init_name;
    
#line 837 
    goto return_label;
  }
  else ;
  
#line 839 
  tmp = kobject_name(& dev->kobj);
  
#line 839 
  __retres = tmp;
  return_label: 
#line 839 
                return __retres;
}


#line 1006 
void device_release_driver(struct device *);


#line 44  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/firmware.h"
int request_firmware_nowait(struct module *, bool, char const *, struct device *, gfp_t, void *, void (*)(struct firmware const *, void *));


#line 51 
void release_firmware(struct firmware const *);


#line 36  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/kmod.h"
int __request_module(bool, char const * , ...);


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/vmalloc.h"
void *vmalloc(unsigned long);


#line 83 
void vfree(void const *);


#line 430  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/rculist.h"
void __compiletime_assert_430(void);


#line 581  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kzalloc_3(size_t size, gfp_t flags);


#line 58  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/debugfs.h"
struct dentry *debugfs_create_dir(char const *, struct dentry *);


#line 69 
void debugfs_remove_recursive(struct dentry *);


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-fw.h"
__inline static bool fw_has_api(struct iwl_ucode_capabilities const *capabilities, iwl_ucode_tlv_api_t api)
{
  bool __retres;
  int tmp_1;
  
#line 116 
  if (0 != 0) {
    int tmp;
    
#line 116 
    tmp = constant_test_bit((long)api,(unsigned long const volatile *)(& capabilities->_api));
    
#line 116 
    tmp_1 = tmp != 0;
  }
  else {
    int tmp_0;
    
#line 116 
    tmp_0 = variable_test_bit((long)api,(unsigned long const volatile *)(& capabilities->_api));
    
#line 116 
    tmp_1 = tmp_0 != 0;
  }
  
#line 116 
  __retres = (_Bool)(tmp_1 != 0);
  
#line 116 
  return __retres;
}


#line 170  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
int iwl_opmode_register(char const *name, struct iwl_op_mode_ops const *ops);


#line 171 
void iwl_opmode_deregister(char const *name);


#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h"
__inline static void iwl_op_mode_stop(struct iwl_op_mode *op_mode)
{
  
#line 187 
  __might_sleep("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-op-mode.h",187,0);
  
#line 188 
  (*((op_mode->ops)->stop))(op_mode);
  
#line 189 
  return;
}


#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static struct dentry *iwl_dbgfs_root;

#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static struct mutex iwlwifi_opmode_table_mtx;

#line 140  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static struct iwlwifi_opmode_table iwlwifi_opmode_table[2U] = {{.name = "iwldvm", .ops = (struct iwl_op_mode_ops const *)0, .drv = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}, {.name = "iwlmvm", .ops = (struct iwl_op_mode_ops const *)0, .drv = {.next = (struct list_head *)0, .prev = (struct list_head *)0}}};

#line 157  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void iwl_free_fw_desc(struct iwl_drv *drv, struct fw_desc *desc)
{
  
#line 159 
  vfree(desc->data);
  
#line 160 
  desc->data = (void const *)0;
  
#line 161 
  desc->len = 0U;
  
#line 162 
  return;
}


#line 164  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void iwl_free_fw_img(struct iwl_drv *drv, struct fw_img *img)
{
  int i;
  
#line 167 
  i = 0;
  
#line 167 
  goto ldv_51396;
  ldv_51395: 
#line 168 
  ;
  
#line 168 
  iwl_free_fw_desc(drv,& img->sec[i]);
  
#line 167 
  i += 1;
  ldv_51396: 
#line 168 
  ;
  
#line 167 
  if (i <= 11) 
#line 169 
               goto ldv_51395; else 
#line 172 
                                    goto ldv_51397;
  ldv_51397: 
#line 173 
  ;
  
#line 174 
  return;
}


#line 171  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void iwl_dealloc_ucode(struct iwl_drv *drv)
{
  int i;
  
#line 175 
  kfree((void const *)drv->fw.dbg_dest_tlv);
  
#line 176 
  i = 0;
  
#line 176 
  goto ldv_51406;
  ldv_51405: 
#line 177 
  ;
  
#line 177 
  kfree((void const *)drv->fw.dbg_conf_tlv[i]);
  
#line 176 
  i += 1;
  ldv_51406: 
#line 177 
  ;
  
#line 176 
  if ((unsigned int)i <= 31U) 
#line 178 
                              goto ldv_51405; else 
#line 181 
                                                   goto ldv_51407;
  ldv_51407: 
#line 182 
  ;
  
#line 178 
  i = 0;
  
#line 178 
  goto ldv_51412;
  ldv_51411: 
#line 179 
  ;
  
#line 179 
  kfree((void const *)drv->fw.dbg_trigger_tlv[i]);
  
#line 178 
  i += 1;
  ldv_51412: 
#line 179 
  ;
  
#line 178 
  if ((unsigned int)i <= 11U) 
#line 180 
                              goto ldv_51411; else 
#line 183 
                                                   goto ldv_51413;
  ldv_51413: 
#line 184 
  ;
  
#line 181 
  i = 0;
  
#line 181 
  goto ldv_51415;
  ldv_51414: 
#line 182 
  ;
  
#line 182 
  iwl_free_fw_img(drv,(struct fw_img *)(& drv->fw.img) + i);
  
#line 181 
  i += 1;
  ldv_51415: 
#line 182 
  ;
  
#line 181 
  if (i <= 3) 
#line 183 
              goto ldv_51414; else 
#line 186 
                                   goto ldv_51416;
  ldv_51416: 
#line 187 
  ;
  
#line 188 
  return;
}


#line 185  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_alloc_fw_desc(struct iwl_drv *drv, struct fw_desc *desc, struct fw_sec *sec)
{
  int __retres;
  void *data;
  
#line 190 
  desc->data = (void const *)0;
  
#line 192 
  if (sec == (struct fw_sec *)0 || sec->size == 0UL) {
    
#line 193 
    __retres = -22;
    
#line 193 
    goto return_label;
  }
  else ;
  
#line 195 
  data = vmalloc(sec->size);
  
#line 196 
  if (data == (void *)0) {
    
#line 197 
    __retres = -12;
    
#line 197 
    goto return_label;
  }
  else ;
  
#line 199 
  desc->len = (unsigned int)sec->size;
  
#line 200 
  desc->offset = sec->offset;
  
#line 201 
  memcpy(data,sec->data,(unsigned long)desc->len);
  
#line 202 
  desc->data = (void const *)data;
  
#line 204 
  __retres = 0;
  return_label: 
#line 204 
                return __retres;
}


#line 207 
static void iwl_req_fw_callback(struct firmware const *ucode_raw, void *context);


#line 232 
void __compiletime_assert_232(void);


#line 250 
void __compiletime_assert_253(void);


#line 213  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_request_firmware(struct iwl_drv *drv, bool first)
{
  int __retres;
  char tag[8U];
  char *tmp;
  int tmp_0;
  
#line 215 
  char const *name_pre = (drv->cfg)->fw_name_pre;
  
#line 218 
  if ((int)first != 0) {
    
#line 220 
    drv->fw_index = 100;
    
#line 221 
    strcpy((char *)(& tag),"exp");
  }
  else 
    
#line 222 
    if (drv->fw_index == 100) {
      
#line 224 
      drv->fw_index = (int)(drv->cfg)->ucode_api_max;
      
#line 225 
      sprintf((char *)(& tag),"%d",drv->fw_index);
    }
    else {
      
#line 227 
      drv->fw_index -= 1;
      
#line 228 
      sprintf((char *)(& tag),"%d",drv->fw_index);
    }
  
#line 231 
  if ((unsigned int)drv->fw_index < (drv->cfg)->ucode_api_min) {
    {
      
#line 232 
      bool __cond = (_Bool)((int)*("no suitable firmware found!\n" + 27UL) != 10);
      
#line 232 
      if ((int)__cond != 0) 
#line 232 
                            __compiletime_assert_232(); else ;
    }
    
#line 232 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"no suitable firmware found!\n");
    
#line 233 
    __retres = -2;
    
#line 233 
    goto return_label;
  }
  else ;
  
#line 236 
  snprintf((char *)(& drv->firmware_name),32UL,"%s%s.ucode",name_pre,(char *)(& tag));
  
#line 243 
  if (((drv->trans)->cfg)->device_family == (unsigned int)IWL_DEVICE_FAMILY_8000) {
    
#line 244 
    char rev_step = (char)((((drv->trans)->hw_rev >> 2) & 3U) + 65U);
    
#line 246 
    snprintf((char *)(& drv->firmware_name),32UL,"%s%c-%s.ucode",name_pre,(int)rev_step,(char *)(& tag));
  }
  else ;
  {
    
#line 250 
    bool __cond_0 = (_Bool)((int)*("attempting to load firmware %s\'%s\'\n" + 34UL) != 10);
    
#line 250 
    if ((int)__cond_0 != 0) 
#line 250 
                            __compiletime_assert_253(); else ;
  }
  
#line 250 
  ;
  
#line 250 
  if (drv->fw_index == 100) 
#line 250 
                            tmp = (char *)"EXPERIMENTAL "; else 
#line 250 
                                                                tmp = (char *)"";
  
#line 250 
  ;
  
#line 250 
  __iwl_dbg(drv->dev,1U,(_Bool)0,"iwl_request_firmware","attempting to load firmware %s\'%s\'\n",tmp,(char *)(& drv->firmware_name));
  
#line 255 
  tmp_0 = request_firmware_nowait(& __this_module,(_Bool)1,(char const *)(& drv->firmware_name),(drv->trans)->dev,208U,(void *)drv,& iwl_req_fw_callback);
  
#line 255 
  __retres = tmp_0;
  return_label: 
#line 255 
                return __retres;
}


#line 302  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static struct fw_sec *get_sec(struct iwl_firmware_pieces *pieces, enum iwl_ucode_type type, int sec)
{
  struct fw_sec *__retres;
  
#line 306 
  __retres = & pieces->img[(unsigned int)type].sec[sec];
  
#line 306 
  return __retres;
}


#line 309  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void set_sec_data(struct iwl_firmware_pieces *pieces, enum iwl_ucode_type type, int sec, void const *data)
{
  
#line 314 
  pieces->img[(unsigned int)type].sec[sec].data = data;
  
#line 315 
  return;
}


#line 317  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void set_sec_size(struct iwl_firmware_pieces *pieces, enum iwl_ucode_type type, int sec, size_t size)
{
  
#line 322 
  pieces->img[(unsigned int)type].sec[sec].size = size;
  
#line 323 
  return;
}


#line 325  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static size_t get_sec_size(struct iwl_firmware_pieces *pieces, enum iwl_ucode_type type, int sec)
{
  size_t __retres;
  
#line 329 
  __retres = pieces->img[(unsigned int)type].sec[sec].size;
  
#line 329 
  return __retres;
}


#line 332  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void set_sec_offset(struct iwl_firmware_pieces *pieces, enum iwl_ucode_type type, int sec, u32 offset)
{
  
#line 337 
  pieces->img[(unsigned int)type].sec[sec].offset = offset;
  
#line 338 
  return;
}


#line 340  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_store_cscheme(struct iwl_fw *fw, u8 const *data, u32 const len)
{
  int __retres;
  int i;
  int j;
  struct iwl_fw_cipher_scheme *fwcs;
  struct ieee80211_cipher_scheme *cs;
  u32 cipher;
  int tmp;
  
#line 343 
  struct iwl_fw_cscheme_list *l = (struct iwl_fw_cscheme_list *)data;
  
#line 348 
  if (len == 0U || (unsigned long)len < (unsigned long)l->size * 13UL + 1UL) {
    
#line 350 
    __retres = -22;
    
#line 350 
    goto return_label;
  }
  else ;
  
#line 352 
  i = 0;
  
#line 352 
  j = 0;
  
#line 352 
  goto ldv_51505;
  ldv_51504: 
#line 353 
  ;
  
#line 353 
  fwcs = & l->cs[j];
  
#line 354 
  cipher = fwcs->cipher;
  
#line 357 
  if (cipher == 0U) 
#line 358 
                    goto ldv_51503; else ;
  
#line 360 
  tmp = j;
  
#line 360 
  j += 1;
  
#line 360 
  cs = & fw->cs[tmp];
  
#line 361 
  cs->cipher = cipher;
  
#line 362 
  cs->iftype = (unsigned short)4U;
  
#line 363 
  cs->hdr_len = fwcs->hdr_len;
  
#line 364 
  cs->pn_len = fwcs->pn_len;
  
#line 365 
  cs->pn_off = fwcs->pn_off;
  
#line 366 
  cs->key_idx_off = fwcs->key_idx_off;
  
#line 367 
  cs->key_idx_mask = fwcs->key_idx_mask;
  
#line 368 
  cs->key_idx_shift = fwcs->key_idx_shift;
  
#line 369 
  cs->mic_len = fwcs->mic_len;
  ldv_51503: 
#line 370 
  ;
  
#line 352 
  i += 1;
  ldv_51505: 
#line 353 
  ;
  
#line 352 
  if (i <= 0 && (int)l->size > i) 
#line 354 
                                  goto ldv_51504; else 
#line 357 
                                                       goto ldv_51506;
  ldv_51506: 
#line 358 
  ;
  
#line 372 
  __retres = 0;
  return_label: 
#line 372 
                return __retres;
}


#line 378  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_store_ucode_sec(struct iwl_firmware_pieces *pieces, void const *data, enum iwl_ucode_type type, int size)
{
  int __retres;
  struct fw_img_parsing *img;
  struct fw_sec *sec;
  struct fw_sec_parsing *sec_parse;
  int tmp;
  {
    
#line 386 
    int __ret_warn_on = ((pieces == (struct iwl_firmware_pieces *)0 || data == (void const *)0) || type > (unsigned int)IWL_UCODE_REGULAR_USNIFFER) != 0;
    
#line 386 
    if ((long)(__ret_warn_on != 0) != 0L) 
#line 386 
                                          warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c",386); else ;
    
#line 386 
    tmp = (long)(__ret_warn_on != 0);
  }
  
#line 386 
  if ((long)tmp != 0L) {
    
#line 387 
    __retres = -1;
    
#line 387 
    goto return_label;
  }
  else ;
  
#line 389 
  sec_parse = (struct fw_sec_parsing *)data;
  
#line 391 
  img = & pieces->img[(unsigned int)type];
  
#line 392 
  sec = & img->sec[img->sec_counter];
  
#line 394 
  sec->offset = sec_parse->offset;
  
#line 395 
  sec->data = (void const *)(& sec_parse->data);
  
#line 396 
  sec->size = (unsigned long)size + 18446744073709551612UL;
  
#line 398 
  img->sec_counter += 1;
  
#line 400 
  __retres = 0;
  return_label: 
#line 400 
                return __retres;
}


#line 409 
void __compiletime_assert_410(void);


#line 403  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_set_default_calib(struct iwl_drv *drv, u8 const *data)
{
  int __retres;
  
#line 405 
  struct iwl_tlv_calib_data *def_calib = (struct iwl_tlv_calib_data *)data;
  
#line 407 
  u32 ucode_type = def_calib->ucode_type;
  
#line 408 
  if (ucode_type > 3U) {
    {
      
#line 409 
      bool __cond = (_Bool)((int)*("Wrong ucode_type %u for default calibration.\n" + 44UL) != 10);
      
#line 409 
      if ((int)__cond != 0) 
#line 409 
                            __compiletime_assert_410(); else ;
    }
    
#line 409 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Wrong ucode_type %u for default calibration.\n",ucode_type);
    
#line 411 
    __retres = -22;
    
#line 411 
    goto return_label;
  }
  else ;
  
#line 413 
  drv->fw.default_calib[ucode_type].flow_trigger = def_calib->calib.flow_trigger;
  
#line 415 
  drv->fw.default_calib[ucode_type].event_trigger = def_calib->calib.event_trigger;
  
#line 418 
  __retres = 0;
  return_label: 
#line 418 
                return __retres;
}


#line 421  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_set_ucode_api_flags(struct iwl_drv *drv, u8 const *data, struct iwl_ucode_capabilities *capa)
{
  int __retres;
  int i;
  
#line 424 
  struct iwl_ucode_api const *ucode_api = (struct iwl_ucode_api const *)data;
  
#line 425 
  u32 api_index = ucode_api->api_index;
  
#line 426 
  u32 api_flags = ucode_api->api_flags;
  
#line 429 
  if (api_index > 1U) {
    {
      
#line 430 
      bool __cond = (_Bool)((int)*("api_index larger than supported by driver\n" + 41UL) != 10);
      
#line 430 
      if ((int)__cond != 0) 
#line 430 
                            __compiletime_assert_430(); else ;
    }
    
#line 430 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"api_index larger than supported by driver\n");
    
#line 432 
    __retres = 0;
    
#line 432 
    goto return_label;
  }
  else ;
  
#line 435 
  i = 0;
  
#line 435 
  goto ldv_51542;
  ldv_51541: 
#line 436 
  ;
  
#line 436 
  if ((((unsigned long)api_flags >> i) & 1UL) != 0UL) 
#line 437 
                                                      __set_bit((long)(api_index * 32U + (unsigned int)i),(unsigned long volatile *)(& capa->_api)); else ;
  
#line 435 
  i += 1;
  ldv_51542: 
#line 436 
  ;
  
#line 435 
  if (i <= 31) 
#line 437 
               goto ldv_51541; else 
#line 440 
                                    goto ldv_51543;
  ldv_51543: 
#line 441 
  ;
  
#line 440 
  __retres = 0;
  return_label: 
#line 440 
                return __retres;
}


#line 452 
void __compiletime_assert_452(void);


#line 443  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_set_ucode_capabilities(struct iwl_drv *drv, u8 const *data, struct iwl_ucode_capabilities *capa)
{
  int __retres;
  int i;
  
#line 446 
  struct iwl_ucode_capa const *ucode_capa = (struct iwl_ucode_capa const *)data;
  
#line 447 
  u32 api_index = ucode_capa->api_index;
  
#line 448 
  u32 api_flags = ucode_capa->api_capa;
  
#line 451 
  if (api_index > 1U) {
    {
      
#line 452 
      bool __cond = (_Bool)((int)*("api_index larger than supported by driver\n" + 41UL) != 10);
      
#line 452 
      if ((int)__cond != 0) 
#line 452 
                            __compiletime_assert_452(); else ;
    }
    
#line 452 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"api_index larger than supported by driver\n");
    
#line 454 
    __retres = 0;
    
#line 454 
    goto return_label;
  }
  else ;
  
#line 457 
  i = 0;
  
#line 457 
  goto ldv_51558;
  ldv_51557: 
#line 458 
  ;
  
#line 458 
  if ((((unsigned long)api_flags >> i) & 1UL) != 0UL) 
#line 459 
                                                      __set_bit((long)(api_index * 32U + (unsigned int)i),(unsigned long volatile *)(& capa->_capa)); else ;
  
#line 457 
  i += 1;
  ldv_51558: 
#line 458 
  ;
  
#line 457 
  if (i <= 31) 
#line 459 
               goto ldv_51557; else 
#line 462 
                                    goto ldv_51559;
  ldv_51559: 
#line 463 
  ;
  
#line 462 
  __retres = 0;
  return_label: 
#line 462 
                return __retres;
}


#line 481 
void __compiletime_assert_481(void);


#line 500 
void __compiletime_assert_500(void);


#line 540 
void __compiletime_assert_542(void);


#line 465  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_parse_v1_v2_firmware(struct iwl_drv *drv, struct firmware const *ucode_raw, struct iwl_firmware_pieces *pieces)
{
  int __retres;
  u32 api_ver;
  u32 hdr_size;
  u32 build;
  char buildstr[25U];
  u8 const *src;
  size_t tmp_0;
  size_t tmp_1;
  size_t tmp_2;
  size_t tmp_3;
  size_t tmp_4;
  size_t tmp_5;
  size_t tmp_6;
  size_t tmp_7;
  
#line 469 
  struct iwl_ucode_header *ucode = (struct iwl_ucode_header *)ucode_raw->data;
  
#line 474 
  drv->fw.ucode_ver = ucode->ver;
  
#line 475 
  api_ver = (drv->fw.ucode_ver >> 8) & 255U;
  
#line 477 
  switch (api_ver) {
    default: 
#line 478 
    ;
    
#line 479 
    hdr_size = 28U;
    
#line 480 
    if (ucode_raw->size < (unsigned long)hdr_size) {
      {
        
#line 481 
        bool __cond = (_Bool)((int)*("File size too small!\n" + 20UL) != 10);
        
#line 481 
        if ((int)__cond != 0) 
#line 481 
                              __compiletime_assert_481(); else ;
      }
      
#line 481 
      __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"File size too small!\n");
      
#line 482 
      __retres = -22;
      
#line 482 
      goto return_label;
    }
    else ;
    
#line 484 
    build = ucode->u.v2.build;
    
#line 485 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1,(unsigned long)ucode->u.v2.inst_size);
    
#line 487 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0,(unsigned long)ucode->u.v2.data_size);
    
#line 489 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1,(unsigned long)ucode->u.v2.init_size);
    
#line 491 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0,(unsigned long)ucode->u.v2.init_data_size);
    
#line 493 
    src = (u8 const *)(& ucode->u.v2.data);
    
#line 494 
    goto ldv_51576;
    case (u32)0: 
#line 495 
    ;
    case (u32)1: 
#line 496 
    ;
    case (u32)2: 
#line 497 
    ;
    
#line 498 
    hdr_size = 24U;
    
#line 499 
    if (ucode_raw->size < (unsigned long)hdr_size) {
      {
        
#line 500 
        bool __cond_0 = (_Bool)((int)*("File size too small!\n" + 20UL) != 10);
        
#line 500 
        if ((int)__cond_0 != 0) 
#line 500 
                                __compiletime_assert_500(); else ;
      }
      
#line 500 
      __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"File size too small!\n");
      
#line 501 
      __retres = -22;
      
#line 501 
      goto return_label;
    }
    else ;
    
#line 503 
    build = 0U;
    
#line 504 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1,(unsigned long)ucode->u.v1.inst_size);
    
#line 506 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0,(unsigned long)ucode->u.v1.data_size);
    
#line 508 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1,(unsigned long)ucode->u.v1.init_size);
    
#line 510 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0,(unsigned long)ucode->u.v1.init_data_size);
    
#line 512 
    src = (u8 const *)(& ucode->u.v1.data);
    
#line 513 
    goto ldv_51576;
  }
  ldv_51576: 
#line 516 
  ;
  
#line 516 
  if (build != 0U) {
    char *tmp;
    
#line 517 
    if (drv->fw_index == 100) 
#line 517 
                              tmp = (char *)" (EXP)"; else 
#line 517 
                                                           tmp = (char *)"";
    
#line 517 
    ;
    
#line 517 
    sprintf((char *)(& buildstr)," build %u%s",build,tmp);
  }
  else 
#line 521 
       buildstr[0] = (char)0;
  
#line 523 
  snprintf((char *)(& drv->fw.fw_version),32UL,"%u.%u.%u.%u%s",drv->fw.ucode_ver >> 24,(drv->fw.ucode_ver >> 16) & 255U,(drv->fw.ucode_ver >> 8) & 255U,drv->fw.ucode_ver & 255U,(char *)(& buildstr));
  
#line 534 
  tmp_0 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1);
  
#line 535 
  tmp_1 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0);
  
#line 536 
  tmp_2 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1);
  
#line 537 
  tmp_3 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0);
  
#line 534 
  ;
  
#line 534 
  if (ucode_raw->size != ((((unsigned long)hdr_size + tmp_0) + tmp_1) + tmp_2) + tmp_3) {
    {
      
#line 540 
      bool __cond_1 = (_Bool)((int)*("uCode file size %d does not match expected size\n" + 47UL) != 10);
      
#line 540 
      if ((int)__cond_1 != 0) 
#line 540 
                              __compiletime_assert_542(); else ;
    }
    
#line 540 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"uCode file size %d does not match expected size\n",(int)ucode_raw->size);
    
#line 543 
    __retres = -22;
    
#line 543 
    goto return_label;
  }
  else ;
  
#line 547 
  set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1,(void const *)src);
  
#line 548 
  tmp_4 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1);
  
#line 548 
  src += tmp_4;
  
#line 549 
  set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1,0U);
  
#line 551 
  set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0,(void const *)src);
  
#line 552 
  tmp_5 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0);
  
#line 552 
  src += tmp_5;
  
#line 553 
  set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0,8388608U);
  
#line 555 
  set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1,(void const *)src);
  
#line 556 
  tmp_6 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1);
  
#line 556 
  src += tmp_6;
  
#line 557 
  set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1,0U);
  
#line 559 
  set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0,(void const *)src);
  
#line 560 
  tmp_7 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0);
  
#line 560 
  src += tmp_7;
  
#line 561 
  set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0,8388608U);
  
#line 563 
  __retres = 0;
  return_label: 
#line 563 
                return __retres;
}


#line 585 
void __compiletime_assert_585(void);


#line 590 
void __compiletime_assert_591(void);


#line 629 
void __compiletime_assert_630(void);


#line 876 
void __compiletime_assert_877(void);


#line 882 
void __compiletime_assert_883(void);


#line 897 
void __compiletime_assert_899(void);


#line 904 
void __compiletime_assert_906(void);


#line 920 
void __compiletime_assert_921(void);


#line 933 
void __compiletime_assert_935(void);


#line 940 
void __compiletime_assert_942(void);


#line 946 
void __compiletime_assert_946(void);


#line 977 
void __compiletime_assert_977(void);


#line 985 
void __compiletime_assert_985(void);


#line 566  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_parse_tlv_firmware(struct iwl_drv *drv, struct firmware const *ucode_raw, struct iwl_firmware_pieces *pieces, struct iwl_ucode_capabilities *capa)
{
  int __retres;
  struct iwl_ucode_tlv *tlv;
  u8 const *data;
  u32 tlv_len;
  enum iwl_ucode_tlv_type tlv_type;
  u8 const *tlv_data;
  char buildstr[25U];
  u32 build;
  int num_of_cpus;
  bool tmp_10;
  
#line 571 
  struct iwl_tlv_ucode_header *ucode = (struct iwl_tlv_ucode_header *)ucode_raw->data;
  
#line 573 
  size_t len = ucode_raw->size;
  
#line 581 
  bool usniffer_images = (_Bool)0;
  
#line 582 
  bool usniffer_req = (_Bool)0;
  
#line 584 
  if (len <= 87UL) {
    {
      
#line 585 
      bool __cond = (_Bool)((int)*("uCode has invalid length: %zd\n" + 29UL) != 10);
      
#line 585 
      if ((int)__cond != 0) 
#line 585 
                            __compiletime_assert_585(); else ;
    }
    
#line 585 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"uCode has invalid length: %zd\n",len);
    
#line 586 
    __retres = -22;
    
#line 586 
    goto return_label;
  }
  else ;
  
#line 589 
  if (ucode->magic != 172775241U) {
    {
      
#line 590 
      bool __cond_0 = (_Bool)((int)*("invalid uCode magic: 0X%x\n" + 25UL) != 10);
      
#line 590 
      if ((int)__cond_0 != 0) 
#line 590 
                              __compiletime_assert_591(); else ;
    }
    
#line 590 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"invalid uCode magic: 0X%x\n",ucode->magic);
    
#line 592 
    __retres = -22;
    
#line 592 
    goto return_label;
  }
  else ;
  
#line 595 
  drv->fw.ucode_ver = ucode->ver;
  
#line 596 
  memcpy((void *)(& drv->fw.human_readable),(void const *)(& ucode->human_readable),64UL);
  
#line 598 
  build = ucode->build;
  
#line 600 
  if (build != 0U) {
    char *tmp;
    
#line 601 
    if (drv->fw_index == 100) 
#line 601 
                              tmp = (char *)" (EXP)"; else 
#line 601 
                                                           tmp = (char *)"";
    
#line 601 
    ;
    
#line 601 
    sprintf((char *)(& buildstr)," build %u%s",build,tmp);
  }
  else 
#line 605 
       buildstr[0] = (char)0;
  
#line 607 
  snprintf((char *)(& drv->fw.fw_version),32UL,"%u.%u.%u.%u%s",drv->fw.ucode_ver >> 24,(drv->fw.ucode_ver >> 16) & 255U,(drv->fw.ucode_ver >> 8) & 255U,drv->fw.ucode_ver & 255U,(char *)(& buildstr));
  
#line 616 
  data = (u8 const *)(& ucode->data);
  
#line 618 
  len += 18446744073709551528UL;
  
#line 620 
  goto ldv_51723;
  ldv_51722: 
#line 621 
  ;
  
#line 621 
  len += 18446744073709551608UL;
  
#line 622 
  tlv = (struct iwl_ucode_tlv *)data;
  
#line 624 
  tlv_len = tlv->length;
  
#line 625 
  tlv_type = (enum iwl_ucode_tlv_type)tlv->type;
  
#line 626 
  tlv_data = (u8 const *)(& tlv->data);
  
#line 628 
  if ((unsigned long)tlv_len > len) {
    {
      
#line 629 
      bool __cond_1 = (_Bool)((int)*("invalid TLV len: %zd/%u\n" + 23UL) != 10);
      
#line 629 
      if ((int)__cond_1 != 0) 
#line 629 
                              __compiletime_assert_630(); else ;
    }
    
#line 629 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"invalid TLV len: %zd/%u\n",len,tlv_len);
    
#line 631 
    __retres = -22;
    
#line 631 
    goto return_label;
  }
  else ;
  
#line 633 
  len -= (unsigned long)(tlv_len + 3U) & 4294967292UL;
  
#line 634 
  data += ((unsigned long)(tlv_len + 3U) & 4294967292UL) + 8UL;
  
#line 636 
  switch ((unsigned int)tlv_type) {
    int tmp_0;
    int tmp_1;
    int tmp_2;
    __u32 tmp_3;
    int tmp_4;
    case (unsigned int)1: 
#line 637 
    ;
    
#line 638 
    set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1,(void const *)tlv_data);
    
#line 640 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1,(unsigned long)tlv_len);
    
#line 642 
    set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1,0U);
    
#line 645 
    goto ldv_51619;
    case (unsigned int)2: 
#line 646 
    ;
    
#line 647 
    set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0,(void const *)tlv_data);
    
#line 649 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0,(unsigned long)tlv_len);
    
#line 651 
    set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0,8388608U);
    
#line 654 
    goto ldv_51619;
    case (unsigned int)3: 
#line 655 
    ;
    
#line 656 
    set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1,(void const *)tlv_data);
    
#line 658 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1,(unsigned long)tlv_len);
    
#line 660 
    set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1,0U);
    
#line 663 
    goto ldv_51619;
    case (unsigned int)4: 
#line 664 
    ;
    
#line 665 
    set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0,(void const *)tlv_data);
    
#line 667 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0,(unsigned long)tlv_len);
    
#line 669 
    set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0,8388608U);
    
#line 672 
    goto ldv_51619;
    case (unsigned int)5: 
#line 673 
    ;
    {
      
#line 674 
      bool __cond_2 = (_Bool)((int)*("Found unexpected BOOT ucode\n" + 27UL) != 10);
      
#line 674 
      if ((int)__cond_2 != 0) 
#line 674 
                              __compiletime_assert_674(); else ;
    }
    
#line 674 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Found unexpected BOOT ucode\n");
    
#line 675 
    goto ldv_51619;
    case (unsigned int)6: 
#line 676 
    ;
    
#line 677 
    if (tlv_len != 4U) 
#line 678 
                       goto invalid_tlv_len; else ;
    
#line 679 
    capa->max_probe_length = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 681 
    goto ldv_51619;
    case (unsigned int)7: 
#line 682 
    ;
    
#line 683 
    if (tlv_len != 0U) 
#line 684 
                       goto invalid_tlv_len; else ;
    
#line 685 
    capa->flags |= 1U;
    
#line 686 
    goto ldv_51619;
    case (unsigned int)18: 
#line 687 
    ;
    
#line 689 
    if (tlv_len <= 3U) 
#line 690 
                       goto invalid_tlv_len; else ;
    
#line 692 
    if ((tlv_len & 3U) != 0U) 
#line 693 
                              goto invalid_tlv_len; else ;
    
#line 701 
    capa->flags = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 702 
    goto ldv_51619;
    case (unsigned int)29: 
#line 703 
    ;
    
#line 704 
    if (tlv_len != 8U) 
#line 705 
                       goto invalid_tlv_len; else ;
    
#line 706 
    tmp_0 = iwl_set_ucode_api_flags(drv,tlv_data,capa);
    
#line 706 
    if (tmp_0 != 0) 
#line 707 
                    goto tlv_error; else ;
    
#line 708 
    goto ldv_51619;
    case (unsigned int)30: 
#line 709 
    ;
    
#line 710 
    if (tlv_len != 8U) 
#line 711 
                       goto invalid_tlv_len; else ;
    
#line 712 
    tmp_1 = iwl_set_ucode_capabilities(drv,tlv_data,capa);
    
#line 712 
    if (tmp_1 != 0) 
#line 713 
                    goto tlv_error; else ;
    
#line 714 
    goto ldv_51619;
    case (unsigned int)11: 
#line 715 
    ;
    
#line 716 
    if (tlv_len != 4U) 
#line 717 
                       goto invalid_tlv_len; else ;
    
#line 718 
    pieces->init_evtlog_ptr = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 720 
    goto ldv_51619;
    case (unsigned int)12: 
#line 721 
    ;
    
#line 722 
    if (tlv_len != 4U) 
#line 723 
                       goto invalid_tlv_len; else ;
    
#line 724 
    pieces->init_evtlog_size = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 726 
    goto ldv_51619;
    case (unsigned int)13: 
#line 727 
    ;
    
#line 728 
    if (tlv_len != 4U) 
#line 729 
                       goto invalid_tlv_len; else ;
    
#line 730 
    pieces->init_errlog_ptr = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 732 
    goto ldv_51619;
    case (unsigned int)8: 
#line 733 
    ;
    
#line 734 
    if (tlv_len != 4U) 
#line 735 
                       goto invalid_tlv_len; else ;
    
#line 736 
    pieces->inst_evtlog_ptr = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 738 
    goto ldv_51619;
    case (unsigned int)9: 
#line 739 
    ;
    
#line 740 
    if (tlv_len != 4U) 
#line 741 
                       goto invalid_tlv_len; else ;
    
#line 742 
    pieces->inst_evtlog_size = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 744 
    goto ldv_51619;
    case (unsigned int)10: 
#line 745 
    ;
    
#line 746 
    if (tlv_len != 4U) 
#line 747 
                       goto invalid_tlv_len; else ;
    
#line 748 
    pieces->inst_errlog_ptr = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 750 
    goto ldv_51619;
    case (unsigned int)14: 
#line 751 
    ;
    
#line 752 
    if (tlv_len != 0U) 
#line 753 
                       goto invalid_tlv_len; else ;
    
#line 754 
    drv->fw.enhance_sensitivity_table = (_Bool)1;
    
#line 755 
    goto ldv_51619;
    case (unsigned int)16: 
#line 756 
    ;
    
#line 757 
    set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_WOWLAN,1,(void const *)tlv_data);
    
#line 759 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_WOWLAN,1,(unsigned long)tlv_len);
    
#line 761 
    set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_WOWLAN,1,0U);
    
#line 764 
    goto ldv_51619;
    case (unsigned int)17: 
#line 765 
    ;
    
#line 766 
    set_sec_data(pieces,(enum iwl_ucode_type)IWL_UCODE_WOWLAN,0,(void const *)tlv_data);
    
#line 768 
    set_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_WOWLAN,0,(unsigned long)tlv_len);
    
#line 770 
    set_sec_offset(pieces,(enum iwl_ucode_type)IWL_UCODE_WOWLAN,0,8388608U);
    
#line 773 
    goto ldv_51619;
    case (unsigned int)15: 
#line 774 
    ;
    
#line 775 
    if (tlv_len != 4U) 
#line 776 
                       goto invalid_tlv_len; else ;
    
#line 777 
    capa->standard_phy_calibration_size = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 779 
    goto ldv_51619;
    case (unsigned int)19: 
#line 780 
    ;
    
#line 781 
    iwl_store_ucode_sec(pieces,(void const *)tlv_data,(enum iwl_ucode_type)IWL_UCODE_REGULAR,(int)tlv_len);
    
#line 783 
    drv->fw.mvm_fw = (_Bool)1;
    
#line 784 
    goto ldv_51619;
    case (unsigned int)20: 
#line 785 
    ;
    
#line 786 
    iwl_store_ucode_sec(pieces,(void const *)tlv_data,(enum iwl_ucode_type)IWL_UCODE_INIT,(int)tlv_len);
    
#line 788 
    drv->fw.mvm_fw = (_Bool)1;
    
#line 789 
    goto ldv_51619;
    case (unsigned int)21: 
#line 790 
    ;
    
#line 791 
    iwl_store_ucode_sec(pieces,(void const *)tlv_data,(enum iwl_ucode_type)IWL_UCODE_WOWLAN,(int)tlv_len);
    
#line 793 
    drv->fw.mvm_fw = (_Bool)1;
    
#line 794 
    goto ldv_51619;
    case (unsigned int)22: 
#line 795 
    ;
    
#line 796 
    if (tlv_len != 12U) 
#line 797 
                        goto invalid_tlv_len; else ;
    
#line 798 
    tmp_2 = iwl_set_default_calib(drv,tlv_data);
    
#line 798 
    if (tmp_2 != 0) 
#line 799 
                    goto tlv_error; else ;
    
#line 800 
    goto ldv_51619;
    case (unsigned int)23: 
#line 801 
    ;
    
#line 802 
    if (tlv_len != 4U) 
#line 803 
                       goto invalid_tlv_len; else ;
    
#line 804 
    drv->fw.phy_config = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 805 
    drv->fw.valid_tx_ant = (unsigned char)((unsigned int)((unsigned char)(drv->fw.phy_config >> 16)) & 15U);
    
#line 808 
    drv->fw.valid_rx_ant = (unsigned char)((unsigned int)((unsigned char)(drv->fw.phy_config >> 20)) & 15U);
    
#line 811 
    goto ldv_51619;
    case (unsigned int)24: 
#line 812 
    ;
    
#line 813 
    iwl_store_ucode_sec(pieces,(void const *)tlv_data,(enum iwl_ucode_type)IWL_UCODE_REGULAR,(int)tlv_len);
    
#line 815 
    drv->fw.mvm_fw = (_Bool)1;
    
#line 816 
    goto ldv_51619;
    case (unsigned int)25: 
#line 817 
    ;
    
#line 818 
    iwl_store_ucode_sec(pieces,(void const *)tlv_data,(enum iwl_ucode_type)IWL_UCODE_INIT,(int)tlv_len);
    
#line 820 
    drv->fw.mvm_fw = (_Bool)1;
    
#line 821 
    goto ldv_51619;
    case (unsigned int)26: 
#line 822 
    ;
    
#line 823 
    iwl_store_ucode_sec(pieces,(void const *)tlv_data,(enum iwl_ucode_type)IWL_UCODE_WOWLAN,(int)tlv_len);
    
#line 825 
    drv->fw.mvm_fw = (_Bool)1;
    
#line 826 
    goto ldv_51619;
    case (unsigned int)27: 
#line 827 
    ;
    
#line 828 
    if (tlv_len != 4U) 
#line 829 
                       goto invalid_tlv_len; else ;
    
#line 831 
    tmp_3 = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 830 
    num_of_cpus = (int)tmp_3;
    
#line 833 
    if (num_of_cpus == 2) {
      
#line 834 
      drv->fw.img[0].is_dual_cpus = (_Bool)1;
      
#line 836 
      drv->fw.img[1].is_dual_cpus = (_Bool)1;
      
#line 838 
      drv->fw.img[2].is_dual_cpus = (_Bool)1;
    }
    else 
      
#line 840 
      if ((unsigned int)num_of_cpus + 4294967295U > 1U) {
        {
          
#line 841 
          bool __cond_3 = (_Bool)((int)*("Driver support upto 2 CPUs\n" + 26UL) != 10);
          
#line 841 
          if ((int)__cond_3 != 0) 
#line 841 
                                  __compiletime_assert_841(); else ;
        }
        
#line 841 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Driver support upto 2 CPUs\n");
        
#line 842 
        __retres = -22;
        
#line 842 
        goto return_label;
      }
      else ;
    
#line 844 
    goto ldv_51619;
    case (unsigned int)28: 
#line 845 
    ;
    
#line 846 
    tmp_4 = iwl_store_cscheme(& drv->fw,tlv_data,tlv_len);
    
#line 846 
    if (tmp_4 != 0) 
#line 847 
                    goto invalid_tlv_len; else ;
    
#line 848 
    goto ldv_51619;
    case (unsigned int)31: 
#line 849 
    ;
    
#line 850 
    if (tlv_len != 4U) 
#line 851 
                       goto invalid_tlv_len; else ;
    
#line 852 
    capa->n_scan_channels = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 854 
    goto ldv_51619;
    case (unsigned int)36: 
#line 855 
    ;
    {
      u32 major;
      u32 minor;
      u8 local_comp;
      __le32 *tmp_5;
      __le32 *tmp_6;
      __u32 tmp_7;
      
#line 856 
      __le32 *ptr = (__le32 *)tlv_data;
      
#line 860 
      if (tlv_len != 12U) 
#line 861 
                          goto invalid_tlv_len; else ;
      
#line 863 
      tmp_5 = ptr;
      
#line 863 
      ptr += 1;
      
#line 863 
      ;
      
#line 863 
      major = __le32_to_cpup((__le32 const *)tmp_5);
      
#line 864 
      tmp_6 = ptr;
      
#line 864 
      ptr += 1;
      
#line 864 
      ;
      
#line 864 
      minor = __le32_to_cpup((__le32 const *)tmp_6);
      
#line 865 
      tmp_7 = __le32_to_cpup((__le32 const *)ptr);
      
#line 865 
      local_comp = (unsigned char)tmp_7;
      
#line 867 
      snprintf((char *)(& drv->fw.fw_version),32UL,"%u.%u.%u",major,minor,(int)local_comp);
      
#line 870 
      goto ldv_51619;
    }
    case (unsigned int)38: 
#line 872 
    ;
    {
      char const *tmp_8;
      
#line 873 
      struct iwl_fw_dbg_dest_tlv *dest = (struct iwl_fw_dbg_dest_tlv *)tlv_data;
      
#line 875 
      if (pieces->dbg_dest_tlv != (struct iwl_fw_dbg_dest_tlv *)0) {
        {
          
#line 876 
          bool __cond_4 = (_Bool)((int)*("dbg destination ignored, already exists\n" + 39UL) != 10);
          
#line 876 
          if ((int)__cond_4 != 0) 
#line 876 
                                  __compiletime_assert_877(); else ;
        }
        
#line 876 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"dbg destination ignored, already exists\n");
        
#line 878 
        goto ldv_51619;
      }
      else ;
      
#line 881 
      pieces->dbg_dest_tlv = dest;
      {
        
#line 882 
        bool __cond_5 = (_Bool)((int)*("Found debug destination: %s\n" + 27UL) != 10);
        
#line 882 
        if ((int)__cond_5 != 0) 
#line 882 
                                __compiletime_assert_883(); else ;
      }
      
#line 882 
      tmp_8 = get_fw_dbg_mode_string((int)dest->monitor_mode);
      
#line 882 
      ;
      
#line 882 
      __iwl_info(drv->dev,"Found debug destination: %s\n",tmp_8);
      
#line 885 
      drv->fw.dbg_dest_reg_num = (unsigned char)((unsigned int)((unsigned char)tlv_len) + 234U);
      
#line 888 
      drv->fw.dbg_dest_reg_num = (unsigned char)((unsigned int)drv->fw.dbg_dest_reg_num / 12U);
      
#line 891 
      goto ldv_51619;
    }
    case (unsigned int)39: 
#line 893 
    ;
    {
      
#line 894 
      struct iwl_fw_dbg_conf_tlv *conf = (struct iwl_fw_dbg_conf_tlv *)tlv_data;
      
#line 896 
      if (pieces->dbg_dest_tlv == (struct iwl_fw_dbg_dest_tlv *)0) {
        {
          
#line 897 
          bool __cond_6 = (_Bool)((int)*("Ignore dbg config %d - no destination configured\n" + 48UL) != 10);
          
#line 897 
          if ((int)__cond_6 != 0) 
#line 897 
                                  __compiletime_assert_899(); else ;
        }
        
#line 897 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Ignore dbg config %d - no destination configured\n",(int)conf->id);
        
#line 900 
        goto ldv_51619;
      }
      else ;
      
#line 903 
      if ((unsigned int)conf->id > 31U) {
        {
          
#line 904 
          bool __cond_7 = (_Bool)((int)*("Skip unknown configuration: %d\n" + 30UL) != 10);
          
#line 904 
          if ((int)__cond_7 != 0) 
#line 904 
                                  __compiletime_assert_906(); else ;
        }
        
#line 904 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Skip unknown configuration: %d\n",(int)conf->id);
        
#line 907 
        goto ldv_51619;
      }
      else ;
      
#line 910 
      if (pieces->dbg_conf_tlv[(int)conf->id] != (struct iwl_fw_dbg_conf_tlv *)0) {
        {
          
#line 911 
          bool __cond_8 = (_Bool)((int)*("Ignore duplicate dbg config %d\n" + 30UL) != 10);
          
#line 911 
          if ((int)__cond_8 != 0) 
#line 911 
                                  __compiletime_assert_913(); else ;
        }
        
#line 911 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Ignore duplicate dbg config %d\n",(int)conf->id);
        
#line 914 
        goto ldv_51619;
      }
      else ;
      
#line 917 
      if ((unsigned int)conf->usniffer != 0U) 
#line 918 
                                              usniffer_req = (_Bool)1; else ;
      {
        
#line 920 
        bool __cond_9 = (_Bool)((int)*("Found debug configuration: %d\n" + 29UL) != 10);
        
#line 920 
        if ((int)__cond_9 != 0) 
#line 920 
                                __compiletime_assert_921(); else ;
      }
      
#line 920 
      __iwl_info(drv->dev,"Found debug configuration: %d\n",(int)conf->id);
      
#line 923 
      pieces->dbg_conf_tlv[(int)conf->id] = conf;
      
#line 924 
      pieces->dbg_conf_tlv_len[(int)conf->id] = (unsigned long)tlv_len;
      
#line 925 
      goto ldv_51619;
    }
    case (unsigned int)40: 
#line 927 
    ;
    {
      
#line 928 
      struct iwl_fw_dbg_trigger_tlv *trigger = (struct iwl_fw_dbg_trigger_tlv *)tlv_data;
      
#line 930 
      u32 trigger_id = trigger->id;
      
#line 932 
      if (trigger_id > 11U) {
        {
          
#line 933 
          bool __cond_10 = (_Bool)((int)*("Skip unknown trigger: %u\n" + 24UL) != 10);
          
#line 933 
          if ((int)__cond_10 != 0) 
#line 933 
                                   __compiletime_assert_935(); else ;
        }
        
#line 933 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Skip unknown trigger: %u\n",trigger->id);
        
#line 936 
        goto ldv_51619;
      }
      else ;
      
#line 939 
      if (pieces->dbg_trigger_tlv[trigger_id] != (struct iwl_fw_dbg_trigger_tlv *)0) {
        {
          
#line 940 
          bool __cond_11 = (_Bool)((int)*("Ignore duplicate dbg trigger %u\n" + 31UL) != 10);
          
#line 940 
          if ((int)__cond_11 != 0) 
#line 940 
                                   __compiletime_assert_942(); else ;
        }
        
#line 940 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Ignore duplicate dbg trigger %u\n",trigger->id);
        
#line 943 
        goto ldv_51619;
      }
      else ;
      {
        
#line 946 
        bool __cond_12 = (_Bool)((int)*("Found debug trigger: %u\n" + 23UL) != 10);
        
#line 946 
        if ((int)__cond_12 != 0) 
#line 946 
                                 __compiletime_assert_946(); else ;
      }
      
#line 946 
      __iwl_info(drv->dev,"Found debug trigger: %u\n",trigger->id);
      
#line 948 
      pieces->dbg_trigger_tlv[trigger_id] = trigger;
      
#line 949 
      pieces->dbg_trigger_tlv_len[trigger_id] = (unsigned long)tlv_len;
      
#line 950 
      goto ldv_51619;
    }
    case (unsigned int)34: 
#line 952 
    ;
    
#line 953 
    usniffer_images = (_Bool)1;
    
#line 954 
    iwl_store_ucode_sec(pieces,(void const *)tlv_data,(enum iwl_ucode_type)IWL_UCODE_REGULAR_USNIFFER,(int)tlv_len);
    
#line 957 
    goto ldv_51619;
    case (unsigned int)35: 
#line 958 
    ;
    
#line 959 
    if (tlv_len != 4U) 
#line 960 
                       goto invalid_tlv_len; else ;
    
#line 961 
    drv->fw.sdio_adma_addr = __le32_to_cpup((__le32 const *)tlv_data);
    
#line 963 
    goto ldv_51619;
    default: 
#line 964 
    ;
    {
      
#line 965 
      bool __cond_13 = (_Bool)((int)*("unknown TLV: %d\n" + 15UL) != 10);
      
#line 965 
      if ((int)__cond_13 != 0) 
#line 965 
                               __compiletime_assert_965(); else ;
    }
    
#line 965 
    __iwl_dbg(drv->dev,1U,(_Bool)0,"iwl_parse_tlv_firmware","unknown TLV: %d\n",(unsigned int)tlv_type);
    
#line 966 
    goto ldv_51619;
  }
  ldv_51619: 
#line 968 
  ;
  ldv_51723: 
#line 969 
  ;
  
#line 620 
  if (len > 7UL) 
#line 622 
                 goto ldv_51722; else 
#line 625 
                                      goto ldv_51724;
  ldv_51724: 
#line 626 
  ;
  
#line 970 
  if ((int)usniffer_req != 0 && ! usniffer_images) {
    {
      
#line 971 
      bool __cond_14 = (_Bool)((int)*("user selected to work with usniffer but usniffer image isn\'t available in ucode package\n" + 87UL) != 10);
      
#line 971 
      if ((int)__cond_14 != 0) 
#line 971 
                               __compiletime_assert_972(); else ;
    }
    
#line 971 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"user selected to work with usniffer but usniffer image isn\'t available in ucode package\n");
    
#line 973 
    __retres = -22;
    
#line 973 
    goto return_label;
  }
  else ;
  
#line 976 
  if (len != 0UL) {
    bool tmp_9;
    {
      
#line 977 
      bool __cond_15 = (_Bool)((int)*("invalid TLV after parsing: %zd\n" + 30UL) != 10);
      
#line 977 
      if ((int)__cond_15 != 0) 
#line 977 
                               __compiletime_assert_977(); else ;
    }
    
#line 977 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"invalid TLV after parsing: %zd\n",len);
    
#line 978 
    tmp_9 = iwl_have_debug_level(65536U);
    
#line 978 
    if ((int)tmp_9 != 0) 
#line 978 
                         print_hex_dump("\001","iwl data: ",2,16,1,(void const *)data,len,(_Bool)1); else ;
    
#line 979 
    __retres = -22;
    
#line 979 
    goto return_label;
  }
  else ;
  
#line 982 
  __retres = 0;
  
#line 982 
  goto return_label;
  invalid_tlv_len: 
#line 984 
  ;
  {
    
#line 985 
    bool __cond_16 = (_Bool)((int)*("TLV %d has invalid size: %u\n" + 27UL) != 10);
    
#line 985 
    if ((int)__cond_16 != 0) 
#line 985 
                             __compiletime_assert_985(); else ;
  }
  
#line 985 
  __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"TLV %d has invalid size: %u\n",(unsigned int)tlv_type,tlv_len);
  tlv_error: 
#line 986 
  ;
  
#line 987 
  tmp_10 = iwl_have_debug_level(65536U);
  
#line 987 
  if ((int)tmp_10 != 0) 
#line 987 
                        print_hex_dump("\001","iwl data: ",2,16,1,(void const *)tlv_data,(unsigned long)tlv_len,(_Bool)1); else ;
  
#line 989 
  __retres = -22;
  return_label: 
#line 989 
                return __retres;
}


#line 992  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_alloc_ucode(struct iwl_drv *drv, struct iwl_firmware_pieces *pieces, enum iwl_ucode_type type)
{
  int __retres;
  int i;
  int tmp_0;
  struct fw_sec *tmp;
  
#line 997 
  i = 0;
  
#line 997 
  goto ldv_51744;
  ldv_51743: 
#line 998 
  ;
  
#line 1000 
  tmp = get_sec(pieces,type,i);
  
#line 1000 
  ;
  
#line 1000 
  ;
  
#line 1000 
  tmp_0 = iwl_alloc_fw_desc(drv,& drv->fw.img[(unsigned int)type].sec[i],tmp);
  
#line 1000 
  if (tmp_0 != 0) {
    
#line 1002 
    __retres = -12;
    
#line 1002 
    goto return_label;
  }
  else ;
  
#line 999 
  i += 1;
  ldv_51744: 
#line 1000 
  ;
  
#line 997 
  if (i <= 11) {
    size_t tmp_1;
    
#line 998 
    tmp_1 = get_sec_size(pieces,type,i);
    
#line 998 
    if (tmp_1 != 0UL) 
#line 1000 
                      goto ldv_51743; else 
#line 1003 
                                           goto ldv_51745;
  }
  else 
#line 1003 
       goto ldv_51745;
  ldv_51745: 
#line 1004 
  ;
  
#line 1003 
  __retres = 0;
  return_label: 
#line 1003 
                return __retres;
}


#line 1013 
void __compiletime_assert_1015(void);


#line 1016 
void __compiletime_assert_1017(void);


#line 1032 
void __compiletime_assert_1034(void);


#line 1040 
void __compiletime_assert_1042(void);


#line 1048 
void __compiletime_assert_1050(void);


#line 1006  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int validate_sec_sizes(struct iwl_drv *drv, struct iwl_firmware_pieces *pieces, struct iwl_cfg const *cfg)
{
  int __retres;
  size_t tmp;
  size_t tmp_0;
  size_t tmp_1;
  size_t tmp_2;
  size_t tmp_4;
  size_t tmp_6;
  size_t tmp_8;
  size_t tmp_10;
  {
    
#line 1010 
    bool __cond = (_Bool)((int)*("f/w package hdr runtime inst size = %Zd\n" + 39UL) != 10);
    
#line 1010 
    if ((int)__cond != 0) 
#line 1010 
                          __compiletime_assert_1012(); else ;
  }
  
#line 1010 
  tmp = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1);
  
#line 1010 
  ;
  
#line 1010 
  __iwl_dbg(drv->dev,1U,(_Bool)0,"validate_sec_sizes","f/w package hdr runtime inst size = %Zd\n",tmp);
  {
    
#line 1013 
    bool __cond_0 = (_Bool)((int)*("f/w package hdr runtime data size = %Zd\n" + 39UL) != 10);
    
#line 1013 
    if ((int)__cond_0 != 0) 
#line 1013 
                            __compiletime_assert_1015(); else ;
  }
  
#line 1013 
  tmp_0 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0);
  
#line 1013 
  ;
  
#line 1013 
  __iwl_dbg(drv->dev,1U,(_Bool)0,"validate_sec_sizes","f/w package hdr runtime data size = %Zd\n",tmp_0);
  {
    
#line 1016 
    bool __cond_1 = (_Bool)((int)*("f/w package hdr init inst size = %Zd\n" + 36UL) != 10);
    
#line 1016 
    if ((int)__cond_1 != 0) 
#line 1016 
                            __compiletime_assert_1017(); else ;
  }
  
#line 1016 
  tmp_1 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1);
  
#line 1016 
  ;
  
#line 1016 
  __iwl_dbg(drv->dev,1U,(_Bool)0,"validate_sec_sizes","f/w package hdr init inst size = %Zd\n",tmp_1);
  {
    
#line 1018 
    bool __cond_2 = (_Bool)((int)*("f/w package hdr init data size = %Zd\n" + 36UL) != 10);
    
#line 1018 
    if ((int)__cond_2 != 0) 
#line 1018 
                            __compiletime_assert_1019(); else ;
  }
  
#line 1018 
  tmp_2 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0);
  
#line 1018 
  ;
  
#line 1018 
  __iwl_dbg(drv->dev,1U,(_Bool)0,"validate_sec_sizes","f/w package hdr init data size = %Zd\n",tmp_2);
  
#line 1022 
  tmp_4 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1);
  
#line 1022 
  ;
  
#line 1022 
  if (tmp_4 > (unsigned long)cfg->max_inst_size) {
    size_t tmp_3;
    {
      
#line 1024 
      bool __cond_3 = (_Bool)((int)*("uCode instr len %Zd too large to fit in\n" + 39UL) != 10);
      
#line 1024 
      if ((int)__cond_3 != 0) 
#line 1024 
                              __compiletime_assert_1026(); else ;
    }
    
#line 1024 
    tmp_3 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,1);
    
#line 1024 
    ;
    
#line 1024 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"uCode instr len %Zd too large to fit in\n",tmp_3);
    
#line 1027 
    __retres = -1;
    
#line 1027 
    goto return_label;
  }
  else ;
  
#line 1030 
  tmp_6 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0);
  
#line 1030 
  ;
  
#line 1030 
  if (tmp_6 > (unsigned long)cfg->max_data_size) {
    size_t tmp_5;
    {
      
#line 1032 
      bool __cond_4 = (_Bool)((int)*("uCode data len %Zd too large to fit in\n" + 38UL) != 10);
      
#line 1032 
      if ((int)__cond_4 != 0) 
#line 1032 
                              __compiletime_assert_1034(); else ;
    }
    
#line 1032 
    tmp_5 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0);
    
#line 1032 
    ;
    
#line 1032 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"uCode data len %Zd too large to fit in\n",tmp_5);
    
#line 1035 
    __retres = -1;
    
#line 1035 
    goto return_label;
  }
  else ;
  
#line 1038 
  tmp_8 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1);
  
#line 1038 
  ;
  
#line 1038 
  if (tmp_8 > (unsigned long)cfg->max_inst_size) {
    size_t tmp_7;
    {
      
#line 1040 
      bool __cond_5 = (_Bool)((int)*("uCode init instr len %Zd too large to fit in\n" + 44UL) != 10);
      
#line 1040 
      if ((int)__cond_5 != 0) 
#line 1040 
                              __compiletime_assert_1042(); else ;
    }
    
#line 1040 
    tmp_7 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,1);
    
#line 1040 
    ;
    
#line 1040 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"uCode init instr len %Zd too large to fit in\n",tmp_7);
    
#line 1043 
    __retres = -1;
    
#line 1043 
    goto return_label;
  }
  else ;
  
#line 1046 
  tmp_10 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_INIT,0);
  
#line 1046 
  ;
  
#line 1046 
  if (tmp_10 > (unsigned long)cfg->max_data_size) {
    size_t tmp_9;
    {
      
#line 1048 
      bool __cond_6 = (_Bool)((int)*("uCode init data len %Zd too large to fit in\n" + 43UL) != 10);
      
#line 1048 
      if ((int)__cond_6 != 0) 
#line 1048 
                              __compiletime_assert_1050(); else ;
    }
    
#line 1048 
    tmp_9 = get_sec_size(pieces,(enum iwl_ucode_type)IWL_UCODE_REGULAR,0);
    
#line 1048 
    ;
    
#line 1048 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"uCode init data len %Zd too large to fit in\n",tmp_9);
    
#line 1051 
    __retres = -1;
    
#line 1051 
    goto return_label;
  }
  else ;
  
#line 1053 
  __retres = 0;
  return_label: 
#line 1053 
                return __retres;
}


#line 1067 
void __compiletime_assert_1068(void);


#line 1057  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static struct iwl_op_mode *_iwl_op_mode_start(struct iwl_drv *drv, struct iwlwifi_opmode_table *op)
{
  struct iwl_op_mode *__retres;
  
#line 1059 
  struct iwl_op_mode_ops const *ops = op->ops;
  
#line 1060 
  struct dentry *dbgfs_dir = (struct dentry *)0;
  
#line 1061 
  struct iwl_op_mode *op_mode = (struct iwl_op_mode *)0;
  
#line 1064 
  drv->dbgfs_op_mode = debugfs_create_dir(op->name,drv->dbgfs_drv);
  
#line 1066 
  if (drv->dbgfs_op_mode == (struct dentry *)0) {
    {
      
#line 1067 
      bool __cond = (_Bool)((int)*("failed to create opmode debugfs directory\n" + 41UL) != 10);
      
#line 1067 
      if ((int)__cond != 0) 
#line 1067 
                            __compiletime_assert_1068(); else ;
    }
    
#line 1067 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"failed to create opmode debugfs directory\n");
    
#line 1069 
    __retres = op_mode;
    
#line 1069 
    goto return_label;
  }
  else ;
  
#line 1071 
  dbgfs_dir = drv->dbgfs_op_mode;
  
#line 1074 
  op_mode = (*(ops->start))(drv->trans,drv->cfg,(struct iwl_fw const *)(& drv->fw),dbgfs_dir);
  
#line 1077 
  if (op_mode == (struct iwl_op_mode *)0) {
    
#line 1078 
    debugfs_remove_recursive(drv->dbgfs_op_mode);
    
#line 1079 
    drv->dbgfs_op_mode = (struct dentry *)0;
  }
  else ;
  
#line 1083 
  __retres = op_mode;
  return_label: 
#line 1083 
                return __retres;
}


#line 1086  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void _iwl_op_mode_stop(struct iwl_drv *drv)
{
  
#line 1089 
  if (drv->op_mode != (struct iwl_op_mode *)0) {
    
#line 1090 
    iwl_op_mode_stop(drv->op_mode);
    
#line 1091 
    drv->op_mode = (struct iwl_op_mode *)0;
    
#line 1094 
    debugfs_remove_recursive(drv->dbgfs_op_mode);
    
#line 1095 
    drv->dbgfs_op_mode = (struct dentry *)0;
  }
  else ;
  
#line 1097 
  return;
}


#line 1136 
void __compiletime_assert_1138(void);


#line 1142 
void __compiletime_assert_1143(void);


#line 1147 
void __compiletime_assert_1147(void);


#line 1176 
void __compiletime_assert_1179(void);


#line 1185 
void __compiletime_assert_1187(void);


#line 1189 
void __compiletime_assert_1191(void);


#line 1192 
void __compiletime_assert_1193(void);


#line 1321 
void __compiletime_assert_1322(void);


#line 1355 
void __compiletime_assert_1357(void);


#line 1372 
void __compiletime_assert_1372(void);


#line 1106  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void iwl_req_fw_callback(struct firmware const *ucode_raw, void *context)
{
  struct iwl_ucode_header *ucode;
  struct iwlwifi_opmode_table *op;
  int err;
  struct iwl_firmware_pieces *pieces;
  size_t trigger_tlv_sz[12U];
  u32 api_ver;
  int i;
  bool tmp_0;
  int tmp_2;
  int tmp_7;
  
#line 1108 
  struct iwl_drv *drv = (struct iwl_drv *)context;
  
#line 1109 
  struct iwl_fw *fw = & drv->fw;
  
#line 1114 
  unsigned int const api_max = (drv->cfg)->ucode_api_max;
  
#line 1115 
  unsigned int api_ok = (drv->cfg)->ucode_api_ok;
  
#line 1116 
  unsigned int const api_min = (drv->cfg)->ucode_api_min;
  
#line 1120 
  bool load_module = (_Bool)0;
  
#line 1122 
  fw->ucode_capa.max_probe_length = 200U;
  
#line 1123 
  fw->ucode_capa.standard_phy_calibration_size = 18U;
  
#line 1125 
  fw->ucode_capa.n_scan_channels = 40U;
  
#line 1127 
  if (api_ok == 0U) 
#line 1128 
                    api_ok = api_max; else ;
  
#line 1130 
  pieces = (struct iwl_firmware_pieces *)kzalloc_3(1920UL,208U);
  
#line 1131 
  if (pieces == (struct iwl_firmware_pieces *)0) 
#line 1132 
                                                 goto return_label; else ;
  
#line 1134 
  if (ucode_raw == (struct firmware const *)0) {
    
#line 1135 
    if ((unsigned int)drv->fw_index <= api_ok) {
      {
        
#line 1136 
        bool __cond = (_Bool)((int)*("request for firmware file \'%s\' failed.\n" + 38UL) != 10);
        
#line 1136 
        if ((int)__cond != 0) 
#line 1136 
                              __compiletime_assert_1138(); else ;
      }
      
#line 1136 
      __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"request for firmware file \'%s\' failed.\n",(char *)(& drv->firmware_name));
    }
    else ;
    
#line 1139 
    goto try_again;
  }
  else ;
  {
    
#line 1142 
    bool __cond_0 = (_Bool)((int)*("Loaded firmware file \'%s\' (%zd bytes).\n" + 38UL) != 10);
    
#line 1142 
    if ((int)__cond_0 != 0) 
#line 1142 
                            __compiletime_assert_1143(); else ;
  }
  
#line 1142 
  __iwl_dbg(drv->dev,1U,(_Bool)0,"iwl_req_fw_callback","Loaded firmware file \'%s\' (%zd bytes).\n",(char *)(& drv->firmware_name),ucode_raw->size);
  
#line 1146 
  if (ucode_raw->size <= 3UL) {
    {
      
#line 1147 
      bool __cond_1 = (_Bool)((int)*("File size way too small!\n" + 24UL) != 10);
      
#line 1147 
      if ((int)__cond_1 != 0) 
#line 1147 
                              __compiletime_assert_1147(); else ;
    }
    
#line 1147 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"File size way too small!\n");
    
#line 1148 
    goto try_again;
  }
  else ;
  
#line 1152 
  ucode = (struct iwl_ucode_header *)ucode_raw->data;
  
#line 1154 
  if (ucode->ver != 0U) 
#line 1155 
                        err = iwl_parse_v1_v2_firmware(drv,ucode_raw,pieces); else 
                                                                    
#line 1157 
                                                                    err = iwl_parse_tlv_firmware(drv,ucode_raw,pieces,& fw->ucode_capa);
  
#line 1160 
  if (err != 0) 
#line 1161 
                goto try_again; else ;
  
#line 1163 
  tmp_0 = fw_has_api((struct iwl_ucode_capabilities const *)(& drv->fw.ucode_capa),20U);
  
#line 1163 
  if ((int)tmp_0 != 0) 
#line 1164 
                       api_ver = drv->fw.ucode_ver; else 
#line 1166 
                                                         api_ver = (drv->fw.ucode_ver >> 8) & 255U;
  
#line 1174 
  if (drv->fw_index != 100) {
    
#line 1175 
    if (api_ver < api_min || api_ver > api_max) {
      {
        
#line 1176 
        bool __cond_2 = (_Bool)((int)*("Driver unable to support your firmware API. " + 81UL) != 10);
        
#line 1176 
        if ((int)__cond_2 != 0) 
#line 1176 
                                __compiletime_assert_1179(); else ;
      }
      
#line 1176 
      __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Driver unable to support your firmware API. ",api_max,api_ver);
      
#line 1180 
      goto try_again;
    }
    else ;
    
#line 1183 
    if (api_ver < api_ok) {
      
#line 1184 
      if (api_ok != api_max) {
        {
          
#line 1185 
          bool __cond_3 = (_Bool)((int)*("Firmware has old API version, " + 64UL) != 10);
          
#line 1185 
          if ((int)__cond_3 != 0) 
#line 1185 
                                  __compiletime_assert_1187(); else ;
        }
        
#line 1185 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Firmware has old API version, ",api_ok,api_max,api_ver);
      }
      else {
        {
          
#line 1189 
          bool __cond_4 = (_Bool)((int)*("Firmware has old API version, " + 52UL) != 10);
          
#line 1189 
          if ((int)__cond_4 != 0) 
#line 1189 
                                  __compiletime_assert_1191(); else ;
        }
        
#line 1189 
        __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"Firmware has old API version, ",api_max,api_ver);
      }
      {
        
#line 1192 
        bool __cond_5 = (_Bool)((int)*("New firmware can be obtained from " + 69UL) != 10);
        
#line 1192 
        if ((int)__cond_5 != 0) 
#line 1192 
                                __compiletime_assert_1193(); else ;
      }
      
#line 1192 
      __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"New firmware can be obtained from ");
    }
    else ;
  }
  else ;
  
#line 1201 
  if (! fw->mvm_fw) {
    int tmp_1;
    
#line 1201 
    tmp_1 = validate_sec_sizes(drv,pieces,drv->cfg);
    
#line 1201 
    if (tmp_1 != 0) 
#line 1202 
                    goto try_again; else ;
  }
  else ;
  
#line 1209 
  i = 0;
  
#line 1209 
  goto ldv_51847;
  ldv_51846: 
#line 1210 
  ;
  
#line 1210 
  tmp_2 = iwl_alloc_ucode(drv,pieces,(enum iwl_ucode_type)i);
  
#line 1210 
  if (tmp_2 != 0) 
#line 1211 
                  goto out_free_fw; else ;
  
#line 1209 
  i += 1;
  ldv_51847: 
#line 1210 
  ;
  
#line 1209 
  if (i <= 3) 
#line 1211 
              goto ldv_51846; else 
#line 1214 
                                   goto ldv_51848;
  ldv_51848: 
#line 1215 
  ;
  
#line 1213 
  if (pieces->dbg_dest_tlv != (struct iwl_fw_dbg_dest_tlv *)0) {
    
#line 1215 
    drv->fw.dbg_dest_tlv = (struct iwl_fw_dbg_dest_tlv *)kmemdup((void const *)pieces->dbg_dest_tlv,(unsigned long)drv->fw.dbg_dest_reg_num * 12UL + 22UL,208U);
    
#line 1220 
    if (drv->fw.dbg_dest_tlv == (struct iwl_fw_dbg_dest_tlv *)0) 
#line 1221 
                                                                 goto out_free_fw; else ;
  }
  else ;
  
#line 1224 
  i = 0;
  
#line 1224 
  goto ldv_51853;
  ldv_51852: 
#line 1225 
  ;
  
#line 1225 
  if (pieces->dbg_conf_tlv[i] != (struct iwl_fw_dbg_conf_tlv *)0) {
    
#line 1226 
    drv->fw.dbg_conf_tlv_len[i] = pieces->dbg_conf_tlv_len[i];
    
#line 1229 
    drv->fw.dbg_conf_tlv[i] = (struct iwl_fw_dbg_conf_tlv *)kmemdup((void const *)pieces->dbg_conf_tlv[i],drv->fw.dbg_conf_tlv_len[i],208U);
    
#line 1232 
    if (drv->fw.dbg_conf_tlv[i] == (struct iwl_fw_dbg_conf_tlv *)0) 
#line 1233 
                                                                    goto out_free_fw; else ;
  }
  else ;
  
#line 1224 
  i += 1;
  ldv_51853: 
#line 1225 
  ;
  
#line 1224 
  if ((unsigned int)i <= 31U) 
#line 1226 
                              goto ldv_51852; else 
#line 1229 
                                                   goto ldv_51854;
  ldv_51854: 
#line 1230 
  ;
  
#line 1237 
  memset((void *)(& trigger_tlv_sz),255,96UL);
  
#line 1239 
  trigger_tlv_sz[3] = 32UL;
  
#line 1241 
  trigger_tlv_sz[4] = 0UL;
  
#line 1242 
  trigger_tlv_sz[5] = 32UL;
  
#line 1244 
  trigger_tlv_sz[6] = 16UL;
  
#line 1246 
  trigger_tlv_sz[7] = 16UL;
  
#line 1248 
  trigger_tlv_sz[8] = 4UL;
  
#line 1250 
  trigger_tlv_sz[9] = 48UL;
  
#line 1252 
  trigger_tlv_sz[10] = 192UL;
  
#line 1254 
  trigger_tlv_sz[11] = 14UL;
  
#line 1257 
  i = 0;
  
#line 1257 
  goto ldv_51861;
  ldv_51860: 
#line 1258 
  ;
  
#line 1258 
  if (pieces->dbg_trigger_tlv[i] != (struct iwl_fw_dbg_trigger_tlv *)0) {
    int tmp_5;
    {
      
#line 1266 
      int __ret_warn_on = pieces->dbg_trigger_tlv_len[i] < trigger_tlv_sz[i] + 28UL;
      
#line 1266 
      if ((long)(__ret_warn_on != 0) != 0L) 
#line 1266 
                                            warn_slowpath_null("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c",1268); else ;
      
#line 1266 
      tmp_5 = (long)(__ret_warn_on != 0);
    }
    
#line 1266 
    if ((long)tmp_5 != 0L) 
#line 1269 
                           goto out_free_fw; else ;
    
#line 1270 
    drv->fw.dbg_trigger_tlv_len[i] = pieces->dbg_trigger_tlv_len[i];
    
#line 1273 
    drv->fw.dbg_trigger_tlv[i] = (struct iwl_fw_dbg_trigger_tlv *)kmemdup((void const *)pieces->dbg_trigger_tlv[i],drv->fw.dbg_trigger_tlv_len[i],208U);
    
#line 1276 
    if (drv->fw.dbg_trigger_tlv[i] == (struct iwl_fw_dbg_trigger_tlv *)0) 
      
#line 1277 
      goto out_free_fw; else ;
  }
  else ;
  
#line 1257 
  i += 1;
  ldv_51861: 
#line 1258 
  ;
  
#line 1257 
  if ((unsigned int)i <= 11U) 
#line 1259 
                              goto ldv_51860; else 
#line 1262 
                                                   goto ldv_51862;
  ldv_51862: 
#line 1263 
  ;
  
#line 1288 
  fw->init_evtlog_ptr = pieces->init_evtlog_ptr;
  
#line 1289 
  if (pieces->init_evtlog_size != 0U) 
#line 1290 
                                      fw->init_evtlog_size = (pieces->init_evtlog_size + 4294967280U) / 12U; else 
                                                                    
#line 1292 
                                                                    fw->init_evtlog_size = ((drv->cfg)->base_params)->max_event_log_size;
  
#line 1294 
  fw->init_errlog_ptr = pieces->init_errlog_ptr;
  
#line 1295 
  fw->inst_evtlog_ptr = pieces->inst_evtlog_ptr;
  
#line 1296 
  if (pieces->inst_evtlog_size != 0U) 
#line 1297 
                                      fw->inst_evtlog_size = (pieces->inst_evtlog_size + 4294967280U) / 12U; else 
                                                                    
#line 1299 
                                                                    fw->inst_evtlog_size = ((drv->cfg)->base_params)->max_event_log_size;
  
#line 1301 
  fw->inst_errlog_ptr = pieces->inst_errlog_ptr;
  
#line 1307 
  if (fw->ucode_capa.standard_phy_calibration_size > 253U) 
#line 1309 
                                                           fw->ucode_capa.standard_phy_calibration_size = 19U; else ;
  
#line 1313 
  release_firmware(ucode_raw);
  
#line 1315 
  ldv_mutex_lock_73(& iwlwifi_opmode_table_mtx);
  
#line 1316 
  if ((int)fw->mvm_fw != 0) 
#line 1317 
                            op = & iwlwifi_opmode_table[1]; else 
#line 1319 
                                                                 op = &(iwlwifi_opmode_table[0]);
  {
    
#line 1321 
    bool __cond_6 = (_Bool)((int)*("loaded firmware version %s op_mode %s\n" + 37UL) != 10);
    
#line 1321 
    if ((int)__cond_6 != 0) 
#line 1321 
                            __compiletime_assert_1322(); else ;
  }
  
#line 1321 
  __iwl_info(drv->dev,"loaded firmware version %s op_mode %s\n",(char *)(& drv->fw.fw_version),op->name);
  
#line 1325 
  list_add_tail(& drv->list,& op->drv);
  
#line 1327 
  if (op->ops != (struct iwl_op_mode_ops const *)0) {
    
#line 1328 
    drv->op_mode = _iwl_op_mode_start(drv,op);
    
#line 1330 
    if (drv->op_mode == (struct iwl_op_mode *)0) {
      
#line 1331 
      ldv_mutex_unlock_74(& iwlwifi_opmode_table_mtx);
      
#line 1332 
      goto out_unbind;
    }
    else ;
  }
  else 
#line 1335 
       load_module = (_Bool)1;
  
#line 1337 
  ldv_mutex_unlock_75(& iwlwifi_opmode_table_mtx);
  
#line 1344 
  complete(& drv->request_firmware_complete);
  
#line 1351 
  if ((int)load_module != 0) {
    
#line 1352 
    err = __request_module((_Bool)1,"%s",op->name);
    
#line 1354 
    if (err != 0) {
      {
        
#line 1355 
        bool __cond_7 = (_Bool)((int)*("failed to load module %s (error %d), is dynamic loading enabled?\n" + 64UL) != 10);
        
#line 1355 
        if ((int)__cond_7 != 0) 
#line 1355 
                                __compiletime_assert_1357(); else ;
      }
      
#line 1355 
      __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"failed to load module %s (error %d), is dynamic loading enabled?\n",op->name,err);
    }
    else ;
  }
  else ;
  
#line 1360 
  kfree((void const *)pieces);
  
#line 1361 
  goto return_label;
  try_again: 
#line 1363 
  ;
  
#line 1365 
  release_firmware(ucode_raw);
  
#line 1366 
  tmp_7 = iwl_request_firmware(drv,(_Bool)0);
  
#line 1366 
  if (tmp_7 != 0) 
#line 1367 
                  goto out_unbind; else ;
  
#line 1368 
  kfree((void const *)pieces);
  
#line 1369 
  goto return_label;
  out_free_fw: 
#line 1371 
  ;
  {
    
#line 1372 
    bool __cond_8 = (_Bool)((int)*("failed to allocate pci memory\n" + 29UL) != 10);
    
#line 1372 
    if ((int)__cond_8 != 0) 
#line 1372 
                            __compiletime_assert_1372(); else ;
  }
  
#line 1372 
  __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"failed to allocate pci memory\n");
  
#line 1373 
  iwl_dealloc_ucode(drv);
  
#line 1374 
  release_firmware(ucode_raw);
  out_unbind: 
#line 1375 
  ;
  
#line 1376 
  kfree((void const *)pieces);
  
#line 1377 
  complete(& drv->request_firmware_complete);
  
#line 1378 
  device_release_driver((drv->trans)->dev);
  return_label: 
#line 1379 
                return;
}


#line 1406 
void __compiletime_assert_1406(void);


#line 1415 
void __compiletime_assert_1415(void);


#line 1423 
void __compiletime_assert_1423(void);


#line 1381  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct iwl_drv *iwl_drv_start(struct iwl_trans *trans, struct iwl_cfg const *cfg)
{
  struct iwl_drv *__retres;
  struct iwl_drv *drv;
  int ret;
  char const *tmp_0;
  struct iwl_drv *tmp_1;
  
#line 1387 
  drv = (struct iwl_drv *)kzalloc_3(1952UL,208U);
  
#line 1388 
  if (drv == (struct iwl_drv *)0) {
    
#line 1389 
    ret = -12;
    
#line 1390 
    goto err;
  }
  else ;
  
#line 1393 
  drv->trans = trans;
  
#line 1394 
  drv->dev = trans->dev;
  
#line 1395 
  drv->cfg = cfg;
  
#line 1397 
  init_completion(& drv->request_firmware_complete);
  
#line 1398 
  INIT_LIST_HEAD(& drv->list);
  
#line 1402 
  ;
  
#line 1402 
  tmp_0 = dev_name((struct device const *)trans->dev);
  
#line 1402 
  drv->dbgfs_drv = debugfs_create_dir(tmp_0,iwl_dbgfs_root);
  
#line 1405 
  if (drv->dbgfs_drv == (struct dentry *)0) {
    {
      
#line 1406 
      bool __cond = (_Bool)((int)*("failed to create debugfs directory\n" + 34UL) != 10);
      
#line 1406 
      if ((int)__cond != 0) 
#line 1406 
                            __compiletime_assert_1406(); else ;
    }
    
#line 1406 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"failed to create debugfs directory\n");
    
#line 1407 
    ret = -12;
    
#line 1408 
    goto err_free_drv;
  }
  else ;
  
#line 1412 
  (drv->trans)->dbgfs_dir = debugfs_create_dir("trans",drv->dbgfs_drv);
  
#line 1414 
  if ((drv->trans)->dbgfs_dir == (struct dentry *)0) {
    {
      
#line 1415 
      bool __cond_0 = (_Bool)((int)*("failed to create transport debugfs directory\n" + 44UL) != 10);
      
#line 1415 
      if ((int)__cond_0 != 0) 
#line 1415 
                              __compiletime_assert_1415(); else ;
    }
    
#line 1415 
    __iwl_err(drv->dev,(_Bool)0,(_Bool)0,"failed to create transport debugfs directory\n");
    
#line 1416 
    ret = -12;
    
#line 1417 
    goto err_free_dbgfs;
  }
  else ;
  
#line 1421 
  ret = iwl_request_firmware(drv,(_Bool)1);
  
#line 1422 
  if (ret != 0) {
    {
      
#line 1423 
      bool __cond_1 = (_Bool)((int)*("Couldn\'t request the fw\n" + 23UL) != 10);
      
#line 1423 
      if ((int)__cond_1 != 0) 
#line 1423 
                              __compiletime_assert_1423(); else ;
    }
    
#line 1423 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Couldn\'t request the fw\n");
    
#line 1424 
    goto err_fw;
  }
  else ;
  
#line 1427 
  __retres = drv;
  
#line 1427 
  goto return_label;
  err_fw: 
#line 1429 
  ;
  err_free_dbgfs: 
#line 1431 
  ;
  
#line 1432 
  debugfs_remove_recursive(drv->dbgfs_drv);
  err_free_drv: 
#line 1433 
  ;
  
#line 1435 
  kfree((void const *)drv);
  err: 
#line 1436 
  ;
  
#line 1437 
  tmp_1 = (struct iwl_drv *)ERR_PTR_1((long)ret);
  
#line 1437 
  __retres = tmp_1;
  return_label: 
#line 1437 
                return __retres;
}


#line 1440  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
void iwl_drv_stop(struct iwl_drv *drv)
{
  int tmp;
  
#line 1442 
  wait_for_completion(& drv->request_firmware_complete);
  
#line 1444 
  _iwl_op_mode_stop(drv);
  
#line 1446 
  iwl_dealloc_ucode(drv);
  
#line 1448 
  ldv_mutex_lock_76(& iwlwifi_opmode_table_mtx);
  
#line 1454 
  tmp = list_empty((struct list_head const *)(& drv->list));
  
#line 1454 
  if (tmp == 0) 
#line 1455 
                list_del(& drv->list); else ;
  
#line 1456 
  ldv_mutex_unlock_77(& iwlwifi_opmode_table_mtx);
  
#line 1459 
  debugfs_remove_recursive(drv->dbgfs_drv);
  
#line 1462 
  kfree((void const *)drv);
  
#line 1463 
  return;
}


#line 1467  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct iwl_mod_params iwlwifi_mod_params = {.sw_crypto = 0, .disable_11n = 0U, .amsdu_size_8K = 0, .restart_fw = (_Bool)1, .bt_coex_active = (_Bool)1, .led_mode = 0, .power_save = (_Bool)0, .power_level = 0, .debug_level = 0U, .ant_coupling = 0, .nvm_file = (char *)0, .uapsd_disable = (_Bool)0, .d0i3_disable = (_Bool)1, .lar_disable = (_Bool)0, .fw_monitor = (_Bool)0};

#line 1477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static char const __kstrtab_iwlwifi_mod_params[19U] = {(char)'i', (char)'w', (char)'l', (char)'w', (char)'i', (char)'f', (char)'i', (char)'_', (char)'m', (char)'o', (char)'d', (char)'_', (char)'p', (char)'a', (char)'r', (char)'a', (char)'m', (char)'s', (char)'\000'};

#line 1477 
struct kernel_symbol const __ksymtab_iwlwifi_mod_params;


#line 1477  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct kernel_symbol const __ksymtab_iwlwifi_mod_params = {.value = (unsigned long)(& iwlwifi_mod_params), .name = (char const *)(& __kstrtab_iwlwifi_mod_params)};

#line 1479  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
int iwl_opmode_register(char const *name, struct iwl_op_mode_ops const *ops)
{
  int __retres;
  int i;
  struct iwl_drv *drv;
  struct iwlwifi_opmode_table *op;
  int tmp;
  struct iwl_drv *tmp_0;
  struct iwl_drv *tmp_1;
  
#line 1485 
  ldv_mutex_lock_78(& iwlwifi_opmode_table_mtx);
  
#line 1486 
  i = 0;
  
#line 1486 
  goto ldv_51927;
  ldv_51926: 
#line 1487 
  ;
  
#line 1487 
  op = & iwlwifi_opmode_table[i];
  
#line 1488 
  tmp = strcmp(op->name,name);
  
#line 1488 
  if (tmp != 0) 
#line 1489 
                goto ldv_51918; else ;
  
#line 1490 
  op->ops = ops;
  {
    
#line 1492 
    struct list_head const *__mptr = (struct list_head const *)op->drv.next;
    
#line 1492 
    tmp_0 = (struct iwl_drv *)__mptr;
  }
  
#line 1492 
  drv = tmp_0;
  
#line 1492 
  goto ldv_51924;
  ldv_51923: 
#line 1493 
  ;
  
#line 1493 
  drv->op_mode = _iwl_op_mode_start(drv,op);
  {
    
#line 1492 
    struct list_head const *__mptr_0 = (struct list_head const *)drv->list.next;
    
#line 1492 
    tmp_1 = (struct iwl_drv *)__mptr_0;
  }
  
#line 1492 
  drv = tmp_1;
  ldv_51924: 
#line 1494 
  ;
  
#line 1492 
  if (& drv->list != & op->drv) 
#line 1494 
                                goto ldv_51923; else 
#line 1497 
                                                     goto ldv_51925;
  ldv_51925: 
#line 1498 
  ;
  
#line 1495 
  ldv_mutex_unlock_79(& iwlwifi_opmode_table_mtx);
  
#line 1496 
  __retres = 0;
  
#line 1496 
  goto return_label;
  ldv_51918: 
#line 1497 
  ;
  
#line 1486 
  i += 1;
  ldv_51927: 
#line 1487 
  ;
  
#line 1486 
  if ((unsigned int)i <= 1U) 
#line 1488 
                             goto ldv_51926; else 
#line 1491 
                                                  goto ldv_51928;
  ldv_51928: 
#line 1492 
  ;
  
#line 1498 
  ldv_mutex_unlock_80(& iwlwifi_opmode_table_mtx);
  
#line 1499 
  __retres = -5;
  return_label: 
#line 1499 
                return __retres;
}


#line 1501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static char const __kstrtab_iwl_opmode_register[20U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'o', (char)'p', (char)'m', (char)'o', (char)'d', (char)'e', (char)'_', (char)'r', (char)'e', (char)'g', (char)'i', (char)'s', (char)'t', (char)'e', (char)'r', (char)'\000'};

#line 1501 
struct kernel_symbol const __ksymtab_iwl_opmode_register;


#line 1501  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct kernel_symbol const __ksymtab_iwl_opmode_register = {.value = (unsigned long)(& iwl_opmode_register), .name = (char const *)(& __kstrtab_iwl_opmode_register)};

#line 1503  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
void iwl_opmode_deregister(char const *name)
{
  int i;
  struct iwl_drv *drv;
  int tmp;
  struct iwl_drv *tmp_0;
  struct iwl_drv *tmp_1;
  
#line 1508 
  ldv_mutex_lock_81(& iwlwifi_opmode_table_mtx);
  
#line 1509 
  i = 0;
  
#line 1509 
  goto ldv_51954;
  ldv_51953: 
#line 1510 
  ;
  
#line 1510 
  tmp = strcmp(iwlwifi_opmode_table[i].name,name);
  
#line 1510 
  if (tmp != 0) 
#line 1511 
                goto ldv_51945; else ;
  
#line 1512 
  iwlwifi_opmode_table[i].ops = (struct iwl_op_mode_ops const *)0;
  {
    
#line 1515 
    struct list_head const *__mptr = (struct list_head const *)iwlwifi_opmode_table[i].drv.next;
    
#line 1515 
    tmp_0 = (struct iwl_drv *)__mptr;
  }
  
#line 1515 
  drv = tmp_0;
  
#line 1515 
  goto ldv_51951;
  ldv_51950: 
#line 1516 
  ;
  
#line 1516 
  _iwl_op_mode_stop(drv);
  {
    
#line 1515 
    struct list_head const *__mptr_0 = (struct list_head const *)drv->list.next;
    
#line 1515 
    tmp_1 = (struct iwl_drv *)__mptr_0;
  }
  
#line 1515 
  drv = tmp_1;
  ldv_51951: 
#line 1517 
  ;
  
#line 1515 
  if (& drv->list != & iwlwifi_opmode_table[i].drv) 
#line 1517 
                                                    goto ldv_51950; else 
                                                                    
#line 1520 
                                                                    goto ldv_51952;
  ldv_51952: 
#line 1521 
  ;
  
#line 1518 
  ldv_mutex_unlock_82(& iwlwifi_opmode_table_mtx);
  
#line 1519 
  goto return_label;
  ldv_51945: 
#line 1520 
  ;
  
#line 1509 
  i += 1;
  ldv_51954: 
#line 1510 
  ;
  
#line 1509 
  if ((unsigned int)i <= 1U) 
#line 1511 
                             goto ldv_51953; else 
#line 1514 
                                                  goto ldv_51955;
  ldv_51955: 
#line 1515 
  ;
  
#line 1521 
  ldv_mutex_unlock_83(& iwlwifi_opmode_table_mtx);
  return_label: 
#line 1522 
                return;
}


#line 1523  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static char const __kstrtab_iwl_opmode_deregister[22U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'o', (char)'p', (char)'m', (char)'o', (char)'d', (char)'e', (char)'_', (char)'d', (char)'e', (char)'r', (char)'e', (char)'g', (char)'i', (char)'s', (char)'t', (char)'e', (char)'r', (char)'\000'};

#line 1523 
struct kernel_symbol const __ksymtab_iwl_opmode_deregister;


#line 1523  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
struct kernel_symbol const __ksymtab_iwl_opmode_deregister = {.value = (unsigned long)(& iwl_opmode_deregister), .name = (char const *)(& __kstrtab_iwl_opmode_deregister)};

#line 1525  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static int iwl_drv_init(void)
{
  int __retres;
  int i;
  int tmp;
  {
    struct lock_class_key __key;
    
#line 1529 
    __mutex_init(& iwlwifi_opmode_table_mtx,"&iwlwifi_opmode_table_mtx",& __key);
  }
  
#line 1531 
  i = 0;
  
#line 1531 
  goto ldv_51972;
  ldv_51971: 
#line 1532 
  ;
  
#line 1532 
  INIT_LIST_HEAD(& iwlwifi_opmode_table[i].drv);
  
#line 1531 
  i += 1;
  ldv_51972: 
#line 1532 
  ;
  
#line 1531 
  if ((unsigned int)i <= 1U) 
#line 1533 
                             goto ldv_51971; else 
#line 1536 
                                                  goto ldv_51973;
  ldv_51973: 
#line 1537 
  ;
  
#line 1534 
  printk("\001");
  
#line 1535 
  printk("\001");
  
#line 1539 
  iwl_dbgfs_root = debugfs_create_dir("iwlwifi",(struct dentry *)0);
  
#line 1541 
  if (iwl_dbgfs_root == (struct dentry *)0) {
    
#line 1542 
    __retres = -14;
    
#line 1542 
    goto return_label;
  }
  else ;
  
#line 1545 
  tmp = iwl_pci_register_driver();
  
#line 1545 
  __retres = tmp;
  return_label: 
#line 1545 
                return __retres;
}


#line 1549  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-drv.c"
static void iwl_drv_exit(void)
{
  
#line 1551 
  iwl_pci_unregister_driver();
  
#line 1554 
  debugfs_remove_recursive(iwl_dbgfs_root);
  
#line 1555 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
void ldv_emg_iwl_drv_exit(void)
{
  
#line 67 
  iwl_drv_exit();
  
#line 68 
  return;
}


#line 70  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
int ldv_emg_iwl_drv_init(void)
{
  int tmp;
  
#line 71 
  tmp = iwl_drv_init();
  
#line 71 
  return tmp;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void *ERR_PTR_1(long error)
{
  void *tmp;
  
#line 78 
  tmp = ldv_err_ptr(error);
  
#line 78 
  return tmp;
}


#line 509  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void *kzalloc_3(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 512 
  tmp = ldv_kzalloc(size,flags);
  
#line 512 
  return tmp;
}


#line 753  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_lock_73(struct mutex *ldv_func_arg1)
{
  
#line 757 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 758 
  return;
}


#line 761  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_unlock_74(struct mutex *ldv_func_arg1)
{
  
#line 765 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 766 
  return;
}


#line 769  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_unlock_75(struct mutex *ldv_func_arg1)
{
  
#line 773 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 774 
  return;
}


#line 777  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_lock_76(struct mutex *ldv_func_arg1)
{
  
#line 781 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 782 
  return;
}


#line 785  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_unlock_77(struct mutex *ldv_func_arg1)
{
  
#line 789 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 790 
  return;
}


#line 793  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_lock_78(struct mutex *ldv_func_arg1)
{
  
#line 797 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 798 
  return;
}


#line 801  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_unlock_79(struct mutex *ldv_func_arg1)
{
  
#line 805 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 806 
  return;
}


#line 809  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_unlock_80(struct mutex *ldv_func_arg1)
{
  
#line 813 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 814 
  return;
}


#line 817  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_lock_81(struct mutex *ldv_func_arg1)
{
  
#line 821 
  ldv_mutex_model_lock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 822 
  return;
}


#line 825  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_unlock_82(struct mutex *ldv_func_arg1)
{
  
#line 829 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 830 
  return;
}


#line 833  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-drv.c.aux"
static void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1)
{
  
#line 837 
  ldv_mutex_model_unlock(ldv_func_arg1,(char *)"iwlwifi_opmode_table_mtx");
  
#line 838 
  return;
}


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-1000.c"
static struct iwl_base_params const iwl1000_base_params = {.eeprom_size = 2048, .num_of_queues = 20, .pll_cfg_val = 8913664U, .max_ll_items = (unsigned short)3U, .shadow_ram_support = (_Bool)0, .led_compensation = (unsigned short)51U, .wd_timeout = 0U, .max_event_log_size = 128U, .shadow_reg_enable = (_Bool)0, .pcie_l1_allowed = (_Bool)0, .apmg_wake_up_wa = (_Bool)0, .scd_chain_ext_wa = (_Bool)1};

#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-1000.c"
static struct iwl_ht_params const iwl1000_ht_params = {.smps_mode = 0, .ht_greenfield_support = (_Bool)1, .stbc = (_Bool)0, .ldpc = (_Bool)0, .use_rts_for_aggregation = (_Bool)1, .ht40_bands = (unsigned char)1U};

#line 74  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-1000.c"
static struct iwl_eeprom_params const iwl1000_eeprom_params = {.regulatory_bands = {(unsigned char)8U, (unsigned char)38U, (unsigned char)66U, (unsigned char)92U, (unsigned char)116U, (unsigned char)130U, (unsigned char)0U}, .enhanced_txpower = (_Bool)0};

#line 101  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-1000.c"
struct iwl_cfg const iwl1000_bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 1000 BGN", .fw_name_pre = "iwlwifi-1000-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_1000, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)348U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl1000_base_params, .ht_params = & iwl1000_ht_params, .eeprom_params = & iwl1000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 107  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-1000.c"
struct iwl_cfg const iwl1000_bg_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 1000 BG", .fw_name_pre = "iwlwifi-1000-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 1U, .device_family = IWL_DEVICE_FAMILY_1000, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)348U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl1000_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl1000_eeprom_params, .led_mode = IWL_LED_BLINK, .rx_with_siso_diversity = (_Bool)0, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 128  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-1000.c"
struct iwl_cfg const iwl100_bgn_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 100 BGN", .fw_name_pre = "iwlwifi-100-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_100, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)348U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl1000_base_params, .ht_params = & iwl1000_ht_params, .eeprom_params = & iwl1000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)1, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 134  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-1000.c"
struct iwl_cfg const iwl100_bg_cfg = {.name = "Intel(R) Centrino(R) Wireless-N 100 BG", .fw_name_pre = "iwlwifi-100-", .ucode_api_max = 5U, .ucode_api_ok = 5U, .ucode_api_min = 5U, .device_family = IWL_DEVICE_FAMILY_100, .max_data_size = 49152U, .max_inst_size = 131072U, .valid_tx_ant = (unsigned char)0, .valid_rx_ant = (unsigned char)0, .non_shared_ant = (unsigned char)0, .bt_shared_single_ant = (_Bool)0, .nvm_ver = (unsigned short)348U, .nvm_calib_ver = (unsigned short)4U, .base_params = & iwl1000_base_params, .ht_params = (struct iwl_ht_params const *)0, .eeprom_params = & iwl1000_eeprom_params, .led_mode = IWL_LED_RF_STATE, .rx_with_siso_diversity = (_Bool)1, .internal_wimax_coex = (_Bool)0, .host_interrupt_operation_mode = (_Bool)0, .high_temp = (_Bool)0, .d0i3 = (_Bool)0, .nvm_hw_section_num = (unsigned char)0, .lp_xtal_workaround = (_Bool)0, .pwr_tx_backoffs = (struct iwl_pwr_tx_backoff const *)0, .no_power_up_nic_in_init = (_Bool)0, .default_nvm_file_B_step = (char const *)0, .default_nvm_file_C_step = (char const *)0, .max_rx_agg_size = 0U, .disable_dummy_notification = (_Bool)0, .max_tx_agg_size = 0U, .max_ht_ampdu_exponent = 3U, .max_vht_ampdu_exponent = 0U, .dccm_offset = 0U, .dccm_len = 0U, .dccm2_offset = 0U, .dccm2_len = 0U, .smem_offset = 0U, .smem_len = 0U, .thermal_params = (struct iwl_tt_params const *)0, .apmg_not_supported = (_Bool)0};

#line 116  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
struct kmem_cache *kmem_cache_create(char const *, size_t, size_t, unsigned long, void (*)(void *));


#line 119 
void kmem_cache_destroy(struct kmem_cache *);


#line 581 
static void *kzalloc_4(size_t size, gfp_t flags);


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.c"
struct iwl_trans *iwl_trans_alloc(unsigned int priv_size, struct device *dev, struct iwl_cfg const *cfg, struct iwl_trans_ops const *ops, size_t dev_cmd_headroom)
{
  struct iwl_trans *__retres;
  struct iwl_trans *trans;
  struct lock_class_key __key;
  char const *tmp_0;
  
#line 77 
  trans = (struct iwl_trans *)kzalloc_4((unsigned long)priv_size + 536UL,208U);
  
#line 78 
  if (trans == (struct iwl_trans *)0) {
    
#line 79 
    __retres = (struct iwl_trans *)0;
    
#line 79 
    goto return_label;
  }
  else ;
  
#line 82 
  lockdep_init_map(& trans->sync_cmd_lockdep_map,"sync_cmd_lockdep_map",& __key,0);
  
#line 86 
  trans->dev = dev;
  
#line 87 
  trans->cfg = cfg;
  
#line 88 
  trans->ops = ops;
  
#line 89 
  trans->dev_cmd_headroom = dev_cmd_headroom;
  
#line 92 
  tmp_0 = dev_name((struct device const *)trans->dev);
  
#line 91 
  ;
  
#line 91 
  snprintf((char *)(& trans->dev_cmd_pool_name),50UL,"iwl_cmd_pool:%s",tmp_0);
  
#line 93 
  trans->dev_cmd_pool = kmem_cache_create((char const *)(& trans->dev_cmd_pool_name),trans->dev_cmd_headroom + 324UL,8UL,8192UL,(void (*)(void *))0);
  
#line 100 
  if (trans->dev_cmd_pool == (struct kmem_cache *)0) 
#line 101 
                                                     goto free; else ;
  
#line 103 
  __retres = trans;
  
#line 103 
  goto return_label;
  free: 
#line 104 
  ;
  
#line 105 
  kfree((void const *)trans);
  
#line 106 
  __retres = (struct iwl_trans *)0;
  return_label: 
#line 106 
                return __retres;
}


#line 109  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-trans.c"
void iwl_trans_free(struct iwl_trans *trans)
{
  
#line 111 
  kmem_cache_destroy(trans->dev_cmd_pool);
  
#line 112 
  kfree((void const *)trans);
  
#line 113 
  return;
}


#line 418  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-trans.c.aux"
static void *kzalloc_4(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 421 
  tmp = ldv_kzalloc(size,flags);
  
#line 421 
  return tmp;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
static bool static_key_false_4(struct static_key *key)
{
  bool tmp;
  
#line 125 
  tmp = arch_static_branch(key);
  
#line 125 
  return tmp;
}


#line 418  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/slab.h"
static void *kmalloc_1(size_t size, gfp_t flags);


#line 68  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.h"
int iwl_read_eeprom(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size);


#line 35  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32_4(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 35 
  tmp_4 = static_key_false_4(& __tracepoint_iwlwifi_dev_ioread32.key);
  
#line 35 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 35 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_7766 __u;
          
#line 35 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u.__c),8);
          
#line 35 
          tmp = __u.__val;
        }
        
#line 35 
        struct tracepoint_func *_________p1 = tmp;
        
#line 35 
        tmp_0 = _________p1;
      }
      
#line 35 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 35 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 35 
        if (tmp_1 != 0) {
          
#line 35 
          if (! __warned) {
            int tmp_2;
            
#line 35 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 35 
            if (tmp_2 == 0) {
              
#line 35 
              __warned = (_Bool)1;
              
#line 35 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 35 
      tmp_3 = ________p1;
    }
    
#line 35 
    it_func_ptr = tmp_3;
    
#line 35 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50300: 
#line 37 
      ;
      
#line 35 
      it_func = it_func_ptr->func;
      
#line 35 
      __data = it_func_ptr->data;
      
#line 35 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 35 
      it_func_ptr += 1;
      
#line 35 
      ;
      
#line 35 
      if (it_func_ptr->func != (void *)0) 
#line 37 
                                          goto ldv_50300; else 
#line 40 
                                                               goto ldv_50301;
      ldv_50301: 
#line 41 
      ;
    }
    else ;
    
#line 35 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 35 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_7768 __u_0;
        
#line 35 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),(void *)(& __u_0.__c),8);
        
#line 35 
        tmp_5 = __u_0.__val;
      }
      
#line 35 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 35 
      tmp_6 = _________p1_0;
    }
    
#line 35 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 35 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 35 
      if (tmp_7 != 0) {
        
#line 35 
        if (! __warned_0) {
          int tmp_8;
          
#line 35 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 35 
          if (tmp_8 == 0) {
            
#line 35 
            __warned_0 = (_Bool)1;
            
#line 35 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",50,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 35 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 35 
  rcu_read_unlock_sched_notrace();
  
#line 37 
  return;
}


#line 69  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32_4(struct device const *dev, u32 offs, u32 val)
{
  bool tmp_4;
  
#line 69 
  tmp_4 = static_key_false_4(& __tracepoint_iwlwifi_dev_iowrite32.key);
  
#line 69 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 69 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_7774 __u;
          
#line 69 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u.__c),8);
          
#line 69 
          tmp = __u.__val;
        }
        
#line 69 
        struct tracepoint_func *_________p1 = tmp;
        
#line 69 
        tmp_0 = _________p1;
      }
      
#line 69 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 69 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 69 
        if (tmp_1 != 0) {
          
#line 69 
          if (! __warned) {
            int tmp_2;
            
#line 69 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 69 
            if (tmp_2 == 0) {
              
#line 69 
              __warned = (_Bool)1;
              
#line 69 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 69 
      tmp_3 = ________p1;
    }
    
#line 69 
    it_func_ptr = tmp_3;
    
#line 69 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50422: 
#line 71 
      ;
      
#line 69 
      it_func = it_func_ptr->func;
      
#line 69 
      __data = it_func_ptr->data;
      
#line 69 
      (*((void (*)(void *, struct device const *, u32 , u32 ))it_func))(__data,dev,offs,val);
      
#line 69 
      it_func_ptr += 1;
      
#line 69 
      ;
      
#line 69 
      if (it_func_ptr->func != (void *)0) 
#line 71 
                                          goto ldv_50422; else 
#line 74 
                                                               goto ldv_50423;
      ldv_50423: 
#line 75 
      ;
    }
    else ;
    
#line 69 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 69 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_7776 __u_0;
        
#line 69 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),(void *)(& __u_0.__c),8);
        
#line 69 
        tmp_5 = __u_0.__val;
      }
      
#line 69 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 69 
      tmp_6 = _________p1_0;
    }
    
#line 69 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 69 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 69 
      if (tmp_7 != 0) {
        
#line 69 
        if (! __warned_0) {
          int tmp_8;
          
#line 69 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 69 
          if (tmp_8 == 0) {
            
#line 69 
            __warned_0 = (_Bool)1;
            
#line 69 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-io.h",84,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 69 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 69 
  rcu_read_unlock_sched_notrace();
  
#line 71 
  return;
}


#line 41  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static void iwl_write32_4(struct iwl_trans *trans, u32 ofs, u32 val)
{
  
#line 43 
  trace_iwlwifi_dev_iowrite32_4((struct device const *)trans->dev,ofs,val);
  
#line 44 
  iwl_trans_write32(trans,ofs,val);
  
#line 45 
  return;
}


#line 47  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-io.h"
__inline static u32 iwl_read32_4(struct iwl_trans *trans, u32 ofs)
{
  
#line 49 
  u32 val = iwl_trans_read32(trans,ofs);
  
#line 50 
  trace_iwlwifi_dev_ioread32_4((struct device const *)trans->dev,ofs,val);
  
#line 51 
  return val;
}


#line 113  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
void __compiletime_assert_115(void);


#line 97  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static int iwl_eeprom_acquire_semaphore(struct iwl_trans *trans)
{
  int __retres;
  u16 count;
  int ret;
  
#line 102 
  count = (unsigned short)0U;
  
#line 102 
  goto ldv_51770;
  ldv_51769: 
#line 103 
  ;
  
#line 104 
  iwl_set_bit(trans,0U,2097152U);
  
#line 108 
  ret = iwl_poll_bit(trans,0U,2097152U,2097152U,10);
  
#line 112 
  if (ret >= 0) {
    {
      
#line 113 
      bool __cond = (_Bool)((int)*("Acquired semaphore after %d tries.\n" + 34UL) != 10);
      
#line 113 
      if ((int)__cond != 0) 
#line 113 
                            __compiletime_assert_115(); else ;
    }
    
#line 113 
    __iwl_dbg(trans->dev,64U,(_Bool)0,"iwl_eeprom_acquire_semaphore","Acquired semaphore after %d tries.\n",(int)count + 1);
    
#line 116 
    __retres = ret;
    
#line 116 
    goto return_label;
  }
  else ;
  
#line 102 
  count = (u16)((int)count + 1);
  ldv_51770: 
#line 103 
  ;
  
#line 102 
  if ((unsigned int)count <= 999U) 
#line 104 
                                   goto ldv_51769; else 
#line 107 
                                                        goto ldv_51771;
  ldv_51771: 
#line 108 
  ;
  
#line 120 
  __retres = ret;
  return_label: 
#line 120 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static void iwl_eeprom_release_semaphore(struct iwl_trans *trans)
{
  
#line 125 
  iwl_clear_bit(trans,0U,2097152U);
  
#line 126 
  return;
}


#line 133 
void __compiletime_assert_133(void);


#line 138 
void __compiletime_assert_139(void);


#line 146 
void __compiletime_assert_146(void);


#line 152 
void __compiletime_assert_154(void);


#line 129  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static int iwl_eeprom_verify_signature(struct iwl_trans *trans, bool nvm_is_otp)
{
  int __retres;
  u32 tmp;
  
#line 131 
  tmp = iwl_read32_4(trans,48U);
  
#line 131 
  u32 gp = tmp & 7U;
  {
    
#line 133 
    bool __cond = (_Bool)((int)*("EEPROM signature=0x%08x\n" + 23UL) != 10);
    
#line 133 
    if ((int)__cond != 0) 
#line 133 
                          __compiletime_assert_133(); else ;
  }
  
#line 133 
  __iwl_dbg(trans->dev,64U,(_Bool)0,"iwl_eeprom_verify_signature","EEPROM signature=0x%08x\n",gp);
  
#line 135 
  switch (gp) {
    char *tmp_0;
    case (u32)1: 
#line 136 
    ;
    
#line 137 
    if (! nvm_is_otp) {
      {
        
#line 138 
        bool __cond_0 = (_Bool)((int)*("EEPROM with bad signature: 0x%08x\n" + 33UL) != 10);
        
#line 138 
        if ((int)__cond_0 != 0) 
#line 138 
                                __compiletime_assert_139(); else ;
      }
      
#line 138 
      __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"EEPROM with bad signature: 0x%08x\n",gp);
      
#line 140 
      __retres = -2;
      
#line 140 
      goto return_label;
    }
    else ;
    
#line 142 
    __retres = 0;
    
#line 142 
    goto return_label;
    case (u32)2: 
#line 143 
    ;
    case (u32)4: 
#line 144 
    ;
    
#line 145 
    if ((int)nvm_is_otp != 0) {
      {
        
#line 146 
        bool __cond_1 = (_Bool)((int)*("OTP with bad signature: 0x%08x\n" + 30UL) != 10);
        
#line 146 
        if ((int)__cond_1 != 0) 
#line 146 
                                __compiletime_assert_146(); else ;
      }
      
#line 146 
      __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"OTP with bad signature: 0x%08x\n",gp);
      
#line 147 
      __retres = -2;
      
#line 147 
      goto return_label;
    }
    else ;
    
#line 149 
    __retres = 0;
    
#line 149 
    goto return_label;
    case (u32)0: 
#line 150 
    ;
    default: 
#line 151 
    ;
    {
      
#line 152 
      bool __cond_2 = (_Bool)((int)*("bad EEPROM/OTP signature, type=%s, EEPROM_GP=0x%08x\n" + 51UL) != 10);
      
#line 152 
      if ((int)__cond_2 != 0) 
#line 152 
                              __compiletime_assert_154(); else ;
    }
    
#line 152 
    ;
    
#line 152 
    if ((int)nvm_is_otp != 0) 
#line 152 
                              tmp_0 = (char *)"OTP"; else 
#line 152 
                                                          tmp_0 = (char *)"EEPROM";
    
#line 152 
    ;
    
#line 152 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"bad EEPROM/OTP signature, type=%s, EEPROM_GP=0x%08x\n",tmp_0,gp);
    
#line 155 
    __retres = -2;
    
#line 155 
    goto return_label;
  }
  return_label: 
#line 135 
                return __retres;
}


#line 165  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static void iwl_set_otp_access_absolute(struct iwl_trans *trans)
{
  
#line 167 
  iwl_read32_4(trans,52U);
  
#line 169 
  iwl_clear_bit(trans,52U,131072U);
  
#line 170 
  return;
}


#line 180 
void __compiletime_assert_180(void);


#line 173  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static int iwl_nvm_is_otp(struct iwl_trans *trans)
{
  int __retres;
  u32 otpgp;
  
#line 178 
  switch (trans->hw_rev & 65520U) {
    case (unsigned int)496: 
#line 179 
    ;
    {
      
#line 180 
      bool __cond = (_Bool)((int)*("Unknown hardware type\n" + 21UL) != 10);
      
#line 180 
      if ((int)__cond != 0) 
#line 180 
                            __compiletime_assert_180(); else ;
    }
    
#line 180 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Unknown hardware type\n");
    
#line 181 
    __retres = -5;
    
#line 181 
    goto return_label;
    case (unsigned int)32: 
#line 182 
    ;
    case (unsigned int)48: 
#line 183 
    ;
    case (unsigned int)80: 
#line 184 
    ;
    case (unsigned int)64: 
#line 185 
    ;
    
#line 186 
    __retres = 0;
    
#line 186 
    goto return_label;
    default: 
#line 187 
    ;
    
#line 188 
    otpgp = iwl_read32_4(trans,52U);
    
#line 189 
    if ((otpgp & 65536U) != 0U) {
      
#line 190 
      __retres = 1;
      
#line 190 
      goto return_label;
    }
    else ;
    
#line 191 
    __retres = 0;
    
#line 191 
    goto return_label;
  }
  return_label: 
#line 178 
                return __retres;
}


#line 210 
void __compiletime_assert_210(void);


#line 195  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static int iwl_init_otp_access(struct iwl_trans *trans)
{
  int ret;
  u32 tmp;
  
#line 200 
  tmp = iwl_read32_4(trans,36U);
  
#line 200 
  ;
  
#line 200 
  iwl_write32_4(trans,36U,tmp | 4U);
  
#line 205 
  ret = iwl_poll_bit(trans,36U,1U,1U,25000);
  
#line 209 
  if (ret < 0) {
    {
      
#line 210 
      bool __cond = (_Bool)((int)*("Time out access OTP\n" + 19UL) != 10);
      
#line 210 
      if ((int)__cond != 0) 
#line 210 
                            __compiletime_assert_210(); else ;
    }
    
#line 210 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Time out access OTP\n");
  }
  else {
    
#line 212 
    iwl_set_bits_prph(trans,12300U,67108864U);
    
#line 214 
    __const_udelay(21475UL);
    
#line 215 
    iwl_clear_bits_prph(trans,12300U,67108864U);
    
#line 222 
    if ((int)((trans->cfg)->base_params)->shadow_ram_support != 0) 
#line 223 
                                                                   iwl_set_bit(trans,592U,2147483648U); else ;
  }
  
#line 226 
  return ret;
}


#line 243 
void __compiletime_assert_243(void);


#line 254 
void __compiletime_assert_254(void);


#line 262 
void __compiletime_assert_262(void);


#line 229  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static int iwl_read_otp_word(struct iwl_trans *trans, u16 addr, __le16 *eeprom_data)
{
  int __retres;
  u32 r;
  u32 otpgp;
  
#line 232 
  int ret = 0;
  
#line 236 
  iwl_write32_4(trans,44U,(unsigned int)((int)addr << 1) & 65532U);
  
#line 238 
  ret = iwl_poll_bit(trans,44U,1U,1U,5000);
  
#line 242 
  if (ret < 0) {
    {
      
#line 243 
      bool __cond = (_Bool)((int)*("Time out reading OTP[%d]\n" + 24UL) != 10);
      
#line 243 
      if ((int)__cond != 0) 
#line 243 
                            __compiletime_assert_243(); else ;
    }
    
#line 243 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Time out reading OTP[%d]\n",(int)addr);
    
#line 244 
    __retres = ret;
    
#line 244 
    goto return_label;
  }
  else ;
  
#line 246 
  r = iwl_read32_4(trans,44U);
  
#line 248 
  otpgp = iwl_read32_4(trans,52U);
  
#line 249 
  if ((otpgp & 2097152U) != 0U) {
    
#line 252 
    iwl_set_bit(trans,52U,2097152U);
    {
      
#line 254 
      bool __cond_0 = (_Bool)((int)*("Uncorrectable OTP ECC error, abort OTP read\n" + 43UL) != 10);
      
#line 254 
      if ((int)__cond_0 != 0) 
#line 254 
                              __compiletime_assert_254(); else ;
    }
    
#line 254 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Uncorrectable OTP ECC error, abort OTP read\n");
    
#line 255 
    __retres = -22;
    
#line 255 
    goto return_label;
  }
  else ;
  
#line 257 
  if ((otpgp & 1048576U) != 0U) {
    
#line 260 
    iwl_set_bit(trans,52U,1048576U);
    {
      
#line 262 
      bool __cond_1 = (_Bool)((int)*("Correctable OTP ECC error, continue read\n" + 40UL) != 10);
      
#line 262 
      if ((int)__cond_1 != 0) 
#line 262 
                              __compiletime_assert_262(); else ;
    }
    
#line 262 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Correctable OTP ECC error, continue read\n");
  }
  else ;
  
#line 264 
  *eeprom_data = (unsigned short)(r >> 16);
  
#line 265 
  __retres = 0;
  return_label: 
#line 265 
                return __retres;
}


#line 280 
void __compiletime_assert_280(void);


#line 284 
void __compiletime_assert_284(void);


#line 271  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static bool iwl_is_otp_empty(struct iwl_trans *trans)
{
  __le16 link_value;
  int tmp;
  
#line 273 
  u16 next_link_addr = (unsigned short)0U;
  
#line 275 
  bool is_empty = (_Bool)0;
  
#line 278 
  tmp = iwl_read_otp_word(trans,(unsigned short)((int)next_link_addr),& link_value);
  
#line 278 
  if (tmp == 0) {
    
#line 279 
    if ((unsigned int)link_value == 0U) {
      {
        
#line 280 
        bool __cond = (_Bool)((int)*("OTP is empty\n" + 12UL) != 10);
        
#line 280 
        if ((int)__cond != 0) 
#line 280 
                              __compiletime_assert_280(); else ;
      }
      
#line 280 
      __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"OTP is empty\n");
      
#line 281 
      is_empty = (_Bool)1;
    }
    else ;
  }
  else {
    {
      
#line 284 
      bool __cond_0 = (_Bool)((int)*("Unable to read first block of OTP list.\n" + 39UL) != 10);
      
#line 284 
      if ((int)__cond_0 != 0) 
#line 284 
                              __compiletime_assert_284(); else ;
    }
    
#line 284 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Unable to read first block of OTP list.\n");
    
#line 285 
    is_empty = (_Bool)1;
  }
  
#line 288 
  return is_empty;
}


#line 326 
void __compiletime_assert_327(void);


#line 346 
void __compiletime_assert_346(void);


#line 301  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static int iwl_find_otp_image(struct iwl_trans *trans, u16 *validblockaddr)
{
  int __retres;
  u16 valid_addr;
  bool tmp;
  int tmp_0;
  
#line 304 
  u16 next_link_addr = (unsigned short)0U;
  
#line 305 
  __le16 link_value = (unsigned short)0U;
  
#line 306 
  int usedblocks = 0;
  
#line 309 
  iwl_set_otp_access_absolute(trans);
  
#line 312 
  tmp = iwl_is_otp_empty(trans);
  
#line 312 
  if ((int)tmp != 0) {
    
#line 313 
    __retres = -22;
    
#line 313 
    goto return_label;
  }
  else ;
  ldv_51874: 
#line 314 
  ;
  
#line 324 
  valid_addr = next_link_addr;
  
#line 325 
  next_link_addr = (unsigned short)((unsigned int)link_value * 2U);
  {
    
#line 326 
    bool __cond = (_Bool)((int)*("OTP blocks %d addr 0x%x\n" + 23UL) != 10);
    
#line 326 
    if ((int)__cond != 0) 
#line 326 
                          __compiletime_assert_327(); else ;
  }
  
#line 326 
  __iwl_dbg(trans->dev,64U,(_Bool)0,"iwl_find_otp_image","OTP blocks %d addr 0x%x\n",usedblocks,(int)next_link_addr);
  
#line 328 
  tmp_0 = iwl_read_otp_word(trans,(unsigned short)((int)next_link_addr),& link_value);
  
#line 328 
  if (tmp_0 != 0) {
    
#line 329 
    __retres = -22;
    
#line 329 
    goto return_label;
  }
  else ;
  
#line 330 
  if ((unsigned int)link_value == 0U) {
    
#line 336 
    *validblockaddr = valid_addr;
    
#line 338 
    *validblockaddr = (unsigned short)((unsigned int)*validblockaddr + 2U);
    
#line 339 
    __retres = 0;
    
#line 339 
    goto return_label;
  }
  else ;
  
#line 342 
  usedblocks += 1;
  
#line 343 
  if ((int)((trans->cfg)->base_params)->max_ll_items >= usedblocks) 
#line 345 
                                                                    goto ldv_51874; else 
                                                                    
#line 348 
                                                                    goto ldv_51875;
  ldv_51875: 
#line 349 
  ;
  {
    
#line 346 
    bool __cond_0 = (_Bool)((int)*("OTP has no valid blocks\n" + 23UL) != 10);
    
#line 346 
    if ((int)__cond_0 != 0) 
#line 346 
                            __compiletime_assert_346(); else ;
  }
  
#line 346 
  __iwl_dbg(trans->dev,64U,(_Bool)0,"iwl_find_otp_image","OTP has no valid blocks\n");
  
#line 347 
  __retres = -22;
  return_label: 
#line 347 
                return __retres;
}


#line 377 
void __compiletime_assert_377(void);


#line 385 
void __compiletime_assert_385(void);


#line 392 
void __compiletime_assert_392(void);


#line 399 
void __compiletime_assert_399(void);


#line 439 
void __compiletime_assert_440(void);


#line 448 
void __compiletime_assert_449(void);


#line 358  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
int iwl_read_eeprom(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size)
{
  int __retres;
  __le16 *e;
  int sz;
  int ret;
  u16 addr;
  int nvm_is_otp;
  char *tmp_2;
  
#line 361 
  u32 gp = iwl_read32_4(trans,48U);
  
#line 365 
  u16 validblockaddr = (unsigned short)0U;
  
#line 366 
  u16 cache_addr = (unsigned short)0U;
  
#line 369 
  if (eeprom == (u8 **)0U || eeprom_size == (size_t *)0UL) {
    
#line 370 
    __retres = -22;
    
#line 370 
    goto return_label;
  }
  else ;
  
#line 372 
  nvm_is_otp = iwl_nvm_is_otp(trans);
  
#line 373 
  if (nvm_is_otp < 0) {
    
#line 374 
    __retres = nvm_is_otp;
    
#line 374 
    goto return_label;
  }
  else ;
  
#line 376 
  sz = ((trans->cfg)->base_params)->eeprom_size;
  {
    
#line 377 
    bool __cond = (_Bool)((int)*("NVM size = %d\n" + 13UL) != 10);
    
#line 377 
    if ((int)__cond != 0) 
#line 377 
                          __compiletime_assert_377(); else ;
  }
  
#line 377 
  __iwl_dbg(trans->dev,64U,(_Bool)0,"iwl_read_eeprom","NVM size = %d\n",sz);
  
#line 379 
  e = (__le16 *)kmalloc_1((unsigned long)sz,208U);
  
#line 380 
  if (e == (__le16 *)0U) {
    
#line 381 
    __retres = -12;
    
#line 381 
    goto return_label;
  }
  else ;
  
#line 383 
  ret = iwl_eeprom_verify_signature(trans,(_Bool)(nvm_is_otp != 0));
  
#line 384 
  if (ret < 0) {
    {
      
#line 385 
      bool __cond_0 = (_Bool)((int)*("EEPROM not found, EEPROM_GP=0x%08x\n" + 34UL) != 10);
      
#line 385 
      if ((int)__cond_0 != 0) 
#line 385 
                              __compiletime_assert_385(); else ;
    }
    
#line 385 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"EEPROM not found, EEPROM_GP=0x%08x\n",gp);
    
#line 386 
    goto err_free;
  }
  else ;
  
#line 390 
  ret = iwl_eeprom_acquire_semaphore(trans);
  
#line 391 
  if (ret < 0) {
    {
      
#line 392 
      bool __cond_1 = (_Bool)((int)*("Failed to acquire EEPROM semaphore.\n" + 35UL) != 10);
      
#line 392 
      if ((int)__cond_1 != 0) 
#line 392 
                              __compiletime_assert_392(); else ;
    }
    
#line 392 
    __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Failed to acquire EEPROM semaphore.\n");
    
#line 393 
    goto err_free;
  }
  else ;
  
#line 396 
  if (nvm_is_otp != 0) {
    u32 tmp_1;
    
#line 397 
    ret = iwl_init_otp_access(trans);
    
#line 398 
    if (ret != 0) {
      {
        
#line 399 
        bool __cond_2 = (_Bool)((int)*("Failed to initialize OTP access.\n" + 32UL) != 10);
        
#line 399 
        if ((int)__cond_2 != 0) 
#line 399 
                                __compiletime_assert_399(); else ;
      }
      
#line 399 
      __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Failed to initialize OTP access.\n");
      
#line 400 
      goto err_unlock;
    }
    else ;
    
#line 403 
    tmp_1 = iwl_read32_4(trans,48U);
    
#line 403 
    ;
    
#line 403 
    iwl_write32_4(trans,48U,tmp_1 & 4294966911U);
    
#line 407 
    iwl_set_bit(trans,52U,3145728U);
    
#line 411 
    if (! ((trans->cfg)->base_params)->shadow_ram_support) {
      
#line 412 
      ret = iwl_find_otp_image(trans,& validblockaddr);
      
#line 413 
      if (ret != 0) 
#line 414 
                    goto err_unlock; else ;
    }
    else ;
    
#line 416 
    addr = validblockaddr;
    
#line 416 
    goto ldv_51914;
    ldv_51913: 
#line 417 
    ;
    {
      __le16 eeprom_data;
      
#line 420 
      ret = iwl_read_otp_word(trans,(unsigned short)((int)addr),& eeprom_data);
      
#line 421 
      if (ret != 0) 
#line 422 
                    goto err_unlock; else ;
      
#line 423 
      *(e + (unsigned int)cache_addr / 2U) = eeprom_data;
      
#line 424 
      cache_addr = (unsigned short)((unsigned int)cache_addr + 2U);
    }
    
#line 417 
    addr = (unsigned short)((unsigned int)addr + 2U);
    ldv_51914: 
#line 418 
    ;
    
#line 416 
    if ((int)addr < (int)validblockaddr + sz) 
#line 418 
                                              goto ldv_51913; else 
#line 421 
                                                                   goto ldv_51915;
    ldv_51915: 
#line 422 
    ;
  }
  else {
    
#line 428 
    addr = (unsigned short)0U;
    
#line 428 
    goto ldv_51922;
    ldv_51921: 
#line 429 
    ;
    {
      u32 r;
      
#line 431 
      iwl_write32_4(trans,44U,(unsigned int)((int)addr << 1) & 65532U);
      
#line 434 
      ret = iwl_poll_bit(trans,44U,1U,1U,5000);
      
#line 438 
      if (ret < 0) {
        {
          
#line 439 
          bool __cond_3 = (_Bool)((int)*("Time out reading EEPROM[%d]\n" + 27UL) != 10);
          
#line 439 
          if ((int)__cond_3 != 0) 
#line 439 
                                  __compiletime_assert_440(); else ;
        }
        
#line 439 
        __iwl_err(trans->dev,(_Bool)0,(_Bool)0,"Time out reading EEPROM[%d]\n",(int)addr);
        
#line 441 
        goto err_unlock;
      }
      else ;
      
#line 443 
      r = iwl_read32_4(trans,44U);
      
#line 444 
      *(e + (unsigned int)addr / 2U) = (unsigned short)(r >> 16);
    }
    
#line 428 
    addr = (unsigned short)((unsigned int)addr + 2U);
    ldv_51922: 
#line 429 
    ;
    
#line 428 
    if ((int)addr < sz) 
#line 430 
                        goto ldv_51921; else 
#line 433 
                                             goto ldv_51923;
    ldv_51923: 
#line 434 
    ;
  }
  {
    
#line 448 
    bool __cond_4 = (_Bool)((int)*("NVM Type: %s\n" + 12UL) != 10);
    
#line 448 
    if ((int)__cond_4 != 0) 
#line 448 
                            __compiletime_assert_449(); else ;
  }
  
#line 448 
  if (nvm_is_otp != 0) 
#line 448 
                       tmp_2 = (char *)"OTP"; else 
#line 448 
                                                   tmp_2 = (char *)"EEPROM";
  
#line 448 
  ;
  
#line 448 
  __iwl_dbg(trans->dev,64U,(_Bool)0,"iwl_read_eeprom","NVM Type: %s\n",tmp_2);
  
#line 451 
  iwl_eeprom_release_semaphore(trans);
  
#line 453 
  *eeprom_size = (unsigned long)sz;
  
#line 454 
  *eeprom = (u8 *)e;
  
#line 455 
  __retres = 0;
  
#line 455 
  goto return_label;
  err_unlock: 
#line 457 
  ;
  
#line 458 
  iwl_eeprom_release_semaphore(trans);
  err_free: 
#line 459 
  ;
  
#line 460 
  kfree((void const *)e);
  
#line 462 
  __retres = ret;
  return_label: 
#line 462 
                return __retres;
}


#line 464  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
static char const __kstrtab_iwl_read_eeprom[16U] = {(char)'i', (char)'w', (char)'l', (char)'_', (char)'r', (char)'e', (char)'a', (char)'d', (char)'_', (char)'e', (char)'e', (char)'p', (char)'r', (char)'o', (char)'m', (char)'\000'};

#line 464 
struct kernel_symbol const __ksymtab_iwl_read_eeprom;


#line 464  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c"
struct kernel_symbol const __ksymtab_iwl_read_eeprom = {.value = (unsigned long)(& iwl_read_eeprom), .name = (char const *)(& __kstrtab_iwl_read_eeprom)};

#line 397  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/weaver/.tmp_iwl-eeprom-read.c.aux"
static void *kmalloc_1(size_t size, gfp_t flags)
{
  void *tmp;
  
#line 400 
  tmp = ldv_kmalloc(size,flags);
  
#line 400 
  return tmp;
}

void __builtin_va_end(__builtin_va_list);

void __builtin_va_start(__builtin_va_list);


#line 123  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/jump_label.h"
static bool static_key_false_5(struct static_key *key)
{
  bool tmp;
  
#line 125 
  tmp = arch_static_branch(key);
  
#line 125 
  return tmp;
}


#line 1074  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/device.h"
void dev_printk(char const *, struct device const *, char const * , ...);


#line 1081 
void dev_crit(struct device const *, char const * , ...);


#line 1085 
void dev_warn(struct device const *, char const * , ...);


#line 51  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
__inline static void trace_iwlwifi_err(struct va_format *vaf)
{
  bool tmp_4;
  
#line 51 
  tmp_4 = static_key_false_5(& __tracepoint_iwlwifi_err.key);
  
#line 51 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 51 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_8259 __u;
          
#line 51 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_err.funcs),(void *)(& __u.__c),8);
          
#line 51 
          tmp = __u.__val;
        }
        
#line 51 
        struct tracepoint_func *_________p1 = tmp;
        
#line 51 
        tmp_0 = _________p1;
      }
      
#line 51 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 51 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 51 
        if (tmp_1 != 0) {
          
#line 51 
          if (! __warned) {
            int tmp_2;
            
#line 51 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 51 
            if (tmp_2 == 0) {
              
#line 51 
              __warned = (_Bool)1;
              
#line 51 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",54,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 51 
      tmp_3 = ________p1;
    }
    
#line 51 
    it_func_ptr = tmp_3;
    
#line 51 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50841: 
#line 53 
      ;
      
#line 51 
      it_func = it_func_ptr->func;
      
#line 51 
      __data = it_func_ptr->data;
      
#line 51 
      (*((void (*)(void *, struct va_format *))it_func))(__data,vaf);
      
#line 51 
      it_func_ptr += 1;
      
#line 51 
      ;
      
#line 51 
      if (it_func_ptr->func != (void *)0) 
#line 53 
                                          goto ldv_50841; else 
#line 56 
                                                               goto ldv_50842;
      ldv_50842: 
#line 57 
      ;
    }
    else ;
    
#line 51 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 51 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_8261 __u_0;
        
#line 51 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_err.funcs),(void *)(& __u_0.__c),8);
        
#line 51 
        tmp_5 = __u_0.__val;
      }
      
#line 51 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 51 
      tmp_6 = _________p1_0;
    }
    
#line 51 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 51 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 51 
      if (tmp_7 != 0) {
        
#line 51 
        if (! __warned_0) {
          int tmp_8;
          
#line 51 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 51 
          if (tmp_8 == 0) {
            
#line 51 
            __warned_0 = (_Bool)1;
            
#line 51 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",54,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 51 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 51 
  rcu_read_unlock_sched_notrace();
  
#line 53 
  return;
}


#line 56  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
__inline static void trace_iwlwifi_warn(struct va_format *vaf)
{
  bool tmp_4;
  
#line 56 
  tmp_4 = static_key_false_5(& __tracepoint_iwlwifi_warn.key);
  
#line 56 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 56 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_8263 __u;
          
#line 56 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_warn.funcs),(void *)(& __u.__c),8);
          
#line 56 
          tmp = __u.__val;
        }
        
#line 56 
        struct tracepoint_func *_________p1 = tmp;
        
#line 56 
        tmp_0 = _________p1;
      }
      
#line 56 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 56 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 56 
        if (tmp_1 != 0) {
          
#line 56 
          if (! __warned) {
            int tmp_2;
            
#line 56 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 56 
            if (tmp_2 == 0) {
              
#line 56 
              __warned = (_Bool)1;
              
#line 56 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",59,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 56 
      tmp_3 = ________p1;
    }
    
#line 56 
    it_func_ptr = tmp_3;
    
#line 56 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50892: 
#line 58 
      ;
      
#line 56 
      it_func = it_func_ptr->func;
      
#line 56 
      __data = it_func_ptr->data;
      
#line 56 
      (*((void (*)(void *, struct va_format *))it_func))(__data,vaf);
      
#line 56 
      it_func_ptr += 1;
      
#line 56 
      ;
      
#line 56 
      if (it_func_ptr->func != (void *)0) 
#line 58 
                                          goto ldv_50892; else 
#line 61 
                                                               goto ldv_50893;
      ldv_50893: 
#line 62 
      ;
    }
    else ;
    
#line 56 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 56 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_8265 __u_0;
        
#line 56 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_warn.funcs),(void *)(& __u_0.__c),8);
        
#line 56 
        tmp_5 = __u_0.__val;
      }
      
#line 56 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 56 
      tmp_6 = _________p1_0;
    }
    
#line 56 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 56 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 56 
      if (tmp_7 != 0) {
        
#line 56 
        if (! __warned_0) {
          int tmp_8;
          
#line 56 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 56 
          if (tmp_8 == 0) {
            
#line 56 
            __warned_0 = (_Bool)1;
            
#line 56 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",59,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 56 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 56 
  rcu_read_unlock_sched_notrace();
  
#line 58 
  return;
}


#line 61  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
__inline static void trace_iwlwifi_info(struct va_format *vaf)
{
  bool tmp_4;
  
#line 61 
  tmp_4 = static_key_false_5(& __tracepoint_iwlwifi_info.key);
  
#line 61 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 61 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_8267 __u;
          
#line 61 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_info.funcs),(void *)(& __u.__c),8);
          
#line 61 
          tmp = __u.__val;
        }
        
#line 61 
        struct tracepoint_func *_________p1 = tmp;
        
#line 61 
        tmp_0 = _________p1;
      }
      
#line 61 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 61 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 61 
        if (tmp_1 != 0) {
          
#line 61 
          if (! __warned) {
            int tmp_2;
            
#line 61 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 61 
            if (tmp_2 == 0) {
              
#line 61 
              __warned = (_Bool)1;
              
#line 61 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",64,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 61 
      tmp_3 = ________p1;
    }
    
#line 61 
    it_func_ptr = tmp_3;
    
#line 61 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50943: 
#line 63 
      ;
      
#line 61 
      it_func = it_func_ptr->func;
      
#line 61 
      __data = it_func_ptr->data;
      
#line 61 
      (*((void (*)(void *, struct va_format *))it_func))(__data,vaf);
      
#line 61 
      it_func_ptr += 1;
      
#line 61 
      ;
      
#line 61 
      if (it_func_ptr->func != (void *)0) 
#line 63 
                                          goto ldv_50943; else 
#line 66 
                                                               goto ldv_50944;
      ldv_50944: 
#line 67 
      ;
    }
    else ;
    
#line 61 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 61 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_8269 __u_0;
        
#line 61 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_info.funcs),(void *)(& __u_0.__c),8);
        
#line 61 
        tmp_5 = __u_0.__val;
      }
      
#line 61 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 61 
      tmp_6 = _________p1_0;
    }
    
#line 61 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 61 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 61 
      if (tmp_7 != 0) {
        
#line 61 
        if (! __warned_0) {
          int tmp_8;
          
#line 61 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 61 
          if (tmp_8 == 0) {
            
#line 61 
            __warned_0 = (_Bool)1;
            
#line 61 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",64,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 61 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 61 
  rcu_read_unlock_sched_notrace();
  
#line 63 
  return;
}


#line 66  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
__inline static void trace_iwlwifi_crit(struct va_format *vaf)
{
  bool tmp_4;
  
#line 66 
  tmp_4 = static_key_false_5(& __tracepoint_iwlwifi_crit.key);
  
#line 66 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 66 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_8271 __u;
          
#line 66 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_crit.funcs),(void *)(& __u.__c),8);
          
#line 66 
          tmp = __u.__val;
        }
        
#line 66 
        struct tracepoint_func *_________p1 = tmp;
        
#line 66 
        tmp_0 = _________p1;
      }
      
#line 66 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 66 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 66 
        if (tmp_1 != 0) {
          
#line 66 
          if (! __warned) {
            int tmp_2;
            
#line 66 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 66 
            if (tmp_2 == 0) {
              
#line 66 
              __warned = (_Bool)1;
              
#line 66 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",69,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 66 
      tmp_3 = ________p1;
    }
    
#line 66 
    it_func_ptr = tmp_3;
    
#line 66 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_50994: 
#line 68 
      ;
      
#line 66 
      it_func = it_func_ptr->func;
      
#line 66 
      __data = it_func_ptr->data;
      
#line 66 
      (*((void (*)(void *, struct va_format *))it_func))(__data,vaf);
      
#line 66 
      it_func_ptr += 1;
      
#line 66 
      ;
      
#line 66 
      if (it_func_ptr->func != (void *)0) 
#line 68 
                                          goto ldv_50994; else 
#line 71 
                                                               goto ldv_50995;
      ldv_50995: 
#line 72 
      ;
    }
    else ;
    
#line 66 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 66 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_8273 __u_0;
        
#line 66 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_crit.funcs),(void *)(& __u_0.__c),8);
        
#line 66 
        tmp_5 = __u_0.__val;
      }
      
#line 66 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 66 
      tmp_6 = _________p1_0;
    }
    
#line 66 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 66 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 66 
      if (tmp_7 != 0) {
        
#line 66 
        if (! __warned_0) {
          int tmp_8;
          
#line 66 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 66 
          if (tmp_8 == 0) {
            
#line 66 
            __warned_0 = (_Bool)1;
            
#line 66 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",69,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 66 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 66 
  rcu_read_unlock_sched_notrace();
  
#line 68 
  return;
}


#line 71  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h"
__inline static void trace_iwlwifi_dbg(u32 level, bool in_interrupt, char const *function, struct va_format *vaf)
{
  bool tmp_4;
  
#line 71 
  tmp_4 = static_key_false_5(& __tracepoint_iwlwifi_dbg.key);
  
#line 71 
  if ((int)tmp_4 != 0) {
    struct tracepoint_func *it_func_ptr;
    void *it_func;
    void *__data;
    struct tracepoint_func *tmp_3;
    
#line 71 
    rcu_read_lock_sched_notrace();
    {
      struct tracepoint_func *tmp_0;
      {
        struct tracepoint_func *tmp;
        {
          union __anonunion___u_8275 __u;
          
#line 71 
          __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dbg.funcs),(void *)(& __u.__c),8);
          
#line 71 
          tmp = __u.__val;
        }
        
#line 71 
        struct tracepoint_func *_________p1 = tmp;
        
#line 71 
        tmp_0 = _________p1;
      }
      
#line 71 
      struct tracepoint_func *________p1 = tmp_0;
      {
        bool __warned;
        int tmp_1;
        
#line 71 
        tmp_1 = debug_lockdep_rcu_enabled();
        
#line 71 
        if (tmp_1 != 0) {
          
#line 71 
          if (! __warned) {
            int tmp_2;
            
#line 71 
            tmp_2 = rcu_read_lock_sched_held();
            
#line 71 
            if (tmp_2 == 0) {
              
#line 71 
              __warned = (_Bool)1;
              
#line 71 
              lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",90,"suspicious rcu_dereference_check() usage");
            }
            else ;
          }
          else ;
        }
        else ;
      }
      
#line 71 
      tmp_3 = ________p1;
    }
    
#line 71 
    it_func_ptr = tmp_3;
    
#line 71 
    if (it_func_ptr != (struct tracepoint_func *)0) {
      ldv_51051: 
#line 73 
      ;
      
#line 71 
      it_func = it_func_ptr->func;
      
#line 71 
      __data = it_func_ptr->data;
      
#line 71 
      (*((void (*)(void *, u32 , bool , char const *, struct va_format *))it_func))(__data,level,(_Bool)((bool)((int)in_interrupt) != 0),function,vaf);
      
#line 71 
      it_func_ptr += 1;
      
#line 71 
      ;
      
#line 71 
      if (it_func_ptr->func != (void *)0) 
#line 73 
                                          goto ldv_51051; else 
#line 76 
                                                               goto ldv_51052;
      ldv_51052: 
#line 77 
      ;
    }
    else ;
    
#line 71 
    rcu_read_unlock_sched_notrace();
  }
  else ;
  
#line 71 
  rcu_read_lock_sched_notrace();
  {
    struct tracepoint_func *tmp_6;
    {
      struct tracepoint_func *tmp_5;
      {
        union __anonunion___u_8277 __u_0;
        
#line 71 
        __read_once_size((void const volatile *)(& __tracepoint_iwlwifi_dbg.funcs),(void *)(& __u_0.__c),8);
        
#line 71 
        tmp_5 = __u_0.__val;
      }
      
#line 71 
      struct tracepoint_func *_________p1_0 = tmp_5;
      
#line 71 
      tmp_6 = _________p1_0;
    }
    
#line 71 
    struct tracepoint_func *________p1_0 = tmp_6;
    {
      bool __warned_0;
      int tmp_7;
      
#line 71 
      tmp_7 = debug_lockdep_rcu_enabled();
      
#line 71 
      if (tmp_7 != 0) {
        
#line 71 
        if (! __warned_0) {
          int tmp_8;
          
#line 71 
          tmp_8 = rcu_read_lock_sched_held();
          
#line 71 
          if (tmp_8 == 0) {
            
#line 71 
            __warned_0 = (_Bool)1;
            
#line 71 
            lockdep_rcu_suspicious("/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-devtrace-msg.h",90,"suspicious rcu_dereference_check() usage");
          }
          else ;
        }
        else ;
      }
      else ;
    }
    
#line 71 
    struct tracepoint_func *tmp_9 = ________p1_0;
  }
  
#line 71 
  rcu_read_unlock_sched_notrace();
  
#line 73 
  return;
}


#line 86  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
void __iwl_warn(struct device *dev, char const *fmt , ...)
{
  va_list args;
  
#line 86 
  struct va_format vaf = {.fmt = fmt, .va = (va_list *)0};
  
#line 86 
  __builtin_va_start((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 86 
  vaf.va = & args;
  
#line 86 
  dev_warn((struct device const *)dev,"%pV",& vaf);
  
#line 86 
  trace_iwlwifi_warn(& vaf);
  
#line 86 
  __builtin_va_end((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 87 
  return;
}


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
static char const __kstrtab___iwl_warn[11U] = {(char)'_', (char)'_', (char)'i', (char)'w', (char)'l', (char)'_', (char)'w', (char)'a', (char)'r', (char)'n', (char)'\000'};

#line 87 
struct kernel_symbol const __ksymtab___iwl_warn;


#line 87  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
struct kernel_symbol const __ksymtab___iwl_warn = {.value = (unsigned long)(& __iwl_warn), .name = (char const *)(& __kstrtab___iwl_warn)};

#line 88  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
void __iwl_info(struct device *dev, char const *fmt , ...)
{
  va_list args;
  
#line 88 
  struct va_format vaf = {.fmt = fmt, .va = (va_list *)0};
  
#line 88 
  __builtin_va_start((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 88 
  vaf.va = & args;
  
#line 88 
  _dev_info((struct device const *)dev,"%pV",& vaf);
  
#line 88 
  trace_iwlwifi_info(& vaf);
  
#line 88 
  __builtin_va_end((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 89 
  return;
}


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
static char const __kstrtab___iwl_info[11U] = {(char)'_', (char)'_', (char)'i', (char)'w', (char)'l', (char)'_', (char)'i', (char)'n', (char)'f', (char)'o', (char)'\000'};

#line 89 
struct kernel_symbol const __ksymtab___iwl_info;


#line 89  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
struct kernel_symbol const __ksymtab___iwl_info = {.value = (unsigned long)(& __iwl_info), .name = (char const *)(& __kstrtab___iwl_info)};

#line 90  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
void __iwl_crit(struct device *dev, char const *fmt , ...)
{
  va_list args;
  
#line 90 
  struct va_format vaf = {.fmt = fmt, .va = (va_list *)0};
  
#line 90 
  __builtin_va_start((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 90 
  vaf.va = & args;
  
#line 90 
  dev_crit((struct device const *)dev,"%pV",& vaf);
  
#line 90 
  trace_iwlwifi_crit(& vaf);
  
#line 90 
  __builtin_va_end((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 91 
  return;
}


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
static char const __kstrtab___iwl_crit[11U] = {(char)'_', (char)'_', (char)'i', (char)'w', (char)'l', (char)'_', (char)'c', (char)'r', (char)'i', (char)'t', (char)'\000'};

#line 91 
struct kernel_symbol const __ksymtab___iwl_crit;


#line 91  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
struct kernel_symbol const __ksymtab___iwl_crit = {.value = (unsigned long)(& __iwl_crit), .name = (char const *)(& __kstrtab___iwl_crit)};

#line 93  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
void __iwl_err(struct device *dev, bool rfkill_prefix, bool trace_only, char const *fmt , ...)
{
  va_list args;
  
#line 96 
  struct va_format vaf = {.fmt = fmt, .va = (va_list *)0};
  
#line 101 
  __builtin_va_start((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 102 
  vaf.va = & args;
  
#line 103 
  if (! trace_only) 
    
#line 104 
    if ((int)rfkill_prefix != 0) 
#line 105 
                                 dev_err((struct device const *)dev,"(RFKILL) %pV",& vaf); else 
                                                                    
#line 107 
                                                                    dev_err((struct device const *)dev,"%pV",& vaf);
  else ;
  
#line 109 
  trace_iwlwifi_err(& vaf);
  
#line 110 
  __builtin_va_end((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 111 
  return;
}


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
static char const __kstrtab___iwl_err[10U] = {(char)'_', (char)'_', (char)'i', (char)'w', (char)'l', (char)'_', (char)'e', (char)'r', (char)'r', (char)'\000'};

#line 112 
struct kernel_symbol const __ksymtab___iwl_err;


#line 112  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
struct kernel_symbol const __ksymtab___iwl_err = {.value = (unsigned long)(& __iwl_err), .name = (char const *)(& __kstrtab___iwl_err)};

#line 115  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
void __iwl_dbg(struct device *dev, u32 level, bool limit, char const *function, char const *fmt , ...)
{
  va_list args;
  bool tmp_1;
  int tmp_3;
  
#line 119 
  struct va_format vaf = {.fmt = fmt, .va = (va_list *)0};
  
#line 124 
  __builtin_va_start((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 125 
  vaf.va = & args;
  
#line 127 
  tmp_1 = iwl_have_debug_level(level);
  
#line 127 
  if ((int)tmp_1 != 0) {
    
#line 128 
    if (! limit) 
#line 127 
                 goto _LOR;
    else {
      int tmp_2;
      
#line 128 
      tmp_2 = net_ratelimit();
      
#line 128 
      if (tmp_2 != 0) {
        int tmp_0;
        int tmp;
        _LOR: { /* sequence */
                
#line 129 
                ;
                
#line 129 
                tmp = preempt_count();
                
#line 129 
                if (((unsigned long)tmp & 2096896UL) != 0UL) 
#line 129 
                                                             tmp_0 = 73; else 
                                                                    
#line 129 
                                                                    tmp_0 = 85;
                
#line 129 
                ;
              }
        
#line 129 
        dev_printk("\001",(struct device const *)dev,"%c %s %pV",tmp_0,function,& vaf);
      }
      else ;
    }
  }
  else ;
  
#line 132 
  ;
  
#line 132 
  tmp_3 = preempt_count();
  
#line 132 
  ;
  
#line 132 
  trace_iwlwifi_dbg(level,(_Bool)(((unsigned long)tmp_3 & 2096896UL) != 0UL),function,& vaf);
  
#line 133 
  __builtin_va_end((__builtin_va_list)((__va_list_tag *)(& args)));
  
#line 134 
  return;
}


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
static char const __kstrtab___iwl_dbg[10U] = {(char)'_', (char)'_', (char)'i', (char)'w', (char)'l', (char)'_', (char)'d', (char)'b', (char)'g', (char)'\000'};

#line 135 
struct kernel_symbol const __ksymtab___iwl_dbg;


#line 135  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/drivers/net/wireless/iwlwifi/iwl-debug.c"
struct kernel_symbol const __ksymtab___iwl_dbg = {.value = (unsigned long)(& __iwl_dbg), .name = (char const *)(& __kstrtab___iwl_dbg)};

#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  
#line 23 
  v->counter += i;
  
#line 24 
  return;
}


#line 27  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  
#line 29 
  v->counter -= i;
  
#line 30 
  return;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  int __retres;
  
#line 35 
  v->counter -= i;
  
#line 36 
  if (v->counter != 0) {
    
#line 37 
    __retres = 0;
    
#line 37 
    goto return_label;
  }
  else ;
  
#line 39 
  __retres = 1;
  return_label: 
#line 39 
                return __retres;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  
#line 45 
  v->counter += 1;
  
#line 46 
  return;
}


#line 49  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  
#line 51 
  v->counter -= 1;
  
#line 52 
  return;
}


#line 55  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  int __retres;
  
#line 57 
  v->counter -= 1;
  
#line 58 
  if (v->counter != 0) {
    
#line 59 
    __retres = 0;
    
#line 59 
    goto return_label;
  }
  else ;
  
#line 61 
  __retres = 1;
  return_label: 
#line 61 
                return __retres;
}


#line 65  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  int __retres;
  
#line 67 
  v->counter += 1;
  
#line 68 
  if (v->counter != 0) {
    
#line 69 
    __retres = 0;
    
#line 69 
    goto return_label;
  }
  else ;
  
#line 71 
  __retres = 1;
  return_label: 
#line 71 
                return __retres;
}


#line 75  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  int __retres;
  
#line 77 
  v->counter += i;
  
#line 78 
  __retres = v->counter;
  
#line 78 
  return __retres;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  int __retres;
  
#line 84 
  v->counter += i;
  
#line 85 
  __retres = v->counter < 0;
  
#line 85 
  return __retres;
}


#line 89  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  int __retres;
  
#line 91 
  *v = (short)((unsigned int)*v + 1U);
  
#line 92 
  __retres = (int)*v;
  
#line 92 
  return __retres;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device const *dev);


#line 24 
int ldv_dev_set_drvdata(struct device *dev, void *data);


#line 30  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_xmalloc(size_t size);


#line 31 
void *ldv_xzalloc(size_t size);


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
struct ldv_list_element global_list = {.data = (void *)0, .next = (struct ldv_list_element *)0};

#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static ldv_list_ptr ldv_list_create(void *data)
{
  
#line 35 
  ldv_list_ptr list = (struct ldv_list_element *)0;
  
#line 37 
  list = (ldv_list_ptr)ldv_xmalloc(16UL);
  
#line 39 
  list->data = data;
  
#line 40 
  list->next = (struct ldv_list_element *)0;
  
#line 42 
  return list;
}


#line 45  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memlist.h"
__inline static void ldv_save_pointer(void *data)
{
  ldv_list_ptr element;
  ldv_list_ptr cached;
  
#line 50 
  if (global_list.data == (void *)0) {
    
#line 51 
    element = & global_list;
    
#line 52 
    element->data = data;
  }
  else {
    
#line 54 
    element = ldv_list_create(data);
    
#line 55 
    cached = global_list.next;
    
#line 56 
    global_list.next = element;
    
#line 57 
    element->next = cached;
  }
  
#line 60 
  return;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device const *dev)
{
  void *__retres;
  
#line 30 
  if (dev != (struct device const *)0 && dev->p != (struct device_private *)0) {
    
#line 31 
    __retres = (dev->p)->driver_data;
    
#line 31 
    goto return_label;
  }
  else ;
  
#line 33 
  __retres = (void *)0;
  return_label: 
#line 33 
                return __retres;
}


#line 42  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  int __retres;
  
#line 44 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  
#line 45 
  ldv_save_pointer((void *)dev->p);
  
#line 46 
  (dev->p)->driver_data = data;
  
#line 48 
  __retres = 0;
  
#line 48 
  return __retres;
}


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_zalloc(size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  struct spi_master *__retres;
  struct spi_master *master;
  
#line 27 
  master = (struct spi_master *)ldv_zalloc((unsigned long)size + 2192UL);
  
#line 29 
  if (master == (struct spi_master *)0) {
    
#line 30 
    __retres = (struct spi_master *)0;
    
#line 30 
    goto return_label;
  }
  else ;
  
#line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  
#line 34 
  __retres = master;
  return_label: 
#line 34 
                return __retres;
}


#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/err.h"
long ldv_is_err_or_null(void const *ptr);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_assume(int);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err(void const *ptr)
{
  long __retres;
  
#line 23 
  __retres = (long)((unsigned long)ptr > 4294967295UL);
  
#line 23 
  return __retres;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  void *__retres;
  
#line 28 
  __VERIFIER_assume(error < 0L);
  
#line 29 
  __retres = (void *)(4294967295L - error);
  
#line 29 
  return __retres;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void const *ptr)
{
  long __retres;
  
#line 34 
  __VERIFIER_assume((unsigned long)ptr > 4294967295UL);
  
#line 35 
  __retres = (long)(4294967295UL - (unsigned long)ptr);
  
#line 35 
  return __retres;
}


#line 38  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_is_err_or_null(void const *ptr)
{
  long __retres;
  int tmp_0;
  
#line 40 
  if (ptr == (void const *)0) 
#line 40 
                              tmp_0 = 1;
  else {
    long tmp;
    
#line 40 
    tmp = ldv_is_err(ptr);
    
#line 40 
    if (tmp != 0L) 
#line 40 
                   tmp_0 = 1; else 
#line 40 
                                   tmp_0 = 0;
  }
  
#line 40 
  __retres = (long)tmp_0;
  
#line 40 
  return __retres;
}


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/panic.h"
void ldv_panic(void);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  
#line 23 
  __VERIFIER_assume(0);
  
#line 24 
  return;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void);


#line 42 
void ldv_switch_to_process_context(void);


#line 50 
bool ldv_in_interrupt_context(void);


#line 112 
int ldv_post_init(int init_ret_val);


#line 132 
int ldv_post_probe(int probe_ret_val);


#line 133 
void ldv_check_return_value_probe(int);


#line 141 
int ldv_filter_err_code(int ret_val);


#line 25  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;

#line 28  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void)
{
  
#line 30 
  __ldv_in_interrupt_context = (_Bool)1;
  
#line 31 
  return;
}


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
void ldv_switch_to_process_context(void)
{
  
#line 36 
  __ldv_in_interrupt_context = (_Bool)0;
  
#line 37 
  return;
}


#line 39  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
bool ldv_in_interrupt_context(void)
{
  
#line 41 
  return __ldv_in_interrupt_context;
}


#line 44  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
static int ldv_filter_positive_int(int val)
{
  
#line 46 
  __VERIFIER_assume(val <= 0);
  
#line 47 
  return val;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_init(int init_ret_val)
{
  int tmp;
  
#line 56 
  tmp = ldv_filter_positive_int(init_ret_val);
  
#line 56 
  return tmp;
}


#line 60  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val)
{
  int tmp;
  
#line 62 
  ldv_check_return_value_probe(probe_ret_val);
  
#line 63 
  tmp = ldv_filter_positive_int(probe_ret_val);
  
#line 63 
  return tmp;
}


#line 67  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val)
{
  int tmp;
  
#line 69 
  tmp = ldv_filter_positive_int(ret_val);
  
#line 69 
  return tmp;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/slab.h"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);


#line 28 
void ldv_check_alloc_flags(gfp_t);


#line 29 
void ldv_after_alloc(void *);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *ldv_malloc(size_t size);


#line 24 
void *ldv_calloc(size_t nmemb, size_t size);


#line 21  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 25 
  ldv_check_alloc_flags(flags);
  
#line 26 
  res = ldv_malloc(size);
  
#line 27 
  ldv_after_alloc(res);
  
#line 29 
  return res;
}


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 36 
  ldv_check_alloc_flags(flags);
  
#line 37 
  res = ldv_calloc(n,size);
  
#line 38 
  ldv_after_alloc(res);
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  void *res;
  
#line 47 
  ldv_check_alloc_flags(flags);
  
#line 48 
  res = ldv_zalloc(size);
  
#line 49 
  ldv_after_alloc(res);
  
#line 51 
  return res;
}


#line 54  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  void *res;
  
#line 58 
  ldv_check_alloc_flags(flags);
  
#line 59 
  res = ldv_malloc(n * size);
  
#line 60 
  ldv_after_alloc(res);
  
#line 62 
  return res;
}


#line 26  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void ldv_free(void *s);


#line 35 
void *ldv_malloc_unknown_size(void);


#line 36 
void *ldv_calloc_unknown_size(void);


#line 37 
void *ldv_zalloc_unknown_size(void);


#line 40 
void *ldv_reference_malloc(size_t size);


#line 41 
void *ldv_reference_calloc(size_t nmemb, size_t size);


#line 42 
void *ldv_reference_zalloc(size_t size);


#line 43 
void ldv_reference_free(void *s);


#line 47 
void *ldv_reference_xmalloc(size_t size);


#line 48 
void *ldv_reference_xzalloc(size_t size);


#line 52 
void *ldv_reference_malloc_unknown_size(void);


#line 53 
void *ldv_reference_calloc_unknown_size(void);


#line 54 
void *ldv_reference_zalloc_unknown_size(void);


#line 61 
void *ldv_xmalloc_unknown_size(size_t size);


#line 32  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);


#line 34  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  void *res;
  
#line 37 
  res = ldv_reference_malloc(size);
  
#line 38 
  if (res != (void *)0) {
    long tmp;
    
#line 39 
    tmp = ldv_is_err((void const *)res);
    
#line 39 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 40 
  return res;
}


#line 43  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  void *res;
  
#line 46 
  res = ldv_reference_calloc(nmemb,size);
  
#line 47 
  if (res != (void *)0) {
    long tmp;
    
#line 48 
    tmp = ldv_is_err((void const *)res);
    
#line 48 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 49 
  return res;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  void *res;
  
#line 55 
  res = ldv_reference_zalloc(size);
  
#line 56 
  if (res != (void *)0) {
    long tmp;
    
#line 57 
    tmp = ldv_is_err((void const *)res);
    
#line 57 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 58 
  return res;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  
#line 63 
  ldv_reference_free(s);
  
#line 64 
  return;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 69 
  res = ldv_reference_xmalloc(size);
  
#line 70 
  tmp = ldv_is_err((void const *)res);
  
#line 70 
  __VERIFIER_assume(tmp == 0L);
  
#line 71 
  return res;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  void *res;
  long tmp;
  
#line 77 
  res = ldv_reference_xzalloc(size);
  
#line 78 
  tmp = ldv_is_err((void const *)res);
  
#line 78 
  __VERIFIER_assume(tmp == 0L);
  
#line 79 
  return res;
}


#line 82  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  void *res;
  
#line 85 
  res = ldv_reference_malloc_unknown_size();
  
#line 86 
  if (res != (void *)0) {
    long tmp;
    
#line 87 
    tmp = ldv_is_err((void const *)res);
    
#line 87 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 88 
  return res;
}


#line 91  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  void *res;
  
#line 94 
  res = ldv_reference_calloc_unknown_size();
  
#line 95 
  if (res != (void *)0) {
    long tmp;
    
#line 96 
    tmp = ldv_is_err((void const *)res);
    
#line 96 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  void *res;
  
#line 103 
  res = ldv_reference_zalloc_unknown_size();
  
#line 104 
  if (res != (void *)0) {
    long tmp;
    
#line 105 
    tmp = ldv_is_err((void const *)res);
    
#line 105 
    __VERIFIER_assume(tmp == 0L);
  }
  else ;
  
#line 106 
  return res;
}


#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  void *res;
  long tmp;
  
#line 112 
  res = ldv_reference_xmalloc_unknown_size(size);
  
#line 113 
  tmp = ldv_is_err((void const *)res);
  
#line 113 
  __VERIFIER_assume(tmp == 0L);
  
#line 114 
  return res;
}

long __builtin_expect(long exp, long c);


#line 22  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/common.h"
void __VERIFIER_error(void);


#line 24  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
long __builtin_expect(long exp, long c)
{
  
#line 26 
  return exp;
}


#line 35  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  
#line 37 
  __VERIFIER_error();
  
#line 38 
  return;
}


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.h"
int ldv_undef_int(void);


#line 24 
int ldv_undef_long(void);


#line 25 
unsigned int ldv_undef_uint(void);


#line 26 
unsigned long ldv_undef_ulong(void);


#line 27 
unsigned long long ldv_undef_ulonglong(void);


#line 28 
void *ldv_undef_ptr(void);


#line 31 
int ldv_undef_int_positive(void);


#line 34 
int ldv_undef_int_negative(void);


#line 37 
int ldv_undef_int_nonpositive(void);


#line 40 
void *ldv_undef_ptr_non_null(void);


#line 29  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __VERIFIER_nondet_int(void);


#line 31 
long __VERIFIER_nondet_long(void);


#line 38 
unsigned int __VERIFIER_nondet_uint(void);


#line 41 
unsigned long __VERIFIER_nondet_ulong(void);


#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);


#line 43 
void *__VERIFIER_nondet_pointer(void);


#line 46  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  int tmp;
  
#line 48 
  tmp = __VERIFIER_nondet_int();
  
#line 48 
  return tmp;
}


#line 51  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_long(void)
{
  int __retres;
  long tmp;
  
#line 53 
  tmp = __VERIFIER_nondet_long();
  
#line 53 
  __retres = (int)tmp;
  
#line 53 
  return __retres;
}


#line 56  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  unsigned int tmp;
  
#line 58 
  tmp = __VERIFIER_nondet_uint();
  
#line 58 
  return tmp;
}


#line 61  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  void *tmp;
  
#line 63 
  tmp = __VERIFIER_nondet_pointer();
  
#line 63 
  return tmp;
}


#line 66  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp;
  
#line 68 
  tmp = __VERIFIER_nondet_ulong();
  
#line 68 
  return tmp;
}


#line 71  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  unsigned long long tmp;
  
#line 73 
  tmp = __VERIFIER_nondet_ulonglong();
  
#line 73 
  return tmp;
}


#line 76  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  
#line 78 
  int ret = ldv_undef_int();
  
#line 80 
  __VERIFIER_assume(ret > 0);
  
#line 82 
  return ret;
}


#line 85  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  
#line 87 
  int ret = ldv_undef_int();
  
#line 89 
  __VERIFIER_assume(ret < 0);
  
#line 91 
  return ret;
}


#line 94  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  
#line 96 
  int ret = ldv_undef_int();
  
#line 98 
  __VERIFIER_assume(ret <= 0);
  
#line 100 
  return ret;
}


#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  
#line 105 
  void *ret = ldv_undef_ptr();
  
#line 107 
  __VERIFIER_assume(ret != (void *)0);
  
#line 109 
  return ret;
}


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/memory.h"
void *external_allocated_data(void);


#line 45 
void *ldv_reference_realloc(void *ptr, size_t size);


#line 23  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *malloc(size_t);


#line 24 
void *calloc(size_t, size_t);


#line 25 
void free(void *);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 37 
  tmp = ldv_undef_int();
  
#line 37 
  if (tmp != 0) {
    
#line 39 
    res = malloc(size);
    
#line 40 
    __VERIFIER_assume(res != (void *)0);
    
#line 41 
    __retres = res;
    
#line 41 
    goto return_label;
  }
  else {
    
#line 44 
    __retres = (void *)0;
    
#line 44 
    goto return_label;
  }
  return_label: 
#line 37 
                return __retres;
}


#line 47  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  void *tmp;
  
#line 49 
  tmp = calloc(nmemb,size);
  
#line 49 
  return tmp;
}


#line 52  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  void *tmp;
  
#line 54 
  tmp = calloc(1UL,size);
  
#line 54 
  return tmp;
}


#line 57  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  
#line 59 
  free(s);
  
#line 60 
  return;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 66 
  if (ptr != (void *)0 && size == 0UL) {
    
#line 67 
    free(ptr);
    
#line 68 
    __retres = (void *)0;
    
#line 68 
    goto return_label;
  }
  else ;
  
#line 71 
  if (ptr == (void *)0) {
    
#line 72 
    res = malloc(size);
    
#line 73 
    __retres = res;
    
#line 73 
    goto return_label;
  }
  else ;
  
#line 76 
  tmp = ldv_undef_int();
  
#line 76 
  if (tmp != 0) {
    
#line 78 
    res = malloc(size);
    
#line 79 
    __VERIFIER_assume(res != (void *)0);
    
#line 81 
    memcpy(res,(void const *)ptr,size);
    
#line 82 
    free(ptr);
    
#line 84 
    __retres = res;
    
#line 84 
    goto return_label;
  }
  else {
    
#line 87 
    __retres = (void *)0;
    
#line 87 
    goto return_label;
  }
  return_label: 
#line 76 
                return __retres;
}


#line 90  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  void *res;
  
#line 94 
  res = malloc(size);
  
#line 95 
  __VERIFIER_assume(res != (void *)0);
  
#line 97 
  return res;
}


#line 100  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  void *res;
  
#line 104 
  res = calloc(1UL,size);
  
#line 105 
  __VERIFIER_assume(res != (void *)0);
  
#line 107 
  return res;
}


#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 114 
  tmp = ldv_undef_int();
  
#line 114 
  if (tmp != 0) {
    
#line 115 
    res = external_allocated_data();
    
#line 116 
    __VERIFIER_assume(res != (void *)0);
    
#line 117 
    __retres = res;
    
#line 117 
    goto return_label;
  }
  else {
    
#line 120 
    __retres = (void *)0;
    
#line 120 
    goto return_label;
  }
  return_label: 
#line 114 
                return __retres;
}


#line 123  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  void *__retres;
  void *res;
  int tmp;
  
#line 127 
  tmp = ldv_undef_int();
  
#line 127 
  if (tmp != 0) {
    
#line 128 
    res = external_allocated_data();
    
#line 129 
    memset(res,0,8UL);
    
#line 130 
    __VERIFIER_assume(res != (void *)0);
    
#line 131 
    __retres = res;
    
#line 131 
    goto return_label;
  }
  else {
    
#line 134 
    __retres = (void *)0;
    
#line 134 
    goto return_label;
  }
  return_label: 
#line 127 
                return __retres;
}


#line 137  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  void *tmp;
  
#line 139 
  tmp = ldv_reference_calloc_unknown_size();
  
#line 139 
  return tmp;
}


#line 142  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  void *res;
  
#line 146 
  res = external_allocated_data();
  
#line 147 
  __VERIFIER_assume(res != (void *)0);
  
#line 149 
  return res;
}


#line 62  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/linux/ldv/common.h"
void ldv_initialize(void);


#line 123 
void ldv_pre_probe(void);


#line 33  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/root/specifications/verifier/thread.h"
int pthread_create(pthread_t *, pthread_attr_t const *, void *(*)(void *), void *);


#line 37 
int pthread_join(pthread_t, void **);


#line 23  "/home/debian/klever-inst/klever/build bases/linux-4.2.6/Storage/home/debian/klever-inst/tmp-dir/linux-4.2.6/include/linux/err.h"
__inline static void *ERR_PTR_2(long error)
{
  void *__retres;
  
#line 25 
  __retres = (void *)error;
  
#line 25 
  return __retres;
}


#line 74  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_15(void *arg0);


#line 75 
void ldv_dispatch_instance_deregister_2_1(struct timer_list *arg0);


#line 78 
void *ldv_character_driver_scenario_12(void *arg0);


#line 79 
void ldv_dispatch_instance_deregister_8_1(struct timer_list *arg0);


#line 80 
int main(void);


#line 81 
void ldv_dispatch_irq_deregister_3_1(int arg0);


#line 82 
void *ldv_character_driver_scenario_17(void *arg0);


#line 83 
void *ldv_character_driver_scenario_11(void *arg0);


#line 85 
void ldv_dispatch_deregister_9_1(struct pci_driver *arg0);


#line 86 
void *ldv_character_driver_scenario_18(void *arg0);


#line 88 
void ldv_dispatch_irq_register_5_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);


#line 90 
void *ldv_pci_scenario_13(void *arg0);


#line 92 
void *ldv_timer_scenario_19(void *arg0);


#line 93 
void ldv_dispatch_register_10_3(struct file_operations *arg0);


#line 94 
void *ldv_initialization_1(void *arg0);


#line 95 
void *ldv_pm_ops_scenario_16(void *arg0);


#line 96 
void ldv_dispatch_instance_register_4_3(struct timer_list *arg0);


#line 97 
void ldv_dispatch_register_6_3(struct pci_driver *arg0);


#line 98 
void *ldv_interrupt_scenario_14(void *arg0);


#line 102  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_14;

#line 103  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_12;

#line 104  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_13;

#line 105  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_16;

#line 106  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_11;

#line 107  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_17;

#line 108  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_15;

#line 109  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_19;

#line 110  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
pthread_t ldv_thread_18;

#line 114  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_del_timer_sync(struct timer_list *arg0)
{
  int __retres;
  struct timer_list *ldv_8_timer_list;
  
#line 120 
  ldv_8_timer_list = arg0;
  
#line 124 
  ldv_dispatch_instance_deregister_8_1(ldv_8_timer_list);
  
#line 125 
  ;
  
#line 125 
  __retres = 0;
  
#line 125 
  return __retres;
}


#line 133  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_del_timer(struct timer_list *arg0)
{
  int __retres;
  struct timer_list *ldv_2_timer_list;
  
#line 139 
  ldv_2_timer_list = arg0;
  
#line 143 
  ldv_dispatch_instance_deregister_2_1(ldv_2_timer_list);
  
#line 144 
  ;
  
#line 144 
  __retres = 0;
  
#line 144 
  return __retres;
}


#line 152  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_15(void *arg0)
{
  void *__retres;
  struct file *ldv_15_resource_1;
  int ldv_15_ldv_param_2_3;
  long long ldv_15_ldv_param_1_2;
  char *ldv_15_ldv_param_1_4;
  unsigned long ldv_15_size_cnt;
  long long *ldv_15_ldv_param_3_5;
  struct inode *ldv_15_resource_0;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 161 
  struct file_operations *ldv_15_container = ldv_emg_alias_iwl_dbgfs_csr_ops_2;
  
#line 162 
  int ldv_15_ret = ldv_undef_int();
  
#line 165 
  struct ldv_struct_character_driver_scenario_11 *data = (struct ldv_struct_character_driver_scenario_11 *)arg0;
  
#line 169 
  ldv_15_ret = ldv_undef_int();
  
#line 172 
  if (data != (struct ldv_struct_character_driver_scenario_11 *)0) {
    
#line 173 
    ldv_15_container = data->arg0;
    
#line 174 
    ldv_free((void *)data);
  }
  else ;
  
#line 179 
  ldv_15_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 180 
  tmp_1 = ldv_undef_int();
  
#line 180 
  ldv_15_size_cnt = (unsigned long)tmp_1;
  
#line 187 
  goto ldv_main_15;
  
#line 189 
  __retres = (void *)0;
  
#line 189 
  goto return_label;
  ldv_main_15: 
#line 192 
  ;
  
#line 195 
  tmp_3 = ldv_undef_int();
  
#line 195 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 198 
    ldv_15_ret = (*ldv_emg_alias_simple_open_5)(ldv_15_resource_0,ldv_15_resource_1);
    
#line 200 
    ldv_15_ret = ldv_filter_err_code(ldv_15_ret);
    
#line 203 
    tmp_2 = ldv_undef_int();
    
#line 203 
    if (tmp_2 != 0) {
      
#line 205 
      __VERIFIER_assume(ldv_15_ret == 0);
      
#line 212 
      goto ldv_call_15;
    }
    else {
      
#line 216 
      __VERIFIER_assume(ldv_15_ret != 0);
      
#line 223 
      goto ldv_main_15;
    }
  }
  else {
    
#line 228 
    ldv_free((void *)ldv_15_resource_0);
    
#line 236 
    __retres = (void *)0;
    
#line 236 
    goto return_label;
  }
  
#line 239 
  __retres = (void *)0;
  
#line 239 
  goto return_label;
  ldv_call_15: 
#line 242 
  ;
  
#line 245 
  tmp_4 = ldv_undef_int();
  
#line 245 
  switch (tmp_4) {
    case 1: 
#line 246 
    ;
    
#line 252 
    (*ldv_emg_alias_generic_file_llseek_3)(ldv_15_resource_1,ldv_15_ldv_param_1_2,ldv_15_ldv_param_2_3);
    
#line 262 
    goto ldv_call_15;
    case 2: 
#line 265 
    ;
    
#line 267 
    ldv_15_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 268 
    ldv_15_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 277 
    __VERIFIER_assume(ldv_15_size_cnt <= 2147479552UL);
    
#line 279 
    ldv_emg_wrapper_iwl_dbgfs_csr_write_4(ldv_15_resource_1,ldv_15_ldv_param_1_4,ldv_15_size_cnt,ldv_15_ldv_param_3_5);
    
#line 283 
    ldv_free((void *)ldv_15_ldv_param_1_4);
    
#line 284 
    ldv_free((void *)ldv_15_ldv_param_3_5);
    
#line 291 
    goto ldv_call_15;
    case 3: 
#line 294 
    ;
    
#line 296 
    if (ldv_15_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 298 
      (*(ldv_15_container->release))(ldv_15_resource_0,ldv_15_resource_1); else ;
    
#line 306 
    goto ldv_main_15;
    default: 
#line 309 
    ;
    
#line 309 
    __VERIFIER_assume(0);
  }
  
#line 312 
  __retres = (void *)0;
  return_label: 
#line 312 
                return __retres;
}


#line 317  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_deregister_2_1(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_19 *cf_arg_19;
  int tmp;
  
#line 320 
  tmp = ldv_undef_int();
  
#line 320 
  switch (tmp) {
    case 0: 
#line 321 
    ;
    
#line 322 
    ret = pthread_join(ldv_thread_19,(void **)0);
    
#line 323 
    __VERIFIER_assume(ret == 0);
    
#line 324 
    goto ldv_32667;
    default: 
#line 326 
    ;
    
#line 326 
    __VERIFIER_assume(0);
  }
  ldv_32667: 
#line 327 
  ;
  
#line 328 
  return;
}


#line 332  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  int __retres;
  int tmp_0;
  
#line 335 
  struct pci_driver *ldv_6_pci_driver = ldv_emg_alias_iwl_pci_driver_2;
  
#line 339 
  tmp_0 = ldv_undef_int();
  
#line 339 
  if (tmp_0 != 0) {
    
#line 341 
    ldv_6_pci_driver = arg0;
    
#line 345 
    ldv_dispatch_register_6_3(ldv_6_pci_driver);
    
#line 349 
    __retres = 0;
    
#line 349 
    goto return_label;
  }
  else {
    int tmp;
    
#line 356 
    tmp = ldv_undef_int_negative();
    
#line 356 
    __retres = tmp;
    
#line 356 
    goto return_label;
  }
  return_label: 
#line 339 
                return __retres;
}


#line 366  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
struct dentry *ldv_emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4)
{
  struct dentry *__retres;
  struct dentry *ldv_10_dentry;
  struct file_operations *ldv_10_file_operations;
  int tmp_1;
  
#line 374 
  tmp_1 = ldv_undef_int();
  
#line 374 
  if (tmp_1 != 0) {
    
#line 376 
    ldv_10_dentry = (struct dentry *)ldv_xmalloc_unknown_size(0UL);
    
#line 377 
    ldv_10_file_operations = arg4;
    
#line 381 
    ldv_dispatch_register_10_3(ldv_10_file_operations);
    
#line 385 
    __retres = ldv_10_dentry;
    
#line 385 
    goto return_label;
  }
  else {
    struct dentry *tmp_0;
    
#line 392 
    tmp_0 = (struct dentry *)ERR_PTR_2(-19L);
    
#line 392 
    __retres = tmp_0;
    
#line 392 
    goto return_label;
  }
  return_label: 
#line 374 
                return __retres;
}


#line 402  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_12(void *arg0)
{
  void *__retres;
  struct file *ldv_12_resource_1;
  int ldv_12_ldv_param_2_3;
  long long ldv_12_ldv_param_1_2;
  char *ldv_12_ldv_param_1_4;
  struct inode *ldv_12_resource_0;
  unsigned long ldv_12_size_cnt;
  long long *ldv_12_ldv_param_3_5;
  char *ldv_12_ldv_param_1_6;
  long long *ldv_12_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 413 
  struct file_operations *ldv_12_container = ldv_emg_alias_iwl_dbgfs_interrupt_ops_2;
  
#line 414 
  int ldv_12_ret = ldv_undef_int();
  
#line 417 
  struct ldv_struct_character_driver_scenario_11 *data = (struct ldv_struct_character_driver_scenario_11 *)arg0;
  
#line 421 
  ldv_12_ret = ldv_undef_int();
  
#line 424 
  if (data != (struct ldv_struct_character_driver_scenario_11 *)0) {
    
#line 425 
    ldv_12_container = data->arg0;
    
#line 426 
    ldv_free((void *)data);
  }
  else ;
  
#line 431 
  ldv_12_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 432 
  tmp_1 = ldv_undef_int();
  
#line 432 
  ldv_12_size_cnt = (unsigned long)tmp_1;
  
#line 439 
  goto ldv_main_12;
  
#line 441 
  __retres = (void *)0;
  
#line 441 
  goto return_label;
  ldv_main_12: 
#line 444 
  ;
  
#line 447 
  tmp_3 = ldv_undef_int();
  
#line 447 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 450 
    ldv_12_ret = (*ldv_emg_alias_simple_open_5)(ldv_12_resource_0,ldv_12_resource_1);
    
#line 452 
    ldv_12_ret = ldv_filter_err_code(ldv_12_ret);
    
#line 455 
    tmp_2 = ldv_undef_int();
    
#line 455 
    if (tmp_2 != 0) {
      
#line 457 
      __VERIFIER_assume(ldv_12_ret == 0);
      
#line 464 
      goto ldv_call_12;
    }
    else {
      
#line 468 
      __VERIFIER_assume(ldv_12_ret != 0);
      
#line 475 
      goto ldv_main_12;
    }
  }
  else {
    
#line 480 
    ldv_free((void *)ldv_12_resource_0);
    
#line 488 
    __retres = (void *)0;
    
#line 488 
    goto return_label;
  }
  
#line 491 
  __retres = (void *)0;
  
#line 491 
  goto return_label;
  ldv_call_12: 
#line 494 
  ;
  
#line 497 
  tmp_4 = ldv_undef_int();
  
#line 497 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 498 
    ;
    
#line 500 
    ldv_12_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 501 
    ldv_12_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 510 
    __VERIFIER_assume(ldv_12_size_cnt <= 2147479552UL);
    
#line 512 
    ldv_emg_wrapper_iwl_dbgfs_interrupt_write_4(ldv_12_resource_1,ldv_12_ldv_param_1_6,ldv_12_size_cnt,ldv_12_ldv_param_3_7);
    
#line 516 
    ldv_free((void *)ldv_12_ldv_param_1_6);
    
#line 517 
    ldv_free((void *)ldv_12_ldv_param_3_7);
    
#line 524 
    goto ldv_call_12;
    case 2: 
#line 527 
    ;
    
#line 529 
    if (ldv_12_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 531 
      (*(ldv_12_container->release))(ldv_12_resource_0,ldv_12_resource_1); else ;
    
#line 539 
    goto ldv_main_12;
    case 3: 
#line 542 
    ;
    
#line 546 
    tmp_9 = ldv_undef_int();
    
#line 546 
    if (tmp_9 != 0) 
#line 549 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_12_resource_1,ldv_12_ldv_param_1_2,ldv_12_ldv_param_2_3);
    else {
      
#line 555 
      ldv_12_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 556 
      ldv_12_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 561 
      ldv_emg_wrapper_iwl_dbgfs_interrupt_read_3(ldv_12_resource_1,ldv_12_ldv_param_1_4,ldv_12_size_cnt,ldv_12_ldv_param_3_5);
      
#line 565 
      ldv_free((void *)ldv_12_ldv_param_3_5);
      
#line 566 
      ldv_free((void *)ldv_12_ldv_param_1_4);
    }
    
#line 570 
    goto ldv_32704;
    default: 
#line 572 
    ;
    
#line 572 
    __VERIFIER_assume(0);
  }
  ldv_32704: 
#line 581 
  ;
  
#line 581 
  goto ldv_call_12;
  
#line 583 
  __retres = (void *)0;
  return_label: 
#line 583 
                return __retres;
}


#line 588  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_deregister_8_1(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_19 *cf_arg_19;
  int tmp;
  
#line 591 
  tmp = ldv_undef_int();
  
#line 591 
  switch (tmp) {
    case 0: 
#line 592 
    ;
    
#line 593 
    ret = pthread_join(ldv_thread_19,(void **)0);
    
#line 594 
    __VERIFIER_assume(ret == 0);
    
#line 595 
    goto ldv_32712;
    default: 
#line 597 
    ;
    
#line 597 
    __VERIFIER_assume(0);
  }
  ldv_32712: 
#line 598 
  ;
  
#line 599 
  return;
}


#line 603  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
int main(void)
{
  int __retres;
  
#line 606 
  ldv_initialize();
  
#line 609 
  ldv_initialization_1((void *)0);
  
#line 611 
  __retres = 0;
  
#line 611 
  return __retres;
}


#line 616  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_deregister_3_1(int arg0)
{
  int ret;
  struct ldv_struct_free_irq_3 *cf_arg_14;
  int tmp;
  
#line 619 
  tmp = ldv_undef_int();
  
#line 619 
  switch (tmp) {
    case 0: 
#line 620 
    ;
    
#line 621 
    ret = pthread_join(ldv_thread_14,(void **)0);
    
#line 622 
    __VERIFIER_assume(ret == 0);
    
#line 623 
    goto ldv_32723;
    default: 
#line 625 
    ;
    
#line 625 
    __VERIFIER_assume(0);
  }
  ldv_32723: 
#line 626 
  ;
  
#line 627 
  return;
}


#line 631  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_17(void *arg0)
{
  void *__retres;
  struct file *ldv_17_resource_1;
  int ldv_17_ldv_param_2_3;
  long long ldv_17_ldv_param_1_2;
  char *ldv_17_ldv_param_1_4;
  struct inode *ldv_17_resource_0;
  unsigned long ldv_17_size_cnt;
  long long *ldv_17_ldv_param_3_5;
  char *ldv_17_ldv_param_1_6;
  long long *ldv_17_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 642 
  struct file_operations *ldv_17_container = ldv_emg_alias_iwl_dbgfs_tx_queue_ops_2;
  
#line 643 
  int ldv_17_ret = ldv_undef_int();
  
#line 646 
  struct ldv_struct_character_driver_scenario_11 *data = (struct ldv_struct_character_driver_scenario_11 *)arg0;
  
#line 650 
  ldv_17_ret = ldv_undef_int();
  
#line 653 
  if (data != (struct ldv_struct_character_driver_scenario_11 *)0) {
    
#line 654 
    ldv_17_container = data->arg0;
    
#line 655 
    ldv_free((void *)data);
  }
  else ;
  
#line 660 
  ldv_17_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 661 
  tmp_1 = ldv_undef_int();
  
#line 661 
  ldv_17_size_cnt = (unsigned long)tmp_1;
  
#line 668 
  goto ldv_main_17;
  
#line 670 
  __retres = (void *)0;
  
#line 670 
  goto return_label;
  ldv_main_17: 
#line 673 
  ;
  
#line 676 
  tmp_3 = ldv_undef_int();
  
#line 676 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 679 
    ldv_17_ret = (*ldv_emg_alias_simple_open_5)(ldv_17_resource_0,ldv_17_resource_1);
    
#line 681 
    ldv_17_ret = ldv_filter_err_code(ldv_17_ret);
    
#line 684 
    tmp_2 = ldv_undef_int();
    
#line 684 
    if (tmp_2 != 0) {
      
#line 686 
      __VERIFIER_assume(ldv_17_ret == 0);
      
#line 693 
      goto ldv_call_17;
    }
    else {
      
#line 697 
      __VERIFIER_assume(ldv_17_ret != 0);
      
#line 704 
      goto ldv_main_17;
    }
  }
  else {
    
#line 709 
    ldv_free((void *)ldv_17_resource_0);
    
#line 717 
    __retres = (void *)0;
    
#line 717 
    goto return_label;
  }
  
#line 720 
  __retres = (void *)0;
  
#line 720 
  goto return_label;
  ldv_call_17: 
#line 723 
  ;
  
#line 726 
  tmp_4 = ldv_undef_int();
  
#line 726 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 727 
    ;
    
#line 729 
    ldv_17_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 730 
    ldv_17_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 734 
    if (ldv_17_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 740 
      __VERIFIER_assume(ldv_17_size_cnt <= 2147479552UL);
      
#line 742 
      (*(ldv_17_container->write))(ldv_17_resource_1,(char const *)ldv_17_ldv_param_1_6,ldv_17_size_cnt,ldv_17_ldv_param_3_7);
    }
    else ;
    
#line 747 
    ldv_free((void *)ldv_17_ldv_param_3_7);
    
#line 748 
    ldv_free((void *)ldv_17_ldv_param_1_6);
    
#line 755 
    goto ldv_call_17;
    case 2: 
#line 758 
    ;
    
#line 760 
    if (ldv_17_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 762 
      (*(ldv_17_container->release))(ldv_17_resource_0,ldv_17_resource_1); else ;
    
#line 770 
    goto ldv_main_17;
    case 3: 
#line 773 
    ;
    
#line 777 
    tmp_9 = ldv_undef_int();
    
#line 777 
    if (tmp_9 != 0) 
#line 780 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_17_resource_1,ldv_17_ldv_param_1_2,ldv_17_ldv_param_2_3);
    else {
      
#line 786 
      ldv_17_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 787 
      ldv_17_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 792 
      ldv_emg_wrapper_iwl_dbgfs_tx_queue_read_3(ldv_17_resource_1,ldv_17_ldv_param_1_4,ldv_17_size_cnt,ldv_17_ldv_param_3_5);
      
#line 796 
      ldv_free((void *)ldv_17_ldv_param_3_5);
      
#line 797 
      ldv_free((void *)ldv_17_ldv_param_1_4);
    }
    
#line 801 
    goto ldv_32745;
    default: 
#line 803 
    ;
    
#line 803 
    __VERIFIER_assume(0);
  }
  ldv_32745: 
#line 812 
  ;
  
#line 812 
  goto ldv_call_17;
  
#line 814 
  __retres = (void *)0;
  return_label: 
#line 814 
                return __retres;
}


#line 819  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_11(void *arg0)
{
  void *__retres;
  struct file *ldv_11_resource_1;
  int ldv_11_ldv_param_2_3;
  long long ldv_11_ldv_param_1_2;
  char *ldv_11_ldv_param_1_4;
  struct inode *ldv_11_resource_0;
  unsigned long ldv_11_size_cnt;
  long long *ldv_11_ldv_param_3_5;
  char *ldv_11_ldv_param_1_6;
  long long *ldv_11_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 830 
  struct file_operations *ldv_11_container = ldv_emg_alias_iwl_dbgfs_rx_queue_ops_2;
  
#line 831 
  int ldv_11_ret = ldv_undef_int();
  
#line 834 
  struct ldv_struct_character_driver_scenario_11 *data = (struct ldv_struct_character_driver_scenario_11 *)arg0;
  
#line 838 
  ldv_11_ret = ldv_undef_int();
  
#line 841 
  if (data != (struct ldv_struct_character_driver_scenario_11 *)0) {
    
#line 842 
    ldv_11_container = data->arg0;
    
#line 843 
    ldv_free((void *)data);
  }
  else ;
  
#line 848 
  ldv_11_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 849 
  tmp_1 = ldv_undef_int();
  
#line 849 
  ldv_11_size_cnt = (unsigned long)tmp_1;
  
#line 856 
  goto ldv_main_11;
  
#line 858 
  __retres = (void *)0;
  
#line 858 
  goto return_label;
  ldv_main_11: 
#line 861 
  ;
  
#line 864 
  tmp_3 = ldv_undef_int();
  
#line 864 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 867 
    ldv_11_ret = (*ldv_emg_alias_simple_open_5)(ldv_11_resource_0,ldv_11_resource_1);
    
#line 869 
    ldv_11_ret = ldv_filter_err_code(ldv_11_ret);
    
#line 872 
    tmp_2 = ldv_undef_int();
    
#line 872 
    if (tmp_2 != 0) {
      
#line 874 
      __VERIFIER_assume(ldv_11_ret == 0);
      
#line 881 
      goto ldv_call_11;
    }
    else {
      
#line 885 
      __VERIFIER_assume(ldv_11_ret != 0);
      
#line 892 
      goto ldv_main_11;
    }
  }
  else {
    
#line 897 
    ldv_free((void *)ldv_11_resource_0);
    
#line 905 
    __retres = (void *)0;
    
#line 905 
    goto return_label;
  }
  
#line 908 
  __retres = (void *)0;
  
#line 908 
  goto return_label;
  ldv_call_11: 
#line 911 
  ;
  
#line 914 
  tmp_4 = ldv_undef_int();
  
#line 914 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 915 
    ;
    
#line 917 
    ldv_11_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 918 
    ldv_11_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 922 
    if (ldv_11_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 928 
      __VERIFIER_assume(ldv_11_size_cnt <= 2147479552UL);
      
#line 930 
      (*(ldv_11_container->write))(ldv_11_resource_1,(char const *)ldv_11_ldv_param_1_6,ldv_11_size_cnt,ldv_11_ldv_param_3_7);
    }
    else ;
    
#line 935 
    ldv_free((void *)ldv_11_ldv_param_1_6);
    
#line 936 
    ldv_free((void *)ldv_11_ldv_param_3_7);
    
#line 943 
    goto ldv_call_11;
    case 2: 
#line 946 
    ;
    
#line 948 
    if (ldv_11_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 950 
      (*(ldv_11_container->release))(ldv_11_resource_0,ldv_11_resource_1); else ;
    
#line 958 
    goto ldv_main_11;
    case 3: 
#line 961 
    ;
    
#line 965 
    tmp_9 = ldv_undef_int();
    
#line 965 
    if (tmp_9 != 0) 
#line 968 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_11_resource_1,ldv_11_ldv_param_1_2,ldv_11_ldv_param_2_3);
    else {
      
#line 974 
      ldv_11_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 975 
      ldv_11_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 980 
      ldv_emg_wrapper_iwl_dbgfs_rx_queue_read_3(ldv_11_resource_1,ldv_11_ldv_param_1_4,ldv_11_size_cnt,ldv_11_ldv_param_3_5);
      
#line 984 
      ldv_free((void *)ldv_11_ldv_param_3_5);
      
#line 985 
      ldv_free((void *)ldv_11_ldv_param_1_4);
    }
    
#line 989 
    goto ldv_32767;
    default: 
#line 991 
    ;
    
#line 991 
    __VERIFIER_assume(0);
  }
  ldv_32767: 
#line 1000 
  ;
  
#line 1000 
  goto ldv_call_11;
  
#line 1002 
  __retres = (void *)0;
  return_label: 
#line 1002 
                return __retres;
}


#line 1007  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
_Bool ldv_emg_schedule_work(struct work_struct *arg0)
{
  _Bool __retres;
  struct work_struct *ldv_7_work_struct;
  int tmp;
  
#line 1014 
  tmp = ldv_undef_int();
  
#line 1014 
  if (tmp != 0) {
    
#line 1016 
    ldv_7_work_struct = arg0;
    
#line 1020 
    if (ldv_7_work_struct->func != (void (*)(struct work_struct *))0) 
      
#line 1022 
      (*(ldv_7_work_struct->func))(ldv_7_work_struct); else ;
    
#line 1027 
    __retres = (_Bool)1;
    
#line 1027 
    goto return_label;
  }
  else {
    
#line 1034 
    __retres = (_Bool)0;
    
#line 1034 
    goto return_label;
  }
  return_label: 
#line 1014 
                return __retres;
}


#line 1044  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_deregister_9_1(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_13 *cf_arg_13;
  int tmp;
  
#line 1047 
  tmp = ldv_undef_int();
  
#line 1047 
  switch (tmp) {
    case 0: 
#line 1048 
    ;
    
#line 1049 
    ret = pthread_join(ldv_thread_13,(void **)0);
    
#line 1050 
    __VERIFIER_assume(ret == 0);
    
#line 1051 
    goto ldv_32779;
    default: 
#line 1053 
    ;
    
#line 1053 
    __VERIFIER_assume(0);
  }
  ldv_32779: 
#line 1054 
  ;
  
#line 1055 
  return;
}


#line 1059  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_character_driver_scenario_18(void *arg0)
{
  void *__retres;
  struct file *ldv_18_resource_1;
  int ldv_18_ldv_param_2_3;
  long long ldv_18_ldv_param_1_2;
  char *ldv_18_ldv_param_1_4;
  struct inode *ldv_18_resource_0;
  unsigned long ldv_18_size_cnt;
  long long *ldv_18_ldv_param_3_5;
  char *ldv_18_ldv_param_1_6;
  long long *ldv_18_ldv_param_3_7;
  int tmp_1;
  int tmp_3;
  int tmp_4;
  
#line 1070 
  struct file_operations *ldv_18_container = ldv_emg_alias_iwl_dbgfs_fh_reg_ops_2;
  
#line 1071 
  int ldv_18_ret = ldv_undef_int();
  
#line 1074 
  struct ldv_struct_character_driver_scenario_11 *data = (struct ldv_struct_character_driver_scenario_11 *)arg0;
  
#line 1078 
  ldv_18_ret = ldv_undef_int();
  
#line 1081 
  if (data != (struct ldv_struct_character_driver_scenario_11 *)0) {
    
#line 1082 
    ldv_18_container = data->arg0;
    
#line 1083 
    ldv_free((void *)data);
  }
  else ;
  
#line 1088 
  ldv_18_resource_0 = (struct inode *)ldv_xmalloc_unknown_size(0UL);
  
#line 1089 
  tmp_1 = ldv_undef_int();
  
#line 1089 
  ldv_18_size_cnt = (unsigned long)tmp_1;
  
#line 1096 
  goto ldv_main_18;
  
#line 1098 
  __retres = (void *)0;
  
#line 1098 
  goto return_label;
  ldv_main_18: 
#line 1101 
  ;
  
#line 1104 
  tmp_3 = ldv_undef_int();
  
#line 1104 
  if (tmp_3 != 0) {
    int tmp_2;
    
#line 1107 
    ldv_18_ret = (*ldv_emg_alias_simple_open_5)(ldv_18_resource_0,ldv_18_resource_1);
    
#line 1109 
    ldv_18_ret = ldv_filter_err_code(ldv_18_ret);
    
#line 1112 
    tmp_2 = ldv_undef_int();
    
#line 1112 
    if (tmp_2 != 0) {
      
#line 1114 
      __VERIFIER_assume(ldv_18_ret == 0);
      
#line 1121 
      goto ldv_call_18;
    }
    else {
      
#line 1125 
      __VERIFIER_assume(ldv_18_ret != 0);
      
#line 1132 
      goto ldv_main_18;
    }
  }
  else {
    
#line 1137 
    ldv_free((void *)ldv_18_resource_0);
    
#line 1145 
    __retres = (void *)0;
    
#line 1145 
    goto return_label;
  }
  
#line 1148 
  __retres = (void *)0;
  
#line 1148 
  goto return_label;
  ldv_call_18: 
#line 1151 
  ;
  
#line 1154 
  tmp_4 = ldv_undef_int();
  
#line 1154 
  switch (tmp_4) {
    int tmp_9;
    case 1: 
#line 1155 
    ;
    
#line 1157 
    ldv_18_ldv_param_1_6 = (char *)ldv_xmalloc_unknown_size(0UL);
    
#line 1158 
    ldv_18_ldv_param_3_7 = (long long *)ldv_xmalloc_unknown_size(0UL);
    
#line 1162 
    if (ldv_18_container->write != (ssize_t (*)(struct file *, char const *, size_t , loff_t *))0) {
      
#line 1168 
      __VERIFIER_assume(ldv_18_size_cnt <= 2147479552UL);
      
#line 1170 
      (*(ldv_18_container->write))(ldv_18_resource_1,(char const *)ldv_18_ldv_param_1_6,ldv_18_size_cnt,ldv_18_ldv_param_3_7);
    }
    else ;
    
#line 1175 
    ldv_free((void *)ldv_18_ldv_param_1_6);
    
#line 1176 
    ldv_free((void *)ldv_18_ldv_param_3_7);
    
#line 1183 
    goto ldv_call_18;
    case 2: 
#line 1186 
    ;
    
#line 1188 
    if (ldv_18_container->release != (int (*)(struct inode *, struct file *))0) 
      
#line 1190 
      (*(ldv_18_container->release))(ldv_18_resource_0,ldv_18_resource_1); else ;
    
#line 1198 
    goto ldv_main_18;
    case 3: 
#line 1201 
    ;
    
#line 1205 
    tmp_9 = ldv_undef_int();
    
#line 1205 
    if (tmp_9 != 0) 
#line 1208 
                    (*ldv_emg_alias_generic_file_llseek_3)(ldv_18_resource_1,ldv_18_ldv_param_1_2,ldv_18_ldv_param_2_3);
    else {
      
#line 1214 
      ldv_18_ldv_param_1_4 = (char *)ldv_xmalloc_unknown_size(0UL);
      
#line 1215 
      ldv_18_ldv_param_3_5 = (long long *)ldv_xmalloc_unknown_size(0UL);
      
#line 1220 
      ldv_emg_wrapper_iwl_dbgfs_fh_reg_read_3(ldv_18_resource_1,ldv_18_ldv_param_1_4,ldv_18_size_cnt,ldv_18_ldv_param_3_5);
      
#line 1224 
      ldv_free((void *)ldv_18_ldv_param_1_4);
      
#line 1225 
      ldv_free((void *)ldv_18_ldv_param_3_5);
    }
    
#line 1229 
    goto ldv_32801;
    default: 
#line 1231 
    ;
    
#line 1231 
    __VERIFIER_assume(0);
  }
  ldv_32801: 
#line 1240 
  ;
  
#line 1240 
  goto ldv_call_18;
  
#line 1242 
  __retres = (void *)0;
  return_label: 
#line 1242 
                return __retres;
}


#line 1247  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_request_threaded_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), unsigned long arg3, char *arg4, void *arg5)
{
  int __retres;
  int ldv_5_line;
  void *ldv_5_data;
  int tmp_0;
  
#line 1252 
  enum irqreturn (*ldv_5_callback)(int , void *) = & iwl_pcie_isr;
  
#line 1253 
  enum irqreturn (*ldv_5_thread)(int , void *) = & iwl_pcie_irq_handler;
  
#line 1257 
  tmp_0 = ldv_undef_int();
  
#line 1257 
  if (tmp_0 != 0) {
    
#line 1259 
    ldv_5_line = (int)arg0;
    
#line 1260 
    ldv_5_callback = arg1;
    
#line 1261 
    ldv_5_thread = arg2;
    
#line 1262 
    ldv_5_data = arg5;
    
#line 1266 
    ldv_dispatch_irq_register_5_3(ldv_5_line,ldv_5_callback,ldv_5_thread,ldv_5_data);
    
#line 1270 
    __retres = 0;
    
#line 1270 
    goto return_label;
  }
  else {
    int tmp;
    
#line 1277 
    tmp = ldv_undef_int_negative();
    
#line 1277 
    __retres = tmp;
    
#line 1277 
    goto return_label;
  }
  return_label: 
#line 1257 
                return __retres;
}


#line 1287  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_irq_register_5_3(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  int ret;
  struct ldv_struct_interrupt_scenario_14 *cf_arg_14;
  int tmp;
  
#line 1290 
  tmp = ldv_undef_int();
  
#line 1290 
  switch (tmp) {
    case 0: 
#line 1291 
    ;
    
#line 1292 
    cf_arg_14 = (struct ldv_struct_interrupt_scenario_14 *)ldv_xmalloc(32UL);
    
#line 1293 
    cf_arg_14->arg0 = arg0;
    
#line 1294 
    cf_arg_14->arg1 = arg1;
    
#line 1295 
    cf_arg_14->arg2 = arg2;
    
#line 1296 
    cf_arg_14->arg3 = arg3;
    
#line 1297 
    ret = pthread_create(& ldv_thread_14,(pthread_attr_t const *)0,& ldv_interrupt_scenario_14,(void *)cf_arg_14);
    
#line 1298 
    __VERIFIER_assume(ret == 0);
    
#line 1299 
    goto ldv_32836;
    default: 
#line 1301 
    ;
    
#line 1301 
    __VERIFIER_assume(0);
  }
  ldv_32836: 
#line 1302 
  ;
  
#line 1303 
  return;
}


#line 1307  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_free_irq(unsigned int arg0, void *arg1)
{
  int ldv_3_line;
  
#line 1313 
  ldv_3_line = (int)arg0;
  
#line 1317 
  ldv_dispatch_irq_deregister_3_1(ldv_3_line);
  
#line 1321 
  goto return_label;
  return_label: 
#line 1323 
                return;
}


#line 1328  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pci_scenario_13(void *arg0)
{
  void *__retres;
  struct pci_dev *ldv_13_resource_1;
  struct pci_device_id *ldv_13_ldv_param_1_2;
  struct pm_message ldv_13_resource_0;
  int tmp_2;
  int tmp_3;
  
#line 1333 
  struct pci_driver *ldv_13_container = ldv_emg_alias_iwl_pci_driver_2;
  
#line 1334 
  int ldv_13_ret = ldv_undef_int();
  
#line 1337 
  struct ldv_struct_pci_scenario_13 *data = (struct ldv_struct_pci_scenario_13 *)arg0;
  
#line 1341 
  ldv_13_ret = ldv_undef_int();
  
#line 1344 
  if (data != (struct ldv_struct_pci_scenario_13 *)0) {
    
#line 1345 
    ldv_13_container = data->arg0;
    
#line 1346 
    ldv_free((void *)data);
  }
  else ;
  
#line 1357 
  goto ldv_main_13;
  
#line 1359 
  __retres = (void *)0;
  
#line 1359 
  goto return_label;
  ldv_main_13: 
#line 1362 
  ;
  
#line 1365 
  tmp_2 = ldv_undef_int();
  
#line 1365 
  if (tmp_2 != 0) {
    int tmp_1;
    
#line 1367 
    ldv_13_ldv_param_1_2 = (struct pci_device_id *)ldv_xmalloc_unknown_size(0UL);
    
#line 1372 
    ldv_pre_probe();
    
#line 1374 
    ldv_13_ret = ldv_emg_wrapper_iwl_pci_probe_2(ldv_13_resource_1,ldv_13_ldv_param_1_2);
    
#line 1376 
    ldv_13_ret = ldv_post_probe(ldv_13_ret);
    
#line 1380 
    ldv_free((void *)ldv_13_ldv_param_1_2);
    
#line 1383 
    tmp_1 = ldv_undef_int();
    
#line 1383 
    if (tmp_1 != 0) {
      
#line 1385 
      __VERIFIER_assume(ldv_13_ret == 0);
      
#line 1392 
      goto ldv_call_13;
    }
    else {
      
#line 1396 
      __VERIFIER_assume(ldv_13_ret != 0);
      
#line 1403 
      goto ldv_main_13;
    }
  }
  else {
    
#line 1415 
    __retres = (void *)0;
    
#line 1415 
    goto return_label;
  }
  
#line 1418 
  __retres = (void *)0;
  
#line 1418 
  goto return_label;
  ldv_call_13: 
#line 1421 
  ;
  
#line 1424 
  tmp_3 = ldv_undef_int();
  
#line 1424 
  switch (tmp_3) {
    case 1: 
#line 1425 
    ;
    
#line 1434 
    goto ldv_call_13;
    case 2: 
#line 1437 
    ;
    
#line 1439 
    if (ldv_13_container->suspend != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 1441 
      ldv_13_ret = (*(ldv_13_container->suspend))(ldv_13_resource_1,ldv_13_resource_0);
      
#line 1443 
      ldv_13_ret = ldv_filter_err_code(ldv_13_ret);
    }
    else 
#line 1445 
         ldv_13_ret = ldv_undef_int();
    
#line 1450 
    if (ldv_13_container->suspend_late != (int (*)(struct pci_dev *, pm_message_t ))0) {
      
#line 1452 
      ldv_13_ret = (*(ldv_13_container->suspend_late))(ldv_13_resource_1,ldv_13_resource_0);
      
#line 1454 
      ldv_13_ret = ldv_filter_err_code(ldv_13_ret);
    }
    else 
#line 1456 
         ldv_13_ret = ldv_undef_int();
    
#line 1461 
    if (ldv_13_container->resume_early != (int (*)(struct pci_dev *))0) 
      
#line 1463 
      (*(ldv_13_container->resume_early))(ldv_13_resource_1); else ;
    
#line 1468 
    if (ldv_13_container->resume != (int (*)(struct pci_dev *))0) 
#line 1470 
                                                                  (*(ldv_13_container->resume))(ldv_13_resource_1); else ;
    
#line 1478 
    goto ldv_call_13;
    case 3: 
#line 1481 
    ;
    
#line 1483 
    if (ldv_13_container->shutdown != (void (*)(struct pci_dev *))0) 
      
#line 1485 
      (*(ldv_13_container->shutdown))(ldv_13_resource_1); else ;
    
#line 1491 
    ldv_emg_wrapper_iwl_pci_remove_3(ldv_13_resource_1);
    
#line 1498 
    goto ldv_main_13;
    default: 
#line 1501 
    ;
    
#line 1501 
    __VERIFIER_assume(0);
  }
  
#line 1504 
  __retres = (void *)0;
  return_label: 
#line 1504 
                return __retres;
}


#line 1509  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0)
{
  
#line 1512 
  struct pci_driver *ldv_9_pci_driver = ldv_emg_alias_iwl_pci_driver_2;
  
#line 1515 
  ldv_9_pci_driver = arg0;
  
#line 1519 
  ldv_dispatch_deregister_9_1(ldv_9_pci_driver);
  
#line 1523 
  goto return_label;
  return_label: 
#line 1525 
                return;
}


#line 1530  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_timer_scenario_19(void *arg0)
{
  void *__retres;
  struct timer_list *ldv_19_container;
  
#line 1535 
  struct ldv_struct_timer_scenario_19 *data = (struct ldv_struct_timer_scenario_19 *)arg0;
  
#line 1540 
  if (data != (struct ldv_struct_timer_scenario_19 *)0) {
    
#line 1541 
    ldv_19_container = data->arg0;
    
#line 1542 
    ldv_free((void *)data);
  }
  else ;
  
#line 1547 
  if (ldv_19_container->function != (void (*)(unsigned long ))0) {
    
#line 1549 
    ldv_switch_to_interrupt_context();
    
#line 1551 
    (*(ldv_19_container->function))(ldv_19_container->data);
    
#line 1553 
    ldv_switch_to_process_context();
  }
  else ;
  
#line 1562 
  __retres = (void *)0;
  
#line 1562 
  goto return_label;
  
#line 1564 
  __retres = (void *)0;
  return_label: 
#line 1564 
                return __retres;
}


#line 1569  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_10_3(struct file_operations *arg0)
{
  int ret;
  struct ldv_struct_character_driver_scenario_11 *cf_arg_17;
  struct ldv_struct_character_driver_scenario_11 *cf_arg_18;
  struct ldv_struct_character_driver_scenario_11 *cf_arg_11;
  struct ldv_struct_character_driver_scenario_11 *cf_arg_12;
  struct ldv_struct_character_driver_scenario_11 *cf_arg_15;
  int tmp;
  
#line 1576 
  tmp = ldv_undef_int();
  
#line 1576 
  switch (tmp) {
    case 0: 
#line 1577 
    ;
    
#line 1578 
    cf_arg_17 = (struct ldv_struct_character_driver_scenario_11 *)ldv_xmalloc(16UL);
    
#line 1579 
    cf_arg_17->arg0 = arg0;
    
#line 1580 
    ret = pthread_create(& ldv_thread_17,(pthread_attr_t const *)0,& ldv_character_driver_scenario_17,(void *)cf_arg_17);
    
#line 1581 
    __VERIFIER_assume(ret == 0);
    
#line 1582 
    goto ldv_32877;
    case 1: 
#line 1584 
    ;
    
#line 1585 
    cf_arg_18 = (struct ldv_struct_character_driver_scenario_11 *)ldv_xmalloc(16UL);
    
#line 1586 
    cf_arg_18->arg0 = arg0;
    
#line 1587 
    ret = pthread_create(& ldv_thread_18,(pthread_attr_t const *)0,& ldv_character_driver_scenario_18,(void *)cf_arg_18);
    
#line 1588 
    __VERIFIER_assume(ret == 0);
    
#line 1589 
    goto ldv_32877;
    case 2: 
#line 1591 
    ;
    
#line 1592 
    cf_arg_11 = (struct ldv_struct_character_driver_scenario_11 *)ldv_xmalloc(16UL);
    
#line 1593 
    cf_arg_11->arg0 = arg0;
    
#line 1594 
    ret = pthread_create(& ldv_thread_11,(pthread_attr_t const *)0,& ldv_character_driver_scenario_11,(void *)cf_arg_11);
    
#line 1595 
    __VERIFIER_assume(ret == 0);
    
#line 1596 
    goto ldv_32877;
    case 3: 
#line 1598 
    ;
    
#line 1599 
    cf_arg_12 = (struct ldv_struct_character_driver_scenario_11 *)ldv_xmalloc(16UL);
    
#line 1600 
    cf_arg_12->arg0 = arg0;
    
#line 1601 
    ret = pthread_create(& ldv_thread_12,(pthread_attr_t const *)0,& ldv_character_driver_scenario_12,(void *)cf_arg_12);
    
#line 1602 
    __VERIFIER_assume(ret == 0);
    
#line 1603 
    goto ldv_32877;
    case 4: 
#line 1605 
    ;
    
#line 1606 
    cf_arg_15 = (struct ldv_struct_character_driver_scenario_11 *)ldv_xmalloc(16UL);
    
#line 1607 
    cf_arg_15->arg0 = arg0;
    
#line 1608 
    ret = pthread_create(& ldv_thread_15,(pthread_attr_t const *)0,& ldv_character_driver_scenario_15,(void *)cf_arg_15);
    
#line 1609 
    __VERIFIER_assume(ret == 0);
    
#line 1610 
    goto ldv_32877;
    default: 
#line 1612 
    ;
    
#line 1612 
    __VERIFIER_assume(0);
  }
  ldv_32877: 
#line 1613 
  ;
  
#line 1614 
  return;
}


#line 1618  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_initialization_1(void *arg0)
{
  void *__retres;
  int ldv_1_ret;
  int tmp;
  
#line 1625 
  ldv_1_ret = ldv_emg_iwl_drv_init();
  
#line 1626 
  ldv_1_ret = ldv_post_init(ldv_1_ret);
  
#line 1629 
  tmp = ldv_undef_int();
  
#line 1629 
  if (tmp != 0) {
    
#line 1631 
    __VERIFIER_assume(ldv_1_ret != 0);
    
#line 1635 
    __retres = (void *)0;
    
#line 1635 
    goto return_label;
  }
  else {
    
#line 1639 
    __VERIFIER_assume(ldv_1_ret == 0);
    
#line 1644 
    ldv_emg_iwl_drv_exit();
    
#line 1648 
    __retres = (void *)0;
    
#line 1648 
    goto return_label;
  }
  
#line 1651 
  __retres = (void *)0;
  return_label: 
#line 1651 
                return __retres;
}


#line 1656  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_pm_ops_scenario_16(void *arg0)
{
  void *__retres;
  struct device *ldv_16_device;
  int tmp;
  
#line 1659 
  struct dev_pm_ops *ldv_16_pm_ops = ldv_emg_alias_iwl_dev_pm_ops_3;
  
#line 1670 
  goto ldv_do_16;
  
#line 1672 
  __retres = (void *)0;
  
#line 1672 
  goto return_label;
  ldv_do_16: 
#line 1675 
  ;
  
#line 1678 
  tmp = ldv_undef_int();
  
#line 1678 
  switch (tmp) {
    int tmp_0;
    case 1: 
#line 1679 
    ;
    
#line 1681 
    if (ldv_16_pm_ops->runtime_idle != (int (*)(struct device *))0) 
#line 1683 
                                                                    (*(ldv_16_pm_ops->runtime_idle))(ldv_16_device); else ;
    
#line 1691 
    goto ldv_do_16;
    case 2: 
#line 1694 
    ;
    
#line 1696 
    if (ldv_16_pm_ops->runtime_suspend != (int (*)(struct device *))0) 
      
#line 1698 
      (*(ldv_16_pm_ops->runtime_suspend))(ldv_16_device); else ;
    
#line 1703 
    if (ldv_16_pm_ops->runtime_resume != (int (*)(struct device *))0) 
      
#line 1705 
      (*(ldv_16_pm_ops->runtime_resume))(ldv_16_device); else ;
    
#line 1713 
    goto ldv_do_16;
    case 3: 
#line 1716 
    ;
    
#line 1718 
    if (ldv_16_pm_ops->prepare != (int (*)(struct device *))0) 
#line 1720 
                                                               (*(ldv_16_pm_ops->prepare))(ldv_16_device); else ;
    
#line 1724 
    tmp_0 = ldv_undef_int();
    
#line 1724 
    switch (tmp_0) {
      int tmp_1;
      int tmp_2;
      int tmp_3;
      case 1: 
#line 1725 
      ;
      
#line 1728 
      ldv_emg_wrapper_iwl_pci_suspend_2(ldv_16_device);
      
#line 1731 
      tmp_1 = ldv_undef_int();
      
#line 1731 
      if (tmp_1 != 0) {
        
#line 1733 
        if (ldv_16_pm_ops->suspend_noirq != (int (*)(struct device *))0) 
          
#line 1735 
          (*(ldv_16_pm_ops->suspend_noirq))(ldv_16_device); else ;
        
#line 1740 
        if (ldv_16_pm_ops->resume_noirq != (int (*)(struct device *))0) 
          
#line 1742 
          (*(ldv_16_pm_ops->resume_noirq))(ldv_16_device); else ;
      }
      else {
        
#line 1749 
        if (ldv_16_pm_ops->suspend_late != (int (*)(struct device *))0) 
          
#line 1751 
          (*(ldv_16_pm_ops->suspend_late))(ldv_16_device); else ;
        
#line 1756 
        if (ldv_16_pm_ops->resume_early != (int (*)(struct device *))0) 
          
#line 1758 
          (*(ldv_16_pm_ops->resume_early))(ldv_16_device); else ;
      }
      
#line 1765 
      ldv_emg_wrapper_iwl_pci_resume_4(ldv_16_device);
      
#line 1768 
      goto ldv_32897;
      case 2: 
#line 1770 
      ;
      
#line 1773 
      ldv_emg_wrapper_iwl_pci_suspend_2(ldv_16_device);
      
#line 1776 
      tmp_2 = ldv_undef_int();
      
#line 1776 
      if (tmp_2 != 0) {
        
#line 1778 
        if (ldv_16_pm_ops->freeze_late != (int (*)(struct device *))0) 
          
#line 1780 
          (*(ldv_16_pm_ops->freeze_late))(ldv_16_device); else ;
        
#line 1785 
        if (ldv_16_pm_ops->thaw_early != (int (*)(struct device *))0) 
          
#line 1787 
          (*(ldv_16_pm_ops->thaw_early))(ldv_16_device); else ;
      }
      else {
        
#line 1794 
        if (ldv_16_pm_ops->freeze_noirq != (int (*)(struct device *))0) 
          
#line 1796 
          (*(ldv_16_pm_ops->freeze_noirq))(ldv_16_device); else ;
        
#line 1801 
        if (ldv_16_pm_ops->thaw_noirq != (int (*)(struct device *))0) 
          
#line 1803 
          (*(ldv_16_pm_ops->thaw_noirq))(ldv_16_device); else ;
      }
      
#line 1810 
      ldv_emg_wrapper_iwl_pci_resume_4(ldv_16_device);
      
#line 1813 
      goto ldv_32897;
      case 3: 
#line 1815 
      ;
      
#line 1818 
      ldv_emg_wrapper_iwl_pci_suspend_2(ldv_16_device);
      
#line 1821 
      tmp_3 = ldv_undef_int();
      
#line 1821 
      if (tmp_3 != 0) {
        
#line 1823 
        if (ldv_16_pm_ops->poweroff_late != (int (*)(struct device *))0) 
          
#line 1825 
          (*(ldv_16_pm_ops->poweroff_late))(ldv_16_device); else ;
        
#line 1830 
        if (ldv_16_pm_ops->restore_early != (int (*)(struct device *))0) 
          
#line 1832 
          (*(ldv_16_pm_ops->restore_early))(ldv_16_device); else ;
      }
      else {
        
#line 1839 
        if (ldv_16_pm_ops->poweroff_noirq != (int (*)(struct device *))0) 
          
#line 1841 
          (*(ldv_16_pm_ops->poweroff_noirq))(ldv_16_device); else ;
        
#line 1846 
        if (ldv_16_pm_ops->restore_noirq != (int (*)(struct device *))0) 
          
#line 1848 
          (*(ldv_16_pm_ops->restore_noirq))(ldv_16_device); else ;
      }
      
#line 1855 
      ldv_emg_wrapper_iwl_pci_resume_4(ldv_16_device);
      
#line 1858 
      goto ldv_32897;
      default: 
#line 1860 
      ;
      
#line 1860 
      __VERIFIER_assume(0);
    }
    ldv_32897: 
#line 1863 
    ;
    
#line 1863 
    if (ldv_16_pm_ops->complete != (void (*)(struct device *))0) 
#line 1865 
                                                                 (*(ldv_16_pm_ops->complete))(ldv_16_device); else ;
    
#line 1873 
    goto ldv_do_16;
    case 4: 
#line 1876 
    ;
    
#line 1882 
    __retres = (void *)0;
    
#line 1882 
    goto return_label;
    default: 
#line 1885 
    ;
    
#line 1885 
    __VERIFIER_assume(0);
  }
  
#line 1888 
  __retres = (void *)0;
  return_label: 
#line 1888 
                return __retres;
}


#line 1893  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_instance_register_4_3(struct timer_list *arg0)
{
  int ret;
  struct ldv_struct_timer_scenario_19 *cf_arg_19;
  int tmp;
  
#line 1896 
  tmp = ldv_undef_int();
  
#line 1896 
  switch (tmp) {
    case 0: 
#line 1897 
    ;
    
#line 1898 
    cf_arg_19 = (struct ldv_struct_timer_scenario_19 *)ldv_xmalloc(16UL);
    
#line 1899 
    cf_arg_19->arg0 = arg0;
    
#line 1900 
    ret = pthread_create(& ldv_thread_19,(pthread_attr_t const *)0,& ldv_timer_scenario_19,(void *)cf_arg_19);
    
#line 1901 
    __VERIFIER_assume(ret == 0);
    
#line 1902 
    goto ldv_32909;
    default: 
#line 1904 
    ;
    
#line 1904 
    __VERIFIER_assume(0);
  }
  ldv_32909: 
#line 1905 
  ;
  
#line 1906 
  return;
}


#line 1910  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void ldv_dispatch_register_6_3(struct pci_driver *arg0)
{
  int ret;
  struct ldv_struct_pci_scenario_13 *cf_arg_13;
  int tmp;
  
#line 1913 
  tmp = ldv_undef_int();
  
#line 1913 
  switch (tmp) {
    case 0: 
#line 1914 
    ;
    
#line 1915 
    cf_arg_13 = (struct ldv_struct_pci_scenario_13 *)ldv_xmalloc(16UL);
    
#line 1916 
    cf_arg_13->arg0 = arg0;
    
#line 1917 
    ret = pthread_create(& ldv_thread_13,(pthread_attr_t const *)0,& ldv_pci_scenario_13,(void *)cf_arg_13);
    
#line 1918 
    __VERIFIER_assume(ret == 0);
    
#line 1919 
    goto ldv_32917;
    default: 
#line 1921 
    ;
    
#line 1921 
    __VERIFIER_assume(0);
  }
  ldv_32917: 
#line 1922 
  ;
  
#line 1923 
  return;
}


#line 1927  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
void *ldv_interrupt_scenario_14(void *arg0)
{
  void *__retres;
  enum irqreturn ldv_14_ret_val;
  int ldv_14_line;
  void *ldv_14_data;
  int tmp;
  
#line 1933 
  enum irqreturn (*ldv_14_callback)(int , void *) = & iwl_pcie_isr;
  
#line 1934 
  enum irqreturn (*ldv_14_thread)(int , void *) = & iwl_pcie_irq_handler;
  
#line 1936 
  struct ldv_struct_interrupt_scenario_14 *data = (struct ldv_struct_interrupt_scenario_14 *)arg0;
  
#line 1941 
  if (data != (struct ldv_struct_interrupt_scenario_14 *)0) {
    
#line 1942 
    ldv_14_line = data->arg0;
    
#line 1943 
    ldv_14_callback = data->arg1;
    
#line 1944 
    ldv_14_thread = data->arg2;
    
#line 1945 
    ldv_14_data = data->arg3;
    
#line 1946 
    ldv_free((void *)data);
  }
  else ;
  
#line 1952 
  ldv_switch_to_interrupt_context();
  
#line 1954 
  ldv_14_ret_val = iwl_pcie_isr(ldv_14_line,ldv_14_data);
  
#line 1956 
  ldv_switch_to_process_context();
  
#line 1959 
  tmp = ldv_undef_int();
  
#line 1959 
  if (tmp != 0) {
    
#line 1961 
    __VERIFIER_assume(ldv_14_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    
#line 1966 
    iwl_pcie_irq_handler(ldv_14_line,ldv_14_data);
  }
  else 
#line 1972 
       __VERIFIER_assume(ldv_14_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  
#line 1981 
  __retres = (void *)0;
  
#line 1981 
  goto return_label;
  
#line 1983 
  __retres = (void *)0;
  return_label: 
#line 1983 
                return __retres;
}


#line 1988  "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/91e514eede894122cca4a9df4375a888/klever-core-work-dir/job/vtg/drivers/net/wireless/iwlwifi/iwlwifi.ko/linux:concurrency safety/emg/environment_model.c"
int ldv_emg_mod_timer(struct timer_list *arg0, unsigned long arg1)
{
  int __retres;
  struct timer_list *ldv_4_timer_list;
  int tmp_0;
  
#line 1995 
  tmp_0 = ldv_undef_int();
  
#line 1995 
  if (tmp_0 != 0) {
    
#line 1997 
    ldv_4_timer_list = arg0;
    
#line 2001 
    ldv_dispatch_instance_register_4_3(ldv_4_timer_list);
    
#line 2005 
    __retres = 0;
    
#line 2005 
    goto return_label;
  }
  else {
    int tmp;
    
#line 2012 
    tmp = ldv_undef_int_negative();
    
#line 2012 
    __retres = tmp;
    
#line 2012 
    goto return_label;
  }
  return_label: 
#line 1995 
                return __retres;
}


